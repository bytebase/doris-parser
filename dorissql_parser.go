// Code generated from DorisSQL.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // DorisSQL
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type DorisSQLParser struct {
	*antlr.BaseParser
}

var DorisSQLParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func dorissqlParserInit() {
	staticData := &DorisSQLParserStaticData
	staticData.LiteralNames = []string{
		"", "'.'", "'('", "','", "')'", "'=>'", "'['", "']'", "':'", "'{'",
		"'}'", "'ACCESS'", "'ACTIVE'", "'ADD'", "'ADMIN'", "'ADVISOR'", "'AFTER'",
		"'AGGREGATE'", "'ALL'", "'ALTER'", "'ANALYZE'", "'AND'", "'ANTI'", "'APPLY'",
		"'ARRAY'", "'ARRAY_AGG'", "'ARRAY_AGG_DISTINCT'", "'AS'", "'ASC'", "'ASYNC'",
		"'AUTHORS'", "'AUTHENTICATION'", "'AUTOMATED'", "'AUTO_INCREMENT'",
		"'AVG'", "'BACKEND'", "'BACKENDS'", "'BACKUP'", "'BASE'", "'BASELINE'",
		"'BEGIN'", "'BETWEEN'", "'BIGINT'", "'BINARY'", "'BITMAP'", "'BITMAP_UNION'",
		"'BLACKHOLE'", "'BLACKLIST'", "'BODY'", "'BOOLEAN'", "'BOTH'", "'BRANCH'",
		"'BROKER'", "'BUCKETS'", "'BUILTIN'", "'BY'", "'CACHE'", "'CANCEL'",
		"'CASE'", "'CAST'", "'CATALOG'", "'CATALOGS'", "'CEIL'", "'CHAIN'",
		"'CHAR'", "'CHARACTER'", "'CHARSET'", "'CHECK'", "'CLEAN'", "'CLEAR'",
		"'CLUSTER'", "'CLUSTERS'", "'CNGROUP'", "'CNGROUPS'", "'COLLATE'", "'COLLATION'",
		"'COLUMN'", "'COLUMNS'", "'COMMENT'", "'COMMIT'", "'COMMITTED'", "'COMPACT'",
		"'COMPACTION'", "'COMPUTE'", "'CONFIG'", "'CONNECTION'", "'CONSISTENT'",
		"'CONVERT'", "'COSTS'", "'COUNT'", "'CREATE'", "'CROSS'", "'CUBE'",
		"'CUME_DIST'", "'CUMULATIVE'", "'CURRENT'", "'CURRENT_DATE'", "'CURRENT_GROUP'",
		"'CURRENT_ROLE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'CURRENT_USER'",
		"'DATA'", "'DATACACHE'", "'DATABASE'", "'DATABASES'", "'DATE'", "'DATETIME'",
		"'DAY'", "'DAYS'", "'DEALLOCATE'", "'DECIMAL'", "'DECIMALV2'", "'DECIMAL32'",
		"'DECIMAL64'", "'DECIMAL128'", "'DECOMMISSION'", "'DEFAULT'", "'DELETE'",
		"'DENSE_RANK'", "'DEFERRED'", "'DIALECT'", "'DICTIONARY'", "'DICTIONARY_GET'",
		"'NTILE'", "'DESC'", "'DESCRIBE'", "'DISABLE'", "'DISTINCT'", "'DISTRIBUTED'",
		"'DISTRIBUTION'", "'DOUBLE'", "'DROP'", "'DUAL'", "'DUPLICATE'", "'DYNAMIC'",
		"'ELSE'", "'ENABLE'", "'ENCLOSE'", "'END'", "'ENGINE'", "'ENGINES'",
		"'ERRORS'", "'ESCAPE'", "'EVENTS'", "'EXCEPT'", "'EXCLUDE'", "'EXECUTE'",
		"'EXISTS'", "'EXPLAIN'", "'EXPORT'", "'EXTERNAL'", "'EXTRACT'", "'EVERY'",
		"'FAILPOINT'", "'FAILPOINTS'", "'FALSE'", "'FIELDS'", "'FILE'", "'FILES'",
		"'FILTER'", "'FIRST'", "'FIRST_VALUE'", "'FLOAT'", "'FLOOR'", "'FN'",
		"'FOLLOWING'", "'FOLLOWER'", "'FOR'", "'FORCE'", "'FORMAT'", "'FREE'",
		"'FROM'", "'FRONTEND'", "'FRONTENDS'", "'FULL'", "'FUNCTION'", "'FUNCTIONS'",
		"'GLOBAL'", "'GRANT'", "'GRANTS'", "'GROUP'", "'GROUPS'", "'GROUPING'",
		"'GROUPING_ID'", "'GROUP_CONCAT'", "'HASH'", "'HAVING'", "'HELP'", "'HISTOGRAM'",
		"'HLL'", "'HLL_UNION'", "'HOST'", "'HOUR'", "'HOURS'", "'HUB'", "'IDENTIFIED'",
		"'IF'", "'IMPERSONATE'", "'IMMEDIATE'", "'IGNORE'", "'IMAGE'", "'IN'",
		"'INACTIVE'", "'INCREMENTAL'", "'INDEX'", "'INDEXES'", "'INFILE'", "'INNER'",
		"'INSTALL'", "'INSERT'", "'INT'", "'INTEGER'", "'INTEGRATION'", "'INTEGRATIONS'",
		"'INTERMEDIATE'", "'INTERSECT'", "'INTERVAL'", "'INTO'", "'INVOKER'",
		"'GIN'", "'OVERWRITE'", "'IS'", "'ISOLATION'", "'JOB'", "'JOIN'", "'JSON'",
		"'KEY'", "'KEYS'", "'KILL'", "'LABEL'", "'LAG'", "'LARGEINT'", "'LAST'",
		"'LAST_VALUE'", "'LATERAL'", "'LEAD'", "'LEFT'", "'LESS'", "'LEVEL'",
		"'LIKE'", "'LIMIT'", "'LIST'", "'LOAD'", "'LOCAL'", "'LOCALTIME'", "'LOCALTIMESTAMP'",
		"'LOCATION'", "'LOCATIONS'", "'LOGS'", "'LOGICAL'", "'MANUAL'", "'MAP'",
		"'MAPPING'", "'MAPPINGS'", "'MASKING'", "'MATCH'", "'MATERIALIZED'",
		"'MAX'", "'MAXVALUE'", "'MERGE'", "'MICROSECOND'", "'MILLISECOND'",
		"'MIN'", "'MINUTE'", "'MINUTES'", "'MINUS'", "'META'", "'MOD'", "'MODE'",
		"'MODIFY'", "'MONTH'", "'MULTIPLE'", "'NAME'", "'NAMES'", "'NEGATIVE'",
		"'NGRAMBF'", "'NO'", "'NODE'", "'NODES'", "'NONE'", "'NOT'", "'NULL'",
		"'NULLS'", "'NUMBER'", "'NUMERIC'", "'OBSERVER'", "'OF'", "'OFF'", "'OFFSET'",
		"'ON'", "'ONLY'", "'OPEN'", "'OPERATE'", "'OPTIMIZE'", "'OPTIMIZER'",
		"'OPTION'", "'OR'", "'ORDER'", "'OUTER'", "'OUTFILE'", "'OVER'", "'?'",
		"'PARTITION'", "'PARTITIONS'", "'PASSWORD'", "'PATH'", "'PAUSE'", "'PENDING'",
		"'PERCENT_RANK'", "'PERCENTILE'", "'PERCENTILE_UNION'", "'PLAN'", "'PLUGIN'",
		"'PLUGINS'", "'PIPE'", "'PIPES'", "'PIVOT'", "'POLICY'", "'POLICIES'",
		"'PRECEDING'", "'PREDICATE'", "'PREPARE'", "'PRIMARY'", "'PRIORITY'",
		"'PRIVILEGES'", "'PROBABILITY'", "'PROC'", "'PROCEDURE'", "'PROCESSLIST'",
		"'PROFILE'", "'PROFILELIST'", "'PROPERTIES'", "'PROPERTY'", "'PROVIDER'",
		"'PROVIDERS'", "'QUALIFY'", "'QUARTER'", "'QUERY'", "'QUERIES'", "'QUEUE'",
		"'QUOTA'", "'RANDOM'", "'RANGE'", "'RANK'", "'READ'", "'REASON'", "'RECOVER'",
		"'REFRESH'", "'REWRITE'", "'REGEXP'", "'RELEASE'", "'REMOVE'", "'RENAME'",
		"'REPAIR'", "'REPEATABLE'", "'REPLACE'", "'REPLACE_IF_NOT_NULL'", "'REPLICA'",
		"'REPOSITORY'", "'REPOSITORIES'", "'RESOURCE'", "'RESOURCES'", "'RESTORE'",
		"'RESUME'", "'RETAIN'", "'RETENTION'", "'RETURNS'", "'RETRY'", "'REVOKE'",
		"'REVERT'", "'RIGHT'", "'RLIKE'", "'ROLE'", "'ROLES'", "'ROLLBACK'",
		"'ROLLUP'", "'ROUTINE'", "'ROW'", "'ROWS'", "'ROW_NUMBER'", "'RULE'",
		"'RULES'", "'RUNNING'", "'SAMPLE'", "'SCHEDULE'", "'SCHEDULER'", "'SCHEMA'",
		"'SCHEMAS'", "'SECOND'", "'SECURITY'", "'SELECT'", "'SEMI'", "'SEPARATOR'",
		"'SERIALIZABLE'", "'SESSION'", "'SET'", "'SETS'", "'SET_VAR'", "'SIGNED'",
		"'SKIP_HEADER'", "'SHOW'", "'SMALLINT'", "'SNAPSHOT'", "'SNAPSHOTS'",
		"'SQLBLACKLIST'", "'START'", "'STATS'", "'STATUS'", "'STOP'", "'STORAGE'",
		"'STREAM'", "'STRING'", "'TEXT'", "'SUBMIT'", "'SUM'", "'SUSPEND'",
		"'SYNC'", "'SYSTEM'", "'SYSTEM_TIME'", "'SWAP'", "'STRUCT'", "'TABLE'",
		"'TABLES'", "'TABLET'", "'TABLETS'", "'TAG'", "'TASK'", "'TEMPORARY'",
		"'TERMINATED'", "'THAN'", "'THEN'", "'TIME'", "'TIMES'", "'TIMESTAMP'",
		"'TIMESTAMPADD'", "'TIMESTAMPDIFF'", "'TINYINT'", "'TRANSACTION'", "'TRANSLATE'",
		"'TO'", "'TRACE'", "'TRIGGERS'", "'TRIM_SPACE'", "'TRUE'", "'TRUNCATE'",
		"'TYPE'", "'TYPES'", "'UNBOUNDED'", "'UNCOMMITTED'", "'UNION'", "'UNIQUE'",
		"'UNINSTALL'", "'UNSET'", "'UNSIGNED'", "'UPDATE'", "'USAGE'", "'USE'",
		"'USER'", "'USERS'", "'USING'", "'VALUE'", "'VALUES'", "'VARBINARY'",
		"'VARCHAR'", "'VARIABLES'", "'VECTOR'", "'VERBOSE'", "'VERSION'", "'VIEW'",
		"'VIEWS'", "'VOLUME'", "'VOLUMES'", "'WAREHOUSE'", "'WAREHOUSES'", "'WARNINGS'",
		"'WEEK'", "'WHEN'", "'WHERE'", "'WHITELIST'", "'WITH'", "'WORK'", "'WRITE'",
		"'YEAR'", "'LOCK'", "'UNLOCK'", "'LOW_PRIORITY'", "'DISK'", "'BEFORE'",
		"'$$'", "'FIELD'", "'PERSISTENT'", "'='", "", "'<'", "'<='", "'>'",
		"'>='", "'<=>'", "'[*]'", "'+'", "'-'", "'*'", "'/'", "'%'", "'||'",
		"'&&'", "'!'", "'DIV'", "'&'", "'|'", "'^'", "'~'", "'BITSHIFTLEFT'",
		"'BITSHIFTRIGHT'", "'BITSHIFTRIGHTLOGICAL'", "'->'", "'@'", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "';'", "'...'",
	}
	staticData.SymbolicNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "ACCESS", "ACTIVE", "ADD",
		"ADMIN", "ADVISOR", "AFTER", "AGGREGATE", "ALL", "ALTER", "ANALYZE",
		"AND", "ANTI", "APPLY", "ARRAY", "ARRAY_AGG", "ARRAY_AGG_DISTINCT",
		"AS", "ASC", "ASYNC", "AUTHORS", "AUTHENTICATION", "AUTOMATED", "AUTO_INCREMENT",
		"AVG", "BACKEND", "BACKENDS", "BACKUP", "BASE", "BASELINE", "BEGIN",
		"BETWEEN", "BIGINT", "BINARY", "BITMAP", "BITMAP_UNION", "BLACKHOLE",
		"BLACKLIST", "BODY", "BOOLEAN", "BOTH", "BRANCH", "BROKER", "BUCKETS",
		"BUILTIN", "BY", "CACHE", "CANCEL", "CASE", "CAST", "CATALOG", "CATALOGS",
		"CEIL", "CHAIN", "CHAR", "CHARACTER", "CHARSET", "CHECK", "CLEAN", "CLEAR",
		"CLUSTER", "CLUSTERS", "CNGROUP", "CNGROUPS", "COLLATE", "COLLATION",
		"COLUMN", "COLUMNS", "COMMENT", "COMMIT", "COMMITTED", "COMPACT", "COMPACTION",
		"COMPUTE", "CONFIG", "CONNECTION", "CONSISTENT", "CONVERT", "COSTS",
		"COUNT", "CREATE", "CROSS", "CUBE", "CUME_DIST", "CUMULATIVE", "CURRENT",
		"CURRENT_DATE", "CURRENT_GROUP", "CURRENT_ROLE", "CURRENT_TIME", "CURRENT_TIMESTAMP",
		"CURRENT_USER", "DATA", "DATACACHE", "DATABASE", "DATABASES", "DATE",
		"DATETIME", "DAY", "DAYS", "DEALLOCATE", "DECIMAL", "DECIMALV2", "DECIMAL32",
		"DECIMAL64", "DECIMAL128", "DECOMMISSION", "DEFAULT", "DELETE", "DENSE_RANK",
		"DEFERRED", "DIALECT", "DICTIONARY", "DICTIONARY_GET", "NTILE", "DESC",
		"DESCRIBE", "DISABLE", "DISTINCT", "DISTRIBUTED", "DISTRIBUTION", "DOUBLE",
		"DROP", "DUAL", "DUPLICATE", "DYNAMIC", "ELSE", "ENABLE", "ENCLOSE",
		"END", "ENGINE", "ENGINES", "ERRORS", "ESCAPE", "EVENTS", "EXCEPT",
		"EXCLUDE", "EXECUTE", "EXISTS", "EXPLAIN", "EXPORT", "EXTERNAL", "EXTRACT",
		"EVERY", "FAILPOINT", "FAILPOINTS", "FALSE", "FIELDS", "FILE", "FILES",
		"FILTER", "FIRST", "FIRST_VALUE", "FLOAT", "FLOOR", "FN", "FOLLOWING",
		"FOLLOWER", "FOR", "FORCE", "FORMAT", "FREE", "FROM", "FRONTEND", "FRONTENDS",
		"FULL", "FUNCTION", "FUNCTIONS", "GLOBAL", "GRANT", "GRANTS", "GROUP",
		"GROUPS", "GROUPING", "GROUPING_ID", "GROUP_CONCAT", "HASH", "HAVING",
		"HELP", "HISTOGRAM", "HLL", "HLL_UNION", "HOST", "HOUR", "HOURS", "HUB",
		"IDENTIFIED", "IF", "IMPERSONATE", "IMMEDIATE", "IGNORE", "IMAGE", "IN",
		"INACTIVE", "INCREMENTAL", "INDEX", "INDEXES", "INFILE", "INNER", "INSTALL",
		"INSERT", "INT", "INTEGER", "INTEGRATION", "INTEGRATIONS", "INTERMEDIATE",
		"INTERSECT", "INTERVAL", "INTO", "INVOKER", "GIN", "OVERWRITE", "IS",
		"ISOLATION", "JOB", "JOIN", "JSON", "KEY", "KEYS", "KILL", "LABEL",
		"LAG", "LARGEINT", "LAST", "LAST_VALUE", "LATERAL", "LEAD", "LEFT",
		"LESS", "LEVEL", "LIKE", "LIMIT", "LIST", "LOAD", "LOCAL", "LOCALTIME",
		"LOCALTIMESTAMP", "LOCATION", "LOCATIONS", "LOGS", "LOGICAL", "MANUAL",
		"MAP", "MAPPING", "MAPPINGS", "MASKING", "MATCH", "MATERIALIZED", "MAX",
		"MAXVALUE", "MERGE", "MICROSECOND", "MILLISECOND", "MIN", "MINUTE",
		"MINUTES", "MINUS", "META", "MOD", "MODE", "MODIFY", "MONTH", "MULTIPLE",
		"NAME", "NAMES", "NEGATIVE", "NGRAMBF", "NO", "NODE", "NODES", "NONE",
		"NOT", "NULL", "NULLS", "NUMBER", "NUMERIC", "OBSERVER", "OF", "OFF",
		"OFFSET", "ON", "ONLY", "OPEN", "OPERATE", "OPTIMIZE", "OPTIMIZER",
		"OPTION", "OR", "ORDER", "OUTER", "OUTFILE", "OVER", "PARAMETER", "PARTITION",
		"PARTITIONS", "PASSWORD", "PATH", "PAUSE", "PENDING", "PERCENT_RANK",
		"PERCENTILE", "PERCENTILE_UNION", "PLAN", "PLUGIN", "PLUGINS", "PIPE",
		"PIPES", "PIVOT", "POLICY", "POLICIES", "PRECEDING", "PREDICATE", "PREPARE",
		"PRIMARY", "PRIORITY", "PRIVILEGES", "PROBABILITY", "PROC", "PROCEDURE",
		"PROCESSLIST", "PROFILE", "PROFILELIST", "PROPERTIES", "PROPERTY", "PROVIDER",
		"PROVIDERS", "QUALIFY", "QUARTER", "QUERY", "QUERIES", "QUEUE", "QUOTA",
		"RANDOM", "RANGE", "RANK", "READ", "REASON", "RECOVER", "REFRESH", "REWRITE",
		"REGEXP", "RELEASE", "REMOVE", "RENAME", "REPAIR", "REPEATABLE", "REPLACE",
		"REPLACE_IF_NOT_NULL", "REPLICA", "REPOSITORY", "REPOSITORIES", "RESOURCE",
		"RESOURCES", "RESTORE", "RESUME", "RETAIN", "RETENTION", "RETURNS",
		"RETRY", "REVOKE", "REVERT", "RIGHT", "RLIKE", "ROLE", "ROLES", "ROLLBACK",
		"ROLLUP", "ROUTINE", "ROW", "ROWS", "ROW_NUMBER", "RULE", "RULES", "RUNNING",
		"SAMPLE", "SCHEDULE", "SCHEDULER", "SCHEMA", "SCHEMAS", "SECOND", "SECURITY",
		"SELECT", "SEMI", "SEPARATOR", "SERIALIZABLE", "SESSION", "SET", "SETS",
		"SET_VAR", "SIGNED", "SKIP_HEADER", "SHOW", "SMALLINT", "SNAPSHOT",
		"SNAPSHOTS", "SQLBLACKLIST", "START", "STATS", "STATUS", "STOP", "STORAGE",
		"STREAM", "STRING", "TEXT", "SUBMIT", "SUM", "SUSPEND", "SYNC", "SYSTEM",
		"SYSTEM_TIME", "SWAP", "STRUCT", "TABLE", "TABLES", "TABLET", "TABLETS",
		"TAG", "TASK", "TEMPORARY", "TERMINATED", "THAN", "THEN", "TIME", "TIMES",
		"TIMESTAMP", "TIMESTAMPADD", "TIMESTAMPDIFF", "TINYINT", "TRANSACTION",
		"TRANSLATE", "TO", "TRACE", "TRIGGERS", "TRIM_SPACE", "TRUE", "TRUNCATE",
		"TYPE", "TYPES", "UNBOUNDED", "UNCOMMITTED", "UNION", "UNIQUE", "UNINSTALL",
		"UNSET", "UNSIGNED", "UPDATE", "USAGE", "USE", "USER", "USERS", "USING",
		"VALUE", "VALUES", "VARBINARY", "VARCHAR", "VARIABLES", "VECTOR", "VERBOSE",
		"VERSION", "VIEW", "VIEWS", "VOLUME", "VOLUMES", "WAREHOUSE", "WAREHOUSES",
		"WARNINGS", "WEEK", "WHEN", "WHERE", "WHITELIST", "WITH", "WORK", "WRITE",
		"YEAR", "LOCK", "UNLOCK", "LOW_PRIORITY", "DISK", "BEFORE", "DOUBLE_DOLLAR",
		"FIELD", "PERSISTENT", "EQ", "NEQ", "LT", "LTE", "GT", "GTE", "EQ_FOR_NULL",
		"ARRAY_ELEMENT", "PLUS_SYMBOL", "MINUS_SYMBOL", "ASTERISK_SYMBOL", "SLASH_SYMBOL",
		"PERCENT_SYMBOL", "LOGICAL_OR", "LOGICAL_AND", "LOGICAL_NOT", "INT_DIV",
		"BITAND", "BITOR", "BITXOR", "BITNOT", "BIT_SHIFT_LEFT", "BIT_SHIFT_RIGHT",
		"BIT_SHIFT_RIGHT_LOGICAL", "ARROW", "AT", "INTEGER_VALUE", "DECIMAL_VALUE",
		"DOUBLE_VALUE", "SINGLE_QUOTED_TEXT", "DOUBLE_QUOTED_TEXT", "BINARY_SINGLE_QUOTED_TEXT",
		"BINARY_DOUBLE_QUOTED_TEXT", "LETTER_IDENTIFIER", "DIGIT_IDENTIFIER",
		"BACKQUOTED_IDENTIFIER", "DOT_IDENTIFIER", "SIMPLE_COMMENT", "BRACKETED_COMMENT",
		"OPTIMIZER_HINT", "SEMICOLON", "DOTDOTDOT", "WS", "ATTACHMENT", "CONCAT",
	}
	staticData.RuleNames = []string{
		"sqlStatements", "singleStatement", "emptyStatement", "statement", "useDatabaseStatement",
		"useCatalogStatement", "setCatalogStatement", "showDatabasesStatement",
		"alterDbQuotaStatement", "createDbStatement", "dropDbStatement", "showCreateDbStatement",
		"alterDatabaseRenameStatement", "recoverDbStmt", "showDataStmt", "showDataDistributionStmt",
		"createTableStatement", "columnDesc", "charsetName", "defaultDesc",
		"generatedColumnDesc", "indexDesc", "engineDesc", "charsetDesc", "collateDesc",
		"keyDesc", "orderByDesc", "columnNullable", "typeWithNullable", "aggStateDesc",
		"aggDesc", "rollupDesc", "rollupItem", "dupKeys", "fromRollup", "orReplace",
		"ifNotExists", "createTableAsSelectStatement", "dropTableStatement",
		"cleanTemporaryTableStatement", "alterTableStatement", "createIndexStatement",
		"dropIndexStatement", "indexType", "showTableStatement", "showTemporaryTablesStatement",
		"showCreateTableStatement", "showColumnStatement", "showTableStatusStatement",
		"refreshTableStatement", "showAlterStatement", "descTableStatement",
		"createTableLikeStatement", "showIndexStatement", "recoverTableStatement",
		"truncateTableStatement", "cancelAlterTableStatement", "showPartitionsStatement",
		"recoverPartitionStatement", "createViewStatement", "alterViewStatement",
		"dropViewStatement", "columnNameWithComment", "submitTaskStatement",
		"taskClause", "dropTaskStatement", "taskScheduleDesc", "createMaterializedViewStatement",
		"mvPartitionExprs", "materializedViewDesc", "showMaterializedViewsStatement",
		"dropMaterializedViewStatement", "alterMaterializedViewStatement", "refreshMaterializedViewStatement",
		"cancelRefreshMaterializedViewStatement", "adminSetConfigStatement",
		"adminSetReplicaStatusStatement", "adminShowConfigStatement", "adminShowReplicaDistributionStatement",
		"adminShowReplicaStatusStatement", "adminRepairTableStatement", "adminCancelRepairTableStatement",
		"adminCheckTabletsStatement", "adminSetPartitionVersion", "killStatement",
		"syncStatement", "adminSetAutomatedSnapshotOnStatement", "adminSetAutomatedSnapshotOffStatement",
		"alterSystemStatement", "cancelAlterSystemStatement", "showComputeNodesStatement",
		"createExternalCatalogStatement", "showCreateExternalCatalogStatement",
		"dropExternalCatalogStatement", "showCatalogsStatement", "alterCatalogStatement",
		"createStorageVolumeStatement", "typeDesc", "locationsDesc", "showStorageVolumesStatement",
		"dropStorageVolumeStatement", "alterStorageVolumeStatement", "alterStorageVolumeClause",
		"modifyStorageVolumePropertiesClause", "modifyStorageVolumeCommentClause",
		"descStorageVolumeStatement", "setDefaultStorageVolumeStatement", "updateFailPointStatusStatement",
		"showFailPointStatement", "createDictionaryStatement", "dropDictionaryStatement",
		"refreshDictionaryStatement", "showDictionaryStatement", "cancelRefreshDictionaryStatement",
		"dictionaryColumnDesc", "dictionaryName", "alterClause", "addFrontendClause",
		"dropFrontendClause", "modifyFrontendHostClause", "addBackendClause",
		"dropBackendClause", "decommissionBackendClause", "modifyBackendClause",
		"addComputeNodeClause", "dropComputeNodeClause", "modifyBrokerClause",
		"alterLoadErrorUrlClause", "createImageClause", "cleanTabletSchedQClause",
		"decommissionDiskClause", "cancelDecommissionDiskClause", "disableDiskClause",
		"cancelDisableDiskClause", "createIndexClause", "dropIndexClause", "tableRenameClause",
		"swapTableClause", "modifyPropertiesClause", "modifyCommentClause",
		"optimizeRange", "optimizeClause", "addColumnClause", "addColumnsClause",
		"dropColumnClause", "modifyColumnClause", "modifyColumnCommentClause",
		"columnRenameClause", "reorderColumnsClause", "rollupRenameClause",
		"compactionClause", "subfieldName", "nestedFieldName", "addFieldClause",
		"dropFieldClause", "createOrReplaceTagClause", "createOrReplaceBranchClause",
		"dropBranchClause", "dropTagClause", "tableOperationClause", "tagOptions",
		"branchOptions", "snapshotRetention", "refRetain", "maxSnapshotAge",
		"minSnapshotsToKeep", "snapshotId", "timeUnit", "integer_list", "dropPersistentIndexClause",
		"addPartitionClause", "dropPartitionClause", "truncatePartitionClause",
		"modifyPartitionClause", "replacePartitionClause", "partitionRenameClause",
		"insertStatement", "insertLabelOrColumnAliases", "columnAliasesOrByName",
		"updateStatement", "deleteStatement", "createRoutineLoadStatement",
		"alterRoutineLoadStatement", "dataSource", "loadProperties", "colSeparatorProperty",
		"rowDelimiterProperty", "importColumns", "columnProperties", "jobProperties",
		"dataSourceProperties", "stopRoutineLoadStatement", "resumeRoutineLoadStatement",
		"pauseRoutineLoadStatement", "showRoutineLoadStatement", "showRoutineLoadTaskStatement",
		"showCreateRoutineLoadStatement", "showStreamLoadStatement", "analyzeStatement",
		"analyzeColumnClause", "dropStatsStatement", "histogramStatement", "analyzeHistogramStatement",
		"dropHistogramStatement", "createAnalyzeStatement", "dropAnalyzeJobStatement",
		"showAnalyzeStatement", "showStatsMetaStatement", "showHistogramMetaStatement",
		"killAnalyzeStatement", "analyzeProfileStatement", "createBaselinePlanStatement",
		"dropBaselinePlanStatement", "showBaselinePlanStatement", "createResourceGroupStatement",
		"dropResourceGroupStatement", "alterResourceGroupStatement", "showResourceGroupStatement",
		"showResourceGroupUsageStatement", "createResourceStatement", "alterResourceStatement",
		"dropResourceStatement", "showResourceStatement", "classifier", "showFunctionsStatement",
		"dropFunctionStatement", "createFunctionStatement", "inlineFunction",
		"typeList", "loadStatement", "labelName", "dataDescList", "dataDesc",
		"formatProps", "brokerDesc", "resourceDesc", "showLoadStatement", "showLoadWarningsStatement",
		"cancelLoadStatement", "alterLoadStatement", "cancelCompactionStatement",
		"showAuthorStatement", "showBackendsStatement", "showBrokerStatement",
		"showCharsetStatement", "showCollationStatement", "showDeleteStatement",
		"showDynamicPartitionStatement", "showEventsStatement", "showEnginesStatement",
		"showFrontendsStatement", "showPluginsStatement", "showRepositoriesStatement",
		"showOpenTableStatement", "showPrivilegesStatement", "showProcedureStatement",
		"showProcStatement", "showProcesslistStatement", "showProfilelistStatement",
		"showRunningQueriesStatement", "showStatusStatement", "showTabletStatement",
		"showTransactionStatement", "showTriggersStatement", "showUserPropertyStatement",
		"showVariablesStatement", "showWarningStatement", "helpStatement", "createUserStatement",
		"dropUserStatement", "alterUserStatement", "showUserStatement", "showAuthenticationStatement",
		"executeAsStatement", "createRoleStatement", "alterRoleStatement", "dropRoleStatement",
		"showRolesStatement", "grantRoleStatement", "revokeRoleStatement", "setRoleStatement",
		"setDefaultRoleStatement", "grantRevokeClause", "grantPrivilegeStatement",
		"revokePrivilegeStatement", "showGrantsStatement", "authOption", "privObjectName",
		"privObjectNameList", "privFunctionObjectNameList", "privilegeTypeList",
		"privilegeType", "privObjectType", "privObjectTypePlural", "createSecurityIntegrationStatement",
		"alterSecurityIntegrationStatement", "dropSecurityIntegrationStatement",
		"showSecurityIntegrationStatement", "showCreateSecurityIntegrationStatement",
		"createGroupProviderStatement", "dropGroupProviderStatement", "showGroupProvidersStatement",
		"showCreateGroupProviderStatement", "backupStatement", "cancelBackupStatement",
		"showBackupStatement", "restoreStatement", "cancelRestoreStatement",
		"showRestoreStatement", "showSnapshotStatement", "createRepositoryStatement",
		"dropRepositoryStatement", "addSqlBlackListStatement", "delSqlBlackListStatement",
		"showSqlBlackListStatement", "showWhiteListStatement", "addBackendBlackListStatement",
		"delBackendBlackListStatement", "showBackendBlackListStatement", "dataCacheTarget",
		"createDataCacheRuleStatement", "showDataCacheRulesStatement", "dropDataCacheRuleStatement",
		"clearDataCacheRulesStatement", "dataCacheSelectStatement", "exportStatement",
		"cancelExportStatement", "showExportStatement", "installPluginStatement",
		"uninstallPluginStatement", "createFileStatement", "dropFileStatement",
		"showSmallFilesStatement", "createPipeStatement", "dropPipeStatement",
		"alterPipeClause", "alterPipeStatement", "descPipeStatement", "showPipeStatement",
		"setStatement", "setVar", "transaction_characteristics", "transaction_access_mode",
		"isolation_level", "isolation_types", "setExprOrDefault", "setUserPropertyStatement",
		"roleList", "executeScriptStatement", "unsupportedStatement", "lock_item",
		"lock_type", "alterPlanAdvisorAddStatement", "truncatePlanAdvisorStatement",
		"alterPlanAdvisorDropStatement", "showPlanAdvisorStatement", "createWarehouseStatement",
		"dropWarehouseStatement", "suspendWarehouseStatement", "resumeWarehouseStatement",
		"setWarehouseStatement", "showWarehousesStatement", "showClustersStatement",
		"showNodesStatement", "alterWarehouseStatement", "createCNGroupStatement",
		"dropCNGroupStatement", "enableCNGroupStatement", "disableCNGroupStatement",
		"alterCNGroupStatement", "beginStatement", "commitStatement", "rollbackStatement",
		"translateStatement", "dialect", "translateSQL", "queryStatement", "queryRelation",
		"withClause", "queryNoWith", "queryPeriod", "periodType", "queryPrimary",
		"subquery", "rowConstructor", "sortItem", "limitConstExpr", "limitElement",
		"querySpecification", "fromClause", "groupingElement", "groupingSet",
		"commonTableExpression", "setQuantifier", "selectItem", "excludeClause",
		"relations", "relation", "relationPrimary", "pivotClause", "pivotAggregationExpression",
		"pivotValue", "sampleClause", "argumentList", "namedArgumentList", "namedArgument",
		"joinRelation", "crossOrInnerJoinType", "outerAndSemiJoinType", "bracketHint",
		"hintMap", "joinCriteria", "columnAliases", "partitionNames", "keyPartitions",
		"tabletList", "prepareStatement", "prepareSql", "executeStatement",
		"deallocateStatement", "replicaList", "expressionsWithDefault", "expressionOrDefault",
		"mapExpressionList", "mapExpression", "expressionSingleton", "expression",
		"expressionList", "booleanExpression", "predicate", "tupleInSubquery",
		"predicateOperations", "valueExpression", "primaryExpression", "literalExpression",
		"functionCall", "aggregationFunction", "userVariable", "systemVariable",
		"columnReference", "informationFunctionExpression", "specialDateTimeExpression",
		"specialFunctionExpression", "windowFunction", "whenClause", "over",
		"ignoreNulls", "windowFrame", "frameBound", "backupRestoreObjectDesc",
		"tableDesc", "backupRestoreTableDesc", "explainDesc", "optimizerTrace",
		"partitionExpr", "partitionDesc", "listPartitionDesc", "singleItemListPartitionDesc",
		"multiItemListPartitionDesc", "multiListPartitionValues", "singleListPartitionValues",
		"listPartitionValues", "listPartitionValue", "stringList", "literalExpressionList",
		"rangePartitionDesc", "singleRangePartition", "multiRangePartition",
		"partitionRangeDesc", "partitionKeyDesc", "partitionValueList", "keyPartition",
		"partitionValue", "distributionClause", "distributionDesc", "refreshSchemeDesc",
		"statusDesc", "properties", "extProperties", "propertyList", "userPropertyList",
		"property", "inlineProperties", "inlineProperty", "varType", "comment",
		"outfile", "fileFormat", "string", "binary", "comparisonOperator", "booleanValue",
		"interval", "taskInterval", "taskUnitIdentifier", "unitIdentifier",
		"unitBoundary", "type", "arrayType", "mapType", "subfieldDesc", "subfieldDescs",
		"structType", "typeParameter", "baseType", "decimalType", "qualifiedName",
		"tableName", "writeBranch", "identifier", "identifierWithAlias", "identifierWithAliasList",
		"identifierList", "identifierOrString", "identifierOrStringList", "identifierOrStringOrStar",
		"user", "assignment", "assignmentList", "number", "nonReserved",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 536, 8213, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7,
		198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2,
		203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7,
		207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2,
		212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7,
		216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2,
		221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7,
		225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2,
		230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7,
		234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2,
		239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 2, 243, 7,
		243, 2, 244, 7, 244, 2, 245, 7, 245, 2, 246, 7, 246, 2, 247, 7, 247, 2,
		248, 7, 248, 2, 249, 7, 249, 2, 250, 7, 250, 2, 251, 7, 251, 2, 252, 7,
		252, 2, 253, 7, 253, 2, 254, 7, 254, 2, 255, 7, 255, 2, 256, 7, 256, 2,
		257, 7, 257, 2, 258, 7, 258, 2, 259, 7, 259, 2, 260, 7, 260, 2, 261, 7,
		261, 2, 262, 7, 262, 2, 263, 7, 263, 2, 264, 7, 264, 2, 265, 7, 265, 2,
		266, 7, 266, 2, 267, 7, 267, 2, 268, 7, 268, 2, 269, 7, 269, 2, 270, 7,
		270, 2, 271, 7, 271, 2, 272, 7, 272, 2, 273, 7, 273, 2, 274, 7, 274, 2,
		275, 7, 275, 2, 276, 7, 276, 2, 277, 7, 277, 2, 278, 7, 278, 2, 279, 7,
		279, 2, 280, 7, 280, 2, 281, 7, 281, 2, 282, 7, 282, 2, 283, 7, 283, 2,
		284, 7, 284, 2, 285, 7, 285, 2, 286, 7, 286, 2, 287, 7, 287, 2, 288, 7,
		288, 2, 289, 7, 289, 2, 290, 7, 290, 2, 291, 7, 291, 2, 292, 7, 292, 2,
		293, 7, 293, 2, 294, 7, 294, 2, 295, 7, 295, 2, 296, 7, 296, 2, 297, 7,
		297, 2, 298, 7, 298, 2, 299, 7, 299, 2, 300, 7, 300, 2, 301, 7, 301, 2,
		302, 7, 302, 2, 303, 7, 303, 2, 304, 7, 304, 2, 305, 7, 305, 2, 306, 7,
		306, 2, 307, 7, 307, 2, 308, 7, 308, 2, 309, 7, 309, 2, 310, 7, 310, 2,
		311, 7, 311, 2, 312, 7, 312, 2, 313, 7, 313, 2, 314, 7, 314, 2, 315, 7,
		315, 2, 316, 7, 316, 2, 317, 7, 317, 2, 318, 7, 318, 2, 319, 7, 319, 2,
		320, 7, 320, 2, 321, 7, 321, 2, 322, 7, 322, 2, 323, 7, 323, 2, 324, 7,
		324, 2, 325, 7, 325, 2, 326, 7, 326, 2, 327, 7, 327, 2, 328, 7, 328, 2,
		329, 7, 329, 2, 330, 7, 330, 2, 331, 7, 331, 2, 332, 7, 332, 2, 333, 7,
		333, 2, 334, 7, 334, 2, 335, 7, 335, 2, 336, 7, 336, 2, 337, 7, 337, 2,
		338, 7, 338, 2, 339, 7, 339, 2, 340, 7, 340, 2, 341, 7, 341, 2, 342, 7,
		342, 2, 343, 7, 343, 2, 344, 7, 344, 2, 345, 7, 345, 2, 346, 7, 346, 2,
		347, 7, 347, 2, 348, 7, 348, 2, 349, 7, 349, 2, 350, 7, 350, 2, 351, 7,
		351, 2, 352, 7, 352, 2, 353, 7, 353, 2, 354, 7, 354, 2, 355, 7, 355, 2,
		356, 7, 356, 2, 357, 7, 357, 2, 358, 7, 358, 2, 359, 7, 359, 2, 360, 7,
		360, 2, 361, 7, 361, 2, 362, 7, 362, 2, 363, 7, 363, 2, 364, 7, 364, 2,
		365, 7, 365, 2, 366, 7, 366, 2, 367, 7, 367, 2, 368, 7, 368, 2, 369, 7,
		369, 2, 370, 7, 370, 2, 371, 7, 371, 2, 372, 7, 372, 2, 373, 7, 373, 2,
		374, 7, 374, 2, 375, 7, 375, 2, 376, 7, 376, 2, 377, 7, 377, 2, 378, 7,
		378, 2, 379, 7, 379, 2, 380, 7, 380, 2, 381, 7, 381, 2, 382, 7, 382, 2,
		383, 7, 383, 2, 384, 7, 384, 2, 385, 7, 385, 2, 386, 7, 386, 2, 387, 7,
		387, 2, 388, 7, 388, 2, 389, 7, 389, 2, 390, 7, 390, 2, 391, 7, 391, 2,
		392, 7, 392, 2, 393, 7, 393, 2, 394, 7, 394, 2, 395, 7, 395, 2, 396, 7,
		396, 2, 397, 7, 397, 2, 398, 7, 398, 2, 399, 7, 399, 2, 400, 7, 400, 2,
		401, 7, 401, 2, 402, 7, 402, 2, 403, 7, 403, 2, 404, 7, 404, 2, 405, 7,
		405, 2, 406, 7, 406, 2, 407, 7, 407, 2, 408, 7, 408, 2, 409, 7, 409, 2,
		410, 7, 410, 2, 411, 7, 411, 2, 412, 7, 412, 2, 413, 7, 413, 2, 414, 7,
		414, 2, 415, 7, 415, 2, 416, 7, 416, 2, 417, 7, 417, 2, 418, 7, 418, 2,
		419, 7, 419, 2, 420, 7, 420, 2, 421, 7, 421, 2, 422, 7, 422, 2, 423, 7,
		423, 2, 424, 7, 424, 2, 425, 7, 425, 2, 426, 7, 426, 2, 427, 7, 427, 2,
		428, 7, 428, 2, 429, 7, 429, 2, 430, 7, 430, 2, 431, 7, 431, 2, 432, 7,
		432, 2, 433, 7, 433, 2, 434, 7, 434, 2, 435, 7, 435, 2, 436, 7, 436, 2,
		437, 7, 437, 2, 438, 7, 438, 2, 439, 7, 439, 2, 440, 7, 440, 2, 441, 7,
		441, 2, 442, 7, 442, 2, 443, 7, 443, 2, 444, 7, 444, 2, 445, 7, 445, 2,
		446, 7, 446, 2, 447, 7, 447, 2, 448, 7, 448, 2, 449, 7, 449, 2, 450, 7,
		450, 2, 451, 7, 451, 2, 452, 7, 452, 2, 453, 7, 453, 2, 454, 7, 454, 2,
		455, 7, 455, 2, 456, 7, 456, 2, 457, 7, 457, 2, 458, 7, 458, 2, 459, 7,
		459, 2, 460, 7, 460, 2, 461, 7, 461, 2, 462, 7, 462, 2, 463, 7, 463, 2,
		464, 7, 464, 2, 465, 7, 465, 2, 466, 7, 466, 2, 467, 7, 467, 2, 468, 7,
		468, 2, 469, 7, 469, 2, 470, 7, 470, 2, 471, 7, 471, 2, 472, 7, 472, 2,
		473, 7, 473, 2, 474, 7, 474, 2, 475, 7, 475, 2, 476, 7, 476, 2, 477, 7,
		477, 2, 478, 7, 478, 2, 479, 7, 479, 2, 480, 7, 480, 2, 481, 7, 481, 2,
		482, 7, 482, 2, 483, 7, 483, 2, 484, 7, 484, 2, 485, 7, 485, 2, 486, 7,
		486, 2, 487, 7, 487, 2, 488, 7, 488, 2, 489, 7, 489, 2, 490, 7, 490, 2,
		491, 7, 491, 2, 492, 7, 492, 2, 493, 7, 493, 2, 494, 7, 494, 2, 495, 7,
		495, 2, 496, 7, 496, 2, 497, 7, 497, 2, 498, 7, 498, 2, 499, 7, 499, 2,
		500, 7, 500, 2, 501, 7, 501, 2, 502, 7, 502, 2, 503, 7, 503, 2, 504, 7,
		504, 2, 505, 7, 505, 2, 506, 7, 506, 2, 507, 7, 507, 2, 508, 7, 508, 2,
		509, 7, 509, 2, 510, 7, 510, 2, 511, 7, 511, 2, 512, 7, 512, 2, 513, 7,
		513, 2, 514, 7, 514, 2, 515, 7, 515, 2, 516, 7, 516, 2, 517, 7, 517, 2,
		518, 7, 518, 2, 519, 7, 519, 2, 520, 7, 520, 1, 0, 4, 0, 1044, 8, 0, 11,
		0, 12, 0, 1045, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1054, 8, 1, 1,
		2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 3, 3, 1298, 8, 3, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 1314, 8, 7, 1, 7, 1, 7, 1,
		7, 1, 7, 3, 7, 1320, 8, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 1328,
		8, 7, 3, 7, 1330, 8, 7, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 1348, 8, 8, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1355, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1360,
		8, 9, 1, 9, 1, 9, 3, 9, 1364, 8, 9, 1, 9, 3, 9, 1367, 8, 9, 1, 9, 3, 9,
		1370, 8, 9, 1, 10, 1, 10, 1, 10, 1, 10, 3, 10, 1376, 8, 10, 1, 10, 1, 10,
		1, 10, 3, 10, 1381, 8, 10, 1, 10, 1, 10, 3, 10, 1385, 8, 10, 1, 11, 1,
		11, 1, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13,
		1, 13, 1, 13, 1, 13, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 1408,
		8, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 1416, 8, 15, 1,
		16, 1, 16, 3, 16, 1420, 8, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 1426,
		8, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 5, 16, 1433, 8, 16, 10, 16, 12,
		16, 1436, 9, 16, 1, 16, 1, 16, 5, 16, 1440, 8, 16, 10, 16, 12, 16, 1443,
		9, 16, 1, 16, 1, 16, 3, 16, 1447, 8, 16, 1, 16, 3, 16, 1450, 8, 16, 1,
		16, 3, 16, 1453, 8, 16, 1, 16, 3, 16, 1456, 8, 16, 1, 16, 3, 16, 1459,
		8, 16, 1, 16, 3, 16, 1462, 8, 16, 1, 16, 3, 16, 1465, 8, 16, 1, 16, 3,
		16, 1468, 8, 16, 1, 16, 3, 16, 1471, 8, 16, 1, 16, 3, 16, 1474, 8, 16,
		1, 17, 1, 17, 3, 17, 1478, 8, 17, 1, 17, 3, 17, 1481, 8, 17, 1, 17, 3,
		17, 1484, 8, 17, 1, 17, 3, 17, 1487, 8, 17, 1, 17, 3, 17, 1490, 8, 17,
		1, 17, 1, 17, 1, 17, 3, 17, 1495, 8, 17, 1, 17, 3, 17, 1498, 8, 17, 1,
		18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 1508, 8, 18,
		1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3,
		19, 1520, 8, 19, 1, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21,
		3, 21, 1530, 8, 21, 3, 21, 1532, 8, 21, 1, 21, 3, 21, 1535, 8, 21, 1, 22,
		1, 22, 1, 22, 1, 22, 1, 23, 3, 23, 1542, 8, 23, 1, 23, 1, 23, 1, 23, 1,
		23, 1, 23, 3, 23, 1549, 8, 23, 1, 23, 3, 23, 1552, 8, 23, 1, 23, 1, 23,
		1, 24, 3, 24, 1557, 8, 24, 1, 24, 1, 24, 3, 24, 1561, 8, 24, 1, 24, 1,
		24, 1, 25, 1, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27,
		1, 27, 3, 27, 1576, 8, 27, 1, 28, 1, 28, 3, 28, 1580, 8, 28, 1, 29, 1,
		29, 1, 29, 1, 29, 1, 29, 5, 29, 1587, 8, 29, 10, 29, 12, 29, 1590, 9, 29,
		1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 3, 30, 1603, 8, 30, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 5, 31, 1610,
		8, 31, 10, 31, 12, 31, 1613, 9, 31, 1, 31, 1, 31, 1, 32, 1, 32, 1, 32,
		3, 32, 1620, 8, 32, 1, 32, 3, 32, 1623, 8, 32, 1, 32, 3, 32, 1626, 8, 32,
		1, 33, 1, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35, 3, 35, 1637,
		8, 35, 1, 36, 1, 36, 1, 36, 3, 36, 1642, 8, 36, 1, 37, 1, 37, 3, 37, 1646,
		8, 37, 1, 37, 1, 37, 1, 37, 1, 37, 3, 37, 1652, 8, 37, 1, 37, 1, 37, 1,
		37, 1, 37, 1, 37, 5, 37, 1659, 8, 37, 10, 37, 12, 37, 1662, 9, 37, 1, 37,
		1, 37, 5, 37, 1666, 8, 37, 10, 37, 12, 37, 1669, 9, 37, 1, 37, 1, 37, 1,
		37, 5, 37, 1674, 8, 37, 10, 37, 12, 37, 1677, 9, 37, 3, 37, 1679, 8, 37,
		1, 37, 1, 37, 3, 37, 1683, 8, 37, 1, 37, 3, 37, 1686, 8, 37, 1, 37, 3,
		37, 1689, 8, 37, 1, 37, 3, 37, 1692, 8, 37, 1, 37, 3, 37, 1695, 8, 37,
		1, 37, 3, 37, 1698, 8, 37, 1, 37, 3, 37, 1701, 8, 37, 1, 37, 1, 37, 1,
		37, 1, 38, 1, 38, 3, 38, 1708, 8, 38, 1, 38, 1, 38, 1, 38, 3, 38, 1713,
		8, 38, 1, 38, 1, 38, 3, 38, 1717, 8, 38, 1, 39, 1, 39, 1, 39, 1, 39, 1,
		39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 5, 40, 1732,
		8, 40, 10, 40, 12, 40, 1735, 9, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40,
		1, 40, 1, 40, 1, 40, 5, 40, 1745, 8, 40, 10, 40, 12, 40, 1748, 9, 40, 1,
		40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 5, 40, 1758, 8, 40,
		10, 40, 12, 40, 1761, 9, 40, 3, 40, 1763, 8, 40, 1, 41, 1, 41, 1, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 1773, 8, 41, 3, 41, 1775, 8, 41,
		1, 41, 3, 41, 1778, 8, 41, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1,
		43, 1, 43, 1, 43, 1, 44, 1, 44, 3, 44, 1791, 8, 44, 1, 44, 1, 44, 1, 44,
		3, 44, 1796, 8, 44, 1, 44, 1, 44, 1, 44, 1, 44, 3, 44, 1802, 8, 44, 1,
		45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 1809, 8, 45, 1, 45, 1, 45, 1, 45,
		1, 45, 3, 45, 1815, 8, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3,
		46, 1823, 8, 46, 1, 46, 1, 46, 1, 47, 1, 47, 3, 47, 1829, 8, 47, 1, 47,
		1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 1837, 8, 47, 1, 47, 1, 47, 1,
		47, 1, 47, 3, 47, 1843, 8, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48,
		1850, 8, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 1856, 8, 48, 1, 49, 1,
		49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 5, 49, 1867, 8, 49,
		10, 49, 12, 49, 1870, 9, 49, 1, 49, 1, 49, 3, 49, 1874, 8, 49, 1, 50, 1,
		50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 1882, 8, 50, 1, 50, 1, 50, 3, 50,
		1886, 8, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 5, 50, 1893, 8, 50, 10,
		50, 12, 50, 1896, 9, 50, 3, 50, 1898, 8, 50, 1, 50, 3, 50, 1901, 8, 50,
		1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 1909, 8, 50, 1, 50, 1,
		50, 3, 50, 1913, 8, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 5, 50, 1920,
		8, 50, 10, 50, 12, 50, 1923, 9, 50, 3, 50, 1925, 8, 50, 1, 50, 3, 50, 1928,
		8, 50, 3, 50, 1930, 8, 50, 1, 51, 1, 51, 1, 51, 3, 51, 1935, 8, 51, 1,
		51, 1, 51, 3, 51, 1939, 8, 51, 1, 52, 1, 52, 3, 52, 1943, 8, 52, 1, 52,
		1, 52, 1, 52, 1, 52, 3, 52, 1949, 8, 52, 1, 52, 1, 52, 3, 52, 1953, 8,
		52, 1, 52, 3, 52, 1956, 8, 52, 1, 52, 3, 52, 1959, 8, 52, 1, 52, 1, 52,
		1, 52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1971, 8,
		53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 1981,
		8, 55, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 1987, 8, 56, 1, 56, 1, 56, 1,
		56, 1, 56, 1, 56, 1, 56, 5, 56, 1995, 8, 56, 10, 56, 12, 56, 1998, 9, 56,
		1, 56, 3, 56, 2001, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3,
		56, 2009, 8, 56, 1, 57, 1, 57, 3, 57, 2013, 8, 57, 1, 57, 1, 57, 1, 57,
		1, 57, 1, 57, 3, 57, 2020, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 5,
		57, 2027, 8, 57, 10, 57, 12, 57, 2030, 9, 57, 3, 57, 2032, 8, 57, 1, 57,
		3, 57, 2035, 8, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 59, 1,
		59, 1, 59, 3, 59, 2046, 8, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 2052,
		8, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 2059, 8, 59, 10, 59, 12,
		59, 2062, 9, 59, 1, 59, 1, 59, 3, 59, 2066, 8, 59, 1, 59, 3, 59, 2069,
		8, 59, 1, 59, 1, 59, 3, 59, 2073, 8, 59, 1, 59, 1, 59, 1, 59, 1, 60, 1,
		60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 5, 60, 2085, 8, 60, 10, 60, 12,
		60, 2088, 9, 60, 1, 60, 1, 60, 3, 60, 2092, 8, 60, 1, 60, 1, 60, 1, 60,
		1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1,
		60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60,
		2117, 8, 60, 1, 61, 1, 61, 1, 61, 1, 61, 3, 61, 2123, 8, 61, 1, 61, 1,
		61, 1, 62, 1, 62, 3, 62, 2129, 8, 62, 1, 63, 1, 63, 1, 63, 3, 63, 2134,
		8, 63, 1, 63, 5, 63, 2137, 8, 63, 10, 63, 12, 63, 2140, 9, 63, 1, 63, 1,
		63, 1, 63, 1, 63, 3, 63, 2146, 8, 63, 1, 64, 1, 64, 3, 64, 2150, 8, 64,
		1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 2156, 8, 65, 1, 66, 1, 66, 1, 66, 1,
		66, 1, 66, 1, 66, 3, 66, 2164, 8, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66,
		1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 3, 67, 2177, 8, 67, 1, 67, 1,
		67, 1, 67, 1, 67, 1, 67, 5, 67, 2184, 8, 67, 10, 67, 12, 67, 2187, 9, 67,
		1, 67, 1, 67, 5, 67, 2191, 8, 67, 10, 67, 12, 67, 2194, 9, 67, 1, 67, 1,
		67, 3, 67, 2198, 8, 67, 1, 67, 3, 67, 2201, 8, 67, 1, 67, 5, 67, 2204,
		8, 67, 10, 67, 12, 67, 2207, 9, 67, 1, 67, 1, 67, 1, 67, 1, 68, 1, 68,
		1, 68, 1, 68, 1, 68, 5, 68, 2217, 8, 68, 10, 68, 12, 68, 2220, 9, 68, 1,
		68, 1, 68, 3, 68, 2224, 8, 68, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69,
		1, 69, 3, 69, 2233, 8, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 2240,
		8, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 2246, 8, 70, 1, 71, 1, 71, 1,
		71, 1, 71, 1, 71, 3, 71, 2253, 8, 71, 1, 71, 1, 71, 1, 72, 1, 72, 1, 72,
		1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 2265, 8, 72, 1, 72, 1, 72, 1,
		72, 1, 72, 1, 72, 1, 72, 3, 72, 2273, 8, 72, 1, 73, 1, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 1, 73, 3, 73, 2282, 8, 73, 3, 73, 2284, 8, 73, 1, 73, 3,
		73, 2287, 8, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2292, 8, 73, 1, 73, 1, 73,
		1, 73, 3, 73, 2297, 8, 73, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3,
		74, 2305, 8, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75,
		1, 75, 3, 75, 2316, 8, 75, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1,
		77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 2330, 8, 77, 1, 78, 1, 78,
		1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 2339, 8, 78, 1, 79, 1, 79, 1,
		79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 2348, 8, 79, 1, 79, 1, 79, 3, 79,
		2352, 8, 79, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 3, 80, 2359, 8, 80, 1,
		81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 3, 81, 2367, 8, 81, 1, 82, 1, 82,
		1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 83, 1, 83, 1, 83, 1, 83, 1,
		83, 1, 83, 1, 83, 1, 83, 3, 83, 2385, 8, 83, 1, 83, 1, 83, 1, 83, 1, 83,
		1, 83, 1, 84, 1, 84, 3, 84, 2394, 8, 84, 1, 84, 3, 84, 2397, 8, 84, 1,
		84, 1, 84, 3, 84, 2401, 8, 84, 1, 85, 1, 85, 1, 86, 1, 86, 1, 86, 1, 86,
		1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 3, 86, 2414, 8, 86, 1, 87, 1, 87, 1,
		87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 1, 88, 1, 89, 1, 89,
		1, 89, 1, 89, 1, 89, 1, 89, 5, 89, 2433, 8, 89, 10, 89, 12, 89, 2436, 9,
		89, 1, 90, 1, 90, 1, 90, 1, 90, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91,
		3, 91, 2448, 8, 91, 1, 91, 1, 91, 3, 91, 2452, 8, 91, 1, 91, 1, 91, 1,
		92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 93, 1, 93, 1, 93, 1, 93, 3, 93, 2465,
		8, 93, 1, 93, 1, 93, 1, 94, 1, 94, 1, 94, 1, 94, 3, 94, 2473, 8, 94, 1,
		95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96,
		3, 96, 2486, 8, 96, 1, 96, 1, 96, 1, 96, 1, 96, 3, 96, 2492, 8, 96, 1,
		96, 3, 96, 2495, 8, 96, 1, 97, 1, 97, 1, 97, 1, 97, 1, 98, 1, 98, 1, 98,
		1, 98, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 3, 99, 2510, 8, 99, 1, 100, 1,
		100, 1, 100, 1, 100, 1, 100, 3, 100, 2517, 8, 100, 1, 100, 1, 100, 1, 101,
		1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 5, 101, 2528, 8, 101, 10,
		101, 12, 101, 2531, 9, 101, 1, 102, 1, 102, 3, 102, 2535, 8, 102, 1, 103,
		1, 103, 1, 103, 1, 104, 1, 104, 1, 104, 1, 104, 1, 105, 1, 105, 1, 105,
		1, 105, 1, 105, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106,
		1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107,
		3, 107, 2565, 8, 107, 3, 107, 2567, 8, 107, 1, 107, 1, 107, 1, 107, 1,
		107, 3, 107, 2573, 8, 107, 3, 107, 2575, 8, 107, 1, 108, 1, 108, 1, 108,
		1, 108, 3, 108, 2581, 8, 108, 1, 108, 1, 108, 1, 108, 3, 108, 2586, 8,
		108, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1,
		109, 5, 109, 2597, 8, 109, 10, 109, 12, 109, 2600, 9, 109, 1, 109, 1, 109,
		3, 109, 2604, 8, 109, 1, 110, 1, 110, 1, 110, 1, 110, 3, 110, 2610, 8,
		110, 1, 111, 1, 111, 1, 111, 1, 111, 1, 112, 1, 112, 1, 112, 3, 112, 2619,
		8, 112, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 114, 1, 114, 1, 114,
		1, 114, 1, 114, 1, 114, 3, 114, 2632, 8, 114, 1, 115, 1, 115, 1, 116, 1,
		116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1,
		116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1,
		116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1,
		116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1,
		116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1,
		116, 1, 116, 3, 116, 2684, 8, 116, 1, 117, 1, 117, 1, 117, 1, 117, 1, 118,
		1, 118, 1, 118, 1, 118, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119,
		1, 119, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 5, 120, 2706, 8, 120, 10,
		120, 12, 120, 2709, 9, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 3,
		120, 2716, 8, 120, 3, 120, 2718, 8, 120, 1, 121, 1, 121, 1, 121, 1, 121,
		1, 121, 5, 121, 2725, 8, 121, 10, 121, 12, 121, 2728, 9, 121, 1, 121, 1,
		121, 1, 121, 1, 121, 1, 121, 3, 121, 2735, 8, 121, 3, 121, 2737, 8, 121,
		1, 121, 3, 121, 2740, 8, 121, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 5,
		122, 2747, 8, 122, 10, 122, 12, 122, 2750, 9, 122, 1, 123, 1, 123, 1, 123,
		1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123,
		1, 123, 3, 123, 2765, 8, 123, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1,
		124, 5, 124, 2773, 8, 124, 10, 124, 12, 124, 2776, 9, 124, 1, 124, 1, 124,
		1, 124, 1, 124, 1, 124, 3, 124, 2783, 8, 124, 3, 124, 2785, 8, 124, 1,
		125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 5, 125, 2793, 8, 125, 10,
		125, 12, 125, 2796, 9, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 3,
		125, 2803, 8, 125, 3, 125, 2805, 8, 125, 1, 126, 1, 126, 1, 126, 1, 126,
		1, 126, 1, 126, 5, 126, 2813, 8, 126, 10, 126, 12, 126, 2816, 9, 126, 1,
		126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 5, 126, 2824, 8, 126, 10,
		126, 12, 126, 2827, 9, 126, 1, 126, 1, 126, 1, 126, 1, 126, 3, 126, 2833,
		8, 126, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 3, 127, 2840, 8, 127, 1,
		128, 1, 128, 1, 128, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 130, 1,
		130, 1, 130, 1, 130, 1, 130, 5, 130, 2855, 8, 130, 10, 130, 12, 130, 2858,
		9, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 131, 1, 131, 1, 131, 1, 131,
		1, 131, 1, 131, 5, 131, 2870, 8, 131, 10, 131, 12, 131, 2873, 9, 131, 1,
		131, 1, 131, 1, 131, 1, 131, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 5,
		132, 2884, 8, 132, 10, 132, 12, 132, 2887, 9, 132, 1, 132, 1, 132, 1, 132,
		1, 132, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 5, 133, 2899, 8,
		133, 10, 133, 12, 133, 2902, 9, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1,
		134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 3, 134, 2914, 8, 134, 3, 134,
		2916, 8, 134, 1, 134, 3, 134, 2919, 8, 134, 1, 135, 1, 135, 1, 135, 1,
		135, 1, 136, 1, 136, 1, 136, 1, 137, 1, 137, 1, 137, 1, 137, 1, 138, 1,
		138, 1, 138, 1, 139, 1, 139, 1, 139, 1, 139, 1, 140, 1, 140, 1, 140, 1,
		140, 1, 140, 1, 141, 3, 141, 2945, 8, 141, 1, 141, 3, 141, 2948, 8, 141,
		1, 141, 3, 141, 2951, 8, 141, 1, 141, 3, 141, 2954, 8, 141, 1, 141, 3,
		141, 2957, 8, 141, 1, 141, 3, 141, 2960, 8, 141, 1, 142, 1, 142, 1, 142,
		1, 142, 1, 142, 1, 142, 3, 142, 2968, 8, 142, 1, 142, 1, 142, 3, 142, 2972,
		8, 142, 1, 142, 3, 142, 2975, 8, 142, 1, 143, 1, 143, 1, 143, 1, 143, 1,
		143, 1, 143, 5, 143, 2983, 8, 143, 10, 143, 12, 143, 2986, 9, 143, 1, 143,
		1, 143, 1, 143, 3, 143, 2991, 8, 143, 1, 143, 3, 143, 2994, 8, 143, 1,
		144, 1, 144, 1, 144, 1, 144, 1, 144, 3, 144, 3001, 8, 144, 1, 144, 3, 144,
		3004, 8, 144, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 3, 145, 3012,
		8, 145, 1, 145, 1, 145, 3, 145, 3016, 8, 145, 1, 145, 3, 145, 3019, 8,
		145, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 147, 1, 147, 1, 147, 1,
		147, 1, 147, 1, 147, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 3, 148, 3037,
		8, 148, 1, 148, 3, 148, 3040, 8, 148, 1, 149, 1, 149, 1, 149, 1, 149, 1,
		149, 1, 150, 3, 150, 3048, 8, 150, 1, 150, 1, 150, 1, 150, 3, 150, 3053,
		8, 150, 1, 151, 1, 151, 3, 151, 3057, 8, 151, 1, 152, 1, 152, 1, 152, 1,
		152, 5, 152, 3063, 8, 152, 10, 152, 12, 152, 3066, 9, 152, 1, 153, 1, 153,
		1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 3, 153, 3077, 8,
		153, 1, 153, 3, 153, 3080, 8, 153, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154,
		1, 154, 1, 154, 3, 154, 3089, 8, 154, 1, 155, 1, 155, 3, 155, 3093, 8,
		155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1,
		155, 1, 155, 3, 155, 3105, 8, 155, 1, 155, 1, 155, 1, 155, 3, 155, 3110,
		8, 155, 1, 156, 1, 156, 3, 156, 3114, 8, 156, 1, 156, 1, 156, 1, 156, 1,
		156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 3, 156, 3126, 8, 156,
		1, 156, 1, 156, 1, 156, 3, 156, 3131, 8, 156, 1, 157, 1, 157, 1, 157, 1,
		157, 3, 157, 3137, 8, 157, 1, 157, 1, 157, 1, 158, 1, 158, 1, 158, 1, 158,
		3, 158, 3145, 8, 158, 1, 158, 1, 158, 1, 159, 1, 159, 1, 159, 1, 160, 1,
		160, 1, 160, 1, 160, 3, 160, 3156, 8, 160, 1, 160, 3, 160, 3159, 8, 160,
		1, 161, 1, 161, 1, 161, 1, 161, 3, 161, 3165, 8, 161, 1, 161, 3, 161, 3168,
		8, 161, 1, 161, 3, 161, 3171, 8, 161, 1, 162, 1, 162, 1, 162, 1, 162, 1,
		162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1,
		162, 3, 162, 3187, 8, 162, 1, 163, 1, 163, 1, 163, 1, 163, 1, 164, 1, 164,
		1, 164, 1, 165, 1, 165, 1, 165, 1, 166, 1, 166, 1, 167, 1, 167, 1, 168,
		1, 168, 1, 168, 1, 168, 5, 168, 3207, 8, 168, 10, 168, 12, 168, 3210, 9,
		168, 1, 168, 1, 168, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 1,
		169, 1, 170, 1, 170, 3, 170, 3223, 8, 170, 1, 170, 1, 170, 1, 170, 3, 170,
		3228, 8, 170, 1, 170, 3, 170, 3231, 8, 170, 1, 170, 3, 170, 3234, 8, 170,
		1, 170, 1, 170, 3, 170, 3238, 8, 170, 1, 170, 1, 170, 3, 170, 3242, 8,
		170, 1, 170, 3, 170, 3245, 8, 170, 1, 170, 3, 170, 3248, 8, 170, 3, 170,
		3250, 8, 170, 1, 171, 1, 171, 3, 171, 3254, 8, 171, 1, 171, 1, 171, 1,
		171, 3, 171, 3259, 8, 171, 1, 171, 1, 171, 1, 171, 1, 171, 3, 171, 3265,
		8, 171, 1, 171, 3, 171, 3268, 8, 171, 1, 171, 3, 171, 3271, 8, 171, 1,
		171, 1, 171, 3, 171, 3275, 8, 171, 1, 171, 1, 171, 1, 171, 3, 171, 3280,
		8, 171, 1, 171, 1, 171, 3, 171, 3284, 8, 171, 1, 171, 1, 171, 3, 171, 3288,
		8, 171, 1, 171, 1, 171, 1, 171, 3, 171, 3293, 8, 171, 1, 171, 1, 171, 1,
		171, 3, 171, 3298, 8, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 3, 171,
		3305, 8, 171, 3, 171, 3307, 8, 171, 1, 172, 1, 172, 1, 172, 1, 173, 1,
		173, 1, 173, 1, 173, 1, 173, 1, 173, 1, 173, 3, 173, 3319, 8, 173, 1, 173,
		1, 173, 1, 173, 1, 173, 1, 173, 3, 173, 3326, 8, 173, 1, 174, 1, 174, 1,
		174, 1, 174, 1, 174, 3, 174, 3333, 8, 174, 1, 175, 1, 175, 1, 175, 1, 175,
		1, 175, 1, 176, 3, 176, 3341, 8, 176, 1, 176, 1, 176, 1, 176, 1, 176, 3,
		176, 3347, 8, 176, 1, 176, 3, 176, 3350, 8, 176, 1, 176, 1, 176, 1, 176,
		1, 176, 1, 176, 3, 176, 3357, 8, 176, 1, 176, 5, 176, 3360, 8, 176, 10,
		176, 12, 176, 3363, 9, 176, 1, 176, 3, 176, 3366, 8, 176, 1, 176, 1, 176,
		1, 176, 1, 176, 1, 176, 5, 176, 3373, 8, 176, 10, 176, 12, 176, 3376, 9,
		176, 3, 176, 3378, 8, 176, 1, 177, 1, 177, 1, 177, 1, 177, 3, 177, 3384,
		8, 177, 1, 178, 1, 178, 1, 178, 3, 178, 3389, 8, 178, 1, 179, 3, 179, 3392,
		8, 179, 1, 179, 3, 179, 3395, 8, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1,
		179, 1, 179, 1, 179, 3, 179, 3404, 8, 179, 1, 180, 3, 180, 3407, 8, 180,
		1, 180, 3, 180, 3410, 8, 180, 1, 180, 1, 180, 1, 180, 1, 180, 3, 180, 3416,
		8, 180, 1, 180, 1, 180, 3, 180, 3420, 8, 180, 1, 180, 1, 180, 3, 180, 3424,
		8, 180, 1, 181, 1, 181, 1, 181, 1, 181, 1, 181, 1, 181, 3, 181, 3432, 8,
		181, 1, 181, 1, 181, 1, 181, 1, 181, 1, 181, 1, 181, 5, 181, 3440, 8, 181,
		10, 181, 12, 181, 3443, 9, 181, 3, 181, 3445, 8, 181, 1, 181, 3, 181, 3448,
		8, 181, 1, 181, 1, 181, 1, 181, 3, 181, 3453, 8, 181, 1, 182, 1, 182, 1,
		182, 1, 182, 1, 182, 1, 182, 1, 182, 3, 182, 3462, 8, 182, 1, 182, 1, 182,
		1, 182, 1, 182, 5, 182, 3468, 8, 182, 10, 182, 12, 182, 3471, 9, 182, 3,
		182, 3473, 8, 182, 1, 182, 3, 182, 3476, 8, 182, 1, 182, 3, 182, 3479,
		8, 182, 1, 183, 1, 183, 1, 183, 1, 183, 1, 184, 1, 184, 1, 184, 1, 184,
		1, 184, 1, 184, 3, 184, 3491, 8, 184, 1, 185, 1, 185, 1, 185, 1, 185, 1,
		185, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 187, 1, 187, 1, 187, 1,
		188, 1, 188, 1, 188, 3, 188, 3509, 8, 188, 1, 188, 1, 188, 1, 188, 3, 188,
		3514, 8, 188, 5, 188, 3516, 8, 188, 10, 188, 12, 188, 3519, 9, 188, 1,
		188, 1, 188, 1, 189, 1, 189, 1, 190, 1, 190, 1, 191, 1, 191, 1, 191, 1,
		191, 1, 191, 1, 191, 1, 191, 3, 191, 3534, 8, 191, 1, 191, 1, 191, 1, 192,
		1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 3, 192, 3545, 8, 192, 1,
		192, 1, 192, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 3,
		193, 3556, 8, 193, 1, 193, 1, 193, 1, 194, 1, 194, 3, 194, 3562, 8, 194,
		1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 3, 194, 3570, 8, 194, 1,
		194, 3, 194, 3573, 8, 194, 1, 194, 1, 194, 3, 194, 3577, 8, 194, 1, 194,
		1, 194, 3, 194, 3581, 8, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 5,
		194, 3588, 8, 194, 10, 194, 12, 194, 3591, 9, 194, 3, 194, 3593, 8, 194,
		1, 194, 3, 194, 3596, 8, 194, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1,
		195, 3, 195, 3604, 8, 195, 1, 195, 1, 195, 1, 195, 1, 196, 1, 196, 1, 196,
		1, 196, 1, 196, 1, 196, 1, 196, 3, 196, 3616, 8, 196, 1, 196, 1, 196, 1,
		197, 1, 197, 3, 197, 3622, 8, 197, 1, 197, 1, 197, 1, 197, 1, 197, 1, 197,
		1, 197, 3, 197, 3630, 8, 197, 1, 197, 3, 197, 3633, 8, 197, 1, 197, 1,
		197, 3, 197, 3637, 8, 197, 1, 197, 1, 197, 3, 197, 3641, 8, 197, 1, 197,
		1, 197, 1, 197, 1, 197, 1, 197, 5, 197, 3648, 8, 197, 10, 197, 12, 197,
		3651, 9, 197, 3, 197, 3653, 8, 197, 1, 197, 3, 197, 3656, 8, 197, 1, 198,
		1, 198, 3, 198, 3660, 8, 198, 1, 198, 1, 198, 1, 198, 3, 198, 3665, 8,
		198, 1, 198, 3, 198, 3668, 8, 198, 1, 198, 1, 198, 1, 198, 3, 198, 3673,
		8, 198, 1, 198, 3, 198, 3676, 8, 198, 1, 199, 1, 199, 1, 199, 1, 199, 5,
		199, 3682, 8, 199, 10, 199, 12, 199, 3685, 9, 199, 1, 199, 1, 199, 1, 199,
		1, 199, 1, 199, 5, 199, 3692, 8, 199, 10, 199, 12, 199, 3695, 9, 199, 1,
		199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1,
		199, 5, 199, 3707, 8, 199, 10, 199, 12, 199, 3710, 9, 199, 1, 199, 1, 199,
		3, 199, 3714, 8, 199, 1, 200, 1, 200, 1, 200, 3, 200, 3719, 8, 200, 1,
		200, 1, 200, 1, 200, 1, 201, 1, 201, 1, 201, 1, 201, 1, 201, 1, 201, 1,
		201, 1, 201, 1, 201, 1, 201, 3, 201, 3734, 8, 201, 1, 201, 3, 201, 3737,
		8, 201, 1, 202, 1, 202, 1, 202, 1, 202, 3, 202, 3743, 8, 202, 1, 203, 1,
		203, 1, 203, 1, 203, 1, 203, 1, 203, 1, 203, 1, 203, 1, 203, 5, 203, 3754,
		8, 203, 10, 203, 12, 203, 3757, 9, 203, 1, 204, 1, 204, 1, 204, 3, 204,
		3762, 8, 204, 1, 204, 1, 204, 3, 204, 3766, 8, 204, 1, 204, 1, 204, 1,
		204, 3, 204, 3771, 8, 204, 1, 204, 1, 204, 1, 204, 3, 204, 3776, 8, 204,
		1, 204, 1, 204, 1, 204, 3, 204, 3781, 8, 204, 1, 204, 1, 204, 1, 204, 1,
		204, 1, 204, 1, 204, 5, 204, 3789, 8, 204, 10, 204, 12, 204, 3792, 9, 204,
		1, 204, 1, 204, 3, 204, 3796, 8, 204, 1, 204, 3, 204, 3799, 8, 204, 1,
		204, 1, 204, 3, 204, 3803, 8, 204, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205,
		1, 205, 1, 205, 3, 205, 3812, 8, 205, 1, 206, 1, 206, 1, 206, 3, 206, 3817,
		8, 206, 1, 206, 1, 206, 3, 206, 3821, 8, 206, 1, 206, 1, 206, 1, 206, 1,
		206, 1, 206, 5, 206, 3828, 8, 206, 10, 206, 12, 206, 3831, 9, 206, 3, 206,
		3833, 8, 206, 1, 206, 3, 206, 3836, 8, 206, 1, 207, 1, 207, 1, 207, 3,
		207, 3841, 8, 207, 1, 207, 1, 207, 1, 207, 1, 207, 3, 207, 3847, 8, 207,
		1, 207, 1, 207, 1, 207, 1, 207, 1, 207, 5, 207, 3854, 8, 207, 10, 207,
		12, 207, 3857, 9, 207, 3, 207, 3859, 8, 207, 1, 207, 3, 207, 3862, 8, 207,
		1, 208, 1, 208, 1, 208, 1, 208, 1, 208, 3, 208, 3869, 8, 208, 1, 208, 1,
		208, 1, 208, 1, 208, 1, 208, 5, 208, 3876, 8, 208, 10, 208, 12, 208, 3879,
		9, 208, 3, 208, 3881, 8, 208, 1, 208, 3, 208, 3884, 8, 208, 1, 209, 1,
		209, 1, 209, 1, 209, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1,
		210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 5, 210, 3902, 8, 210, 10,
		210, 12, 210, 3905, 9, 210, 3, 210, 3907, 8, 210, 1, 211, 1, 211, 3, 211,
		3911, 8, 211, 1, 211, 1, 211, 1, 211, 3, 211, 3916, 8, 211, 1, 211, 1,
		211, 1, 211, 3, 211, 3921, 8, 211, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212,
		5, 212, 3928, 8, 212, 10, 212, 12, 212, 3931, 9, 212, 1, 213, 1, 213, 1,
		213, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 3, 214, 3942, 8, 214,
		1, 214, 1, 214, 3, 214, 3946, 8, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1,
		214, 5, 214, 3953, 8, 214, 10, 214, 12, 214, 3956, 9, 214, 3, 214, 3958,
		8, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 5, 214, 3965, 8, 214, 10,
		214, 12, 214, 3968, 9, 214, 1, 214, 1, 214, 1, 215, 1, 215, 1, 215, 1,
		215, 1, 215, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1,
		216, 5, 216, 3985, 8, 216, 10, 216, 12, 216, 3988, 9, 216, 1, 216, 1, 216,
		1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 5, 216, 3999, 8,
		216, 10, 216, 12, 216, 4002, 9, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1,
		216, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1,
		216, 1, 216, 1, 216, 1, 216, 1, 216, 5, 216, 4022, 8, 216, 10, 216, 12,
		216, 4025, 9, 216, 1, 216, 1, 216, 3, 216, 4029, 8, 216, 1, 217, 1, 217,
		3, 217, 4033, 8, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 3, 217, 4040,
		8, 217, 1, 217, 1, 217, 1, 217, 3, 217, 4045, 8, 217, 3, 217, 4047, 8,
		217, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1,
		218, 3, 218, 4058, 8, 218, 1, 219, 1, 219, 3, 219, 4062, 8, 219, 1, 219,
		1, 219, 1, 219, 3, 219, 4067, 8, 219, 1, 220, 1, 220, 1, 220, 1, 220, 1,
		220, 1, 220, 1, 221, 1, 221, 1, 221, 1, 221, 1, 222, 1, 222, 1, 222, 1,
		223, 1, 223, 1, 223, 1, 223, 1, 224, 1, 224, 3, 224, 4088, 8, 224, 1, 224,
		3, 224, 4091, 8, 224, 1, 224, 1, 224, 1, 224, 3, 224, 4096, 8, 224, 1,
		224, 1, 224, 1, 224, 1, 224, 3, 224, 4102, 8, 224, 1, 225, 1, 225, 3, 225,
		4106, 8, 225, 1, 225, 1, 225, 1, 225, 3, 225, 4111, 8, 225, 1, 225, 1,
		225, 1, 225, 1, 225, 1, 225, 1, 226, 1, 226, 1, 226, 3, 226, 4121, 8, 226,
		1, 226, 3, 226, 4124, 8, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1,
		226, 1, 226, 1, 226, 1, 226, 1, 226, 3, 226, 4136, 8, 226, 1, 226, 3, 226,
		4139, 8, 226, 1, 227, 1, 227, 1, 227, 1, 228, 3, 228, 4145, 8, 228, 1,
		228, 1, 228, 5, 228, 4149, 8, 228, 10, 228, 12, 228, 4152, 9, 228, 1, 228,
		1, 228, 3, 228, 4156, 8, 228, 1, 229, 1, 229, 1, 229, 1, 229, 3, 229, 4162,
		8, 229, 1, 229, 3, 229, 4165, 8, 229, 1, 229, 1, 229, 3, 229, 4169, 8,
		229, 1, 229, 1, 229, 3, 229, 4173, 8, 229, 1, 229, 1, 229, 1, 229, 1, 229,
		3, 229, 4179, 8, 229, 1, 229, 1, 229, 1, 229, 3, 229, 4184, 8, 229, 3,
		229, 4186, 8, 229, 1, 230, 1, 230, 1, 230, 3, 230, 4191, 8, 230, 1, 230,
		1, 230, 1, 231, 1, 231, 1, 231, 1, 231, 5, 231, 4199, 8, 231, 10, 231,
		12, 231, 4202, 9, 231, 1, 231, 1, 231, 1, 232, 1, 232, 1, 232, 1, 232,
		3, 232, 4210, 8, 232, 1, 232, 1, 232, 1, 232, 1, 232, 3, 232, 4216, 8,
		232, 1, 232, 1, 232, 1, 232, 1, 232, 3, 232, 4222, 8, 232, 1, 232, 1, 232,
		1, 232, 1, 232, 3, 232, 4228, 8, 232, 1, 232, 3, 232, 4231, 8, 232, 1,
		232, 3, 232, 4234, 8, 232, 1, 232, 3, 232, 4237, 8, 232, 1, 232, 1, 232,
		1, 232, 1, 232, 1, 232, 3, 232, 4244, 8, 232, 1, 232, 1, 232, 3, 232, 4248,
		8, 232, 1, 232, 1, 232, 3, 232, 4252, 8, 232, 1, 232, 1, 232, 1, 232, 1,
		232, 1, 232, 3, 232, 4259, 8, 232, 1, 232, 1, 232, 1, 232, 1, 232, 3, 232,
		4265, 8, 232, 1, 232, 1, 232, 3, 232, 4269, 8, 232, 1, 232, 1, 232, 3,
		232, 4273, 8, 232, 3, 232, 4275, 8, 232, 1, 233, 1, 233, 1, 233, 1, 233,
		3, 233, 4281, 8, 233, 1, 233, 1, 233, 1, 233, 3, 233, 4286, 8, 233, 1,
		233, 1, 233, 1, 233, 3, 233, 4291, 8, 233, 1, 233, 1, 233, 1, 233, 3, 233,
		4296, 8, 233, 1, 233, 1, 233, 1, 234, 1, 234, 1, 234, 3, 234, 4303, 8,
		234, 1, 234, 1, 234, 1, 234, 1, 234, 3, 234, 4309, 8, 234, 3, 234, 4311,
		8, 234, 1, 235, 1, 235, 1, 235, 1, 235, 3, 235, 4317, 8, 235, 1, 236, 1,
		236, 1, 236, 3, 236, 4322, 8, 236, 1, 236, 1, 236, 3, 236, 4326, 8, 236,
		1, 236, 1, 236, 3, 236, 4330, 8, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1,
		236, 5, 236, 4337, 8, 236, 10, 236, 12, 236, 4340, 9, 236, 3, 236, 4342,
		8, 236, 1, 236, 3, 236, 4345, 8, 236, 1, 237, 1, 237, 1, 237, 1, 237, 1,
		237, 3, 237, 4352, 8, 237, 1, 237, 1, 237, 3, 237, 4356, 8, 237, 1, 237,
		3, 237, 4359, 8, 237, 1, 237, 1, 237, 1, 237, 1, 237, 1, 237, 3, 237, 4366,
		8, 237, 1, 238, 1, 238, 1, 238, 1, 238, 3, 238, 4372, 8, 238, 1, 238, 1,
		238, 3, 238, 4376, 8, 238, 1, 239, 1, 239, 1, 239, 1, 239, 1, 239, 1, 239,
		3, 239, 4384, 8, 239, 1, 239, 1, 239, 3, 239, 4388, 8, 239, 1, 240, 1,
		240, 1, 240, 1, 240, 1, 240, 1, 241, 1, 241, 1, 241, 1, 242, 1, 242, 1,
		242, 1, 243, 1, 243, 1, 243, 1, 244, 1, 244, 1, 244, 1, 244, 1, 244, 1,
		244, 3, 244, 4410, 8, 244, 1, 244, 1, 244, 1, 244, 1, 244, 3, 244, 4416,
		8, 244, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 3, 245, 4424, 8,
		245, 1, 246, 1, 246, 1, 246, 1, 246, 3, 246, 4430, 8, 246, 1, 247, 1, 247,
		1, 247, 1, 247, 1, 247, 1, 247, 3, 247, 4438, 8, 247, 1, 248, 1, 248, 1,
		248, 1, 248, 3, 248, 4444, 8, 248, 1, 248, 1, 248, 1, 248, 1, 248, 3, 248,
		4450, 8, 248, 1, 249, 1, 249, 1, 249, 1, 250, 1, 250, 1, 250, 1, 251, 1,
		251, 1, 251, 1, 252, 1, 252, 1, 252, 1, 253, 1, 253, 1, 253, 1, 253, 1,
		254, 1, 254, 1, 254, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1,
		255, 3, 255, 4478, 8, 255, 1, 256, 1, 256, 1, 256, 1, 256, 1, 257, 1, 257,
		3, 257, 4486, 8, 257, 1, 257, 1, 257, 1, 257, 3, 257, 4491, 8, 257, 1,
		258, 1, 258, 1, 258, 1, 258, 3, 258, 4497, 8, 258, 1, 259, 1, 259, 1, 259,
		1, 259, 1, 259, 3, 259, 4504, 8, 259, 1, 260, 1, 260, 3, 260, 4508, 8,
		260, 1, 260, 1, 260, 1, 260, 1, 260, 1, 260, 3, 260, 4515, 8, 260, 1, 261,
		1, 261, 1, 261, 1, 261, 1, 261, 1, 261, 1, 261, 1, 261, 3, 261, 4525, 8,
		261, 1, 261, 1, 261, 3, 261, 4529, 8, 261, 1, 261, 1, 261, 1, 261, 1, 261,
		1, 261, 5, 261, 4536, 8, 261, 10, 261, 12, 261, 4539, 9, 261, 3, 261, 4541,
		8, 261, 1, 261, 3, 261, 4544, 8, 261, 3, 261, 4546, 8, 261, 1, 262, 1,
		262, 1, 262, 1, 262, 3, 262, 4552, 8, 262, 1, 262, 1, 262, 3, 262, 4556,
		8, 262, 1, 263, 1, 263, 3, 263, 4560, 8, 263, 1, 263, 1, 263, 1, 263, 3,
		263, 4565, 8, 263, 1, 263, 1, 263, 1, 263, 1, 263, 3, 263, 4571, 8, 263,
		1, 264, 1, 264, 1, 264, 1, 264, 3, 264, 4577, 8, 264, 1, 264, 1, 264, 3,
		264, 4581, 8, 264, 1, 264, 1, 264, 1, 264, 1, 264, 3, 264, 4587, 8, 264,
		1, 264, 1, 264, 3, 264, 4591, 8, 264, 3, 264, 4593, 8, 264, 1, 265, 1,
		265, 3, 265, 4597, 8, 265, 1, 265, 1, 265, 1, 265, 1, 265, 1, 265, 3, 265,
		4604, 8, 265, 1, 266, 1, 266, 1, 266, 3, 266, 4609, 8, 266, 1, 267, 1,
		267, 1, 267, 1, 268, 1, 268, 1, 268, 1, 268, 1, 268, 3, 268, 4619, 8, 268,
		1, 268, 1, 268, 3, 268, 4623, 8, 268, 1, 268, 1, 268, 1, 268, 3, 268, 4628,
		8, 268, 1, 268, 3, 268, 4631, 8, 268, 1, 269, 1, 269, 1, 269, 1, 269, 3,
		269, 4637, 8, 269, 1, 269, 1, 269, 1, 270, 1, 270, 1, 270, 1, 270, 3, 270,
		4645, 8, 270, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 3,
		270, 4654, 8, 270, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 3, 270,
		4662, 8, 270, 1, 270, 1, 270, 1, 270, 1, 270, 3, 270, 4668, 8, 270, 1,
		270, 1, 270, 1, 270, 1, 270, 3, 270, 4674, 8, 270, 1, 271, 1, 271, 1, 271,
		1, 272, 1, 272, 1, 272, 1, 272, 1, 272, 1, 272, 1, 272, 3, 272, 4686, 8,
		272, 3, 272, 4688, 8, 272, 1, 273, 1, 273, 1, 273, 1, 273, 1, 273, 1, 273,
		3, 273, 4696, 8, 273, 1, 274, 1, 274, 1, 274, 1, 274, 1, 274, 3, 274, 4703,
		8, 274, 1, 274, 1, 274, 3, 274, 4707, 8, 274, 1, 275, 1, 275, 1, 275, 1,
		275, 3, 275, 4713, 8, 275, 1, 275, 1, 275, 1, 275, 1, 275, 1, 275, 1, 275,
		1, 276, 1, 276, 1, 276, 1, 276, 3, 276, 4725, 8, 276, 1, 276, 1, 276, 1,
		277, 1, 277, 1, 277, 1, 278, 1, 278, 1, 278, 1, 278, 3, 278, 4736, 8, 278,
		1, 278, 1, 278, 1, 278, 1, 278, 1, 278, 1, 278, 1, 278, 1, 278, 3, 278,
		4746, 8, 278, 1, 279, 1, 279, 1, 279, 1, 279, 3, 279, 4752, 8, 279, 1,
		279, 1, 279, 1, 279, 1, 279, 1, 279, 1, 279, 1, 279, 1, 279, 3, 279, 4762,
		8, 279, 1, 280, 1, 280, 1, 280, 1, 280, 1, 280, 1, 280, 1, 280, 1, 280,
		1, 280, 1, 280, 1, 280, 3, 280, 4775, 8, 280, 1, 280, 1, 280, 1, 280, 3,
		280, 4780, 8, 280, 1, 281, 1, 281, 1, 281, 1, 281, 1, 281, 1, 281, 3, 281,
		4788, 8, 281, 1, 281, 1, 281, 1, 281, 1, 282, 3, 282, 4794, 8, 282, 1,
		282, 1, 282, 1, 282, 3, 282, 4799, 8, 282, 1, 283, 1, 283, 1, 283, 1, 283,
		1, 283, 1, 283, 1, 283, 5, 283, 4808, 8, 283, 10, 283, 12, 283, 4811, 9,
		283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 3, 283, 4818, 8, 283, 1, 283,
		1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 3, 283,
		4829, 8, 283, 1, 283, 1, 283, 1, 283, 1, 283, 3, 283, 4835, 8, 283, 1,
		283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 3, 283, 4844, 8, 283,
		1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283,
		3, 283, 4855, 8, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1,
		283, 1, 283, 1, 283, 1, 283, 3, 283, 4867, 8, 283, 1, 283, 1, 283, 1, 283,
		1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 3, 283,
		4880, 8, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 3, 283, 4887, 8,
		283, 3, 283, 4889, 8, 283, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284,
		1, 284, 5, 284, 4898, 8, 284, 10, 284, 12, 284, 4901, 9, 284, 1, 284, 1,
		284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1,
		284, 1, 284, 1, 284, 1, 284, 3, 284, 4917, 8, 284, 1, 284, 1, 284, 1, 284,
		1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284,
		1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284,
		1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284,
		1, 284, 3, 284, 4950, 8, 284, 1, 284, 1, 284, 1, 284, 3, 284, 4955, 8,
		284, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 3, 285, 4963, 8, 285,
		1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 3, 285, 4971, 8, 285, 1,
		286, 1, 286, 1, 286, 3, 286, 4976, 8, 286, 1, 286, 1, 286, 1, 286, 1, 286,
		1, 286, 1, 286, 3, 286, 4984, 8, 286, 3, 286, 4986, 8, 286, 1, 287, 1,
		287, 1, 287, 3, 287, 4991, 8, 287, 1, 288, 1, 288, 1, 288, 5, 288, 4996,
		8, 288, 10, 288, 12, 288, 4999, 9, 288, 1, 289, 1, 289, 1, 289, 1, 289,
		1, 289, 1, 289, 1, 289, 1, 289, 1, 289, 1, 289, 5, 289, 5011, 8, 289, 10,
		289, 12, 289, 5014, 9, 289, 1, 290, 1, 290, 1, 290, 5, 290, 5019, 8, 290,
		10, 290, 12, 290, 5022, 9, 290, 1, 291, 1, 291, 3, 291, 5026, 8, 291, 1,
		291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1,
		291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1,
		291, 1, 291, 1, 291, 1, 291, 3, 291, 5050, 8, 291, 1, 291, 1, 291, 1, 291,
		1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291,
		1, 291, 1, 291, 1, 291, 3, 291, 5067, 8, 291, 1, 292, 1, 292, 1, 292, 1,
		292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1,
		292, 1, 292, 3, 292, 5083, 8, 292, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293,
		1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293,
		1, 293, 1, 293, 1, 293, 1, 293, 3, 293, 5103, 8, 293, 1, 294, 1, 294, 1,
		294, 1, 294, 1, 294, 1, 294, 1, 295, 1, 295, 1, 295, 1, 295, 1, 295, 1,
		295, 1, 295, 1, 296, 1, 296, 1, 296, 1, 296, 1, 296, 1, 297, 1, 297, 1,
		297, 1, 297, 1, 298, 1, 298, 1, 298, 1, 298, 1, 298, 1, 298, 1, 299, 1,
		299, 1, 299, 1, 299, 1, 299, 1, 299, 1, 300, 1, 300, 1, 300, 1, 300, 1,
		300, 1, 301, 1, 301, 1, 301, 1, 301, 1, 302, 1, 302, 1, 302, 1, 302, 1,
		302, 1, 302, 1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 3,
		303, 5161, 8, 303, 1, 303, 1, 303, 3, 303, 5165, 8, 303, 1, 303, 1, 303,
		1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 5, 303, 5176, 8,
		303, 10, 303, 12, 303, 5179, 9, 303, 1, 303, 1, 303, 3, 303, 5183, 8, 303,
		1, 303, 1, 303, 3, 303, 5187, 8, 303, 1, 304, 1, 304, 1, 304, 1, 304, 1,
		304, 1, 304, 1, 304, 3, 304, 5196, 8, 304, 1, 305, 1, 305, 1, 305, 1, 305,
		3, 305, 5202, 8, 305, 1, 306, 1, 306, 1, 306, 1, 306, 1, 306, 1, 306, 1,
		306, 1, 306, 1, 306, 1, 306, 1, 306, 3, 306, 5215, 8, 306, 1, 306, 1, 306,
		1, 306, 1, 306, 3, 306, 5221, 8, 306, 3, 306, 5223, 8, 306, 1, 306, 1,
		306, 1, 306, 1, 306, 1, 306, 5, 306, 5230, 8, 306, 10, 306, 12, 306, 5233,
		9, 306, 1, 306, 1, 306, 3, 306, 5237, 8, 306, 1, 306, 1, 306, 3, 306, 5241,
		8, 306, 1, 307, 1, 307, 1, 307, 1, 307, 1, 307, 1, 307, 1, 307, 3, 307,
		5250, 8, 307, 1, 308, 1, 308, 1, 308, 1, 308, 3, 308, 5256, 8, 308, 1,
		308, 1, 308, 3, 308, 5260, 8, 308, 1, 309, 1, 309, 1, 309, 1, 309, 1, 309,
		1, 309, 3, 309, 5268, 8, 309, 1, 310, 1, 310, 1, 310, 3, 310, 5273, 8,
		310, 1, 310, 1, 310, 1, 310, 1, 310, 1, 310, 3, 310, 5280, 8, 310, 1, 310,
		1, 310, 1, 310, 1, 310, 1, 310, 3, 310, 5287, 8, 310, 1, 311, 1, 311, 1,
		311, 1, 311, 1, 312, 1, 312, 1, 312, 1, 312, 1, 313, 1, 313, 1, 313, 1,
		313, 1, 313, 5, 313, 5302, 8, 313, 10, 313, 12, 313, 5305, 9, 313, 1, 314,
		1, 314, 1, 314, 1, 315, 1, 315, 1, 315, 1, 316, 1, 316, 1, 316, 1, 316,
		1, 316, 1, 316, 5, 316, 5319, 8, 316, 10, 316, 12, 316, 5322, 9, 316, 1,
		317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 5, 317, 5330, 8, 317, 10,
		317, 12, 317, 5333, 9, 317, 1, 318, 1, 318, 1, 318, 1, 318, 1, 319, 1,
		319, 1, 319, 1, 319, 1, 319, 1, 319, 1, 320, 1, 320, 1, 320, 1, 320, 1,
		320, 1, 320, 3, 320, 5351, 8, 320, 1, 320, 1, 320, 1, 320, 3, 320, 5356,
		8, 320, 1, 320, 1, 320, 3, 320, 5360, 8, 320, 1, 321, 1, 321, 1, 321, 1,
		321, 1, 322, 1, 322, 1, 322, 1, 322, 1, 322, 1, 323, 1, 323, 1, 323, 1,
		323, 1, 324, 1, 324, 1, 324, 1, 324, 1, 324, 5, 324, 5380, 8, 324, 10,
		324, 12, 324, 5383, 9, 324, 1, 324, 1, 324, 1, 324, 1, 324, 3, 324, 5389,
		8, 324, 1, 324, 3, 324, 5392, 8, 324, 1, 325, 1, 325, 1, 325, 1, 325, 3,
		325, 5398, 8, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 3, 325, 5405,
		8, 325, 1, 325, 3, 325, 5408, 8, 325, 1, 325, 3, 325, 5411, 8, 325, 1,
		326, 1, 326, 1, 326, 1, 326, 3, 326, 5417, 8, 326, 1, 326, 1, 326, 1, 326,
		1, 326, 3, 326, 5423, 8, 326, 1, 327, 1, 327, 1, 327, 1, 327, 3, 327, 5429,
		8, 327, 1, 327, 1, 327, 1, 327, 1, 327, 3, 327, 5435, 8, 327, 1, 327, 1,
		327, 1, 327, 1, 327, 1, 327, 5, 327, 5442, 8, 327, 10, 327, 12, 327, 5445,
		9, 327, 3, 327, 5447, 8, 327, 1, 327, 3, 327, 5450, 8, 327, 1, 328, 1,
		328, 1, 328, 1, 328, 1, 328, 3, 328, 5457, 8, 328, 1, 329, 1, 329, 1, 329,
		1, 329, 1, 330, 1, 330, 1, 330, 1, 330, 1, 330, 3, 330, 5468, 8, 330, 1,
		330, 1, 330, 1, 331, 1, 331, 1, 331, 1, 331, 1, 331, 3, 331, 5477, 8, 331,
		1, 331, 1, 331, 1, 332, 1, 332, 1, 332, 1, 332, 3, 332, 5485, 8, 332, 1,
		333, 1, 333, 1, 333, 1, 333, 1, 333, 1, 333, 3, 333, 5493, 8, 333, 1, 333,
		1, 333, 1, 333, 1, 334, 1, 334, 1, 334, 1, 334, 3, 334, 5502, 8, 334, 1,
		334, 1, 334, 1, 335, 1, 335, 1, 335, 1, 335, 1, 335, 1, 335, 1, 335, 1,
		335, 1, 335, 3, 335, 5515, 8, 335, 1, 336, 1, 336, 1, 336, 1, 336, 1, 336,
		1, 337, 1, 337, 1, 337, 1, 337, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338,
		1, 338, 1, 338, 1, 338, 3, 338, 5534, 8, 338, 1, 338, 1, 338, 1, 338, 1,
		338, 1, 338, 5, 338, 5541, 8, 338, 10, 338, 12, 338, 5544, 9, 338, 3, 338,
		5546, 8, 338, 1, 338, 3, 338, 5549, 8, 338, 1, 339, 1, 339, 1, 339, 1,
		339, 5, 339, 5555, 8, 339, 10, 339, 12, 339, 5558, 9, 339, 1, 340, 1, 340,
		1, 340, 1, 340, 1, 340, 3, 340, 5565, 8, 340, 1, 340, 1, 340, 3, 340, 5569,
		8, 340, 1, 340, 1, 340, 1, 340, 3, 340, 5574, 8, 340, 1, 340, 1, 340, 1,
		340, 3, 340, 5579, 8, 340, 3, 340, 5581, 8, 340, 1, 340, 1, 340, 1, 340,
		1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 3, 340, 5591, 8, 340, 1, 340, 1,
		340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 3,
		340, 5603, 8, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 3, 340, 5610,
		8, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340,
		1, 340, 3, 340, 5621, 8, 340, 1, 340, 1, 340, 3, 340, 5625, 8, 340, 1,
		341, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 1,
		341, 3, 341, 5637, 8, 341, 1, 342, 1, 342, 1, 342, 1, 342, 3, 342, 5643,
		8, 342, 1, 343, 1, 343, 1, 343, 1, 343, 1, 344, 1, 344, 1, 344, 1, 344,
		1, 344, 1, 344, 1, 344, 3, 344, 5656, 8, 344, 1, 345, 1, 345, 1, 345, 1,
		345, 3, 345, 5662, 8, 345, 1, 346, 1, 346, 1, 346, 1, 346, 3, 346, 5668,
		8, 346, 1, 346, 1, 346, 1, 347, 1, 347, 1, 347, 5, 347, 5675, 8, 347, 10,
		347, 12, 347, 5678, 9, 347, 1, 348, 1, 348, 1, 348, 1, 348, 1, 348, 1,
		348, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 5, 349, 5691, 8, 349, 10,
		349, 12, 349, 5694, 9, 349, 1, 349, 1, 349, 3, 349, 5698, 8, 349, 1, 350,
		1, 350, 3, 350, 5702, 8, 350, 1, 350, 3, 350, 5705, 8, 350, 1, 350, 1,
		350, 1, 351, 1, 351, 3, 351, 5711, 8, 351, 1, 351, 3, 351, 5714, 8, 351,
		1, 351, 3, 351, 5717, 8, 351, 1, 352, 1, 352, 1, 352, 1, 352, 1, 352, 1,
		352, 1, 353, 1, 353, 1, 353, 1, 353, 1, 354, 1, 354, 1, 354, 1, 354, 1,
		354, 1, 354, 1, 355, 1, 355, 1, 355, 1, 355, 1, 356, 1, 356, 1, 356, 1,
		356, 1, 356, 3, 356, 5744, 8, 356, 1, 356, 1, 356, 3, 356, 5748, 8, 356,
		1, 356, 3, 356, 5751, 8, 356, 1, 357, 1, 357, 1, 357, 1, 357, 3, 357, 5757,
		8, 357, 1, 357, 1, 357, 1, 358, 1, 358, 1, 358, 1, 358, 3, 358, 5765, 8,
		358, 1, 358, 1, 358, 1, 359, 1, 359, 1, 359, 1, 359, 3, 359, 5773, 8, 359,
		1, 359, 1, 359, 1, 360, 1, 360, 3, 360, 5779, 8, 360, 1, 360, 1, 360, 3,
		360, 5783, 8, 360, 1, 360, 1, 360, 1, 361, 1, 361, 1, 361, 1, 361, 3, 361,
		5791, 8, 361, 1, 362, 1, 362, 1, 362, 1, 362, 1, 362, 1, 362, 1, 363, 1,
		363, 1, 363, 1, 363, 1, 363, 1, 363, 3, 363, 5805, 8, 363, 1, 363, 1, 363,
		1, 363, 1, 363, 1, 363, 1, 363, 1, 363, 3, 363, 5814, 8, 363, 3, 363, 5816,
		8, 363, 1, 364, 1, 364, 1, 364, 1, 364, 1, 364, 1, 365, 1, 365, 1, 365,
		1, 365, 1, 365, 1, 365, 1, 365, 1, 365, 3, 365, 5831, 8, 365, 1, 365, 1,
		365, 3, 365, 5835, 8, 365, 1, 365, 3, 365, 5838, 8, 365, 1, 366, 1, 366,
		1, 366, 1, 366, 1, 366, 1, 366, 1, 366, 3, 366, 5847, 8, 366, 1, 366, 1,
		366, 3, 366, 5851, 8, 366, 1, 367, 1, 367, 1, 367, 1, 367, 1, 367, 1, 367,
		1, 367, 1, 368, 1, 368, 1, 368, 1, 368, 1, 368, 1, 368, 1, 368, 1, 369,
		1, 369, 1, 369, 1, 369, 1, 369, 1, 369, 1, 369, 1, 369, 1, 370, 1, 370,
		1, 370, 1, 370, 1, 370, 3, 370, 5880, 8, 370, 1, 370, 1, 370, 3, 370, 5884,
		8, 370, 3, 370, 5886, 8, 370, 1, 371, 1, 371, 3, 371, 5890, 8, 371, 1,
		371, 1, 371, 3, 371, 5894, 8, 371, 1, 371, 3, 371, 5897, 8, 371, 1, 371,
		3, 371, 5900, 8, 371, 1, 371, 3, 371, 5903, 8, 371, 1, 372, 1, 372, 3,
		372, 5907, 8, 372, 1, 372, 1, 372, 3, 372, 5911, 8, 372, 1, 372, 3, 372,
		5914, 8, 372, 1, 372, 3, 372, 5917, 8, 372, 1, 372, 3, 372, 5920, 8, 372,
		1, 373, 1, 373, 1, 373, 1, 373, 1, 374, 1, 374, 1, 375, 4, 375, 5929, 8,
		375, 11, 375, 12, 375, 5930, 1, 376, 1, 376, 3, 376, 5935, 8, 376, 1, 376,
		1, 376, 3, 376, 5939, 8, 376, 1, 377, 3, 377, 5942, 8, 377, 1, 377, 1,
		377, 1, 378, 1, 378, 1, 378, 1, 378, 5, 378, 5950, 8, 378, 10, 378, 12,
		378, 5953, 9, 378, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379, 5, 379,
		5961, 8, 379, 10, 379, 12, 379, 5964, 9, 379, 3, 379, 5966, 8, 379, 1,
		379, 3, 379, 5969, 8, 379, 1, 380, 3, 380, 5972, 8, 380, 1, 380, 1, 380,
		1, 380, 1, 380, 1, 380, 1, 380, 1, 380, 3, 380, 5981, 8, 380, 1, 380, 1,
		380, 1, 380, 1, 380, 1, 380, 1, 380, 1, 380, 3, 380, 5990, 8, 380, 1, 380,
		1, 380, 1, 380, 1, 380, 3, 380, 5996, 8, 380, 1, 380, 1, 380, 1, 380, 1,
		380, 1, 380, 3, 380, 6003, 8, 380, 1, 381, 1, 381, 1, 382, 1, 382, 1, 382,
		3, 382, 6010, 8, 382, 1, 382, 1, 382, 1, 382, 3, 382, 6015, 8, 382, 1,
		382, 1, 382, 1, 382, 1, 382, 3, 382, 6021, 8, 382, 1, 382, 5, 382, 6024,
		8, 382, 10, 382, 12, 382, 6027, 9, 382, 1, 383, 1, 383, 1, 383, 1, 383,
		1, 384, 1, 384, 1, 384, 1, 384, 1, 385, 1, 385, 3, 385, 6039, 8, 385, 1,
		385, 1, 385, 3, 385, 6043, 8, 385, 1, 386, 1, 386, 1, 386, 3, 386, 6048,
		8, 386, 1, 387, 1, 387, 1, 387, 1, 387, 3, 387, 6054, 8, 387, 1, 387, 1,
		387, 1, 387, 1, 387, 1, 387, 3, 387, 6061, 8, 387, 1, 388, 1, 388, 3, 388,
		6065, 8, 388, 1, 388, 1, 388, 1, 388, 5, 388, 6070, 8, 388, 10, 388, 12,
		388, 6073, 9, 388, 1, 388, 1, 388, 1, 388, 3, 388, 6078, 8, 388, 1, 388,
		1, 388, 1, 388, 3, 388, 6083, 8, 388, 1, 388, 1, 388, 3, 388, 6087, 8,
		388, 1, 388, 1, 388, 1, 388, 1, 388, 1, 388, 3, 388, 6094, 8, 388, 1, 389,
		1, 389, 1, 389, 3, 389, 6099, 8, 389, 3, 389, 6101, 8, 389, 1, 389, 1,
		389, 3, 389, 6105, 8, 389, 1, 390, 1, 390, 1, 390, 3, 390, 6110, 8, 390,
		1, 390, 1, 390, 1, 390, 1, 390, 3, 390, 6116, 8, 390, 1, 390, 1, 390, 1,
		390, 1, 390, 1, 390, 1, 390, 1, 390, 5, 390, 6125, 8, 390, 10, 390, 12,
		390, 6128, 9, 390, 1, 390, 1, 390, 1, 390, 3, 390, 6133, 8, 390, 1, 391,
		1, 391, 3, 391, 6137, 8, 391, 1, 391, 1, 391, 5, 391, 6141, 8, 391, 10,
		391, 12, 391, 6144, 9, 391, 1, 391, 1, 391, 1, 392, 1, 392, 3, 392, 6150,
		8, 392, 1, 392, 1, 392, 1, 392, 1, 392, 1, 392, 1, 393, 1, 393, 1, 394,
		1, 394, 3, 394, 6161, 8, 394, 1, 394, 1, 394, 3, 394, 6165, 8, 394, 3,
		394, 6167, 8, 394, 1, 394, 1, 394, 1, 394, 1, 394, 3, 394, 6173, 8, 394,
		1, 394, 1, 394, 3, 394, 6177, 8, 394, 3, 394, 6179, 8, 394, 1, 395, 1,
		395, 1, 395, 1, 395, 1, 395, 5, 395, 6186, 8, 395, 10, 395, 12, 395, 6189,
		9, 395, 1, 395, 1, 395, 1, 396, 1, 396, 1, 396, 3, 396, 6196, 8, 396, 1,
		396, 5, 396, 6199, 8, 396, 10, 396, 12, 396, 6202, 9, 396, 1, 397, 1, 397,
		5, 397, 6206, 8, 397, 10, 397, 12, 397, 6209, 9, 397, 1, 397, 1, 397, 1,
		397, 5, 397, 6214, 8, 397, 10, 397, 12, 397, 6217, 9, 397, 1, 397, 1, 397,
		3, 397, 6221, 8, 397, 1, 398, 1, 398, 3, 398, 6225, 8, 398, 1, 398, 3,
		398, 6228, 8, 398, 1, 398, 3, 398, 6231, 8, 398, 1, 398, 3, 398, 6234,
		8, 398, 1, 398, 3, 398, 6237, 8, 398, 1, 398, 3, 398, 6240, 8, 398, 1,
		398, 3, 398, 6243, 8, 398, 1, 398, 3, 398, 6246, 8, 398, 1, 398, 1, 398,
		3, 398, 6250, 8, 398, 1, 398, 1, 398, 1, 398, 1, 398, 1, 398, 5, 398, 6257,
		8, 398, 10, 398, 12, 398, 6260, 9, 398, 1, 398, 1, 398, 3, 398, 6264, 8,
		398, 1, 398, 1, 398, 3, 398, 6268, 8, 398, 3, 398, 6270, 8, 398, 1, 398,
		1, 398, 3, 398, 6274, 8, 398, 1, 398, 1, 398, 3, 398, 6278, 8, 398, 3,
		398, 6280, 8, 398, 1, 398, 1, 398, 1, 398, 1, 398, 1, 398, 3, 398, 6287,
		8, 398, 1, 398, 1, 398, 3, 398, 6291, 8, 398, 3, 398, 6293, 8, 398, 1,
		398, 1, 398, 1, 398, 1, 398, 1, 398, 1, 398, 1, 398, 1, 398, 3, 398, 6303,
		8, 398, 1, 398, 1, 398, 3, 398, 6307, 8, 398, 3, 398, 6309, 8, 398, 1,
		398, 1, 398, 1, 398, 3, 398, 6314, 8, 398, 1, 398, 1, 398, 3, 398, 6318,
		8, 398, 3, 398, 6320, 8, 398, 1, 398, 1, 398, 1, 398, 1, 398, 3, 398, 6326,
		8, 398, 1, 399, 1, 399, 1, 399, 1, 399, 1, 399, 5, 399, 6333, 8, 399, 10,
		399, 12, 399, 6336, 9, 399, 1, 399, 1, 399, 1, 399, 3, 399, 6341, 8, 399,
		1, 399, 1, 399, 1, 399, 1, 399, 1, 399, 5, 399, 6348, 8, 399, 10, 399,
		12, 399, 6351, 9, 399, 1, 399, 1, 399, 1, 399, 1, 400, 1, 400, 3, 400,
		6358, 8, 400, 1, 400, 1, 400, 3, 400, 6362, 8, 400, 3, 400, 6364, 8, 400,
		1, 401, 1, 401, 3, 401, 6368, 8, 401, 1, 401, 3, 401, 6371, 8, 401, 1,
		401, 1, 401, 3, 401, 6375, 8, 401, 3, 401, 6377, 8, 401, 1, 402, 1, 402,
		3, 402, 6381, 8, 402, 1, 403, 1, 403, 3, 403, 6385, 8, 403, 1, 404, 1,
		404, 1, 404, 5, 404, 6390, 8, 404, 10, 404, 12, 404, 6393, 9, 404, 1, 405,
		1, 405, 1, 405, 1, 405, 1, 406, 1, 406, 3, 406, 6401, 8, 406, 1, 406, 3,
		406, 6404, 8, 406, 1, 406, 1, 406, 3, 406, 6408, 8, 406, 1, 406, 1, 406,
		3, 406, 6412, 8, 406, 1, 406, 3, 406, 6415, 8, 406, 1, 406, 1, 406, 1,
		406, 3, 406, 6420, 8, 406, 1, 407, 1, 407, 1, 407, 1, 407, 1, 407, 1, 407,
		3, 407, 6428, 8, 407, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1,
		408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1,
		408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1,
		408, 1, 408, 1, 408, 3, 408, 6457, 8, 408, 1, 409, 1, 409, 1, 409, 1, 409,
		5, 409, 6463, 8, 409, 10, 409, 12, 409, 6466, 9, 409, 1, 409, 1, 409, 1,
		409, 1, 409, 1, 409, 1, 409, 1, 409, 1, 409, 1, 409, 3, 409, 6477, 8, 409,
		1, 410, 1, 410, 1, 410, 1, 410, 1, 411, 1, 411, 1, 411, 1, 411, 1, 411,
		1, 411, 1, 411, 5, 411, 6490, 8, 411, 10, 411, 12, 411, 6493, 9, 411, 1,
		411, 1, 411, 3, 411, 6497, 8, 411, 1, 412, 1, 412, 1, 412, 1, 412, 5, 412,
		6503, 8, 412, 10, 412, 12, 412, 6506, 9, 412, 1, 412, 1, 412, 1, 413, 3,
		413, 6511, 8, 413, 1, 413, 1, 413, 1, 413, 1, 413, 1, 413, 5, 413, 6518,
		8, 413, 10, 413, 12, 413, 6521, 9, 413, 1, 413, 1, 413, 1, 413, 3, 413,
		6526, 8, 413, 1, 413, 1, 413, 1, 413, 3, 413, 6531, 8, 413, 1, 414, 1,
		414, 1, 414, 1, 414, 1, 414, 5, 414, 6538, 8, 414, 10, 414, 12, 414, 6541,
		9, 414, 1, 414, 1, 414, 1, 415, 1, 415, 1, 415, 1, 415, 1, 415, 5, 415,
		6550, 8, 415, 10, 415, 12, 415, 6553, 9, 415, 1, 415, 1, 415, 1, 416, 1,
		416, 1, 416, 1, 416, 1, 416, 1, 417, 1, 417, 3, 417, 6564, 8, 417, 1, 418,
		1, 418, 1, 418, 1, 418, 1, 418, 1, 418, 1, 418, 1, 418, 5, 418, 6574, 8,
		418, 10, 418, 12, 418, 6577, 9, 418, 3, 418, 6579, 8, 418, 1, 419, 1, 419,
		1, 419, 1, 419, 1, 420, 1, 420, 1, 420, 1, 420, 1, 420, 5, 420, 6590, 8,
		420, 10, 420, 12, 420, 6593, 9, 420, 1, 420, 1, 420, 1, 421, 1, 421, 1,
		421, 1, 421, 5, 421, 6601, 8, 421, 10, 421, 12, 421, 6604, 9, 421, 1, 421,
		1, 421, 1, 422, 1, 422, 3, 422, 6610, 8, 422, 1, 423, 1, 423, 1, 423, 5,
		423, 6615, 8, 423, 10, 423, 12, 423, 6618, 9, 423, 1, 424, 1, 424, 1, 424,
		1, 424, 1, 425, 1, 425, 1, 425, 1, 426, 1, 426, 3, 426, 6629, 8, 426, 1,
		426, 1, 426, 1, 426, 3, 426, 6634, 8, 426, 1, 426, 1, 426, 1, 426, 1, 426,
		1, 426, 1, 426, 5, 426, 6642, 8, 426, 10, 426, 12, 426, 6645, 9, 426, 1,
		427, 1, 427, 1, 427, 5, 427, 6650, 8, 427, 10, 427, 12, 427, 6653, 9, 427,
		1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 3, 428, 6661, 8, 428, 1,
		428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1,
		428, 1, 428, 5, 428, 6674, 8, 428, 10, 428, 12, 428, 6677, 9, 428, 1, 429,
		1, 429, 3, 429, 6681, 8, 429, 1, 429, 3, 429, 6684, 8, 429, 1, 430, 1,
		430, 1, 430, 1, 430, 4, 430, 6690, 8, 430, 11, 430, 12, 430, 6691, 1, 430,
		1, 430, 3, 430, 6696, 8, 430, 1, 430, 1, 430, 1, 430, 1, 430, 1, 430, 1,
		431, 3, 431, 6704, 8, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431,
		3, 431, 6712, 8, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 3,
		431, 6720, 8, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 3, 431,
		6728, 8, 431, 1, 431, 1, 431, 3, 431, 6732, 8, 431, 1, 432, 1, 432, 1,
		432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1,
		432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1,
		432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 5, 432, 6761, 8, 432,
		10, 432, 12, 432, 6764, 9, 432, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433,
		1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433,
		1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433,
		1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433,
		1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433,
		1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 4, 433, 6813, 8, 433, 11,
		433, 12, 433, 6814, 1, 433, 1, 433, 3, 433, 6819, 8, 433, 1, 433, 1, 433,
		1, 433, 1, 433, 4, 433, 6825, 8, 433, 11, 433, 12, 433, 6826, 1, 433, 1,
		433, 3, 433, 6831, 8, 433, 1, 433, 1, 433, 1, 433, 3, 433, 6836, 8, 433,
		1, 433, 1, 433, 3, 433, 6840, 8, 433, 1, 433, 1, 433, 1, 433, 1, 433, 3,
		433, 6846, 8, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 3, 433, 6853,
		8, 433, 1, 433, 1, 433, 1, 433, 3, 433, 6858, 8, 433, 1, 433, 1, 433, 1,
		433, 1, 433, 1, 433, 1, 433, 1, 433, 3, 433, 6867, 8, 433, 1, 433, 1, 433,
		3, 433, 6871, 8, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 3, 433, 6878,
		8, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 3, 433, 6886, 8,
		433, 1, 433, 1, 433, 1, 433, 1, 433, 3, 433, 6892, 8, 433, 1, 433, 1, 433,
		1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 3, 433, 6902, 8, 433, 1,
		433, 1, 433, 3, 433, 6906, 8, 433, 1, 433, 1, 433, 1, 433, 1, 433, 5, 433,
		6912, 8, 433, 10, 433, 12, 433, 6915, 9, 433, 1, 434, 1, 434, 1, 434, 1,
		434, 1, 434, 1, 434, 1, 434, 1, 434, 1, 434, 1, 434, 3, 434, 6927, 8, 434,
		1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435,
		1, 435, 1, 435, 1, 435, 5, 435, 6941, 8, 435, 10, 435, 12, 435, 6944, 9,
		435, 3, 435, 6946, 8, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435,
		5, 435, 6954, 8, 435, 10, 435, 12, 435, 6957, 9, 435, 3, 435, 6959, 8,
		435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 3, 435, 6967, 8, 435,
		1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 5, 435,
		6977, 8, 435, 10, 435, 12, 435, 6980, 9, 435, 3, 435, 6982, 8, 435, 1,
		435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 5, 435, 6990, 8, 435, 10,
		435, 12, 435, 6993, 9, 435, 3, 435, 6995, 8, 435, 1, 435, 1, 435, 3, 435,
		6999, 8, 435, 3, 435, 7001, 8, 435, 1, 436, 1, 436, 1, 436, 3, 436, 7006,
		8, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 3, 436, 7014, 8,
		436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 3, 436, 7021, 8, 436, 3, 436,
		7023, 8, 436, 1, 436, 1, 436, 1, 436, 5, 436, 7028, 8, 436, 10, 436, 12,
		436, 7031, 9, 436, 3, 436, 7033, 8, 436, 1, 436, 1, 436, 1, 436, 1, 436,
		3, 436, 7039, 8, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 3,
		436, 7047, 8, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 3, 436,
		7055, 8, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 3, 436, 7063,
		8, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 5, 436, 7071, 8,
		436, 10, 436, 12, 436, 7074, 9, 436, 3, 436, 7076, 8, 436, 1, 436, 1, 436,
		1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 5, 436,
		7088, 8, 436, 10, 436, 12, 436, 7091, 9, 436, 3, 436, 7093, 8, 436, 1,
		436, 1, 436, 1, 436, 1, 436, 1, 436, 3, 436, 7100, 8, 436, 1, 436, 1, 436,
		1, 436, 5, 436, 7105, 8, 436, 10, 436, 12, 436, 7108, 9, 436, 1, 436, 1,
		436, 1, 436, 1, 436, 1, 436, 5, 436, 7115, 8, 436, 10, 436, 12, 436, 7118,
		9, 436, 3, 436, 7120, 8, 436, 1, 436, 1, 436, 3, 436, 7124, 8, 436, 1,
		436, 1, 436, 3, 436, 7128, 8, 436, 1, 437, 1, 437, 1, 437, 1, 438, 1, 438,
		1, 438, 1, 438, 1, 438, 3, 438, 7138, 8, 438, 1, 438, 1, 438, 1, 439, 1,
		439, 1, 440, 1, 440, 1, 440, 1, 440, 1, 440, 1, 440, 1, 440, 1, 440, 1,
		440, 1, 440, 1, 440, 1, 440, 1, 440, 1, 440, 1, 440, 3, 440, 7159, 8, 440,
		1, 440, 1, 440, 1, 440, 3, 440, 7164, 8, 440, 1, 440, 1, 440, 1, 440, 3,
		440, 7169, 8, 440, 3, 440, 7171, 8, 440, 1, 441, 1, 441, 1, 441, 3, 441,
		7176, 8, 441, 1, 441, 1, 441, 1, 441, 3, 441, 7181, 8, 441, 1, 441, 1,
		441, 1, 441, 3, 441, 7186, 8, 441, 1, 441, 3, 441, 7189, 8, 441, 1, 441,
		1, 441, 1, 441, 3, 441, 7194, 8, 441, 1, 441, 1, 441, 1, 441, 3, 441, 7199,
		8, 441, 3, 441, 7201, 8, 441, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1,
		442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1,
		442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 5, 442, 7223, 8, 442, 10,
		442, 12, 442, 7226, 9, 442, 3, 442, 7228, 8, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 5, 442, 7279, 8, 442, 10, 442, 12, 442, 7282, 9, 442, 3, 442, 7284,
		8, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 3, 442, 7344, 8, 442, 1, 443, 1,
		443, 1, 443, 1, 443, 1, 443, 1, 443, 1, 443, 1, 443, 1, 443, 1, 443, 1,
		443, 1, 443, 1, 443, 1, 443, 1, 443, 1, 443, 1, 443, 1, 443, 3, 443, 7364,
		8, 443, 1, 443, 1, 443, 1, 443, 1, 443, 1, 443, 3, 443, 7371, 8, 443, 1,
		443, 1, 443, 5, 443, 7375, 8, 443, 10, 443, 12, 443, 7378, 9, 443, 3, 443,
		7380, 8, 443, 1, 443, 1, 443, 3, 443, 7384, 8, 443, 1, 443, 1, 443, 1,
		443, 1, 443, 3, 443, 7390, 8, 443, 1, 443, 1, 443, 5, 443, 7394, 8, 443,
		10, 443, 12, 443, 7397, 9, 443, 3, 443, 7399, 8, 443, 1, 443, 1, 443, 3,
		443, 7403, 8, 443, 1, 443, 1, 443, 1, 443, 1, 443, 3, 443, 7409, 8, 443,
		1, 443, 1, 443, 5, 443, 7413, 8, 443, 10, 443, 12, 443, 7416, 9, 443, 3,
		443, 7418, 8, 443, 1, 443, 1, 443, 3, 443, 7422, 8, 443, 1, 443, 1, 443,
		1, 443, 1, 443, 3, 443, 7428, 8, 443, 1, 443, 1, 443, 5, 443, 7432, 8,
		443, 10, 443, 12, 443, 7435, 9, 443, 3, 443, 7437, 8, 443, 1, 443, 1, 443,
		3, 443, 7441, 8, 443, 3, 443, 7443, 8, 443, 1, 444, 1, 444, 1, 444, 1,
		444, 1, 444, 1, 445, 1, 445, 1, 445, 3, 445, 7453, 8, 445, 1, 445, 1, 445,
		1, 445, 1, 445, 1, 445, 5, 445, 7460, 8, 445, 10, 445, 12, 445, 7463, 9,
		445, 3, 445, 7465, 8, 445, 1, 445, 1, 445, 1, 445, 1, 445, 1, 445, 5, 445,
		7472, 8, 445, 10, 445, 12, 445, 7475, 9, 445, 3, 445, 7477, 8, 445, 1,
		445, 3, 445, 7480, 8, 445, 1, 445, 1, 445, 1, 446, 1, 446, 1, 446, 1, 447,
		1, 447, 1, 447, 1, 447, 1, 447, 1, 447, 1, 447, 1, 447, 1, 447, 1, 447,
		1, 447, 1, 447, 1, 447, 1, 447, 1, 447, 1, 447, 3, 447, 7503, 8, 447, 1,
		448, 1, 448, 1, 448, 1, 448, 1, 448, 1, 448, 1, 448, 1, 448, 1, 448, 3,
		448, 7514, 8, 448, 1, 449, 1, 449, 1, 449, 1, 449, 1, 449, 1, 449, 1, 449,
		3, 449, 7523, 8, 449, 3, 449, 7525, 8, 449, 1, 449, 1, 449, 1, 449, 1,
		449, 3, 449, 7531, 8, 449, 1, 449, 1, 449, 1, 449, 1, 449, 1, 449, 1, 449,
		1, 449, 1, 449, 3, 449, 7541, 8, 449, 3, 449, 7543, 8, 449, 1, 449, 1,
		449, 1, 449, 1, 449, 1, 449, 1, 449, 3, 449, 7551, 8, 449, 3, 449, 7553,
		8, 449, 3, 449, 7555, 8, 449, 1, 450, 1, 450, 3, 450, 7559, 8, 450, 1,
		451, 1, 451, 3, 451, 7563, 8, 451, 1, 451, 1, 451, 3, 451, 7567, 8, 451,
		1, 452, 1, 452, 3, 452, 7571, 8, 452, 1, 453, 1, 453, 1, 453, 3, 453, 7576,
		8, 453, 1, 454, 1, 454, 3, 454, 7580, 8, 454, 1, 455, 1, 455, 1, 455, 1,
		455, 1, 455, 1, 455, 1, 455, 1, 455, 5, 455, 7590, 8, 455, 10, 455, 12,
		455, 7593, 9, 455, 3, 455, 7595, 8, 455, 1, 455, 1, 455, 1, 455, 1, 455,
		1, 455, 1, 455, 1, 455, 1, 455, 1, 455, 1, 455, 5, 455, 7607, 8, 455, 10,
		455, 12, 455, 7610, 9, 455, 3, 455, 7612, 8, 455, 1, 455, 1, 455, 1, 455,
		1, 455, 1, 455, 3, 455, 7619, 8, 455, 1, 455, 1, 455, 1, 455, 1, 455, 1,
		455, 5, 455, 7626, 8, 455, 10, 455, 12, 455, 7629, 9, 455, 3, 455, 7631,
		8, 455, 1, 455, 1, 455, 1, 455, 1, 455, 1, 455, 3, 455, 7638, 8, 455, 1,
		455, 1, 455, 1, 455, 1, 455, 1, 455, 1, 455, 1, 455, 1, 455, 5, 455, 7648,
		8, 455, 10, 455, 12, 455, 7651, 9, 455, 3, 455, 7653, 8, 455, 1, 455, 1,
		455, 1, 455, 1, 455, 1, 455, 1, 455, 1, 455, 1, 455, 1, 455, 1, 455, 5,
		455, 7665, 8, 455, 10, 455, 12, 455, 7668, 9, 455, 3, 455, 7670, 8, 455,
		1, 456, 1, 456, 3, 456, 7674, 8, 456, 1, 457, 1, 457, 1, 457, 1, 457, 3,
		457, 7680, 8, 457, 1, 457, 1, 457, 1, 457, 1, 457, 1, 457, 3, 457, 7687,
		8, 457, 1, 458, 1, 458, 1, 458, 1, 458, 3, 458, 7693, 8, 458, 1, 458, 1,
		458, 1, 458, 1, 458, 1, 458, 3, 458, 7700, 8, 458, 1, 459, 1, 459, 1, 459,
		1, 459, 5, 459, 7706, 8, 459, 10, 459, 12, 459, 7709, 9, 459, 1, 459, 1,
		459, 1, 460, 1, 460, 1, 460, 1, 460, 5, 460, 7717, 8, 460, 10, 460, 12,
		460, 7720, 9, 460, 1, 460, 1, 460, 1, 461, 1, 461, 3, 461, 7726, 8, 461,
		1, 462, 1, 462, 3, 462, 7730, 8, 462, 1, 463, 1, 463, 1, 463, 1, 463, 5,
		463, 7736, 8, 463, 10, 463, 12, 463, 7739, 9, 463, 1, 463, 1, 463, 1, 464,
		1, 464, 1, 464, 1, 464, 5, 464, 7747, 8, 464, 10, 464, 12, 464, 7750, 9,
		464, 1, 464, 1, 464, 1, 465, 1, 465, 3, 465, 7756, 8, 465, 1, 466, 1, 466,
		1, 466, 1, 466, 3, 466, 7762, 8, 466, 1, 466, 1, 466, 1, 466, 1, 466, 3,
		466, 7768, 8, 466, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467,
		1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467,
		1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467,
		1, 467, 3, 467, 7796, 8, 467, 1, 468, 1, 468, 1, 468, 1, 468, 1, 468, 1,
		468, 1, 468, 1, 468, 1, 468, 1, 469, 1, 469, 1, 469, 1, 469, 3, 469, 7811,
		8, 469, 1, 469, 1, 469, 1, 469, 1, 469, 1, 469, 1, 469, 3, 469, 7819, 8,
		469, 1, 470, 1, 470, 1, 470, 1, 470, 5, 470, 7825, 8, 470, 10, 470, 12,
		470, 7828, 9, 470, 1, 470, 1, 470, 1, 471, 1, 471, 1, 471, 1, 471, 1, 472,
		1, 472, 3, 472, 7838, 8, 472, 1, 473, 1, 473, 1, 473, 1, 473, 1, 473, 1,
		473, 3, 473, 7846, 8, 473, 1, 473, 1, 473, 1, 473, 1, 473, 3, 473, 7852,
		8, 473, 1, 474, 1, 474, 1, 474, 1, 474, 1, 474, 1, 474, 3, 474, 7860, 8,
		474, 1, 474, 1, 474, 1, 474, 1, 474, 1, 474, 1, 474, 1, 474, 1, 474, 1,
		474, 3, 474, 7871, 8, 474, 3, 474, 7873, 8, 474, 1, 475, 1, 475, 3, 475,
		7877, 8, 475, 1, 475, 1, 475, 1, 475, 1, 475, 1, 475, 1, 475, 1, 475, 3,
		475, 7886, 8, 475, 1, 475, 1, 475, 1, 475, 1, 475, 1, 475, 1, 475, 1, 475,
		3, 475, 7895, 8, 475, 1, 476, 1, 476, 1, 477, 1, 477, 1, 477, 1, 477, 1,
		477, 5, 477, 7904, 8, 477, 10, 477, 12, 477, 7907, 9, 477, 1, 477, 1, 477,
		1, 478, 1, 478, 1, 478, 1, 479, 1, 479, 1, 479, 1, 479, 5, 479, 7918, 8,
		479, 10, 479, 12, 479, 7921, 9, 479, 1, 479, 1, 479, 1, 480, 1, 480, 1,
		480, 5, 480, 7928, 8, 480, 10, 480, 12, 480, 7931, 9, 480, 1, 481, 1, 481,
		1, 481, 1, 481, 1, 482, 1, 482, 5, 482, 7939, 8, 482, 10, 482, 12, 482,
		7942, 9, 482, 1, 483, 1, 483, 1, 483, 1, 483, 1, 484, 1, 484, 1, 485, 1,
		485, 1, 485, 1, 486, 1, 486, 1, 486, 1, 486, 3, 486, 7957, 8, 486, 1, 486,
		3, 486, 7960, 8, 486, 1, 487, 1, 487, 1, 487, 1, 487, 3, 487, 7966, 8,
		487, 1, 488, 1, 488, 1, 489, 1, 489, 1, 490, 1, 490, 1, 491, 1, 491, 1,
		492, 1, 492, 1, 492, 1, 492, 1, 493, 1, 493, 1, 493, 1, 493, 1, 494, 1,
		494, 1, 495, 1, 495, 1, 496, 1, 496, 1, 497, 1, 497, 1, 497, 1, 497, 1,
		497, 3, 497, 7995, 8, 497, 1, 498, 1, 498, 1, 498, 1, 498, 1, 498, 1, 499,
		1, 499, 1, 499, 1, 499, 1, 499, 1, 499, 1, 499, 1, 500, 1, 500, 3, 500,
		8011, 8, 500, 1, 500, 1, 500, 1, 501, 1, 501, 1, 501, 5, 501, 8018, 8,
		501, 10, 501, 12, 501, 8021, 9, 501, 1, 502, 1, 502, 1, 502, 1, 502, 1,
		502, 1, 503, 1, 503, 1, 503, 1, 503, 1, 504, 1, 504, 1, 504, 3, 504, 8035,
		8, 504, 1, 504, 1, 504, 3, 504, 8039, 8, 504, 1, 504, 1, 504, 3, 504, 8043,
		8, 504, 1, 504, 1, 504, 3, 504, 8047, 8, 504, 1, 504, 1, 504, 3, 504, 8051,
		8, 504, 1, 504, 1, 504, 3, 504, 8055, 8, 504, 1, 504, 1, 504, 3, 504, 8059,
		8, 504, 1, 504, 1, 504, 3, 504, 8063, 8, 504, 1, 504, 1, 504, 3, 504, 8067,
		8, 504, 1, 504, 1, 504, 3, 504, 8071, 8, 504, 1, 504, 1, 504, 1, 504, 1,
		504, 1, 504, 1, 504, 1, 504, 3, 504, 8080, 8, 504, 1, 504, 1, 504, 3, 504,
		8084, 8, 504, 1, 504, 1, 504, 1, 504, 1, 504, 1, 504, 1, 504, 1, 504, 1,
		504, 3, 504, 8094, 8, 504, 1, 504, 1, 504, 3, 504, 8098, 8, 504, 3, 504,
		8100, 8, 504, 1, 505, 1, 505, 1, 505, 1, 505, 1, 505, 3, 505, 8107, 8,
		505, 1, 505, 3, 505, 8110, 8, 505, 1, 506, 1, 506, 1, 506, 1, 506, 5, 506,
		8116, 8, 506, 10, 506, 12, 506, 8119, 9, 506, 1, 507, 1, 507, 1, 508, 3,
		508, 8124, 8, 508, 1, 508, 1, 508, 1, 508, 1, 508, 1, 508, 1, 509, 1, 509,
		1, 509, 1, 509, 3, 509, 8135, 8, 509, 1, 510, 1, 510, 1, 510, 3, 510, 8140,
		8, 510, 1, 511, 1, 511, 1, 511, 1, 511, 5, 511, 8146, 8, 511, 10, 511,
		12, 511, 8149, 9, 511, 1, 511, 1, 511, 1, 512, 1, 512, 1, 512, 1, 512,
		5, 512, 8157, 8, 512, 10, 512, 12, 512, 8160, 9, 512, 1, 512, 1, 512, 1,
		513, 1, 513, 3, 513, 8166, 8, 513, 1, 514, 1, 514, 1, 514, 5, 514, 8171,
		8, 514, 10, 514, 12, 514, 8174, 9, 514, 1, 515, 1, 515, 1, 515, 3, 515,
		8179, 8, 515, 1, 516, 1, 516, 1, 516, 1, 516, 1, 516, 1, 516, 1, 516, 1,
		516, 1, 516, 1, 516, 1, 516, 3, 516, 8192, 8, 516, 1, 517, 1, 517, 1, 517,
		1, 517, 1, 518, 1, 518, 1, 518, 5, 518, 8201, 8, 518, 10, 518, 12, 518,
		8204, 9, 518, 1, 519, 1, 519, 1, 519, 3, 519, 8209, 8, 519, 1, 520, 1,
		520, 1, 520, 1, 4135, 5, 764, 852, 856, 864, 866, 521, 0, 2, 4, 6, 8, 10,
		12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46,
		48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82,
		84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114,
		116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144,
		146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174,
		176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204,
		206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234,
		236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264,
		266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294,
		296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322, 324,
		326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354,
		356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 382, 384,
		386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408, 410, 412, 414,
		416, 418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442, 444,
		446, 448, 450, 452, 454, 456, 458, 460, 462, 464, 466, 468, 470, 472, 474,
		476, 478, 480, 482, 484, 486, 488, 490, 492, 494, 496, 498, 500, 502, 504,
		506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534,
		536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562, 564,
		566, 568, 570, 572, 574, 576, 578, 580, 582, 584, 586, 588, 590, 592, 594,
		596, 598, 600, 602, 604, 606, 608, 610, 612, 614, 616, 618, 620, 622, 624,
		626, 628, 630, 632, 634, 636, 638, 640, 642, 644, 646, 648, 650, 652, 654,
		656, 658, 660, 662, 664, 666, 668, 670, 672, 674, 676, 678, 680, 682, 684,
		686, 688, 690, 692, 694, 696, 698, 700, 702, 704, 706, 708, 710, 712, 714,
		716, 718, 720, 722, 724, 726, 728, 730, 732, 734, 736, 738, 740, 742, 744,
		746, 748, 750, 752, 754, 756, 758, 760, 762, 764, 766, 768, 770, 772, 774,
		776, 778, 780, 782, 784, 786, 788, 790, 792, 794, 796, 798, 800, 802, 804,
		806, 808, 810, 812, 814, 816, 818, 820, 822, 824, 826, 828, 830, 832, 834,
		836, 838, 840, 842, 844, 846, 848, 850, 852, 854, 856, 858, 860, 862, 864,
		866, 868, 870, 872, 874, 876, 878, 880, 882, 884, 886, 888, 890, 892, 894,
		896, 898, 900, 902, 904, 906, 908, 910, 912, 914, 916, 918, 920, 922, 924,
		926, 928, 930, 932, 934, 936, 938, 940, 942, 944, 946, 948, 950, 952, 954,
		956, 958, 960, 962, 964, 966, 968, 970, 972, 974, 976, 978, 980, 982, 984,
		986, 988, 990, 992, 994, 996, 998, 1000, 1002, 1004, 1006, 1008, 1010,
		1012, 1014, 1016, 1018, 1020, 1022, 1024, 1026, 1028, 1030, 1032, 1034,
		1036, 1038, 1040, 0, 65, 1, 1, 532, 532, 2, 0, 172, 172, 202, 202, 2, 0,
		104, 104, 387, 387, 2, 0, 151, 151, 428, 428, 4, 0, 17, 17, 134, 134, 323,
		323, 451, 451, 4, 0, 44, 44, 220, 220, 276, 276, 466, 466, 2, 0, 77, 77,
		157, 157, 3, 0, 76, 76, 294, 294, 376, 376, 1, 0, 125, 126, 2, 0, 205,
		206, 227, 228, 2, 0, 219, 219, 280, 280, 2, 0, 13, 13, 270, 270, 2, 0,
		29, 29, 417, 417, 2, 0, 127, 127, 137, 137, 2, 0, 167, 167, 286, 286, 2,
		0, 202, 202, 440, 440, 2, 0, 38, 38, 94, 94, 3, 0, 109, 109, 194, 194,
		265, 265, 2, 0, 218, 218, 221, 221, 2, 0, 175, 175, 384, 384, 2, 0, 224,
		224, 408, 408, 2, 0, 54, 54, 178, 178, 2, 0, 17, 17, 422, 422, 2, 0, 176,
		176, 328, 328, 1, 0, 424, 425, 2, 0, 142, 142, 475, 475, 1, 0, 458, 459,
		2, 0, 27, 27, 55, 55, 1, 0, 60, 61, 2, 0, 173, 173, 518, 518, 2, 0, 71,
		71, 73, 73, 3, 0, 419, 419, 434, 434, 468, 468, 3, 0, 145, 145, 266, 266,
		450, 450, 2, 0, 28, 28, 125, 125, 2, 0, 161, 161, 233, 233, 2, 0, 18, 18,
		128, 128, 1, 0, 145, 146, 1, 0, 303, 304, 2, 0, 110, 110, 132, 132, 2,
		0, 21, 21, 506, 506, 2, 0, 297, 297, 505, 505, 3, 0, 240, 240, 350, 350,
		372, 372, 3, 0, 268, 268, 502, 504, 508, 508, 1, 0, 500, 501, 2, 0, 500,
		501, 512, 512, 1, 0, 106, 107, 2, 0, 166, 166, 320, 320, 1, 0, 176, 177,
		1, 0, 422, 423, 1, 0, 469, 470, 2, 0, 125, 126, 149, 149, 5, 0, 20, 20,
		88, 88, 250, 250, 386, 386, 467, 467, 5, 0, 18, 18, 249, 249, 346, 346,
		433, 433, 462, 462, 2, 0, 120, 120, 199, 199, 2, 0, 12, 12, 203, 203, 4,
		0, 178, 178, 244, 244, 395, 395, 467, 467, 1, 0, 521, 522, 1, 0, 523, 524,
		1, 0, 492, 498, 2, 0, 156, 156, 444, 444, 4, 0, 108, 108, 193, 193, 264,
		264, 389, 389, 9, 0, 108, 108, 193, 193, 261, 262, 264, 264, 271, 271,
		337, 337, 389, 389, 476, 476, 483, 483, 2, 0, 62, 62, 164, 164, 2, 0, 111,
		115, 284, 285, 93, 0, 11, 12, 14, 17, 22, 23, 25, 26, 29, 40, 43, 43, 45,
		49, 51, 54, 56, 57, 59, 63, 66, 66, 68, 73, 75, 75, 77, 81, 83, 86, 88,
		89, 93, 95, 102, 103, 106, 110, 116, 116, 121, 123, 127, 127, 129, 130,
		134, 135, 137, 147, 150, 155, 157, 158, 160, 161, 164, 167, 170, 171, 173,
		174, 177, 178, 180, 180, 185, 186, 188, 189, 191, 196, 198, 198, 201, 201,
		203, 204, 206, 206, 209, 209, 213, 215, 217, 217, 221, 221, 223, 224, 230,
		230, 233, 233, 238, 239, 242, 242, 244, 244, 247, 258, 260, 260, 263, 267,
		269, 280, 283, 289, 291, 293, 295, 296, 304, 309, 311, 321, 324, 327, 329,
		342, 344, 344, 346, 349, 352, 352, 354, 355, 357, 368, 370, 370, 373, 378,
		381, 386, 389, 390, 392, 395, 397, 397, 399, 400, 403, 412, 414, 417, 419,
		421, 423, 428, 430, 430, 432, 436, 438, 439, 441, 443, 445, 449, 452, 453,
		456, 456, 458, 459, 461, 461, 463, 463, 465, 476, 479, 479, 481, 488, 490,
		491, 499, 499, 533, 533, 9260, 0, 1043, 1, 0, 0, 0, 2, 1053, 1, 0, 0, 0,
		4, 1055, 1, 0, 0, 0, 6, 1297, 1, 0, 0, 0, 8, 1299, 1, 0, 0, 0, 10, 1302,
		1, 0, 0, 0, 12, 1305, 1, 0, 0, 0, 14, 1329, 1, 0, 0, 0, 16, 1347, 1, 0,
		0, 0, 18, 1349, 1, 0, 0, 0, 20, 1371, 1, 0, 0, 0, 22, 1386, 1, 0, 0, 0,
		24, 1391, 1, 0, 0, 0, 26, 1397, 1, 0, 0, 0, 28, 1407, 1, 0, 0, 0, 30, 1409,
		1, 0, 0, 0, 32, 1417, 1, 0, 0, 0, 34, 1475, 1, 0, 0, 0, 36, 1507, 1, 0,
		0, 0, 38, 1509, 1, 0, 0, 0, 40, 1521, 1, 0, 0, 0, 42, 1524, 1, 0, 0, 0,
		44, 1536, 1, 0, 0, 0, 46, 1541, 1, 0, 0, 0, 48, 1556, 1, 0, 0, 0, 50, 1564,
		1, 0, 0, 0, 52, 1568, 1, 0, 0, 0, 54, 1575, 1, 0, 0, 0, 56, 1577, 1, 0,
		0, 0, 58, 1581, 1, 0, 0, 0, 60, 1602, 1, 0, 0, 0, 62, 1604, 1, 0, 0, 0,
		64, 1616, 1, 0, 0, 0, 66, 1627, 1, 0, 0, 0, 68, 1631, 1, 0, 0, 0, 70, 1636,
		1, 0, 0, 0, 72, 1641, 1, 0, 0, 0, 74, 1643, 1, 0, 0, 0, 76, 1705, 1, 0,
		0, 0, 78, 1718, 1, 0, 0, 0, 80, 1762, 1, 0, 0, 0, 82, 1764, 1, 0, 0, 0,
		84, 1779, 1, 0, 0, 0, 86, 1785, 1, 0, 0, 0, 88, 1788, 1, 0, 0, 0, 90, 1803,
		1, 0, 0, 0, 92, 1816, 1, 0, 0, 0, 94, 1826, 1, 0, 0, 0, 96, 1844, 1, 0,
		0, 0, 98, 1857, 1, 0, 0, 0, 100, 1929, 1, 0, 0, 0, 102, 1931, 1, 0, 0,
		0, 104, 1940, 1, 0, 0, 0, 106, 1963, 1, 0, 0, 0, 108, 1972, 1, 0, 0, 0,
		110, 1976, 1, 0, 0, 0, 112, 2008, 1, 0, 0, 0, 114, 2010, 1, 0, 0, 0, 116,
		2036, 1, 0, 0, 0, 118, 2042, 1, 0, 0, 0, 120, 2116, 1, 0, 0, 0, 122, 2118,
		1, 0, 0, 0, 124, 2126, 1, 0, 0, 0, 126, 2130, 1, 0, 0, 0, 128, 2149, 1,
		0, 0, 0, 130, 2151, 1, 0, 0, 0, 132, 2157, 1, 0, 0, 0, 134, 2170, 1, 0,
		0, 0, 136, 2223, 1, 0, 0, 0, 138, 2232, 1, 0, 0, 0, 140, 2234, 1, 0, 0,
		0, 142, 2247, 1, 0, 0, 0, 144, 2272, 1, 0, 0, 0, 146, 2274, 1, 0, 0, 0,
		148, 2298, 1, 0, 0, 0, 150, 2306, 1, 0, 0, 0, 152, 2317, 1, 0, 0, 0, 154,
		2323, 1, 0, 0, 0, 156, 2331, 1, 0, 0, 0, 158, 2340, 1, 0, 0, 0, 160, 2353,
		1, 0, 0, 0, 162, 2360, 1, 0, 0, 0, 164, 2368, 1, 0, 0, 0, 166, 2376, 1,
		0, 0, 0, 168, 2391, 1, 0, 0, 0, 170, 2402, 1, 0, 0, 0, 172, 2404, 1, 0,
		0, 0, 174, 2415, 1, 0, 0, 0, 176, 2422, 1, 0, 0, 0, 178, 2426, 1, 0, 0,
		0, 180, 2437, 1, 0, 0, 0, 182, 2441, 1, 0, 0, 0, 184, 2455, 1, 0, 0, 0,
		186, 2460, 1, 0, 0, 0, 188, 2468, 1, 0, 0, 0, 190, 2474, 1, 0, 0, 0, 192,
		2479, 1, 0, 0, 0, 194, 2496, 1, 0, 0, 0, 196, 2500, 1, 0, 0, 0, 198, 2504,
		1, 0, 0, 0, 200, 2511, 1, 0, 0, 0, 202, 2520, 1, 0, 0, 0, 204, 2534, 1,
		0, 0, 0, 206, 2536, 1, 0, 0, 0, 208, 2539, 1, 0, 0, 0, 210, 2543, 1, 0,
		0, 0, 212, 2548, 1, 0, 0, 0, 214, 2555, 1, 0, 0, 0, 216, 2576, 1, 0, 0,
		0, 218, 2587, 1, 0, 0, 0, 220, 2605, 1, 0, 0, 0, 222, 2611, 1, 0, 0, 0,
		224, 2615, 1, 0, 0, 0, 226, 2620, 1, 0, 0, 0, 228, 2631, 1, 0, 0, 0, 230,
		2633, 1, 0, 0, 0, 232, 2683, 1, 0, 0, 0, 234, 2685, 1, 0, 0, 0, 236, 2689,
		1, 0, 0, 0, 238, 2693, 1, 0, 0, 0, 240, 2700, 1, 0, 0, 0, 242, 2719, 1,
		0, 0, 0, 244, 2741, 1, 0, 0, 0, 246, 2764, 1, 0, 0, 0, 248, 2766, 1, 0,
		0, 0, 250, 2786, 1, 0, 0, 0, 252, 2832, 1, 0, 0, 0, 254, 2834, 1, 0, 0,
		0, 256, 2841, 1, 0, 0, 0, 258, 2844, 1, 0, 0, 0, 260, 2849, 1, 0, 0, 0,
		262, 2863, 1, 0, 0, 0, 264, 2878, 1, 0, 0, 0, 266, 2892, 1, 0, 0, 0, 268,
		2907, 1, 0, 0, 0, 270, 2920, 1, 0, 0, 0, 272, 2924, 1, 0, 0, 0, 274, 2927,
		1, 0, 0, 0, 276, 2931, 1, 0, 0, 0, 278, 2934, 1, 0, 0, 0, 280, 2938, 1,
		0, 0, 0, 282, 2944, 1, 0, 0, 0, 284, 2961, 1, 0, 0, 0, 286, 2976, 1, 0,
		0, 0, 288, 2995, 1, 0, 0, 0, 290, 3005, 1, 0, 0, 0, 292, 3020, 1, 0, 0,
		0, 294, 3025, 1, 0, 0, 0, 296, 3031, 1, 0, 0, 0, 298, 3041, 1, 0, 0, 0,
		300, 3047, 1, 0, 0, 0, 302, 3056, 1, 0, 0, 0, 304, 3058, 1, 0, 0, 0, 306,
		3067, 1, 0, 0, 0, 308, 3081, 1, 0, 0, 0, 310, 3109, 1, 0, 0, 0, 312, 3130,
		1, 0, 0, 0, 314, 3132, 1, 0, 0, 0, 316, 3140, 1, 0, 0, 0, 318, 3148, 1,
		0, 0, 0, 320, 3155, 1, 0, 0, 0, 322, 3164, 1, 0, 0, 0, 324, 3186, 1, 0,
		0, 0, 326, 3188, 1, 0, 0, 0, 328, 3192, 1, 0, 0, 0, 330, 3195, 1, 0, 0,
		0, 332, 3198, 1, 0, 0, 0, 334, 3200, 1, 0, 0, 0, 336, 3202, 1, 0, 0, 0,
		338, 3213, 1, 0, 0, 0, 340, 3249, 1, 0, 0, 0, 342, 3306, 1, 0, 0, 0, 344,
		3308, 1, 0, 0, 0, 346, 3325, 1, 0, 0, 0, 348, 3327, 1, 0, 0, 0, 350, 3334,
		1, 0, 0, 0, 352, 3340, 1, 0, 0, 0, 354, 3383, 1, 0, 0, 0, 356, 3388, 1,
		0, 0, 0, 358, 3391, 1, 0, 0, 0, 360, 3406, 1, 0, 0, 0, 362, 3425, 1, 0,
		0, 0, 364, 3454, 1, 0, 0, 0, 366, 3480, 1, 0, 0, 0, 368, 3490, 1, 0, 0,
		0, 370, 3492, 1, 0, 0, 0, 372, 3497, 1, 0, 0, 0, 374, 3502, 1, 0, 0, 0,
		376, 3505, 1, 0, 0, 0, 378, 3522, 1, 0, 0, 0, 380, 3524, 1, 0, 0, 0, 382,
		3526, 1, 0, 0, 0, 384, 3537, 1, 0, 0, 0, 386, 3548, 1, 0, 0, 0, 388, 3559,
		1, 0, 0, 0, 390, 3597, 1, 0, 0, 0, 392, 3608, 1, 0, 0, 0, 394, 3619, 1,
		0, 0, 0, 396, 3657, 1, 0, 0, 0, 398, 3713, 1, 0, 0, 0, 400, 3715, 1, 0,
		0, 0, 402, 3723, 1, 0, 0, 0, 404, 3738, 1, 0, 0, 0, 406, 3744, 1, 0, 0,
		0, 408, 3802, 1, 0, 0, 0, 410, 3811, 1, 0, 0, 0, 412, 3813, 1, 0, 0, 0,
		414, 3837, 1, 0, 0, 0, 416, 3863, 1, 0, 0, 0, 418, 3885, 1, 0, 0, 0, 420,
		3906, 1, 0, 0, 0, 422, 3908, 1, 0, 0, 0, 424, 3922, 1, 0, 0, 0, 426, 3932,
		1, 0, 0, 0, 428, 3935, 1, 0, 0, 0, 430, 3971, 1, 0, 0, 0, 432, 4028, 1,
		0, 0, 0, 434, 4046, 1, 0, 0, 0, 436, 4057, 1, 0, 0, 0, 438, 4059, 1, 0,
		0, 0, 440, 4068, 1, 0, 0, 0, 442, 4074, 1, 0, 0, 0, 444, 4078, 1, 0, 0,
		0, 446, 4081, 1, 0, 0, 0, 448, 4085, 1, 0, 0, 0, 450, 4103, 1, 0, 0, 0,
		452, 4117, 1, 0, 0, 0, 454, 4140, 1, 0, 0, 0, 456, 4144, 1, 0, 0, 0, 458,
		4185, 1, 0, 0, 0, 460, 4190, 1, 0, 0, 0, 462, 4194, 1, 0, 0, 0, 464, 4274,
		1, 0, 0, 0, 466, 4276, 1, 0, 0, 0, 468, 4310, 1, 0, 0, 0, 470, 4312, 1,
		0, 0, 0, 472, 4318, 1, 0, 0, 0, 474, 4365, 1, 0, 0, 0, 476, 4367, 1, 0,
		0, 0, 478, 4377, 1, 0, 0, 0, 480, 4389, 1, 0, 0, 0, 482, 4394, 1, 0, 0,
		0, 484, 4397, 1, 0, 0, 0, 486, 4400, 1, 0, 0, 0, 488, 4403, 1, 0, 0, 0,
		490, 4417, 1, 0, 0, 0, 492, 4425, 1, 0, 0, 0, 494, 4431, 1, 0, 0, 0, 496,
		4439, 1, 0, 0, 0, 498, 4451, 1, 0, 0, 0, 500, 4454, 1, 0, 0, 0, 502, 4457,
		1, 0, 0, 0, 504, 4460, 1, 0, 0, 0, 506, 4463, 1, 0, 0, 0, 508, 4467, 1,
		0, 0, 0, 510, 4470, 1, 0, 0, 0, 512, 4479, 1, 0, 0, 0, 514, 4483, 1, 0,
		0, 0, 516, 4492, 1, 0, 0, 0, 518, 4498, 1, 0, 0, 0, 520, 4505, 1, 0, 0,
		0, 522, 4545, 1, 0, 0, 0, 524, 4547, 1, 0, 0, 0, 526, 4557, 1, 0, 0, 0,
		528, 4592, 1, 0, 0, 0, 530, 4594, 1, 0, 0, 0, 532, 4605, 1, 0, 0, 0, 534,
		4610, 1, 0, 0, 0, 536, 4613, 1, 0, 0, 0, 538, 4632, 1, 0, 0, 0, 540, 4673,
		1, 0, 0, 0, 542, 4675, 1, 0, 0, 0, 544, 4687, 1, 0, 0, 0, 546, 4689, 1,
		0, 0, 0, 548, 4697, 1, 0, 0, 0, 550, 4708, 1, 0, 0, 0, 552, 4720, 1, 0,
		0, 0, 554, 4728, 1, 0, 0, 0, 556, 4745, 1, 0, 0, 0, 558, 4761, 1, 0, 0,
		0, 560, 4779, 1, 0, 0, 0, 562, 4781, 1, 0, 0, 0, 564, 4798, 1, 0, 0, 0,
		566, 4888, 1, 0, 0, 0, 568, 4954, 1, 0, 0, 0, 570, 4970, 1, 0, 0, 0, 572,
		4985, 1, 0, 0, 0, 574, 4987, 1, 0, 0, 0, 576, 4992, 1, 0, 0, 0, 578, 5000,
		1, 0, 0, 0, 580, 5015, 1, 0, 0, 0, 582, 5066, 1, 0, 0, 0, 584, 5082, 1,
		0, 0, 0, 586, 5102, 1, 0, 0, 0, 588, 5104, 1, 0, 0, 0, 590, 5110, 1, 0,
		0, 0, 592, 5117, 1, 0, 0, 0, 594, 5122, 1, 0, 0, 0, 596, 5126, 1, 0, 0,
		0, 598, 5132, 1, 0, 0, 0, 600, 5138, 1, 0, 0, 0, 602, 5143, 1, 0, 0, 0,
		604, 5147, 1, 0, 0, 0, 606, 5153, 1, 0, 0, 0, 608, 5188, 1, 0, 0, 0, 610,
		5197, 1, 0, 0, 0, 612, 5203, 1, 0, 0, 0, 614, 5242, 1, 0, 0, 0, 616, 5251,
		1, 0, 0, 0, 618, 5261, 1, 0, 0, 0, 620, 5269, 1, 0, 0, 0, 622, 5288, 1,
		0, 0, 0, 624, 5292, 1, 0, 0, 0, 626, 5296, 1, 0, 0, 0, 628, 5306, 1, 0,
		0, 0, 630, 5309, 1, 0, 0, 0, 632, 5312, 1, 0, 0, 0, 634, 5323, 1, 0, 0,
		0, 636, 5334, 1, 0, 0, 0, 638, 5338, 1, 0, 0, 0, 640, 5344, 1, 0, 0, 0,
		642, 5361, 1, 0, 0, 0, 644, 5365, 1, 0, 0, 0, 646, 5370, 1, 0, 0, 0, 648,
		5374, 1, 0, 0, 0, 650, 5393, 1, 0, 0, 0, 652, 5412, 1, 0, 0, 0, 654, 5424,
		1, 0, 0, 0, 656, 5451, 1, 0, 0, 0, 658, 5458, 1, 0, 0, 0, 660, 5462, 1,
		0, 0, 0, 662, 5471, 1, 0, 0, 0, 664, 5480, 1, 0, 0, 0, 666, 5486, 1, 0,
		0, 0, 668, 5497, 1, 0, 0, 0, 670, 5514, 1, 0, 0, 0, 672, 5516, 1, 0, 0,
		0, 674, 5521, 1, 0, 0, 0, 676, 5525, 1, 0, 0, 0, 678, 5550, 1, 0, 0, 0,
		680, 5624, 1, 0, 0, 0, 682, 5636, 1, 0, 0, 0, 684, 5642, 1, 0, 0, 0, 686,
		5644, 1, 0, 0, 0, 688, 5655, 1, 0, 0, 0, 690, 5661, 1, 0, 0, 0, 692, 5663,
		1, 0, 0, 0, 694, 5671, 1, 0, 0, 0, 696, 5679, 1, 0, 0, 0, 698, 5697, 1,
		0, 0, 0, 700, 5699, 1, 0, 0, 0, 702, 5716, 1, 0, 0, 0, 704, 5718, 1, 0,
		0, 0, 706, 5724, 1, 0, 0, 0, 708, 5728, 1, 0, 0, 0, 710, 5734, 1, 0, 0,
		0, 712, 5738, 1, 0, 0, 0, 714, 5752, 1, 0, 0, 0, 716, 5760, 1, 0, 0, 0,
		718, 5768, 1, 0, 0, 0, 720, 5776, 1, 0, 0, 0, 722, 5786, 1, 0, 0, 0, 724,
		5792, 1, 0, 0, 0, 726, 5815, 1, 0, 0, 0, 728, 5817, 1, 0, 0, 0, 730, 5822,
		1, 0, 0, 0, 732, 5839, 1, 0, 0, 0, 734, 5852, 1, 0, 0, 0, 736, 5859, 1,
		0, 0, 0, 738, 5866, 1, 0, 0, 0, 740, 5885, 1, 0, 0, 0, 742, 5887, 1, 0,
		0, 0, 744, 5904, 1, 0, 0, 0, 746, 5921, 1, 0, 0, 0, 748, 5925, 1, 0, 0,
		0, 750, 5928, 1, 0, 0, 0, 752, 5934, 1, 0, 0, 0, 754, 5941, 1, 0, 0, 0,
		756, 5945, 1, 0, 0, 0, 758, 5954, 1, 0, 0, 0, 760, 6002, 1, 0, 0, 0, 762,
		6004, 1, 0, 0, 0, 764, 6009, 1, 0, 0, 0, 766, 6028, 1, 0, 0, 0, 768, 6032,
		1, 0, 0, 0, 770, 6036, 1, 0, 0, 0, 772, 6047, 1, 0, 0, 0, 774, 6060, 1,
		0, 0, 0, 776, 6062, 1, 0, 0, 0, 778, 6104, 1, 0, 0, 0, 780, 6132, 1, 0,
		0, 0, 782, 6134, 1, 0, 0, 0, 784, 6147, 1, 0, 0, 0, 786, 6156, 1, 0, 0,
		0, 788, 6178, 1, 0, 0, 0, 790, 6180, 1, 0, 0, 0, 792, 6192, 1, 0, 0, 0,
		794, 6220, 1, 0, 0, 0, 796, 6325, 1, 0, 0, 0, 798, 6327, 1, 0, 0, 0, 800,
		6355, 1, 0, 0, 0, 802, 6367, 1, 0, 0, 0, 804, 6378, 1, 0, 0, 0, 806, 6384,
		1, 0, 0, 0, 808, 6386, 1, 0, 0, 0, 810, 6394, 1, 0, 0, 0, 812, 6419, 1,
		0, 0, 0, 814, 6427, 1, 0, 0, 0, 816, 6456, 1, 0, 0, 0, 818, 6476, 1, 0,
		0, 0, 820, 6478, 1, 0, 0, 0, 822, 6496, 1, 0, 0, 0, 824, 6498, 1, 0, 0,
		0, 826, 6530, 1, 0, 0, 0, 828, 6532, 1, 0, 0, 0, 830, 6544, 1, 0, 0, 0,
		832, 6556, 1, 0, 0, 0, 834, 6563, 1, 0, 0, 0, 836, 6565, 1, 0, 0, 0, 838,
		6580, 1, 0, 0, 0, 840, 6584, 1, 0, 0, 0, 842, 6596, 1, 0, 0, 0, 844, 6609,
		1, 0, 0, 0, 846, 6611, 1, 0, 0, 0, 848, 6619, 1, 0, 0, 0, 850, 6623, 1,
		0, 0, 0, 852, 6633, 1, 0, 0, 0, 854, 6646, 1, 0, 0, 0, 856, 6654, 1, 0,
		0, 0, 858, 6683, 1, 0, 0, 0, 860, 6685, 1, 0, 0, 0, 862, 6731, 1, 0, 0,
		0, 864, 6733, 1, 0, 0, 0, 866, 6870, 1, 0, 0, 0, 868, 6926, 1, 0, 0, 0,
		870, 7000, 1, 0, 0, 0, 872, 7127, 1, 0, 0, 0, 874, 7129, 1, 0, 0, 0, 876,
		7132, 1, 0, 0, 0, 878, 7141, 1, 0, 0, 0, 880, 7170, 1, 0, 0, 0, 882, 7200,
		1, 0, 0, 0, 884, 7343, 1, 0, 0, 0, 886, 7442, 1, 0, 0, 0, 888, 7444, 1,
		0, 0, 0, 890, 7449, 1, 0, 0, 0, 892, 7483, 1, 0, 0, 0, 894, 7502, 1, 0,
		0, 0, 896, 7513, 1, 0, 0, 0, 898, 7554, 1, 0, 0, 0, 900, 7556, 1, 0, 0,
		0, 902, 7560, 1, 0, 0, 0, 904, 7568, 1, 0, 0, 0, 906, 7572, 1, 0, 0, 0,
		908, 7579, 1, 0, 0, 0, 910, 7669, 1, 0, 0, 0, 912, 7673, 1, 0, 0, 0, 914,
		7675, 1, 0, 0, 0, 916, 7688, 1, 0, 0, 0, 918, 7701, 1, 0, 0, 0, 920, 7712,
		1, 0, 0, 0, 922, 7725, 1, 0, 0, 0, 924, 7729, 1, 0, 0, 0, 926, 7731, 1,
		0, 0, 0, 928, 7742, 1, 0, 0, 0, 930, 7755, 1, 0, 0, 0, 932, 7757, 1, 0,
		0, 0, 934, 7795, 1, 0, 0, 0, 936, 7797, 1, 0, 0, 0, 938, 7818, 1, 0, 0,
		0, 940, 7820, 1, 0, 0, 0, 942, 7831, 1, 0, 0, 0, 944, 7837, 1, 0, 0, 0,
		946, 7851, 1, 0, 0, 0, 948, 7872, 1, 0, 0, 0, 950, 7874, 1, 0, 0, 0, 952,
		7896, 1, 0, 0, 0, 954, 7898, 1, 0, 0, 0, 956, 7910, 1, 0, 0, 0, 958, 7913,
		1, 0, 0, 0, 960, 7924, 1, 0, 0, 0, 962, 7932, 1, 0, 0, 0, 964, 7936, 1,
		0, 0, 0, 966, 7943, 1, 0, 0, 0, 968, 7947, 1, 0, 0, 0, 970, 7949, 1, 0,
		0, 0, 972, 7952, 1, 0, 0, 0, 974, 7961, 1, 0, 0, 0, 976, 7967, 1, 0, 0,
		0, 978, 7969, 1, 0, 0, 0, 980, 7971, 1, 0, 0, 0, 982, 7973, 1, 0, 0, 0,
		984, 7975, 1, 0, 0, 0, 986, 7979, 1, 0, 0, 0, 988, 7983, 1, 0, 0, 0, 990,
		7985, 1, 0, 0, 0, 992, 7987, 1, 0, 0, 0, 994, 7994, 1, 0, 0, 0, 996, 7996,
		1, 0, 0, 0, 998, 8001, 1, 0, 0, 0, 1000, 8010, 1, 0, 0, 0, 1002, 8014,
		1, 0, 0, 0, 1004, 8022, 1, 0, 0, 0, 1006, 8027, 1, 0, 0, 0, 1008, 8099,
		1, 0, 0, 0, 1010, 8101, 1, 0, 0, 0, 1012, 8111, 1, 0, 0, 0, 1014, 8120,
		1, 0, 0, 0, 1016, 8123, 1, 0, 0, 0, 1018, 8134, 1, 0, 0, 0, 1020, 8136,
		1, 0, 0, 0, 1022, 8141, 1, 0, 0, 0, 1024, 8152, 1, 0, 0, 0, 1026, 8165,
		1, 0, 0, 0, 1028, 8167, 1, 0, 0, 0, 1030, 8178, 1, 0, 0, 0, 1032, 8191,
		1, 0, 0, 0, 1034, 8193, 1, 0, 0, 0, 1036, 8197, 1, 0, 0, 0, 1038, 8208,
		1, 0, 0, 0, 1040, 8210, 1, 0, 0, 0, 1042, 1044, 3, 2, 1, 0, 1043, 1042,
		1, 0, 0, 0, 1044, 1045, 1, 0, 0, 0, 1045, 1043, 1, 0, 0, 0, 1045, 1046,
		1, 0, 0, 0, 1046, 1047, 1, 0, 0, 0, 1047, 1048, 5, 0, 0, 1, 1048, 1, 1,
		0, 0, 0, 1049, 1050, 3, 6, 3, 0, 1050, 1051, 7, 0, 0, 0, 1051, 1054, 1,
		0, 0, 0, 1052, 1054, 3, 4, 2, 0, 1053, 1049, 1, 0, 0, 0, 1053, 1052, 1,
		0, 0, 0, 1054, 3, 1, 0, 0, 0, 1055, 1056, 5, 532, 0, 0, 1056, 5, 1, 0,
		0, 0, 1057, 1298, 3, 752, 376, 0, 1058, 1298, 3, 8, 4, 0, 1059, 1298, 3,
		10, 5, 0, 1060, 1298, 3, 12, 6, 0, 1061, 1298, 3, 14, 7, 0, 1062, 1298,
		3, 16, 8, 0, 1063, 1298, 3, 18, 9, 0, 1064, 1298, 3, 20, 10, 0, 1065, 1298,
		3, 22, 11, 0, 1066, 1298, 3, 24, 12, 0, 1067, 1298, 3, 26, 13, 0, 1068,
		1298, 3, 28, 14, 0, 1069, 1298, 3, 30, 15, 0, 1070, 1298, 3, 32, 16, 0,
		1071, 1298, 3, 74, 37, 0, 1072, 1298, 3, 104, 52, 0, 1073, 1298, 3, 92,
		46, 0, 1074, 1298, 3, 76, 38, 0, 1075, 1298, 3, 78, 39, 0, 1076, 1298,
		3, 108, 54, 0, 1077, 1298, 3, 110, 55, 0, 1078, 1298, 3, 88, 44, 0, 1079,
		1298, 3, 102, 51, 0, 1080, 1298, 3, 96, 48, 0, 1081, 1298, 3, 94, 47, 0,
		1082, 1298, 3, 98, 49, 0, 1083, 1298, 3, 80, 40, 0, 1084, 1298, 3, 112,
		56, 0, 1085, 1298, 3, 100, 50, 0, 1086, 1298, 3, 90, 45, 0, 1087, 1298,
		3, 118, 59, 0, 1088, 1298, 3, 120, 60, 0, 1089, 1298, 3, 122, 61, 0, 1090,
		1298, 3, 114, 57, 0, 1091, 1298, 3, 116, 58, 0, 1092, 1298, 3, 82, 41,
		0, 1093, 1298, 3, 84, 42, 0, 1094, 1298, 3, 106, 53, 0, 1095, 1298, 3,
		126, 63, 0, 1096, 1298, 3, 130, 65, 0, 1097, 1298, 3, 134, 67, 0, 1098,
		1298, 3, 140, 70, 0, 1099, 1298, 3, 142, 71, 0, 1100, 1298, 3, 144, 72,
		0, 1101, 1298, 3, 146, 73, 0, 1102, 1298, 3, 148, 74, 0, 1103, 1298, 3,
		182, 91, 0, 1104, 1298, 3, 186, 93, 0, 1105, 1298, 3, 188, 94, 0, 1106,
		1298, 3, 184, 92, 0, 1107, 1298, 3, 190, 95, 0, 1108, 1298, 3, 352, 176,
		0, 1109, 1298, 3, 358, 179, 0, 1110, 1298, 3, 360, 180, 0, 1111, 1298,
		3, 362, 181, 0, 1112, 1298, 3, 364, 182, 0, 1113, 1298, 3, 382, 191, 0,
		1114, 1298, 3, 384, 192, 0, 1115, 1298, 3, 386, 193, 0, 1116, 1298, 3,
		388, 194, 0, 1117, 1298, 3, 390, 195, 0, 1118, 1298, 3, 392, 196, 0, 1119,
		1298, 3, 394, 197, 0, 1120, 1298, 3, 150, 75, 0, 1121, 1298, 3, 152, 76,
		0, 1122, 1298, 3, 154, 77, 0, 1123, 1298, 3, 156, 78, 0, 1124, 1298, 3,
		158, 79, 0, 1125, 1298, 3, 160, 80, 0, 1126, 1298, 3, 162, 81, 0, 1127,
		1298, 3, 164, 82, 0, 1128, 1298, 3, 166, 83, 0, 1129, 1298, 3, 168, 84,
		0, 1130, 1298, 3, 170, 85, 0, 1131, 1298, 3, 696, 348, 0, 1132, 1298, 3,
		172, 86, 0, 1133, 1298, 3, 174, 87, 0, 1134, 1298, 3, 176, 88, 0, 1135,
		1298, 3, 178, 89, 0, 1136, 1298, 3, 180, 90, 0, 1137, 1298, 3, 396, 198,
		0, 1138, 1298, 3, 400, 200, 0, 1139, 1298, 3, 408, 204, 0, 1140, 1298,
		3, 410, 205, 0, 1141, 1298, 3, 404, 202, 0, 1142, 1298, 3, 406, 203, 0,
		1143, 1298, 3, 412, 206, 0, 1144, 1298, 3, 414, 207, 0, 1145, 1298, 3,
		416, 208, 0, 1146, 1298, 3, 418, 209, 0, 1147, 1298, 3, 420, 210, 0, 1148,
		1298, 3, 428, 214, 0, 1149, 1298, 3, 430, 215, 0, 1150, 1298, 3, 432, 216,
		0, 1151, 1298, 3, 434, 217, 0, 1152, 1298, 3, 436, 218, 0, 1153, 1298,
		3, 438, 219, 0, 1154, 1298, 3, 440, 220, 0, 1155, 1298, 3, 442, 221, 0,
		1156, 1298, 3, 444, 222, 0, 1157, 1298, 3, 448, 224, 0, 1158, 1298, 3,
		450, 225, 0, 1159, 1298, 3, 452, 226, 0, 1160, 1298, 3, 458, 229, 0, 1161,
		1298, 3, 472, 236, 0, 1162, 1298, 3, 474, 237, 0, 1163, 1298, 3, 476, 238,
		0, 1164, 1298, 3, 478, 239, 0, 1165, 1298, 3, 482, 241, 0, 1166, 1298,
		3, 484, 242, 0, 1167, 1298, 3, 486, 243, 0, 1168, 1298, 3, 488, 244, 0,
		1169, 1298, 3, 490, 245, 0, 1170, 1298, 3, 492, 246, 0, 1171, 1298, 3,
		494, 247, 0, 1172, 1298, 3, 496, 248, 0, 1173, 1298, 3, 498, 249, 0, 1174,
		1298, 3, 500, 250, 0, 1175, 1298, 3, 502, 251, 0, 1176, 1298, 3, 504, 252,
		0, 1177, 1298, 3, 506, 253, 0, 1178, 1298, 3, 508, 254, 0, 1179, 1298,
		3, 510, 255, 0, 1180, 1298, 3, 512, 256, 0, 1181, 1298, 3, 514, 257, 0,
		1182, 1298, 3, 516, 258, 0, 1183, 1298, 3, 518, 259, 0, 1184, 1298, 3,
		520, 260, 0, 1185, 1298, 3, 522, 261, 0, 1186, 1298, 3, 524, 262, 0, 1187,
		1298, 3, 526, 263, 0, 1188, 1298, 3, 528, 264, 0, 1189, 1298, 3, 530, 265,
		0, 1190, 1298, 3, 532, 266, 0, 1191, 1298, 3, 534, 267, 0, 1192, 1298,
		3, 536, 268, 0, 1193, 1298, 3, 538, 269, 0, 1194, 1298, 3, 540, 270, 0,
		1195, 1298, 3, 542, 271, 0, 1196, 1298, 3, 544, 272, 0, 1197, 1298, 3,
		546, 273, 0, 1198, 1298, 3, 548, 274, 0, 1199, 1298, 3, 550, 275, 0, 1200,
		1298, 3, 552, 276, 0, 1201, 1298, 3, 554, 277, 0, 1202, 1298, 3, 556, 278,
		0, 1203, 1298, 3, 558, 279, 0, 1204, 1298, 3, 560, 280, 0, 1205, 1298,
		3, 562, 281, 0, 1206, 1298, 3, 566, 283, 0, 1207, 1298, 3, 568, 284, 0,
		1208, 1298, 3, 570, 285, 0, 1209, 1298, 3, 588, 294, 0, 1210, 1298, 3,
		590, 295, 0, 1211, 1298, 3, 592, 296, 0, 1212, 1298, 3, 594, 297, 0, 1213,
		1298, 3, 596, 298, 0, 1214, 1298, 3, 598, 299, 0, 1215, 1298, 3, 600, 300,
		0, 1216, 1298, 3, 602, 301, 0, 1217, 1298, 3, 604, 302, 0, 1218, 1298,
		3, 606, 303, 0, 1219, 1298, 3, 608, 304, 0, 1220, 1298, 3, 610, 305, 0,
		1221, 1298, 3, 612, 306, 0, 1222, 1298, 3, 614, 307, 0, 1223, 1298, 3,
		616, 308, 0, 1224, 1298, 3, 618, 309, 0, 1225, 1298, 3, 620, 310, 0, 1226,
		1298, 3, 622, 311, 0, 1227, 1298, 3, 624, 312, 0, 1228, 1298, 3, 626, 313,
		0, 1229, 1298, 3, 628, 314, 0, 1230, 1298, 3, 630, 315, 0, 1231, 1298,
		3, 632, 316, 0, 1232, 1298, 3, 634, 317, 0, 1233, 1298, 3, 636, 318, 0,
		1234, 1298, 3, 640, 320, 0, 1235, 1298, 3, 642, 321, 0, 1236, 1298, 3,
		644, 322, 0, 1237, 1298, 3, 646, 323, 0, 1238, 1298, 3, 648, 324, 0, 1239,
		1298, 3, 650, 325, 0, 1240, 1298, 3, 652, 326, 0, 1241, 1298, 3, 654, 327,
		0, 1242, 1298, 3, 656, 328, 0, 1243, 1298, 3, 658, 329, 0, 1244, 1298,
		3, 660, 330, 0, 1245, 1298, 3, 662, 331, 0, 1246, 1298, 3, 664, 332, 0,
		1247, 1298, 3, 678, 339, 0, 1248, 1298, 3, 692, 346, 0, 1249, 1298, 3,
		192, 96, 0, 1250, 1298, 3, 202, 101, 0, 1251, 1298, 3, 200, 100, 0, 1252,
		1298, 3, 198, 99, 0, 1253, 1298, 3, 210, 105, 0, 1254, 1298, 3, 212, 106,
		0, 1255, 1298, 3, 666, 333, 0, 1256, 1298, 3, 668, 334, 0, 1257, 1298,
		3, 672, 336, 0, 1258, 1298, 3, 676, 338, 0, 1259, 1298, 3, 674, 337, 0,
		1260, 1298, 3, 480, 240, 0, 1261, 1298, 3, 214, 107, 0, 1262, 1298, 3,
		216, 108, 0, 1263, 1298, 3, 832, 416, 0, 1264, 1298, 3, 836, 418, 0, 1265,
		1298, 3, 838, 419, 0, 1266, 1298, 3, 218, 109, 0, 1267, 1298, 3, 220, 110,
		0, 1268, 1298, 3, 222, 111, 0, 1269, 1298, 3, 224, 112, 0, 1270, 1298,
		3, 226, 113, 0, 1271, 1298, 3, 704, 352, 0, 1272, 1298, 3, 706, 353, 0,
		1273, 1298, 3, 708, 354, 0, 1274, 1298, 3, 710, 355, 0, 1275, 1298, 3,
		712, 356, 0, 1276, 1298, 3, 714, 357, 0, 1277, 1298, 3, 716, 358, 0, 1278,
		1298, 3, 718, 359, 0, 1279, 1298, 3, 720, 360, 0, 1280, 1298, 3, 722, 361,
		0, 1281, 1298, 3, 724, 362, 0, 1282, 1298, 3, 726, 363, 0, 1283, 1298,
		3, 728, 364, 0, 1284, 1298, 3, 730, 365, 0, 1285, 1298, 3, 732, 366, 0,
		1286, 1298, 3, 734, 367, 0, 1287, 1298, 3, 736, 368, 0, 1288, 1298, 3,
		738, 369, 0, 1289, 1298, 3, 740, 370, 0, 1290, 1298, 3, 742, 371, 0, 1291,
		1298, 3, 744, 372, 0, 1292, 1298, 3, 746, 373, 0, 1293, 1298, 3, 422, 211,
		0, 1294, 1298, 3, 424, 212, 0, 1295, 1298, 3, 426, 213, 0, 1296, 1298,
		3, 698, 349, 0, 1297, 1057, 1, 0, 0, 0, 1297, 1058, 1, 0, 0, 0, 1297, 1059,
		1, 0, 0, 0, 1297, 1060, 1, 0, 0, 0, 1297, 1061, 1, 0, 0, 0, 1297, 1062,
		1, 0, 0, 0, 1297, 1063, 1, 0, 0, 0, 1297, 1064, 1, 0, 0, 0, 1297, 1065,
		1, 0, 0, 0, 1297, 1066, 1, 0, 0, 0, 1297, 1067, 1, 0, 0, 0, 1297, 1068,
		1, 0, 0, 0, 1297, 1069, 1, 0, 0, 0, 1297, 1070, 1, 0, 0, 0, 1297, 1071,
		1, 0, 0, 0, 1297, 1072, 1, 0, 0, 0, 1297, 1073, 1, 0, 0, 0, 1297, 1074,
		1, 0, 0, 0, 1297, 1075, 1, 0, 0, 0, 1297, 1076, 1, 0, 0, 0, 1297, 1077,
		1, 0, 0, 0, 1297, 1078, 1, 0, 0, 0, 1297, 1079, 1, 0, 0, 0, 1297, 1080,
		1, 0, 0, 0, 1297, 1081, 1, 0, 0, 0, 1297, 1082, 1, 0, 0, 0, 1297, 1083,
		1, 0, 0, 0, 1297, 1084, 1, 0, 0, 0, 1297, 1085, 1, 0, 0, 0, 1297, 1086,
		1, 0, 0, 0, 1297, 1087, 1, 0, 0, 0, 1297, 1088, 1, 0, 0, 0, 1297, 1089,
		1, 0, 0, 0, 1297, 1090, 1, 0, 0, 0, 1297, 1091, 1, 0, 0, 0, 1297, 1092,
		1, 0, 0, 0, 1297, 1093, 1, 0, 0, 0, 1297, 1094, 1, 0, 0, 0, 1297, 1095,
		1, 0, 0, 0, 1297, 1096, 1, 0, 0, 0, 1297, 1097, 1, 0, 0, 0, 1297, 1098,
		1, 0, 0, 0, 1297, 1099, 1, 0, 0, 0, 1297, 1100, 1, 0, 0, 0, 1297, 1101,
		1, 0, 0, 0, 1297, 1102, 1, 0, 0, 0, 1297, 1103, 1, 0, 0, 0, 1297, 1104,
		1, 0, 0, 0, 1297, 1105, 1, 0, 0, 0, 1297, 1106, 1, 0, 0, 0, 1297, 1107,
		1, 0, 0, 0, 1297, 1108, 1, 0, 0, 0, 1297, 1109, 1, 0, 0, 0, 1297, 1110,
		1, 0, 0, 0, 1297, 1111, 1, 0, 0, 0, 1297, 1112, 1, 0, 0, 0, 1297, 1113,
		1, 0, 0, 0, 1297, 1114, 1, 0, 0, 0, 1297, 1115, 1, 0, 0, 0, 1297, 1116,
		1, 0, 0, 0, 1297, 1117, 1, 0, 0, 0, 1297, 1118, 1, 0, 0, 0, 1297, 1119,
		1, 0, 0, 0, 1297, 1120, 1, 0, 0, 0, 1297, 1121, 1, 0, 0, 0, 1297, 1122,
		1, 0, 0, 0, 1297, 1123, 1, 0, 0, 0, 1297, 1124, 1, 0, 0, 0, 1297, 1125,
		1, 0, 0, 0, 1297, 1126, 1, 0, 0, 0, 1297, 1127, 1, 0, 0, 0, 1297, 1128,
		1, 0, 0, 0, 1297, 1129, 1, 0, 0, 0, 1297, 1130, 1, 0, 0, 0, 1297, 1131,
		1, 0, 0, 0, 1297, 1132, 1, 0, 0, 0, 1297, 1133, 1, 0, 0, 0, 1297, 1134,
		1, 0, 0, 0, 1297, 1135, 1, 0, 0, 0, 1297, 1136, 1, 0, 0, 0, 1297, 1137,
		1, 0, 0, 0, 1297, 1138, 1, 0, 0, 0, 1297, 1139, 1, 0, 0, 0, 1297, 1140,
		1, 0, 0, 0, 1297, 1141, 1, 0, 0, 0, 1297, 1142, 1, 0, 0, 0, 1297, 1143,
		1, 0, 0, 0, 1297, 1144, 1, 0, 0, 0, 1297, 1145, 1, 0, 0, 0, 1297, 1146,
		1, 0, 0, 0, 1297, 1147, 1, 0, 0, 0, 1297, 1148, 1, 0, 0, 0, 1297, 1149,
		1, 0, 0, 0, 1297, 1150, 1, 0, 0, 0, 1297, 1151, 1, 0, 0, 0, 1297, 1152,
		1, 0, 0, 0, 1297, 1153, 1, 0, 0, 0, 1297, 1154, 1, 0, 0, 0, 1297, 1155,
		1, 0, 0, 0, 1297, 1156, 1, 0, 0, 0, 1297, 1157, 1, 0, 0, 0, 1297, 1158,
		1, 0, 0, 0, 1297, 1159, 1, 0, 0, 0, 1297, 1160, 1, 0, 0, 0, 1297, 1161,
		1, 0, 0, 0, 1297, 1162, 1, 0, 0, 0, 1297, 1163, 1, 0, 0, 0, 1297, 1164,
		1, 0, 0, 0, 1297, 1165, 1, 0, 0, 0, 1297, 1166, 1, 0, 0, 0, 1297, 1167,
		1, 0, 0, 0, 1297, 1168, 1, 0, 0, 0, 1297, 1169, 1, 0, 0, 0, 1297, 1170,
		1, 0, 0, 0, 1297, 1171, 1, 0, 0, 0, 1297, 1172, 1, 0, 0, 0, 1297, 1173,
		1, 0, 0, 0, 1297, 1174, 1, 0, 0, 0, 1297, 1175, 1, 0, 0, 0, 1297, 1176,
		1, 0, 0, 0, 1297, 1177, 1, 0, 0, 0, 1297, 1178, 1, 0, 0, 0, 1297, 1179,
		1, 0, 0, 0, 1297, 1180, 1, 0, 0, 0, 1297, 1181, 1, 0, 0, 0, 1297, 1182,
		1, 0, 0, 0, 1297, 1183, 1, 0, 0, 0, 1297, 1184, 1, 0, 0, 0, 1297, 1185,
		1, 0, 0, 0, 1297, 1186, 1, 0, 0, 0, 1297, 1187, 1, 0, 0, 0, 1297, 1188,
		1, 0, 0, 0, 1297, 1189, 1, 0, 0, 0, 1297, 1190, 1, 0, 0, 0, 1297, 1191,
		1, 0, 0, 0, 1297, 1192, 1, 0, 0, 0, 1297, 1193, 1, 0, 0, 0, 1297, 1194,
		1, 0, 0, 0, 1297, 1195, 1, 0, 0, 0, 1297, 1196, 1, 0, 0, 0, 1297, 1197,
		1, 0, 0, 0, 1297, 1198, 1, 0, 0, 0, 1297, 1199, 1, 0, 0, 0, 1297, 1200,
		1, 0, 0, 0, 1297, 1201, 1, 0, 0, 0, 1297, 1202, 1, 0, 0, 0, 1297, 1203,
		1, 0, 0, 0, 1297, 1204, 1, 0, 0, 0, 1297, 1205, 1, 0, 0, 0, 1297, 1206,
		1, 0, 0, 0, 1297, 1207, 1, 0, 0, 0, 1297, 1208, 1, 0, 0, 0, 1297, 1209,
		1, 0, 0, 0, 1297, 1210, 1, 0, 0, 0, 1297, 1211, 1, 0, 0, 0, 1297, 1212,
		1, 0, 0, 0, 1297, 1213, 1, 0, 0, 0, 1297, 1214, 1, 0, 0, 0, 1297, 1215,
		1, 0, 0, 0, 1297, 1216, 1, 0, 0, 0, 1297, 1217, 1, 0, 0, 0, 1297, 1218,
		1, 0, 0, 0, 1297, 1219, 1, 0, 0, 0, 1297, 1220, 1, 0, 0, 0, 1297, 1221,
		1, 0, 0, 0, 1297, 1222, 1, 0, 0, 0, 1297, 1223, 1, 0, 0, 0, 1297, 1224,
		1, 0, 0, 0, 1297, 1225, 1, 0, 0, 0, 1297, 1226, 1, 0, 0, 0, 1297, 1227,
		1, 0, 0, 0, 1297, 1228, 1, 0, 0, 0, 1297, 1229, 1, 0, 0, 0, 1297, 1230,
		1, 0, 0, 0, 1297, 1231, 1, 0, 0, 0, 1297, 1232, 1, 0, 0, 0, 1297, 1233,
		1, 0, 0, 0, 1297, 1234, 1, 0, 0, 0, 1297, 1235, 1, 0, 0, 0, 1297, 1236,
		1, 0, 0, 0, 1297, 1237, 1, 0, 0, 0, 1297, 1238, 1, 0, 0, 0, 1297, 1239,
		1, 0, 0, 0, 1297, 1240, 1, 0, 0, 0, 1297, 1241, 1, 0, 0, 0, 1297, 1242,
		1, 0, 0, 0, 1297, 1243, 1, 0, 0, 0, 1297, 1244, 1, 0, 0, 0, 1297, 1245,
		1, 0, 0, 0, 1297, 1246, 1, 0, 0, 0, 1297, 1247, 1, 0, 0, 0, 1297, 1248,
		1, 0, 0, 0, 1297, 1249, 1, 0, 0, 0, 1297, 1250, 1, 0, 0, 0, 1297, 1251,
		1, 0, 0, 0, 1297, 1252, 1, 0, 0, 0, 1297, 1253, 1, 0, 0, 0, 1297, 1254,
		1, 0, 0, 0, 1297, 1255, 1, 0, 0, 0, 1297, 1256, 1, 0, 0, 0, 1297, 1257,
		1, 0, 0, 0, 1297, 1258, 1, 0, 0, 0, 1297, 1259, 1, 0, 0, 0, 1297, 1260,
		1, 0, 0, 0, 1297, 1261, 1, 0, 0, 0, 1297, 1262, 1, 0, 0, 0, 1297, 1263,
		1, 0, 0, 0, 1297, 1264, 1, 0, 0, 0, 1297, 1265, 1, 0, 0, 0, 1297, 1266,
		1, 0, 0, 0, 1297, 1267, 1, 0, 0, 0, 1297, 1268, 1, 0, 0, 0, 1297, 1269,
		1, 0, 0, 0, 1297, 1270, 1, 0, 0, 0, 1297, 1271, 1, 0, 0, 0, 1297, 1272,
		1, 0, 0, 0, 1297, 1273, 1, 0, 0, 0, 1297, 1274, 1, 0, 0, 0, 1297, 1275,
		1, 0, 0, 0, 1297, 1276, 1, 0, 0, 0, 1297, 1277, 1, 0, 0, 0, 1297, 1278,
		1, 0, 0, 0, 1297, 1279, 1, 0, 0, 0, 1297, 1280, 1, 0, 0, 0, 1297, 1281,
		1, 0, 0, 0, 1297, 1282, 1, 0, 0, 0, 1297, 1283, 1, 0, 0, 0, 1297, 1284,
		1, 0, 0, 0, 1297, 1285, 1, 0, 0, 0, 1297, 1286, 1, 0, 0, 0, 1297, 1287,
		1, 0, 0, 0, 1297, 1288, 1, 0, 0, 0, 1297, 1289, 1, 0, 0, 0, 1297, 1290,
		1, 0, 0, 0, 1297, 1291, 1, 0, 0, 0, 1297, 1292, 1, 0, 0, 0, 1297, 1293,
		1, 0, 0, 0, 1297, 1294, 1, 0, 0, 0, 1297, 1295, 1, 0, 0, 0, 1297, 1296,
		1, 0, 0, 0, 1298, 7, 1, 0, 0, 0, 1299, 1300, 5, 457, 0, 0, 1300, 1301,
		3, 1012, 506, 0, 1301, 9, 1, 0, 0, 0, 1302, 1303, 5, 457, 0, 0, 1303, 1304,
		3, 976, 488, 0, 1304, 11, 1, 0, 0, 0, 1305, 1306, 5, 396, 0, 0, 1306, 1307,
		5, 60, 0, 0, 1307, 1308, 3, 1026, 513, 0, 1308, 13, 1, 0, 0, 0, 1309, 1310,
		5, 401, 0, 0, 1310, 1313, 5, 105, 0, 0, 1311, 1312, 7, 1, 0, 0, 1312, 1314,
		3, 1012, 506, 0, 1313, 1311, 1, 0, 0, 0, 1313, 1314, 1, 0, 0, 0, 1314,
		1319, 1, 0, 0, 0, 1315, 1316, 5, 240, 0, 0, 1316, 1320, 3, 976, 488, 0,
		1317, 1318, 5, 478, 0, 0, 1318, 1320, 3, 852, 426, 0, 1319, 1315, 1, 0,
		0, 0, 1319, 1317, 1, 0, 0, 0, 1319, 1320, 1, 0, 0, 0, 1320, 1330, 1, 0,
		0, 0, 1321, 1322, 5, 401, 0, 0, 1322, 1327, 5, 388, 0, 0, 1323, 1324, 5,
		240, 0, 0, 1324, 1328, 3, 976, 488, 0, 1325, 1326, 5, 478, 0, 0, 1326,
		1328, 3, 852, 426, 0, 1327, 1323, 1, 0, 0, 0, 1327, 1325, 1, 0, 0, 0, 1327,
		1328, 1, 0, 0, 0, 1328, 1330, 1, 0, 0, 0, 1329, 1309, 1, 0, 0, 0, 1329,
		1321, 1, 0, 0, 0, 1330, 15, 1, 0, 0, 0, 1331, 1332, 5, 19, 0, 0, 1332,
		1333, 5, 104, 0, 0, 1333, 1334, 3, 1018, 509, 0, 1334, 1335, 5, 396, 0,
		0, 1335, 1336, 5, 102, 0, 0, 1336, 1337, 5, 341, 0, 0, 1337, 1338, 3, 1018,
		509, 0, 1338, 1348, 1, 0, 0, 0, 1339, 1340, 5, 19, 0, 0, 1340, 1341, 5,
		104, 0, 0, 1341, 1342, 3, 1018, 509, 0, 1342, 1343, 5, 396, 0, 0, 1343,
		1344, 5, 358, 0, 0, 1344, 1345, 5, 341, 0, 0, 1345, 1346, 5, 518, 0, 0,
		1346, 1348, 1, 0, 0, 0, 1347, 1331, 1, 0, 0, 0, 1347, 1339, 1, 0, 0, 0,
		1348, 17, 1, 0, 0, 0, 1349, 1350, 5, 90, 0, 0, 1350, 1354, 7, 2, 0, 0,
		1351, 1352, 5, 197, 0, 0, 1352, 1353, 5, 281, 0, 0, 1353, 1355, 5, 148,
		0, 0, 1354, 1351, 1, 0, 0, 0, 1354, 1355, 1, 0, 0, 0, 1355, 1359, 1, 0,
		0, 0, 1356, 1357, 3, 1018, 509, 0, 1357, 1358, 5, 1, 0, 0, 1358, 1360,
		1, 0, 0, 0, 1359, 1356, 1, 0, 0, 0, 1359, 1360, 1, 0, 0, 0, 1360, 1361,
		1, 0, 0, 0, 1361, 1363, 3, 1012, 506, 0, 1362, 1364, 3, 46, 23, 0, 1363,
		1362, 1, 0, 0, 0, 1363, 1364, 1, 0, 0, 0, 1364, 1366, 1, 0, 0, 0, 1365,
		1367, 3, 48, 24, 0, 1366, 1365, 1, 0, 0, 0, 1366, 1367, 1, 0, 0, 0, 1367,
		1369, 1, 0, 0, 0, 1368, 1370, 3, 954, 477, 0, 1369, 1368, 1, 0, 0, 0, 1369,
		1370, 1, 0, 0, 0, 1370, 19, 1, 0, 0, 0, 1371, 1372, 5, 132, 0, 0, 1372,
		1375, 7, 2, 0, 0, 1373, 1374, 5, 197, 0, 0, 1374, 1376, 5, 148, 0, 0, 1375,
		1373, 1, 0, 0, 0, 1375, 1376, 1, 0, 0, 0, 1376, 1380, 1, 0, 0, 0, 1377,
		1378, 3, 1018, 509, 0, 1378, 1379, 5, 1, 0, 0, 1379, 1381, 1, 0, 0, 0,
		1380, 1377, 1, 0, 0, 0, 1380, 1381, 1, 0, 0, 0, 1381, 1382, 1, 0, 0, 0,
		1382, 1384, 3, 1012, 506, 0, 1383, 1385, 5, 169, 0, 0, 1384, 1383, 1, 0,
		0, 0, 1384, 1385, 1, 0, 0, 0, 1385, 21, 1, 0, 0, 0, 1386, 1387, 5, 401,
		0, 0, 1387, 1388, 5, 90, 0, 0, 1388, 1389, 7, 2, 0, 0, 1389, 1390, 3, 1018,
		509, 0, 1390, 23, 1, 0, 0, 0, 1391, 1392, 5, 19, 0, 0, 1392, 1393, 5, 104,
		0, 0, 1393, 1394, 3, 1018, 509, 0, 1394, 1395, 5, 353, 0, 0, 1395, 1396,
		3, 1018, 509, 0, 1396, 25, 1, 0, 0, 0, 1397, 1398, 5, 347, 0, 0, 1398,
		1399, 7, 2, 0, 0, 1399, 1400, 3, 1018, 509, 0, 1400, 27, 1, 0, 0, 0, 1401,
		1402, 5, 401, 0, 0, 1402, 1408, 5, 102, 0, 0, 1403, 1404, 5, 401, 0, 0,
		1404, 1405, 5, 102, 0, 0, 1405, 1406, 5, 172, 0, 0, 1406, 1408, 3, 1012,
		506, 0, 1407, 1401, 1, 0, 0, 0, 1407, 1403, 1, 0, 0, 0, 1408, 29, 1, 0,
		0, 0, 1409, 1410, 5, 401, 0, 0, 1410, 1411, 5, 102, 0, 0, 1411, 1412, 5,
		130, 0, 0, 1412, 1413, 5, 172, 0, 0, 1413, 1415, 3, 1012, 506, 0, 1414,
		1416, 3, 826, 413, 0, 1415, 1414, 1, 0, 0, 0, 1415, 1416, 1, 0, 0, 0, 1416,
		31, 1, 0, 0, 0, 1417, 1419, 5, 90, 0, 0, 1418, 1420, 7, 3, 0, 0, 1419,
		1418, 1, 0, 0, 0, 1419, 1420, 1, 0, 0, 0, 1420, 1421, 1, 0, 0, 0, 1421,
		1425, 5, 422, 0, 0, 1422, 1423, 5, 197, 0, 0, 1423, 1424, 5, 281, 0, 0,
		1424, 1426, 5, 148, 0, 0, 1425, 1422, 1, 0, 0, 0, 1425, 1426, 1, 0, 0,
		0, 1426, 1427, 1, 0, 0, 0, 1427, 1428, 3, 1012, 506, 0, 1428, 1429, 5,
		2, 0, 0, 1429, 1434, 3, 34, 17, 0, 1430, 1431, 5, 3, 0, 0, 1431, 1433,
		3, 34, 17, 0, 1432, 1430, 1, 0, 0, 0, 1433, 1436, 1, 0, 0, 0, 1434, 1432,
		1, 0, 0, 0, 1434, 1435, 1, 0, 0, 0, 1435, 1441, 1, 0, 0, 0, 1436, 1434,
		1, 0, 0, 0, 1437, 1438, 5, 3, 0, 0, 1438, 1440, 3, 42, 21, 0, 1439, 1437,
		1, 0, 0, 0, 1440, 1443, 1, 0, 0, 0, 1441, 1439, 1, 0, 0, 0, 1441, 1442,
		1, 0, 0, 0, 1442, 1444, 1, 0, 0, 0, 1443, 1441, 1, 0, 0, 0, 1444, 1446,
		5, 4, 0, 0, 1445, 1447, 3, 44, 22, 0, 1446, 1445, 1, 0, 0, 0, 1446, 1447,
		1, 0, 0, 0, 1447, 1449, 1, 0, 0, 0, 1448, 1450, 3, 46, 23, 0, 1449, 1448,
		1, 0, 0, 0, 1449, 1450, 1, 0, 0, 0, 1450, 1452, 1, 0, 0, 0, 1451, 1453,
		3, 50, 25, 0, 1452, 1451, 1, 0, 0, 0, 1452, 1453, 1, 0, 0, 0, 1453, 1455,
		1, 0, 0, 0, 1454, 1456, 3, 970, 485, 0, 1455, 1454, 1, 0, 0, 0, 1455, 1456,
		1, 0, 0, 0, 1456, 1458, 1, 0, 0, 0, 1457, 1459, 3, 910, 455, 0, 1458, 1457,
		1, 0, 0, 0, 1458, 1459, 1, 0, 0, 0, 1459, 1461, 1, 0, 0, 0, 1460, 1462,
		3, 948, 474, 0, 1461, 1460, 1, 0, 0, 0, 1461, 1462, 1, 0, 0, 0, 1462, 1464,
		1, 0, 0, 0, 1463, 1465, 3, 52, 26, 0, 1464, 1463, 1, 0, 0, 0, 1464, 1465,
		1, 0, 0, 0, 1465, 1467, 1, 0, 0, 0, 1466, 1468, 3, 62, 31, 0, 1467, 1466,
		1, 0, 0, 0, 1467, 1468, 1, 0, 0, 0, 1468, 1470, 1, 0, 0, 0, 1469, 1471,
		3, 954, 477, 0, 1470, 1469, 1, 0, 0, 0, 1470, 1471, 1, 0, 0, 0, 1471, 1473,
		1, 0, 0, 0, 1472, 1474, 3, 956, 478, 0, 1473, 1472, 1, 0, 0, 0, 1473, 1474,
		1, 0, 0, 0, 1474, 33, 1, 0, 0, 0, 1475, 1477, 3, 1018, 509, 0, 1476, 1478,
		3, 994, 497, 0, 1477, 1476, 1, 0, 0, 0, 1477, 1478, 1, 0, 0, 0, 1478, 1480,
		1, 0, 0, 0, 1479, 1481, 3, 36, 18, 0, 1480, 1479, 1, 0, 0, 0, 1480, 1481,
		1, 0, 0, 0, 1481, 1483, 1, 0, 0, 0, 1482, 1484, 5, 227, 0, 0, 1483, 1482,
		1, 0, 0, 0, 1483, 1484, 1, 0, 0, 0, 1484, 1486, 1, 0, 0, 0, 1485, 1487,
		3, 60, 30, 0, 1486, 1485, 1, 0, 0, 0, 1486, 1487, 1, 0, 0, 0, 1487, 1489,
		1, 0, 0, 0, 1488, 1490, 3, 54, 27, 0, 1489, 1488, 1, 0, 0, 0, 1489, 1490,
		1, 0, 0, 0, 1490, 1494, 1, 0, 0, 0, 1491, 1495, 3, 38, 19, 0, 1492, 1495,
		5, 33, 0, 0, 1493, 1495, 3, 40, 20, 0, 1494, 1491, 1, 0, 0, 0, 1494, 1492,
		1, 0, 0, 0, 1494, 1493, 1, 0, 0, 0, 1494, 1495, 1, 0, 0, 0, 1495, 1497,
		1, 0, 0, 0, 1496, 1498, 3, 970, 485, 0, 1497, 1496, 1, 0, 0, 0, 1497, 1498,
		1, 0, 0, 0, 1498, 35, 1, 0, 0, 0, 1499, 1500, 5, 64, 0, 0, 1500, 1501,
		5, 396, 0, 0, 1501, 1508, 3, 1018, 509, 0, 1502, 1503, 5, 66, 0, 0, 1503,
		1508, 3, 1018, 509, 0, 1504, 1505, 5, 65, 0, 0, 1505, 1506, 5, 396, 0,
		0, 1506, 1508, 3, 1018, 509, 0, 1507, 1499, 1, 0, 0, 0, 1507, 1502, 1,
		0, 0, 0, 1507, 1504, 1, 0, 0, 0, 1508, 37, 1, 0, 0, 0, 1509, 1519, 5, 117,
		0, 0, 1510, 1520, 3, 976, 488, 0, 1511, 1520, 5, 282, 0, 0, 1512, 1520,
		5, 100, 0, 0, 1513, 1514, 5, 2, 0, 0, 1514, 1515, 3, 1012, 506, 0, 1515,
		1516, 5, 2, 0, 0, 1516, 1517, 5, 4, 0, 0, 1517, 1518, 5, 4, 0, 0, 1518,
		1520, 1, 0, 0, 0, 1519, 1510, 1, 0, 0, 0, 1519, 1511, 1, 0, 0, 0, 1519,
		1512, 1, 0, 0, 0, 1519, 1513, 1, 0, 0, 0, 1520, 39, 1, 0, 0, 0, 1521, 1522,
		5, 27, 0, 0, 1522, 1523, 3, 852, 426, 0, 1523, 41, 1, 0, 0, 0, 1524, 1525,
		5, 205, 0, 0, 1525, 1526, 3, 1018, 509, 0, 1526, 1531, 3, 1024, 512, 0,
		1527, 1529, 3, 86, 43, 0, 1528, 1530, 3, 958, 479, 0, 1529, 1528, 1, 0,
		0, 0, 1529, 1530, 1, 0, 0, 0, 1530, 1532, 1, 0, 0, 0, 1531, 1527, 1, 0,
		0, 0, 1531, 1532, 1, 0, 0, 0, 1532, 1534, 1, 0, 0, 0, 1533, 1535, 3, 970,
		485, 0, 1534, 1533, 1, 0, 0, 0, 1534, 1535, 1, 0, 0, 0, 1535, 43, 1, 0,
		0, 0, 1536, 1537, 5, 140, 0, 0, 1537, 1538, 5, 492, 0, 0, 1538, 1539, 3,
		1018, 509, 0, 1539, 45, 1, 0, 0, 0, 1540, 1542, 5, 117, 0, 0, 1541, 1540,
		1, 0, 0, 0, 1541, 1542, 1, 0, 0, 0, 1542, 1548, 1, 0, 0, 0, 1543, 1544,
		5, 64, 0, 0, 1544, 1549, 5, 396, 0, 0, 1545, 1549, 5, 66, 0, 0, 1546, 1547,
		5, 65, 0, 0, 1547, 1549, 5, 396, 0, 0, 1548, 1543, 1, 0, 0, 0, 1548, 1545,
		1, 0, 0, 0, 1548, 1546, 1, 0, 0, 0, 1549, 1551, 1, 0, 0, 0, 1550, 1552,
		5, 492, 0, 0, 1551, 1550, 1, 0, 0, 0, 1551, 1552, 1, 0, 0, 0, 1552, 1553,
		1, 0, 0, 0, 1553, 1554, 3, 1026, 513, 0, 1554, 47, 1, 0, 0, 0, 1555, 1557,
		5, 117, 0, 0, 1556, 1555, 1, 0, 0, 0, 1556, 1557, 1, 0, 0, 0, 1557, 1558,
		1, 0, 0, 0, 1558, 1560, 5, 74, 0, 0, 1559, 1561, 5, 492, 0, 0, 1560, 1559,
		1, 0, 0, 0, 1560, 1561, 1, 0, 0, 0, 1561, 1562, 1, 0, 0, 0, 1562, 1563,
		3, 1026, 513, 0, 1563, 49, 1, 0, 0, 0, 1564, 1565, 7, 4, 0, 0, 1565, 1566,
		5, 227, 0, 0, 1566, 1567, 3, 1024, 512, 0, 1567, 51, 1, 0, 0, 0, 1568,
		1569, 5, 298, 0, 0, 1569, 1570, 5, 55, 0, 0, 1570, 1571, 3, 1024, 512,
		0, 1571, 53, 1, 0, 0, 0, 1572, 1576, 5, 282, 0, 0, 1573, 1574, 5, 281,
		0, 0, 1574, 1576, 5, 282, 0, 0, 1575, 1572, 1, 0, 0, 0, 1575, 1573, 1,
		0, 0, 0, 1576, 55, 1, 0, 0, 0, 1577, 1579, 3, 994, 497, 0, 1578, 1580,
		3, 54, 27, 0, 1579, 1578, 1, 0, 0, 0, 1579, 1580, 1, 0, 0, 0, 1580, 57,
		1, 0, 0, 0, 1581, 1582, 3, 1018, 509, 0, 1582, 1583, 5, 2, 0, 0, 1583,
		1588, 3, 56, 28, 0, 1584, 1585, 5, 3, 0, 0, 1585, 1587, 3, 56, 28, 0, 1586,
		1584, 1, 0, 0, 0, 1587, 1590, 1, 0, 0, 0, 1588, 1586, 1, 0, 0, 0, 1588,
		1589, 1, 0, 0, 0, 1589, 1591, 1, 0, 0, 0, 1590, 1588, 1, 0, 0, 0, 1591,
		1592, 5, 4, 0, 0, 1592, 59, 1, 0, 0, 0, 1593, 1603, 5, 415, 0, 0, 1594,
		1603, 5, 258, 0, 0, 1595, 1603, 5, 263, 0, 0, 1596, 1603, 5, 356, 0, 0,
		1597, 1603, 5, 191, 0, 0, 1598, 1603, 5, 45, 0, 0, 1599, 1603, 5, 311,
		0, 0, 1600, 1603, 5, 357, 0, 0, 1601, 1603, 3, 58, 29, 0, 1602, 1593, 1,
		0, 0, 0, 1602, 1594, 1, 0, 0, 0, 1602, 1595, 1, 0, 0, 0, 1602, 1596, 1,
		0, 0, 0, 1602, 1597, 1, 0, 0, 0, 1602, 1598, 1, 0, 0, 0, 1602, 1599, 1,
		0, 0, 0, 1602, 1600, 1, 0, 0, 0, 1602, 1601, 1, 0, 0, 0, 1603, 61, 1, 0,
		0, 0, 1604, 1605, 5, 376, 0, 0, 1605, 1606, 5, 2, 0, 0, 1606, 1611, 3,
		64, 32, 0, 1607, 1608, 5, 3, 0, 0, 1608, 1610, 3, 64, 32, 0, 1609, 1607,
		1, 0, 0, 0, 1610, 1613, 1, 0, 0, 0, 1611, 1609, 1, 0, 0, 0, 1611, 1612,
		1, 0, 0, 0, 1612, 1614, 1, 0, 0, 0, 1613, 1611, 1, 0, 0, 0, 1614, 1615,
		5, 4, 0, 0, 1615, 63, 1, 0, 0, 0, 1616, 1617, 3, 1018, 509, 0, 1617, 1619,
		3, 1024, 512, 0, 1618, 1620, 3, 66, 33, 0, 1619, 1618, 1, 0, 0, 0, 1619,
		1620, 1, 0, 0, 0, 1620, 1622, 1, 0, 0, 0, 1621, 1623, 3, 68, 34, 0, 1622,
		1621, 1, 0, 0, 0, 1622, 1623, 1, 0, 0, 0, 1623, 1625, 1, 0, 0, 0, 1624,
		1626, 3, 954, 477, 0, 1625, 1624, 1, 0, 0, 0, 1625, 1626, 1, 0, 0, 0, 1626,
		65, 1, 0, 0, 0, 1627, 1628, 5, 134, 0, 0, 1628, 1629, 5, 227, 0, 0, 1629,
		1630, 3, 1024, 512, 0, 1630, 67, 1, 0, 0, 0, 1631, 1632, 5, 172, 0, 0,
		1632, 1633, 3, 1018, 509, 0, 1633, 69, 1, 0, 0, 0, 1634, 1635, 5, 297,
		0, 0, 1635, 1637, 5, 356, 0, 0, 1636, 1634, 1, 0, 0, 0, 1636, 1637, 1,
		0, 0, 0, 1637, 71, 1, 0, 0, 0, 1638, 1639, 5, 197, 0, 0, 1639, 1640, 5,
		281, 0, 0, 1640, 1642, 5, 148, 0, 0, 1641, 1638, 1, 0, 0, 0, 1641, 1642,
		1, 0, 0, 0, 1642, 73, 1, 0, 0, 0, 1643, 1645, 5, 90, 0, 0, 1644, 1646,
		5, 428, 0, 0, 1645, 1644, 1, 0, 0, 0, 1645, 1646, 1, 0, 0, 0, 1646, 1647,
		1, 0, 0, 0, 1647, 1651, 5, 422, 0, 0, 1648, 1649, 5, 197, 0, 0, 1649, 1650,
		5, 281, 0, 0, 1650, 1652, 5, 148, 0, 0, 1651, 1648, 1, 0, 0, 0, 1651, 1652,
		1, 0, 0, 0, 1652, 1653, 1, 0, 0, 0, 1653, 1682, 3, 1012, 506, 0, 1654,
		1678, 5, 2, 0, 0, 1655, 1660, 3, 1018, 509, 0, 1656, 1657, 5, 3, 0, 0,
		1657, 1659, 3, 1018, 509, 0, 1658, 1656, 1, 0, 0, 0, 1659, 1662, 1, 0,
		0, 0, 1660, 1658, 1, 0, 0, 0, 1660, 1661, 1, 0, 0, 0, 1661, 1667, 1, 0,
		0, 0, 1662, 1660, 1, 0, 0, 0, 1663, 1664, 5, 3, 0, 0, 1664, 1666, 3, 42,
		21, 0, 1665, 1663, 1, 0, 0, 0, 1666, 1669, 1, 0, 0, 0, 1667, 1665, 1, 0,
		0, 0, 1667, 1668, 1, 0, 0, 0, 1668, 1679, 1, 0, 0, 0, 1669, 1667, 1, 0,
		0, 0, 1670, 1675, 3, 42, 21, 0, 1671, 1672, 5, 3, 0, 0, 1672, 1674, 3,
		42, 21, 0, 1673, 1671, 1, 0, 0, 0, 1674, 1677, 1, 0, 0, 0, 1675, 1673,
		1, 0, 0, 0, 1675, 1676, 1, 0, 0, 0, 1676, 1679, 1, 0, 0, 0, 1677, 1675,
		1, 0, 0, 0, 1678, 1655, 1, 0, 0, 0, 1678, 1670, 1, 0, 0, 0, 1679, 1680,
		1, 0, 0, 0, 1680, 1681, 5, 4, 0, 0, 1681, 1683, 1, 0, 0, 0, 1682, 1654,
		1, 0, 0, 0, 1682, 1683, 1, 0, 0, 0, 1683, 1685, 1, 0, 0, 0, 1684, 1686,
		3, 50, 25, 0, 1685, 1684, 1, 0, 0, 0, 1685, 1686, 1, 0, 0, 0, 1686, 1688,
		1, 0, 0, 0, 1687, 1689, 3, 970, 485, 0, 1688, 1687, 1, 0, 0, 0, 1688, 1689,
		1, 0, 0, 0, 1689, 1691, 1, 0, 0, 0, 1690, 1692, 3, 910, 455, 0, 1691, 1690,
		1, 0, 0, 0, 1691, 1692, 1, 0, 0, 0, 1692, 1694, 1, 0, 0, 0, 1693, 1695,
		3, 948, 474, 0, 1694, 1693, 1, 0, 0, 0, 1694, 1695, 1, 0, 0, 0, 1695, 1697,
		1, 0, 0, 0, 1696, 1698, 3, 52, 26, 0, 1697, 1696, 1, 0, 0, 0, 1697, 1698,
		1, 0, 0, 0, 1698, 1700, 1, 0, 0, 0, 1699, 1701, 3, 954, 477, 0, 1700, 1699,
		1, 0, 0, 0, 1700, 1701, 1, 0, 0, 0, 1701, 1702, 1, 0, 0, 0, 1702, 1703,
		5, 27, 0, 0, 1703, 1704, 3, 752, 376, 0, 1704, 75, 1, 0, 0, 0, 1705, 1707,
		5, 132, 0, 0, 1706, 1708, 5, 428, 0, 0, 1707, 1706, 1, 0, 0, 0, 1707, 1708,
		1, 0, 0, 0, 1708, 1709, 1, 0, 0, 0, 1709, 1712, 5, 422, 0, 0, 1710, 1711,
		5, 197, 0, 0, 1711, 1713, 5, 148, 0, 0, 1712, 1710, 1, 0, 0, 0, 1712, 1713,
		1, 0, 0, 0, 1713, 1714, 1, 0, 0, 0, 1714, 1716, 3, 1012, 506, 0, 1715,
		1717, 5, 169, 0, 0, 1716, 1715, 1, 0, 0, 0, 1716, 1717, 1, 0, 0, 0, 1717,
		77, 1, 0, 0, 0, 1718, 1719, 5, 68, 0, 0, 1719, 1720, 5, 428, 0, 0, 1720,
		1721, 5, 422, 0, 0, 1721, 1722, 5, 290, 0, 0, 1722, 1723, 5, 395, 0, 0,
		1723, 1724, 3, 976, 488, 0, 1724, 79, 1, 0, 0, 0, 1725, 1726, 5, 19, 0,
		0, 1726, 1727, 5, 422, 0, 0, 1727, 1728, 3, 1012, 506, 0, 1728, 1733, 3,
		232, 116, 0, 1729, 1730, 5, 3, 0, 0, 1730, 1732, 3, 232, 116, 0, 1731,
		1729, 1, 0, 0, 0, 1732, 1735, 1, 0, 0, 0, 1733, 1731, 1, 0, 0, 0, 1733,
		1734, 1, 0, 0, 0, 1734, 1763, 1, 0, 0, 0, 1735, 1733, 1, 0, 0, 0, 1736,
		1737, 5, 19, 0, 0, 1737, 1738, 5, 422, 0, 0, 1738, 1739, 3, 1012, 506,
		0, 1739, 1740, 5, 13, 0, 0, 1740, 1741, 5, 376, 0, 0, 1741, 1746, 3, 64,
		32, 0, 1742, 1743, 5, 3, 0, 0, 1743, 1745, 3, 64, 32, 0, 1744, 1742, 1,
		0, 0, 0, 1745, 1748, 1, 0, 0, 0, 1746, 1744, 1, 0, 0, 0, 1746, 1747, 1,
		0, 0, 0, 1747, 1763, 1, 0, 0, 0, 1748, 1746, 1, 0, 0, 0, 1749, 1750, 5,
		19, 0, 0, 1750, 1751, 5, 422, 0, 0, 1751, 1752, 3, 1012, 506, 0, 1752,
		1753, 5, 132, 0, 0, 1753, 1754, 5, 376, 0, 0, 1754, 1759, 3, 1018, 509,
		0, 1755, 1756, 5, 3, 0, 0, 1756, 1758, 3, 1018, 509, 0, 1757, 1755, 1,
		0, 0, 0, 1758, 1761, 1, 0, 0, 0, 1759, 1757, 1, 0, 0, 0, 1759, 1760, 1,
		0, 0, 0, 1760, 1763, 1, 0, 0, 0, 1761, 1759, 1, 0, 0, 0, 1762, 1725, 1,
		0, 0, 0, 1762, 1736, 1, 0, 0, 0, 1762, 1749, 1, 0, 0, 0, 1763, 81, 1, 0,
		0, 0, 1764, 1765, 5, 90, 0, 0, 1765, 1766, 5, 205, 0, 0, 1766, 1767, 3,
		1018, 509, 0, 1767, 1768, 5, 290, 0, 0, 1768, 1769, 3, 1012, 506, 0, 1769,
		1774, 3, 1024, 512, 0, 1770, 1772, 3, 86, 43, 0, 1771, 1773, 3, 958, 479,
		0, 1772, 1771, 1, 0, 0, 0, 1772, 1773, 1, 0, 0, 0, 1773, 1775, 1, 0, 0,
		0, 1774, 1770, 1, 0, 0, 0, 1774, 1775, 1, 0, 0, 0, 1775, 1777, 1, 0, 0,
		0, 1776, 1778, 3, 970, 485, 0, 1777, 1776, 1, 0, 0, 0, 1777, 1778, 1, 0,
		0, 0, 1778, 83, 1, 0, 0, 0, 1779, 1780, 5, 132, 0, 0, 1780, 1781, 5, 205,
		0, 0, 1781, 1782, 3, 1018, 509, 0, 1782, 1783, 5, 290, 0, 0, 1783, 1784,
		3, 1012, 506, 0, 1784, 85, 1, 0, 0, 0, 1785, 1786, 5, 460, 0, 0, 1786,
		1787, 7, 5, 0, 0, 1787, 87, 1, 0, 0, 0, 1788, 1790, 5, 401, 0, 0, 1789,
		1791, 5, 175, 0, 0, 1790, 1789, 1, 0, 0, 0, 1790, 1791, 1, 0, 0, 0, 1791,
		1792, 1, 0, 0, 0, 1792, 1795, 5, 423, 0, 0, 1793, 1794, 7, 1, 0, 0, 1794,
		1796, 3, 1012, 506, 0, 1795, 1793, 1, 0, 0, 0, 1795, 1796, 1, 0, 0, 0,
		1796, 1801, 1, 0, 0, 0, 1797, 1798, 5, 240, 0, 0, 1798, 1802, 3, 976, 488,
		0, 1799, 1800, 5, 478, 0, 0, 1800, 1802, 3, 852, 426, 0, 1801, 1797, 1,
		0, 0, 0, 1801, 1799, 1, 0, 0, 0, 1801, 1802, 1, 0, 0, 0, 1802, 89, 1, 0,
		0, 0, 1803, 1804, 5, 401, 0, 0, 1804, 1805, 5, 428, 0, 0, 1805, 1808, 5,
		423, 0, 0, 1806, 1807, 7, 1, 0, 0, 1807, 1809, 3, 1012, 506, 0, 1808, 1806,
		1, 0, 0, 0, 1808, 1809, 1, 0, 0, 0, 1809, 1814, 1, 0, 0, 0, 1810, 1811,
		5, 240, 0, 0, 1811, 1815, 3, 976, 488, 0, 1812, 1813, 5, 478, 0, 0, 1813,
		1815, 3, 852, 426, 0, 1814, 1810, 1, 0, 0, 0, 1814, 1812, 1, 0, 0, 0, 1814,
		1815, 1, 0, 0, 0, 1815, 91, 1, 0, 0, 0, 1816, 1817, 5, 401, 0, 0, 1817,
		1822, 5, 90, 0, 0, 1818, 1823, 5, 422, 0, 0, 1819, 1823, 5, 469, 0, 0,
		1820, 1821, 5, 257, 0, 0, 1821, 1823, 5, 469, 0, 0, 1822, 1818, 1, 0, 0,
		0, 1822, 1819, 1, 0, 0, 0, 1822, 1820, 1, 0, 0, 0, 1823, 1824, 1, 0, 0,
		0, 1824, 1825, 3, 1012, 506, 0, 1825, 93, 1, 0, 0, 0, 1826, 1828, 5, 401,
		0, 0, 1827, 1829, 5, 175, 0, 0, 1828, 1827, 1, 0, 0, 0, 1828, 1829, 1,
		0, 0, 0, 1829, 1830, 1, 0, 0, 0, 1830, 1831, 7, 6, 0, 0, 1831, 1832, 7,
		1, 0, 0, 1832, 1833, 3, 1012, 506, 0, 1833, 1836, 1, 0, 0, 0, 1834, 1835,
		7, 1, 0, 0, 1835, 1837, 3, 1012, 506, 0, 1836, 1834, 1, 0, 0, 0, 1836,
		1837, 1, 0, 0, 0, 1837, 1842, 1, 0, 0, 0, 1838, 1839, 5, 240, 0, 0, 1839,
		1843, 3, 976, 488, 0, 1840, 1841, 5, 478, 0, 0, 1841, 1843, 3, 852, 426,
		0, 1842, 1838, 1, 0, 0, 0, 1842, 1840, 1, 0, 0, 0, 1842, 1843, 1, 0, 0,
		0, 1843, 95, 1, 0, 0, 0, 1844, 1845, 5, 401, 0, 0, 1845, 1846, 5, 422,
		0, 0, 1846, 1849, 5, 408, 0, 0, 1847, 1848, 7, 1, 0, 0, 1848, 1850, 3,
		1012, 506, 0, 1849, 1847, 1, 0, 0, 0, 1849, 1850, 1, 0, 0, 0, 1850, 1855,
		1, 0, 0, 0, 1851, 1852, 5, 240, 0, 0, 1852, 1856, 3, 976, 488, 0, 1853,
		1854, 5, 478, 0, 0, 1854, 1856, 3, 852, 426, 0, 1855, 1851, 1, 0, 0, 0,
		1855, 1853, 1, 0, 0, 0, 1855, 1856, 1, 0, 0, 0, 1856, 97, 1, 0, 0, 0, 1857,
		1858, 5, 348, 0, 0, 1858, 1859, 5, 151, 0, 0, 1859, 1860, 5, 422, 0, 0,
		1860, 1873, 3, 1012, 506, 0, 1861, 1862, 5, 303, 0, 0, 1862, 1863, 5, 2,
		0, 0, 1863, 1868, 3, 976, 488, 0, 1864, 1865, 5, 3, 0, 0, 1865, 1867, 3,
		976, 488, 0, 1866, 1864, 1, 0, 0, 0, 1867, 1870, 1, 0, 0, 0, 1868, 1866,
		1, 0, 0, 0, 1868, 1869, 1, 0, 0, 0, 1869, 1871, 1, 0, 0, 0, 1870, 1868,
		1, 0, 0, 0, 1871, 1872, 5, 4, 0, 0, 1872, 1874, 1, 0, 0, 0, 1873, 1861,
		1, 0, 0, 0, 1873, 1874, 1, 0, 0, 0, 1874, 99, 1, 0, 0, 0, 1875, 1876, 5,
		401, 0, 0, 1876, 1877, 5, 19, 0, 0, 1877, 1878, 5, 422, 0, 0, 1878, 1881,
		7, 7, 0, 0, 1879, 1880, 7, 1, 0, 0, 1880, 1882, 3, 1012, 506, 0, 1881,
		1879, 1, 0, 0, 0, 1881, 1882, 1, 0, 0, 0, 1882, 1885, 1, 0, 0, 0, 1883,
		1884, 5, 478, 0, 0, 1884, 1886, 3, 852, 426, 0, 1885, 1883, 1, 0, 0, 0,
		1885, 1886, 1, 0, 0, 0, 1886, 1897, 1, 0, 0, 0, 1887, 1888, 5, 298, 0,
		0, 1888, 1889, 5, 55, 0, 0, 1889, 1894, 3, 770, 385, 0, 1890, 1891, 5,
		3, 0, 0, 1891, 1893, 3, 770, 385, 0, 1892, 1890, 1, 0, 0, 0, 1893, 1896,
		1, 0, 0, 0, 1894, 1892, 1, 0, 0, 0, 1894, 1895, 1, 0, 0, 0, 1895, 1898,
		1, 0, 0, 0, 1896, 1894, 1, 0, 0, 0, 1897, 1887, 1, 0, 0, 0, 1897, 1898,
		1, 0, 0, 0, 1898, 1900, 1, 0, 0, 0, 1899, 1901, 3, 774, 387, 0, 1900, 1899,
		1, 0, 0, 0, 1900, 1901, 1, 0, 0, 0, 1901, 1930, 1, 0, 0, 0, 1902, 1903,
		5, 401, 0, 0, 1903, 1904, 5, 19, 0, 0, 1904, 1905, 5, 257, 0, 0, 1905,
		1908, 5, 469, 0, 0, 1906, 1907, 7, 1, 0, 0, 1907, 1909, 3, 1012, 506, 0,
		1908, 1906, 1, 0, 0, 0, 1908, 1909, 1, 0, 0, 0, 1909, 1912, 1, 0, 0, 0,
		1910, 1911, 5, 478, 0, 0, 1911, 1913, 3, 852, 426, 0, 1912, 1910, 1, 0,
		0, 0, 1912, 1913, 1, 0, 0, 0, 1913, 1924, 1, 0, 0, 0, 1914, 1915, 5, 298,
		0, 0, 1915, 1916, 5, 55, 0, 0, 1916, 1921, 3, 770, 385, 0, 1917, 1918,
		5, 3, 0, 0, 1918, 1920, 3, 770, 385, 0, 1919, 1917, 1, 0, 0, 0, 1920, 1923,
		1, 0, 0, 0, 1921, 1919, 1, 0, 0, 0, 1921, 1922, 1, 0, 0, 0, 1922, 1925,
		1, 0, 0, 0, 1923, 1921, 1, 0, 0, 0, 1924, 1914, 1, 0, 0, 0, 1924, 1925,
		1, 0, 0, 0, 1925, 1927, 1, 0, 0, 0, 1926, 1928, 3, 774, 387, 0, 1927, 1926,
		1, 0, 0, 0, 1927, 1928, 1, 0, 0, 0, 1928, 1930, 1, 0, 0, 0, 1929, 1875,
		1, 0, 0, 0, 1929, 1902, 1, 0, 0, 0, 1930, 101, 1, 0, 0, 0, 1931, 1938,
		7, 8, 0, 0, 1932, 1934, 3, 1012, 506, 0, 1933, 1935, 5, 18, 0, 0, 1934,
		1933, 1, 0, 0, 0, 1934, 1935, 1, 0, 0, 0, 1935, 1939, 1, 0, 0, 0, 1936,
		1937, 5, 159, 0, 0, 1937, 1939, 3, 958, 479, 0, 1938, 1932, 1, 0, 0, 0,
		1938, 1936, 1, 0, 0, 0, 1939, 103, 1, 0, 0, 0, 1940, 1942, 5, 90, 0, 0,
		1941, 1943, 7, 3, 0, 0, 1942, 1941, 1, 0, 0, 0, 1942, 1943, 1, 0, 0, 0,
		1943, 1944, 1, 0, 0, 0, 1944, 1948, 5, 422, 0, 0, 1945, 1946, 5, 197, 0,
		0, 1946, 1947, 5, 281, 0, 0, 1947, 1949, 5, 148, 0, 0, 1948, 1945, 1, 0,
		0, 0, 1948, 1949, 1, 0, 0, 0, 1949, 1950, 1, 0, 0, 0, 1950, 1952, 3, 1012,
		506, 0, 1951, 1953, 3, 910, 455, 0, 1952, 1951, 1, 0, 0, 0, 1952, 1953,
		1, 0, 0, 0, 1953, 1955, 1, 0, 0, 0, 1954, 1956, 3, 948, 474, 0, 1955, 1954,
		1, 0, 0, 0, 1955, 1956, 1, 0, 0, 0, 1956, 1958, 1, 0, 0, 0, 1957, 1959,
		3, 954, 477, 0, 1958, 1957, 1, 0, 0, 0, 1958, 1959, 1, 0, 0, 0, 1959, 1960,
		1, 0, 0, 0, 1960, 1961, 5, 240, 0, 0, 1961, 1962, 3, 1012, 506, 0, 1962,
		105, 1, 0, 0, 0, 1963, 1964, 5, 401, 0, 0, 1964, 1965, 7, 9, 0, 0, 1965,
		1966, 7, 1, 0, 0, 1966, 1967, 3, 1012, 506, 0, 1967, 1970, 1, 0, 0, 0,
		1968, 1969, 7, 1, 0, 0, 1969, 1971, 3, 1012, 506, 0, 1970, 1968, 1, 0,
		0, 0, 1970, 1971, 1, 0, 0, 0, 1971, 107, 1, 0, 0, 0, 1972, 1973, 5, 347,
		0, 0, 1973, 1974, 5, 422, 0, 0, 1974, 1975, 3, 1012, 506, 0, 1975, 109,
		1, 0, 0, 0, 1976, 1977, 5, 445, 0, 0, 1977, 1978, 5, 422, 0, 0, 1978, 1980,
		3, 1012, 506, 0, 1979, 1981, 3, 826, 413, 0, 1980, 1979, 1, 0, 0, 0, 1980,
		1981, 1, 0, 0, 0, 1981, 111, 1, 0, 0, 0, 1982, 1983, 5, 57, 0, 0, 1983,
		1984, 5, 19, 0, 0, 1984, 1986, 5, 422, 0, 0, 1985, 1987, 7, 7, 0, 0, 1986,
		1985, 1, 0, 0, 0, 1986, 1987, 1, 0, 0, 0, 1987, 1988, 1, 0, 0, 0, 1988,
		1989, 5, 172, 0, 0, 1989, 2000, 3, 1012, 506, 0, 1990, 1991, 5, 2, 0, 0,
		1991, 1996, 5, 518, 0, 0, 1992, 1993, 5, 3, 0, 0, 1993, 1995, 5, 518, 0,
		0, 1994, 1992, 1, 0, 0, 0, 1995, 1998, 1, 0, 0, 0, 1996, 1994, 1, 0, 0,
		0, 1996, 1997, 1, 0, 0, 0, 1997, 1999, 1, 0, 0, 0, 1998, 1996, 1, 0, 0,
		0, 1999, 2001, 5, 4, 0, 0, 2000, 1990, 1, 0, 0, 0, 2000, 2001, 1, 0, 0,
		0, 2001, 2009, 1, 0, 0, 0, 2002, 2003, 5, 57, 0, 0, 2003, 2004, 5, 19,
		0, 0, 2004, 2005, 5, 257, 0, 0, 2005, 2006, 5, 469, 0, 0, 2006, 2007, 5,
		172, 0, 0, 2007, 2009, 3, 1012, 506, 0, 2008, 1982, 1, 0, 0, 0, 2008, 2002,
		1, 0, 0, 0, 2009, 113, 1, 0, 0, 0, 2010, 2012, 5, 401, 0, 0, 2011, 2013,
		5, 428, 0, 0, 2012, 2011, 1, 0, 0, 0, 2012, 2013, 1, 0, 0, 0, 2013, 2014,
		1, 0, 0, 0, 2014, 2015, 5, 304, 0, 0, 2015, 2016, 5, 172, 0, 0, 2016, 2019,
		3, 1012, 506, 0, 2017, 2018, 5, 478, 0, 0, 2018, 2020, 3, 852, 426, 0,
		2019, 2017, 1, 0, 0, 0, 2019, 2020, 1, 0, 0, 0, 2020, 2031, 1, 0, 0, 0,
		2021, 2022, 5, 298, 0, 0, 2022, 2023, 5, 55, 0, 0, 2023, 2028, 3, 770,
		385, 0, 2024, 2025, 5, 3, 0, 0, 2025, 2027, 3, 770, 385, 0, 2026, 2024,
		1, 0, 0, 0, 2027, 2030, 1, 0, 0, 0, 2028, 2026, 1, 0, 0, 0, 2028, 2029,
		1, 0, 0, 0, 2029, 2032, 1, 0, 0, 0, 2030, 2028, 1, 0, 0, 0, 2031, 2021,
		1, 0, 0, 0, 2031, 2032, 1, 0, 0, 0, 2032, 2034, 1, 0, 0, 0, 2033, 2035,
		3, 774, 387, 0, 2034, 2033, 1, 0, 0, 0, 2034, 2035, 1, 0, 0, 0, 2035, 115,
		1, 0, 0, 0, 2036, 2037, 5, 347, 0, 0, 2037, 2038, 5, 303, 0, 0, 2038, 2039,
		3, 1018, 509, 0, 2039, 2040, 5, 172, 0, 0, 2040, 2041, 3, 1012, 506, 0,
		2041, 117, 1, 0, 0, 0, 2042, 2045, 5, 90, 0, 0, 2043, 2044, 5, 297, 0,
		0, 2044, 2046, 5, 356, 0, 0, 2045, 2043, 1, 0, 0, 0, 2045, 2046, 1, 0,
		0, 0, 2046, 2047, 1, 0, 0, 0, 2047, 2051, 5, 469, 0, 0, 2048, 2049, 5,
		197, 0, 0, 2049, 2050, 5, 281, 0, 0, 2050, 2052, 5, 148, 0, 0, 2051, 2048,
		1, 0, 0, 0, 2051, 2052, 1, 0, 0, 0, 2052, 2053, 1, 0, 0, 0, 2053, 2065,
		3, 1012, 506, 0, 2054, 2055, 5, 2, 0, 0, 2055, 2060, 3, 124, 62, 0, 2056,
		2057, 5, 3, 0, 0, 2057, 2059, 3, 124, 62, 0, 2058, 2056, 1, 0, 0, 0, 2059,
		2062, 1, 0, 0, 0, 2060, 2058, 1, 0, 0, 0, 2060, 2061, 1, 0, 0, 0, 2061,
		2063, 1, 0, 0, 0, 2062, 2060, 1, 0, 0, 0, 2063, 2064, 5, 4, 0, 0, 2064,
		2066, 1, 0, 0, 0, 2065, 2054, 1, 0, 0, 0, 2065, 2066, 1, 0, 0, 0, 2066,
		2068, 1, 0, 0, 0, 2067, 2069, 3, 970, 485, 0, 2068, 2067, 1, 0, 0, 0, 2068,
		2069, 1, 0, 0, 0, 2069, 2072, 1, 0, 0, 0, 2070, 2071, 5, 390, 0, 0, 2071,
		2073, 7, 10, 0, 0, 2072, 2070, 1, 0, 0, 0, 2072, 2073, 1, 0, 0, 0, 2073,
		2074, 1, 0, 0, 0, 2074, 2075, 5, 27, 0, 0, 2075, 2076, 3, 752, 376, 0,
		2076, 119, 1, 0, 0, 0, 2077, 2078, 5, 19, 0, 0, 2078, 2079, 5, 469, 0,
		0, 2079, 2091, 3, 1012, 506, 0, 2080, 2081, 5, 2, 0, 0, 2081, 2086, 3,
		124, 62, 0, 2082, 2083, 5, 3, 0, 0, 2083, 2085, 3, 124, 62, 0, 2084, 2082,
		1, 0, 0, 0, 2085, 2088, 1, 0, 0, 0, 2086, 2084, 1, 0, 0, 0, 2086, 2087,
		1, 0, 0, 0, 2087, 2089, 1, 0, 0, 0, 2088, 2086, 1, 0, 0, 0, 2089, 2090,
		5, 4, 0, 0, 2090, 2092, 1, 0, 0, 0, 2091, 2080, 1, 0, 0, 0, 2091, 2092,
		1, 0, 0, 0, 2092, 2093, 1, 0, 0, 0, 2093, 2094, 5, 27, 0, 0, 2094, 2095,
		3, 752, 376, 0, 2095, 2117, 1, 0, 0, 0, 2096, 2097, 5, 19, 0, 0, 2097,
		2098, 5, 469, 0, 0, 2098, 2099, 3, 1012, 506, 0, 2099, 2100, 5, 396, 0,
		0, 2100, 2101, 5, 390, 0, 0, 2101, 2102, 7, 10, 0, 0, 2102, 2117, 1, 0,
		0, 0, 2103, 2104, 5, 19, 0, 0, 2104, 2105, 5, 469, 0, 0, 2105, 2106, 3,
		1012, 506, 0, 2106, 2107, 5, 396, 0, 0, 2107, 2108, 3, 954, 477, 0, 2108,
		2117, 1, 0, 0, 0, 2109, 2110, 5, 19, 0, 0, 2110, 2111, 5, 469, 0, 0, 2111,
		2112, 3, 1012, 506, 0, 2112, 2113, 7, 11, 0, 0, 2113, 2114, 5, 121, 0,
		0, 2114, 2115, 3, 752, 376, 0, 2115, 2117, 1, 0, 0, 0, 2116, 2077, 1, 0,
		0, 0, 2116, 2096, 1, 0, 0, 0, 2116, 2103, 1, 0, 0, 0, 2116, 2109, 1, 0,
		0, 0, 2117, 121, 1, 0, 0, 0, 2118, 2119, 5, 132, 0, 0, 2119, 2122, 5, 469,
		0, 0, 2120, 2121, 5, 197, 0, 0, 2121, 2123, 5, 148, 0, 0, 2122, 2120, 1,
		0, 0, 0, 2122, 2123, 1, 0, 0, 0, 2123, 2124, 1, 0, 0, 0, 2124, 2125, 3,
		1012, 506, 0, 2125, 123, 1, 0, 0, 0, 2126, 2128, 3, 1018, 509, 0, 2127,
		2129, 3, 970, 485, 0, 2128, 2127, 1, 0, 0, 0, 2128, 2129, 1, 0, 0, 0, 2129,
		125, 1, 0, 0, 0, 2130, 2131, 5, 414, 0, 0, 2131, 2133, 5, 427, 0, 0, 2132,
		2134, 3, 1012, 506, 0, 2133, 2132, 1, 0, 0, 0, 2133, 2134, 1, 0, 0, 0,
		2134, 2138, 1, 0, 0, 0, 2135, 2137, 3, 128, 64, 0, 2136, 2135, 1, 0, 0,
		0, 2137, 2140, 1, 0, 0, 0, 2138, 2136, 1, 0, 0, 0, 2138, 2139, 1, 0, 0,
		0, 2139, 2141, 1, 0, 0, 0, 2140, 2138, 1, 0, 0, 0, 2141, 2145, 5, 27, 0,
		0, 2142, 2146, 3, 74, 37, 0, 2143, 2146, 3, 352, 176, 0, 2144, 2146, 3,
		648, 324, 0, 2145, 2142, 1, 0, 0, 0, 2145, 2143, 1, 0, 0, 0, 2145, 2144,
		1, 0, 0, 0, 2146, 127, 1, 0, 0, 0, 2147, 2150, 3, 954, 477, 0, 2148, 2150,
		3, 132, 66, 0, 2149, 2147, 1, 0, 0, 0, 2149, 2148, 1, 0, 0, 0, 2150, 129,
		1, 0, 0, 0, 2151, 2152, 5, 132, 0, 0, 2152, 2153, 5, 427, 0, 0, 2153, 2155,
		3, 1012, 506, 0, 2154, 2156, 5, 169, 0, 0, 2155, 2154, 1, 0, 0, 0, 2155,
		2156, 1, 0, 0, 0, 2156, 131, 1, 0, 0, 0, 2157, 2163, 5, 385, 0, 0, 2158,
		2159, 5, 406, 0, 0, 2159, 2160, 5, 2, 0, 0, 2160, 2161, 3, 976, 488, 0,
		2161, 2162, 5, 4, 0, 0, 2162, 2164, 1, 0, 0, 0, 2163, 2158, 1, 0, 0, 0,
		2163, 2164, 1, 0, 0, 0, 2164, 2165, 1, 0, 0, 0, 2165, 2166, 5, 153, 0,
		0, 2166, 2167, 5, 2, 0, 0, 2167, 2168, 3, 986, 493, 0, 2168, 2169, 5, 4,
		0, 0, 2169, 133, 1, 0, 0, 0, 2170, 2171, 5, 90, 0, 0, 2171, 2172, 5, 257,
		0, 0, 2172, 2176, 5, 469, 0, 0, 2173, 2174, 5, 197, 0, 0, 2174, 2175, 5,
		281, 0, 0, 2175, 2177, 5, 148, 0, 0, 2176, 2173, 1, 0, 0, 0, 2176, 2177,
		1, 0, 0, 0, 2177, 2178, 1, 0, 0, 0, 2178, 2197, 3, 1012, 506, 0, 2179,
		2180, 5, 2, 0, 0, 2180, 2185, 3, 124, 62, 0, 2181, 2182, 5, 3, 0, 0, 2182,
		2184, 3, 124, 62, 0, 2183, 2181, 1, 0, 0, 0, 2184, 2187, 1, 0, 0, 0, 2185,
		2183, 1, 0, 0, 0, 2185, 2186, 1, 0, 0, 0, 2186, 2192, 1, 0, 0, 0, 2187,
		2185, 1, 0, 0, 0, 2188, 2189, 5, 3, 0, 0, 2189, 2191, 3, 42, 21, 0, 2190,
		2188, 1, 0, 0, 0, 2191, 2194, 1, 0, 0, 0, 2192, 2190, 1, 0, 0, 0, 2192,
		2193, 1, 0, 0, 0, 2193, 2195, 1, 0, 0, 0, 2194, 2192, 1, 0, 0, 0, 2195,
		2196, 5, 4, 0, 0, 2196, 2198, 1, 0, 0, 0, 2197, 2179, 1, 0, 0, 0, 2197,
		2198, 1, 0, 0, 0, 2198, 2200, 1, 0, 0, 0, 2199, 2201, 3, 970, 485, 0, 2200,
		2199, 1, 0, 0, 0, 2200, 2201, 1, 0, 0, 0, 2201, 2205, 1, 0, 0, 0, 2202,
		2204, 3, 138, 69, 0, 2203, 2202, 1, 0, 0, 0, 2204, 2207, 1, 0, 0, 0, 2205,
		2203, 1, 0, 0, 0, 2205, 2206, 1, 0, 0, 0, 2206, 2208, 1, 0, 0, 0, 2207,
		2205, 1, 0, 0, 0, 2208, 2209, 5, 27, 0, 0, 2209, 2210, 3, 752, 376, 0,
		2210, 135, 1, 0, 0, 0, 2211, 2224, 3, 866, 433, 0, 2212, 2213, 5, 2, 0,
		0, 2213, 2218, 3, 866, 433, 0, 2214, 2215, 5, 3, 0, 0, 2215, 2217, 3, 866,
		433, 0, 2216, 2214, 1, 0, 0, 0, 2217, 2220, 1, 0, 0, 0, 2218, 2216, 1,
		0, 0, 0, 2218, 2219, 1, 0, 0, 0, 2219, 2221, 1, 0, 0, 0, 2220, 2218, 1,
		0, 0, 0, 2221, 2222, 5, 4, 0, 0, 2222, 2224, 1, 0, 0, 0, 2223, 2211, 1,
		0, 0, 0, 2223, 2212, 1, 0, 0, 0, 2224, 137, 1, 0, 0, 0, 2225, 2226, 5,
		303, 0, 0, 2226, 2227, 5, 55, 0, 0, 2227, 2233, 3, 136, 68, 0, 2228, 2233,
		3, 948, 474, 0, 2229, 2233, 3, 52, 26, 0, 2230, 2233, 3, 950, 475, 0, 2231,
		2233, 3, 954, 477, 0, 2232, 2225, 1, 0, 0, 0, 2232, 2228, 1, 0, 0, 0, 2232,
		2229, 1, 0, 0, 0, 2232, 2230, 1, 0, 0, 0, 2232, 2231, 1, 0, 0, 0, 2233,
		139, 1, 0, 0, 0, 2234, 2235, 5, 401, 0, 0, 2235, 2236, 5, 257, 0, 0, 2236,
		2239, 5, 470, 0, 0, 2237, 2238, 7, 1, 0, 0, 2238, 2240, 3, 1012, 506, 0,
		2239, 2237, 1, 0, 0, 0, 2239, 2240, 1, 0, 0, 0, 2240, 2245, 1, 0, 0, 0,
		2241, 2242, 5, 240, 0, 0, 2242, 2246, 3, 976, 488, 0, 2243, 2244, 5, 478,
		0, 0, 2244, 2246, 3, 852, 426, 0, 2245, 2241, 1, 0, 0, 0, 2245, 2243, 1,
		0, 0, 0, 2245, 2246, 1, 0, 0, 0, 2246, 141, 1, 0, 0, 0, 2247, 2248, 5,
		132, 0, 0, 2248, 2249, 5, 257, 0, 0, 2249, 2252, 5, 469, 0, 0, 2250, 2251,
		5, 197, 0, 0, 2251, 2253, 5, 148, 0, 0, 2252, 2250, 1, 0, 0, 0, 2252, 2253,
		1, 0, 0, 0, 2253, 2254, 1, 0, 0, 0, 2254, 2255, 3, 1012, 506, 0, 2255,
		143, 1, 0, 0, 0, 2256, 2257, 5, 19, 0, 0, 2257, 2258, 5, 257, 0, 0, 2258,
		2259, 5, 469, 0, 0, 2259, 2264, 3, 1012, 506, 0, 2260, 2265, 3, 950, 475,
		0, 2261, 2265, 3, 272, 136, 0, 2262, 2265, 3, 276, 138, 0, 2263, 2265,
		3, 274, 137, 0, 2264, 2260, 1, 0, 0, 0, 2264, 2261, 1, 0, 0, 0, 2264, 2262,
		1, 0, 0, 0, 2264, 2263, 1, 0, 0, 0, 2265, 2273, 1, 0, 0, 0, 2266, 2267,
		5, 19, 0, 0, 2267, 2268, 5, 257, 0, 0, 2268, 2269, 5, 469, 0, 0, 2269,
		2270, 3, 1012, 506, 0, 2270, 2271, 3, 952, 476, 0, 2271, 2273, 1, 0, 0,
		0, 2272, 2256, 1, 0, 0, 0, 2272, 2266, 1, 0, 0, 0, 2273, 145, 1, 0, 0,
		0, 2274, 2275, 5, 348, 0, 0, 2275, 2276, 5, 257, 0, 0, 2276, 2277, 5, 469,
		0, 0, 2277, 2283, 3, 1012, 506, 0, 2278, 2281, 5, 303, 0, 0, 2279, 2282,
		3, 936, 468, 0, 2280, 2282, 3, 922, 461, 0, 2281, 2279, 1, 0, 0, 0, 2281,
		2280, 1, 0, 0, 0, 2282, 2284, 1, 0, 0, 0, 2283, 2278, 1, 0, 0, 0, 2283,
		2284, 1, 0, 0, 0, 2284, 2286, 1, 0, 0, 0, 2285, 2287, 5, 169, 0, 0, 2286,
		2285, 1, 0, 0, 0, 2286, 2287, 1, 0, 0, 0, 2287, 2291, 1, 0, 0, 0, 2288,
		2289, 5, 480, 0, 0, 2289, 2290, 7, 12, 0, 0, 2290, 2292, 5, 269, 0, 0,
		2291, 2288, 1, 0, 0, 0, 2291, 2292, 1, 0, 0, 0, 2292, 2296, 1, 0, 0, 0,
		2293, 2294, 5, 480, 0, 0, 2294, 2295, 5, 324, 0, 0, 2295, 2297, 5, 518,
		0, 0, 2296, 2293, 1, 0, 0, 0, 2296, 2297, 1, 0, 0, 0, 2297, 147, 1, 0,
		0, 0, 2298, 2299, 5, 57, 0, 0, 2299, 2300, 5, 348, 0, 0, 2300, 2301, 5,
		257, 0, 0, 2301, 2302, 5, 469, 0, 0, 2302, 2304, 3, 1012, 506, 0, 2303,
		2305, 5, 169, 0, 0, 2304, 2303, 1, 0, 0, 0, 2304, 2305, 1, 0, 0, 0, 2305,
		149, 1, 0, 0, 0, 2306, 2307, 5, 14, 0, 0, 2307, 2308, 5, 396, 0, 0, 2308,
		2309, 5, 173, 0, 0, 2309, 2310, 5, 84, 0, 0, 2310, 2311, 5, 2, 0, 0, 2311,
		2312, 3, 962, 481, 0, 2312, 2315, 5, 4, 0, 0, 2313, 2314, 5, 480, 0, 0,
		2314, 2316, 5, 491, 0, 0, 2315, 2313, 1, 0, 0, 0, 2315, 2316, 1, 0, 0,
		0, 2316, 151, 1, 0, 0, 0, 2317, 2318, 5, 14, 0, 0, 2318, 2319, 5, 396,
		0, 0, 2319, 2320, 5, 358, 0, 0, 2320, 2321, 5, 408, 0, 0, 2321, 2322, 3,
		954, 477, 0, 2322, 153, 1, 0, 0, 0, 2323, 2324, 5, 14, 0, 0, 2324, 2325,
		5, 401, 0, 0, 2325, 2326, 5, 173, 0, 0, 2326, 2329, 5, 84, 0, 0, 2327,
		2328, 5, 240, 0, 0, 2328, 2330, 3, 976, 488, 0, 2329, 2327, 1, 0, 0, 0,
		2329, 2330, 1, 0, 0, 0, 2330, 155, 1, 0, 0, 0, 2331, 2332, 5, 14, 0, 0,
		2332, 2333, 5, 401, 0, 0, 2333, 2334, 5, 358, 0, 0, 2334, 2335, 5, 130,
		0, 0, 2335, 2336, 5, 172, 0, 0, 2336, 2338, 3, 1012, 506, 0, 2337, 2339,
		3, 826, 413, 0, 2338, 2337, 1, 0, 0, 0, 2338, 2339, 1, 0, 0, 0, 2339, 157,
		1, 0, 0, 0, 2340, 2341, 5, 14, 0, 0, 2341, 2342, 5, 401, 0, 0, 2342, 2343,
		5, 358, 0, 0, 2343, 2344, 5, 408, 0, 0, 2344, 2345, 5, 172, 0, 0, 2345,
		2347, 3, 1012, 506, 0, 2346, 2348, 3, 826, 413, 0, 2347, 2346, 1, 0, 0,
		0, 2347, 2348, 1, 0, 0, 0, 2348, 2351, 1, 0, 0, 0, 2349, 2350, 5, 478,
		0, 0, 2350, 2352, 3, 852, 426, 0, 2351, 2349, 1, 0, 0, 0, 2351, 2352, 1,
		0, 0, 0, 2352, 159, 1, 0, 0, 0, 2353, 2354, 5, 14, 0, 0, 2354, 2355, 5,
		354, 0, 0, 2355, 2356, 5, 422, 0, 0, 2356, 2358, 3, 1012, 506, 0, 2357,
		2359, 3, 826, 413, 0, 2358, 2357, 1, 0, 0, 0, 2358, 2359, 1, 0, 0, 0, 2359,
		161, 1, 0, 0, 0, 2360, 2361, 5, 14, 0, 0, 2361, 2362, 5, 57, 0, 0, 2362,
		2363, 5, 354, 0, 0, 2363, 2364, 5, 422, 0, 0, 2364, 2366, 3, 1012, 506,
		0, 2365, 2367, 3, 826, 413, 0, 2366, 2365, 1, 0, 0, 0, 2366, 2367, 1, 0,
		0, 0, 2367, 163, 1, 0, 0, 0, 2368, 2369, 5, 14, 0, 0, 2369, 2370, 5, 67,
		0, 0, 2370, 2371, 3, 830, 415, 0, 2371, 2372, 5, 332, 0, 0, 2372, 2373,
		5, 2, 0, 0, 2373, 2374, 3, 962, 481, 0, 2374, 2375, 5, 4, 0, 0, 2375, 165,
		1, 0, 0, 0, 2376, 2377, 5, 14, 0, 0, 2377, 2378, 5, 396, 0, 0, 2378, 2379,
		5, 422, 0, 0, 2379, 2380, 3, 1012, 506, 0, 2380, 2381, 5, 303, 0, 0, 2381,
		2384, 5, 2, 0, 0, 2382, 2385, 3, 1026, 513, 0, 2383, 2385, 5, 518, 0, 0,
		2384, 2382, 1, 0, 0, 0, 2384, 2383, 1, 0, 0, 0, 2385, 2386, 1, 0, 0, 0,
		2386, 2387, 5, 4, 0, 0, 2387, 2388, 5, 468, 0, 0, 2388, 2389, 5, 440, 0,
		0, 2389, 2390, 5, 518, 0, 0, 2390, 167, 1, 0, 0, 0, 2391, 2396, 5, 229,
		0, 0, 2392, 2394, 5, 85, 0, 0, 2393, 2392, 1, 0, 0, 0, 2393, 2394, 1, 0,
		0, 0, 2394, 2397, 1, 0, 0, 0, 2395, 2397, 5, 338, 0, 0, 2396, 2393, 1,
		0, 0, 0, 2396, 2395, 1, 0, 0, 0, 2397, 2400, 1, 0, 0, 0, 2398, 2401, 5,
		518, 0, 0, 2399, 2401, 3, 976, 488, 0, 2400, 2398, 1, 0, 0, 0, 2400, 2399,
		1, 0, 0, 0, 2401, 169, 1, 0, 0, 0, 2402, 2403, 5, 417, 0, 0, 2403, 171,
		1, 0, 0, 0, 2404, 2405, 5, 14, 0, 0, 2405, 2406, 5, 396, 0, 0, 2406, 2407,
		5, 32, 0, 0, 2407, 2408, 5, 70, 0, 0, 2408, 2409, 5, 403, 0, 0, 2409, 2413,
		5, 290, 0, 0, 2410, 2411, 5, 410, 0, 0, 2411, 2412, 5, 471, 0, 0, 2412,
		2414, 3, 1018, 509, 0, 2413, 2410, 1, 0, 0, 0, 2413, 2414, 1, 0, 0, 0,
		2414, 173, 1, 0, 0, 0, 2415, 2416, 5, 14, 0, 0, 2416, 2417, 5, 396, 0,
		0, 2417, 2418, 5, 32, 0, 0, 2418, 2419, 5, 70, 0, 0, 2419, 2420, 5, 403,
		0, 0, 2420, 2421, 5, 288, 0, 0, 2421, 175, 1, 0, 0, 0, 2422, 2423, 5, 19,
		0, 0, 2423, 2424, 5, 418, 0, 0, 2424, 2425, 3, 232, 116, 0, 2425, 177,
		1, 0, 0, 0, 2426, 2427, 5, 57, 0, 0, 2427, 2428, 5, 116, 0, 0, 2428, 2429,
		5, 35, 0, 0, 2429, 2434, 3, 976, 488, 0, 2430, 2431, 5, 3, 0, 0, 2431,
		2433, 3, 976, 488, 0, 2432, 2430, 1, 0, 0, 0, 2433, 2436, 1, 0, 0, 0, 2434,
		2432, 1, 0, 0, 0, 2434, 2435, 1, 0, 0, 0, 2435, 179, 1, 0, 0, 0, 2436,
		2434, 1, 0, 0, 0, 2437, 2438, 5, 401, 0, 0, 2438, 2439, 5, 83, 0, 0, 2439,
		2440, 5, 279, 0, 0, 2440, 181, 1, 0, 0, 0, 2441, 2442, 5, 90, 0, 0, 2442,
		2443, 5, 151, 0, 0, 2443, 2447, 5, 60, 0, 0, 2444, 2445, 5, 197, 0, 0,
		2445, 2446, 5, 281, 0, 0, 2446, 2448, 5, 148, 0, 0, 2447, 2444, 1, 0, 0,
		0, 2447, 2448, 1, 0, 0, 0, 2448, 2449, 1, 0, 0, 0, 2449, 2451, 3, 1026,
		513, 0, 2450, 2452, 3, 970, 485, 0, 2451, 2450, 1, 0, 0, 0, 2451, 2452,
		1, 0, 0, 0, 2452, 2453, 1, 0, 0, 0, 2453, 2454, 3, 954, 477, 0, 2454, 183,
		1, 0, 0, 0, 2455, 2456, 5, 401, 0, 0, 2456, 2457, 5, 90, 0, 0, 2457, 2458,
		5, 60, 0, 0, 2458, 2459, 3, 1026, 513, 0, 2459, 185, 1, 0, 0, 0, 2460,
		2461, 5, 132, 0, 0, 2461, 2464, 5, 60, 0, 0, 2462, 2463, 5, 197, 0, 0,
		2463, 2465, 5, 148, 0, 0, 2464, 2462, 1, 0, 0, 0, 2464, 2465, 1, 0, 0,
		0, 2465, 2466, 1, 0, 0, 0, 2466, 2467, 3, 1026, 513, 0, 2467, 187, 1, 0,
		0, 0, 2468, 2469, 5, 401, 0, 0, 2469, 2472, 5, 61, 0, 0, 2470, 2471, 5,
		240, 0, 0, 2471, 2473, 3, 976, 488, 0, 2472, 2470, 1, 0, 0, 0, 2472, 2473,
		1, 0, 0, 0, 2473, 189, 1, 0, 0, 0, 2474, 2475, 5, 19, 0, 0, 2475, 2476,
		5, 60, 0, 0, 2476, 2477, 3, 1026, 513, 0, 2477, 2478, 3, 276, 138, 0, 2478,
		191, 1, 0, 0, 0, 2479, 2480, 5, 90, 0, 0, 2480, 2481, 5, 410, 0, 0, 2481,
		2485, 5, 471, 0, 0, 2482, 2483, 5, 197, 0, 0, 2483, 2484, 5, 281, 0, 0,
		2484, 2486, 5, 148, 0, 0, 2485, 2482, 1, 0, 0, 0, 2485, 2486, 1, 0, 0,
		0, 2486, 2487, 1, 0, 0, 0, 2487, 2488, 3, 1026, 513, 0, 2488, 2489, 3,
		194, 97, 0, 2489, 2491, 3, 196, 98, 0, 2490, 2492, 3, 970, 485, 0, 2491,
		2490, 1, 0, 0, 0, 2491, 2492, 1, 0, 0, 0, 2492, 2494, 1, 0, 0, 0, 2493,
		2495, 3, 954, 477, 0, 2494, 2493, 1, 0, 0, 0, 2494, 2495, 1, 0, 0, 0, 2495,
		193, 1, 0, 0, 0, 2496, 2497, 5, 446, 0, 0, 2497, 2498, 5, 492, 0, 0, 2498,
		2499, 3, 1018, 509, 0, 2499, 195, 1, 0, 0, 0, 2500, 2501, 5, 248, 0, 0,
		2501, 2502, 5, 492, 0, 0, 2502, 2503, 3, 926, 463, 0, 2503, 197, 1, 0,
		0, 0, 2504, 2505, 5, 401, 0, 0, 2505, 2506, 5, 410, 0, 0, 2506, 2509, 5,
		472, 0, 0, 2507, 2508, 5, 240, 0, 0, 2508, 2510, 3, 976, 488, 0, 2509,
		2507, 1, 0, 0, 0, 2509, 2510, 1, 0, 0, 0, 2510, 199, 1, 0, 0, 0, 2511,
		2512, 5, 132, 0, 0, 2512, 2513, 5, 410, 0, 0, 2513, 2516, 5, 471, 0, 0,
		2514, 2515, 5, 197, 0, 0, 2515, 2517, 5, 148, 0, 0, 2516, 2514, 1, 0, 0,
		0, 2516, 2517, 1, 0, 0, 0, 2517, 2518, 1, 0, 0, 0, 2518, 2519, 3, 1026,
		513, 0, 2519, 201, 1, 0, 0, 0, 2520, 2521, 5, 19, 0, 0, 2521, 2522, 5,
		410, 0, 0, 2522, 2523, 5, 471, 0, 0, 2523, 2524, 3, 1026, 513, 0, 2524,
		2529, 3, 204, 102, 0, 2525, 2526, 5, 3, 0, 0, 2526, 2528, 3, 204, 102,
		0, 2527, 2525, 1, 0, 0, 0, 2528, 2531, 1, 0, 0, 0, 2529, 2527, 1, 0, 0,
		0, 2529, 2530, 1, 0, 0, 0, 2530, 203, 1, 0, 0, 0, 2531, 2529, 1, 0, 0,
		0, 2532, 2535, 3, 208, 104, 0, 2533, 2535, 3, 206, 103, 0, 2534, 2532,
		1, 0, 0, 0, 2534, 2533, 1, 0, 0, 0, 2535, 205, 1, 0, 0, 0, 2536, 2537,
		5, 396, 0, 0, 2537, 2538, 3, 958, 479, 0, 2538, 207, 1, 0, 0, 0, 2539,
		2540, 5, 78, 0, 0, 2540, 2541, 5, 492, 0, 0, 2541, 2542, 3, 976, 488, 0,
		2542, 209, 1, 0, 0, 0, 2543, 2544, 7, 8, 0, 0, 2544, 2545, 5, 410, 0, 0,
		2545, 2546, 5, 471, 0, 0, 2546, 2547, 3, 1026, 513, 0, 2547, 211, 1, 0,
		0, 0, 2548, 2549, 5, 396, 0, 0, 2549, 2550, 3, 1026, 513, 0, 2550, 2551,
		5, 27, 0, 0, 2551, 2552, 5, 117, 0, 0, 2552, 2553, 5, 410, 0, 0, 2553,
		2554, 5, 471, 0, 0, 2554, 213, 1, 0, 0, 0, 2555, 2556, 5, 14, 0, 0, 2556,
		2557, 7, 13, 0, 0, 2557, 2558, 5, 154, 0, 0, 2558, 2566, 3, 976, 488, 0,
		2559, 2564, 5, 480, 0, 0, 2560, 2561, 5, 518, 0, 0, 2561, 2565, 5, 433,
		0, 0, 2562, 2563, 5, 519, 0, 0, 2563, 2565, 5, 326, 0, 0, 2564, 2560, 1,
		0, 0, 0, 2564, 2562, 1, 0, 0, 0, 2565, 2567, 1, 0, 0, 0, 2566, 2559, 1,
		0, 0, 0, 2566, 2567, 1, 0, 0, 0, 2567, 2574, 1, 0, 0, 0, 2568, 2572, 5,
		290, 0, 0, 2569, 2570, 5, 35, 0, 0, 2570, 2573, 3, 976, 488, 0, 2571, 2573,
		5, 173, 0, 0, 2572, 2569, 1, 0, 0, 0, 2572, 2571, 1, 0, 0, 0, 2573, 2575,
		1, 0, 0, 0, 2574, 2568, 1, 0, 0, 0, 2574, 2575, 1, 0, 0, 0, 2575, 215,
		1, 0, 0, 0, 2576, 2577, 5, 401, 0, 0, 2577, 2580, 5, 155, 0, 0, 2578, 2579,
		5, 240, 0, 0, 2579, 2581, 3, 976, 488, 0, 2580, 2578, 1, 0, 0, 0, 2580,
		2581, 1, 0, 0, 0, 2581, 2585, 1, 0, 0, 0, 2582, 2583, 5, 290, 0, 0, 2583,
		2584, 5, 35, 0, 0, 2584, 2586, 3, 976, 488, 0, 2585, 2582, 1, 0, 0, 0,
		2585, 2586, 1, 0, 0, 0, 2586, 217, 1, 0, 0, 0, 2587, 2588, 5, 90, 0, 0,
		2588, 2589, 5, 122, 0, 0, 2589, 2590, 3, 230, 115, 0, 2590, 2591, 5, 460,
		0, 0, 2591, 2592, 3, 1012, 506, 0, 2592, 2593, 5, 2, 0, 0, 2593, 2598,
		3, 228, 114, 0, 2594, 2595, 5, 3, 0, 0, 2595, 2597, 3, 228, 114, 0, 2596,
		2594, 1, 0, 0, 0, 2597, 2600, 1, 0, 0, 0, 2598, 2596, 1, 0, 0, 0, 2598,
		2599, 1, 0, 0, 0, 2599, 2601, 1, 0, 0, 0, 2600, 2598, 1, 0, 0, 0, 2601,
		2603, 5, 4, 0, 0, 2602, 2604, 3, 954, 477, 0, 2603, 2602, 1, 0, 0, 0, 2603,
		2604, 1, 0, 0, 0, 2604, 219, 1, 0, 0, 0, 2605, 2606, 5, 132, 0, 0, 2606,
		2607, 5, 122, 0, 0, 2607, 2609, 3, 1012, 506, 0, 2608, 2610, 5, 56, 0,
		0, 2609, 2608, 1, 0, 0, 0, 2609, 2610, 1, 0, 0, 0, 2610, 221, 1, 0, 0,
		0, 2611, 2612, 5, 348, 0, 0, 2612, 2613, 5, 122, 0, 0, 2613, 2614, 3, 1012,
		506, 0, 2614, 223, 1, 0, 0, 0, 2615, 2616, 5, 401, 0, 0, 2616, 2618, 5,
		122, 0, 0, 2617, 2619, 3, 1012, 506, 0, 2618, 2617, 1, 0, 0, 0, 2618, 2619,
		1, 0, 0, 0, 2619, 225, 1, 0, 0, 0, 2620, 2621, 5, 57, 0, 0, 2621, 2622,
		5, 348, 0, 0, 2622, 2623, 5, 122, 0, 0, 2623, 2624, 3, 1012, 506, 0, 2624,
		227, 1, 0, 0, 0, 2625, 2626, 3, 1012, 506, 0, 2626, 2627, 5, 227, 0, 0,
		2627, 2632, 1, 0, 0, 0, 2628, 2629, 3, 1012, 506, 0, 2629, 2630, 5, 461,
		0, 0, 2630, 2632, 1, 0, 0, 0, 2631, 2625, 1, 0, 0, 0, 2631, 2628, 1, 0,
		0, 0, 2632, 229, 1, 0, 0, 0, 2633, 2634, 3, 1012, 506, 0, 2634, 231, 1,
		0, 0, 0, 2635, 2684, 3, 234, 117, 0, 2636, 2684, 3, 236, 118, 0, 2637,
		2684, 3, 238, 119, 0, 2638, 2684, 3, 240, 120, 0, 2639, 2684, 3, 242, 121,
		0, 2640, 2684, 3, 244, 122, 0, 2641, 2684, 3, 246, 123, 0, 2642, 2684,
		3, 248, 124, 0, 2643, 2684, 3, 250, 125, 0, 2644, 2684, 3, 252, 126, 0,
		2645, 2684, 3, 254, 127, 0, 2646, 2684, 3, 256, 128, 0, 2647, 2684, 3,
		258, 129, 0, 2648, 2684, 3, 260, 130, 0, 2649, 2684, 3, 262, 131, 0, 2650,
		2684, 3, 264, 132, 0, 2651, 2684, 3, 266, 133, 0, 2652, 2684, 3, 268, 134,
		0, 2653, 2684, 3, 270, 135, 0, 2654, 2684, 3, 272, 136, 0, 2655, 2684,
		3, 274, 137, 0, 2656, 2684, 3, 276, 138, 0, 2657, 2684, 3, 284, 142, 0,
		2658, 2684, 3, 286, 143, 0, 2659, 2684, 3, 288, 144, 0, 2660, 2684, 3,
		292, 146, 0, 2661, 2684, 3, 290, 145, 0, 2662, 2684, 3, 294, 147, 0, 2663,
		2684, 3, 296, 148, 0, 2664, 2684, 3, 298, 149, 0, 2665, 2684, 3, 300, 150,
		0, 2666, 2684, 3, 278, 139, 0, 2667, 2684, 3, 282, 141, 0, 2668, 2684,
		3, 306, 153, 0, 2669, 2684, 3, 308, 154, 0, 2670, 2684, 3, 312, 156, 0,
		2671, 2684, 3, 310, 155, 0, 2672, 2684, 3, 314, 157, 0, 2673, 2684, 3,
		316, 158, 0, 2674, 2684, 3, 318, 159, 0, 2675, 2684, 3, 338, 169, 0, 2676,
		2684, 3, 340, 170, 0, 2677, 2684, 3, 342, 171, 0, 2678, 2684, 3, 946, 473,
		0, 2679, 2684, 3, 344, 172, 0, 2680, 2684, 3, 346, 173, 0, 2681, 2684,
		3, 348, 174, 0, 2682, 2684, 3, 350, 175, 0, 2683, 2635, 1, 0, 0, 0, 2683,
		2636, 1, 0, 0, 0, 2683, 2637, 1, 0, 0, 0, 2683, 2638, 1, 0, 0, 0, 2683,
		2639, 1, 0, 0, 0, 2683, 2640, 1, 0, 0, 0, 2683, 2641, 1, 0, 0, 0, 2683,
		2642, 1, 0, 0, 0, 2683, 2643, 1, 0, 0, 0, 2683, 2644, 1, 0, 0, 0, 2683,
		2645, 1, 0, 0, 0, 2683, 2646, 1, 0, 0, 0, 2683, 2647, 1, 0, 0, 0, 2683,
		2648, 1, 0, 0, 0, 2683, 2649, 1, 0, 0, 0, 2683, 2650, 1, 0, 0, 0, 2683,
		2651, 1, 0, 0, 0, 2683, 2652, 1, 0, 0, 0, 2683, 2653, 1, 0, 0, 0, 2683,
		2654, 1, 0, 0, 0, 2683, 2655, 1, 0, 0, 0, 2683, 2656, 1, 0, 0, 0, 2683,
		2657, 1, 0, 0, 0, 2683, 2658, 1, 0, 0, 0, 2683, 2659, 1, 0, 0, 0, 2683,
		2660, 1, 0, 0, 0, 2683, 2661, 1, 0, 0, 0, 2683, 2662, 1, 0, 0, 0, 2683,
		2663, 1, 0, 0, 0, 2683, 2664, 1, 0, 0, 0, 2683, 2665, 1, 0, 0, 0, 2683,
		2666, 1, 0, 0, 0, 2683, 2667, 1, 0, 0, 0, 2683, 2668, 1, 0, 0, 0, 2683,
		2669, 1, 0, 0, 0, 2683, 2670, 1, 0, 0, 0, 2683, 2671, 1, 0, 0, 0, 2683,
		2672, 1, 0, 0, 0, 2683, 2673, 1, 0, 0, 0, 2683, 2674, 1, 0, 0, 0, 2683,
		2675, 1, 0, 0, 0, 2683, 2676, 1, 0, 0, 0, 2683, 2677, 1, 0, 0, 0, 2683,
		2678, 1, 0, 0, 0, 2683, 2679, 1, 0, 0, 0, 2683, 2680, 1, 0, 0, 0, 2683,
		2681, 1, 0, 0, 0, 2683, 2682, 1, 0, 0, 0, 2684, 233, 1, 0, 0, 0, 2685,
		2686, 5, 13, 0, 0, 2686, 2687, 7, 14, 0, 0, 2687, 2688, 3, 976, 488, 0,
		2688, 235, 1, 0, 0, 0, 2689, 2690, 5, 132, 0, 0, 2690, 2691, 7, 14, 0,
		0, 2691, 2692, 3, 976, 488, 0, 2692, 237, 1, 0, 0, 0, 2693, 2694, 5, 270,
		0, 0, 2694, 2695, 5, 173, 0, 0, 2695, 2696, 5, 192, 0, 0, 2696, 2697, 3,
		976, 488, 0, 2697, 2698, 5, 440, 0, 0, 2698, 2699, 3, 976, 488, 0, 2699,
		239, 1, 0, 0, 0, 2700, 2701, 5, 13, 0, 0, 2701, 2702, 5, 35, 0, 0, 2702,
		2707, 3, 976, 488, 0, 2703, 2704, 5, 3, 0, 0, 2704, 2706, 3, 976, 488,
		0, 2705, 2703, 1, 0, 0, 0, 2706, 2709, 1, 0, 0, 0, 2707, 2705, 1, 0, 0,
		0, 2707, 2708, 1, 0, 0, 0, 2708, 2717, 1, 0, 0, 0, 2709, 2707, 1, 0, 0,
		0, 2710, 2711, 5, 218, 0, 0, 2711, 2712, 5, 473, 0, 0, 2712, 2715, 3, 1026,
		513, 0, 2713, 2714, 5, 72, 0, 0, 2714, 2716, 3, 1026, 513, 0, 2715, 2713,
		1, 0, 0, 0, 2715, 2716, 1, 0, 0, 0, 2716, 2718, 1, 0, 0, 0, 2717, 2710,
		1, 0, 0, 0, 2717, 2718, 1, 0, 0, 0, 2718, 241, 1, 0, 0, 0, 2719, 2720,
		5, 132, 0, 0, 2720, 2721, 5, 35, 0, 0, 2721, 2726, 3, 976, 488, 0, 2722,
		2723, 5, 3, 0, 0, 2723, 2725, 3, 976, 488, 0, 2724, 2722, 1, 0, 0, 0, 2725,
		2728, 1, 0, 0, 0, 2726, 2724, 1, 0, 0, 0, 2726, 2727, 1, 0, 0, 0, 2727,
		2736, 1, 0, 0, 0, 2728, 2726, 1, 0, 0, 0, 2729, 2730, 5, 172, 0, 0, 2730,
		2731, 5, 473, 0, 0, 2731, 2734, 3, 1026, 513, 0, 2732, 2733, 5, 72, 0,
		0, 2733, 2735, 3, 1026, 513, 0, 2734, 2732, 1, 0, 0, 0, 2734, 2735, 1,
		0, 0, 0, 2735, 2737, 1, 0, 0, 0, 2736, 2729, 1, 0, 0, 0, 2736, 2737, 1,
		0, 0, 0, 2737, 2739, 1, 0, 0, 0, 2738, 2740, 5, 169, 0, 0, 2739, 2738,
		1, 0, 0, 0, 2739, 2740, 1, 0, 0, 0, 2740, 243, 1, 0, 0, 0, 2741, 2742,
		5, 116, 0, 0, 2742, 2743, 5, 35, 0, 0, 2743, 2748, 3, 976, 488, 0, 2744,
		2745, 5, 3, 0, 0, 2745, 2747, 3, 976, 488, 0, 2746, 2744, 1, 0, 0, 0, 2747,
		2750, 1, 0, 0, 0, 2748, 2746, 1, 0, 0, 0, 2748, 2749, 1, 0, 0, 0, 2749,
		245, 1, 0, 0, 0, 2750, 2748, 1, 0, 0, 0, 2751, 2752, 5, 270, 0, 0, 2752,
		2753, 5, 35, 0, 0, 2753, 2754, 5, 192, 0, 0, 2754, 2755, 3, 976, 488, 0,
		2755, 2756, 5, 440, 0, 0, 2756, 2757, 3, 976, 488, 0, 2757, 2765, 1, 0,
		0, 0, 2758, 2759, 5, 270, 0, 0, 2759, 2760, 5, 35, 0, 0, 2760, 2761, 3,
		976, 488, 0, 2761, 2762, 5, 396, 0, 0, 2762, 2763, 3, 958, 479, 0, 2763,
		2765, 1, 0, 0, 0, 2764, 2751, 1, 0, 0, 0, 2764, 2758, 1, 0, 0, 0, 2765,
		247, 1, 0, 0, 0, 2766, 2767, 5, 13, 0, 0, 2767, 2768, 5, 83, 0, 0, 2768,
		2769, 5, 278, 0, 0, 2769, 2774, 3, 976, 488, 0, 2770, 2771, 5, 3, 0, 0,
		2771, 2773, 3, 976, 488, 0, 2772, 2770, 1, 0, 0, 0, 2773, 2776, 1, 0, 0,
		0, 2774, 2772, 1, 0, 0, 0, 2774, 2775, 1, 0, 0, 0, 2775, 2784, 1, 0, 0,
		0, 2776, 2774, 1, 0, 0, 0, 2777, 2778, 5, 218, 0, 0, 2778, 2779, 5, 473,
		0, 0, 2779, 2782, 3, 1026, 513, 0, 2780, 2781, 5, 72, 0, 0, 2781, 2783,
		3, 1026, 513, 0, 2782, 2780, 1, 0, 0, 0, 2782, 2783, 1, 0, 0, 0, 2783,
		2785, 1, 0, 0, 0, 2784, 2777, 1, 0, 0, 0, 2784, 2785, 1, 0, 0, 0, 2785,
		249, 1, 0, 0, 0, 2786, 2787, 5, 132, 0, 0, 2787, 2788, 5, 83, 0, 0, 2788,
		2789, 5, 278, 0, 0, 2789, 2794, 3, 976, 488, 0, 2790, 2791, 5, 3, 0, 0,
		2791, 2793, 3, 976, 488, 0, 2792, 2790, 1, 0, 0, 0, 2793, 2796, 1, 0, 0,
		0, 2794, 2792, 1, 0, 0, 0, 2794, 2795, 1, 0, 0, 0, 2795, 2804, 1, 0, 0,
		0, 2796, 2794, 1, 0, 0, 0, 2797, 2798, 5, 172, 0, 0, 2798, 2799, 5, 473,
		0, 0, 2799, 2802, 3, 1026, 513, 0, 2800, 2801, 5, 72, 0, 0, 2801, 2803,
		3, 1026, 513, 0, 2802, 2800, 1, 0, 0, 0, 2802, 2803, 1, 0, 0, 0, 2803,
		2805, 1, 0, 0, 0, 2804, 2797, 1, 0, 0, 0, 2804, 2805, 1, 0, 0, 0, 2805,
		251, 1, 0, 0, 0, 2806, 2807, 5, 13, 0, 0, 2807, 2808, 5, 52, 0, 0, 2808,
		2809, 3, 1026, 513, 0, 2809, 2814, 3, 976, 488, 0, 2810, 2811, 5, 3, 0,
		0, 2811, 2813, 3, 976, 488, 0, 2812, 2810, 1, 0, 0, 0, 2813, 2816, 1, 0,
		0, 0, 2814, 2812, 1, 0, 0, 0, 2814, 2815, 1, 0, 0, 0, 2815, 2833, 1, 0,
		0, 0, 2816, 2814, 1, 0, 0, 0, 2817, 2818, 5, 132, 0, 0, 2818, 2819, 5,
		52, 0, 0, 2819, 2820, 3, 1026, 513, 0, 2820, 2825, 3, 976, 488, 0, 2821,
		2822, 5, 3, 0, 0, 2822, 2824, 3, 976, 488, 0, 2823, 2821, 1, 0, 0, 0, 2824,
		2827, 1, 0, 0, 0, 2825, 2823, 1, 0, 0, 0, 2825, 2826, 1, 0, 0, 0, 2826,
		2833, 1, 0, 0, 0, 2827, 2825, 1, 0, 0, 0, 2828, 2829, 5, 132, 0, 0, 2829,
		2830, 5, 18, 0, 0, 2830, 2831, 5, 52, 0, 0, 2831, 2833, 3, 1026, 513, 0,
		2832, 2806, 1, 0, 0, 0, 2832, 2817, 1, 0, 0, 0, 2832, 2828, 1, 0, 0, 0,
		2833, 253, 1, 0, 0, 0, 2834, 2835, 5, 396, 0, 0, 2835, 2836, 5, 243, 0,
		0, 2836, 2837, 5, 142, 0, 0, 2837, 2839, 5, 195, 0, 0, 2838, 2840, 3, 954,
		477, 0, 2839, 2838, 1, 0, 0, 0, 2839, 2840, 1, 0, 0, 0, 2840, 255, 1, 0,
		0, 0, 2841, 2842, 5, 90, 0, 0, 2842, 2843, 5, 201, 0, 0, 2843, 257, 1,
		0, 0, 0, 2844, 2845, 5, 68, 0, 0, 2845, 2846, 5, 424, 0, 0, 2846, 2847,
		5, 386, 0, 0, 2847, 2848, 5, 340, 0, 0, 2848, 259, 1, 0, 0, 0, 2849, 2850,
		5, 116, 0, 0, 2850, 2851, 5, 487, 0, 0, 2851, 2856, 3, 976, 488, 0, 2852,
		2853, 5, 3, 0, 0, 2853, 2855, 3, 976, 488, 0, 2854, 2852, 1, 0, 0, 0, 2855,
		2858, 1, 0, 0, 0, 2856, 2854, 1, 0, 0, 0, 2856, 2857, 1, 0, 0, 0, 2857,
		2859, 1, 0, 0, 0, 2858, 2856, 1, 0, 0, 0, 2859, 2860, 5, 290, 0, 0, 2860,
		2861, 5, 35, 0, 0, 2861, 2862, 3, 976, 488, 0, 2862, 261, 1, 0, 0, 0, 2863,
		2864, 5, 57, 0, 0, 2864, 2865, 5, 116, 0, 0, 2865, 2866, 5, 487, 0, 0,
		2866, 2871, 3, 976, 488, 0, 2867, 2868, 5, 3, 0, 0, 2868, 2870, 3, 976,
		488, 0, 2869, 2867, 1, 0, 0, 0, 2870, 2873, 1, 0, 0, 0, 2871, 2869, 1,
		0, 0, 0, 2871, 2872, 1, 0, 0, 0, 2872, 2874, 1, 0, 0, 0, 2873, 2871, 1,
		0, 0, 0, 2874, 2875, 5, 290, 0, 0, 2875, 2876, 5, 35, 0, 0, 2876, 2877,
		3, 976, 488, 0, 2877, 263, 1, 0, 0, 0, 2878, 2879, 5, 127, 0, 0, 2879,
		2880, 5, 487, 0, 0, 2880, 2885, 3, 976, 488, 0, 2881, 2882, 5, 3, 0, 0,
		2882, 2884, 3, 976, 488, 0, 2883, 2881, 1, 0, 0, 0, 2884, 2887, 1, 0, 0,
		0, 2885, 2883, 1, 0, 0, 0, 2885, 2886, 1, 0, 0, 0, 2886, 2888, 1, 0, 0,
		0, 2887, 2885, 1, 0, 0, 0, 2888, 2889, 5, 290, 0, 0, 2889, 2890, 5, 35,
		0, 0, 2890, 2891, 3, 976, 488, 0, 2891, 265, 1, 0, 0, 0, 2892, 2893, 5,
		57, 0, 0, 2893, 2894, 5, 127, 0, 0, 2894, 2895, 5, 487, 0, 0, 2895, 2900,
		3, 976, 488, 0, 2896, 2897, 5, 3, 0, 0, 2897, 2899, 3, 976, 488, 0, 2898,
		2896, 1, 0, 0, 0, 2899, 2902, 1, 0, 0, 0, 2900, 2898, 1, 0, 0, 0, 2900,
		2901, 1, 0, 0, 0, 2901, 2903, 1, 0, 0, 0, 2902, 2900, 1, 0, 0, 0, 2903,
		2904, 5, 290, 0, 0, 2904, 2905, 5, 35, 0, 0, 2905, 2906, 3, 976, 488, 0,
		2906, 267, 1, 0, 0, 0, 2907, 2908, 5, 13, 0, 0, 2908, 2909, 5, 205, 0,
		0, 2909, 2910, 3, 1018, 509, 0, 2910, 2915, 3, 1024, 512, 0, 2911, 2913,
		3, 86, 43, 0, 2912, 2914, 3, 958, 479, 0, 2913, 2912, 1, 0, 0, 0, 2913,
		2914, 1, 0, 0, 0, 2914, 2916, 1, 0, 0, 0, 2915, 2911, 1, 0, 0, 0, 2915,
		2916, 1, 0, 0, 0, 2916, 2918, 1, 0, 0, 0, 2917, 2919, 3, 970, 485, 0, 2918,
		2917, 1, 0, 0, 0, 2918, 2919, 1, 0, 0, 0, 2919, 269, 1, 0, 0, 0, 2920,
		2921, 5, 132, 0, 0, 2921, 2922, 5, 205, 0, 0, 2922, 2923, 3, 1018, 509,
		0, 2923, 271, 1, 0, 0, 0, 2924, 2925, 5, 353, 0, 0, 2925, 2926, 3, 1018,
		509, 0, 2926, 273, 1, 0, 0, 0, 2927, 2928, 5, 420, 0, 0, 2928, 2929, 5,
		480, 0, 0, 2929, 2930, 3, 1018, 509, 0, 2930, 275, 1, 0, 0, 0, 2931, 2932,
		5, 396, 0, 0, 2932, 2933, 3, 958, 479, 0, 2933, 277, 1, 0, 0, 0, 2934,
		2935, 5, 78, 0, 0, 2935, 2936, 5, 492, 0, 0, 2936, 2937, 3, 976, 488, 0,
		2937, 279, 1, 0, 0, 0, 2938, 2939, 5, 41, 0, 0, 2939, 2940, 3, 976, 488,
		0, 2940, 2941, 5, 21, 0, 0, 2941, 2942, 3, 976, 488, 0, 2942, 281, 1, 0,
		0, 0, 2943, 2945, 3, 826, 413, 0, 2944, 2943, 1, 0, 0, 0, 2944, 2945, 1,
		0, 0, 0, 2945, 2947, 1, 0, 0, 0, 2946, 2948, 3, 50, 25, 0, 2947, 2946,
		1, 0, 0, 0, 2947, 2948, 1, 0, 0, 0, 2948, 2950, 1, 0, 0, 0, 2949, 2951,
		3, 910, 455, 0, 2950, 2949, 1, 0, 0, 0, 2950, 2951, 1, 0, 0, 0, 2951, 2953,
		1, 0, 0, 0, 2952, 2954, 3, 52, 26, 0, 2953, 2952, 1, 0, 0, 0, 2953, 2954,
		1, 0, 0, 0, 2954, 2956, 1, 0, 0, 0, 2955, 2957, 3, 948, 474, 0, 2956, 2955,
		1, 0, 0, 0, 2956, 2957, 1, 0, 0, 0, 2957, 2959, 1, 0, 0, 0, 2958, 2960,
		3, 280, 140, 0, 2959, 2958, 1, 0, 0, 0, 2959, 2960, 1, 0, 0, 0, 2960, 283,
		1, 0, 0, 0, 2961, 2962, 5, 13, 0, 0, 2962, 2963, 5, 76, 0, 0, 2963, 2967,
		3, 34, 17, 0, 2964, 2968, 5, 161, 0, 0, 2965, 2966, 5, 16, 0, 0, 2966,
		2968, 3, 1018, 509, 0, 2967, 2964, 1, 0, 0, 0, 2967, 2965, 1, 0, 0, 0,
		2967, 2968, 1, 0, 0, 0, 2968, 2971, 1, 0, 0, 0, 2969, 2970, 7, 15, 0, 0,
		2970, 2972, 3, 1018, 509, 0, 2971, 2969, 1, 0, 0, 0, 2971, 2972, 1, 0,
		0, 0, 2972, 2974, 1, 0, 0, 0, 2973, 2975, 3, 954, 477, 0, 2974, 2973, 1,
		0, 0, 0, 2974, 2975, 1, 0, 0, 0, 2975, 285, 1, 0, 0, 0, 2976, 2977, 5,
		13, 0, 0, 2977, 2978, 5, 76, 0, 0, 2978, 2979, 5, 2, 0, 0, 2979, 2984,
		3, 34, 17, 0, 2980, 2981, 5, 3, 0, 0, 2981, 2983, 3, 34, 17, 0, 2982, 2980,
		1, 0, 0, 0, 2983, 2986, 1, 0, 0, 0, 2984, 2982, 1, 0, 0, 0, 2984, 2985,
		1, 0, 0, 0, 2985, 2987, 1, 0, 0, 0, 2986, 2984, 1, 0, 0, 0, 2987, 2990,
		5, 4, 0, 0, 2988, 2989, 7, 15, 0, 0, 2989, 2991, 3, 1018, 509, 0, 2990,
		2988, 1, 0, 0, 0, 2990, 2991, 1, 0, 0, 0, 2991, 2993, 1, 0, 0, 0, 2992,
		2994, 3, 954, 477, 0, 2993, 2992, 1, 0, 0, 0, 2993, 2994, 1, 0, 0, 0, 2994,
		287, 1, 0, 0, 0, 2995, 2996, 5, 132, 0, 0, 2996, 2997, 5, 76, 0, 0, 2997,
		3000, 3, 1018, 509, 0, 2998, 2999, 5, 172, 0, 0, 2999, 3001, 3, 1018, 509,
		0, 3000, 2998, 1, 0, 0, 0, 3000, 3001, 1, 0, 0, 0, 3001, 3003, 1, 0, 0,
		0, 3002, 3004, 3, 954, 477, 0, 3003, 3002, 1, 0, 0, 0, 3003, 3004, 1, 0,
		0, 0, 3004, 289, 1, 0, 0, 0, 3005, 3006, 5, 270, 0, 0, 3006, 3007, 5, 76,
		0, 0, 3007, 3011, 3, 34, 17, 0, 3008, 3012, 5, 161, 0, 0, 3009, 3010, 5,
		16, 0, 0, 3010, 3012, 3, 1018, 509, 0, 3011, 3008, 1, 0, 0, 0, 3011, 3009,
		1, 0, 0, 0, 3011, 3012, 1, 0, 0, 0, 3012, 3015, 1, 0, 0, 0, 3013, 3014,
		5, 172, 0, 0, 3014, 3016, 3, 1018, 509, 0, 3015, 3013, 1, 0, 0, 0, 3015,
		3016, 1, 0, 0, 0, 3016, 3018, 1, 0, 0, 0, 3017, 3019, 3, 954, 477, 0, 3018,
		3017, 1, 0, 0, 0, 3018, 3019, 1, 0, 0, 0, 3019, 291, 1, 0, 0, 0, 3020,
		3021, 5, 270, 0, 0, 3021, 3022, 5, 76, 0, 0, 3022, 3023, 3, 1018, 509,
		0, 3023, 3024, 3, 970, 485, 0, 3024, 293, 1, 0, 0, 0, 3025, 3026, 5, 353,
		0, 0, 3026, 3027, 5, 76, 0, 0, 3027, 3028, 3, 1018, 509, 0, 3028, 3029,
		5, 440, 0, 0, 3029, 3030, 3, 1018, 509, 0, 3030, 295, 1, 0, 0, 0, 3031,
		3032, 5, 298, 0, 0, 3032, 3033, 5, 55, 0, 0, 3033, 3036, 3, 1024, 512,
		0, 3034, 3035, 5, 172, 0, 0, 3035, 3037, 3, 1018, 509, 0, 3036, 3034, 1,
		0, 0, 0, 3036, 3037, 1, 0, 0, 0, 3037, 3039, 1, 0, 0, 0, 3038, 3040, 3,
		954, 477, 0, 3039, 3038, 1, 0, 0, 0, 3039, 3040, 1, 0, 0, 0, 3040, 297,
		1, 0, 0, 0, 3041, 3042, 5, 353, 0, 0, 3042, 3043, 5, 376, 0, 0, 3043, 3044,
		3, 1018, 509, 0, 3044, 3045, 3, 1018, 509, 0, 3045, 299, 1, 0, 0, 0, 3046,
		3048, 7, 16, 0, 0, 3047, 3046, 1, 0, 0, 0, 3047, 3048, 1, 0, 0, 0, 3048,
		3049, 1, 0, 0, 0, 3049, 3052, 5, 81, 0, 0, 3050, 3053, 3, 1018, 509, 0,
		3051, 3053, 3, 1024, 512, 0, 3052, 3050, 1, 0, 0, 0, 3052, 3051, 1, 0,
		0, 0, 3052, 3053, 1, 0, 0, 0, 3053, 301, 1, 0, 0, 0, 3054, 3057, 3, 1018,
		509, 0, 3055, 3057, 5, 499, 0, 0, 3056, 3054, 1, 0, 0, 0, 3056, 3055, 1,
		0, 0, 0, 3057, 303, 1, 0, 0, 0, 3058, 3064, 3, 302, 151, 0, 3059, 3063,
		5, 528, 0, 0, 3060, 3061, 5, 1, 0, 0, 3061, 3063, 3, 302, 151, 0, 3062,
		3059, 1, 0, 0, 0, 3062, 3060, 1, 0, 0, 0, 3063, 3066, 1, 0, 0, 0, 3064,
		3062, 1, 0, 0, 0, 3064, 3065, 1, 0, 0, 0, 3065, 305, 1, 0, 0, 0, 3066,
		3064, 1, 0, 0, 0, 3067, 3068, 5, 270, 0, 0, 3068, 3069, 5, 76, 0, 0, 3069,
		3070, 3, 1018, 509, 0, 3070, 3071, 5, 13, 0, 0, 3071, 3072, 5, 490, 0,
		0, 3072, 3076, 3, 1000, 500, 0, 3073, 3077, 5, 161, 0, 0, 3074, 3075, 5,
		16, 0, 0, 3075, 3077, 3, 1018, 509, 0, 3076, 3073, 1, 0, 0, 0, 3076, 3074,
		1, 0, 0, 0, 3076, 3077, 1, 0, 0, 0, 3077, 3079, 1, 0, 0, 0, 3078, 3080,
		3, 954, 477, 0, 3079, 3078, 1, 0, 0, 0, 3079, 3080, 1, 0, 0, 0, 3080, 307,
		1, 0, 0, 0, 3081, 3082, 5, 270, 0, 0, 3082, 3083, 5, 76, 0, 0, 3083, 3084,
		3, 1018, 509, 0, 3084, 3085, 5, 132, 0, 0, 3085, 3086, 5, 490, 0, 0, 3086,
		3088, 3, 304, 152, 0, 3087, 3089, 3, 954, 477, 0, 3088, 3087, 1, 0, 0,
		0, 3088, 3089, 1, 0, 0, 0, 3089, 309, 1, 0, 0, 0, 3090, 3091, 5, 90, 0,
		0, 3091, 3093, 5, 297, 0, 0, 3092, 3090, 1, 0, 0, 0, 3092, 3093, 1, 0,
		0, 0, 3093, 3094, 1, 0, 0, 0, 3094, 3095, 5, 356, 0, 0, 3095, 3096, 5,
		426, 0, 0, 3096, 3097, 3, 1018, 509, 0, 3097, 3098, 3, 320, 160, 0, 3098,
		3110, 1, 0, 0, 0, 3099, 3100, 5, 90, 0, 0, 3100, 3104, 5, 426, 0, 0, 3101,
		3102, 5, 197, 0, 0, 3102, 3103, 5, 281, 0, 0, 3103, 3105, 5, 148, 0, 0,
		3104, 3101, 1, 0, 0, 0, 3104, 3105, 1, 0, 0, 0, 3105, 3106, 1, 0, 0, 0,
		3106, 3107, 3, 1018, 509, 0, 3107, 3108, 3, 320, 160, 0, 3108, 3110, 1,
		0, 0, 0, 3109, 3092, 1, 0, 0, 0, 3109, 3099, 1, 0, 0, 0, 3110, 311, 1,
		0, 0, 0, 3111, 3112, 5, 90, 0, 0, 3112, 3114, 5, 297, 0, 0, 3113, 3111,
		1, 0, 0, 0, 3113, 3114, 1, 0, 0, 0, 3114, 3115, 1, 0, 0, 0, 3115, 3116,
		5, 356, 0, 0, 3116, 3117, 5, 51, 0, 0, 3117, 3118, 3, 1018, 509, 0, 3118,
		3119, 3, 322, 161, 0, 3119, 3131, 1, 0, 0, 0, 3120, 3121, 5, 90, 0, 0,
		3121, 3125, 5, 51, 0, 0, 3122, 3123, 5, 197, 0, 0, 3123, 3124, 5, 281,
		0, 0, 3124, 3126, 5, 148, 0, 0, 3125, 3122, 1, 0, 0, 0, 3125, 3126, 1,
		0, 0, 0, 3126, 3127, 1, 0, 0, 0, 3127, 3128, 3, 1018, 509, 0, 3128, 3129,
		3, 322, 161, 0, 3129, 3131, 1, 0, 0, 0, 3130, 3113, 1, 0, 0, 0, 3130, 3120,
		1, 0, 0, 0, 3131, 313, 1, 0, 0, 0, 3132, 3133, 5, 132, 0, 0, 3133, 3136,
		5, 51, 0, 0, 3134, 3135, 5, 197, 0, 0, 3135, 3137, 5, 148, 0, 0, 3136,
		3134, 1, 0, 0, 0, 3136, 3137, 1, 0, 0, 0, 3137, 3138, 1, 0, 0, 0, 3138,
		3139, 3, 1018, 509, 0, 3139, 315, 1, 0, 0, 0, 3140, 3141, 5, 132, 0, 0,
		3141, 3144, 5, 426, 0, 0, 3142, 3143, 5, 197, 0, 0, 3143, 3145, 5, 148,
		0, 0, 3144, 3142, 1, 0, 0, 0, 3144, 3145, 1, 0, 0, 0, 3145, 3146, 1, 0,
		0, 0, 3146, 3147, 3, 1018, 509, 0, 3147, 317, 1, 0, 0, 0, 3148, 3149, 5,
		147, 0, 0, 3149, 3150, 3, 870, 435, 0, 3150, 319, 1, 0, 0, 0, 3151, 3152,
		5, 27, 0, 0, 3152, 3153, 5, 287, 0, 0, 3153, 3154, 5, 468, 0, 0, 3154,
		3156, 3, 332, 166, 0, 3155, 3151, 1, 0, 0, 0, 3155, 3156, 1, 0, 0, 0, 3156,
		3158, 1, 0, 0, 0, 3157, 3159, 3, 326, 163, 0, 3158, 3157, 1, 0, 0, 0, 3158,
		3159, 1, 0, 0, 0, 3159, 321, 1, 0, 0, 0, 3160, 3161, 5, 27, 0, 0, 3161,
		3162, 5, 287, 0, 0, 3162, 3163, 5, 468, 0, 0, 3163, 3165, 3, 332, 166,
		0, 3164, 3160, 1, 0, 0, 0, 3164, 3165, 1, 0, 0, 0, 3165, 3167, 1, 0, 0,
		0, 3166, 3168, 3, 326, 163, 0, 3167, 3166, 1, 0, 0, 0, 3167, 3168, 1, 0,
		0, 0, 3168, 3170, 1, 0, 0, 0, 3169, 3171, 3, 324, 162, 0, 3170, 3169, 1,
		0, 0, 0, 3170, 3171, 1, 0, 0, 0, 3171, 323, 1, 0, 0, 0, 3172, 3173, 5,
		480, 0, 0, 3173, 3174, 5, 403, 0, 0, 3174, 3175, 5, 366, 0, 0, 3175, 3187,
		3, 330, 165, 0, 3176, 3177, 5, 480, 0, 0, 3177, 3178, 5, 403, 0, 0, 3178,
		3179, 5, 366, 0, 0, 3179, 3187, 3, 328, 164, 0, 3180, 3181, 5, 480, 0,
		0, 3181, 3182, 5, 403, 0, 0, 3182, 3183, 5, 366, 0, 0, 3183, 3184, 3, 330,
		165, 0, 3184, 3185, 3, 328, 164, 0, 3185, 3187, 1, 0, 0, 0, 3186, 3172,
		1, 0, 0, 0, 3186, 3176, 1, 0, 0, 0, 3186, 3180, 1, 0, 0, 0, 3187, 325,
		1, 0, 0, 0, 3188, 3189, 5, 365, 0, 0, 3189, 3190, 3, 1038, 519, 0, 3190,
		3191, 3, 334, 167, 0, 3191, 327, 1, 0, 0, 0, 3192, 3193, 3, 1038, 519,
		0, 3193, 3194, 3, 334, 167, 0, 3194, 329, 1, 0, 0, 0, 3195, 3196, 3, 1038,
		519, 0, 3196, 3197, 5, 404, 0, 0, 3197, 331, 1, 0, 0, 0, 3198, 3199, 3,
		1038, 519, 0, 3199, 333, 1, 0, 0, 0, 3200, 3201, 7, 17, 0, 0, 3201, 335,
		1, 0, 0, 0, 3202, 3203, 5, 2, 0, 0, 3203, 3208, 5, 518, 0, 0, 3204, 3205,
		5, 3, 0, 0, 3205, 3207, 5, 518, 0, 0, 3206, 3204, 1, 0, 0, 0, 3207, 3210,
		1, 0, 0, 0, 3208, 3206, 1, 0, 0, 0, 3208, 3209, 1, 0, 0, 0, 3209, 3211,
		1, 0, 0, 0, 3210, 3208, 1, 0, 0, 0, 3211, 3212, 5, 4, 0, 0, 3212, 337,
		1, 0, 0, 0, 3213, 3214, 5, 132, 0, 0, 3214, 3215, 5, 491, 0, 0, 3215, 3216,
		5, 205, 0, 0, 3216, 3217, 5, 290, 0, 0, 3217, 3218, 5, 425, 0, 0, 3218,
		3219, 3, 336, 168, 0, 3219, 339, 1, 0, 0, 0, 3220, 3222, 5, 13, 0, 0, 3221,
		3223, 5, 428, 0, 0, 3222, 3221, 1, 0, 0, 0, 3222, 3223, 1, 0, 0, 0, 3223,
		3227, 1, 0, 0, 0, 3224, 3228, 3, 932, 466, 0, 3225, 3226, 5, 304, 0, 0,
		3226, 3228, 3, 934, 467, 0, 3227, 3224, 1, 0, 0, 0, 3227, 3225, 1, 0, 0,
		0, 3228, 3230, 1, 0, 0, 0, 3229, 3231, 3, 948, 474, 0, 3230, 3229, 1, 0,
		0, 0, 3230, 3231, 1, 0, 0, 0, 3231, 3233, 1, 0, 0, 0, 3232, 3234, 3, 954,
		477, 0, 3233, 3232, 1, 0, 0, 0, 3233, 3234, 1, 0, 0, 0, 3234, 3250, 1,
		0, 0, 0, 3235, 3237, 5, 13, 0, 0, 3236, 3238, 5, 428, 0, 0, 3237, 3236,
		1, 0, 0, 0, 3237, 3238, 1, 0, 0, 0, 3238, 3241, 1, 0, 0, 0, 3239, 3242,
		3, 914, 457, 0, 3240, 3242, 3, 916, 458, 0, 3241, 3239, 1, 0, 0, 0, 3241,
		3240, 1, 0, 0, 0, 3242, 3244, 1, 0, 0, 0, 3243, 3245, 3, 948, 474, 0, 3244,
		3243, 1, 0, 0, 0, 3244, 3245, 1, 0, 0, 0, 3245, 3247, 1, 0, 0, 0, 3246,
		3248, 3, 954, 477, 0, 3247, 3246, 1, 0, 0, 0, 3247, 3248, 1, 0, 0, 0, 3248,
		3250, 1, 0, 0, 0, 3249, 3220, 1, 0, 0, 0, 3249, 3235, 1, 0, 0, 0, 3250,
		341, 1, 0, 0, 0, 3251, 3253, 5, 132, 0, 0, 3252, 3254, 5, 428, 0, 0, 3253,
		3252, 1, 0, 0, 0, 3253, 3254, 1, 0, 0, 0, 3254, 3267, 1, 0, 0, 0, 3255,
		3258, 5, 303, 0, 0, 3256, 3257, 5, 197, 0, 0, 3257, 3259, 5, 148, 0, 0,
		3258, 3256, 1, 0, 0, 0, 3258, 3259, 1, 0, 0, 0, 3259, 3260, 1, 0, 0, 0,
		3260, 3268, 3, 1018, 509, 0, 3261, 3264, 5, 304, 0, 0, 3262, 3263, 5, 197,
		0, 0, 3263, 3265, 5, 148, 0, 0, 3264, 3262, 1, 0, 0, 0, 3264, 3265, 1,
		0, 0, 0, 3265, 3266, 1, 0, 0, 0, 3266, 3268, 3, 1024, 512, 0, 3267, 3255,
		1, 0, 0, 0, 3267, 3261, 1, 0, 0, 0, 3268, 3270, 1, 0, 0, 0, 3269, 3271,
		5, 169, 0, 0, 3270, 3269, 1, 0, 0, 0, 3270, 3271, 1, 0, 0, 0, 3271, 3307,
		1, 0, 0, 0, 3272, 3274, 5, 132, 0, 0, 3273, 3275, 5, 428, 0, 0, 3274, 3273,
		1, 0, 0, 0, 3274, 3275, 1, 0, 0, 0, 3275, 3276, 1, 0, 0, 0, 3276, 3279,
		5, 304, 0, 0, 3277, 3278, 5, 197, 0, 0, 3278, 3280, 5, 148, 0, 0, 3279,
		3277, 1, 0, 0, 0, 3279, 3280, 1, 0, 0, 0, 3280, 3281, 1, 0, 0, 0, 3281,
		3283, 3, 934, 467, 0, 3282, 3284, 5, 169, 0, 0, 3283, 3282, 1, 0, 0, 0,
		3283, 3284, 1, 0, 0, 0, 3284, 3307, 1, 0, 0, 0, 3285, 3287, 5, 132, 0,
		0, 3286, 3288, 5, 428, 0, 0, 3287, 3286, 1, 0, 0, 0, 3287, 3288, 1, 0,
		0, 0, 3288, 3289, 1, 0, 0, 0, 3289, 3292, 5, 304, 0, 0, 3290, 3291, 5,
		197, 0, 0, 3291, 3293, 5, 148, 0, 0, 3292, 3290, 1, 0, 0, 0, 3292, 3293,
		1, 0, 0, 0, 3293, 3294, 1, 0, 0, 0, 3294, 3295, 5, 478, 0, 0, 3295, 3297,
		3, 852, 426, 0, 3296, 3298, 5, 169, 0, 0, 3297, 3296, 1, 0, 0, 0, 3297,
		3298, 1, 0, 0, 0, 3298, 3307, 1, 0, 0, 0, 3299, 3300, 5, 132, 0, 0, 3300,
		3301, 5, 18, 0, 0, 3301, 3302, 5, 428, 0, 0, 3302, 3304, 5, 304, 0, 0,
		3303, 3305, 5, 169, 0, 0, 3304, 3303, 1, 0, 0, 0, 3304, 3305, 1, 0, 0,
		0, 3305, 3307, 1, 0, 0, 0, 3306, 3251, 1, 0, 0, 0, 3306, 3272, 1, 0, 0,
		0, 3306, 3285, 1, 0, 0, 0, 3306, 3299, 1, 0, 0, 0, 3307, 343, 1, 0, 0,
		0, 3308, 3309, 5, 445, 0, 0, 3309, 3310, 3, 826, 413, 0, 3310, 345, 1,
		0, 0, 0, 3311, 3312, 5, 270, 0, 0, 3312, 3318, 5, 303, 0, 0, 3313, 3319,
		3, 1018, 509, 0, 3314, 3319, 3, 1024, 512, 0, 3315, 3316, 5, 2, 0, 0, 3316,
		3317, 5, 502, 0, 0, 3317, 3319, 5, 4, 0, 0, 3318, 3313, 1, 0, 0, 0, 3318,
		3314, 1, 0, 0, 0, 3318, 3315, 1, 0, 0, 0, 3319, 3320, 1, 0, 0, 0, 3320,
		3321, 5, 396, 0, 0, 3321, 3326, 3, 958, 479, 0, 3322, 3323, 5, 270, 0,
		0, 3323, 3324, 5, 303, 0, 0, 3324, 3326, 3, 948, 474, 0, 3325, 3311, 1,
		0, 0, 0, 3325, 3322, 1, 0, 0, 0, 3326, 347, 1, 0, 0, 0, 3327, 3328, 5,
		356, 0, 0, 3328, 3329, 3, 826, 413, 0, 3329, 3330, 5, 480, 0, 0, 3330,
		3332, 3, 826, 413, 0, 3331, 3333, 3, 954, 477, 0, 3332, 3331, 1, 0, 0,
		0, 3332, 3333, 1, 0, 0, 0, 3333, 349, 1, 0, 0, 0, 3334, 3335, 5, 353, 0,
		0, 3335, 3336, 5, 303, 0, 0, 3336, 3337, 3, 1018, 509, 0, 3337, 3338, 3,
		1018, 509, 0, 3338, 351, 1, 0, 0, 0, 3339, 3341, 3, 904, 452, 0, 3340,
		3339, 1, 0, 0, 0, 3340, 3341, 1, 0, 0, 0, 3341, 3342, 1, 0, 0, 0, 3342,
		3343, 5, 210, 0, 0, 3343, 3356, 7, 18, 0, 0, 3344, 3346, 3, 1012, 506,
		0, 3345, 3347, 3, 1016, 508, 0, 3346, 3345, 1, 0, 0, 0, 3346, 3347, 1,
		0, 0, 0, 3347, 3349, 1, 0, 0, 0, 3348, 3350, 3, 826, 413, 0, 3349, 3348,
		1, 0, 0, 0, 3349, 3350, 1, 0, 0, 0, 3350, 3357, 1, 0, 0, 0, 3351, 3352,
		5, 159, 0, 0, 3352, 3357, 3, 958, 479, 0, 3353, 3354, 5, 46, 0, 0, 3354,
		3355, 5, 2, 0, 0, 3355, 3357, 5, 4, 0, 0, 3356, 3344, 1, 0, 0, 0, 3356,
		3351, 1, 0, 0, 0, 3356, 3353, 1, 0, 0, 0, 3357, 3361, 1, 0, 0, 0, 3358,
		3360, 3, 354, 177, 0, 3359, 3358, 1, 0, 0, 0, 3360, 3363, 1, 0, 0, 0, 3361,
		3359, 1, 0, 0, 0, 3361, 3362, 1, 0, 0, 0, 3362, 3365, 1, 0, 0, 0, 3363,
		3361, 1, 0, 0, 0, 3364, 3366, 3, 954, 477, 0, 3365, 3364, 1, 0, 0, 0, 3365,
		3366, 1, 0, 0, 0, 3366, 3377, 1, 0, 0, 0, 3367, 3378, 3, 752, 376, 0, 3368,
		3369, 5, 462, 0, 0, 3369, 3374, 3, 842, 421, 0, 3370, 3371, 5, 3, 0, 0,
		3371, 3373, 3, 842, 421, 0, 3372, 3370, 1, 0, 0, 0, 3373, 3376, 1, 0, 0,
		0, 3374, 3372, 1, 0, 0, 0, 3374, 3375, 1, 0, 0, 0, 3375, 3378, 1, 0, 0,
		0, 3376, 3374, 1, 0, 0, 0, 3377, 3367, 1, 0, 0, 0, 3377, 3368, 1, 0, 0,
		0, 3378, 353, 1, 0, 0, 0, 3379, 3384, 3, 356, 178, 0, 3380, 3381, 5, 480,
		0, 0, 3381, 3382, 5, 230, 0, 0, 3382, 3384, 3, 1018, 509, 0, 3383, 3379,
		1, 0, 0, 0, 3383, 3380, 1, 0, 0, 0, 3384, 355, 1, 0, 0, 0, 3385, 3389,
		3, 824, 412, 0, 3386, 3387, 5, 55, 0, 0, 3387, 3389, 5, 273, 0, 0, 3388,
		3385, 1, 0, 0, 0, 3388, 3386, 1, 0, 0, 0, 3389, 357, 1, 0, 0, 0, 3390,
		3392, 3, 904, 452, 0, 3391, 3390, 1, 0, 0, 0, 3391, 3392, 1, 0, 0, 0, 3392,
		3394, 1, 0, 0, 0, 3393, 3395, 3, 756, 378, 0, 3394, 3393, 1, 0, 0, 0, 3394,
		3395, 1, 0, 0, 0, 3395, 3396, 1, 0, 0, 0, 3396, 3397, 5, 455, 0, 0, 3397,
		3398, 3, 1012, 506, 0, 3398, 3399, 5, 396, 0, 0, 3399, 3400, 3, 1036, 518,
		0, 3400, 3403, 3, 778, 389, 0, 3401, 3402, 5, 478, 0, 0, 3402, 3404, 3,
		852, 426, 0, 3403, 3401, 1, 0, 0, 0, 3403, 3404, 1, 0, 0, 0, 3404, 359,
		1, 0, 0, 0, 3405, 3407, 3, 904, 452, 0, 3406, 3405, 1, 0, 0, 0, 3406, 3407,
		1, 0, 0, 0, 3407, 3409, 1, 0, 0, 0, 3408, 3410, 3, 756, 378, 0, 3409, 3408,
		1, 0, 0, 0, 3409, 3410, 1, 0, 0, 0, 3410, 3411, 1, 0, 0, 0, 3411, 3412,
		5, 118, 0, 0, 3412, 3413, 5, 172, 0, 0, 3413, 3415, 3, 1012, 506, 0, 3414,
		3416, 3, 826, 413, 0, 3415, 3414, 1, 0, 0, 0, 3415, 3416, 1, 0, 0, 0, 3416,
		3419, 1, 0, 0, 0, 3417, 3418, 5, 460, 0, 0, 3418, 3420, 3, 792, 396, 0,
		3419, 3417, 1, 0, 0, 0, 3419, 3420, 1, 0, 0, 0, 3420, 3423, 1, 0, 0, 0,
		3421, 3422, 5, 478, 0, 0, 3422, 3424, 3, 852, 426, 0, 3423, 3421, 1, 0,
		0, 0, 3423, 3424, 1, 0, 0, 0, 3424, 361, 1, 0, 0, 0, 3425, 3426, 5, 90,
		0, 0, 3426, 3427, 5, 377, 0, 0, 3427, 3431, 5, 243, 0, 0, 3428, 3429, 3,
		1012, 506, 0, 3429, 3430, 5, 1, 0, 0, 3430, 3432, 1, 0, 0, 0, 3431, 3428,
		1, 0, 0, 0, 3431, 3432, 1, 0, 0, 0, 3432, 3433, 1, 0, 0, 0, 3433, 3434,
		3, 1018, 509, 0, 3434, 3435, 5, 290, 0, 0, 3435, 3444, 3, 1012, 506, 0,
		3436, 3441, 3, 368, 184, 0, 3437, 3438, 5, 3, 0, 0, 3438, 3440, 3, 368,
		184, 0, 3439, 3437, 1, 0, 0, 0, 3440, 3443, 1, 0, 0, 0, 3441, 3439, 1,
		0, 0, 0, 3441, 3442, 1, 0, 0, 0, 3442, 3445, 1, 0, 0, 0, 3443, 3441, 1,
		0, 0, 0, 3444, 3436, 1, 0, 0, 0, 3444, 3445, 1, 0, 0, 0, 3445, 3447, 1,
		0, 0, 0, 3446, 3448, 3, 378, 189, 0, 3447, 3446, 1, 0, 0, 0, 3447, 3448,
		1, 0, 0, 0, 3448, 3449, 1, 0, 0, 0, 3449, 3450, 5, 172, 0, 0, 3450, 3452,
		3, 1018, 509, 0, 3451, 3453, 3, 380, 190, 0, 3452, 3451, 1, 0, 0, 0, 3452,
		3453, 1, 0, 0, 0, 3453, 363, 1, 0, 0, 0, 3454, 3455, 5, 19, 0, 0, 3455,
		3456, 5, 377, 0, 0, 3456, 3457, 5, 243, 0, 0, 3457, 3461, 5, 168, 0, 0,
		3458, 3459, 3, 1012, 506, 0, 3459, 3460, 5, 1, 0, 0, 3460, 3462, 1, 0,
		0, 0, 3461, 3458, 1, 0, 0, 0, 3461, 3462, 1, 0, 0, 0, 3462, 3463, 1, 0,
		0, 0, 3463, 3472, 3, 1018, 509, 0, 3464, 3469, 3, 368, 184, 0, 3465, 3466,
		5, 3, 0, 0, 3466, 3468, 3, 368, 184, 0, 3467, 3465, 1, 0, 0, 0, 3468, 3471,
		1, 0, 0, 0, 3469, 3467, 1, 0, 0, 0, 3469, 3470, 1, 0, 0, 0, 3470, 3473,
		1, 0, 0, 0, 3471, 3469, 1, 0, 0, 0, 3472, 3464, 1, 0, 0, 0, 3472, 3473,
		1, 0, 0, 0, 3473, 3475, 1, 0, 0, 0, 3474, 3476, 3, 378, 189, 0, 3475, 3474,
		1, 0, 0, 0, 3475, 3476, 1, 0, 0, 0, 3476, 3478, 1, 0, 0, 0, 3477, 3479,
		3, 366, 183, 0, 3478, 3477, 1, 0, 0, 0, 3478, 3479, 1, 0, 0, 0, 3479, 365,
		1, 0, 0, 0, 3480, 3481, 5, 172, 0, 0, 3481, 3482, 3, 1018, 509, 0, 3482,
		3483, 3, 380, 190, 0, 3483, 367, 1, 0, 0, 0, 3484, 3491, 3, 370, 185, 0,
		3485, 3491, 3, 372, 186, 0, 3486, 3491, 3, 374, 187, 0, 3487, 3488, 5,
		478, 0, 0, 3488, 3491, 3, 852, 426, 0, 3489, 3491, 3, 826, 413, 0, 3490,
		3484, 1, 0, 0, 0, 3490, 3485, 1, 0, 0, 0, 3490, 3486, 1, 0, 0, 0, 3490,
		3487, 1, 0, 0, 0, 3490, 3489, 1, 0, 0, 0, 3491, 369, 1, 0, 0, 0, 3492,
		3493, 5, 77, 0, 0, 3493, 3494, 5, 429, 0, 0, 3494, 3495, 5, 55, 0, 0, 3495,
		3496, 3, 976, 488, 0, 3496, 371, 1, 0, 0, 0, 3497, 3498, 5, 379, 0, 0,
		3498, 3499, 5, 429, 0, 0, 3499, 3500, 5, 55, 0, 0, 3500, 3501, 3, 976,
		488, 0, 3501, 373, 1, 0, 0, 0, 3502, 3503, 5, 77, 0, 0, 3503, 3504, 3,
		376, 188, 0, 3504, 375, 1, 0, 0, 0, 3505, 3508, 5, 2, 0, 0, 3506, 3509,
		3, 1012, 506, 0, 3507, 3509, 3, 1034, 517, 0, 3508, 3506, 1, 0, 0, 0, 3508,
		3507, 1, 0, 0, 0, 3509, 3517, 1, 0, 0, 0, 3510, 3513, 5, 3, 0, 0, 3511,
		3514, 3, 1012, 506, 0, 3512, 3514, 3, 1034, 517, 0, 3513, 3511, 1, 0, 0,
		0, 3513, 3512, 1, 0, 0, 0, 3514, 3516, 1, 0, 0, 0, 3515, 3510, 1, 0, 0,
		0, 3516, 3519, 1, 0, 0, 0, 3517, 3515, 1, 0, 0, 0, 3517, 3518, 1, 0, 0,
		0, 3518, 3520, 1, 0, 0, 0, 3519, 3517, 1, 0, 0, 0, 3520, 3521, 5, 4, 0,
		0, 3521, 377, 1, 0, 0, 0, 3522, 3523, 3, 954, 477, 0, 3523, 379, 1, 0,
		0, 0, 3524, 3525, 3, 958, 479, 0, 3525, 381, 1, 0, 0, 0, 3526, 3527, 5,
		409, 0, 0, 3527, 3528, 5, 377, 0, 0, 3528, 3529, 5, 243, 0, 0, 3529, 3533,
		5, 168, 0, 0, 3530, 3531, 3, 1012, 506, 0, 3531, 3532, 5, 1, 0, 0, 3532,
		3534, 1, 0, 0, 0, 3533, 3530, 1, 0, 0, 0, 3533, 3534, 1, 0, 0, 0, 3534,
		3535, 1, 0, 0, 0, 3535, 3536, 3, 1018, 509, 0, 3536, 383, 1, 0, 0, 0, 3537,
		3538, 5, 364, 0, 0, 3538, 3539, 5, 377, 0, 0, 3539, 3540, 5, 243, 0, 0,
		3540, 3544, 5, 168, 0, 0, 3541, 3542, 3, 1012, 506, 0, 3542, 3543, 5, 1,
		0, 0, 3543, 3545, 1, 0, 0, 0, 3544, 3541, 1, 0, 0, 0, 3544, 3545, 1, 0,
		0, 0, 3545, 3546, 1, 0, 0, 0, 3546, 3547, 3, 1018, 509, 0, 3547, 385, 1,
		0, 0, 0, 3548, 3549, 5, 307, 0, 0, 3549, 3550, 5, 377, 0, 0, 3550, 3551,
		5, 243, 0, 0, 3551, 3555, 5, 168, 0, 0, 3552, 3553, 3, 1012, 506, 0, 3553,
		3554, 5, 1, 0, 0, 3554, 3556, 1, 0, 0, 0, 3555, 3552, 1, 0, 0, 0, 3555,
		3556, 1, 0, 0, 0, 3556, 3557, 1, 0, 0, 0, 3557, 3558, 3, 1018, 509, 0,
		3558, 387, 1, 0, 0, 0, 3559, 3561, 5, 401, 0, 0, 3560, 3562, 5, 18, 0,
		0, 3561, 3560, 1, 0, 0, 0, 3561, 3562, 1, 0, 0, 0, 3562, 3563, 1, 0, 0,
		0, 3563, 3564, 5, 377, 0, 0, 3564, 3572, 5, 243, 0, 0, 3565, 3569, 5, 168,
		0, 0, 3566, 3567, 3, 1012, 506, 0, 3567, 3568, 5, 1, 0, 0, 3568, 3570,
		1, 0, 0, 0, 3569, 3566, 1, 0, 0, 0, 3569, 3570, 1, 0, 0, 0, 3570, 3571,
		1, 0, 0, 0, 3571, 3573, 3, 1018, 509, 0, 3572, 3565, 1, 0, 0, 0, 3572,
		3573, 1, 0, 0, 0, 3573, 3576, 1, 0, 0, 0, 3574, 3575, 5, 172, 0, 0, 3575,
		3577, 3, 1012, 506, 0, 3576, 3574, 1, 0, 0, 0, 3576, 3577, 1, 0, 0, 0,
		3577, 3580, 1, 0, 0, 0, 3578, 3579, 5, 478, 0, 0, 3579, 3581, 3, 852, 426,
		0, 3580, 3578, 1, 0, 0, 0, 3580, 3581, 1, 0, 0, 0, 3581, 3592, 1, 0, 0,
		0, 3582, 3583, 5, 298, 0, 0, 3583, 3584, 5, 55, 0, 0, 3584, 3589, 3, 770,
		385, 0, 3585, 3586, 5, 3, 0, 0, 3586, 3588, 3, 770, 385, 0, 3587, 3585,
		1, 0, 0, 0, 3588, 3591, 1, 0, 0, 0, 3589, 3587, 1, 0, 0, 0, 3589, 3590,
		1, 0, 0, 0, 3590, 3593, 1, 0, 0, 0, 3591, 3589, 1, 0, 0, 0, 3592, 3582,
		1, 0, 0, 0, 3592, 3593, 1, 0, 0, 0, 3593, 3595, 1, 0, 0, 0, 3594, 3596,
		3, 774, 387, 0, 3595, 3594, 1, 0, 0, 0, 3595, 3596, 1, 0, 0, 0, 3596, 389,
		1, 0, 0, 0, 3597, 3598, 5, 401, 0, 0, 3598, 3599, 5, 377, 0, 0, 3599, 3600,
		5, 243, 0, 0, 3600, 3603, 5, 427, 0, 0, 3601, 3602, 5, 172, 0, 0, 3602,
		3604, 3, 1012, 506, 0, 3603, 3601, 1, 0, 0, 0, 3603, 3604, 1, 0, 0, 0,
		3604, 3605, 1, 0, 0, 0, 3605, 3606, 5, 478, 0, 0, 3606, 3607, 3, 852, 426,
		0, 3607, 391, 1, 0, 0, 0, 3608, 3609, 5, 401, 0, 0, 3609, 3610, 5, 90,
		0, 0, 3610, 3611, 5, 377, 0, 0, 3611, 3615, 5, 243, 0, 0, 3612, 3613, 3,
		1012, 506, 0, 3613, 3614, 5, 1, 0, 0, 3614, 3616, 1, 0, 0, 0, 3615, 3612,
		1, 0, 0, 0, 3615, 3616, 1, 0, 0, 0, 3616, 3617, 1, 0, 0, 0, 3617, 3618,
		3, 1018, 509, 0, 3618, 393, 1, 0, 0, 0, 3619, 3621, 5, 401, 0, 0, 3620,
		3622, 5, 18, 0, 0, 3621, 3620, 1, 0, 0, 0, 3621, 3622, 1, 0, 0, 0, 3622,
		3623, 1, 0, 0, 0, 3623, 3624, 5, 411, 0, 0, 3624, 3632, 5, 243, 0, 0, 3625,
		3629, 5, 168, 0, 0, 3626, 3627, 3, 1012, 506, 0, 3627, 3628, 5, 1, 0, 0,
		3628, 3630, 1, 0, 0, 0, 3629, 3626, 1, 0, 0, 0, 3629, 3630, 1, 0, 0, 0,
		3630, 3631, 1, 0, 0, 0, 3631, 3633, 3, 1018, 509, 0, 3632, 3625, 1, 0,
		0, 0, 3632, 3633, 1, 0, 0, 0, 3633, 3636, 1, 0, 0, 0, 3634, 3635, 5, 172,
		0, 0, 3635, 3637, 3, 1012, 506, 0, 3636, 3634, 1, 0, 0, 0, 3636, 3637,
		1, 0, 0, 0, 3637, 3640, 1, 0, 0, 0, 3638, 3639, 5, 478, 0, 0, 3639, 3641,
		3, 852, 426, 0, 3640, 3638, 1, 0, 0, 0, 3640, 3641, 1, 0, 0, 0, 3641, 3652,
		1, 0, 0, 0, 3642, 3643, 5, 298, 0, 0, 3643, 3644, 5, 55, 0, 0, 3644, 3649,
		3, 770, 385, 0, 3645, 3646, 5, 3, 0, 0, 3646, 3648, 3, 770, 385, 0, 3647,
		3645, 1, 0, 0, 0, 3648, 3651, 1, 0, 0, 0, 3649, 3647, 1, 0, 0, 0, 3649,
		3650, 1, 0, 0, 0, 3650, 3653, 1, 0, 0, 0, 3651, 3649, 1, 0, 0, 0, 3652,
		3642, 1, 0, 0, 0, 3652, 3653, 1, 0, 0, 0, 3653, 3655, 1, 0, 0, 0, 3654,
		3656, 3, 774, 387, 0, 3655, 3654, 1, 0, 0, 0, 3655, 3656, 1, 0, 0, 0, 3656,
		395, 1, 0, 0, 0, 3657, 3659, 5, 20, 0, 0, 3658, 3660, 7, 19, 0, 0, 3659,
		3658, 1, 0, 0, 0, 3659, 3660, 1, 0, 0, 0, 3660, 3661, 1, 0, 0, 0, 3661,
		3662, 5, 422, 0, 0, 3662, 3664, 3, 1014, 507, 0, 3663, 3665, 3, 398, 199,
		0, 3664, 3663, 1, 0, 0, 0, 3664, 3665, 1, 0, 0, 0, 3665, 3667, 1, 0, 0,
		0, 3666, 3668, 3, 826, 413, 0, 3667, 3666, 1, 0, 0, 0, 3667, 3668, 1, 0,
		0, 0, 3668, 3672, 1, 0, 0, 0, 3669, 3670, 5, 480, 0, 0, 3670, 3671, 7,
		12, 0, 0, 3671, 3673, 5, 269, 0, 0, 3672, 3669, 1, 0, 0, 0, 3672, 3673,
		1, 0, 0, 0, 3673, 3675, 1, 0, 0, 0, 3674, 3676, 3, 954, 477, 0, 3675, 3674,
		1, 0, 0, 0, 3675, 3676, 1, 0, 0, 0, 3676, 397, 1, 0, 0, 0, 3677, 3678,
		5, 2, 0, 0, 3678, 3683, 3, 1012, 506, 0, 3679, 3680, 5, 3, 0, 0, 3680,
		3682, 3, 1012, 506, 0, 3681, 3679, 1, 0, 0, 0, 3682, 3685, 1, 0, 0, 0,
		3683, 3681, 1, 0, 0, 0, 3683, 3684, 1, 0, 0, 0, 3684, 3686, 1, 0, 0, 0,
		3685, 3683, 1, 0, 0, 0, 3686, 3687, 5, 4, 0, 0, 3687, 3714, 1, 0, 0, 0,
		3688, 3693, 3, 1012, 506, 0, 3689, 3690, 5, 3, 0, 0, 3690, 3692, 3, 1012,
		506, 0, 3691, 3689, 1, 0, 0, 0, 3692, 3695, 1, 0, 0, 0, 3693, 3691, 1,
		0, 0, 0, 3693, 3694, 1, 0, 0, 0, 3694, 3714, 1, 0, 0, 0, 3695, 3693, 1,
		0, 0, 0, 3696, 3697, 5, 18, 0, 0, 3697, 3714, 5, 77, 0, 0, 3698, 3699,
		5, 321, 0, 0, 3699, 3714, 5, 77, 0, 0, 3700, 3701, 5, 272, 0, 0, 3701,
		3702, 5, 77, 0, 0, 3702, 3703, 5, 2, 0, 0, 3703, 3708, 3, 1012, 506, 0,
		3704, 3705, 5, 3, 0, 0, 3705, 3707, 3, 1012, 506, 0, 3706, 3704, 1, 0,
		0, 0, 3707, 3710, 1, 0, 0, 0, 3708, 3706, 1, 0, 0, 0, 3708, 3709, 1, 0,
		0, 0, 3709, 3711, 1, 0, 0, 0, 3710, 3708, 1, 0, 0, 0, 3711, 3712, 5, 4,
		0, 0, 3712, 3714, 1, 0, 0, 0, 3713, 3677, 1, 0, 0, 0, 3713, 3688, 1, 0,
		0, 0, 3713, 3696, 1, 0, 0, 0, 3713, 3698, 1, 0, 0, 0, 3713, 3700, 1, 0,
		0, 0, 3714, 399, 1, 0, 0, 0, 3715, 3718, 5, 132, 0, 0, 3716, 3717, 5, 272,
		0, 0, 3717, 3719, 5, 77, 0, 0, 3718, 3716, 1, 0, 0, 0, 3718, 3719, 1, 0,
		0, 0, 3719, 3720, 1, 0, 0, 0, 3720, 3721, 5, 407, 0, 0, 3721, 3722, 3,
		1012, 506, 0, 3722, 401, 1, 0, 0, 0, 3723, 3724, 5, 20, 0, 0, 3724, 3725,
		5, 422, 0, 0, 3725, 3726, 3, 1014, 507, 0, 3726, 3727, 5, 455, 0, 0, 3727,
		3728, 5, 189, 0, 0, 3728, 3729, 5, 290, 0, 0, 3729, 3733, 3, 398, 199,
		0, 3730, 3731, 5, 480, 0, 0, 3731, 3732, 5, 518, 0, 0, 3732, 3734, 5, 53,
		0, 0, 3733, 3730, 1, 0, 0, 0, 3733, 3734, 1, 0, 0, 0, 3734, 3736, 1, 0,
		0, 0, 3735, 3737, 3, 954, 477, 0, 3736, 3735, 1, 0, 0, 0, 3736, 3737, 1,
		0, 0, 0, 3737, 403, 1, 0, 0, 0, 3738, 3742, 3, 402, 201, 0, 3739, 3740,
		5, 480, 0, 0, 3740, 3741, 7, 12, 0, 0, 3741, 3743, 5, 269, 0, 0, 3742,
		3739, 1, 0, 0, 0, 3742, 3743, 1, 0, 0, 0, 3743, 405, 1, 0, 0, 0, 3744,
		3745, 5, 20, 0, 0, 3745, 3746, 5, 422, 0, 0, 3746, 3747, 3, 1012, 506,
		0, 3747, 3748, 5, 132, 0, 0, 3748, 3749, 5, 189, 0, 0, 3749, 3750, 5, 290,
		0, 0, 3750, 3755, 3, 1012, 506, 0, 3751, 3752, 5, 3, 0, 0, 3752, 3754,
		3, 1012, 506, 0, 3753, 3751, 1, 0, 0, 0, 3754, 3757, 1, 0, 0, 0, 3755,
		3753, 1, 0, 0, 0, 3755, 3756, 1, 0, 0, 0, 3756, 407, 1, 0, 0, 0, 3757,
		3755, 1, 0, 0, 0, 3758, 3759, 5, 90, 0, 0, 3759, 3761, 5, 20, 0, 0, 3760,
		3762, 7, 19, 0, 0, 3761, 3760, 1, 0, 0, 0, 3761, 3762, 1, 0, 0, 0, 3762,
		3763, 1, 0, 0, 0, 3763, 3765, 5, 18, 0, 0, 3764, 3766, 3, 954, 477, 0,
		3765, 3764, 1, 0, 0, 0, 3765, 3766, 1, 0, 0, 0, 3766, 3803, 1, 0, 0, 0,
		3767, 3768, 5, 90, 0, 0, 3768, 3770, 5, 20, 0, 0, 3769, 3771, 7, 19, 0,
		0, 3770, 3769, 1, 0, 0, 0, 3770, 3771, 1, 0, 0, 0, 3771, 3772, 1, 0, 0,
		0, 3772, 3773, 5, 104, 0, 0, 3773, 3775, 3, 1018, 509, 0, 3774, 3776, 3,
		954, 477, 0, 3775, 3774, 1, 0, 0, 0, 3775, 3776, 1, 0, 0, 0, 3776, 3803,
		1, 0, 0, 0, 3777, 3778, 5, 90, 0, 0, 3778, 3780, 5, 20, 0, 0, 3779, 3781,
		7, 19, 0, 0, 3780, 3779, 1, 0, 0, 0, 3780, 3781, 1, 0, 0, 0, 3781, 3782,
		1, 0, 0, 0, 3782, 3783, 5, 422, 0, 0, 3783, 3795, 3, 1012, 506, 0, 3784,
		3785, 5, 2, 0, 0, 3785, 3790, 3, 1012, 506, 0, 3786, 3787, 5, 3, 0, 0,
		3787, 3789, 3, 1012, 506, 0, 3788, 3786, 1, 0, 0, 0, 3789, 3792, 1, 0,
		0, 0, 3790, 3788, 1, 0, 0, 0, 3790, 3791, 1, 0, 0, 0, 3791, 3793, 1, 0,
		0, 0, 3792, 3790, 1, 0, 0, 0, 3793, 3794, 5, 4, 0, 0, 3794, 3796, 1, 0,
		0, 0, 3795, 3784, 1, 0, 0, 0, 3795, 3796, 1, 0, 0, 0, 3796, 3798, 1, 0,
		0, 0, 3797, 3799, 3, 954, 477, 0, 3798, 3797, 1, 0, 0, 0, 3798, 3799, 1,
		0, 0, 0, 3799, 3803, 1, 0, 0, 0, 3800, 3801, 5, 90, 0, 0, 3801, 3803, 3,
		402, 201, 0, 3802, 3758, 1, 0, 0, 0, 3802, 3767, 1, 0, 0, 0, 3802, 3777,
		1, 0, 0, 0, 3802, 3800, 1, 0, 0, 0, 3803, 409, 1, 0, 0, 0, 3804, 3805,
		5, 132, 0, 0, 3805, 3806, 5, 20, 0, 0, 3806, 3812, 5, 518, 0, 0, 3807,
		3808, 5, 132, 0, 0, 3808, 3809, 5, 18, 0, 0, 3809, 3810, 5, 20, 0, 0, 3810,
		3812, 5, 224, 0, 0, 3811, 3804, 1, 0, 0, 0, 3811, 3807, 1, 0, 0, 0, 3812,
		411, 1, 0, 0, 0, 3813, 3814, 5, 401, 0, 0, 3814, 3816, 5, 20, 0, 0, 3815,
		3817, 7, 20, 0, 0, 3816, 3815, 1, 0, 0, 0, 3816, 3817, 1, 0, 0, 0, 3817,
		3820, 1, 0, 0, 0, 3818, 3819, 5, 478, 0, 0, 3819, 3821, 3, 852, 426, 0,
		3820, 3818, 1, 0, 0, 0, 3820, 3821, 1, 0, 0, 0, 3821, 3832, 1, 0, 0, 0,
		3822, 3823, 5, 298, 0, 0, 3823, 3824, 5, 55, 0, 0, 3824, 3829, 3, 770,
		385, 0, 3825, 3826, 5, 3, 0, 0, 3826, 3828, 3, 770, 385, 0, 3827, 3825,
		1, 0, 0, 0, 3828, 3831, 1, 0, 0, 0, 3829, 3827, 1, 0, 0, 0, 3829, 3830,
		1, 0, 0, 0, 3830, 3833, 1, 0, 0, 0, 3831, 3829, 1, 0, 0, 0, 3832, 3822,
		1, 0, 0, 0, 3832, 3833, 1, 0, 0, 0, 3833, 3835, 1, 0, 0, 0, 3834, 3836,
		3, 774, 387, 0, 3835, 3834, 1, 0, 0, 0, 3835, 3836, 1, 0, 0, 0, 3836, 413,
		1, 0, 0, 0, 3837, 3840, 5, 401, 0, 0, 3838, 3839, 5, 272, 0, 0, 3839, 3841,
		5, 77, 0, 0, 3840, 3838, 1, 0, 0, 0, 3840, 3841, 1, 0, 0, 0, 3841, 3842,
		1, 0, 0, 0, 3842, 3843, 5, 407, 0, 0, 3843, 3846, 5, 267, 0, 0, 3844, 3845,
		5, 478, 0, 0, 3845, 3847, 3, 852, 426, 0, 3846, 3844, 1, 0, 0, 0, 3846,
		3847, 1, 0, 0, 0, 3847, 3858, 1, 0, 0, 0, 3848, 3849, 5, 298, 0, 0, 3849,
		3850, 5, 55, 0, 0, 3850, 3855, 3, 770, 385, 0, 3851, 3852, 5, 3, 0, 0,
		3852, 3854, 3, 770, 385, 0, 3853, 3851, 1, 0, 0, 0, 3854, 3857, 1, 0, 0,
		0, 3855, 3853, 1, 0, 0, 0, 3855, 3856, 1, 0, 0, 0, 3856, 3859, 1, 0, 0,
		0, 3857, 3855, 1, 0, 0, 0, 3858, 3848, 1, 0, 0, 0, 3858, 3859, 1, 0, 0,
		0, 3859, 3861, 1, 0, 0, 0, 3860, 3862, 3, 774, 387, 0, 3861, 3860, 1, 0,
		0, 0, 3861, 3862, 1, 0, 0, 0, 3862, 415, 1, 0, 0, 0, 3863, 3864, 5, 401,
		0, 0, 3864, 3865, 5, 189, 0, 0, 3865, 3868, 5, 267, 0, 0, 3866, 3867, 5,
		478, 0, 0, 3867, 3869, 3, 852, 426, 0, 3868, 3866, 1, 0, 0, 0, 3868, 3869,
		1, 0, 0, 0, 3869, 3880, 1, 0, 0, 0, 3870, 3871, 5, 298, 0, 0, 3871, 3872,
		5, 55, 0, 0, 3872, 3877, 3, 770, 385, 0, 3873, 3874, 5, 3, 0, 0, 3874,
		3876, 3, 770, 385, 0, 3875, 3873, 1, 0, 0, 0, 3876, 3879, 1, 0, 0, 0, 3877,
		3875, 1, 0, 0, 0, 3877, 3878, 1, 0, 0, 0, 3878, 3881, 1, 0, 0, 0, 3879,
		3877, 1, 0, 0, 0, 3880, 3870, 1, 0, 0, 0, 3880, 3881, 1, 0, 0, 0, 3881,
		3883, 1, 0, 0, 0, 3882, 3884, 3, 774, 387, 0, 3883, 3882, 1, 0, 0, 0, 3883,
		3884, 1, 0, 0, 0, 3884, 417, 1, 0, 0, 0, 3885, 3886, 5, 229, 0, 0, 3886,
		3887, 5, 20, 0, 0, 3887, 3888, 5, 518, 0, 0, 3888, 419, 1, 0, 0, 0, 3889,
		3890, 5, 20, 0, 0, 3890, 3891, 5, 330, 0, 0, 3891, 3892, 5, 172, 0, 0,
		3892, 3907, 3, 976, 488, 0, 3893, 3894, 5, 20, 0, 0, 3894, 3895, 5, 330,
		0, 0, 3895, 3896, 5, 172, 0, 0, 3896, 3897, 3, 976, 488, 0, 3897, 3898,
		5, 3, 0, 0, 3898, 3903, 5, 518, 0, 0, 3899, 3900, 5, 3, 0, 0, 3900, 3902,
		5, 518, 0, 0, 3901, 3899, 1, 0, 0, 0, 3902, 3905, 1, 0, 0, 0, 3903, 3901,
		1, 0, 0, 0, 3903, 3904, 1, 0, 0, 0, 3904, 3907, 1, 0, 0, 0, 3905, 3903,
		1, 0, 0, 0, 3906, 3889, 1, 0, 0, 0, 3906, 3893, 1, 0, 0, 0, 3907, 421,
		1, 0, 0, 0, 3908, 3910, 5, 90, 0, 0, 3909, 3911, 5, 178, 0, 0, 3910, 3909,
		1, 0, 0, 0, 3910, 3911, 1, 0, 0, 0, 3911, 3912, 1, 0, 0, 0, 3912, 3915,
		5, 39, 0, 0, 3913, 3914, 5, 290, 0, 0, 3914, 3916, 3, 754, 377, 0, 3915,
		3913, 1, 0, 0, 0, 3915, 3916, 1, 0, 0, 0, 3916, 3917, 1, 0, 0, 0, 3917,
		3918, 5, 460, 0, 0, 3918, 3920, 3, 754, 377, 0, 3919, 3921, 3, 954, 477,
		0, 3920, 3919, 1, 0, 0, 0, 3920, 3921, 1, 0, 0, 0, 3921, 423, 1, 0, 0,
		0, 3922, 3923, 5, 132, 0, 0, 3923, 3924, 5, 39, 0, 0, 3924, 3929, 5, 518,
		0, 0, 3925, 3926, 5, 3, 0, 0, 3926, 3928, 5, 518, 0, 0, 3927, 3925, 1,
		0, 0, 0, 3928, 3931, 1, 0, 0, 0, 3929, 3927, 1, 0, 0, 0, 3929, 3930, 1,
		0, 0, 0, 3930, 425, 1, 0, 0, 0, 3931, 3929, 1, 0, 0, 0, 3932, 3933, 5,
		401, 0, 0, 3933, 3934, 5, 39, 0, 0, 3934, 427, 1, 0, 0, 0, 3935, 3936,
		5, 90, 0, 0, 3936, 3937, 5, 361, 0, 0, 3937, 3941, 5, 181, 0, 0, 3938,
		3939, 5, 197, 0, 0, 3939, 3940, 5, 281, 0, 0, 3940, 3942, 5, 148, 0, 0,
		3941, 3938, 1, 0, 0, 0, 3941, 3942, 1, 0, 0, 0, 3942, 3945, 1, 0, 0, 0,
		3943, 3944, 5, 297, 0, 0, 3944, 3946, 5, 356, 0, 0, 3945, 3943, 1, 0, 0,
		0, 3945, 3946, 1, 0, 0, 0, 3946, 3947, 1, 0, 0, 0, 3947, 3957, 3, 1018,
		509, 0, 3948, 3949, 5, 440, 0, 0, 3949, 3954, 3, 446, 223, 0, 3950, 3951,
		5, 3, 0, 0, 3951, 3953, 3, 446, 223, 0, 3952, 3950, 1, 0, 0, 0, 3953, 3956,
		1, 0, 0, 0, 3954, 3952, 1, 0, 0, 0, 3954, 3955, 1, 0, 0, 0, 3955, 3958,
		1, 0, 0, 0, 3956, 3954, 1, 0, 0, 0, 3957, 3948, 1, 0, 0, 0, 3957, 3958,
		1, 0, 0, 0, 3958, 3959, 1, 0, 0, 0, 3959, 3960, 5, 480, 0, 0, 3960, 3961,
		5, 2, 0, 0, 3961, 3966, 3, 962, 481, 0, 3962, 3963, 5, 3, 0, 0, 3963, 3965,
		3, 962, 481, 0, 3964, 3962, 1, 0, 0, 0, 3965, 3968, 1, 0, 0, 0, 3966, 3964,
		1, 0, 0, 0, 3966, 3967, 1, 0, 0, 0, 3967, 3969, 1, 0, 0, 0, 3968, 3966,
		1, 0, 0, 0, 3969, 3970, 5, 4, 0, 0, 3970, 429, 1, 0, 0, 0, 3971, 3972,
		5, 132, 0, 0, 3972, 3973, 5, 361, 0, 0, 3973, 3974, 5, 181, 0, 0, 3974,
		3975, 3, 1018, 509, 0, 3975, 431, 1, 0, 0, 0, 3976, 3977, 5, 19, 0, 0,
		3977, 3978, 5, 361, 0, 0, 3978, 3979, 5, 181, 0, 0, 3979, 3980, 3, 1018,
		509, 0, 3980, 3981, 5, 13, 0, 0, 3981, 3986, 3, 446, 223, 0, 3982, 3983,
		5, 3, 0, 0, 3983, 3985, 3, 446, 223, 0, 3984, 3982, 1, 0, 0, 0, 3985, 3988,
		1, 0, 0, 0, 3986, 3984, 1, 0, 0, 0, 3986, 3987, 1, 0, 0, 0, 3987, 4029,
		1, 0, 0, 0, 3988, 3986, 1, 0, 0, 0, 3989, 3990, 5, 19, 0, 0, 3990, 3991,
		5, 361, 0, 0, 3991, 3992, 5, 181, 0, 0, 3992, 3993, 3, 1018, 509, 0, 3993,
		3994, 5, 132, 0, 0, 3994, 3995, 5, 2, 0, 0, 3995, 4000, 5, 518, 0, 0, 3996,
		3997, 5, 3, 0, 0, 3997, 3999, 5, 518, 0, 0, 3998, 3996, 1, 0, 0, 0, 3999,
		4002, 1, 0, 0, 0, 4000, 3998, 1, 0, 0, 0, 4000, 4001, 1, 0, 0, 0, 4001,
		4003, 1, 0, 0, 0, 4002, 4000, 1, 0, 0, 0, 4003, 4004, 5, 4, 0, 0, 4004,
		4029, 1, 0, 0, 0, 4005, 4006, 5, 19, 0, 0, 4006, 4007, 5, 361, 0, 0, 4007,
		4008, 5, 181, 0, 0, 4008, 4009, 3, 1018, 509, 0, 4009, 4010, 5, 132, 0,
		0, 4010, 4011, 5, 18, 0, 0, 4011, 4029, 1, 0, 0, 0, 4012, 4013, 5, 19,
		0, 0, 4013, 4014, 5, 361, 0, 0, 4014, 4015, 5, 181, 0, 0, 4015, 4016, 3,
		1018, 509, 0, 4016, 4017, 5, 480, 0, 0, 4017, 4018, 5, 2, 0, 0, 4018, 4023,
		3, 962, 481, 0, 4019, 4020, 5, 3, 0, 0, 4020, 4022, 3, 962, 481, 0, 4021,
		4019, 1, 0, 0, 0, 4022, 4025, 1, 0, 0, 0, 4023, 4021, 1, 0, 0, 0, 4023,
		4024, 1, 0, 0, 0, 4024, 4026, 1, 0, 0, 0, 4025, 4023, 1, 0, 0, 0, 4026,
		4027, 5, 4, 0, 0, 4027, 4029, 1, 0, 0, 0, 4028, 3976, 1, 0, 0, 0, 4028,
		3989, 1, 0, 0, 0, 4028, 4005, 1, 0, 0, 0, 4028, 4012, 1, 0, 0, 0, 4029,
		433, 1, 0, 0, 0, 4030, 4032, 5, 401, 0, 0, 4031, 4033, 5, 467, 0, 0, 4032,
		4031, 1, 0, 0, 0, 4032, 4033, 1, 0, 0, 0, 4033, 4034, 1, 0, 0, 0, 4034,
		4035, 5, 361, 0, 0, 4035, 4036, 5, 181, 0, 0, 4036, 4047, 3, 1018, 509,
		0, 4037, 4039, 5, 401, 0, 0, 4038, 4040, 5, 467, 0, 0, 4039, 4038, 1, 0,
		0, 0, 4039, 4040, 1, 0, 0, 0, 4040, 4041, 1, 0, 0, 0, 4041, 4042, 5, 361,
		0, 0, 4042, 4044, 5, 182, 0, 0, 4043, 4045, 5, 18, 0, 0, 4044, 4043, 1,
		0, 0, 0, 4044, 4045, 1, 0, 0, 0, 4045, 4047, 1, 0, 0, 0, 4046, 4030, 1,
		0, 0, 0, 4046, 4037, 1, 0, 0, 0, 4047, 435, 1, 0, 0, 0, 4048, 4049, 5,
		401, 0, 0, 4049, 4050, 5, 456, 0, 0, 4050, 4051, 5, 361, 0, 0, 4051, 4052,
		5, 181, 0, 0, 4052, 4058, 3, 1018, 509, 0, 4053, 4054, 5, 401, 0, 0, 4054,
		4055, 5, 456, 0, 0, 4055, 4056, 5, 361, 0, 0, 4056, 4058, 5, 182, 0, 0,
		4057, 4048, 1, 0, 0, 0, 4057, 4053, 1, 0, 0, 0, 4058, 437, 1, 0, 0, 0,
		4059, 4061, 5, 90, 0, 0, 4060, 4062, 5, 151, 0, 0, 4061, 4060, 1, 0, 0,
		0, 4061, 4062, 1, 0, 0, 0, 4062, 4063, 1, 0, 0, 0, 4063, 4064, 5, 361,
		0, 0, 4064, 4066, 3, 1026, 513, 0, 4065, 4067, 3, 954, 477, 0, 4066, 4065,
		1, 0, 0, 0, 4066, 4067, 1, 0, 0, 0, 4067, 439, 1, 0, 0, 0, 4068, 4069,
		5, 19, 0, 0, 4069, 4070, 5, 361, 0, 0, 4070, 4071, 3, 1026, 513, 0, 4071,
		4072, 5, 396, 0, 0, 4072, 4073, 3, 954, 477, 0, 4073, 441, 1, 0, 0, 0,
		4074, 4075, 5, 132, 0, 0, 4075, 4076, 5, 361, 0, 0, 4076, 4077, 3, 1026,
		513, 0, 4077, 443, 1, 0, 0, 0, 4078, 4079, 5, 401, 0, 0, 4079, 4080, 5,
		362, 0, 0, 4080, 445, 1, 0, 0, 0, 4081, 4082, 5, 2, 0, 0, 4082, 4083, 3,
		854, 427, 0, 4083, 4084, 5, 4, 0, 0, 4084, 447, 1, 0, 0, 0, 4085, 4087,
		5, 401, 0, 0, 4086, 4088, 5, 175, 0, 0, 4087, 4086, 1, 0, 0, 0, 4087, 4088,
		1, 0, 0, 0, 4088, 4090, 1, 0, 0, 0, 4089, 4091, 7, 21, 0, 0, 4090, 4089,
		1, 0, 0, 0, 4090, 4091, 1, 0, 0, 0, 4091, 4092, 1, 0, 0, 0, 4092, 4095,
		5, 177, 0, 0, 4093, 4094, 7, 1, 0, 0, 4094, 4096, 3, 1012, 506, 0, 4095,
		4093, 1, 0, 0, 0, 4095, 4096, 1, 0, 0, 0, 4096, 4101, 1, 0, 0, 0, 4097,
		4098, 5, 240, 0, 0, 4098, 4102, 3, 976, 488, 0, 4099, 4100, 5, 478, 0,
		0, 4100, 4102, 3, 852, 426, 0, 4101, 4097, 1, 0, 0, 0, 4101, 4099, 1, 0,
		0, 0, 4101, 4102, 1, 0, 0, 0, 4102, 449, 1, 0, 0, 0, 4103, 4105, 5, 132,
		0, 0, 4104, 4106, 5, 178, 0, 0, 4105, 4104, 1, 0, 0, 0, 4105, 4106, 1,
		0, 0, 0, 4106, 4107, 1, 0, 0, 0, 4107, 4110, 5, 176, 0, 0, 4108, 4109,
		5, 197, 0, 0, 4109, 4111, 5, 148, 0, 0, 4110, 4108, 1, 0, 0, 0, 4110, 4111,
		1, 0, 0, 0, 4111, 4112, 1, 0, 0, 0, 4112, 4113, 3, 1012, 506, 0, 4113,
		4114, 5, 2, 0, 0, 4114, 4115, 3, 456, 228, 0, 4115, 4116, 5, 4, 0, 0, 4116,
		451, 1, 0, 0, 0, 4117, 4118, 5, 90, 0, 0, 4118, 4120, 3, 70, 35, 0, 4119,
		4121, 5, 178, 0, 0, 4120, 4119, 1, 0, 0, 0, 4120, 4121, 1, 0, 0, 0, 4121,
		4123, 1, 0, 0, 0, 4122, 4124, 7, 22, 0, 0, 4123, 4122, 1, 0, 0, 0, 4123,
		4124, 1, 0, 0, 0, 4124, 4125, 1, 0, 0, 0, 4125, 4126, 5, 176, 0, 0, 4126,
		4127, 3, 72, 36, 0, 4127, 4128, 3, 1012, 506, 0, 4128, 4129, 5, 2, 0, 0,
		4129, 4130, 3, 456, 228, 0, 4130, 4131, 5, 4, 0, 0, 4131, 4132, 5, 367,
		0, 0, 4132, 4135, 3, 994, 497, 0, 4133, 4136, 3, 954, 477, 0, 4134, 4136,
		3, 964, 482, 0, 4135, 4136, 1, 0, 0, 0, 4135, 4133, 1, 0, 0, 0, 4135, 4134,
		1, 0, 0, 0, 4136, 4138, 1, 0, 0, 0, 4137, 4139, 3, 454, 227, 0, 4138, 4137,
		1, 0, 0, 0, 4138, 4139, 1, 0, 0, 0, 4139, 453, 1, 0, 0, 0, 4140, 4141,
		5, 27, 0, 0, 4141, 4142, 5, 535, 0, 0, 4142, 455, 1, 0, 0, 0, 4143, 4145,
		3, 994, 497, 0, 4144, 4143, 1, 0, 0, 0, 4144, 4145, 1, 0, 0, 0, 4145, 4150,
		1, 0, 0, 0, 4146, 4147, 5, 3, 0, 0, 4147, 4149, 3, 994, 497, 0, 4148, 4146,
		1, 0, 0, 0, 4149, 4152, 1, 0, 0, 0, 4150, 4148, 1, 0, 0, 0, 4150, 4151,
		1, 0, 0, 0, 4151, 4155, 1, 0, 0, 0, 4152, 4150, 1, 0, 0, 0, 4153, 4154,
		5, 3, 0, 0, 4154, 4156, 5, 533, 0, 0, 4155, 4153, 1, 0, 0, 0, 4155, 4156,
		1, 0, 0, 0, 4156, 457, 1, 0, 0, 0, 4157, 4158, 5, 243, 0, 0, 4158, 4159,
		5, 230, 0, 0, 4159, 4161, 3, 460, 230, 0, 4160, 4162, 3, 462, 231, 0, 4161,
		4160, 1, 0, 0, 0, 4161, 4162, 1, 0, 0, 0, 4162, 4164, 1, 0, 0, 0, 4163,
		4165, 3, 468, 234, 0, 4164, 4163, 1, 0, 0, 0, 4164, 4165, 1, 0, 0, 0, 4165,
		4168, 1, 0, 0, 0, 4166, 4167, 5, 55, 0, 0, 4167, 4169, 3, 1026, 513, 0,
		4168, 4166, 1, 0, 0, 0, 4168, 4169, 1, 0, 0, 0, 4169, 4172, 1, 0, 0, 0,
		4170, 4171, 5, 332, 0, 0, 4171, 4173, 3, 958, 479, 0, 4172, 4170, 1, 0,
		0, 0, 4172, 4173, 1, 0, 0, 0, 4173, 4186, 1, 0, 0, 0, 4174, 4175, 5, 243,
		0, 0, 4175, 4176, 5, 230, 0, 0, 4176, 4178, 3, 460, 230, 0, 4177, 4179,
		3, 462, 231, 0, 4178, 4177, 1, 0, 0, 0, 4178, 4179, 1, 0, 0, 0, 4179, 4180,
		1, 0, 0, 0, 4180, 4183, 3, 470, 235, 0, 4181, 4182, 5, 332, 0, 0, 4182,
		4184, 3, 958, 479, 0, 4183, 4181, 1, 0, 0, 0, 4183, 4184, 1, 0, 0, 0, 4184,
		4186, 1, 0, 0, 0, 4185, 4157, 1, 0, 0, 0, 4185, 4174, 1, 0, 0, 0, 4186,
		459, 1, 0, 0, 0, 4187, 4188, 3, 1018, 509, 0, 4188, 4189, 5, 1, 0, 0, 4189,
		4191, 1, 0, 0, 0, 4190, 4187, 1, 0, 0, 0, 4190, 4191, 1, 0, 0, 0, 4191,
		4192, 1, 0, 0, 0, 4192, 4193, 3, 1018, 509, 0, 4193, 461, 1, 0, 0, 0, 4194,
		4195, 5, 2, 0, 0, 4195, 4200, 3, 464, 232, 0, 4196, 4197, 5, 3, 0, 0, 4197,
		4199, 3, 464, 232, 0, 4198, 4196, 1, 0, 0, 0, 4199, 4202, 1, 0, 0, 0, 4200,
		4198, 1, 0, 0, 0, 4200, 4201, 1, 0, 0, 0, 4201, 4203, 1, 0, 0, 0, 4202,
		4200, 1, 0, 0, 0, 4203, 4204, 5, 4, 0, 0, 4204, 463, 1, 0, 0, 0, 4205,
		4206, 5, 102, 0, 0, 4206, 4207, 5, 207, 0, 0, 4207, 4209, 3, 926, 463,
		0, 4208, 4210, 5, 275, 0, 0, 4209, 4208, 1, 0, 0, 0, 4209, 4210, 1, 0,
		0, 0, 4210, 4211, 1, 0, 0, 0, 4211, 4212, 5, 218, 0, 0, 4212, 4213, 5,
		422, 0, 0, 4213, 4215, 3, 1018, 509, 0, 4214, 4216, 3, 826, 413, 0, 4215,
		4214, 1, 0, 0, 0, 4215, 4216, 1, 0, 0, 0, 4216, 4221, 1, 0, 0, 0, 4217,
		4218, 5, 77, 0, 0, 4218, 4219, 5, 429, 0, 0, 4219, 4220, 5, 55, 0, 0, 4220,
		4222, 3, 976, 488, 0, 4221, 4217, 1, 0, 0, 0, 4221, 4222, 1, 0, 0, 0, 4222,
		4227, 1, 0, 0, 0, 4223, 4224, 5, 379, 0, 0, 4224, 4225, 5, 429, 0, 0, 4225,
		4226, 5, 55, 0, 0, 4226, 4228, 3, 976, 488, 0, 4227, 4223, 1, 0, 0, 0,
		4227, 4228, 1, 0, 0, 0, 4228, 4230, 1, 0, 0, 0, 4229, 4231, 3, 974, 487,
		0, 4230, 4229, 1, 0, 0, 0, 4230, 4231, 1, 0, 0, 0, 4231, 4233, 1, 0, 0,
		0, 4232, 4234, 3, 466, 233, 0, 4233, 4232, 1, 0, 0, 0, 4233, 4234, 1, 0,
		0, 0, 4234, 4236, 1, 0, 0, 0, 4235, 4237, 3, 824, 412, 0, 4236, 4235, 1,
		0, 0, 0, 4236, 4237, 1, 0, 0, 0, 4237, 4243, 1, 0, 0, 0, 4238, 4239, 5,
		77, 0, 0, 4239, 4240, 5, 172, 0, 0, 4240, 4241, 5, 306, 0, 0, 4241, 4242,
		5, 27, 0, 0, 4242, 4244, 3, 1024, 512, 0, 4243, 4238, 1, 0, 0, 0, 4243,
		4244, 1, 0, 0, 0, 4244, 4247, 1, 0, 0, 0, 4245, 4246, 5, 396, 0, 0, 4246,
		4248, 3, 446, 223, 0, 4247, 4245, 1, 0, 0, 0, 4247, 4248, 1, 0, 0, 0, 4248,
		4251, 1, 0, 0, 0, 4249, 4250, 5, 478, 0, 0, 4250, 4252, 3, 852, 426, 0,
		4251, 4249, 1, 0, 0, 0, 4251, 4252, 1, 0, 0, 0, 4252, 4275, 1, 0, 0, 0,
		4253, 4254, 5, 102, 0, 0, 4254, 4255, 5, 172, 0, 0, 4255, 4256, 5, 422,
		0, 0, 4256, 4258, 3, 1018, 509, 0, 4257, 4259, 5, 275, 0, 0, 4258, 4257,
		1, 0, 0, 0, 4258, 4259, 1, 0, 0, 0, 4259, 4260, 1, 0, 0, 0, 4260, 4261,
		5, 218, 0, 0, 4261, 4262, 5, 422, 0, 0, 4262, 4264, 3, 1018, 509, 0, 4263,
		4265, 3, 826, 413, 0, 4264, 4263, 1, 0, 0, 0, 4264, 4265, 1, 0, 0, 0, 4265,
		4268, 1, 0, 0, 0, 4266, 4267, 5, 396, 0, 0, 4267, 4269, 3, 446, 223, 0,
		4268, 4266, 1, 0, 0, 0, 4268, 4269, 1, 0, 0, 0, 4269, 4272, 1, 0, 0, 0,
		4270, 4271, 5, 478, 0, 0, 4271, 4273, 3, 852, 426, 0, 4272, 4270, 1, 0,
		0, 0, 4272, 4273, 1, 0, 0, 0, 4273, 4275, 1, 0, 0, 0, 4274, 4205, 1, 0,
		0, 0, 4274, 4253, 1, 0, 0, 0, 4275, 465, 1, 0, 0, 0, 4276, 4280, 5, 2,
		0, 0, 4277, 4278, 5, 400, 0, 0, 4278, 4279, 5, 492, 0, 0, 4279, 4281, 5,
		518, 0, 0, 4280, 4277, 1, 0, 0, 0, 4280, 4281, 1, 0, 0, 0, 4281, 4285,
		1, 0, 0, 0, 4282, 4283, 5, 443, 0, 0, 4283, 4284, 5, 492, 0, 0, 4284, 4286,
		3, 982, 491, 0, 4285, 4282, 1, 0, 0, 0, 4285, 4286, 1, 0, 0, 0, 4286, 4290,
		1, 0, 0, 0, 4287, 4288, 5, 138, 0, 0, 4288, 4289, 5, 492, 0, 0, 4289, 4291,
		3, 976, 488, 0, 4290, 4287, 1, 0, 0, 0, 4290, 4291, 1, 0, 0, 0, 4291, 4295,
		1, 0, 0, 0, 4292, 4293, 5, 143, 0, 0, 4293, 4294, 5, 492, 0, 0, 4294, 4296,
		3, 976, 488, 0, 4295, 4292, 1, 0, 0, 0, 4295, 4296, 1, 0, 0, 0, 4296, 4297,
		1, 0, 0, 0, 4297, 4298, 5, 4, 0, 0, 4298, 467, 1, 0, 0, 0, 4299, 4300,
		5, 480, 0, 0, 4300, 4302, 5, 52, 0, 0, 4301, 4303, 3, 958, 479, 0, 4302,
		4301, 1, 0, 0, 0, 4302, 4303, 1, 0, 0, 0, 4303, 4311, 1, 0, 0, 0, 4304,
		4305, 5, 480, 0, 0, 4305, 4306, 5, 52, 0, 0, 4306, 4308, 3, 1026, 513,
		0, 4307, 4309, 3, 958, 479, 0, 4308, 4307, 1, 0, 0, 0, 4308, 4309, 1, 0,
		0, 0, 4309, 4311, 1, 0, 0, 0, 4310, 4299, 1, 0, 0, 0, 4310, 4304, 1, 0,
		0, 0, 4311, 469, 1, 0, 0, 0, 4312, 4313, 5, 480, 0, 0, 4313, 4314, 5, 361,
		0, 0, 4314, 4316, 3, 1026, 513, 0, 4315, 4317, 3, 958, 479, 0, 4316, 4315,
		1, 0, 0, 0, 4316, 4317, 1, 0, 0, 0, 4317, 471, 1, 0, 0, 0, 4318, 4319,
		5, 401, 0, 0, 4319, 4321, 5, 243, 0, 0, 4320, 4322, 5, 18, 0, 0, 4321,
		4320, 1, 0, 0, 0, 4321, 4322, 1, 0, 0, 0, 4322, 4325, 1, 0, 0, 0, 4323,
		4324, 5, 172, 0, 0, 4324, 4326, 3, 1018, 509, 0, 4325, 4323, 1, 0, 0, 0,
		4325, 4326, 1, 0, 0, 0, 4326, 4329, 1, 0, 0, 0, 4327, 4328, 5, 478, 0,
		0, 4328, 4330, 3, 852, 426, 0, 4329, 4327, 1, 0, 0, 0, 4329, 4330, 1, 0,
		0, 0, 4330, 4341, 1, 0, 0, 0, 4331, 4332, 5, 298, 0, 0, 4332, 4333, 5,
		55, 0, 0, 4333, 4338, 3, 770, 385, 0, 4334, 4335, 5, 3, 0, 0, 4335, 4337,
		3, 770, 385, 0, 4336, 4334, 1, 0, 0, 0, 4337, 4340, 1, 0, 0, 0, 4338, 4336,
		1, 0, 0, 0, 4338, 4339, 1, 0, 0, 0, 4339, 4342, 1, 0, 0, 0, 4340, 4338,
		1, 0, 0, 0, 4341, 4331, 1, 0, 0, 0, 4341, 4342, 1, 0, 0, 0, 4342, 4344,
		1, 0, 0, 0, 4343, 4345, 3, 774, 387, 0, 4344, 4343, 1, 0, 0, 0, 4344, 4345,
		1, 0, 0, 0, 4345, 473, 1, 0, 0, 0, 4346, 4347, 5, 401, 0, 0, 4347, 4348,
		5, 243, 0, 0, 4348, 4351, 5, 475, 0, 0, 4349, 4350, 5, 172, 0, 0, 4350,
		4352, 3, 1018, 509, 0, 4351, 4349, 1, 0, 0, 0, 4351, 4352, 1, 0, 0, 0,
		4352, 4355, 1, 0, 0, 0, 4353, 4354, 5, 478, 0, 0, 4354, 4356, 3, 852, 426,
		0, 4355, 4353, 1, 0, 0, 0, 4355, 4356, 1, 0, 0, 0, 4356, 4358, 1, 0, 0,
		0, 4357, 4359, 3, 774, 387, 0, 4358, 4357, 1, 0, 0, 0, 4358, 4359, 1, 0,
		0, 0, 4359, 4366, 1, 0, 0, 0, 4360, 4361, 5, 401, 0, 0, 4361, 4362, 5,
		243, 0, 0, 4362, 4363, 5, 475, 0, 0, 4363, 4364, 5, 290, 0, 0, 4364, 4366,
		3, 976, 488, 0, 4365, 4346, 1, 0, 0, 0, 4365, 4360, 1, 0, 0, 0, 4366, 475,
		1, 0, 0, 0, 4367, 4368, 5, 57, 0, 0, 4368, 4371, 5, 243, 0, 0, 4369, 4370,
		5, 172, 0, 0, 4370, 4372, 3, 1018, 509, 0, 4371, 4369, 1, 0, 0, 0, 4371,
		4372, 1, 0, 0, 0, 4372, 4375, 1, 0, 0, 0, 4373, 4374, 5, 478, 0, 0, 4374,
		4376, 3, 852, 426, 0, 4375, 4373, 1, 0, 0, 0, 4375, 4376, 1, 0, 0, 0, 4376,
		477, 1, 0, 0, 0, 4377, 4378, 5, 19, 0, 0, 4378, 4379, 5, 243, 0, 0, 4379,
		4383, 5, 168, 0, 0, 4380, 4381, 3, 1012, 506, 0, 4381, 4382, 5, 1, 0, 0,
		4382, 4384, 1, 0, 0, 0, 4383, 4380, 1, 0, 0, 0, 4383, 4384, 1, 0, 0, 0,
		4384, 4385, 1, 0, 0, 0, 4385, 4387, 3, 1018, 509, 0, 4386, 4388, 3, 378,
		189, 0, 4387, 4386, 1, 0, 0, 0, 4387, 4388, 1, 0, 0, 0, 4388, 479, 1, 0,
		0, 0, 4389, 4390, 5, 57, 0, 0, 4390, 4391, 5, 82, 0, 0, 4391, 4392, 5,
		478, 0, 0, 4392, 4393, 3, 852, 426, 0, 4393, 481, 1, 0, 0, 0, 4394, 4395,
		5, 401, 0, 0, 4395, 4396, 5, 30, 0, 0, 4396, 483, 1, 0, 0, 0, 4397, 4398,
		5, 401, 0, 0, 4398, 4399, 5, 36, 0, 0, 4399, 485, 1, 0, 0, 0, 4400, 4401,
		5, 401, 0, 0, 4401, 4402, 5, 52, 0, 0, 4402, 487, 1, 0, 0, 0, 4403, 4409,
		5, 401, 0, 0, 4404, 4405, 5, 64, 0, 0, 4405, 4410, 5, 396, 0, 0, 4406,
		4410, 5, 66, 0, 0, 4407, 4408, 5, 65, 0, 0, 4408, 4410, 5, 396, 0, 0, 4409,
		4404, 1, 0, 0, 0, 4409, 4406, 1, 0, 0, 0, 4409, 4407, 1, 0, 0, 0, 4410,
		4415, 1, 0, 0, 0, 4411, 4412, 5, 240, 0, 0, 4412, 4416, 3, 976, 488, 0,
		4413, 4414, 5, 478, 0, 0, 4414, 4416, 3, 852, 426, 0, 4415, 4411, 1, 0,
		0, 0, 4415, 4413, 1, 0, 0, 0, 4415, 4416, 1, 0, 0, 0, 4416, 489, 1, 0,
		0, 0, 4417, 4418, 5, 401, 0, 0, 4418, 4423, 5, 75, 0, 0, 4419, 4420, 5,
		240, 0, 0, 4420, 4424, 3, 976, 488, 0, 4421, 4422, 5, 478, 0, 0, 4422,
		4424, 3, 852, 426, 0, 4423, 4419, 1, 0, 0, 0, 4423, 4421, 1, 0, 0, 0, 4423,
		4424, 1, 0, 0, 0, 4424, 491, 1, 0, 0, 0, 4425, 4426, 5, 401, 0, 0, 4426,
		4429, 5, 118, 0, 0, 4427, 4428, 7, 1, 0, 0, 4428, 4430, 3, 1012, 506, 0,
		4429, 4427, 1, 0, 0, 0, 4429, 4430, 1, 0, 0, 0, 4430, 493, 1, 0, 0, 0,
		4431, 4432, 5, 401, 0, 0, 4432, 4433, 5, 135, 0, 0, 4433, 4434, 5, 303,
		0, 0, 4434, 4437, 5, 423, 0, 0, 4435, 4436, 7, 1, 0, 0, 4436, 4438, 3,
		1012, 506, 0, 4437, 4435, 1, 0, 0, 0, 4437, 4438, 1, 0, 0, 0, 4438, 495,
		1, 0, 0, 0, 4439, 4440, 5, 401, 0, 0, 4440, 4443, 5, 144, 0, 0, 4441, 4442,
		7, 1, 0, 0, 4442, 4444, 3, 1012, 506, 0, 4443, 4441, 1, 0, 0, 0, 4443,
		4444, 1, 0, 0, 0, 4444, 4449, 1, 0, 0, 0, 4445, 4446, 5, 240, 0, 0, 4446,
		4450, 3, 976, 488, 0, 4447, 4448, 5, 478, 0, 0, 4448, 4450, 3, 852, 426,
		0, 4449, 4445, 1, 0, 0, 0, 4449, 4447, 1, 0, 0, 0, 4449, 4450, 1, 0, 0,
		0, 4450, 497, 1, 0, 0, 0, 4451, 4452, 5, 401, 0, 0, 4452, 4453, 5, 141,
		0, 0, 4453, 499, 1, 0, 0, 0, 4454, 4455, 5, 401, 0, 0, 4455, 4456, 5, 174,
		0, 0, 4456, 501, 1, 0, 0, 0, 4457, 4458, 5, 401, 0, 0, 4458, 4459, 5, 314,
		0, 0, 4459, 503, 1, 0, 0, 0, 4460, 4461, 5, 401, 0, 0, 4461, 4462, 5, 360,
		0, 0, 4462, 505, 1, 0, 0, 0, 4463, 4464, 5, 401, 0, 0, 4464, 4465, 5, 292,
		0, 0, 4465, 4466, 5, 423, 0, 0, 4466, 507, 1, 0, 0, 0, 4467, 4468, 5, 401,
		0, 0, 4468, 4469, 5, 325, 0, 0, 4469, 509, 1, 0, 0, 0, 4470, 4471, 5, 401,
		0, 0, 4471, 4472, 7, 23, 0, 0, 4472, 4477, 5, 408, 0, 0, 4473, 4474, 5,
		240, 0, 0, 4474, 4478, 3, 976, 488, 0, 4475, 4476, 5, 478, 0, 0, 4476,
		4478, 3, 852, 426, 0, 4477, 4473, 1, 0, 0, 0, 4477, 4475, 1, 0, 0, 0, 4477,
		4478, 1, 0, 0, 0, 4478, 511, 1, 0, 0, 0, 4479, 4480, 5, 401, 0, 0, 4480,
		4481, 5, 327, 0, 0, 4481, 4482, 3, 976, 488, 0, 4482, 513, 1, 0, 0, 0,
		4483, 4485, 5, 401, 0, 0, 4484, 4486, 5, 175, 0, 0, 4485, 4484, 1, 0, 0,
		0, 4485, 4486, 1, 0, 0, 0, 4486, 4487, 1, 0, 0, 0, 4487, 4490, 5, 329,
		0, 0, 4488, 4489, 5, 168, 0, 0, 4489, 4491, 3, 976, 488, 0, 4490, 4488,
		1, 0, 0, 0, 4490, 4491, 1, 0, 0, 0, 4491, 515, 1, 0, 0, 0, 4492, 4493,
		5, 401, 0, 0, 4493, 4496, 5, 331, 0, 0, 4494, 4495, 5, 241, 0, 0, 4495,
		4497, 5, 518, 0, 0, 4496, 4494, 1, 0, 0, 0, 4496, 4497, 1, 0, 0, 0, 4497,
		517, 1, 0, 0, 0, 4498, 4499, 5, 401, 0, 0, 4499, 4500, 5, 383, 0, 0, 4500,
		4503, 5, 339, 0, 0, 4501, 4502, 5, 241, 0, 0, 4502, 4504, 5, 518, 0, 0,
		4503, 4501, 1, 0, 0, 0, 4503, 4504, 1, 0, 0, 0, 4504, 519, 1, 0, 0, 0,
		4505, 4507, 5, 401, 0, 0, 4506, 4508, 3, 968, 484, 0, 4507, 4506, 1, 0,
		0, 0, 4507, 4508, 1, 0, 0, 0, 4508, 4509, 1, 0, 0, 0, 4509, 4514, 5, 408,
		0, 0, 4510, 4511, 5, 240, 0, 0, 4511, 4515, 3, 976, 488, 0, 4512, 4513,
		5, 478, 0, 0, 4513, 4515, 3, 852, 426, 0, 4514, 4510, 1, 0, 0, 0, 4514,
		4512, 1, 0, 0, 0, 4514, 4515, 1, 0, 0, 0, 4515, 521, 1, 0, 0, 0, 4516,
		4517, 5, 401, 0, 0, 4517, 4518, 5, 424, 0, 0, 4518, 4546, 5, 518, 0, 0,
		4519, 4520, 5, 401, 0, 0, 4520, 4521, 7, 24, 0, 0, 4521, 4522, 5, 172,
		0, 0, 4522, 4524, 3, 1012, 506, 0, 4523, 4525, 3, 826, 413, 0, 4524, 4523,
		1, 0, 0, 0, 4524, 4525, 1, 0, 0, 0, 4525, 4528, 1, 0, 0, 0, 4526, 4527,
		5, 478, 0, 0, 4527, 4529, 3, 852, 426, 0, 4528, 4526, 1, 0, 0, 0, 4528,
		4529, 1, 0, 0, 0, 4529, 4540, 1, 0, 0, 0, 4530, 4531, 5, 298, 0, 0, 4531,
		4532, 5, 55, 0, 0, 4532, 4537, 3, 770, 385, 0, 4533, 4534, 5, 3, 0, 0,
		4534, 4536, 3, 770, 385, 0, 4535, 4533, 1, 0, 0, 0, 4536, 4539, 1, 0, 0,
		0, 4537, 4535, 1, 0, 0, 0, 4537, 4538, 1, 0, 0, 0, 4538, 4541, 1, 0, 0,
		0, 4539, 4537, 1, 0, 0, 0, 4540, 4530, 1, 0, 0, 0, 4540, 4541, 1, 0, 0,
		0, 4541, 4543, 1, 0, 0, 0, 4542, 4544, 3, 774, 387, 0, 4543, 4542, 1, 0,
		0, 0, 4543, 4544, 1, 0, 0, 0, 4544, 4546, 1, 0, 0, 0, 4545, 4516, 1, 0,
		0, 0, 4545, 4519, 1, 0, 0, 0, 4546, 523, 1, 0, 0, 0, 4547, 4548, 5, 401,
		0, 0, 4548, 4551, 5, 438, 0, 0, 4549, 4550, 7, 1, 0, 0, 4550, 4552, 3,
		1012, 506, 0, 4551, 4549, 1, 0, 0, 0, 4551, 4552, 1, 0, 0, 0, 4552, 4555,
		1, 0, 0, 0, 4553, 4554, 5, 478, 0, 0, 4554, 4556, 3, 852, 426, 0, 4555,
		4553, 1, 0, 0, 0, 4555, 4556, 1, 0, 0, 0, 4556, 525, 1, 0, 0, 0, 4557,
		4559, 5, 401, 0, 0, 4558, 4560, 5, 175, 0, 0, 4559, 4558, 1, 0, 0, 0, 4559,
		4560, 1, 0, 0, 0, 4560, 4561, 1, 0, 0, 0, 4561, 4564, 5, 442, 0, 0, 4562,
		4563, 7, 1, 0, 0, 4563, 4565, 3, 1012, 506, 0, 4564, 4562, 1, 0, 0, 0,
		4564, 4565, 1, 0, 0, 0, 4565, 4570, 1, 0, 0, 0, 4566, 4567, 5, 240, 0,
		0, 4567, 4571, 3, 976, 488, 0, 4568, 4569, 5, 478, 0, 0, 4569, 4571, 3,
		852, 426, 0, 4570, 4566, 1, 0, 0, 0, 4570, 4568, 1, 0, 0, 0, 4570, 4571,
		1, 0, 0, 0, 4571, 527, 1, 0, 0, 0, 4572, 4573, 5, 401, 0, 0, 4573, 4576,
		5, 333, 0, 0, 4574, 4575, 5, 168, 0, 0, 4575, 4577, 3, 976, 488, 0, 4576,
		4574, 1, 0, 0, 0, 4576, 4577, 1, 0, 0, 0, 4577, 4580, 1, 0, 0, 0, 4578,
		4579, 5, 240, 0, 0, 4579, 4581, 3, 976, 488, 0, 4580, 4578, 1, 0, 0, 0,
		4580, 4581, 1, 0, 0, 0, 4581, 4593, 1, 0, 0, 0, 4582, 4583, 5, 401, 0,
		0, 4583, 4586, 5, 332, 0, 0, 4584, 4585, 5, 168, 0, 0, 4585, 4587, 3, 976,
		488, 0, 4586, 4584, 1, 0, 0, 0, 4586, 4587, 1, 0, 0, 0, 4587, 4590, 1,
		0, 0, 0, 4588, 4589, 5, 240, 0, 0, 4589, 4591, 3, 976, 488, 0, 4590, 4588,
		1, 0, 0, 0, 4590, 4591, 1, 0, 0, 0, 4591, 4593, 1, 0, 0, 0, 4592, 4572,
		1, 0, 0, 0, 4592, 4582, 1, 0, 0, 0, 4593, 529, 1, 0, 0, 0, 4594, 4596,
		5, 401, 0, 0, 4595, 4597, 3, 968, 484, 0, 4596, 4595, 1, 0, 0, 0, 4596,
		4597, 1, 0, 0, 0, 4597, 4598, 1, 0, 0, 0, 4598, 4603, 5, 465, 0, 0, 4599,
		4600, 5, 240, 0, 0, 4600, 4604, 3, 976, 488, 0, 4601, 4602, 5, 478, 0,
		0, 4602, 4604, 3, 852, 426, 0, 4603, 4599, 1, 0, 0, 0, 4603, 4601, 1, 0,
		0, 0, 4603, 4604, 1, 0, 0, 0, 4604, 531, 1, 0, 0, 0, 4605, 4606, 5, 401,
		0, 0, 4606, 4608, 7, 25, 0, 0, 4607, 4609, 3, 774, 387, 0, 4608, 4607,
		1, 0, 0, 0, 4608, 4609, 1, 0, 0, 0, 4609, 533, 1, 0, 0, 0, 4610, 4611,
		5, 188, 0, 0, 4611, 4612, 3, 1026, 513, 0, 4612, 535, 1, 0, 0, 0, 4613,
		4614, 5, 90, 0, 0, 4614, 4618, 5, 458, 0, 0, 4615, 4616, 5, 197, 0, 0,
		4616, 4617, 5, 281, 0, 0, 4617, 4619, 5, 148, 0, 0, 4618, 4615, 1, 0, 0,
		0, 4618, 4619, 1, 0, 0, 0, 4619, 4620, 1, 0, 0, 0, 4620, 4622, 3, 1032,
		516, 0, 4621, 4623, 3, 572, 286, 0, 4622, 4621, 1, 0, 0, 0, 4622, 4623,
		1, 0, 0, 0, 4623, 4627, 1, 0, 0, 0, 4624, 4625, 5, 117, 0, 0, 4625, 4626,
		5, 373, 0, 0, 4626, 4628, 3, 694, 347, 0, 4627, 4624, 1, 0, 0, 0, 4627,
		4628, 1, 0, 0, 0, 4628, 4630, 1, 0, 0, 0, 4629, 4631, 3, 954, 477, 0, 4630,
		4629, 1, 0, 0, 0, 4630, 4631, 1, 0, 0, 0, 4631, 537, 1, 0, 0, 0, 4632,
		4633, 5, 132, 0, 0, 4633, 4636, 5, 458, 0, 0, 4634, 4635, 5, 197, 0, 0,
		4635, 4637, 5, 148, 0, 0, 4636, 4634, 1, 0, 0, 0, 4636, 4637, 1, 0, 0,
		0, 4637, 4638, 1, 0, 0, 0, 4638, 4639, 3, 1032, 516, 0, 4639, 539, 1, 0,
		0, 0, 4640, 4641, 5, 19, 0, 0, 4641, 4644, 5, 458, 0, 0, 4642, 4643, 5,
		197, 0, 0, 4643, 4645, 5, 148, 0, 0, 4644, 4642, 1, 0, 0, 0, 4644, 4645,
		1, 0, 0, 0, 4645, 4646, 1, 0, 0, 0, 4646, 4647, 3, 1032, 516, 0, 4647,
		4648, 3, 572, 286, 0, 4648, 4674, 1, 0, 0, 0, 4649, 4650, 5, 19, 0, 0,
		4650, 4653, 5, 458, 0, 0, 4651, 4652, 5, 197, 0, 0, 4652, 4654, 5, 148,
		0, 0, 4653, 4651, 1, 0, 0, 0, 4653, 4654, 1, 0, 0, 0, 4654, 4655, 1, 0,
		0, 0, 4655, 4656, 3, 1032, 516, 0, 4656, 4657, 5, 117, 0, 0, 4657, 4661,
		5, 373, 0, 0, 4658, 4662, 5, 280, 0, 0, 4659, 4662, 5, 18, 0, 0, 4660,
		4662, 3, 694, 347, 0, 4661, 4658, 1, 0, 0, 0, 4661, 4659, 1, 0, 0, 0, 4661,
		4660, 1, 0, 0, 0, 4662, 4674, 1, 0, 0, 0, 4663, 4664, 5, 19, 0, 0, 4664,
		4667, 5, 458, 0, 0, 4665, 4666, 5, 197, 0, 0, 4666, 4668, 5, 148, 0, 0,
		4667, 4665, 1, 0, 0, 0, 4667, 4668, 1, 0, 0, 0, 4668, 4669, 1, 0, 0, 0,
		4669, 4670, 3, 1032, 516, 0, 4670, 4671, 5, 396, 0, 0, 4671, 4672, 3, 954,
		477, 0, 4672, 4674, 1, 0, 0, 0, 4673, 4640, 1, 0, 0, 0, 4673, 4649, 1,
		0, 0, 0, 4673, 4663, 1, 0, 0, 0, 4674, 541, 1, 0, 0, 0, 4675, 4676, 5,
		401, 0, 0, 4676, 4677, 7, 26, 0, 0, 4677, 543, 1, 0, 0, 0, 4678, 4679,
		5, 401, 0, 0, 4679, 4680, 5, 18, 0, 0, 4680, 4688, 5, 31, 0, 0, 4681, 4682,
		5, 401, 0, 0, 4682, 4685, 5, 31, 0, 0, 4683, 4684, 5, 168, 0, 0, 4684,
		4686, 3, 1032, 516, 0, 4685, 4683, 1, 0, 0, 0, 4685, 4686, 1, 0, 0, 0,
		4686, 4688, 1, 0, 0, 0, 4687, 4678, 1, 0, 0, 0, 4687, 4681, 1, 0, 0, 0,
		4688, 545, 1, 0, 0, 0, 4689, 4690, 5, 147, 0, 0, 4690, 4691, 5, 27, 0,
		0, 4691, 4695, 3, 1032, 516, 0, 4692, 4693, 5, 480, 0, 0, 4693, 4694, 5,
		277, 0, 0, 4694, 4696, 5, 370, 0, 0, 4695, 4692, 1, 0, 0, 0, 4695, 4696,
		1, 0, 0, 0, 4696, 547, 1, 0, 0, 0, 4697, 4698, 5, 90, 0, 0, 4698, 4702,
		5, 373, 0, 0, 4699, 4700, 5, 197, 0, 0, 4700, 4701, 5, 281, 0, 0, 4701,
		4703, 5, 148, 0, 0, 4702, 4699, 1, 0, 0, 0, 4702, 4703, 1, 0, 0, 0, 4703,
		4704, 1, 0, 0, 0, 4704, 4706, 3, 694, 347, 0, 4705, 4707, 3, 970, 485,
		0, 4706, 4705, 1, 0, 0, 0, 4706, 4707, 1, 0, 0, 0, 4707, 549, 1, 0, 0,
		0, 4708, 4709, 5, 19, 0, 0, 4709, 4712, 5, 373, 0, 0, 4710, 4711, 5, 197,
		0, 0, 4711, 4713, 5, 148, 0, 0, 4712, 4710, 1, 0, 0, 0, 4712, 4713, 1,
		0, 0, 0, 4713, 4714, 1, 0, 0, 0, 4714, 4715, 3, 694, 347, 0, 4715, 4716,
		5, 396, 0, 0, 4716, 4717, 5, 78, 0, 0, 4717, 4718, 5, 492, 0, 0, 4718,
		4719, 3, 976, 488, 0, 4719, 551, 1, 0, 0, 0, 4720, 4721, 5, 132, 0, 0,
		4721, 4724, 5, 373, 0, 0, 4722, 4723, 5, 197, 0, 0, 4723, 4725, 5, 148,
		0, 0, 4724, 4722, 1, 0, 0, 0, 4724, 4725, 1, 0, 0, 0, 4725, 4726, 1, 0,
		0, 0, 4726, 4727, 3, 694, 347, 0, 4727, 553, 1, 0, 0, 0, 4728, 4729, 5,
		401, 0, 0, 4729, 4730, 5, 374, 0, 0, 4730, 555, 1, 0, 0, 0, 4731, 4732,
		5, 179, 0, 0, 4732, 4733, 3, 1028, 514, 0, 4733, 4735, 5, 440, 0, 0, 4734,
		4736, 5, 458, 0, 0, 4735, 4734, 1, 0, 0, 0, 4735, 4736, 1, 0, 0, 0, 4736,
		4737, 1, 0, 0, 0, 4737, 4738, 3, 1032, 516, 0, 4738, 4746, 1, 0, 0, 0,
		4739, 4740, 5, 179, 0, 0, 4740, 4741, 3, 1028, 514, 0, 4741, 4742, 5, 440,
		0, 0, 4742, 4743, 5, 373, 0, 0, 4743, 4744, 3, 1026, 513, 0, 4744, 4746,
		1, 0, 0, 0, 4745, 4731, 1, 0, 0, 0, 4745, 4739, 1, 0, 0, 0, 4746, 557,
		1, 0, 0, 0, 4747, 4748, 5, 369, 0, 0, 4748, 4749, 3, 1028, 514, 0, 4749,
		4751, 5, 172, 0, 0, 4750, 4752, 5, 458, 0, 0, 4751, 4750, 1, 0, 0, 0, 4751,
		4752, 1, 0, 0, 0, 4752, 4753, 1, 0, 0, 0, 4753, 4754, 3, 1032, 516, 0,
		4754, 4762, 1, 0, 0, 0, 4755, 4756, 5, 369, 0, 0, 4756, 4757, 3, 1028,
		514, 0, 4757, 4758, 5, 172, 0, 0, 4758, 4759, 5, 373, 0, 0, 4759, 4760,
		3, 1026, 513, 0, 4760, 4762, 1, 0, 0, 0, 4761, 4747, 1, 0, 0, 0, 4761,
		4755, 1, 0, 0, 0, 4762, 559, 1, 0, 0, 0, 4763, 4764, 5, 396, 0, 0, 4764,
		4765, 5, 373, 0, 0, 4765, 4780, 5, 117, 0, 0, 4766, 4767, 5, 396, 0, 0,
		4767, 4768, 5, 373, 0, 0, 4768, 4780, 5, 280, 0, 0, 4769, 4770, 5, 396,
		0, 0, 4770, 4771, 5, 373, 0, 0, 4771, 4774, 5, 18, 0, 0, 4772, 4773, 5,
		145, 0, 0, 4773, 4775, 3, 694, 347, 0, 4774, 4772, 1, 0, 0, 0, 4774, 4775,
		1, 0, 0, 0, 4775, 4780, 1, 0, 0, 0, 4776, 4777, 5, 396, 0, 0, 4777, 4778,
		5, 373, 0, 0, 4778, 4780, 3, 694, 347, 0, 4779, 4763, 1, 0, 0, 0, 4779,
		4766, 1, 0, 0, 0, 4779, 4769, 1, 0, 0, 0, 4779, 4776, 1, 0, 0, 0, 4780,
		561, 1, 0, 0, 0, 4781, 4782, 5, 396, 0, 0, 4782, 4783, 5, 117, 0, 0, 4783,
		4787, 5, 373, 0, 0, 4784, 4788, 5, 280, 0, 0, 4785, 4788, 5, 18, 0, 0,
		4786, 4788, 3, 694, 347, 0, 4787, 4784, 1, 0, 0, 0, 4787, 4785, 1, 0, 0,
		0, 4787, 4786, 1, 0, 0, 0, 4788, 4789, 1, 0, 0, 0, 4789, 4790, 5, 440,
		0, 0, 4790, 4791, 3, 1032, 516, 0, 4791, 563, 1, 0, 0, 0, 4792, 4794, 5,
		458, 0, 0, 4793, 4792, 1, 0, 0, 0, 4793, 4794, 1, 0, 0, 0, 4794, 4795,
		1, 0, 0, 0, 4795, 4799, 3, 1032, 516, 0, 4796, 4797, 5, 373, 0, 0, 4797,
		4799, 3, 1026, 513, 0, 4798, 4793, 1, 0, 0, 0, 4798, 4796, 1, 0, 0, 0,
		4799, 565, 1, 0, 0, 0, 4800, 4801, 5, 179, 0, 0, 4801, 4802, 5, 198, 0,
		0, 4802, 4803, 5, 290, 0, 0, 4803, 4804, 5, 458, 0, 0, 4804, 4809, 3, 1032,
		516, 0, 4805, 4806, 5, 3, 0, 0, 4806, 4808, 3, 1032, 516, 0, 4807, 4805,
		1, 0, 0, 0, 4808, 4811, 1, 0, 0, 0, 4809, 4807, 1, 0, 0, 0, 4809, 4810,
		1, 0, 0, 0, 4810, 4812, 1, 0, 0, 0, 4811, 4809, 1, 0, 0, 0, 4812, 4813,
		5, 440, 0, 0, 4813, 4817, 3, 564, 282, 0, 4814, 4815, 5, 480, 0, 0, 4815,
		4816, 5, 179, 0, 0, 4816, 4818, 5, 296, 0, 0, 4817, 4814, 1, 0, 0, 0, 4817,
		4818, 1, 0, 0, 0, 4818, 4889, 1, 0, 0, 0, 4819, 4820, 5, 179, 0, 0, 4820,
		4821, 3, 580, 290, 0, 4821, 4822, 5, 290, 0, 0, 4822, 4823, 3, 576, 288,
		0, 4823, 4824, 5, 440, 0, 0, 4824, 4828, 3, 564, 282, 0, 4825, 4826, 5,
		480, 0, 0, 4826, 4827, 5, 179, 0, 0, 4827, 4829, 5, 296, 0, 0, 4828, 4825,
		1, 0, 0, 0, 4828, 4829, 1, 0, 0, 0, 4829, 4889, 1, 0, 0, 0, 4830, 4831,
		5, 179, 0, 0, 4831, 4832, 3, 580, 290, 0, 4832, 4834, 5, 290, 0, 0, 4833,
		4835, 5, 178, 0, 0, 4834, 4833, 1, 0, 0, 0, 4834, 4835, 1, 0, 0, 0, 4835,
		4836, 1, 0, 0, 0, 4836, 4837, 5, 176, 0, 0, 4837, 4838, 3, 578, 289, 0,
		4838, 4839, 5, 440, 0, 0, 4839, 4843, 3, 564, 282, 0, 4840, 4841, 5, 480,
		0, 0, 4841, 4842, 5, 179, 0, 0, 4842, 4844, 5, 296, 0, 0, 4843, 4840, 1,
		0, 0, 0, 4843, 4844, 1, 0, 0, 0, 4844, 4889, 1, 0, 0, 0, 4845, 4846, 5,
		179, 0, 0, 4846, 4847, 3, 580, 290, 0, 4847, 4848, 5, 290, 0, 0, 4848,
		4849, 5, 418, 0, 0, 4849, 4850, 5, 440, 0, 0, 4850, 4854, 3, 564, 282,
		0, 4851, 4852, 5, 480, 0, 0, 4852, 4853, 5, 179, 0, 0, 4853, 4855, 5, 296,
		0, 0, 4854, 4851, 1, 0, 0, 0, 4854, 4855, 1, 0, 0, 0, 4855, 4889, 1, 0,
		0, 0, 4856, 4857, 5, 179, 0, 0, 4857, 4858, 3, 580, 290, 0, 4858, 4859,
		5, 290, 0, 0, 4859, 4860, 3, 584, 292, 0, 4860, 4861, 3, 576, 288, 0, 4861,
		4862, 5, 440, 0, 0, 4862, 4866, 3, 564, 282, 0, 4863, 4864, 5, 480, 0,
		0, 4864, 4865, 5, 179, 0, 0, 4865, 4867, 5, 296, 0, 0, 4866, 4863, 1, 0,
		0, 0, 4866, 4867, 1, 0, 0, 0, 4867, 4889, 1, 0, 0, 0, 4868, 4869, 5, 179,
		0, 0, 4869, 4870, 3, 580, 290, 0, 4870, 4871, 5, 290, 0, 0, 4871, 4872,
		5, 18, 0, 0, 4872, 4879, 3, 586, 293, 0, 4873, 4874, 5, 202, 0, 0, 4874,
		4875, 5, 18, 0, 0, 4875, 4880, 5, 105, 0, 0, 4876, 4877, 5, 202, 0, 0,
		4877, 4878, 5, 104, 0, 0, 4878, 4880, 3, 1026, 513, 0, 4879, 4873, 1, 0,
		0, 0, 4879, 4876, 1, 0, 0, 0, 4879, 4880, 1, 0, 0, 0, 4880, 4881, 1, 0,
		0, 0, 4881, 4882, 5, 440, 0, 0, 4882, 4886, 3, 564, 282, 0, 4883, 4884,
		5, 480, 0, 0, 4884, 4885, 5, 179, 0, 0, 4885, 4887, 5, 296, 0, 0, 4886,
		4883, 1, 0, 0, 0, 4886, 4887, 1, 0, 0, 0, 4887, 4889, 1, 0, 0, 0, 4888,
		4800, 1, 0, 0, 0, 4888, 4819, 1, 0, 0, 0, 4888, 4830, 1, 0, 0, 0, 4888,
		4845, 1, 0, 0, 0, 4888, 4856, 1, 0, 0, 0, 4888, 4868, 1, 0, 0, 0, 4889,
		567, 1, 0, 0, 0, 4890, 4891, 5, 369, 0, 0, 4891, 4892, 5, 198, 0, 0, 4892,
		4893, 5, 290, 0, 0, 4893, 4894, 5, 458, 0, 0, 4894, 4899, 3, 1032, 516,
		0, 4895, 4896, 5, 3, 0, 0, 4896, 4898, 3, 1032, 516, 0, 4897, 4895, 1,
		0, 0, 0, 4898, 4901, 1, 0, 0, 0, 4899, 4897, 1, 0, 0, 0, 4899, 4900, 1,
		0, 0, 0, 4900, 4902, 1, 0, 0, 0, 4901, 4899, 1, 0, 0, 0, 4902, 4903, 5,
		172, 0, 0, 4903, 4904, 3, 564, 282, 0, 4904, 4955, 1, 0, 0, 0, 4905, 4906,
		5, 369, 0, 0, 4906, 4907, 3, 580, 290, 0, 4907, 4908, 5, 290, 0, 0, 4908,
		4909, 3, 576, 288, 0, 4909, 4910, 5, 172, 0, 0, 4910, 4911, 3, 564, 282,
		0, 4911, 4955, 1, 0, 0, 0, 4912, 4913, 5, 369, 0, 0, 4913, 4914, 3, 580,
		290, 0, 4914, 4916, 5, 290, 0, 0, 4915, 4917, 5, 178, 0, 0, 4916, 4915,
		1, 0, 0, 0, 4916, 4917, 1, 0, 0, 0, 4917, 4918, 1, 0, 0, 0, 4918, 4919,
		5, 176, 0, 0, 4919, 4920, 3, 578, 289, 0, 4920, 4921, 5, 172, 0, 0, 4921,
		4922, 3, 564, 282, 0, 4922, 4955, 1, 0, 0, 0, 4923, 4924, 5, 369, 0, 0,
		4924, 4925, 3, 580, 290, 0, 4925, 4926, 5, 290, 0, 0, 4926, 4927, 5, 418,
		0, 0, 4927, 4928, 5, 172, 0, 0, 4928, 4929, 3, 564, 282, 0, 4929, 4955,
		1, 0, 0, 0, 4930, 4931, 5, 369, 0, 0, 4931, 4932, 3, 580, 290, 0, 4932,
		4933, 5, 290, 0, 0, 4933, 4934, 3, 584, 292, 0, 4934, 4935, 3, 576, 288,
		0, 4935, 4936, 5, 172, 0, 0, 4936, 4937, 3, 564, 282, 0, 4937, 4955, 1,
		0, 0, 0, 4938, 4939, 5, 369, 0, 0, 4939, 4940, 3, 580, 290, 0, 4940, 4941,
		5, 290, 0, 0, 4941, 4942, 5, 18, 0, 0, 4942, 4949, 3, 586, 293, 0, 4943,
		4944, 5, 202, 0, 0, 4944, 4945, 5, 18, 0, 0, 4945, 4950, 5, 105, 0, 0,
		4946, 4947, 5, 202, 0, 0, 4947, 4948, 5, 104, 0, 0, 4948, 4950, 3, 1026,
		513, 0, 4949, 4943, 1, 0, 0, 0, 4949, 4946, 1, 0, 0, 0, 4949, 4950, 1,
		0, 0, 0, 4950, 4951, 1, 0, 0, 0, 4951, 4952, 5, 172, 0, 0, 4952, 4953,
		3, 564, 282, 0, 4953, 4955, 1, 0, 0, 0, 4954, 4890, 1, 0, 0, 0, 4954, 4905,
		1, 0, 0, 0, 4954, 4912, 1, 0, 0, 0, 4954, 4923, 1, 0, 0, 0, 4954, 4930,
		1, 0, 0, 0, 4954, 4938, 1, 0, 0, 0, 4955, 569, 1, 0, 0, 0, 4956, 4957,
		5, 401, 0, 0, 4957, 4971, 5, 180, 0, 0, 4958, 4959, 5, 401, 0, 0, 4959,
		4960, 5, 180, 0, 0, 4960, 4962, 5, 168, 0, 0, 4961, 4963, 5, 458, 0, 0,
		4962, 4961, 1, 0, 0, 0, 4962, 4963, 1, 0, 0, 0, 4963, 4964, 1, 0, 0, 0,
		4964, 4971, 3, 1032, 516, 0, 4965, 4966, 5, 401, 0, 0, 4966, 4967, 5, 180,
		0, 0, 4967, 4968, 5, 168, 0, 0, 4968, 4969, 5, 373, 0, 0, 4969, 4971, 3,
		1026, 513, 0, 4970, 4956, 1, 0, 0, 0, 4970, 4958, 1, 0, 0, 0, 4970, 4965,
		1, 0, 0, 0, 4971, 571, 1, 0, 0, 0, 4972, 4973, 5, 196, 0, 0, 4973, 4975,
		5, 55, 0, 0, 4974, 4976, 5, 305, 0, 0, 4975, 4974, 1, 0, 0, 0, 4975, 4976,
		1, 0, 0, 0, 4976, 4977, 1, 0, 0, 0, 4977, 4986, 3, 976, 488, 0, 4978, 4979,
		5, 196, 0, 0, 4979, 4980, 5, 480, 0, 0, 4980, 4983, 3, 1026, 513, 0, 4981,
		4982, 7, 27, 0, 0, 4982, 4984, 3, 976, 488, 0, 4983, 4981, 1, 0, 0, 0,
		4983, 4984, 1, 0, 0, 0, 4984, 4986, 1, 0, 0, 0, 4985, 4972, 1, 0, 0, 0,
		4985, 4978, 1, 0, 0, 0, 4986, 573, 1, 0, 0, 0, 4987, 4990, 3, 1030, 515,
		0, 4988, 4989, 5, 1, 0, 0, 4989, 4991, 3, 1030, 515, 0, 4990, 4988, 1,
		0, 0, 0, 4990, 4991, 1, 0, 0, 0, 4991, 575, 1, 0, 0, 0, 4992, 4997, 3,
		574, 287, 0, 4993, 4994, 5, 3, 0, 0, 4994, 4996, 3, 574, 287, 0, 4995,
		4993, 1, 0, 0, 0, 4996, 4999, 1, 0, 0, 0, 4997, 4995, 1, 0, 0, 0, 4997,
		4998, 1, 0, 0, 0, 4998, 577, 1, 0, 0, 0, 4999, 4997, 1, 0, 0, 0, 5000,
		5001, 3, 1012, 506, 0, 5001, 5002, 5, 2, 0, 0, 5002, 5003, 3, 456, 228,
		0, 5003, 5012, 5, 4, 0, 0, 5004, 5005, 5, 3, 0, 0, 5005, 5006, 3, 1012,
		506, 0, 5006, 5007, 5, 2, 0, 0, 5007, 5008, 3, 456, 228, 0, 5008, 5009,
		5, 4, 0, 0, 5009, 5011, 1, 0, 0, 0, 5010, 5004, 1, 0, 0, 0, 5011, 5014,
		1, 0, 0, 0, 5012, 5010, 1, 0, 0, 0, 5012, 5013, 1, 0, 0, 0, 5013, 579,
		1, 0, 0, 0, 5014, 5012, 1, 0, 0, 0, 5015, 5020, 3, 582, 291, 0, 5016, 5017,
		5, 3, 0, 0, 5017, 5019, 3, 582, 291, 0, 5018, 5016, 1, 0, 0, 0, 5019, 5022,
		1, 0, 0, 0, 5020, 5018, 1, 0, 0, 0, 5020, 5021, 1, 0, 0, 0, 5021, 581,
		1, 0, 0, 0, 5022, 5020, 1, 0, 0, 0, 5023, 5025, 5, 18, 0, 0, 5024, 5026,
		5, 325, 0, 0, 5025, 5024, 1, 0, 0, 0, 5025, 5026, 1, 0, 0, 0, 5026, 5067,
		1, 0, 0, 0, 5027, 5067, 5, 19, 0, 0, 5028, 5067, 5, 23, 0, 0, 5029, 5067,
		5, 47, 0, 0, 5030, 5049, 5, 90, 0, 0, 5031, 5050, 5, 104, 0, 0, 5032, 5050,
		5, 422, 0, 0, 5033, 5050, 5, 469, 0, 0, 5034, 5050, 5, 176, 0, 0, 5035,
		5036, 5, 178, 0, 0, 5036, 5050, 5, 176, 0, 0, 5037, 5038, 5, 257, 0, 0,
		5038, 5050, 5, 469, 0, 0, 5039, 5050, 5, 361, 0, 0, 5040, 5041, 5, 361,
		0, 0, 5041, 5050, 5, 181, 0, 0, 5042, 5043, 5, 151, 0, 0, 5043, 5050, 5,
		60, 0, 0, 5044, 5045, 5, 410, 0, 0, 5045, 5050, 5, 471, 0, 0, 5046, 5050,
		5, 473, 0, 0, 5047, 5050, 5, 72, 0, 0, 5048, 5050, 5, 315, 0, 0, 5049,
		5031, 1, 0, 0, 0, 5049, 5032, 1, 0, 0, 0, 5049, 5033, 1, 0, 0, 0, 5049,
		5034, 1, 0, 0, 0, 5049, 5035, 1, 0, 0, 0, 5049, 5037, 1, 0, 0, 0, 5049,
		5039, 1, 0, 0, 0, 5049, 5040, 1, 0, 0, 0, 5049, 5042, 1, 0, 0, 0, 5049,
		5044, 1, 0, 0, 0, 5049, 5046, 1, 0, 0, 0, 5049, 5047, 1, 0, 0, 0, 5049,
		5048, 1, 0, 0, 0, 5050, 5067, 1, 0, 0, 0, 5051, 5067, 5, 118, 0, 0, 5052,
		5067, 5, 132, 0, 0, 5053, 5067, 5, 150, 0, 0, 5054, 5067, 5, 158, 0, 0,
		5055, 5067, 5, 198, 0, 0, 5056, 5067, 5, 210, 0, 0, 5057, 5067, 5, 179,
		0, 0, 5058, 5067, 5, 278, 0, 0, 5059, 5067, 5, 293, 0, 0, 5060, 5067, 5,
		313, 0, 0, 5061, 5067, 5, 359, 0, 0, 5062, 5067, 5, 348, 0, 0, 5063, 5067,
		5, 391, 0, 0, 5064, 5067, 5, 455, 0, 0, 5065, 5067, 5, 456, 0, 0, 5066,
		5023, 1, 0, 0, 0, 5066, 5027, 1, 0, 0, 0, 5066, 5028, 1, 0, 0, 0, 5066,
		5029, 1, 0, 0, 0, 5066, 5030, 1, 0, 0, 0, 5066, 5051, 1, 0, 0, 0, 5066,
		5052, 1, 0, 0, 0, 5066, 5053, 1, 0, 0, 0, 5066, 5054, 1, 0, 0, 0, 5066,
		5055, 1, 0, 0, 0, 5066, 5056, 1, 0, 0, 0, 5066, 5057, 1, 0, 0, 0, 5066,
		5058, 1, 0, 0, 0, 5066, 5059, 1, 0, 0, 0, 5066, 5060, 1, 0, 0, 0, 5066,
		5061, 1, 0, 0, 0, 5066, 5062, 1, 0, 0, 0, 5066, 5063, 1, 0, 0, 0, 5066,
		5064, 1, 0, 0, 0, 5066, 5065, 1, 0, 0, 0, 5067, 583, 1, 0, 0, 0, 5068,
		5083, 5, 60, 0, 0, 5069, 5083, 5, 104, 0, 0, 5070, 5071, 5, 257, 0, 0,
		5071, 5083, 5, 469, 0, 0, 5072, 5083, 5, 361, 0, 0, 5073, 5074, 5, 361,
		0, 0, 5074, 5083, 5, 181, 0, 0, 5075, 5076, 5, 410, 0, 0, 5076, 5083, 5,
		471, 0, 0, 5077, 5083, 5, 418, 0, 0, 5078, 5083, 5, 422, 0, 0, 5079, 5083,
		5, 469, 0, 0, 5080, 5083, 5, 473, 0, 0, 5081, 5083, 5, 315, 0, 0, 5082,
		5068, 1, 0, 0, 0, 5082, 5069, 1, 0, 0, 0, 5082, 5070, 1, 0, 0, 0, 5082,
		5072, 1, 0, 0, 0, 5082, 5073, 1, 0, 0, 0, 5082, 5075, 1, 0, 0, 0, 5082,
		5077, 1, 0, 0, 0, 5082, 5078, 1, 0, 0, 0, 5082, 5079, 1, 0, 0, 0, 5082,
		5080, 1, 0, 0, 0, 5082, 5081, 1, 0, 0, 0, 5083, 585, 1, 0, 0, 0, 5084,
		5103, 5, 61, 0, 0, 5085, 5103, 5, 105, 0, 0, 5086, 5103, 5, 177, 0, 0,
		5087, 5088, 5, 178, 0, 0, 5088, 5103, 5, 177, 0, 0, 5089, 5090, 5, 257,
		0, 0, 5090, 5103, 5, 470, 0, 0, 5091, 5103, 5, 319, 0, 0, 5092, 5103, 5,
		362, 0, 0, 5093, 5094, 5, 361, 0, 0, 5094, 5103, 5, 182, 0, 0, 5095, 5096,
		5, 410, 0, 0, 5096, 5103, 5, 472, 0, 0, 5097, 5103, 5, 423, 0, 0, 5098,
		5103, 5, 459, 0, 0, 5099, 5103, 5, 470, 0, 0, 5100, 5103, 5, 474, 0, 0,
		5101, 5103, 5, 316, 0, 0, 5102, 5084, 1, 0, 0, 0, 5102, 5085, 1, 0, 0,
		0, 5102, 5086, 1, 0, 0, 0, 5102, 5087, 1, 0, 0, 0, 5102, 5089, 1, 0, 0,
		0, 5102, 5091, 1, 0, 0, 0, 5102, 5092, 1, 0, 0, 0, 5102, 5093, 1, 0, 0,
		0, 5102, 5095, 1, 0, 0, 0, 5102, 5097, 1, 0, 0, 0, 5102, 5098, 1, 0, 0,
		0, 5102, 5099, 1, 0, 0, 0, 5102, 5100, 1, 0, 0, 0, 5102, 5101, 1, 0, 0,
		0, 5103, 587, 1, 0, 0, 0, 5104, 5105, 5, 90, 0, 0, 5105, 5106, 5, 390,
		0, 0, 5106, 5107, 5, 213, 0, 0, 5107, 5108, 3, 1018, 509, 0, 5108, 5109,
		3, 954, 477, 0, 5109, 589, 1, 0, 0, 0, 5110, 5111, 5, 19, 0, 0, 5111, 5112,
		5, 390, 0, 0, 5112, 5113, 5, 213, 0, 0, 5113, 5114, 3, 1018, 509, 0, 5114,
		5115, 5, 396, 0, 0, 5115, 5116, 3, 958, 479, 0, 5116, 591, 1, 0, 0, 0,
		5117, 5118, 5, 132, 0, 0, 5118, 5119, 5, 390, 0, 0, 5119, 5120, 5, 213,
		0, 0, 5120, 5121, 3, 1018, 509, 0, 5121, 593, 1, 0, 0, 0, 5122, 5123, 5,
		401, 0, 0, 5123, 5124, 5, 390, 0, 0, 5124, 5125, 5, 214, 0, 0, 5125, 595,
		1, 0, 0, 0, 5126, 5127, 5, 401, 0, 0, 5127, 5128, 5, 90, 0, 0, 5128, 5129,
		5, 390, 0, 0, 5129, 5130, 5, 213, 0, 0, 5130, 5131, 3, 1018, 509, 0, 5131,
		597, 1, 0, 0, 0, 5132, 5133, 5, 90, 0, 0, 5133, 5134, 5, 181, 0, 0, 5134,
		5135, 5, 334, 0, 0, 5135, 5136, 3, 1018, 509, 0, 5136, 5137, 3, 954, 477,
		0, 5137, 599, 1, 0, 0, 0, 5138, 5139, 5, 132, 0, 0, 5139, 5140, 5, 181,
		0, 0, 5140, 5141, 5, 334, 0, 0, 5141, 5142, 3, 1018, 509, 0, 5142, 601,
		1, 0, 0, 0, 5143, 5144, 5, 401, 0, 0, 5144, 5145, 5, 181, 0, 0, 5145, 5146,
		5, 335, 0, 0, 5146, 603, 1, 0, 0, 0, 5147, 5148, 5, 401, 0, 0, 5148, 5149,
		5, 90, 0, 0, 5149, 5150, 5, 181, 0, 0, 5150, 5151, 5, 334, 0, 0, 5151,
		5152, 3, 1018, 509, 0, 5152, 605, 1, 0, 0, 0, 5153, 5160, 5, 37, 0, 0,
		5154, 5155, 5, 18, 0, 0, 5155, 5156, 5, 151, 0, 0, 5156, 5161, 5, 61, 0,
		0, 5157, 5158, 5, 151, 0, 0, 5158, 5159, 7, 28, 0, 0, 5159, 5161, 3, 1024,
		512, 0, 5160, 5154, 1, 0, 0, 0, 5160, 5157, 1, 0, 0, 0, 5160, 5161, 1,
		0, 0, 0, 5161, 5164, 1, 0, 0, 0, 5162, 5163, 5, 104, 0, 0, 5163, 5165,
		3, 1018, 509, 0, 5164, 5162, 1, 0, 0, 0, 5164, 5165, 1, 0, 0, 0, 5165,
		5166, 1, 0, 0, 0, 5166, 5167, 5, 403, 0, 0, 5167, 5168, 3, 1012, 506, 0,
		5168, 5169, 5, 440, 0, 0, 5169, 5182, 3, 1018, 509, 0, 5170, 5171, 5, 290,
		0, 0, 5171, 5172, 5, 2, 0, 0, 5172, 5177, 3, 898, 449, 0, 5173, 5174, 5,
		3, 0, 0, 5174, 5176, 3, 898, 449, 0, 5175, 5173, 1, 0, 0, 0, 5176, 5179,
		1, 0, 0, 0, 5177, 5175, 1, 0, 0, 0, 5177, 5178, 1, 0, 0, 0, 5178, 5180,
		1, 0, 0, 0, 5179, 5177, 1, 0, 0, 0, 5180, 5181, 5, 4, 0, 0, 5181, 5183,
		1, 0, 0, 0, 5182, 5170, 1, 0, 0, 0, 5182, 5183, 1, 0, 0, 0, 5183, 5186,
		1, 0, 0, 0, 5184, 5185, 5, 332, 0, 0, 5185, 5187, 3, 958, 479, 0, 5186,
		5184, 1, 0, 0, 0, 5186, 5187, 1, 0, 0, 0, 5187, 607, 1, 0, 0, 0, 5188,
		5189, 5, 57, 0, 0, 5189, 5195, 5, 37, 0, 0, 5190, 5191, 7, 1, 0, 0, 5191,
		5196, 3, 1018, 509, 0, 5192, 5193, 5, 168, 0, 0, 5193, 5194, 5, 151, 0,
		0, 5194, 5196, 5, 60, 0, 0, 5195, 5190, 1, 0, 0, 0, 5195, 5192, 1, 0, 0,
		0, 5195, 5196, 1, 0, 0, 0, 5196, 609, 1, 0, 0, 0, 5197, 5198, 5, 401, 0,
		0, 5198, 5201, 5, 37, 0, 0, 5199, 5200, 7, 1, 0, 0, 5200, 5202, 3, 1018,
		509, 0, 5201, 5199, 1, 0, 0, 0, 5201, 5202, 1, 0, 0, 0, 5202, 611, 1, 0,
		0, 0, 5203, 5204, 5, 363, 0, 0, 5204, 5205, 5, 403, 0, 0, 5205, 5206, 3,
		1012, 506, 0, 5206, 5207, 5, 172, 0, 0, 5207, 5214, 3, 1018, 509, 0, 5208,
		5209, 5, 18, 0, 0, 5209, 5210, 5, 151, 0, 0, 5210, 5215, 5, 61, 0, 0, 5211,
		5212, 5, 151, 0, 0, 5212, 5213, 7, 28, 0, 0, 5213, 5215, 3, 1022, 511,
		0, 5214, 5208, 1, 0, 0, 0, 5214, 5211, 1, 0, 0, 0, 5214, 5215, 1, 0, 0,
		0, 5215, 5222, 1, 0, 0, 0, 5216, 5217, 5, 104, 0, 0, 5217, 5220, 3, 1018,
		509, 0, 5218, 5219, 5, 27, 0, 0, 5219, 5221, 3, 1018, 509, 0, 5220, 5218,
		1, 0, 0, 0, 5220, 5221, 1, 0, 0, 0, 5221, 5223, 1, 0, 0, 0, 5222, 5216,
		1, 0, 0, 0, 5222, 5223, 1, 0, 0, 0, 5223, 5236, 1, 0, 0, 0, 5224, 5225,
		5, 290, 0, 0, 5225, 5226, 5, 2, 0, 0, 5226, 5231, 3, 898, 449, 0, 5227,
		5228, 5, 3, 0, 0, 5228, 5230, 3, 898, 449, 0, 5229, 5227, 1, 0, 0, 0, 5230,
		5233, 1, 0, 0, 0, 5231, 5229, 1, 0, 0, 0, 5231, 5232, 1, 0, 0, 0, 5232,
		5234, 1, 0, 0, 0, 5233, 5231, 1, 0, 0, 0, 5234, 5235, 5, 4, 0, 0, 5235,
		5237, 1, 0, 0, 0, 5236, 5224, 1, 0, 0, 0, 5236, 5237, 1, 0, 0, 0, 5237,
		5240, 1, 0, 0, 0, 5238, 5239, 5, 332, 0, 0, 5239, 5241, 3, 958, 479, 0,
		5240, 5238, 1, 0, 0, 0, 5240, 5241, 1, 0, 0, 0, 5241, 613, 1, 0, 0, 0,
		5242, 5243, 5, 57, 0, 0, 5243, 5249, 5, 363, 0, 0, 5244, 5245, 7, 1, 0,
		0, 5245, 5250, 3, 1018, 509, 0, 5246, 5247, 5, 168, 0, 0, 5247, 5248, 5,
		151, 0, 0, 5248, 5250, 5, 60, 0, 0, 5249, 5244, 1, 0, 0, 0, 5249, 5246,
		1, 0, 0, 0, 5249, 5250, 1, 0, 0, 0, 5250, 615, 1, 0, 0, 0, 5251, 5252,
		5, 401, 0, 0, 5252, 5255, 5, 363, 0, 0, 5253, 5254, 7, 1, 0, 0, 5254, 5256,
		3, 1018, 509, 0, 5255, 5253, 1, 0, 0, 0, 5255, 5256, 1, 0, 0, 0, 5256,
		5259, 1, 0, 0, 0, 5257, 5258, 5, 478, 0, 0, 5258, 5260, 3, 852, 426, 0,
		5259, 5257, 1, 0, 0, 0, 5259, 5260, 1, 0, 0, 0, 5260, 617, 1, 0, 0, 0,
		5261, 5262, 5, 401, 0, 0, 5262, 5263, 5, 403, 0, 0, 5263, 5264, 5, 290,
		0, 0, 5264, 5267, 3, 1018, 509, 0, 5265, 5266, 5, 478, 0, 0, 5266, 5268,
		3, 852, 426, 0, 5267, 5265, 1, 0, 0, 0, 5267, 5268, 1, 0, 0, 0, 5268, 619,
		1, 0, 0, 0, 5269, 5272, 5, 90, 0, 0, 5270, 5271, 5, 345, 0, 0, 5271, 5273,
		5, 291, 0, 0, 5272, 5270, 1, 0, 0, 0, 5272, 5273, 1, 0, 0, 0, 5273, 5274,
		1, 0, 0, 0, 5274, 5275, 5, 359, 0, 0, 5275, 5276, 3, 1018, 509, 0, 5276,
		5277, 5, 480, 0, 0, 5277, 5279, 5, 52, 0, 0, 5278, 5280, 3, 1026, 513,
		0, 5279, 5278, 1, 0, 0, 0, 5279, 5280, 1, 0, 0, 0, 5280, 5281, 1, 0, 0,
		0, 5281, 5282, 5, 290, 0, 0, 5282, 5283, 5, 247, 0, 0, 5283, 5286, 3, 976,
		488, 0, 5284, 5285, 5, 332, 0, 0, 5285, 5287, 3, 958, 479, 0, 5286, 5284,
		1, 0, 0, 0, 5286, 5287, 1, 0, 0, 0, 5287, 621, 1, 0, 0, 0, 5288, 5289,
		5, 132, 0, 0, 5289, 5290, 5, 359, 0, 0, 5290, 5291, 3, 1018, 509, 0, 5291,
		623, 1, 0, 0, 0, 5292, 5293, 5, 13, 0, 0, 5293, 5294, 5, 405, 0, 0, 5294,
		5295, 3, 976, 488, 0, 5295, 625, 1, 0, 0, 0, 5296, 5297, 5, 118, 0, 0,
		5297, 5298, 5, 405, 0, 0, 5298, 5303, 5, 518, 0, 0, 5299, 5300, 5, 3, 0,
		0, 5300, 5302, 5, 518, 0, 0, 5301, 5299, 1, 0, 0, 0, 5302, 5305, 1, 0,
		0, 0, 5303, 5301, 1, 0, 0, 0, 5303, 5304, 1, 0, 0, 0, 5304, 627, 1, 0,
		0, 0, 5305, 5303, 1, 0, 0, 0, 5306, 5307, 5, 401, 0, 0, 5307, 5308, 5,
		405, 0, 0, 5308, 629, 1, 0, 0, 0, 5309, 5310, 5, 401, 0, 0, 5310, 5311,
		5, 479, 0, 0, 5311, 631, 1, 0, 0, 0, 5312, 5313, 5, 13, 0, 0, 5313, 5314,
		5, 35, 0, 0, 5314, 5315, 5, 47, 0, 0, 5315, 5320, 5, 518, 0, 0, 5316, 5317,
		5, 3, 0, 0, 5317, 5319, 5, 518, 0, 0, 5318, 5316, 1, 0, 0, 0, 5319, 5322,
		1, 0, 0, 0, 5320, 5318, 1, 0, 0, 0, 5320, 5321, 1, 0, 0, 0, 5321, 633,
		1, 0, 0, 0, 5322, 5320, 1, 0, 0, 0, 5323, 5324, 5, 118, 0, 0, 5324, 5325,
		5, 35, 0, 0, 5325, 5326, 5, 47, 0, 0, 5326, 5331, 5, 518, 0, 0, 5327, 5328,
		5, 3, 0, 0, 5328, 5330, 5, 518, 0, 0, 5329, 5327, 1, 0, 0, 0, 5330, 5333,
		1, 0, 0, 0, 5331, 5329, 1, 0, 0, 0, 5331, 5332, 1, 0, 0, 0, 5332, 635,
		1, 0, 0, 0, 5333, 5331, 1, 0, 0, 0, 5334, 5335, 5, 401, 0, 0, 5335, 5336,
		5, 35, 0, 0, 5336, 5337, 5, 47, 0, 0, 5337, 637, 1, 0, 0, 0, 5338, 5339,
		3, 1030, 515, 0, 5339, 5340, 5, 1, 0, 0, 5340, 5341, 3, 1030, 515, 0, 5341,
		5342, 5, 1, 0, 0, 5342, 5343, 3, 1030, 515, 0, 5343, 639, 1, 0, 0, 0, 5344,
		5345, 5, 90, 0, 0, 5345, 5346, 5, 103, 0, 0, 5346, 5347, 5, 381, 0, 0,
		5347, 5350, 3, 638, 319, 0, 5348, 5349, 5, 478, 0, 0, 5349, 5351, 3, 852,
		426, 0, 5350, 5348, 1, 0, 0, 0, 5350, 5351, 1, 0, 0, 0, 5351, 5352, 1,
		0, 0, 0, 5352, 5353, 5, 324, 0, 0, 5353, 5355, 5, 492, 0, 0, 5354, 5356,
		5, 501, 0, 0, 5355, 5354, 1, 0, 0, 0, 5355, 5356, 1, 0, 0, 0, 5356, 5357,
		1, 0, 0, 0, 5357, 5359, 5, 518, 0, 0, 5358, 5360, 3, 954, 477, 0, 5359,
		5358, 1, 0, 0, 0, 5359, 5360, 1, 0, 0, 0, 5360, 641, 1, 0, 0, 0, 5361,
		5362, 5, 401, 0, 0, 5362, 5363, 5, 103, 0, 0, 5363, 5364, 5, 382, 0, 0,
		5364, 643, 1, 0, 0, 0, 5365, 5366, 5, 132, 0, 0, 5366, 5367, 5, 103, 0,
		0, 5367, 5368, 5, 381, 0, 0, 5368, 5369, 5, 518, 0, 0, 5369, 645, 1, 0,
		0, 0, 5370, 5371, 5, 69, 0, 0, 5371, 5372, 5, 103, 0, 0, 5372, 5373, 5,
		382, 0, 0, 5373, 647, 1, 0, 0, 0, 5374, 5375, 5, 56, 0, 0, 5375, 5376,
		5, 391, 0, 0, 5376, 5381, 3, 788, 394, 0, 5377, 5378, 5, 3, 0, 0, 5378,
		5380, 3, 788, 394, 0, 5379, 5377, 1, 0, 0, 0, 5380, 5383, 1, 0, 0, 0, 5381,
		5379, 1, 0, 0, 0, 5381, 5382, 1, 0, 0, 0, 5382, 5384, 1, 0, 0, 0, 5383,
		5381, 1, 0, 0, 0, 5384, 5385, 5, 172, 0, 0, 5385, 5388, 3, 1012, 506, 0,
		5386, 5387, 5, 478, 0, 0, 5387, 5389, 3, 852, 426, 0, 5388, 5386, 1, 0,
		0, 0, 5388, 5389, 1, 0, 0, 0, 5389, 5391, 1, 0, 0, 0, 5390, 5392, 3, 954,
		477, 0, 5391, 5390, 1, 0, 0, 0, 5391, 5392, 1, 0, 0, 0, 5392, 649, 1, 0,
		0, 0, 5393, 5394, 5, 150, 0, 0, 5394, 5395, 5, 422, 0, 0, 5395, 5397, 3,
		900, 450, 0, 5396, 5398, 3, 824, 412, 0, 5397, 5396, 1, 0, 0, 0, 5397,
		5398, 1, 0, 0, 0, 5398, 5399, 1, 0, 0, 0, 5399, 5400, 5, 440, 0, 0, 5400,
		5404, 3, 976, 488, 0, 5401, 5402, 5, 480, 0, 0, 5402, 5403, 7, 12, 0, 0,
		5403, 5405, 5, 269, 0, 0, 5404, 5401, 1, 0, 0, 0, 5404, 5405, 1, 0, 0,
		0, 5405, 5407, 1, 0, 0, 0, 5406, 5408, 3, 954, 477, 0, 5407, 5406, 1, 0,
		0, 0, 5407, 5408, 1, 0, 0, 0, 5408, 5410, 1, 0, 0, 0, 5409, 5411, 3, 468,
		234, 0, 5410, 5409, 1, 0, 0, 0, 5410, 5411, 1, 0, 0, 0, 5411, 651, 1, 0,
		0, 0, 5412, 5413, 5, 57, 0, 0, 5413, 5416, 5, 150, 0, 0, 5414, 5415, 7,
		1, 0, 0, 5415, 5417, 3, 1012, 506, 0, 5416, 5414, 1, 0, 0, 0, 5416, 5417,
		1, 0, 0, 0, 5417, 5422, 1, 0, 0, 0, 5418, 5419, 5, 240, 0, 0, 5419, 5423,
		3, 976, 488, 0, 5420, 5421, 5, 478, 0, 0, 5421, 5423, 3, 852, 426, 0, 5422,
		5418, 1, 0, 0, 0, 5422, 5420, 1, 0, 0, 0, 5422, 5423, 1, 0, 0, 0, 5423,
		653, 1, 0, 0, 0, 5424, 5425, 5, 401, 0, 0, 5425, 5428, 5, 150, 0, 0, 5426,
		5427, 7, 1, 0, 0, 5427, 5429, 3, 1012, 506, 0, 5428, 5426, 1, 0, 0, 0,
		5428, 5429, 1, 0, 0, 0, 5429, 5434, 1, 0, 0, 0, 5430, 5431, 5, 240, 0,
		0, 5431, 5435, 3, 976, 488, 0, 5432, 5433, 5, 478, 0, 0, 5433, 5435, 3,
		852, 426, 0, 5434, 5430, 1, 0, 0, 0, 5434, 5432, 1, 0, 0, 0, 5434, 5435,
		1, 0, 0, 0, 5435, 5446, 1, 0, 0, 0, 5436, 5437, 5, 298, 0, 0, 5437, 5438,
		5, 55, 0, 0, 5438, 5443, 3, 770, 385, 0, 5439, 5440, 5, 3, 0, 0, 5440,
		5442, 3, 770, 385, 0, 5441, 5439, 1, 0, 0, 0, 5442, 5445, 1, 0, 0, 0, 5443,
		5441, 1, 0, 0, 0, 5443, 5444, 1, 0, 0, 0, 5444, 5447, 1, 0, 0, 0, 5445,
		5443, 1, 0, 0, 0, 5446, 5436, 1, 0, 0, 0, 5446, 5447, 1, 0, 0, 0, 5447,
		5449, 1, 0, 0, 0, 5448, 5450, 3, 774, 387, 0, 5449, 5448, 1, 0, 0, 0, 5449,
		5450, 1, 0, 0, 0, 5450, 655, 1, 0, 0, 0, 5451, 5452, 5, 209, 0, 0, 5452,
		5453, 5, 313, 0, 0, 5453, 5454, 5, 172, 0, 0, 5454, 5456, 3, 1026, 513,
		0, 5455, 5457, 3, 954, 477, 0, 5456, 5455, 1, 0, 0, 0, 5456, 5457, 1, 0,
		0, 0, 5457, 657, 1, 0, 0, 0, 5458, 5459, 5, 452, 0, 0, 5459, 5460, 5, 313,
		0, 0, 5460, 5461, 3, 1026, 513, 0, 5461, 659, 1, 0, 0, 0, 5462, 5463, 5,
		90, 0, 0, 5463, 5464, 5, 158, 0, 0, 5464, 5467, 3, 976, 488, 0, 5465, 5466,
		7, 1, 0, 0, 5466, 5468, 3, 1012, 506, 0, 5467, 5465, 1, 0, 0, 0, 5467,
		5468, 1, 0, 0, 0, 5468, 5469, 1, 0, 0, 0, 5469, 5470, 3, 954, 477, 0, 5470,
		661, 1, 0, 0, 0, 5471, 5472, 5, 132, 0, 0, 5472, 5473, 5, 158, 0, 0, 5473,
		5476, 3, 976, 488, 0, 5474, 5475, 7, 1, 0, 0, 5475, 5477, 3, 1012, 506,
		0, 5476, 5474, 1, 0, 0, 0, 5476, 5477, 1, 0, 0, 0, 5477, 5478, 1, 0, 0,
		0, 5478, 5479, 3, 954, 477, 0, 5479, 663, 1, 0, 0, 0, 5480, 5481, 5, 401,
		0, 0, 5481, 5484, 5, 158, 0, 0, 5482, 5483, 7, 1, 0, 0, 5483, 5485, 3,
		1012, 506, 0, 5484, 5482, 1, 0, 0, 0, 5484, 5485, 1, 0, 0, 0, 5485, 665,
		1, 0, 0, 0, 5486, 5487, 5, 90, 0, 0, 5487, 5488, 3, 70, 35, 0, 5488, 5489,
		5, 315, 0, 0, 5489, 5490, 3, 72, 36, 0, 5490, 5492, 3, 1012, 506, 0, 5491,
		5493, 3, 954, 477, 0, 5492, 5491, 1, 0, 0, 0, 5492, 5493, 1, 0, 0, 0, 5493,
		5494, 1, 0, 0, 0, 5494, 5495, 5, 27, 0, 0, 5495, 5496, 3, 352, 176, 0,
		5496, 667, 1, 0, 0, 0, 5497, 5498, 5, 132, 0, 0, 5498, 5501, 5, 315, 0,
		0, 5499, 5500, 5, 197, 0, 0, 5500, 5502, 5, 148, 0, 0, 5501, 5499, 1, 0,
		0, 0, 5501, 5502, 1, 0, 0, 0, 5502, 5503, 1, 0, 0, 0, 5503, 5504, 3, 1012,
		506, 0, 5504, 669, 1, 0, 0, 0, 5505, 5515, 5, 416, 0, 0, 5506, 5515, 5,
		364, 0, 0, 5507, 5508, 5, 368, 0, 0, 5508, 5515, 5, 18, 0, 0, 5509, 5510,
		5, 368, 0, 0, 5510, 5511, 5, 158, 0, 0, 5511, 5515, 3, 976, 488, 0, 5512,
		5513, 5, 396, 0, 0, 5513, 5515, 3, 958, 479, 0, 5514, 5505, 1, 0, 0, 0,
		5514, 5506, 1, 0, 0, 0, 5514, 5507, 1, 0, 0, 0, 5514, 5509, 1, 0, 0, 0,
		5514, 5512, 1, 0, 0, 0, 5515, 671, 1, 0, 0, 0, 5516, 5517, 5, 19, 0, 0,
		5517, 5518, 5, 315, 0, 0, 5518, 5519, 3, 1012, 506, 0, 5519, 5520, 3, 670,
		335, 0, 5520, 673, 1, 0, 0, 0, 5521, 5522, 7, 8, 0, 0, 5522, 5523, 5, 315,
		0, 0, 5523, 5524, 3, 1012, 506, 0, 5524, 675, 1, 0, 0, 0, 5525, 5526, 5,
		401, 0, 0, 5526, 5533, 5, 316, 0, 0, 5527, 5528, 5, 240, 0, 0, 5528, 5534,
		3, 976, 488, 0, 5529, 5530, 5, 478, 0, 0, 5530, 5534, 3, 852, 426, 0, 5531,
		5532, 5, 172, 0, 0, 5532, 5534, 3, 1012, 506, 0, 5533, 5527, 1, 0, 0, 0,
		5533, 5529, 1, 0, 0, 0, 5533, 5531, 1, 0, 0, 0, 5533, 5534, 1, 0, 0, 0,
		5534, 5545, 1, 0, 0, 0, 5535, 5536, 5, 298, 0, 0, 5536, 5537, 5, 55, 0,
		0, 5537, 5542, 3, 770, 385, 0, 5538, 5539, 5, 3, 0, 0, 5539, 5541, 3, 770,
		385, 0, 5540, 5538, 1, 0, 0, 0, 5541, 5544, 1, 0, 0, 0, 5542, 5540, 1,
		0, 0, 0, 5542, 5543, 1, 0, 0, 0, 5543, 5546, 1, 0, 0, 0, 5544, 5542, 1,
		0, 0, 0, 5545, 5535, 1, 0, 0, 0, 5545, 5546, 1, 0, 0, 0, 5546, 5548, 1,
		0, 0, 0, 5547, 5549, 3, 774, 387, 0, 5548, 5547, 1, 0, 0, 0, 5548, 5549,
		1, 0, 0, 0, 5549, 677, 1, 0, 0, 0, 5550, 5551, 5, 396, 0, 0, 5551, 5556,
		3, 680, 340, 0, 5552, 5553, 5, 3, 0, 0, 5553, 5555, 3, 680, 340, 0, 5554,
		5552, 1, 0, 0, 0, 5555, 5558, 1, 0, 0, 0, 5556, 5554, 1, 0, 0, 0, 5556,
		5557, 1, 0, 0, 0, 5557, 679, 1, 0, 0, 0, 5558, 5556, 1, 0, 0, 0, 5559,
		5560, 5, 64, 0, 0, 5560, 5565, 5, 396, 0, 0, 5561, 5565, 5, 66, 0, 0, 5562,
		5563, 5, 65, 0, 0, 5563, 5565, 5, 396, 0, 0, 5564, 5559, 1, 0, 0, 0, 5564,
		5561, 1, 0, 0, 0, 5564, 5562, 1, 0, 0, 0, 5565, 5568, 1, 0, 0, 0, 5566,
		5569, 3, 1026, 513, 0, 5567, 5569, 5, 117, 0, 0, 5568, 5566, 1, 0, 0, 0,
		5568, 5567, 1, 0, 0, 0, 5569, 5625, 1, 0, 0, 0, 5570, 5573, 5, 274, 0,
		0, 5571, 5574, 3, 1026, 513, 0, 5572, 5574, 5, 117, 0, 0, 5573, 5571, 1,
		0, 0, 0, 5573, 5572, 1, 0, 0, 0, 5574, 5580, 1, 0, 0, 0, 5575, 5578, 5,
		74, 0, 0, 5576, 5579, 3, 1026, 513, 0, 5577, 5579, 5, 117, 0, 0, 5578,
		5576, 1, 0, 0, 0, 5578, 5577, 1, 0, 0, 0, 5579, 5581, 1, 0, 0, 0, 5580,
		5575, 1, 0, 0, 0, 5580, 5581, 1, 0, 0, 0, 5581, 5625, 1, 0, 0, 0, 5582,
		5583, 5, 305, 0, 0, 5583, 5590, 5, 492, 0, 0, 5584, 5591, 3, 976, 488,
		0, 5585, 5586, 5, 305, 0, 0, 5586, 5587, 5, 2, 0, 0, 5587, 5588, 3, 976,
		488, 0, 5588, 5589, 5, 4, 0, 0, 5589, 5591, 1, 0, 0, 0, 5590, 5584, 1,
		0, 0, 0, 5590, 5585, 1, 0, 0, 0, 5591, 5625, 1, 0, 0, 0, 5592, 5593, 5,
		305, 0, 0, 5593, 5594, 5, 168, 0, 0, 5594, 5595, 3, 1032, 516, 0, 5595,
		5602, 5, 492, 0, 0, 5596, 5603, 3, 976, 488, 0, 5597, 5598, 5, 305, 0,
		0, 5598, 5599, 5, 2, 0, 0, 5599, 5600, 3, 976, 488, 0, 5600, 5601, 5, 4,
		0, 0, 5601, 5603, 1, 0, 0, 0, 5602, 5596, 1, 0, 0, 0, 5602, 5597, 1, 0,
		0, 0, 5603, 5625, 1, 0, 0, 0, 5604, 5605, 3, 874, 437, 0, 5605, 5606, 5,
		492, 0, 0, 5606, 5607, 3, 852, 426, 0, 5607, 5625, 1, 0, 0, 0, 5608, 5610,
		3, 968, 484, 0, 5609, 5608, 1, 0, 0, 0, 5609, 5610, 1, 0, 0, 0, 5610, 5611,
		1, 0, 0, 0, 5611, 5612, 3, 1018, 509, 0, 5612, 5613, 5, 492, 0, 0, 5613,
		5614, 3, 690, 345, 0, 5614, 5625, 1, 0, 0, 0, 5615, 5616, 3, 876, 438,
		0, 5616, 5617, 5, 492, 0, 0, 5617, 5618, 3, 690, 345, 0, 5618, 5625, 1,
		0, 0, 0, 5619, 5621, 3, 968, 484, 0, 5620, 5619, 1, 0, 0, 0, 5620, 5621,
		1, 0, 0, 0, 5621, 5622, 1, 0, 0, 0, 5622, 5623, 5, 438, 0, 0, 5623, 5625,
		3, 682, 341, 0, 5624, 5564, 1, 0, 0, 0, 5624, 5570, 1, 0, 0, 0, 5624, 5582,
		1, 0, 0, 0, 5624, 5592, 1, 0, 0, 0, 5624, 5604, 1, 0, 0, 0, 5624, 5609,
		1, 0, 0, 0, 5624, 5615, 1, 0, 0, 0, 5624, 5620, 1, 0, 0, 0, 5625, 681,
		1, 0, 0, 0, 5626, 5637, 3, 684, 342, 0, 5627, 5637, 3, 686, 343, 0, 5628,
		5629, 3, 684, 342, 0, 5629, 5630, 5, 3, 0, 0, 5630, 5631, 3, 686, 343,
		0, 5631, 5637, 1, 0, 0, 0, 5632, 5633, 3, 686, 343, 0, 5633, 5634, 5, 3,
		0, 0, 5634, 5635, 3, 684, 342, 0, 5635, 5637, 1, 0, 0, 0, 5636, 5626, 1,
		0, 0, 0, 5636, 5627, 1, 0, 0, 0, 5636, 5628, 1, 0, 0, 0, 5636, 5632, 1,
		0, 0, 0, 5637, 683, 1, 0, 0, 0, 5638, 5639, 5, 345, 0, 0, 5639, 5643, 5,
		291, 0, 0, 5640, 5641, 5, 345, 0, 0, 5641, 5643, 5, 482, 0, 0, 5642, 5638,
		1, 0, 0, 0, 5642, 5640, 1, 0, 0, 0, 5643, 685, 1, 0, 0, 0, 5644, 5645,
		5, 223, 0, 0, 5645, 5646, 5, 239, 0, 0, 5646, 5647, 3, 688, 344, 0, 5647,
		687, 1, 0, 0, 0, 5648, 5649, 5, 345, 0, 0, 5649, 5656, 5, 449, 0, 0, 5650,
		5651, 5, 345, 0, 0, 5651, 5656, 5, 80, 0, 0, 5652, 5653, 5, 355, 0, 0,
		5653, 5656, 5, 345, 0, 0, 5654, 5656, 5, 394, 0, 0, 5655, 5648, 1, 0, 0,
		0, 5655, 5650, 1, 0, 0, 0, 5655, 5652, 1, 0, 0, 0, 5655, 5654, 1, 0, 0,
		0, 5656, 689, 1, 0, 0, 0, 5657, 5662, 5, 117, 0, 0, 5658, 5662, 5, 290,
		0, 0, 5659, 5662, 5, 18, 0, 0, 5660, 5662, 3, 852, 426, 0, 5661, 5657,
		1, 0, 0, 0, 5661, 5658, 1, 0, 0, 0, 5661, 5659, 1, 0, 0, 0, 5661, 5660,
		1, 0, 0, 0, 5662, 691, 1, 0, 0, 0, 5663, 5664, 5, 396, 0, 0, 5664, 5667,
		5, 333, 0, 0, 5665, 5666, 5, 168, 0, 0, 5666, 5668, 3, 976, 488, 0, 5667,
		5665, 1, 0, 0, 0, 5667, 5668, 1, 0, 0, 0, 5668, 5669, 1, 0, 0, 0, 5669,
		5670, 3, 960, 480, 0, 5670, 693, 1, 0, 0, 0, 5671, 5676, 3, 1026, 513,
		0, 5672, 5673, 5, 3, 0, 0, 5673, 5675, 3, 1026, 513, 0, 5674, 5672, 1,
		0, 0, 0, 5675, 5678, 1, 0, 0, 0, 5676, 5674, 1, 0, 0, 0, 5676, 5677, 1,
		0, 0, 0, 5677, 695, 1, 0, 0, 0, 5678, 5676, 1, 0, 0, 0, 5679, 5680, 5,
		14, 0, 0, 5680, 5681, 5, 147, 0, 0, 5681, 5682, 5, 290, 0, 0, 5682, 5683,
		7, 29, 0, 0, 5683, 5684, 3, 976, 488, 0, 5684, 697, 1, 0, 0, 0, 5685, 5686,
		5, 484, 0, 0, 5686, 5687, 5, 423, 0, 0, 5687, 5692, 3, 700, 350, 0, 5688,
		5689, 5, 3, 0, 0, 5689, 5691, 3, 700, 350, 0, 5690, 5688, 1, 0, 0, 0, 5691,
		5694, 1, 0, 0, 0, 5692, 5690, 1, 0, 0, 0, 5692, 5693, 1, 0, 0, 0, 5693,
		5698, 1, 0, 0, 0, 5694, 5692, 1, 0, 0, 0, 5695, 5696, 5, 485, 0, 0, 5696,
		5698, 5, 423, 0, 0, 5697, 5685, 1, 0, 0, 0, 5697, 5695, 1, 0, 0, 0, 5698,
		699, 1, 0, 0, 0, 5699, 5704, 3, 1018, 509, 0, 5700, 5702, 5, 27, 0, 0,
		5701, 5700, 1, 0, 0, 0, 5701, 5702, 1, 0, 0, 0, 5702, 5703, 1, 0, 0, 0,
		5703, 5705, 3, 1018, 509, 0, 5704, 5701, 1, 0, 0, 0, 5704, 5705, 1, 0,
		0, 0, 5705, 5706, 1, 0, 0, 0, 5706, 5707, 3, 702, 351, 0, 5707, 701, 1,
		0, 0, 0, 5708, 5710, 5, 345, 0, 0, 5709, 5711, 5, 244, 0, 0, 5710, 5709,
		1, 0, 0, 0, 5710, 5711, 1, 0, 0, 0, 5711, 5717, 1, 0, 0, 0, 5712, 5714,
		5, 486, 0, 0, 5713, 5712, 1, 0, 0, 0, 5713, 5714, 1, 0, 0, 0, 5714, 5715,
		1, 0, 0, 0, 5715, 5717, 5, 482, 0, 0, 5716, 5708, 1, 0, 0, 0, 5716, 5713,
		1, 0, 0, 0, 5717, 703, 1, 0, 0, 0, 5718, 5719, 5, 19, 0, 0, 5719, 5720,
		5, 312, 0, 0, 5720, 5721, 5, 15, 0, 0, 5721, 5722, 5, 13, 0, 0, 5722, 5723,
		3, 752, 376, 0, 5723, 705, 1, 0, 0, 0, 5724, 5725, 5, 445, 0, 0, 5725,
		5726, 5, 312, 0, 0, 5726, 5727, 5, 15, 0, 0, 5727, 707, 1, 0, 0, 0, 5728,
		5729, 5, 19, 0, 0, 5729, 5730, 5, 312, 0, 0, 5730, 5731, 5, 15, 0, 0, 5731,
		5732, 5, 132, 0, 0, 5732, 5733, 3, 976, 488, 0, 5733, 709, 1, 0, 0, 0,
		5734, 5735, 5, 401, 0, 0, 5735, 5736, 5, 312, 0, 0, 5736, 5737, 5, 15,
		0, 0, 5737, 711, 1, 0, 0, 0, 5738, 5739, 5, 90, 0, 0, 5739, 5743, 5, 473,
		0, 0, 5740, 5741, 5, 197, 0, 0, 5741, 5742, 5, 281, 0, 0, 5742, 5744, 5,
		148, 0, 0, 5743, 5740, 1, 0, 0, 0, 5743, 5744, 1, 0, 0, 0, 5744, 5745,
		1, 0, 0, 0, 5745, 5747, 3, 1026, 513, 0, 5746, 5748, 3, 970, 485, 0, 5747,
		5746, 1, 0, 0, 0, 5747, 5748, 1, 0, 0, 0, 5748, 5750, 1, 0, 0, 0, 5749,
		5751, 3, 954, 477, 0, 5750, 5749, 1, 0, 0, 0, 5750, 5751, 1, 0, 0, 0, 5751,
		713, 1, 0, 0, 0, 5752, 5753, 5, 132, 0, 0, 5753, 5756, 5, 473, 0, 0, 5754,
		5755, 5, 197, 0, 0, 5755, 5757, 5, 148, 0, 0, 5756, 5754, 1, 0, 0, 0, 5756,
		5757, 1, 0, 0, 0, 5757, 5758, 1, 0, 0, 0, 5758, 5759, 3, 1026, 513, 0,
		5759, 715, 1, 0, 0, 0, 5760, 5761, 5, 416, 0, 0, 5761, 5764, 5, 473, 0,
		0, 5762, 5763, 5, 197, 0, 0, 5763, 5765, 5, 148, 0, 0, 5764, 5762, 1, 0,
		0, 0, 5764, 5765, 1, 0, 0, 0, 5765, 5766, 1, 0, 0, 0, 5766, 5767, 3, 1018,
		509, 0, 5767, 717, 1, 0, 0, 0, 5768, 5769, 5, 364, 0, 0, 5769, 5772, 5,
		473, 0, 0, 5770, 5771, 5, 197, 0, 0, 5771, 5773, 5, 148, 0, 0, 5772, 5770,
		1, 0, 0, 0, 5772, 5773, 1, 0, 0, 0, 5773, 5774, 1, 0, 0, 0, 5774, 5775,
		3, 1018, 509, 0, 5775, 719, 1, 0, 0, 0, 5776, 5778, 5, 396, 0, 0, 5777,
		5779, 5, 395, 0, 0, 5778, 5777, 1, 0, 0, 0, 5778, 5779, 1, 0, 0, 0, 5779,
		5780, 1, 0, 0, 0, 5780, 5782, 5, 473, 0, 0, 5781, 5783, 5, 492, 0, 0, 5782,
		5781, 1, 0, 0, 0, 5782, 5783, 1, 0, 0, 0, 5783, 5784, 1, 0, 0, 0, 5784,
		5785, 3, 1026, 513, 0, 5785, 721, 1, 0, 0, 0, 5786, 5787, 5, 401, 0, 0,
		5787, 5790, 5, 474, 0, 0, 5788, 5789, 5, 240, 0, 0, 5789, 5791, 3, 976,
		488, 0, 5790, 5788, 1, 0, 0, 0, 5790, 5791, 1, 0, 0, 0, 5791, 723, 1, 0,
		0, 0, 5792, 5793, 5, 401, 0, 0, 5793, 5794, 7, 30, 0, 0, 5794, 5795, 5,
		172, 0, 0, 5795, 5796, 5, 473, 0, 0, 5796, 5797, 3, 1018, 509, 0, 5797,
		725, 1, 0, 0, 0, 5798, 5799, 5, 401, 0, 0, 5799, 5800, 5, 279, 0, 0, 5800,
		5801, 5, 172, 0, 0, 5801, 5804, 5, 474, 0, 0, 5802, 5803, 5, 240, 0, 0,
		5803, 5805, 3, 976, 488, 0, 5804, 5802, 1, 0, 0, 0, 5804, 5805, 1, 0, 0,
		0, 5805, 5816, 1, 0, 0, 0, 5806, 5807, 5, 401, 0, 0, 5807, 5808, 5, 279,
		0, 0, 5808, 5809, 5, 172, 0, 0, 5809, 5810, 5, 473, 0, 0, 5810, 5813, 3,
		1018, 509, 0, 5811, 5812, 5, 72, 0, 0, 5812, 5814, 3, 1026, 513, 0, 5813,
		5811, 1, 0, 0, 0, 5813, 5814, 1, 0, 0, 0, 5814, 5816, 1, 0, 0, 0, 5815,
		5798, 1, 0, 0, 0, 5815, 5806, 1, 0, 0, 0, 5816, 727, 1, 0, 0, 0, 5817,
		5818, 5, 19, 0, 0, 5818, 5819, 5, 473, 0, 0, 5819, 5820, 3, 1026, 513,
		0, 5820, 5821, 3, 276, 138, 0, 5821, 729, 1, 0, 0, 0, 5822, 5823, 5, 19,
		0, 0, 5823, 5824, 5, 473, 0, 0, 5824, 5825, 3, 1026, 513, 0, 5825, 5826,
		5, 13, 0, 0, 5826, 5830, 5, 72, 0, 0, 5827, 5828, 5, 197, 0, 0, 5828, 5829,
		5, 281, 0, 0, 5829, 5831, 5, 148, 0, 0, 5830, 5827, 1, 0, 0, 0, 5830, 5831,
		1, 0, 0, 0, 5831, 5832, 1, 0, 0, 0, 5832, 5834, 3, 1026, 513, 0, 5833,
		5835, 3, 970, 485, 0, 5834, 5833, 1, 0, 0, 0, 5834, 5835, 1, 0, 0, 0, 5835,
		5837, 1, 0, 0, 0, 5836, 5838, 3, 954, 477, 0, 5837, 5836, 1, 0, 0, 0, 5837,
		5838, 1, 0, 0, 0, 5838, 731, 1, 0, 0, 0, 5839, 5840, 5, 19, 0, 0, 5840,
		5841, 5, 473, 0, 0, 5841, 5842, 3, 1026, 513, 0, 5842, 5843, 5, 132, 0,
		0, 5843, 5846, 5, 72, 0, 0, 5844, 5845, 5, 197, 0, 0, 5845, 5847, 5, 148,
		0, 0, 5846, 5844, 1, 0, 0, 0, 5846, 5847, 1, 0, 0, 0, 5847, 5848, 1, 0,
		0, 0, 5848, 5850, 3, 1026, 513, 0, 5849, 5851, 5, 169, 0, 0, 5850, 5849,
		1, 0, 0, 0, 5850, 5851, 1, 0, 0, 0, 5851, 733, 1, 0, 0, 0, 5852, 5853,
		5, 19, 0, 0, 5853, 5854, 5, 473, 0, 0, 5854, 5855, 3, 1026, 513, 0, 5855,
		5856, 5, 137, 0, 0, 5856, 5857, 5, 72, 0, 0, 5857, 5858, 3, 1026, 513,
		0, 5858, 735, 1, 0, 0, 0, 5859, 5860, 5, 19, 0, 0, 5860, 5861, 5, 473,
		0, 0, 5861, 5862, 3, 1026, 513, 0, 5862, 5863, 5, 127, 0, 0, 5863, 5864,
		5, 72, 0, 0, 5864, 5865, 3, 1026, 513, 0, 5865, 737, 1, 0, 0, 0, 5866,
		5867, 5, 19, 0, 0, 5867, 5868, 5, 473, 0, 0, 5868, 5869, 3, 1026, 513,
		0, 5869, 5870, 5, 270, 0, 0, 5870, 5871, 5, 72, 0, 0, 5871, 5872, 3, 1026,
		513, 0, 5872, 5873, 3, 276, 138, 0, 5873, 739, 1, 0, 0, 0, 5874, 5875,
		5, 406, 0, 0, 5875, 5879, 5, 438, 0, 0, 5876, 5877, 5, 480, 0, 0, 5877,
		5878, 5, 86, 0, 0, 5878, 5880, 5, 403, 0, 0, 5879, 5876, 1, 0, 0, 0, 5879,
		5880, 1, 0, 0, 0, 5880, 5886, 1, 0, 0, 0, 5881, 5883, 5, 40, 0, 0, 5882,
		5884, 5, 481, 0, 0, 5883, 5882, 1, 0, 0, 0, 5883, 5884, 1, 0, 0, 0, 5884,
		5886, 1, 0, 0, 0, 5885, 5874, 1, 0, 0, 0, 5885, 5881, 1, 0, 0, 0, 5886,
		741, 1, 0, 0, 0, 5887, 5889, 5, 79, 0, 0, 5888, 5890, 5, 481, 0, 0, 5889,
		5888, 1, 0, 0, 0, 5889, 5890, 1, 0, 0, 0, 5890, 5896, 1, 0, 0, 0, 5891,
		5893, 5, 21, 0, 0, 5892, 5894, 5, 277, 0, 0, 5893, 5892, 1, 0, 0, 0, 5893,
		5894, 1, 0, 0, 0, 5894, 5895, 1, 0, 0, 0, 5895, 5897, 5, 63, 0, 0, 5896,
		5891, 1, 0, 0, 0, 5896, 5897, 1, 0, 0, 0, 5897, 5902, 1, 0, 0, 0, 5898,
		5900, 5, 277, 0, 0, 5899, 5898, 1, 0, 0, 0, 5899, 5900, 1, 0, 0, 0, 5900,
		5901, 1, 0, 0, 0, 5901, 5903, 5, 351, 0, 0, 5902, 5899, 1, 0, 0, 0, 5902,
		5903, 1, 0, 0, 0, 5903, 743, 1, 0, 0, 0, 5904, 5906, 5, 375, 0, 0, 5905,
		5907, 5, 481, 0, 0, 5906, 5905, 1, 0, 0, 0, 5906, 5907, 1, 0, 0, 0, 5907,
		5913, 1, 0, 0, 0, 5908, 5910, 5, 21, 0, 0, 5909, 5911, 5, 277, 0, 0, 5910,
		5909, 1, 0, 0, 0, 5910, 5911, 1, 0, 0, 0, 5911, 5912, 1, 0, 0, 0, 5912,
		5914, 5, 63, 0, 0, 5913, 5908, 1, 0, 0, 0, 5913, 5914, 1, 0, 0, 0, 5914,
		5919, 1, 0, 0, 0, 5915, 5917, 5, 277, 0, 0, 5916, 5915, 1, 0, 0, 0, 5916,
		5917, 1, 0, 0, 0, 5917, 5918, 1, 0, 0, 0, 5918, 5920, 5, 351, 0, 0, 5919,
		5916, 1, 0, 0, 0, 5919, 5920, 1, 0, 0, 0, 5920, 745, 1, 0, 0, 0, 5921,
		5922, 5, 439, 0, 0, 5922, 5923, 3, 748, 374, 0, 5923, 5924, 3, 750, 375,
		0, 5924, 747, 1, 0, 0, 0, 5925, 5926, 3, 1018, 509, 0, 5926, 749, 1, 0,
		0, 0, 5927, 5929, 9, 0, 0, 0, 5928, 5927, 1, 0, 0, 0, 5929, 5930, 1, 0,
		0, 0, 5930, 5928, 1, 0, 0, 0, 5930, 5931, 1, 0, 0, 0, 5931, 751, 1, 0,
		0, 0, 5932, 5935, 3, 904, 452, 0, 5933, 5935, 3, 906, 453, 0, 5934, 5932,
		1, 0, 0, 0, 5934, 5933, 1, 0, 0, 0, 5934, 5935, 1, 0, 0, 0, 5935, 5936,
		1, 0, 0, 0, 5936, 5938, 3, 754, 377, 0, 5937, 5939, 3, 972, 486, 0, 5938,
		5937, 1, 0, 0, 0, 5938, 5939, 1, 0, 0, 0, 5939, 753, 1, 0, 0, 0, 5940,
		5942, 3, 756, 378, 0, 5941, 5940, 1, 0, 0, 0, 5941, 5942, 1, 0, 0, 0, 5942,
		5943, 1, 0, 0, 0, 5943, 5944, 3, 758, 379, 0, 5944, 755, 1, 0, 0, 0, 5945,
		5946, 5, 480, 0, 0, 5946, 5951, 3, 784, 392, 0, 5947, 5948, 5, 3, 0, 0,
		5948, 5950, 3, 784, 392, 0, 5949, 5947, 1, 0, 0, 0, 5950, 5953, 1, 0, 0,
		0, 5951, 5949, 1, 0, 0, 0, 5951, 5952, 1, 0, 0, 0, 5952, 757, 1, 0, 0,
		0, 5953, 5951, 1, 0, 0, 0, 5954, 5965, 3, 764, 382, 0, 5955, 5956, 5, 298,
		0, 0, 5956, 5957, 5, 55, 0, 0, 5957, 5962, 3, 770, 385, 0, 5958, 5959,
		5, 3, 0, 0, 5959, 5961, 3, 770, 385, 0, 5960, 5958, 1, 0, 0, 0, 5961, 5964,
		1, 0, 0, 0, 5962, 5960, 1, 0, 0, 0, 5962, 5963, 1, 0, 0, 0, 5963, 5966,
		1, 0, 0, 0, 5964, 5962, 1, 0, 0, 0, 5965, 5955, 1, 0, 0, 0, 5965, 5966,
		1, 0, 0, 0, 5966, 5968, 1, 0, 0, 0, 5967, 5969, 3, 774, 387, 0, 5968, 5967,
		1, 0, 0, 0, 5968, 5969, 1, 0, 0, 0, 5969, 759, 1, 0, 0, 0, 5970, 5972,
		5, 168, 0, 0, 5971, 5970, 1, 0, 0, 0, 5971, 5972, 1, 0, 0, 0, 5972, 5973,
		1, 0, 0, 0, 5973, 5974, 3, 762, 381, 0, 5974, 5975, 5, 41, 0, 0, 5975,
		5976, 3, 852, 426, 0, 5976, 5977, 5, 21, 0, 0, 5977, 5978, 3, 852, 426,
		0, 5978, 6003, 1, 0, 0, 0, 5979, 5981, 5, 168, 0, 0, 5980, 5979, 1, 0,
		0, 0, 5980, 5981, 1, 0, 0, 0, 5981, 5982, 1, 0, 0, 0, 5982, 5983, 3, 762,
		381, 0, 5983, 5984, 5, 172, 0, 0, 5984, 5985, 3, 852, 426, 0, 5985, 5986,
		5, 440, 0, 0, 5986, 5987, 3, 852, 426, 0, 5987, 6003, 1, 0, 0, 0, 5988,
		5990, 5, 168, 0, 0, 5989, 5988, 1, 0, 0, 0, 5989, 5990, 1, 0, 0, 0, 5990,
		5991, 1, 0, 0, 0, 5991, 5992, 3, 762, 381, 0, 5992, 5993, 5, 18, 0, 0,
		5993, 6003, 1, 0, 0, 0, 5994, 5996, 5, 168, 0, 0, 5995, 5994, 1, 0, 0,
		0, 5995, 5996, 1, 0, 0, 0, 5996, 5997, 1, 0, 0, 0, 5997, 5998, 3, 762,
		381, 0, 5998, 5999, 5, 27, 0, 0, 5999, 6000, 5, 287, 0, 0, 6000, 6001,
		3, 852, 426, 0, 6001, 6003, 1, 0, 0, 0, 6002, 5971, 1, 0, 0, 0, 6002, 5980,
		1, 0, 0, 0, 6002, 5989, 1, 0, 0, 0, 6002, 5995, 1, 0, 0, 0, 6003, 761,
		1, 0, 0, 0, 6004, 6005, 7, 31, 0, 0, 6005, 763, 1, 0, 0, 0, 6006, 6007,
		6, 382, -1, 0, 6007, 6010, 3, 776, 388, 0, 6008, 6010, 3, 766, 383, 0,
		6009, 6006, 1, 0, 0, 0, 6009, 6008, 1, 0, 0, 0, 6010, 6025, 1, 0, 0, 0,
		6011, 6012, 10, 2, 0, 0, 6012, 6014, 5, 216, 0, 0, 6013, 6015, 3, 786,
		393, 0, 6014, 6013, 1, 0, 0, 0, 6014, 6015, 1, 0, 0, 0, 6015, 6016, 1,
		0, 0, 0, 6016, 6024, 3, 764, 382, 3, 6017, 6018, 10, 1, 0, 0, 6018, 6020,
		7, 32, 0, 0, 6019, 6021, 3, 786, 393, 0, 6020, 6019, 1, 0, 0, 0, 6020,
		6021, 1, 0, 0, 0, 6021, 6022, 1, 0, 0, 0, 6022, 6024, 3, 764, 382, 2, 6023,
		6011, 1, 0, 0, 0, 6023, 6017, 1, 0, 0, 0, 6024, 6027, 1, 0, 0, 0, 6025,
		6023, 1, 0, 0, 0, 6025, 6026, 1, 0, 0, 0, 6026, 765, 1, 0, 0, 0, 6027,
		6025, 1, 0, 0, 0, 6028, 6029, 5, 2, 0, 0, 6029, 6030, 3, 754, 377, 0, 6030,
		6031, 5, 4, 0, 0, 6031, 767, 1, 0, 0, 0, 6032, 6033, 5, 2, 0, 0, 6033,
		6034, 3, 854, 427, 0, 6034, 6035, 5, 4, 0, 0, 6035, 769, 1, 0, 0, 0, 6036,
		6038, 3, 852, 426, 0, 6037, 6039, 7, 33, 0, 0, 6038, 6037, 1, 0, 0, 0,
		6038, 6039, 1, 0, 0, 0, 6039, 6042, 1, 0, 0, 0, 6040, 6041, 5, 283, 0,
		0, 6041, 6043, 7, 34, 0, 0, 6042, 6040, 1, 0, 0, 0, 6042, 6043, 1, 0, 0,
		0, 6043, 771, 1, 0, 0, 0, 6044, 6048, 5, 518, 0, 0, 6045, 6048, 5, 302,
		0, 0, 6046, 6048, 3, 874, 437, 0, 6047, 6044, 1, 0, 0, 0, 6047, 6045, 1,
		0, 0, 0, 6047, 6046, 1, 0, 0, 0, 6048, 773, 1, 0, 0, 0, 6049, 6050, 5,
		241, 0, 0, 6050, 6053, 3, 772, 386, 0, 6051, 6052, 5, 289, 0, 0, 6052,
		6054, 3, 772, 386, 0, 6053, 6051, 1, 0, 0, 0, 6053, 6054, 1, 0, 0, 0, 6054,
		6061, 1, 0, 0, 0, 6055, 6056, 5, 241, 0, 0, 6056, 6057, 3, 772, 386, 0,
		6057, 6058, 5, 3, 0, 0, 6058, 6059, 3, 772, 386, 0, 6059, 6061, 1, 0, 0,
		0, 6060, 6049, 1, 0, 0, 0, 6060, 6055, 1, 0, 0, 0, 6061, 775, 1, 0, 0,
		0, 6062, 6064, 5, 391, 0, 0, 6063, 6065, 3, 786, 393, 0, 6064, 6063, 1,
		0, 0, 0, 6064, 6065, 1, 0, 0, 0, 6065, 6066, 1, 0, 0, 0, 6066, 6071, 3,
		788, 394, 0, 6067, 6068, 5, 3, 0, 0, 6068, 6070, 3, 788, 394, 0, 6069,
		6067, 1, 0, 0, 0, 6070, 6073, 1, 0, 0, 0, 6071, 6069, 1, 0, 0, 0, 6071,
		6072, 1, 0, 0, 0, 6072, 6074, 1, 0, 0, 0, 6073, 6071, 1, 0, 0, 0, 6074,
		6077, 3, 778, 389, 0, 6075, 6076, 5, 478, 0, 0, 6076, 6078, 3, 852, 426,
		0, 6077, 6075, 1, 0, 0, 0, 6077, 6078, 1, 0, 0, 0, 6078, 6082, 1, 0, 0,
		0, 6079, 6080, 5, 181, 0, 0, 6080, 6081, 5, 55, 0, 0, 6081, 6083, 3, 780,
		390, 0, 6082, 6079, 1, 0, 0, 0, 6082, 6083, 1, 0, 0, 0, 6083, 6086, 1,
		0, 0, 0, 6084, 6085, 5, 187, 0, 0, 6085, 6087, 3, 852, 426, 0, 6086, 6084,
		1, 0, 0, 0, 6086, 6087, 1, 0, 0, 0, 6087, 6093, 1, 0, 0, 0, 6088, 6089,
		5, 336, 0, 0, 6089, 6090, 3, 788, 394, 0, 6090, 6091, 3, 980, 490, 0, 6091,
		6092, 5, 518, 0, 0, 6092, 6094, 1, 0, 0, 0, 6093, 6088, 1, 0, 0, 0, 6093,
		6094, 1, 0, 0, 0, 6094, 777, 1, 0, 0, 0, 6095, 6096, 5, 172, 0, 0, 6096,
		6098, 3, 792, 396, 0, 6097, 6099, 3, 798, 399, 0, 6098, 6097, 1, 0, 0,
		0, 6098, 6099, 1, 0, 0, 0, 6099, 6101, 1, 0, 0, 0, 6100, 6095, 1, 0, 0,
		0, 6100, 6101, 1, 0, 0, 0, 6101, 6105, 1, 0, 0, 0, 6102, 6103, 5, 172,
		0, 0, 6103, 6105, 5, 133, 0, 0, 6104, 6100, 1, 0, 0, 0, 6104, 6102, 1,
		0, 0, 0, 6105, 779, 1, 0, 0, 0, 6106, 6107, 5, 376, 0, 0, 6107, 6109, 5,
		2, 0, 0, 6108, 6110, 3, 854, 427, 0, 6109, 6108, 1, 0, 0, 0, 6109, 6110,
		1, 0, 0, 0, 6110, 6111, 1, 0, 0, 0, 6111, 6133, 5, 4, 0, 0, 6112, 6113,
		5, 92, 0, 0, 6113, 6115, 5, 2, 0, 0, 6114, 6116, 3, 854, 427, 0, 6115,
		6114, 1, 0, 0, 0, 6115, 6116, 1, 0, 0, 0, 6116, 6117, 1, 0, 0, 0, 6117,
		6133, 5, 4, 0, 0, 6118, 6119, 5, 183, 0, 0, 6119, 6120, 5, 397, 0, 0, 6120,
		6121, 5, 2, 0, 0, 6121, 6126, 3, 782, 391, 0, 6122, 6123, 5, 3, 0, 0, 6123,
		6125, 3, 782, 391, 0, 6124, 6122, 1, 0, 0, 0, 6125, 6128, 1, 0, 0, 0, 6126,
		6124, 1, 0, 0, 0, 6126, 6127, 1, 0, 0, 0, 6127, 6129, 1, 0, 0, 0, 6128,
		6126, 1, 0, 0, 0, 6129, 6130, 5, 4, 0, 0, 6130, 6133, 1, 0, 0, 0, 6131,
		6133, 3, 854, 427, 0, 6132, 6106, 1, 0, 0, 0, 6132, 6112, 1, 0, 0, 0, 6132,
		6118, 1, 0, 0, 0, 6132, 6131, 1, 0, 0, 0, 6133, 781, 1, 0, 0, 0, 6134,
		6136, 5, 2, 0, 0, 6135, 6137, 3, 852, 426, 0, 6136, 6135, 1, 0, 0, 0, 6136,
		6137, 1, 0, 0, 0, 6137, 6142, 1, 0, 0, 0, 6138, 6139, 5, 3, 0, 0, 6139,
		6141, 3, 852, 426, 0, 6140, 6138, 1, 0, 0, 0, 6141, 6144, 1, 0, 0, 0, 6142,
		6140, 1, 0, 0, 0, 6142, 6143, 1, 0, 0, 0, 6143, 6145, 1, 0, 0, 0, 6144,
		6142, 1, 0, 0, 0, 6145, 6146, 5, 4, 0, 0, 6146, 783, 1, 0, 0, 0, 6147,
		6149, 3, 1018, 509, 0, 6148, 6150, 3, 824, 412, 0, 6149, 6148, 1, 0, 0,
		0, 6149, 6150, 1, 0, 0, 0, 6150, 6151, 1, 0, 0, 0, 6151, 6152, 5, 27, 0,
		0, 6152, 6153, 5, 2, 0, 0, 6153, 6154, 3, 754, 377, 0, 6154, 6155, 5, 4,
		0, 0, 6155, 785, 1, 0, 0, 0, 6156, 6157, 7, 35, 0, 0, 6157, 787, 1, 0,
		0, 0, 6158, 6166, 3, 852, 426, 0, 6159, 6161, 5, 27, 0, 0, 6160, 6159,
		1, 0, 0, 0, 6160, 6161, 1, 0, 0, 0, 6161, 6164, 1, 0, 0, 0, 6162, 6165,
		3, 1018, 509, 0, 6163, 6165, 3, 976, 488, 0, 6164, 6162, 1, 0, 0, 0, 6164,
		6163, 1, 0, 0, 0, 6165, 6167, 1, 0, 0, 0, 6166, 6160, 1, 0, 0, 0, 6166,
		6167, 1, 0, 0, 0, 6167, 6179, 1, 0, 0, 0, 6168, 6169, 3, 1012, 506, 0,
		6169, 6170, 5, 1, 0, 0, 6170, 6172, 5, 502, 0, 0, 6171, 6173, 3, 790, 395,
		0, 6172, 6171, 1, 0, 0, 0, 6172, 6173, 1, 0, 0, 0, 6173, 6179, 1, 0, 0,
		0, 6174, 6176, 5, 502, 0, 0, 6175, 6177, 3, 790, 395, 0, 6176, 6175, 1,
		0, 0, 0, 6176, 6177, 1, 0, 0, 0, 6177, 6179, 1, 0, 0, 0, 6178, 6158, 1,
		0, 0, 0, 6178, 6168, 1, 0, 0, 0, 6178, 6174, 1, 0, 0, 0, 6179, 789, 1,
		0, 0, 0, 6180, 6181, 7, 36, 0, 0, 6181, 6182, 5, 2, 0, 0, 6182, 6187, 3,
		1018, 509, 0, 6183, 6184, 5, 3, 0, 0, 6184, 6186, 3, 1018, 509, 0, 6185,
		6183, 1, 0, 0, 0, 6186, 6189, 1, 0, 0, 0, 6187, 6185, 1, 0, 0, 0, 6187,
		6188, 1, 0, 0, 0, 6188, 6190, 1, 0, 0, 0, 6189, 6187, 1, 0, 0, 0, 6190,
		6191, 5, 4, 0, 0, 6191, 791, 1, 0, 0, 0, 6192, 6200, 3, 794, 397, 0, 6193,
		6195, 5, 3, 0, 0, 6194, 6196, 5, 235, 0, 0, 6195, 6194, 1, 0, 0, 0, 6195,
		6196, 1, 0, 0, 0, 6196, 6197, 1, 0, 0, 0, 6197, 6199, 3, 794, 397, 0, 6198,
		6193, 1, 0, 0, 0, 6199, 6202, 1, 0, 0, 0, 6200, 6198, 1, 0, 0, 0, 6200,
		6201, 1, 0, 0, 0, 6201, 793, 1, 0, 0, 0, 6202, 6200, 1, 0, 0, 0, 6203,
		6207, 3, 796, 398, 0, 6204, 6206, 3, 812, 406, 0, 6205, 6204, 1, 0, 0,
		0, 6206, 6209, 1, 0, 0, 0, 6207, 6205, 1, 0, 0, 0, 6207, 6208, 1, 0, 0,
		0, 6208, 6221, 1, 0, 0, 0, 6209, 6207, 1, 0, 0, 0, 6210, 6211, 5, 2, 0,
		0, 6211, 6215, 3, 796, 398, 0, 6212, 6214, 3, 812, 406, 0, 6213, 6212,
		1, 0, 0, 0, 6214, 6217, 1, 0, 0, 0, 6215, 6213, 1, 0, 0, 0, 6215, 6216,
		1, 0, 0, 0, 6216, 6218, 1, 0, 0, 0, 6217, 6215, 1, 0, 0, 0, 6218, 6219,
		5, 4, 0, 0, 6219, 6221, 1, 0, 0, 0, 6220, 6203, 1, 0, 0, 0, 6220, 6210,
		1, 0, 0, 0, 6221, 795, 1, 0, 0, 0, 6222, 6224, 3, 1012, 506, 0, 6223, 6225,
		3, 760, 380, 0, 6224, 6223, 1, 0, 0, 0, 6224, 6225, 1, 0, 0, 0, 6225, 6227,
		1, 0, 0, 0, 6226, 6228, 3, 826, 413, 0, 6227, 6226, 1, 0, 0, 0, 6227, 6228,
		1, 0, 0, 0, 6228, 6230, 1, 0, 0, 0, 6229, 6231, 3, 830, 415, 0, 6230, 6229,
		1, 0, 0, 0, 6230, 6231, 1, 0, 0, 0, 6231, 6233, 1, 0, 0, 0, 6232, 6234,
		3, 840, 420, 0, 6233, 6232, 1, 0, 0, 0, 6233, 6234, 1, 0, 0, 0, 6234, 6236,
		1, 0, 0, 0, 6235, 6237, 3, 804, 402, 0, 6236, 6235, 1, 0, 0, 0, 6236, 6237,
		1, 0, 0, 0, 6237, 6242, 1, 0, 0, 0, 6238, 6240, 5, 27, 0, 0, 6239, 6238,
		1, 0, 0, 0, 6239, 6240, 1, 0, 0, 0, 6240, 6241, 1, 0, 0, 0, 6241, 6243,
		3, 1018, 509, 0, 6242, 6239, 1, 0, 0, 0, 6242, 6243, 1, 0, 0, 0, 6243,
		6245, 1, 0, 0, 0, 6244, 6246, 3, 818, 409, 0, 6245, 6244, 1, 0, 0, 0, 6245,
		6246, 1, 0, 0, 0, 6246, 6249, 1, 0, 0, 0, 6247, 6248, 5, 488, 0, 0, 6248,
		6250, 3, 976, 488, 0, 6249, 6247, 1, 0, 0, 0, 6249, 6250, 1, 0, 0, 0, 6250,
		6326, 1, 0, 0, 0, 6251, 6252, 5, 2, 0, 0, 6252, 6253, 5, 462, 0, 0, 6253,
		6258, 3, 768, 384, 0, 6254, 6255, 5, 3, 0, 0, 6255, 6257, 3, 768, 384,
		0, 6256, 6254, 1, 0, 0, 0, 6257, 6260, 1, 0, 0, 0, 6258, 6256, 1, 0, 0,
		0, 6258, 6259, 1, 0, 0, 0, 6259, 6261, 1, 0, 0, 0, 6260, 6258, 1, 0, 0,
		0, 6261, 6269, 5, 4, 0, 0, 6262, 6264, 5, 27, 0, 0, 6263, 6262, 1, 0, 0,
		0, 6263, 6264, 1, 0, 0, 0, 6264, 6265, 1, 0, 0, 0, 6265, 6267, 3, 1018,
		509, 0, 6266, 6268, 3, 824, 412, 0, 6267, 6266, 1, 0, 0, 0, 6267, 6268,
		1, 0, 0, 0, 6268, 6270, 1, 0, 0, 0, 6269, 6263, 1, 0, 0, 0, 6269, 6270,
		1, 0, 0, 0, 6270, 6326, 1, 0, 0, 0, 6271, 6279, 3, 766, 383, 0, 6272, 6274,
		5, 27, 0, 0, 6273, 6272, 1, 0, 0, 0, 6273, 6274, 1, 0, 0, 0, 6274, 6275,
		1, 0, 0, 0, 6275, 6277, 3, 1018, 509, 0, 6276, 6278, 3, 824, 412, 0, 6277,
		6276, 1, 0, 0, 0, 6277, 6278, 1, 0, 0, 0, 6278, 6280, 1, 0, 0, 0, 6279,
		6273, 1, 0, 0, 0, 6279, 6280, 1, 0, 0, 0, 6280, 6326, 1, 0, 0, 0, 6281,
		6282, 3, 1012, 506, 0, 6282, 6283, 5, 2, 0, 0, 6283, 6284, 3, 854, 427,
		0, 6284, 6292, 5, 4, 0, 0, 6285, 6287, 5, 27, 0, 0, 6286, 6285, 1, 0, 0,
		0, 6286, 6287, 1, 0, 0, 0, 6287, 6288, 1, 0, 0, 0, 6288, 6290, 3, 1018,
		509, 0, 6289, 6291, 3, 824, 412, 0, 6290, 6289, 1, 0, 0, 0, 6290, 6291,
		1, 0, 0, 0, 6291, 6293, 1, 0, 0, 0, 6292, 6286, 1, 0, 0, 0, 6292, 6293,
		1, 0, 0, 0, 6293, 6326, 1, 0, 0, 0, 6294, 6295, 5, 422, 0, 0, 6295, 6296,
		5, 2, 0, 0, 6296, 6297, 3, 1012, 506, 0, 6297, 6298, 5, 2, 0, 0, 6298,
		6299, 3, 806, 403, 0, 6299, 6300, 5, 4, 0, 0, 6300, 6308, 5, 4, 0, 0, 6301,
		6303, 5, 27, 0, 0, 6302, 6301, 1, 0, 0, 0, 6302, 6303, 1, 0, 0, 0, 6303,
		6304, 1, 0, 0, 0, 6304, 6306, 3, 1018, 509, 0, 6305, 6307, 3, 824, 412,
		0, 6306, 6305, 1, 0, 0, 0, 6306, 6307, 1, 0, 0, 0, 6307, 6309, 1, 0, 0,
		0, 6308, 6302, 1, 0, 0, 0, 6308, 6309, 1, 0, 0, 0, 6309, 6326, 1, 0, 0,
		0, 6310, 6311, 5, 159, 0, 0, 6311, 6319, 3, 958, 479, 0, 6312, 6314, 5,
		27, 0, 0, 6313, 6312, 1, 0, 0, 0, 6313, 6314, 1, 0, 0, 0, 6314, 6315, 1,
		0, 0, 0, 6315, 6317, 3, 1018, 509, 0, 6316, 6318, 3, 824, 412, 0, 6317,
		6316, 1, 0, 0, 0, 6317, 6318, 1, 0, 0, 0, 6318, 6320, 1, 0, 0, 0, 6319,
		6313, 1, 0, 0, 0, 6319, 6320, 1, 0, 0, 0, 6320, 6326, 1, 0, 0, 0, 6321,
		6322, 5, 2, 0, 0, 6322, 6323, 3, 792, 396, 0, 6323, 6324, 5, 4, 0, 0, 6324,
		6326, 1, 0, 0, 0, 6325, 6222, 1, 0, 0, 0, 6325, 6251, 1, 0, 0, 0, 6325,
		6271, 1, 0, 0, 0, 6325, 6281, 1, 0, 0, 0, 6325, 6294, 1, 0, 0, 0, 6325,
		6310, 1, 0, 0, 0, 6325, 6321, 1, 0, 0, 0, 6326, 797, 1, 0, 0, 0, 6327,
		6328, 5, 317, 0, 0, 6328, 6329, 5, 2, 0, 0, 6329, 6334, 3, 800, 400, 0,
		6330, 6331, 5, 3, 0, 0, 6331, 6333, 3, 800, 400, 0, 6332, 6330, 1, 0, 0,
		0, 6333, 6336, 1, 0, 0, 0, 6334, 6332, 1, 0, 0, 0, 6334, 6335, 1, 0, 0,
		0, 6335, 6337, 1, 0, 0, 0, 6336, 6334, 1, 0, 0, 0, 6337, 6340, 5, 168,
		0, 0, 6338, 6341, 3, 1018, 509, 0, 6339, 6341, 3, 1024, 512, 0, 6340, 6338,
		1, 0, 0, 0, 6340, 6339, 1, 0, 0, 0, 6341, 6342, 1, 0, 0, 0, 6342, 6343,
		5, 202, 0, 0, 6343, 6344, 5, 2, 0, 0, 6344, 6349, 3, 802, 401, 0, 6345,
		6346, 5, 3, 0, 0, 6346, 6348, 3, 802, 401, 0, 6347, 6345, 1, 0, 0, 0, 6348,
		6351, 1, 0, 0, 0, 6349, 6347, 1, 0, 0, 0, 6349, 6350, 1, 0, 0, 0, 6350,
		6352, 1, 0, 0, 0, 6351, 6349, 1, 0, 0, 0, 6352, 6353, 5, 4, 0, 0, 6353,
		6354, 5, 4, 0, 0, 6354, 799, 1, 0, 0, 0, 6355, 6363, 3, 870, 435, 0, 6356,
		6358, 5, 27, 0, 0, 6357, 6356, 1, 0, 0, 0, 6357, 6358, 1, 0, 0, 0, 6358,
		6361, 1, 0, 0, 0, 6359, 6362, 3, 1018, 509, 0, 6360, 6362, 3, 976, 488,
		0, 6361, 6359, 1, 0, 0, 0, 6361, 6360, 1, 0, 0, 0, 6362, 6364, 1, 0, 0,
		0, 6363, 6357, 1, 0, 0, 0, 6363, 6364, 1, 0, 0, 0, 6364, 801, 1, 0, 0,
		0, 6365, 6368, 3, 868, 434, 0, 6366, 6368, 3, 928, 464, 0, 6367, 6365,
		1, 0, 0, 0, 6367, 6366, 1, 0, 0, 0, 6368, 6376, 1, 0, 0, 0, 6369, 6371,
		5, 27, 0, 0, 6370, 6369, 1, 0, 0, 0, 6370, 6371, 1, 0, 0, 0, 6371, 6374,
		1, 0, 0, 0, 6372, 6375, 3, 1018, 509, 0, 6373, 6375, 3, 976, 488, 0, 6374,
		6372, 1, 0, 0, 0, 6374, 6373, 1, 0, 0, 0, 6375, 6377, 1, 0, 0, 0, 6376,
		6370, 1, 0, 0, 0, 6376, 6377, 1, 0, 0, 0, 6377, 803, 1, 0, 0, 0, 6378,
		6380, 5, 384, 0, 0, 6379, 6381, 3, 958, 479, 0, 6380, 6379, 1, 0, 0, 0,
		6380, 6381, 1, 0, 0, 0, 6381, 805, 1, 0, 0, 0, 6382, 6385, 3, 854, 427,
		0, 6383, 6385, 3, 808, 404, 0, 6384, 6382, 1, 0, 0, 0, 6384, 6383, 1, 0,
		0, 0, 6385, 807, 1, 0, 0, 0, 6386, 6391, 3, 810, 405, 0, 6387, 6388, 5,
		3, 0, 0, 6388, 6390, 3, 810, 405, 0, 6389, 6387, 1, 0, 0, 0, 6390, 6393,
		1, 0, 0, 0, 6391, 6389, 1, 0, 0, 0, 6391, 6392, 1, 0, 0, 0, 6392, 809,
		1, 0, 0, 0, 6393, 6391, 1, 0, 0, 0, 6394, 6395, 3, 1018, 509, 0, 6395,
		6396, 5, 5, 0, 0, 6396, 6397, 3, 852, 426, 0, 6397, 811, 1, 0, 0, 0, 6398,
		6400, 3, 814, 407, 0, 6399, 6401, 3, 818, 409, 0, 6400, 6399, 1, 0, 0,
		0, 6400, 6401, 1, 0, 0, 0, 6401, 6403, 1, 0, 0, 0, 6402, 6404, 5, 235,
		0, 0, 6403, 6402, 1, 0, 0, 0, 6403, 6404, 1, 0, 0, 0, 6404, 6405, 1, 0,
		0, 0, 6405, 6407, 3, 796, 398, 0, 6406, 6408, 3, 822, 411, 0, 6407, 6406,
		1, 0, 0, 0, 6407, 6408, 1, 0, 0, 0, 6408, 6420, 1, 0, 0, 0, 6409, 6411,
		3, 816, 408, 0, 6410, 6412, 3, 818, 409, 0, 6411, 6410, 1, 0, 0, 0, 6411,
		6412, 1, 0, 0, 0, 6412, 6414, 1, 0, 0, 0, 6413, 6415, 5, 235, 0, 0, 6414,
		6413, 1, 0, 0, 0, 6414, 6415, 1, 0, 0, 0, 6415, 6416, 1, 0, 0, 0, 6416,
		6417, 3, 796, 398, 0, 6417, 6418, 3, 822, 411, 0, 6418, 6420, 1, 0, 0,
		0, 6419, 6398, 1, 0, 0, 0, 6419, 6409, 1, 0, 0, 0, 6420, 813, 1, 0, 0,
		0, 6421, 6428, 5, 225, 0, 0, 6422, 6423, 5, 208, 0, 0, 6423, 6428, 5, 225,
		0, 0, 6424, 6428, 5, 91, 0, 0, 6425, 6426, 5, 91, 0, 0, 6426, 6428, 5,
		225, 0, 0, 6427, 6421, 1, 0, 0, 0, 6427, 6422, 1, 0, 0, 0, 6427, 6424,
		1, 0, 0, 0, 6427, 6425, 1, 0, 0, 0, 6428, 815, 1, 0, 0, 0, 6429, 6430,
		5, 237, 0, 0, 6430, 6457, 5, 225, 0, 0, 6431, 6432, 5, 371, 0, 0, 6432,
		6457, 5, 225, 0, 0, 6433, 6434, 5, 175, 0, 0, 6434, 6457, 5, 225, 0, 0,
		6435, 6436, 5, 237, 0, 0, 6436, 6437, 5, 299, 0, 0, 6437, 6457, 5, 225,
		0, 0, 6438, 6439, 5, 371, 0, 0, 6439, 6440, 5, 299, 0, 0, 6440, 6457, 5,
		225, 0, 0, 6441, 6442, 5, 175, 0, 0, 6442, 6443, 5, 299, 0, 0, 6443, 6457,
		5, 225, 0, 0, 6444, 6445, 5, 237, 0, 0, 6445, 6446, 5, 392, 0, 0, 6446,
		6457, 5, 225, 0, 0, 6447, 6448, 5, 371, 0, 0, 6448, 6449, 5, 392, 0, 0,
		6449, 6457, 5, 225, 0, 0, 6450, 6451, 5, 237, 0, 0, 6451, 6452, 5, 22,
		0, 0, 6452, 6457, 5, 225, 0, 0, 6453, 6454, 5, 371, 0, 0, 6454, 6455, 5,
		22, 0, 0, 6455, 6457, 5, 225, 0, 0, 6456, 6429, 1, 0, 0, 0, 6456, 6431,
		1, 0, 0, 0, 6456, 6433, 1, 0, 0, 0, 6456, 6435, 1, 0, 0, 0, 6456, 6438,
		1, 0, 0, 0, 6456, 6441, 1, 0, 0, 0, 6456, 6444, 1, 0, 0, 0, 6456, 6447,
		1, 0, 0, 0, 6456, 6450, 1, 0, 0, 0, 6456, 6453, 1, 0, 0, 0, 6457, 817,
		1, 0, 0, 0, 6458, 6459, 5, 6, 0, 0, 6459, 6464, 3, 1018, 509, 0, 6460,
		6461, 5, 3, 0, 0, 6461, 6463, 3, 1018, 509, 0, 6462, 6460, 1, 0, 0, 0,
		6463, 6466, 1, 0, 0, 0, 6464, 6462, 1, 0, 0, 0, 6464, 6465, 1, 0, 0, 0,
		6465, 6467, 1, 0, 0, 0, 6466, 6464, 1, 0, 0, 0, 6467, 6468, 5, 7, 0, 0,
		6468, 6477, 1, 0, 0, 0, 6469, 6470, 5, 6, 0, 0, 6470, 6471, 3, 1018, 509,
		0, 6471, 6472, 5, 510, 0, 0, 6472, 6473, 3, 866, 433, 0, 6473, 6474, 3,
		928, 464, 0, 6474, 6475, 5, 7, 0, 0, 6475, 6477, 1, 0, 0, 0, 6476, 6458,
		1, 0, 0, 0, 6476, 6469, 1, 0, 0, 0, 6477, 819, 1, 0, 0, 0, 6478, 6479,
		3, 1026, 513, 0, 6479, 6480, 5, 492, 0, 0, 6480, 6481, 3, 868, 434, 0,
		6481, 821, 1, 0, 0, 0, 6482, 6483, 5, 290, 0, 0, 6483, 6497, 3, 852, 426,
		0, 6484, 6485, 5, 460, 0, 0, 6485, 6486, 5, 2, 0, 0, 6486, 6491, 3, 1018,
		509, 0, 6487, 6488, 5, 3, 0, 0, 6488, 6490, 3, 1018, 509, 0, 6489, 6487,
		1, 0, 0, 0, 6490, 6493, 1, 0, 0, 0, 6491, 6489, 1, 0, 0, 0, 6491, 6492,
		1, 0, 0, 0, 6492, 6494, 1, 0, 0, 0, 6493, 6491, 1, 0, 0, 0, 6494, 6495,
		5, 4, 0, 0, 6495, 6497, 1, 0, 0, 0, 6496, 6482, 1, 0, 0, 0, 6496, 6484,
		1, 0, 0, 0, 6497, 823, 1, 0, 0, 0, 6498, 6499, 5, 2, 0, 0, 6499, 6504,
		3, 1018, 509, 0, 6500, 6501, 5, 3, 0, 0, 6501, 6503, 3, 1018, 509, 0, 6502,
		6500, 1, 0, 0, 0, 6503, 6506, 1, 0, 0, 0, 6504, 6502, 1, 0, 0, 0, 6504,
		6505, 1, 0, 0, 0, 6505, 6507, 1, 0, 0, 0, 6506, 6504, 1, 0, 0, 0, 6507,
		6508, 5, 4, 0, 0, 6508, 825, 1, 0, 0, 0, 6509, 6511, 5, 428, 0, 0, 6510,
		6509, 1, 0, 0, 0, 6510, 6511, 1, 0, 0, 0, 6511, 6512, 1, 0, 0, 0, 6512,
		6513, 7, 37, 0, 0, 6513, 6514, 5, 2, 0, 0, 6514, 6519, 3, 1026, 513, 0,
		6515, 6516, 5, 3, 0, 0, 6516, 6518, 3, 1026, 513, 0, 6517, 6515, 1, 0,
		0, 0, 6518, 6521, 1, 0, 0, 0, 6519, 6517, 1, 0, 0, 0, 6519, 6520, 1, 0,
		0, 0, 6520, 6522, 1, 0, 0, 0, 6521, 6519, 1, 0, 0, 0, 6522, 6523, 5, 4,
		0, 0, 6523, 6531, 1, 0, 0, 0, 6524, 6526, 5, 428, 0, 0, 6525, 6524, 1,
		0, 0, 0, 6525, 6526, 1, 0, 0, 0, 6526, 6527, 1, 0, 0, 0, 6527, 6528, 7,
		37, 0, 0, 6528, 6531, 3, 1026, 513, 0, 6529, 6531, 3, 828, 414, 0, 6530,
		6510, 1, 0, 0, 0, 6530, 6525, 1, 0, 0, 0, 6530, 6529, 1, 0, 0, 0, 6531,
		827, 1, 0, 0, 0, 6532, 6533, 5, 303, 0, 0, 6533, 6534, 5, 2, 0, 0, 6534,
		6539, 3, 942, 471, 0, 6535, 6536, 5, 3, 0, 0, 6536, 6538, 3, 942, 471,
		0, 6537, 6535, 1, 0, 0, 0, 6538, 6541, 1, 0, 0, 0, 6539, 6537, 1, 0, 0,
		0, 6539, 6540, 1, 0, 0, 0, 6540, 6542, 1, 0, 0, 0, 6541, 6539, 1, 0, 0,
		0, 6542, 6543, 5, 4, 0, 0, 6543, 829, 1, 0, 0, 0, 6544, 6545, 5, 424, 0,
		0, 6545, 6546, 5, 2, 0, 0, 6546, 6551, 5, 518, 0, 0, 6547, 6548, 5, 3,
		0, 0, 6548, 6550, 5, 518, 0, 0, 6549, 6547, 1, 0, 0, 0, 6550, 6553, 1,
		0, 0, 0, 6551, 6549, 1, 0, 0, 0, 6551, 6552, 1, 0, 0, 0, 6552, 6554, 1,
		0, 0, 0, 6553, 6551, 1, 0, 0, 0, 6554, 6555, 5, 4, 0, 0, 6555, 831, 1,
		0, 0, 0, 6556, 6557, 5, 322, 0, 0, 6557, 6558, 3, 1018, 509, 0, 6558, 6559,
		5, 172, 0, 0, 6559, 6560, 3, 834, 417, 0, 6560, 833, 1, 0, 0, 0, 6561,
		6564, 3, 6, 3, 0, 6562, 6564, 5, 521, 0, 0, 6563, 6561, 1, 0, 0, 0, 6563,
		6562, 1, 0, 0, 0, 6564, 835, 1, 0, 0, 0, 6565, 6566, 5, 147, 0, 0, 6566,
		6578, 3, 1018, 509, 0, 6567, 6568, 5, 460, 0, 0, 6568, 6569, 5, 517, 0,
		0, 6569, 6575, 3, 1026, 513, 0, 6570, 6571, 5, 3, 0, 0, 6571, 6572, 5,
		517, 0, 0, 6572, 6574, 3, 1026, 513, 0, 6573, 6570, 1, 0, 0, 0, 6574, 6577,
		1, 0, 0, 0, 6575, 6573, 1, 0, 0, 0, 6575, 6576, 1, 0, 0, 0, 6576, 6579,
		1, 0, 0, 0, 6577, 6575, 1, 0, 0, 0, 6578, 6567, 1, 0, 0, 0, 6578, 6579,
		1, 0, 0, 0, 6579, 837, 1, 0, 0, 0, 6580, 6581, 7, 38, 0, 0, 6581, 6582,
		5, 322, 0, 0, 6582, 6583, 3, 1018, 509, 0, 6583, 839, 1, 0, 0, 0, 6584,
		6585, 5, 358, 0, 0, 6585, 6586, 5, 2, 0, 0, 6586, 6591, 5, 518, 0, 0, 6587,
		6588, 5, 3, 0, 0, 6588, 6590, 5, 518, 0, 0, 6589, 6587, 1, 0, 0, 0, 6590,
		6593, 1, 0, 0, 0, 6591, 6589, 1, 0, 0, 0, 6591, 6592, 1, 0, 0, 0, 6592,
		6594, 1, 0, 0, 0, 6593, 6591, 1, 0, 0, 0, 6594, 6595, 5, 4, 0, 0, 6595,
		841, 1, 0, 0, 0, 6596, 6597, 5, 2, 0, 0, 6597, 6602, 3, 844, 422, 0, 6598,
		6599, 5, 3, 0, 0, 6599, 6601, 3, 844, 422, 0, 6600, 6598, 1, 0, 0, 0, 6601,
		6604, 1, 0, 0, 0, 6602, 6600, 1, 0, 0, 0, 6602, 6603, 1, 0, 0, 0, 6603,
		6605, 1, 0, 0, 0, 6604, 6602, 1, 0, 0, 0, 6605, 6606, 5, 4, 0, 0, 6606,
		843, 1, 0, 0, 0, 6607, 6610, 3, 852, 426, 0, 6608, 6610, 5, 117, 0, 0,
		6609, 6607, 1, 0, 0, 0, 6609, 6608, 1, 0, 0, 0, 6610, 845, 1, 0, 0, 0,
		6611, 6616, 3, 848, 424, 0, 6612, 6613, 5, 3, 0, 0, 6613, 6615, 3, 848,
		424, 0, 6614, 6612, 1, 0, 0, 0, 6615, 6618, 1, 0, 0, 0, 6616, 6614, 1,
		0, 0, 0, 6616, 6617, 1, 0, 0, 0, 6617, 847, 1, 0, 0, 0, 6618, 6616, 1,
		0, 0, 0, 6619, 6620, 3, 852, 426, 0, 6620, 6621, 5, 8, 0, 0, 6621, 6622,
		3, 852, 426, 0, 6622, 849, 1, 0, 0, 0, 6623, 6624, 3, 852, 426, 0, 6624,
		6625, 5, 0, 0, 1, 6625, 851, 1, 0, 0, 0, 6626, 6628, 6, 426, -1, 0, 6627,
		6629, 5, 43, 0, 0, 6628, 6627, 1, 0, 0, 0, 6628, 6629, 1, 0, 0, 0, 6629,
		6630, 1, 0, 0, 0, 6630, 6634, 3, 856, 428, 0, 6631, 6632, 5, 281, 0, 0,
		6632, 6634, 3, 852, 426, 3, 6633, 6626, 1, 0, 0, 0, 6633, 6631, 1, 0, 0,
		0, 6634, 6643, 1, 0, 0, 0, 6635, 6636, 10, 2, 0, 0, 6636, 6637, 7, 39,
		0, 0, 6637, 6642, 3, 852, 426, 3, 6638, 6639, 10, 1, 0, 0, 6639, 6640,
		7, 40, 0, 0, 6640, 6642, 3, 852, 426, 2, 6641, 6635, 1, 0, 0, 0, 6641,
		6638, 1, 0, 0, 0, 6642, 6645, 1, 0, 0, 0, 6643, 6641, 1, 0, 0, 0, 6643,
		6644, 1, 0, 0, 0, 6644, 853, 1, 0, 0, 0, 6645, 6643, 1, 0, 0, 0, 6646,
		6651, 3, 852, 426, 0, 6647, 6648, 5, 3, 0, 0, 6648, 6650, 3, 852, 426,
		0, 6649, 6647, 1, 0, 0, 0, 6650, 6653, 1, 0, 0, 0, 6651, 6649, 1, 0, 0,
		0, 6651, 6652, 1, 0, 0, 0, 6652, 855, 1, 0, 0, 0, 6653, 6651, 1, 0, 0,
		0, 6654, 6655, 6, 428, -1, 0, 6655, 6656, 3, 858, 429, 0, 6656, 6675, 1,
		0, 0, 0, 6657, 6658, 10, 3, 0, 0, 6658, 6660, 5, 222, 0, 0, 6659, 6661,
		5, 281, 0, 0, 6660, 6659, 1, 0, 0, 0, 6660, 6661, 1, 0, 0, 0, 6661, 6662,
		1, 0, 0, 0, 6662, 6674, 5, 282, 0, 0, 6663, 6664, 10, 2, 0, 0, 6664, 6665,
		3, 980, 490, 0, 6665, 6666, 3, 858, 429, 0, 6666, 6674, 1, 0, 0, 0, 6667,
		6668, 10, 1, 0, 0, 6668, 6669, 3, 980, 490, 0, 6669, 6670, 5, 2, 0, 0,
		6670, 6671, 3, 754, 377, 0, 6671, 6672, 5, 4, 0, 0, 6672, 6674, 1, 0, 0,
		0, 6673, 6657, 1, 0, 0, 0, 6673, 6663, 1, 0, 0, 0, 6673, 6667, 1, 0, 0,
		0, 6674, 6677, 1, 0, 0, 0, 6675, 6673, 1, 0, 0, 0, 6675, 6676, 1, 0, 0,
		0, 6676, 857, 1, 0, 0, 0, 6677, 6675, 1, 0, 0, 0, 6678, 6680, 3, 864, 432,
		0, 6679, 6681, 3, 862, 431, 0, 6680, 6679, 1, 0, 0, 0, 6680, 6681, 1, 0,
		0, 0, 6681, 6684, 1, 0, 0, 0, 6682, 6684, 3, 860, 430, 0, 6683, 6678, 1,
		0, 0, 0, 6683, 6682, 1, 0, 0, 0, 6684, 859, 1, 0, 0, 0, 6685, 6686, 5,
		2, 0, 0, 6686, 6689, 3, 852, 426, 0, 6687, 6688, 5, 3, 0, 0, 6688, 6690,
		3, 852, 426, 0, 6689, 6687, 1, 0, 0, 0, 6690, 6691, 1, 0, 0, 0, 6691, 6689,
		1, 0, 0, 0, 6691, 6692, 1, 0, 0, 0, 6692, 6693, 1, 0, 0, 0, 6693, 6695,
		5, 4, 0, 0, 6694, 6696, 5, 281, 0, 0, 6695, 6694, 1, 0, 0, 0, 6695, 6696,
		1, 0, 0, 0, 6696, 6697, 1, 0, 0, 0, 6697, 6698, 5, 202, 0, 0, 6698, 6699,
		5, 2, 0, 0, 6699, 6700, 3, 754, 377, 0, 6700, 6701, 5, 4, 0, 0, 6701, 861,
		1, 0, 0, 0, 6702, 6704, 5, 281, 0, 0, 6703, 6702, 1, 0, 0, 0, 6703, 6704,
		1, 0, 0, 0, 6704, 6705, 1, 0, 0, 0, 6705, 6706, 5, 202, 0, 0, 6706, 6707,
		5, 2, 0, 0, 6707, 6708, 3, 754, 377, 0, 6708, 6709, 5, 4, 0, 0, 6709, 6732,
		1, 0, 0, 0, 6710, 6712, 5, 281, 0, 0, 6711, 6710, 1, 0, 0, 0, 6711, 6712,
		1, 0, 0, 0, 6712, 6713, 1, 0, 0, 0, 6713, 6714, 5, 202, 0, 0, 6714, 6715,
		5, 2, 0, 0, 6715, 6716, 3, 854, 427, 0, 6716, 6717, 5, 4, 0, 0, 6717, 6732,
		1, 0, 0, 0, 6718, 6720, 5, 281, 0, 0, 6719, 6718, 1, 0, 0, 0, 6719, 6720,
		1, 0, 0, 0, 6720, 6721, 1, 0, 0, 0, 6721, 6722, 5, 41, 0, 0, 6722, 6723,
		3, 864, 432, 0, 6723, 6724, 5, 21, 0, 0, 6724, 6725, 3, 858, 429, 0, 6725,
		6732, 1, 0, 0, 0, 6726, 6728, 5, 281, 0, 0, 6727, 6726, 1, 0, 0, 0, 6727,
		6728, 1, 0, 0, 0, 6728, 6729, 1, 0, 0, 0, 6729, 6730, 7, 41, 0, 0, 6730,
		6732, 3, 864, 432, 0, 6731, 6703, 1, 0, 0, 0, 6731, 6711, 1, 0, 0, 0, 6731,
		6719, 1, 0, 0, 0, 6731, 6727, 1, 0, 0, 0, 6732, 863, 1, 0, 0, 0, 6733,
		6734, 6, 432, -1, 0, 6734, 6735, 3, 866, 433, 0, 6735, 6762, 1, 0, 0, 0,
		6736, 6737, 10, 8, 0, 0, 6737, 6738, 5, 511, 0, 0, 6738, 6761, 3, 864,
		432, 9, 6739, 6740, 10, 7, 0, 0, 6740, 6741, 7, 42, 0, 0, 6741, 6761, 3,
		864, 432, 8, 6742, 6743, 10, 6, 0, 0, 6743, 6744, 7, 43, 0, 0, 6744, 6761,
		3, 864, 432, 7, 6745, 6746, 10, 5, 0, 0, 6746, 6747, 5, 509, 0, 0, 6747,
		6761, 3, 864, 432, 6, 6748, 6749, 10, 4, 0, 0, 6749, 6750, 5, 510, 0, 0,
		6750, 6761, 3, 864, 432, 5, 6751, 6752, 10, 3, 0, 0, 6752, 6753, 5, 513,
		0, 0, 6753, 6761, 3, 864, 432, 4, 6754, 6755, 10, 2, 0, 0, 6755, 6756,
		5, 514, 0, 0, 6756, 6761, 3, 864, 432, 3, 6757, 6758, 10, 1, 0, 0, 6758,
		6759, 5, 515, 0, 0, 6759, 6761, 3, 864, 432, 2, 6760, 6736, 1, 0, 0, 0,
		6760, 6739, 1, 0, 0, 0, 6760, 6742, 1, 0, 0, 0, 6760, 6745, 1, 0, 0, 0,
		6760, 6748, 1, 0, 0, 0, 6760, 6751, 1, 0, 0, 0, 6760, 6754, 1, 0, 0, 0,
		6760, 6757, 1, 0, 0, 0, 6761, 6764, 1, 0, 0, 0, 6762, 6760, 1, 0, 0, 0,
		6762, 6763, 1, 0, 0, 0, 6763, 865, 1, 0, 0, 0, 6764, 6762, 1, 0, 0, 0,
		6765, 6766, 6, 433, -1, 0, 6766, 6871, 3, 874, 437, 0, 6767, 6871, 3, 876,
		438, 0, 6768, 6769, 5, 123, 0, 0, 6769, 6770, 5, 2, 0, 0, 6770, 6771, 3,
		854, 427, 0, 6771, 6772, 5, 4, 0, 0, 6772, 6871, 1, 0, 0, 0, 6773, 6871,
		3, 870, 435, 0, 6774, 6775, 5, 9, 0, 0, 6775, 6776, 5, 165, 0, 0, 6776,
		6777, 3, 870, 435, 0, 6777, 6778, 5, 10, 0, 0, 6778, 6871, 1, 0, 0, 0,
		6779, 6871, 3, 868, 434, 0, 6780, 6871, 3, 878, 439, 0, 6781, 6782, 7,
		44, 0, 0, 6782, 6871, 3, 866, 433, 18, 6783, 6784, 5, 507, 0, 0, 6784,
		6871, 3, 866, 433, 17, 6785, 6786, 5, 2, 0, 0, 6786, 6787, 3, 852, 426,
		0, 6787, 6788, 5, 4, 0, 0, 6788, 6871, 1, 0, 0, 0, 6789, 6790, 5, 148,
		0, 0, 6790, 6791, 5, 2, 0, 0, 6791, 6792, 3, 754, 377, 0, 6792, 6793, 5,
		4, 0, 0, 6793, 6871, 1, 0, 0, 0, 6794, 6871, 3, 766, 383, 0, 6795, 6796,
		5, 59, 0, 0, 6796, 6797, 5, 2, 0, 0, 6797, 6798, 3, 852, 426, 0, 6798,
		6799, 5, 27, 0, 0, 6799, 6800, 3, 994, 497, 0, 6800, 6801, 5, 4, 0, 0,
		6801, 6871, 1, 0, 0, 0, 6802, 6803, 5, 87, 0, 0, 6803, 6804, 5, 2, 0, 0,
		6804, 6805, 3, 852, 426, 0, 6805, 6806, 5, 3, 0, 0, 6806, 6807, 3, 994,
		497, 0, 6807, 6808, 5, 4, 0, 0, 6808, 6871, 1, 0, 0, 0, 6809, 6810, 5,
		58, 0, 0, 6810, 6812, 3, 852, 426, 0, 6811, 6813, 3, 888, 444, 0, 6812,
		6811, 1, 0, 0, 0, 6813, 6814, 1, 0, 0, 0, 6814, 6812, 1, 0, 0, 0, 6814,
		6815, 1, 0, 0, 0, 6815, 6818, 1, 0, 0, 0, 6816, 6817, 5, 136, 0, 0, 6817,
		6819, 3, 852, 426, 0, 6818, 6816, 1, 0, 0, 0, 6818, 6819, 1, 0, 0, 0, 6819,
		6820, 1, 0, 0, 0, 6820, 6821, 5, 139, 0, 0, 6821, 6871, 1, 0, 0, 0, 6822,
		6824, 5, 58, 0, 0, 6823, 6825, 3, 888, 444, 0, 6824, 6823, 1, 0, 0, 0,
		6825, 6826, 1, 0, 0, 0, 6826, 6824, 1, 0, 0, 0, 6826, 6827, 1, 0, 0, 0,
		6827, 6830, 1, 0, 0, 0, 6828, 6829, 5, 136, 0, 0, 6829, 6831, 3, 852, 426,
		0, 6830, 6828, 1, 0, 0, 0, 6830, 6831, 1, 0, 0, 0, 6831, 6832, 1, 0, 0,
		0, 6832, 6833, 5, 139, 0, 0, 6833, 6871, 1, 0, 0, 0, 6834, 6836, 3, 996,
		498, 0, 6835, 6834, 1, 0, 0, 0, 6835, 6836, 1, 0, 0, 0, 6836, 6837, 1,
		0, 0, 0, 6837, 6839, 5, 6, 0, 0, 6838, 6840, 3, 854, 427, 0, 6839, 6838,
		1, 0, 0, 0, 6839, 6840, 1, 0, 0, 0, 6840, 6841, 1, 0, 0, 0, 6841, 6871,
		5, 7, 0, 0, 6842, 6843, 3, 998, 499, 0, 6843, 6845, 5, 9, 0, 0, 6844, 6846,
		3, 846, 423, 0, 6845, 6844, 1, 0, 0, 0, 6845, 6846, 1, 0, 0, 0, 6846, 6847,
		1, 0, 0, 0, 6847, 6848, 5, 10, 0, 0, 6848, 6871, 1, 0, 0, 0, 6849, 6850,
		5, 252, 0, 0, 6850, 6852, 5, 9, 0, 0, 6851, 6853, 3, 846, 423, 0, 6852,
		6851, 1, 0, 0, 0, 6852, 6853, 1, 0, 0, 0, 6853, 6854, 1, 0, 0, 0, 6854,
		6871, 5, 10, 0, 0, 6855, 6858, 3, 1018, 509, 0, 6856, 6858, 3, 1024, 512,
		0, 6857, 6855, 1, 0, 0, 0, 6857, 6856, 1, 0, 0, 0, 6858, 6859, 1, 0, 0,
		0, 6859, 6860, 5, 516, 0, 0, 6860, 6861, 3, 852, 426, 0, 6861, 6871, 1,
		0, 0, 0, 6862, 6863, 3, 1024, 512, 0, 6863, 6864, 5, 516, 0, 0, 6864, 6866,
		5, 2, 0, 0, 6865, 6867, 3, 854, 427, 0, 6866, 6865, 1, 0, 0, 0, 6866, 6867,
		1, 0, 0, 0, 6867, 6868, 1, 0, 0, 0, 6868, 6869, 5, 4, 0, 0, 6869, 6871,
		1, 0, 0, 0, 6870, 6765, 1, 0, 0, 0, 6870, 6767, 1, 0, 0, 0, 6870, 6768,
		1, 0, 0, 0, 6870, 6773, 1, 0, 0, 0, 6870, 6774, 1, 0, 0, 0, 6870, 6779,
		1, 0, 0, 0, 6870, 6780, 1, 0, 0, 0, 6870, 6781, 1, 0, 0, 0, 6870, 6783,
		1, 0, 0, 0, 6870, 6785, 1, 0, 0, 0, 6870, 6789, 1, 0, 0, 0, 6870, 6794,
		1, 0, 0, 0, 6870, 6795, 1, 0, 0, 0, 6870, 6802, 1, 0, 0, 0, 6870, 6809,
		1, 0, 0, 0, 6870, 6822, 1, 0, 0, 0, 6870, 6835, 1, 0, 0, 0, 6870, 6842,
		1, 0, 0, 0, 6870, 6849, 1, 0, 0, 0, 6870, 6857, 1, 0, 0, 0, 6870, 6862,
		1, 0, 0, 0, 6871, 6913, 1, 0, 0, 0, 6872, 6873, 10, 19, 0, 0, 6873, 6874,
		5, 536, 0, 0, 6874, 6912, 3, 866, 433, 20, 6875, 6877, 10, 1, 0, 0, 6876,
		6878, 5, 281, 0, 0, 6877, 6876, 1, 0, 0, 0, 6877, 6878, 1, 0, 0, 0, 6878,
		6879, 1, 0, 0, 0, 6879, 6880, 5, 256, 0, 0, 6880, 6912, 3, 866, 433, 2,
		6881, 6882, 10, 23, 0, 0, 6882, 6885, 5, 74, 0, 0, 6883, 6886, 3, 1018,
		509, 0, 6884, 6886, 3, 976, 488, 0, 6885, 6883, 1, 0, 0, 0, 6885, 6884,
		1, 0, 0, 0, 6886, 6912, 1, 0, 0, 0, 6887, 6891, 10, 20, 0, 0, 6888, 6892,
		5, 528, 0, 0, 6889, 6890, 5, 1, 0, 0, 6890, 6892, 3, 1018, 509, 0, 6891,
		6888, 1, 0, 0, 0, 6891, 6889, 1, 0, 0, 0, 6892, 6912, 1, 0, 0, 0, 6893,
		6894, 10, 6, 0, 0, 6894, 6895, 5, 6, 0, 0, 6895, 6896, 3, 864, 432, 0,
		6896, 6897, 5, 7, 0, 0, 6897, 6912, 1, 0, 0, 0, 6898, 6899, 10, 5, 0, 0,
		6899, 6901, 5, 6, 0, 0, 6900, 6902, 5, 518, 0, 0, 6901, 6900, 1, 0, 0,
		0, 6901, 6902, 1, 0, 0, 0, 6902, 6903, 1, 0, 0, 0, 6903, 6905, 5, 8, 0,
		0, 6904, 6906, 5, 518, 0, 0, 6905, 6904, 1, 0, 0, 0, 6905, 6906, 1, 0,
		0, 0, 6906, 6907, 1, 0, 0, 0, 6907, 6912, 5, 7, 0, 0, 6908, 6909, 10, 4,
		0, 0, 6909, 6910, 5, 516, 0, 0, 6910, 6912, 3, 976, 488, 0, 6911, 6872,
		1, 0, 0, 0, 6911, 6875, 1, 0, 0, 0, 6911, 6881, 1, 0, 0, 0, 6911, 6887,
		1, 0, 0, 0, 6911, 6893, 1, 0, 0, 0, 6911, 6898, 1, 0, 0, 0, 6911, 6908,
		1, 0, 0, 0, 6912, 6915, 1, 0, 0, 0, 6913, 6911, 1, 0, 0, 0, 6913, 6914,
		1, 0, 0, 0, 6914, 867, 1, 0, 0, 0, 6915, 6913, 1, 0, 0, 0, 6916, 6927,
		5, 282, 0, 0, 6917, 6927, 3, 982, 491, 0, 6918, 6927, 3, 1038, 519, 0,
		6919, 6920, 7, 45, 0, 0, 6920, 6927, 3, 976, 488, 0, 6921, 6927, 3, 976,
		488, 0, 6922, 6927, 3, 984, 492, 0, 6923, 6927, 3, 992, 496, 0, 6924, 6927,
		3, 978, 489, 0, 6925, 6927, 5, 302, 0, 0, 6926, 6916, 1, 0, 0, 0, 6926,
		6917, 1, 0, 0, 0, 6926, 6918, 1, 0, 0, 0, 6926, 6919, 1, 0, 0, 0, 6926,
		6921, 1, 0, 0, 0, 6926, 6922, 1, 0, 0, 0, 6926, 6923, 1, 0, 0, 0, 6926,
		6924, 1, 0, 0, 0, 6926, 6925, 1, 0, 0, 0, 6927, 869, 1, 0, 0, 0, 6928,
		6929, 5, 152, 0, 0, 6929, 6930, 5, 2, 0, 0, 6930, 6931, 3, 1018, 509, 0,
		6931, 6932, 5, 172, 0, 0, 6932, 6933, 3, 864, 432, 0, 6933, 6934, 5, 4,
		0, 0, 6934, 7001, 1, 0, 0, 0, 6935, 6936, 5, 183, 0, 0, 6936, 6945, 5,
		2, 0, 0, 6937, 6942, 3, 852, 426, 0, 6938, 6939, 5, 3, 0, 0, 6939, 6941,
		3, 852, 426, 0, 6940, 6938, 1, 0, 0, 0, 6941, 6944, 1, 0, 0, 0, 6942, 6940,
		1, 0, 0, 0, 6942, 6943, 1, 0, 0, 0, 6943, 6946, 1, 0, 0, 0, 6944, 6942,
		1, 0, 0, 0, 6945, 6937, 1, 0, 0, 0, 6945, 6946, 1, 0, 0, 0, 6946, 6947,
		1, 0, 0, 0, 6947, 7001, 5, 4, 0, 0, 6948, 6949, 5, 184, 0, 0, 6949, 6958,
		5, 2, 0, 0, 6950, 6955, 3, 852, 426, 0, 6951, 6952, 5, 3, 0, 0, 6952, 6954,
		3, 852, 426, 0, 6953, 6951, 1, 0, 0, 0, 6954, 6957, 1, 0, 0, 0, 6955, 6953,
		1, 0, 0, 0, 6955, 6956, 1, 0, 0, 0, 6956, 6959, 1, 0, 0, 0, 6957, 6955,
		1, 0, 0, 0, 6958, 6950, 1, 0, 0, 0, 6958, 6959, 1, 0, 0, 0, 6959, 6960,
		1, 0, 0, 0, 6960, 7001, 5, 4, 0, 0, 6961, 7001, 3, 880, 440, 0, 6962, 7001,
		3, 882, 441, 0, 6963, 7001, 3, 884, 442, 0, 6964, 6966, 3, 872, 436, 0,
		6965, 6967, 3, 890, 445, 0, 6966, 6965, 1, 0, 0, 0, 6966, 6967, 1, 0, 0,
		0, 6967, 7001, 1, 0, 0, 0, 6968, 6969, 3, 886, 443, 0, 6969, 6970, 3, 890,
		445, 0, 6970, 7001, 1, 0, 0, 0, 6971, 6972, 5, 439, 0, 0, 6972, 6981, 5,
		2, 0, 0, 6973, 6978, 3, 852, 426, 0, 6974, 6975, 5, 3, 0, 0, 6975, 6977,
		3, 852, 426, 0, 6976, 6974, 1, 0, 0, 0, 6977, 6980, 1, 0, 0, 0, 6978, 6976,
		1, 0, 0, 0, 6978, 6979, 1, 0, 0, 0, 6979, 6982, 1, 0, 0, 0, 6980, 6978,
		1, 0, 0, 0, 6981, 6973, 1, 0, 0, 0, 6981, 6982, 1, 0, 0, 0, 6982, 6983,
		1, 0, 0, 0, 6983, 7001, 5, 4, 0, 0, 6984, 6985, 3, 1012, 506, 0, 6985,
		6994, 5, 2, 0, 0, 6986, 6991, 3, 852, 426, 0, 6987, 6988, 5, 3, 0, 0, 6988,
		6990, 3, 852, 426, 0, 6989, 6987, 1, 0, 0, 0, 6990, 6993, 1, 0, 0, 0, 6991,
		6989, 1, 0, 0, 0, 6991, 6992, 1, 0, 0, 0, 6992, 6995, 1, 0, 0, 0, 6993,
		6991, 1, 0, 0, 0, 6994, 6986, 1, 0, 0, 0, 6994, 6995, 1, 0, 0, 0, 6995,
		6996, 1, 0, 0, 0, 6996, 6998, 5, 4, 0, 0, 6997, 6999, 3, 890, 445, 0, 6998,
		6997, 1, 0, 0, 0, 6998, 6999, 1, 0, 0, 0, 6999, 7001, 1, 0, 0, 0, 7000,
		6928, 1, 0, 0, 0, 7000, 6935, 1, 0, 0, 0, 7000, 6948, 1, 0, 0, 0, 7000,
		6961, 1, 0, 0, 0, 7000, 6962, 1, 0, 0, 0, 7000, 6963, 1, 0, 0, 0, 7000,
		6964, 1, 0, 0, 0, 7000, 6968, 1, 0, 0, 0, 7000, 6971, 1, 0, 0, 0, 7000,
		6984, 1, 0, 0, 0, 7001, 871, 1, 0, 0, 0, 7002, 7003, 5, 34, 0, 0, 7003,
		7005, 5, 2, 0, 0, 7004, 7006, 3, 786, 393, 0, 7005, 7004, 1, 0, 0, 0, 7005,
		7006, 1, 0, 0, 0, 7006, 7007, 1, 0, 0, 0, 7007, 7008, 3, 852, 426, 0, 7008,
		7009, 5, 4, 0, 0, 7009, 7128, 1, 0, 0, 0, 7010, 7011, 5, 89, 0, 0, 7011,
		7013, 5, 2, 0, 0, 7012, 7014, 5, 502, 0, 0, 7013, 7012, 1, 0, 0, 0, 7013,
		7014, 1, 0, 0, 0, 7014, 7015, 1, 0, 0, 0, 7015, 7128, 5, 4, 0, 0, 7016,
		7017, 5, 89, 0, 0, 7017, 7022, 5, 2, 0, 0, 7018, 7020, 3, 786, 393, 0,
		7019, 7021, 3, 818, 409, 0, 7020, 7019, 1, 0, 0, 0, 7020, 7021, 1, 0, 0,
		0, 7021, 7023, 1, 0, 0, 0, 7022, 7018, 1, 0, 0, 0, 7022, 7023, 1, 0, 0,
		0, 7023, 7032, 1, 0, 0, 0, 7024, 7029, 3, 852, 426, 0, 7025, 7026, 5, 3,
		0, 0, 7026, 7028, 3, 852, 426, 0, 7027, 7025, 1, 0, 0, 0, 7028, 7031, 1,
		0, 0, 0, 7029, 7027, 1, 0, 0, 0, 7029, 7030, 1, 0, 0, 0, 7030, 7033, 1,
		0, 0, 0, 7031, 7029, 1, 0, 0, 0, 7032, 7024, 1, 0, 0, 0, 7032, 7033, 1,
		0, 0, 0, 7033, 7034, 1, 0, 0, 0, 7034, 7128, 5, 4, 0, 0, 7035, 7036, 5,
		258, 0, 0, 7036, 7038, 5, 2, 0, 0, 7037, 7039, 3, 786, 393, 0, 7038, 7037,
		1, 0, 0, 0, 7038, 7039, 1, 0, 0, 0, 7039, 7040, 1, 0, 0, 0, 7040, 7041,
		3, 852, 426, 0, 7041, 7042, 5, 4, 0, 0, 7042, 7128, 1, 0, 0, 0, 7043, 7044,
		5, 263, 0, 0, 7044, 7046, 5, 2, 0, 0, 7045, 7047, 3, 786, 393, 0, 7046,
		7045, 1, 0, 0, 0, 7046, 7047, 1, 0, 0, 0, 7047, 7048, 1, 0, 0, 0, 7048,
		7049, 3, 852, 426, 0, 7049, 7050, 5, 4, 0, 0, 7050, 7128, 1, 0, 0, 0, 7051,
		7052, 5, 415, 0, 0, 7052, 7054, 5, 2, 0, 0, 7053, 7055, 3, 786, 393, 0,
		7054, 7053, 1, 0, 0, 0, 7054, 7055, 1, 0, 0, 0, 7055, 7056, 1, 0, 0, 0,
		7056, 7057, 3, 852, 426, 0, 7057, 7058, 5, 4, 0, 0, 7058, 7128, 1, 0, 0,
		0, 7059, 7060, 5, 25, 0, 0, 7060, 7062, 5, 2, 0, 0, 7061, 7063, 3, 786,
		393, 0, 7062, 7061, 1, 0, 0, 0, 7062, 7063, 1, 0, 0, 0, 7063, 7064, 1,
		0, 0, 0, 7064, 7075, 3, 852, 426, 0, 7065, 7066, 5, 298, 0, 0, 7066, 7067,
		5, 55, 0, 0, 7067, 7072, 3, 770, 385, 0, 7068, 7069, 5, 3, 0, 0, 7069,
		7071, 3, 770, 385, 0, 7070, 7068, 1, 0, 0, 0, 7071, 7074, 1, 0, 0, 0, 7072,
		7070, 1, 0, 0, 0, 7072, 7073, 1, 0, 0, 0, 7073, 7076, 1, 0, 0, 0, 7074,
		7072, 1, 0, 0, 0, 7075, 7065, 1, 0, 0, 0, 7075, 7076, 1, 0, 0, 0, 7076,
		7077, 1, 0, 0, 0, 7077, 7078, 5, 4, 0, 0, 7078, 7128, 1, 0, 0, 0, 7079,
		7080, 5, 26, 0, 0, 7080, 7081, 5, 2, 0, 0, 7081, 7092, 3, 852, 426, 0,
		7082, 7083, 5, 298, 0, 0, 7083, 7084, 5, 55, 0, 0, 7084, 7089, 3, 770,
		385, 0, 7085, 7086, 5, 3, 0, 0, 7086, 7088, 3, 770, 385, 0, 7087, 7085,
		1, 0, 0, 0, 7088, 7091, 1, 0, 0, 0, 7089, 7087, 1, 0, 0, 0, 7089, 7090,
		1, 0, 0, 0, 7090, 7093, 1, 0, 0, 0, 7091, 7089, 1, 0, 0, 0, 7092, 7082,
		1, 0, 0, 0, 7092, 7093, 1, 0, 0, 0, 7093, 7094, 1, 0, 0, 0, 7094, 7095,
		5, 4, 0, 0, 7095, 7128, 1, 0, 0, 0, 7096, 7097, 5, 185, 0, 0, 7097, 7099,
		5, 2, 0, 0, 7098, 7100, 3, 786, 393, 0, 7099, 7098, 1, 0, 0, 0, 7099, 7100,
		1, 0, 0, 0, 7100, 7101, 1, 0, 0, 0, 7101, 7106, 3, 852, 426, 0, 7102, 7103,
		5, 3, 0, 0, 7103, 7105, 3, 852, 426, 0, 7104, 7102, 1, 0, 0, 0, 7105, 7108,
		1, 0, 0, 0, 7106, 7104, 1, 0, 0, 0, 7106, 7107, 1, 0, 0, 0, 7107, 7119,
		1, 0, 0, 0, 7108, 7106, 1, 0, 0, 0, 7109, 7110, 5, 298, 0, 0, 7110, 7111,
		5, 55, 0, 0, 7111, 7116, 3, 770, 385, 0, 7112, 7113, 5, 3, 0, 0, 7113,
		7115, 3, 770, 385, 0, 7114, 7112, 1, 0, 0, 0, 7115, 7118, 1, 0, 0, 0, 7116,
		7114, 1, 0, 0, 0, 7116, 7117, 1, 0, 0, 0, 7117, 7120, 1, 0, 0, 0, 7118,
		7116, 1, 0, 0, 0, 7119, 7109, 1, 0, 0, 0, 7119, 7120, 1, 0, 0, 0, 7120,
		7123, 1, 0, 0, 0, 7121, 7122, 5, 393, 0, 0, 7122, 7124, 3, 852, 426, 0,
		7123, 7121, 1, 0, 0, 0, 7123, 7124, 1, 0, 0, 0, 7124, 7125, 1, 0, 0, 0,
		7125, 7126, 5, 4, 0, 0, 7126, 7128, 1, 0, 0, 0, 7127, 7002, 1, 0, 0, 0,
		7127, 7010, 1, 0, 0, 0, 7127, 7016, 1, 0, 0, 0, 7127, 7035, 1, 0, 0, 0,
		7127, 7043, 1, 0, 0, 0, 7127, 7051, 1, 0, 0, 0, 7127, 7059, 1, 0, 0, 0,
		7127, 7079, 1, 0, 0, 0, 7127, 7096, 1, 0, 0, 0, 7128, 873, 1, 0, 0, 0,
		7129, 7130, 5, 517, 0, 0, 7130, 7131, 3, 1026, 513, 0, 7131, 875, 1, 0,
		0, 0, 7132, 7133, 5, 517, 0, 0, 7133, 7137, 5, 517, 0, 0, 7134, 7135, 3,
		968, 484, 0, 7135, 7136, 5, 1, 0, 0, 7136, 7138, 1, 0, 0, 0, 7137, 7134,
		1, 0, 0, 0, 7137, 7138, 1, 0, 0, 0, 7138, 7139, 1, 0, 0, 0, 7139, 7140,
		3, 1018, 509, 0, 7140, 877, 1, 0, 0, 0, 7141, 7142, 3, 1018, 509, 0, 7142,
		879, 1, 0, 0, 0, 7143, 7144, 5, 60, 0, 0, 7144, 7145, 5, 2, 0, 0, 7145,
		7171, 5, 4, 0, 0, 7146, 7147, 5, 104, 0, 0, 7147, 7148, 5, 2, 0, 0, 7148,
		7171, 5, 4, 0, 0, 7149, 7150, 5, 387, 0, 0, 7150, 7151, 5, 2, 0, 0, 7151,
		7171, 5, 4, 0, 0, 7152, 7153, 5, 458, 0, 0, 7153, 7154, 5, 2, 0, 0, 7154,
		7171, 5, 4, 0, 0, 7155, 7158, 5, 101, 0, 0, 7156, 7157, 5, 2, 0, 0, 7157,
		7159, 5, 4, 0, 0, 7158, 7156, 1, 0, 0, 0, 7158, 7159, 1, 0, 0, 0, 7159,
		7171, 1, 0, 0, 0, 7160, 7163, 5, 98, 0, 0, 7161, 7162, 5, 2, 0, 0, 7162,
		7164, 5, 4, 0, 0, 7163, 7161, 1, 0, 0, 0, 7163, 7164, 1, 0, 0, 0, 7164,
		7171, 1, 0, 0, 0, 7165, 7168, 5, 97, 0, 0, 7166, 7167, 5, 2, 0, 0, 7167,
		7169, 5, 4, 0, 0, 7168, 7166, 1, 0, 0, 0, 7168, 7169, 1, 0, 0, 0, 7169,
		7171, 1, 0, 0, 0, 7170, 7143, 1, 0, 0, 0, 7170, 7146, 1, 0, 0, 0, 7170,
		7149, 1, 0, 0, 0, 7170, 7152, 1, 0, 0, 0, 7170, 7155, 1, 0, 0, 0, 7170,
		7160, 1, 0, 0, 0, 7170, 7165, 1, 0, 0, 0, 7171, 881, 1, 0, 0, 0, 7172,
		7175, 5, 96, 0, 0, 7173, 7174, 5, 2, 0, 0, 7174, 7176, 5, 4, 0, 0, 7175,
		7173, 1, 0, 0, 0, 7175, 7176, 1, 0, 0, 0, 7176, 7201, 1, 0, 0, 0, 7177,
		7180, 5, 99, 0, 0, 7178, 7179, 5, 2, 0, 0, 7179, 7181, 5, 4, 0, 0, 7180,
		7178, 1, 0, 0, 0, 7180, 7181, 1, 0, 0, 0, 7181, 7201, 1, 0, 0, 0, 7182,
		7188, 5, 100, 0, 0, 7183, 7185, 5, 2, 0, 0, 7184, 7186, 5, 518, 0, 0, 7185,
		7184, 1, 0, 0, 0, 7185, 7186, 1, 0, 0, 0, 7186, 7187, 1, 0, 0, 0, 7187,
		7189, 5, 4, 0, 0, 7188, 7183, 1, 0, 0, 0, 7188, 7189, 1, 0, 0, 0, 7189,
		7201, 1, 0, 0, 0, 7190, 7193, 5, 245, 0, 0, 7191, 7192, 5, 2, 0, 0, 7192,
		7194, 5, 4, 0, 0, 7193, 7191, 1, 0, 0, 0, 7193, 7194, 1, 0, 0, 0, 7194,
		7201, 1, 0, 0, 0, 7195, 7198, 5, 246, 0, 0, 7196, 7197, 5, 2, 0, 0, 7197,
		7199, 5, 4, 0, 0, 7198, 7196, 1, 0, 0, 0, 7198, 7199, 1, 0, 0, 0, 7199,
		7201, 1, 0, 0, 0, 7200, 7172, 1, 0, 0, 0, 7200, 7177, 1, 0, 0, 0, 7200,
		7182, 1, 0, 0, 0, 7200, 7190, 1, 0, 0, 0, 7200, 7195, 1, 0, 0, 0, 7201,
		883, 1, 0, 0, 0, 7202, 7203, 5, 64, 0, 0, 7203, 7204, 5, 2, 0, 0, 7204,
		7205, 3, 852, 426, 0, 7205, 7206, 5, 4, 0, 0, 7206, 7344, 1, 0, 0, 0, 7207,
		7208, 5, 108, 0, 0, 7208, 7209, 5, 2, 0, 0, 7209, 7210, 3, 852, 426, 0,
		7210, 7211, 5, 4, 0, 0, 7211, 7344, 1, 0, 0, 0, 7212, 7213, 5, 193, 0,
		0, 7213, 7214, 5, 2, 0, 0, 7214, 7215, 3, 852, 426, 0, 7215, 7216, 5, 4,
		0, 0, 7216, 7344, 1, 0, 0, 0, 7217, 7218, 5, 197, 0, 0, 7218, 7227, 5,
		2, 0, 0, 7219, 7224, 3, 852, 426, 0, 7220, 7221, 5, 3, 0, 0, 7221, 7223,
		3, 852, 426, 0, 7222, 7220, 1, 0, 0, 0, 7223, 7226, 1, 0, 0, 0, 7224, 7222,
		1, 0, 0, 0, 7224, 7225, 1, 0, 0, 0, 7225, 7228, 1, 0, 0, 0, 7226, 7224,
		1, 0, 0, 0, 7227, 7219, 1, 0, 0, 0, 7227, 7228, 1, 0, 0, 0, 7228, 7229,
		1, 0, 0, 0, 7229, 7344, 5, 4, 0, 0, 7230, 7231, 5, 237, 0, 0, 7231, 7232,
		5, 2, 0, 0, 7232, 7233, 3, 852, 426, 0, 7233, 7234, 5, 3, 0, 0, 7234, 7235,
		3, 852, 426, 0, 7235, 7236, 5, 4, 0, 0, 7236, 7344, 1, 0, 0, 0, 7237, 7238,
		5, 240, 0, 0, 7238, 7239, 5, 2, 0, 0, 7239, 7240, 3, 852, 426, 0, 7240,
		7241, 5, 3, 0, 0, 7241, 7242, 3, 852, 426, 0, 7242, 7243, 5, 4, 0, 0, 7243,
		7344, 1, 0, 0, 0, 7244, 7245, 5, 264, 0, 0, 7245, 7246, 5, 2, 0, 0, 7246,
		7247, 3, 852, 426, 0, 7247, 7248, 5, 4, 0, 0, 7248, 7344, 1, 0, 0, 0, 7249,
		7250, 5, 268, 0, 0, 7250, 7251, 5, 2, 0, 0, 7251, 7252, 3, 852, 426, 0,
		7252, 7253, 5, 3, 0, 0, 7253, 7254, 3, 852, 426, 0, 7254, 7255, 5, 4, 0,
		0, 7255, 7344, 1, 0, 0, 0, 7256, 7257, 5, 271, 0, 0, 7257, 7258, 5, 2,
		0, 0, 7258, 7259, 3, 852, 426, 0, 7259, 7260, 5, 4, 0, 0, 7260, 7344, 1,
		0, 0, 0, 7261, 7262, 5, 337, 0, 0, 7262, 7263, 5, 2, 0, 0, 7263, 7264,
		3, 852, 426, 0, 7264, 7265, 5, 4, 0, 0, 7265, 7344, 1, 0, 0, 0, 7266, 7267,
		5, 350, 0, 0, 7267, 7268, 5, 2, 0, 0, 7268, 7269, 3, 852, 426, 0, 7269,
		7270, 5, 3, 0, 0, 7270, 7271, 3, 852, 426, 0, 7271, 7272, 5, 4, 0, 0, 7272,
		7344, 1, 0, 0, 0, 7273, 7274, 5, 356, 0, 0, 7274, 7283, 5, 2, 0, 0, 7275,
		7280, 3, 852, 426, 0, 7276, 7277, 5, 3, 0, 0, 7277, 7279, 3, 852, 426,
		0, 7278, 7276, 1, 0, 0, 0, 7279, 7282, 1, 0, 0, 0, 7280, 7278, 1, 0, 0,
		0, 7280, 7281, 1, 0, 0, 0, 7281, 7284, 1, 0, 0, 0, 7282, 7280, 1, 0, 0,
		0, 7283, 7275, 1, 0, 0, 0, 7283, 7284, 1, 0, 0, 0, 7284, 7285, 1, 0, 0,
		0, 7285, 7344, 5, 4, 0, 0, 7286, 7287, 5, 371, 0, 0, 7287, 7288, 5, 2,
		0, 0, 7288, 7289, 3, 852, 426, 0, 7289, 7290, 5, 3, 0, 0, 7290, 7291, 3,
		852, 426, 0, 7291, 7292, 5, 4, 0, 0, 7292, 7344, 1, 0, 0, 0, 7293, 7294,
		5, 372, 0, 0, 7294, 7295, 5, 2, 0, 0, 7295, 7296, 3, 852, 426, 0, 7296,
		7297, 5, 3, 0, 0, 7297, 7298, 3, 852, 426, 0, 7298, 7299, 5, 4, 0, 0, 7299,
		7344, 1, 0, 0, 0, 7300, 7301, 5, 389, 0, 0, 7301, 7302, 5, 2, 0, 0, 7302,
		7303, 3, 852, 426, 0, 7303, 7304, 5, 4, 0, 0, 7304, 7344, 1, 0, 0, 0, 7305,
		7306, 5, 435, 0, 0, 7306, 7307, 5, 2, 0, 0, 7307, 7308, 3, 990, 495, 0,
		7308, 7309, 5, 3, 0, 0, 7309, 7310, 3, 852, 426, 0, 7310, 7311, 5, 3, 0,
		0, 7311, 7312, 3, 852, 426, 0, 7312, 7313, 5, 4, 0, 0, 7313, 7344, 1, 0,
		0, 0, 7314, 7315, 5, 436, 0, 0, 7315, 7316, 5, 2, 0, 0, 7316, 7317, 3,
		990, 495, 0, 7317, 7318, 5, 3, 0, 0, 7318, 7319, 3, 852, 426, 0, 7319,
		7320, 5, 3, 0, 0, 7320, 7321, 3, 852, 426, 0, 7321, 7322, 5, 4, 0, 0, 7322,
		7344, 1, 0, 0, 0, 7323, 7324, 5, 483, 0, 0, 7324, 7325, 5, 2, 0, 0, 7325,
		7326, 3, 852, 426, 0, 7326, 7327, 5, 4, 0, 0, 7327, 7344, 1, 0, 0, 0, 7328,
		7329, 5, 305, 0, 0, 7329, 7330, 5, 2, 0, 0, 7330, 7331, 3, 976, 488, 0,
		7331, 7332, 5, 4, 0, 0, 7332, 7344, 1, 0, 0, 0, 7333, 7334, 5, 164, 0,
		0, 7334, 7335, 5, 2, 0, 0, 7335, 7336, 3, 852, 426, 0, 7336, 7337, 5, 4,
		0, 0, 7337, 7344, 1, 0, 0, 0, 7338, 7339, 5, 62, 0, 0, 7339, 7340, 5, 2,
		0, 0, 7340, 7341, 3, 852, 426, 0, 7341, 7342, 5, 4, 0, 0, 7342, 7344, 1,
		0, 0, 0, 7343, 7202, 1, 0, 0, 0, 7343, 7207, 1, 0, 0, 0, 7343, 7212, 1,
		0, 0, 0, 7343, 7217, 1, 0, 0, 0, 7343, 7230, 1, 0, 0, 0, 7343, 7237, 1,
		0, 0, 0, 7343, 7244, 1, 0, 0, 0, 7343, 7249, 1, 0, 0, 0, 7343, 7256, 1,
		0, 0, 0, 7343, 7261, 1, 0, 0, 0, 7343, 7266, 1, 0, 0, 0, 7343, 7273, 1,
		0, 0, 0, 7343, 7286, 1, 0, 0, 0, 7343, 7293, 1, 0, 0, 0, 7343, 7300, 1,
		0, 0, 0, 7343, 7305, 1, 0, 0, 0, 7343, 7314, 1, 0, 0, 0, 7343, 7323, 1,
		0, 0, 0, 7343, 7328, 1, 0, 0, 0, 7343, 7333, 1, 0, 0, 0, 7343, 7338, 1,
		0, 0, 0, 7344, 885, 1, 0, 0, 0, 7345, 7346, 5, 380, 0, 0, 7346, 7347, 5,
		2, 0, 0, 7347, 7443, 5, 4, 0, 0, 7348, 7349, 5, 344, 0, 0, 7349, 7350,
		5, 2, 0, 0, 7350, 7443, 5, 4, 0, 0, 7351, 7352, 5, 119, 0, 0, 7352, 7353,
		5, 2, 0, 0, 7353, 7443, 5, 4, 0, 0, 7354, 7355, 5, 93, 0, 0, 7355, 7356,
		5, 2, 0, 0, 7356, 7443, 5, 4, 0, 0, 7357, 7358, 5, 309, 0, 0, 7358, 7359,
		5, 2, 0, 0, 7359, 7443, 5, 4, 0, 0, 7360, 7361, 5, 124, 0, 0, 7361, 7363,
		5, 2, 0, 0, 7362, 7364, 3, 852, 426, 0, 7363, 7362, 1, 0, 0, 0, 7363, 7364,
		1, 0, 0, 0, 7364, 7365, 1, 0, 0, 0, 7365, 7443, 5, 4, 0, 0, 7366, 7367,
		5, 236, 0, 0, 7367, 7379, 5, 2, 0, 0, 7368, 7370, 3, 852, 426, 0, 7369,
		7371, 3, 892, 446, 0, 7370, 7369, 1, 0, 0, 0, 7370, 7371, 1, 0, 0, 0, 7371,
		7376, 1, 0, 0, 0, 7372, 7373, 5, 3, 0, 0, 7373, 7375, 3, 852, 426, 0, 7374,
		7372, 1, 0, 0, 0, 7375, 7378, 1, 0, 0, 0, 7376, 7374, 1, 0, 0, 0, 7376,
		7377, 1, 0, 0, 0, 7377, 7380, 1, 0, 0, 0, 7378, 7376, 1, 0, 0, 0, 7379,
		7368, 1, 0, 0, 0, 7379, 7380, 1, 0, 0, 0, 7380, 7381, 1, 0, 0, 0, 7381,
		7383, 5, 4, 0, 0, 7382, 7384, 3, 892, 446, 0, 7383, 7382, 1, 0, 0, 0, 7383,
		7384, 1, 0, 0, 0, 7384, 7443, 1, 0, 0, 0, 7385, 7386, 5, 231, 0, 0, 7386,
		7398, 5, 2, 0, 0, 7387, 7389, 3, 852, 426, 0, 7388, 7390, 3, 892, 446,
		0, 7389, 7388, 1, 0, 0, 0, 7389, 7390, 1, 0, 0, 0, 7390, 7395, 1, 0, 0,
		0, 7391, 7392, 5, 3, 0, 0, 7392, 7394, 3, 852, 426, 0, 7393, 7391, 1, 0,
		0, 0, 7394, 7397, 1, 0, 0, 0, 7395, 7393, 1, 0, 0, 0, 7395, 7396, 1, 0,
		0, 0, 7396, 7399, 1, 0, 0, 0, 7397, 7395, 1, 0, 0, 0, 7398, 7387, 1, 0,
		0, 0, 7398, 7399, 1, 0, 0, 0, 7399, 7400, 1, 0, 0, 0, 7400, 7402, 5, 4,
		0, 0, 7401, 7403, 3, 892, 446, 0, 7402, 7401, 1, 0, 0, 0, 7402, 7403, 1,
		0, 0, 0, 7403, 7443, 1, 0, 0, 0, 7404, 7405, 5, 162, 0, 0, 7405, 7417,
		5, 2, 0, 0, 7406, 7408, 3, 852, 426, 0, 7407, 7409, 3, 892, 446, 0, 7408,
		7407, 1, 0, 0, 0, 7408, 7409, 1, 0, 0, 0, 7409, 7414, 1, 0, 0, 0, 7410,
		7411, 5, 3, 0, 0, 7411, 7413, 3, 852, 426, 0, 7412, 7410, 1, 0, 0, 0, 7413,
		7416, 1, 0, 0, 0, 7414, 7412, 1, 0, 0, 0, 7414, 7415, 1, 0, 0, 0, 7415,
		7418, 1, 0, 0, 0, 7416, 7414, 1, 0, 0, 0, 7417, 7406, 1, 0, 0, 0, 7417,
		7418, 1, 0, 0, 0, 7418, 7419, 1, 0, 0, 0, 7419, 7421, 5, 4, 0, 0, 7420,
		7422, 3, 892, 446, 0, 7421, 7420, 1, 0, 0, 0, 7421, 7422, 1, 0, 0, 0, 7422,
		7443, 1, 0, 0, 0, 7423, 7424, 5, 234, 0, 0, 7424, 7436, 5, 2, 0, 0, 7425,
		7427, 3, 852, 426, 0, 7426, 7428, 3, 892, 446, 0, 7427, 7426, 1, 0, 0,
		0, 7427, 7428, 1, 0, 0, 0, 7428, 7433, 1, 0, 0, 0, 7429, 7430, 5, 3, 0,
		0, 7430, 7432, 3, 852, 426, 0, 7431, 7429, 1, 0, 0, 0, 7432, 7435, 1, 0,
		0, 0, 7433, 7431, 1, 0, 0, 0, 7433, 7434, 1, 0, 0, 0, 7434, 7437, 1, 0,
		0, 0, 7435, 7433, 1, 0, 0, 0, 7436, 7425, 1, 0, 0, 0, 7436, 7437, 1, 0,
		0, 0, 7437, 7438, 1, 0, 0, 0, 7438, 7440, 5, 4, 0, 0, 7439, 7441, 3, 892,
		446, 0, 7440, 7439, 1, 0, 0, 0, 7440, 7441, 1, 0, 0, 0, 7441, 7443, 1,
		0, 0, 0, 7442, 7345, 1, 0, 0, 0, 7442, 7348, 1, 0, 0, 0, 7442, 7351, 1,
		0, 0, 0, 7442, 7354, 1, 0, 0, 0, 7442, 7357, 1, 0, 0, 0, 7442, 7360, 1,
		0, 0, 0, 7442, 7366, 1, 0, 0, 0, 7442, 7385, 1, 0, 0, 0, 7442, 7404, 1,
		0, 0, 0, 7442, 7423, 1, 0, 0, 0, 7443, 887, 1, 0, 0, 0, 7444, 7445, 5,
		477, 0, 0, 7445, 7446, 3, 852, 426, 0, 7446, 7447, 5, 431, 0, 0, 7447,
		7448, 3, 852, 426, 0, 7448, 889, 1, 0, 0, 0, 7449, 7450, 5, 301, 0, 0,
		7450, 7464, 5, 2, 0, 0, 7451, 7453, 3, 818, 409, 0, 7452, 7451, 1, 0, 0,
		0, 7452, 7453, 1, 0, 0, 0, 7453, 7454, 1, 0, 0, 0, 7454, 7455, 5, 303,
		0, 0, 7455, 7456, 5, 55, 0, 0, 7456, 7461, 3, 852, 426, 0, 7457, 7458,
		5, 3, 0, 0, 7458, 7460, 3, 852, 426, 0, 7459, 7457, 1, 0, 0, 0, 7460, 7463,
		1, 0, 0, 0, 7461, 7459, 1, 0, 0, 0, 7461, 7462, 1, 0, 0, 0, 7462, 7465,
		1, 0, 0, 0, 7463, 7461, 1, 0, 0, 0, 7464, 7452, 1, 0, 0, 0, 7464, 7465,
		1, 0, 0, 0, 7465, 7476, 1, 0, 0, 0, 7466, 7467, 5, 298, 0, 0, 7467, 7468,
		5, 55, 0, 0, 7468, 7473, 3, 770, 385, 0, 7469, 7470, 5, 3, 0, 0, 7470,
		7472, 3, 770, 385, 0, 7471, 7469, 1, 0, 0, 0, 7472, 7475, 1, 0, 0, 0, 7473,
		7471, 1, 0, 0, 0, 7473, 7474, 1, 0, 0, 0, 7474, 7477, 1, 0, 0, 0, 7475,
		7473, 1, 0, 0, 0, 7476, 7466, 1, 0, 0, 0, 7476, 7477, 1, 0, 0, 0, 7477,
		7479, 1, 0, 0, 0, 7478, 7480, 3, 894, 447, 0, 7479, 7478, 1, 0, 0, 0, 7479,
		7480, 1, 0, 0, 0, 7480, 7481, 1, 0, 0, 0, 7481, 7482, 5, 4, 0, 0, 7482,
		891, 1, 0, 0, 0, 7483, 7484, 5, 200, 0, 0, 7484, 7485, 5, 283, 0, 0, 7485,
		893, 1, 0, 0, 0, 7486, 7487, 5, 343, 0, 0, 7487, 7503, 3, 896, 448, 0,
		7488, 7489, 5, 379, 0, 0, 7489, 7503, 3, 896, 448, 0, 7490, 7491, 5, 343,
		0, 0, 7491, 7492, 5, 41, 0, 0, 7492, 7493, 3, 896, 448, 0, 7493, 7494,
		5, 21, 0, 0, 7494, 7495, 3, 896, 448, 0, 7495, 7503, 1, 0, 0, 0, 7496,
		7497, 5, 379, 0, 0, 7497, 7498, 5, 41, 0, 0, 7498, 7499, 3, 896, 448, 0,
		7499, 7500, 5, 21, 0, 0, 7500, 7501, 3, 896, 448, 0, 7501, 7503, 1, 0,
		0, 0, 7502, 7486, 1, 0, 0, 0, 7502, 7488, 1, 0, 0, 0, 7502, 7490, 1, 0,
		0, 0, 7502, 7496, 1, 0, 0, 0, 7503, 895, 1, 0, 0, 0, 7504, 7505, 5, 448,
		0, 0, 7505, 7514, 5, 320, 0, 0, 7506, 7507, 5, 448, 0, 0, 7507, 7514, 5,
		166, 0, 0, 7508, 7509, 5, 95, 0, 0, 7509, 7514, 5, 378, 0, 0, 7510, 7511,
		3, 852, 426, 0, 7511, 7512, 7, 46, 0, 0, 7512, 7514, 1, 0, 0, 0, 7513,
		7504, 1, 0, 0, 0, 7513, 7506, 1, 0, 0, 0, 7513, 7508, 1, 0, 0, 0, 7513,
		7510, 1, 0, 0, 0, 7514, 897, 1, 0, 0, 0, 7515, 7555, 3, 902, 451, 0, 7516,
		7517, 5, 18, 0, 0, 7517, 7525, 7, 47, 0, 0, 7518, 7519, 7, 47, 0, 0, 7519,
		7522, 3, 1012, 506, 0, 7520, 7521, 5, 27, 0, 0, 7521, 7523, 3, 1018, 509,
		0, 7522, 7520, 1, 0, 0, 0, 7522, 7523, 1, 0, 0, 0, 7523, 7525, 1, 0, 0,
		0, 7524, 7516, 1, 0, 0, 0, 7524, 7518, 1, 0, 0, 0, 7525, 7555, 1, 0, 0,
		0, 7526, 7527, 5, 18, 0, 0, 7527, 7531, 7, 48, 0, 0, 7528, 7529, 7, 48,
		0, 0, 7529, 7531, 3, 902, 451, 0, 7530, 7526, 1, 0, 0, 0, 7530, 7528, 1,
		0, 0, 0, 7531, 7555, 1, 0, 0, 0, 7532, 7533, 5, 18, 0, 0, 7533, 7534, 5,
		257, 0, 0, 7534, 7543, 7, 49, 0, 0, 7535, 7536, 5, 257, 0, 0, 7536, 7537,
		7, 49, 0, 0, 7537, 7540, 3, 1012, 506, 0, 7538, 7539, 5, 27, 0, 0, 7539,
		7541, 3, 1018, 509, 0, 7540, 7538, 1, 0, 0, 0, 7540, 7541, 1, 0, 0, 0,
		7541, 7543, 1, 0, 0, 0, 7542, 7532, 1, 0, 0, 0, 7542, 7535, 1, 0, 0, 0,
		7543, 7555, 1, 0, 0, 0, 7544, 7545, 5, 18, 0, 0, 7545, 7553, 7, 49, 0,
		0, 7546, 7547, 7, 49, 0, 0, 7547, 7550, 3, 1012, 506, 0, 7548, 7549, 5,
		27, 0, 0, 7549, 7551, 3, 1018, 509, 0, 7550, 7548, 1, 0, 0, 0, 7550, 7551,
		1, 0, 0, 0, 7551, 7553, 1, 0, 0, 0, 7552, 7544, 1, 0, 0, 0, 7552, 7546,
		1, 0, 0, 0, 7553, 7555, 1, 0, 0, 0, 7554, 7515, 1, 0, 0, 0, 7554, 7524,
		1, 0, 0, 0, 7554, 7530, 1, 0, 0, 0, 7554, 7542, 1, 0, 0, 0, 7554, 7552,
		1, 0, 0, 0, 7555, 899, 1, 0, 0, 0, 7556, 7558, 3, 1012, 506, 0, 7557, 7559,
		3, 826, 413, 0, 7558, 7557, 1, 0, 0, 0, 7558, 7559, 1, 0, 0, 0, 7559, 901,
		1, 0, 0, 0, 7560, 7562, 3, 1012, 506, 0, 7561, 7563, 3, 826, 413, 0, 7562,
		7561, 1, 0, 0, 0, 7562, 7563, 1, 0, 0, 0, 7563, 7566, 1, 0, 0, 0, 7564,
		7565, 5, 27, 0, 0, 7565, 7567, 3, 1018, 509, 0, 7566, 7564, 1, 0, 0, 0,
		7566, 7567, 1, 0, 0, 0, 7567, 903, 1, 0, 0, 0, 7568, 7570, 7, 50, 0, 0,
		7569, 7571, 7, 51, 0, 0, 7570, 7569, 1, 0, 0, 0, 7570, 7571, 1, 0, 0, 0,
		7571, 905, 1, 0, 0, 0, 7572, 7573, 5, 441, 0, 0, 7573, 7575, 7, 52, 0,
		0, 7574, 7576, 3, 1018, 509, 0, 7575, 7574, 1, 0, 0, 0, 7575, 7576, 1,
		0, 0, 0, 7576, 907, 1, 0, 0, 0, 7577, 7580, 3, 1018, 509, 0, 7578, 7580,
		3, 870, 435, 0, 7579, 7577, 1, 0, 0, 0, 7579, 7578, 1, 0, 0, 0, 7580, 909,
		1, 0, 0, 0, 7581, 7582, 5, 303, 0, 0, 7582, 7583, 5, 55, 0, 0, 7583, 7584,
		5, 343, 0, 0, 7584, 7585, 3, 1024, 512, 0, 7585, 7594, 5, 2, 0, 0, 7586,
		7591, 3, 930, 465, 0, 7587, 7588, 5, 3, 0, 0, 7588, 7590, 3, 930, 465,
		0, 7589, 7587, 1, 0, 0, 0, 7590, 7593, 1, 0, 0, 0, 7591, 7589, 1, 0, 0,
		0, 7591, 7592, 1, 0, 0, 0, 7592, 7595, 1, 0, 0, 0, 7593, 7591, 1, 0, 0,
		0, 7594, 7586, 1, 0, 0, 0, 7594, 7595, 1, 0, 0, 0, 7595, 7596, 1, 0, 0,
		0, 7596, 7597, 5, 4, 0, 0, 7597, 7670, 1, 0, 0, 0, 7598, 7599, 5, 303,
		0, 0, 7599, 7600, 5, 55, 0, 0, 7600, 7601, 5, 343, 0, 0, 7601, 7602, 3,
		866, 433, 0, 7602, 7611, 5, 2, 0, 0, 7603, 7608, 3, 930, 465, 0, 7604,
		7605, 5, 3, 0, 0, 7605, 7607, 3, 930, 465, 0, 7606, 7604, 1, 0, 0, 0, 7607,
		7610, 1, 0, 0, 0, 7608, 7606, 1, 0, 0, 0, 7608, 7609, 1, 0, 0, 0, 7609,
		7612, 1, 0, 0, 0, 7610, 7608, 1, 0, 0, 0, 7611, 7603, 1, 0, 0, 0, 7611,
		7612, 1, 0, 0, 0, 7612, 7613, 1, 0, 0, 0, 7613, 7614, 5, 4, 0, 0, 7614,
		7670, 1, 0, 0, 0, 7615, 7616, 5, 303, 0, 0, 7616, 7618, 5, 55, 0, 0, 7617,
		7619, 5, 242, 0, 0, 7618, 7617, 1, 0, 0, 0, 7618, 7619, 1, 0, 0, 0, 7619,
		7620, 1, 0, 0, 0, 7620, 7621, 3, 1024, 512, 0, 7621, 7630, 5, 2, 0, 0,
		7622, 7627, 3, 912, 456, 0, 7623, 7624, 5, 3, 0, 0, 7624, 7626, 3, 912,
		456, 0, 7625, 7623, 1, 0, 0, 0, 7626, 7629, 1, 0, 0, 0, 7627, 7625, 1,
		0, 0, 0, 7627, 7628, 1, 0, 0, 0, 7628, 7631, 1, 0, 0, 0, 7629, 7627, 1,
		0, 0, 0, 7630, 7622, 1, 0, 0, 0, 7630, 7631, 1, 0, 0, 0, 7631, 7632, 1,
		0, 0, 0, 7632, 7633, 5, 4, 0, 0, 7633, 7670, 1, 0, 0, 0, 7634, 7635, 5,
		303, 0, 0, 7635, 7637, 5, 55, 0, 0, 7636, 7638, 5, 242, 0, 0, 7637, 7636,
		1, 0, 0, 0, 7637, 7638, 1, 0, 0, 0, 7638, 7639, 1, 0, 0, 0, 7639, 7670,
		3, 1024, 512, 0, 7640, 7641, 5, 303, 0, 0, 7641, 7642, 5, 55, 0, 0, 7642,
		7643, 3, 870, 435, 0, 7643, 7652, 5, 2, 0, 0, 7644, 7649, 3, 930, 465,
		0, 7645, 7646, 5, 3, 0, 0, 7646, 7648, 3, 930, 465, 0, 7647, 7645, 1, 0,
		0, 0, 7648, 7651, 1, 0, 0, 0, 7649, 7647, 1, 0, 0, 0, 7649, 7650, 1, 0,
		0, 0, 7650, 7653, 1, 0, 0, 0, 7651, 7649, 1, 0, 0, 0, 7652, 7644, 1, 0,
		0, 0, 7652, 7653, 1, 0, 0, 0, 7653, 7654, 1, 0, 0, 0, 7654, 7655, 5, 4,
		0, 0, 7655, 7670, 1, 0, 0, 0, 7656, 7657, 5, 303, 0, 0, 7657, 7658, 5,
		55, 0, 0, 7658, 7670, 3, 870, 435, 0, 7659, 7660, 5, 303, 0, 0, 7660, 7661,
		5, 55, 0, 0, 7661, 7666, 3, 908, 454, 0, 7662, 7663, 5, 3, 0, 0, 7663,
		7665, 3, 908, 454, 0, 7664, 7662, 1, 0, 0, 0, 7665, 7668, 1, 0, 0, 0, 7666,
		7664, 1, 0, 0, 0, 7666, 7667, 1, 0, 0, 0, 7667, 7670, 1, 0, 0, 0, 7668,
		7666, 1, 0, 0, 0, 7669, 7581, 1, 0, 0, 0, 7669, 7598, 1, 0, 0, 0, 7669,
		7615, 1, 0, 0, 0, 7669, 7634, 1, 0, 0, 0, 7669, 7640, 1, 0, 0, 0, 7669,
		7656, 1, 0, 0, 0, 7669, 7659, 1, 0, 0, 0, 7670, 911, 1, 0, 0, 0, 7671,
		7674, 3, 914, 457, 0, 7672, 7674, 3, 916, 458, 0, 7673, 7671, 1, 0, 0,
		0, 7673, 7672, 1, 0, 0, 0, 7674, 913, 1, 0, 0, 0, 7675, 7679, 5, 303, 0,
		0, 7676, 7677, 5, 197, 0, 0, 7677, 7678, 5, 281, 0, 0, 7678, 7680, 5, 148,
		0, 0, 7679, 7676, 1, 0, 0, 0, 7679, 7680, 1, 0, 0, 0, 7680, 7681, 1, 0,
		0, 0, 7681, 7682, 3, 1018, 509, 0, 7682, 7683, 5, 462, 0, 0, 7683, 7684,
		5, 202, 0, 0, 7684, 7686, 3, 920, 460, 0, 7685, 7687, 3, 958, 479, 0, 7686,
		7685, 1, 0, 0, 0, 7686, 7687, 1, 0, 0, 0, 7687, 915, 1, 0, 0, 0, 7688,
		7692, 5, 303, 0, 0, 7689, 7690, 5, 197, 0, 0, 7690, 7691, 5, 281, 0, 0,
		7691, 7693, 5, 148, 0, 0, 7692, 7689, 1, 0, 0, 0, 7692, 7693, 1, 0, 0,
		0, 7693, 7694, 1, 0, 0, 0, 7694, 7695, 3, 1018, 509, 0, 7695, 7696, 5,
		462, 0, 0, 7696, 7697, 5, 202, 0, 0, 7697, 7699, 3, 918, 459, 0, 7698,
		7700, 3, 958, 479, 0, 7699, 7698, 1, 0, 0, 0, 7699, 7700, 1, 0, 0, 0, 7700,
		917, 1, 0, 0, 0, 7701, 7702, 5, 2, 0, 0, 7702, 7707, 3, 920, 460, 0, 7703,
		7704, 5, 3, 0, 0, 7704, 7706, 3, 920, 460, 0, 7705, 7703, 1, 0, 0, 0, 7706,
		7709, 1, 0, 0, 0, 7707, 7705, 1, 0, 0, 0, 7707, 7708, 1, 0, 0, 0, 7708,
		7710, 1, 0, 0, 0, 7709, 7707, 1, 0, 0, 0, 7710, 7711, 5, 4, 0, 0, 7711,
		919, 1, 0, 0, 0, 7712, 7713, 5, 2, 0, 0, 7713, 7718, 3, 924, 462, 0, 7714,
		7715, 5, 3, 0, 0, 7715, 7717, 3, 924, 462, 0, 7716, 7714, 1, 0, 0, 0, 7717,
		7720, 1, 0, 0, 0, 7718, 7716, 1, 0, 0, 0, 7718, 7719, 1, 0, 0, 0, 7719,
		7721, 1, 0, 0, 0, 7720, 7718, 1, 0, 0, 0, 7721, 7722, 5, 4, 0, 0, 7722,
		921, 1, 0, 0, 0, 7723, 7726, 3, 920, 460, 0, 7724, 7726, 3, 918, 459, 0,
		7725, 7723, 1, 0, 0, 0, 7725, 7724, 1, 0, 0, 0, 7726, 923, 1, 0, 0, 0,
		7727, 7730, 5, 282, 0, 0, 7728, 7730, 3, 976, 488, 0, 7729, 7727, 1, 0,
		0, 0, 7729, 7728, 1, 0, 0, 0, 7730, 925, 1, 0, 0, 0, 7731, 7732, 5, 2,
		0, 0, 7732, 7737, 3, 976, 488, 0, 7733, 7734, 5, 3, 0, 0, 7734, 7736, 3,
		976, 488, 0, 7735, 7733, 1, 0, 0, 0, 7736, 7739, 1, 0, 0, 0, 7737, 7735,
		1, 0, 0, 0, 7737, 7738, 1, 0, 0, 0, 7738, 7740, 1, 0, 0, 0, 7739, 7737,
		1, 0, 0, 0, 7740, 7741, 5, 4, 0, 0, 7741, 927, 1, 0, 0, 0, 7742, 7743,
		5, 2, 0, 0, 7743, 7748, 3, 868, 434, 0, 7744, 7745, 5, 3, 0, 0, 7745, 7747,
		3, 868, 434, 0, 7746, 7744, 1, 0, 0, 0, 7747, 7750, 1, 0, 0, 0, 7748, 7746,
		1, 0, 0, 0, 7748, 7749, 1, 0, 0, 0, 7749, 7751, 1, 0, 0, 0, 7750, 7748,
		1, 0, 0, 0, 7751, 7752, 5, 4, 0, 0, 7752, 929, 1, 0, 0, 0, 7753, 7756,
		3, 932, 466, 0, 7754, 7756, 3, 934, 467, 0, 7755, 7753, 1, 0, 0, 0, 7755,
		7754, 1, 0, 0, 0, 7756, 931, 1, 0, 0, 0, 7757, 7761, 5, 303, 0, 0, 7758,
		7759, 5, 197, 0, 0, 7759, 7760, 5, 281, 0, 0, 7760, 7762, 5, 148, 0, 0,
		7761, 7758, 1, 0, 0, 0, 7761, 7762, 1, 0, 0, 0, 7762, 7763, 1, 0, 0, 0,
		7763, 7764, 3, 1018, 509, 0, 7764, 7765, 5, 462, 0, 0, 7765, 7767, 3, 938,
		469, 0, 7766, 7768, 3, 958, 479, 0, 7767, 7766, 1, 0, 0, 0, 7767, 7768,
		1, 0, 0, 0, 7768, 933, 1, 0, 0, 0, 7769, 7770, 5, 406, 0, 0, 7770, 7771,
		5, 2, 0, 0, 7771, 7772, 3, 976, 488, 0, 7772, 7773, 5, 4, 0, 0, 7773, 7774,
		5, 139, 0, 0, 7774, 7775, 5, 2, 0, 0, 7775, 7776, 3, 976, 488, 0, 7776,
		7777, 5, 4, 0, 0, 7777, 7778, 5, 153, 0, 0, 7778, 7779, 5, 2, 0, 0, 7779,
		7780, 3, 984, 492, 0, 7780, 7781, 5, 4, 0, 0, 7781, 7796, 1, 0, 0, 0, 7782,
		7783, 5, 406, 0, 0, 7783, 7784, 5, 2, 0, 0, 7784, 7785, 3, 976, 488, 0,
		7785, 7786, 5, 4, 0, 0, 7786, 7787, 5, 139, 0, 0, 7787, 7788, 5, 2, 0,
		0, 7788, 7789, 3, 976, 488, 0, 7789, 7790, 5, 4, 0, 0, 7790, 7791, 5, 153,
		0, 0, 7791, 7792, 5, 2, 0, 0, 7792, 7793, 5, 518, 0, 0, 7793, 7794, 5,
		4, 0, 0, 7794, 7796, 1, 0, 0, 0, 7795, 7769, 1, 0, 0, 0, 7795, 7782, 1,
		0, 0, 0, 7796, 935, 1, 0, 0, 0, 7797, 7798, 5, 406, 0, 0, 7798, 7799, 5,
		2, 0, 0, 7799, 7800, 3, 976, 488, 0, 7800, 7801, 5, 4, 0, 0, 7801, 7802,
		5, 139, 0, 0, 7802, 7803, 5, 2, 0, 0, 7803, 7804, 3, 976, 488, 0, 7804,
		7805, 5, 4, 0, 0, 7805, 937, 1, 0, 0, 0, 7806, 7807, 5, 238, 0, 0, 7807,
		7810, 5, 430, 0, 0, 7808, 7811, 5, 259, 0, 0, 7809, 7811, 3, 940, 470,
		0, 7810, 7808, 1, 0, 0, 0, 7810, 7809, 1, 0, 0, 0, 7811, 7819, 1, 0, 0,
		0, 7812, 7813, 5, 6, 0, 0, 7813, 7814, 3, 940, 470, 0, 7814, 7815, 5, 3,
		0, 0, 7815, 7816, 3, 940, 470, 0, 7816, 7817, 5, 4, 0, 0, 7817, 7819, 1,
		0, 0, 0, 7818, 7806, 1, 0, 0, 0, 7818, 7812, 1, 0, 0, 0, 7819, 939, 1,
		0, 0, 0, 7820, 7821, 5, 2, 0, 0, 7821, 7826, 3, 944, 472, 0, 7822, 7823,
		5, 3, 0, 0, 7823, 7825, 3, 944, 472, 0, 7824, 7822, 1, 0, 0, 0, 7825, 7828,
		1, 0, 0, 0, 7826, 7824, 1, 0, 0, 0, 7826, 7827, 1, 0, 0, 0, 7827, 7829,
		1, 0, 0, 0, 7828, 7826, 1, 0, 0, 0, 7829, 7830, 5, 4, 0, 0, 7830, 941,
		1, 0, 0, 0, 7831, 7832, 3, 1018, 509, 0, 7832, 7833, 5, 492, 0, 0, 7833,
		7834, 3, 868, 434, 0, 7834, 943, 1, 0, 0, 0, 7835, 7838, 5, 259, 0, 0,
		7836, 7838, 3, 976, 488, 0, 7837, 7835, 1, 0, 0, 0, 7837, 7836, 1, 0, 0,
		0, 7838, 945, 1, 0, 0, 0, 7839, 7840, 5, 129, 0, 0, 7840, 7841, 5, 55,
		0, 0, 7841, 7842, 5, 186, 0, 0, 7842, 7845, 3, 1024, 512, 0, 7843, 7844,
		5, 53, 0, 0, 7844, 7846, 5, 518, 0, 0, 7845, 7843, 1, 0, 0, 0, 7845, 7846,
		1, 0, 0, 0, 7846, 7852, 1, 0, 0, 0, 7847, 7848, 5, 129, 0, 0, 7848, 7849,
		5, 55, 0, 0, 7849, 7850, 5, 186, 0, 0, 7850, 7852, 3, 1024, 512, 0, 7851,
		7839, 1, 0, 0, 0, 7851, 7847, 1, 0, 0, 0, 7852, 947, 1, 0, 0, 0, 7853,
		7854, 5, 129, 0, 0, 7854, 7855, 5, 55, 0, 0, 7855, 7856, 5, 186, 0, 0,
		7856, 7859, 3, 1024, 512, 0, 7857, 7858, 5, 53, 0, 0, 7858, 7860, 5, 518,
		0, 0, 7859, 7857, 1, 0, 0, 0, 7859, 7860, 1, 0, 0, 0, 7860, 7873, 1, 0,
		0, 0, 7861, 7862, 5, 129, 0, 0, 7862, 7863, 5, 55, 0, 0, 7863, 7864, 5,
		186, 0, 0, 7864, 7873, 3, 1024, 512, 0, 7865, 7866, 5, 129, 0, 0, 7866,
		7867, 5, 55, 0, 0, 7867, 7870, 5, 342, 0, 0, 7868, 7869, 5, 53, 0, 0, 7869,
		7871, 5, 518, 0, 0, 7870, 7868, 1, 0, 0, 0, 7870, 7871, 1, 0, 0, 0, 7871,
		7873, 1, 0, 0, 0, 7872, 7853, 1, 0, 0, 0, 7872, 7861, 1, 0, 0, 0, 7872,
		7865, 1, 0, 0, 0, 7873, 949, 1, 0, 0, 0, 7874, 7876, 5, 348, 0, 0, 7875,
		7877, 7, 53, 0, 0, 7876, 7875, 1, 0, 0, 0, 7876, 7877, 1, 0, 0, 0, 7877,
		7894, 1, 0, 0, 0, 7878, 7895, 5, 29, 0, 0, 7879, 7885, 5, 29, 0, 0, 7880,
		7881, 5, 406, 0, 0, 7881, 7882, 5, 2, 0, 0, 7882, 7883, 3, 976, 488, 0,
		7883, 7884, 5, 4, 0, 0, 7884, 7886, 1, 0, 0, 0, 7885, 7880, 1, 0, 0, 0,
		7885, 7886, 1, 0, 0, 0, 7886, 7887, 1, 0, 0, 0, 7887, 7888, 5, 153, 0,
		0, 7888, 7889, 5, 2, 0, 0, 7889, 7890, 3, 984, 492, 0, 7890, 7891, 5, 4,
		0, 0, 7891, 7895, 1, 0, 0, 0, 7892, 7895, 5, 204, 0, 0, 7893, 7895, 5,
		251, 0, 0, 7894, 7878, 1, 0, 0, 0, 7894, 7879, 1, 0, 0, 0, 7894, 7892,
		1, 0, 0, 0, 7894, 7893, 1, 0, 0, 0, 7895, 951, 1, 0, 0, 0, 7896, 7897,
		7, 54, 0, 0, 7897, 953, 1, 0, 0, 0, 7898, 7899, 5, 332, 0, 0, 7899, 7900,
		5, 2, 0, 0, 7900, 7905, 3, 962, 481, 0, 7901, 7902, 5, 3, 0, 0, 7902, 7904,
		3, 962, 481, 0, 7903, 7901, 1, 0, 0, 0, 7904, 7907, 1, 0, 0, 0, 7905, 7903,
		1, 0, 0, 0, 7905, 7906, 1, 0, 0, 0, 7906, 7908, 1, 0, 0, 0, 7907, 7905,
		1, 0, 0, 0, 7908, 7909, 5, 4, 0, 0, 7909, 955, 1, 0, 0, 0, 7910, 7911,
		5, 52, 0, 0, 7911, 7912, 3, 954, 477, 0, 7912, 957, 1, 0, 0, 0, 7913, 7914,
		5, 2, 0, 0, 7914, 7919, 3, 962, 481, 0, 7915, 7916, 5, 3, 0, 0, 7916, 7918,
		3, 962, 481, 0, 7917, 7915, 1, 0, 0, 0, 7918, 7921, 1, 0, 0, 0, 7919, 7917,
		1, 0, 0, 0, 7919, 7920, 1, 0, 0, 0, 7920, 7922, 1, 0, 0, 0, 7921, 7919,
		1, 0, 0, 0, 7922, 7923, 5, 4, 0, 0, 7923, 959, 1, 0, 0, 0, 7924, 7929,
		3, 962, 481, 0, 7925, 7926, 5, 3, 0, 0, 7926, 7928, 3, 962, 481, 0, 7927,
		7925, 1, 0, 0, 0, 7928, 7931, 1, 0, 0, 0, 7929, 7927, 1, 0, 0, 0, 7929,
		7930, 1, 0, 0, 0, 7930, 961, 1, 0, 0, 0, 7931, 7929, 1, 0, 0, 0, 7932,
		7933, 3, 976, 488, 0, 7933, 7934, 5, 492, 0, 0, 7934, 7935, 3, 976, 488,
		0, 7935, 963, 1, 0, 0, 0, 7936, 7940, 3, 966, 483, 0, 7937, 7939, 3, 966,
		483, 0, 7938, 7937, 1, 0, 0, 0, 7939, 7942, 1, 0, 0, 0, 7940, 7938, 1,
		0, 0, 0, 7940, 7941, 1, 0, 0, 0, 7941, 965, 1, 0, 0, 0, 7942, 7940, 1,
		0, 0, 0, 7943, 7944, 3, 1018, 509, 0, 7944, 7945, 5, 492, 0, 0, 7945, 7946,
		3, 976, 488, 0, 7946, 967, 1, 0, 0, 0, 7947, 7948, 7, 55, 0, 0, 7948, 969,
		1, 0, 0, 0, 7949, 7950, 5, 78, 0, 0, 7950, 7951, 3, 976, 488, 0, 7951,
		971, 1, 0, 0, 0, 7952, 7953, 5, 218, 0, 0, 7953, 7954, 5, 300, 0, 0, 7954,
		7956, 3, 976, 488, 0, 7955, 7957, 3, 974, 487, 0, 7956, 7955, 1, 0, 0,
		0, 7956, 7957, 1, 0, 0, 0, 7957, 7959, 1, 0, 0, 0, 7958, 7960, 3, 954,
		477, 0, 7959, 7958, 1, 0, 0, 0, 7959, 7960, 1, 0, 0, 0, 7960, 973, 1, 0,
		0, 0, 7961, 7962, 5, 170, 0, 0, 7962, 7965, 5, 27, 0, 0, 7963, 7966, 3,
		1018, 509, 0, 7964, 7966, 3, 976, 488, 0, 7965, 7963, 1, 0, 0, 0, 7965,
		7964, 1, 0, 0, 0, 7966, 975, 1, 0, 0, 0, 7967, 7968, 7, 56, 0, 0, 7968,
		977, 1, 0, 0, 0, 7969, 7970, 7, 57, 0, 0, 7970, 979, 1, 0, 0, 0, 7971,
		7972, 7, 58, 0, 0, 7972, 981, 1, 0, 0, 0, 7973, 7974, 7, 59, 0, 0, 7974,
		983, 1, 0, 0, 0, 7975, 7976, 5, 217, 0, 0, 7976, 7977, 3, 852, 426, 0,
		7977, 7978, 3, 990, 495, 0, 7978, 985, 1, 0, 0, 0, 7979, 7980, 5, 217,
		0, 0, 7980, 7981, 3, 852, 426, 0, 7981, 7982, 3, 988, 494, 0, 7982, 987,
		1, 0, 0, 0, 7983, 7984, 7, 60, 0, 0, 7984, 989, 1, 0, 0, 0, 7985, 7986,
		7, 61, 0, 0, 7986, 991, 1, 0, 0, 0, 7987, 7988, 7, 62, 0, 0, 7988, 993,
		1, 0, 0, 0, 7989, 7995, 3, 1008, 504, 0, 7990, 7995, 3, 1010, 505, 0, 7991,
		7995, 3, 996, 498, 0, 7992, 7995, 3, 1004, 502, 0, 7993, 7995, 3, 998,
		499, 0, 7994, 7989, 1, 0, 0, 0, 7994, 7990, 1, 0, 0, 0, 7994, 7991, 1,
		0, 0, 0, 7994, 7992, 1, 0, 0, 0, 7994, 7993, 1, 0, 0, 0, 7995, 995, 1,
		0, 0, 0, 7996, 7997, 5, 24, 0, 0, 7997, 7998, 5, 494, 0, 0, 7998, 7999,
		3, 994, 497, 0, 7999, 8000, 5, 496, 0, 0, 8000, 997, 1, 0, 0, 0, 8001,
		8002, 5, 252, 0, 0, 8002, 8003, 5, 494, 0, 0, 8003, 8004, 3, 994, 497,
		0, 8004, 8005, 5, 3, 0, 0, 8005, 8006, 3, 994, 497, 0, 8006, 8007, 5, 496,
		0, 0, 8007, 999, 1, 0, 0, 0, 8008, 8011, 3, 1018, 509, 0, 8009, 8011, 3,
		304, 152, 0, 8010, 8008, 1, 0, 0, 0, 8010, 8009, 1, 0, 0, 0, 8011, 8012,
		1, 0, 0, 0, 8012, 8013, 3, 994, 497, 0, 8013, 1001, 1, 0, 0, 0, 8014, 8019,
		3, 1000, 500, 0, 8015, 8016, 5, 3, 0, 0, 8016, 8018, 3, 1000, 500, 0, 8017,
		8015, 1, 0, 0, 0, 8018, 8021, 1, 0, 0, 0, 8019, 8017, 1, 0, 0, 0, 8019,
		8020, 1, 0, 0, 0, 8020, 1003, 1, 0, 0, 0, 8021, 8019, 1, 0, 0, 0, 8022,
		8023, 5, 421, 0, 0, 8023, 8024, 5, 494, 0, 0, 8024, 8025, 3, 1002, 501,
		0, 8025, 8026, 5, 496, 0, 0, 8026, 1005, 1, 0, 0, 0, 8027, 8028, 5, 2,
		0, 0, 8028, 8029, 5, 518, 0, 0, 8029, 8030, 5, 4, 0, 0, 8030, 1007, 1,
		0, 0, 0, 8031, 8100, 5, 49, 0, 0, 8032, 8034, 5, 437, 0, 0, 8033, 8035,
		3, 1006, 503, 0, 8034, 8033, 1, 0, 0, 0, 8034, 8035, 1, 0, 0, 0, 8035,
		8100, 1, 0, 0, 0, 8036, 8038, 5, 402, 0, 0, 8037, 8039, 3, 1006, 503, 0,
		8038, 8037, 1, 0, 0, 0, 8038, 8039, 1, 0, 0, 0, 8039, 8100, 1, 0, 0, 0,
		8040, 8042, 5, 399, 0, 0, 8041, 8043, 5, 211, 0, 0, 8042, 8041, 1, 0, 0,
		0, 8042, 8043, 1, 0, 0, 0, 8043, 8100, 1, 0, 0, 0, 8044, 8046, 5, 399,
		0, 0, 8045, 8047, 5, 212, 0, 0, 8046, 8045, 1, 0, 0, 0, 8046, 8047, 1,
		0, 0, 0, 8047, 8100, 1, 0, 0, 0, 8048, 8050, 5, 454, 0, 0, 8049, 8051,
		5, 211, 0, 0, 8050, 8049, 1, 0, 0, 0, 8050, 8051, 1, 0, 0, 0, 8051, 8100,
		1, 0, 0, 0, 8052, 8054, 5, 454, 0, 0, 8053, 8055, 5, 212, 0, 0, 8054, 8053,
		1, 0, 0, 0, 8054, 8055, 1, 0, 0, 0, 8055, 8100, 1, 0, 0, 0, 8056, 8058,
		5, 211, 0, 0, 8057, 8059, 3, 1006, 503, 0, 8058, 8057, 1, 0, 0, 0, 8058,
		8059, 1, 0, 0, 0, 8059, 8100, 1, 0, 0, 0, 8060, 8062, 5, 212, 0, 0, 8061,
		8063, 3, 1006, 503, 0, 8062, 8061, 1, 0, 0, 0, 8062, 8063, 1, 0, 0, 0,
		8063, 8100, 1, 0, 0, 0, 8064, 8066, 5, 42, 0, 0, 8065, 8067, 3, 1006, 503,
		0, 8066, 8065, 1, 0, 0, 0, 8066, 8067, 1, 0, 0, 0, 8067, 8100, 1, 0, 0,
		0, 8068, 8070, 5, 232, 0, 0, 8069, 8071, 3, 1006, 503, 0, 8070, 8069, 1,
		0, 0, 0, 8070, 8071, 1, 0, 0, 0, 8071, 8100, 1, 0, 0, 0, 8072, 8100, 5,
		163, 0, 0, 8073, 8100, 5, 131, 0, 0, 8074, 8100, 5, 106, 0, 0, 8075, 8100,
		5, 107, 0, 0, 8076, 8100, 5, 432, 0, 0, 8077, 8079, 5, 64, 0, 0, 8078,
		8080, 3, 1006, 503, 0, 8079, 8078, 1, 0, 0, 0, 8079, 8080, 1, 0, 0, 0,
		8080, 8100, 1, 0, 0, 0, 8081, 8083, 5, 464, 0, 0, 8082, 8084, 3, 1006,
		503, 0, 8083, 8082, 1, 0, 0, 0, 8083, 8084, 1, 0, 0, 0, 8084, 8100, 1,
		0, 0, 0, 8085, 8100, 5, 412, 0, 0, 8086, 8100, 5, 413, 0, 0, 8087, 8100,
		5, 44, 0, 0, 8088, 8100, 5, 190, 0, 0, 8089, 8100, 5, 310, 0, 0, 8090,
		8100, 5, 226, 0, 0, 8091, 8093, 5, 463, 0, 0, 8092, 8094, 3, 1006, 503,
		0, 8093, 8092, 1, 0, 0, 0, 8093, 8094, 1, 0, 0, 0, 8094, 8100, 1, 0, 0,
		0, 8095, 8097, 5, 43, 0, 0, 8096, 8098, 3, 1006, 503, 0, 8097, 8096, 1,
		0, 0, 0, 8097, 8098, 1, 0, 0, 0, 8098, 8100, 1, 0, 0, 0, 8099, 8031, 1,
		0, 0, 0, 8099, 8032, 1, 0, 0, 0, 8099, 8036, 1, 0, 0, 0, 8099, 8040, 1,
		0, 0, 0, 8099, 8044, 1, 0, 0, 0, 8099, 8048, 1, 0, 0, 0, 8099, 8052, 1,
		0, 0, 0, 8099, 8056, 1, 0, 0, 0, 8099, 8060, 1, 0, 0, 0, 8099, 8064, 1,
		0, 0, 0, 8099, 8068, 1, 0, 0, 0, 8099, 8072, 1, 0, 0, 0, 8099, 8073, 1,
		0, 0, 0, 8099, 8074, 1, 0, 0, 0, 8099, 8075, 1, 0, 0, 0, 8099, 8076, 1,
		0, 0, 0, 8099, 8077, 1, 0, 0, 0, 8099, 8081, 1, 0, 0, 0, 8099, 8085, 1,
		0, 0, 0, 8099, 8086, 1, 0, 0, 0, 8099, 8087, 1, 0, 0, 0, 8099, 8088, 1,
		0, 0, 0, 8099, 8089, 1, 0, 0, 0, 8099, 8090, 1, 0, 0, 0, 8099, 8091, 1,
		0, 0, 0, 8099, 8095, 1, 0, 0, 0, 8100, 1009, 1, 0, 0, 0, 8101, 8109, 7,
		63, 0, 0, 8102, 8103, 5, 2, 0, 0, 8103, 8106, 5, 518, 0, 0, 8104, 8105,
		5, 3, 0, 0, 8105, 8107, 5, 518, 0, 0, 8106, 8104, 1, 0, 0, 0, 8106, 8107,
		1, 0, 0, 0, 8107, 8108, 1, 0, 0, 0, 8108, 8110, 5, 4, 0, 0, 8109, 8102,
		1, 0, 0, 0, 8109, 8110, 1, 0, 0, 0, 8110, 1011, 1, 0, 0, 0, 8111, 8117,
		3, 1018, 509, 0, 8112, 8116, 5, 528, 0, 0, 8113, 8114, 5, 1, 0, 0, 8114,
		8116, 3, 1018, 509, 0, 8115, 8112, 1, 0, 0, 0, 8115, 8113, 1, 0, 0, 0,
		8116, 8119, 1, 0, 0, 0, 8117, 8115, 1, 0, 0, 0, 8117, 8118, 1, 0, 0, 0,
		8118, 1013, 1, 0, 0, 0, 8119, 8117, 1, 0, 0, 0, 8120, 8121, 3, 1012, 506,
		0, 8121, 1015, 1, 0, 0, 0, 8122, 8124, 5, 168, 0, 0, 8123, 8122, 1, 0,
		0, 0, 8123, 8124, 1, 0, 0, 0, 8124, 8125, 1, 0, 0, 0, 8125, 8126, 5, 468,
		0, 0, 8126, 8127, 5, 27, 0, 0, 8127, 8128, 5, 287, 0, 0, 8128, 8129, 3,
		1018, 509, 0, 8129, 1017, 1, 0, 0, 0, 8130, 8135, 5, 525, 0, 0, 8131, 8135,
		3, 1040, 520, 0, 8132, 8135, 5, 526, 0, 0, 8133, 8135, 5, 527, 0, 0, 8134,
		8130, 1, 0, 0, 0, 8134, 8131, 1, 0, 0, 0, 8134, 8132, 1, 0, 0, 0, 8134,
		8133, 1, 0, 0, 0, 8135, 1019, 1, 0, 0, 0, 8136, 8139, 3, 1018, 509, 0,
		8137, 8138, 5, 27, 0, 0, 8138, 8140, 3, 1018, 509, 0, 8139, 8137, 1, 0,
		0, 0, 8139, 8140, 1, 0, 0, 0, 8140, 1021, 1, 0, 0, 0, 8141, 8142, 5, 2,
		0, 0, 8142, 8147, 3, 1020, 510, 0, 8143, 8144, 5, 3, 0, 0, 8144, 8146,
		3, 1020, 510, 0, 8145, 8143, 1, 0, 0, 0, 8146, 8149, 1, 0, 0, 0, 8147,
		8145, 1, 0, 0, 0, 8147, 8148, 1, 0, 0, 0, 8148, 8150, 1, 0, 0, 0, 8149,
		8147, 1, 0, 0, 0, 8150, 8151, 5, 4, 0, 0, 8151, 1023, 1, 0, 0, 0, 8152,
		8153, 5, 2, 0, 0, 8153, 8158, 3, 1018, 509, 0, 8154, 8155, 5, 3, 0, 0,
		8155, 8157, 3, 1018, 509, 0, 8156, 8154, 1, 0, 0, 0, 8157, 8160, 1, 0,
		0, 0, 8158, 8156, 1, 0, 0, 0, 8158, 8159, 1, 0, 0, 0, 8159, 8161, 1, 0,
		0, 0, 8160, 8158, 1, 0, 0, 0, 8161, 8162, 5, 4, 0, 0, 8162, 1025, 1, 0,
		0, 0, 8163, 8166, 3, 1018, 509, 0, 8164, 8166, 3, 976, 488, 0, 8165, 8163,
		1, 0, 0, 0, 8165, 8164, 1, 0, 0, 0, 8166, 1027, 1, 0, 0, 0, 8167, 8172,
		3, 1026, 513, 0, 8168, 8169, 5, 3, 0, 0, 8169, 8171, 3, 1026, 513, 0, 8170,
		8168, 1, 0, 0, 0, 8171, 8174, 1, 0, 0, 0, 8172, 8170, 1, 0, 0, 0, 8172,
		8173, 1, 0, 0, 0, 8173, 1029, 1, 0, 0, 0, 8174, 8172, 1, 0, 0, 0, 8175,
		8179, 5, 502, 0, 0, 8176, 8179, 3, 1018, 509, 0, 8177, 8179, 3, 976, 488,
		0, 8178, 8175, 1, 0, 0, 0, 8178, 8176, 1, 0, 0, 0, 8178, 8177, 1, 0, 0,
		0, 8179, 1031, 1, 0, 0, 0, 8180, 8192, 3, 1026, 513, 0, 8181, 8182, 3,
		1026, 513, 0, 8182, 8183, 5, 517, 0, 0, 8183, 8184, 3, 1026, 513, 0, 8184,
		8192, 1, 0, 0, 0, 8185, 8186, 3, 1026, 513, 0, 8186, 8187, 5, 517, 0, 0,
		8187, 8188, 5, 6, 0, 0, 8188, 8189, 3, 1026, 513, 0, 8189, 8190, 5, 7,
		0, 0, 8190, 8192, 1, 0, 0, 0, 8191, 8180, 1, 0, 0, 0, 8191, 8181, 1, 0,
		0, 0, 8191, 8185, 1, 0, 0, 0, 8192, 1033, 1, 0, 0, 0, 8193, 8194, 3, 1018,
		509, 0, 8194, 8195, 5, 492, 0, 0, 8195, 8196, 3, 844, 422, 0, 8196, 1035,
		1, 0, 0, 0, 8197, 8202, 3, 1034, 517, 0, 8198, 8199, 5, 3, 0, 0, 8199,
		8201, 3, 1034, 517, 0, 8200, 8198, 1, 0, 0, 0, 8201, 8204, 1, 0, 0, 0,
		8202, 8200, 1, 0, 0, 0, 8202, 8203, 1, 0, 0, 0, 8203, 1037, 1, 0, 0, 0,
		8204, 8202, 1, 0, 0, 0, 8205, 8209, 5, 519, 0, 0, 8206, 8209, 5, 520, 0,
		0, 8207, 8209, 5, 518, 0, 0, 8208, 8205, 1, 0, 0, 0, 8208, 8206, 1, 0,
		0, 0, 8208, 8207, 1, 0, 0, 0, 8209, 1039, 1, 0, 0, 0, 8210, 8211, 7, 64,
		0, 0, 8211, 1041, 1, 0, 0, 0, 975, 1045, 1053, 1297, 1313, 1319, 1327,
		1329, 1347, 1354, 1359, 1363, 1366, 1369, 1375, 1380, 1384, 1407, 1415,
		1419, 1425, 1434, 1441, 1446, 1449, 1452, 1455, 1458, 1461, 1464, 1467,
		1470, 1473, 1477, 1480, 1483, 1486, 1489, 1494, 1497, 1507, 1519, 1529,
		1531, 1534, 1541, 1548, 1551, 1556, 1560, 1575, 1579, 1588, 1602, 1611,
		1619, 1622, 1625, 1636, 1641, 1645, 1651, 1660, 1667, 1675, 1678, 1682,
		1685, 1688, 1691, 1694, 1697, 1700, 1707, 1712, 1716, 1733, 1746, 1759,
		1762, 1772, 1774, 1777, 1790, 1795, 1801, 1808, 1814, 1822, 1828, 1836,
		1842, 1849, 1855, 1868, 1873, 1881, 1885, 1894, 1897, 1900, 1908, 1912,
		1921, 1924, 1927, 1929, 1934, 1938, 1942, 1948, 1952, 1955, 1958, 1970,
		1980, 1986, 1996, 2000, 2008, 2012, 2019, 2028, 2031, 2034, 2045, 2051,
		2060, 2065, 2068, 2072, 2086, 2091, 2116, 2122, 2128, 2133, 2138, 2145,
		2149, 2155, 2163, 2176, 2185, 2192, 2197, 2200, 2205, 2218, 2223, 2232,
		2239, 2245, 2252, 2264, 2272, 2281, 2283, 2286, 2291, 2296, 2304, 2315,
		2329, 2338, 2347, 2351, 2358, 2366, 2384, 2393, 2396, 2400, 2413, 2434,
		2447, 2451, 2464, 2472, 2485, 2491, 2494, 2509, 2516, 2529, 2534, 2564,
		2566, 2572, 2574, 2580, 2585, 2598, 2603, 2609, 2618, 2631, 2683, 2707,
		2715, 2717, 2726, 2734, 2736, 2739, 2748, 2764, 2774, 2782, 2784, 2794,
		2802, 2804, 2814, 2825, 2832, 2839, 2856, 2871, 2885, 2900, 2913, 2915,
		2918, 2944, 2947, 2950, 2953, 2956, 2959, 2967, 2971, 2974, 2984, 2990,
		2993, 3000, 3003, 3011, 3015, 3018, 3036, 3039, 3047, 3052, 3056, 3062,
		3064, 3076, 3079, 3088, 3092, 3104, 3109, 3113, 3125, 3130, 3136, 3144,
		3155, 3158, 3164, 3167, 3170, 3186, 3208, 3222, 3227, 3230, 3233, 3237,
		3241, 3244, 3247, 3249, 3253, 3258, 3264, 3267, 3270, 3274, 3279, 3283,
		3287, 3292, 3297, 3304, 3306, 3318, 3325, 3332, 3340, 3346, 3349, 3356,
		3361, 3365, 3374, 3377, 3383, 3388, 3391, 3394, 3403, 3406, 3409, 3415,
		3419, 3423, 3431, 3441, 3444, 3447, 3452, 3461, 3469, 3472, 3475, 3478,
		3490, 3508, 3513, 3517, 3533, 3544, 3555, 3561, 3569, 3572, 3576, 3580,
		3589, 3592, 3595, 3603, 3615, 3621, 3629, 3632, 3636, 3640, 3649, 3652,
		3655, 3659, 3664, 3667, 3672, 3675, 3683, 3693, 3708, 3713, 3718, 3733,
		3736, 3742, 3755, 3761, 3765, 3770, 3775, 3780, 3790, 3795, 3798, 3802,
		3811, 3816, 3820, 3829, 3832, 3835, 3840, 3846, 3855, 3858, 3861, 3868,
		3877, 3880, 3883, 3903, 3906, 3910, 3915, 3920, 3929, 3941, 3945, 3954,
		3957, 3966, 3986, 4000, 4023, 4028, 4032, 4039, 4044, 4046, 4057, 4061,
		4066, 4087, 4090, 4095, 4101, 4105, 4110, 4120, 4123, 4135, 4138, 4144,
		4150, 4155, 4161, 4164, 4168, 4172, 4178, 4183, 4185, 4190, 4200, 4209,
		4215, 4221, 4227, 4230, 4233, 4236, 4243, 4247, 4251, 4258, 4264, 4268,
		4272, 4274, 4280, 4285, 4290, 4295, 4302, 4308, 4310, 4316, 4321, 4325,
		4329, 4338, 4341, 4344, 4351, 4355, 4358, 4365, 4371, 4375, 4383, 4387,
		4409, 4415, 4423, 4429, 4437, 4443, 4449, 4477, 4485, 4490, 4496, 4503,
		4507, 4514, 4524, 4528, 4537, 4540, 4543, 4545, 4551, 4555, 4559, 4564,
		4570, 4576, 4580, 4586, 4590, 4592, 4596, 4603, 4608, 4618, 4622, 4627,
		4630, 4636, 4644, 4653, 4661, 4667, 4673, 4685, 4687, 4695, 4702, 4706,
		4712, 4724, 4735, 4745, 4751, 4761, 4774, 4779, 4787, 4793, 4798, 4809,
		4817, 4828, 4834, 4843, 4854, 4866, 4879, 4886, 4888, 4899, 4916, 4949,
		4954, 4962, 4970, 4975, 4983, 4985, 4990, 4997, 5012, 5020, 5025, 5049,
		5066, 5082, 5102, 5160, 5164, 5177, 5182, 5186, 5195, 5201, 5214, 5220,
		5222, 5231, 5236, 5240, 5249, 5255, 5259, 5267, 5272, 5279, 5286, 5303,
		5320, 5331, 5350, 5355, 5359, 5381, 5388, 5391, 5397, 5404, 5407, 5410,
		5416, 5422, 5428, 5434, 5443, 5446, 5449, 5456, 5467, 5476, 5484, 5492,
		5501, 5514, 5533, 5542, 5545, 5548, 5556, 5564, 5568, 5573, 5578, 5580,
		5590, 5602, 5609, 5620, 5624, 5636, 5642, 5655, 5661, 5667, 5676, 5692,
		5697, 5701, 5704, 5710, 5713, 5716, 5743, 5747, 5750, 5756, 5764, 5772,
		5778, 5782, 5790, 5804, 5813, 5815, 5830, 5834, 5837, 5846, 5850, 5879,
		5883, 5885, 5889, 5893, 5896, 5899, 5902, 5906, 5910, 5913, 5916, 5919,
		5930, 5934, 5938, 5941, 5951, 5962, 5965, 5968, 5971, 5980, 5989, 5995,
		6002, 6009, 6014, 6020, 6023, 6025, 6038, 6042, 6047, 6053, 6060, 6064,
		6071, 6077, 6082, 6086, 6093, 6098, 6100, 6104, 6109, 6115, 6126, 6132,
		6136, 6142, 6149, 6160, 6164, 6166, 6172, 6176, 6178, 6187, 6195, 6200,
		6207, 6215, 6220, 6224, 6227, 6230, 6233, 6236, 6239, 6242, 6245, 6249,
		6258, 6263, 6267, 6269, 6273, 6277, 6279, 6286, 6290, 6292, 6302, 6306,
		6308, 6313, 6317, 6319, 6325, 6334, 6340, 6349, 6357, 6361, 6363, 6367,
		6370, 6374, 6376, 6380, 6384, 6391, 6400, 6403, 6407, 6411, 6414, 6419,
		6427, 6456, 6464, 6476, 6491, 6496, 6504, 6510, 6519, 6525, 6530, 6539,
		6551, 6563, 6575, 6578, 6591, 6602, 6609, 6616, 6628, 6633, 6641, 6643,
		6651, 6660, 6673, 6675, 6680, 6683, 6691, 6695, 6703, 6711, 6719, 6727,
		6731, 6760, 6762, 6814, 6818, 6826, 6830, 6835, 6839, 6845, 6852, 6857,
		6866, 6870, 6877, 6885, 6891, 6901, 6905, 6911, 6913, 6926, 6942, 6945,
		6955, 6958, 6966, 6978, 6981, 6991, 6994, 6998, 7000, 7005, 7013, 7020,
		7022, 7029, 7032, 7038, 7046, 7054, 7062, 7072, 7075, 7089, 7092, 7099,
		7106, 7116, 7119, 7123, 7127, 7137, 7158, 7163, 7168, 7170, 7175, 7180,
		7185, 7188, 7193, 7198, 7200, 7224, 7227, 7280, 7283, 7343, 7363, 7370,
		7376, 7379, 7383, 7389, 7395, 7398, 7402, 7408, 7414, 7417, 7421, 7427,
		7433, 7436, 7440, 7442, 7452, 7461, 7464, 7473, 7476, 7479, 7502, 7513,
		7522, 7524, 7530, 7540, 7542, 7550, 7552, 7554, 7558, 7562, 7566, 7570,
		7575, 7579, 7591, 7594, 7608, 7611, 7618, 7627, 7630, 7637, 7649, 7652,
		7666, 7669, 7673, 7679, 7686, 7692, 7699, 7707, 7718, 7725, 7729, 7737,
		7748, 7755, 7761, 7767, 7795, 7810, 7818, 7826, 7837, 7845, 7851, 7859,
		7870, 7872, 7876, 7885, 7894, 7905, 7919, 7929, 7940, 7956, 7959, 7965,
		7994, 8010, 8019, 8034, 8038, 8042, 8046, 8050, 8054, 8058, 8062, 8066,
		8070, 8079, 8083, 8093, 8097, 8099, 8106, 8109, 8115, 8117, 8123, 8134,
		8139, 8147, 8158, 8165, 8172, 8178, 8191, 8202, 8208,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// DorisSQLParserInit initializes any static state used to implement DorisSQLParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewDorisSQLParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func DorisSQLParserInit() {
	staticData := &DorisSQLParserStaticData
	staticData.once.Do(dorissqlParserInit)
}

// NewDorisSQLParser produces a new parser instance for the optional input antlr.TokenStream.
func NewDorisSQLParser(input antlr.TokenStream) *DorisSQLParser {
	DorisSQLParserInit()
	this := new(DorisSQLParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &DorisSQLParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "DorisSQL.g4"

	return this
}

// DorisSQLParser tokens.
const (
	DorisSQLParserEOF                       = antlr.TokenEOF
	DorisSQLParserT__0                      = 1
	DorisSQLParserT__1                      = 2
	DorisSQLParserT__2                      = 3
	DorisSQLParserT__3                      = 4
	DorisSQLParserT__4                      = 5
	DorisSQLParserT__5                      = 6
	DorisSQLParserT__6                      = 7
	DorisSQLParserT__7                      = 8
	DorisSQLParserT__8                      = 9
	DorisSQLParserT__9                      = 10
	DorisSQLParserACCESS                    = 11
	DorisSQLParserACTIVE                    = 12
	DorisSQLParserADD                       = 13
	DorisSQLParserADMIN                     = 14
	DorisSQLParserADVISOR                   = 15
	DorisSQLParserAFTER                     = 16
	DorisSQLParserAGGREGATE                 = 17
	DorisSQLParserALL                       = 18
	DorisSQLParserALTER                     = 19
	DorisSQLParserANALYZE                   = 20
	DorisSQLParserAND                       = 21
	DorisSQLParserANTI                      = 22
	DorisSQLParserAPPLY                     = 23
	DorisSQLParserARRAY                     = 24
	DorisSQLParserARRAY_AGG                 = 25
	DorisSQLParserARRAY_AGG_DISTINCT        = 26
	DorisSQLParserAS                        = 27
	DorisSQLParserASC                       = 28
	DorisSQLParserASYNC                     = 29
	DorisSQLParserAUTHORS                   = 30
	DorisSQLParserAUTHENTICATION            = 31
	DorisSQLParserAUTOMATED                 = 32
	DorisSQLParserAUTO_INCREMENT            = 33
	DorisSQLParserAVG                       = 34
	DorisSQLParserBACKEND                   = 35
	DorisSQLParserBACKENDS                  = 36
	DorisSQLParserBACKUP                    = 37
	DorisSQLParserBASE                      = 38
	DorisSQLParserBASELINE                  = 39
	DorisSQLParserBEGIN                     = 40
	DorisSQLParserBETWEEN                   = 41
	DorisSQLParserBIGINT                    = 42
	DorisSQLParserBINARY                    = 43
	DorisSQLParserBITMAP                    = 44
	DorisSQLParserBITMAP_UNION              = 45
	DorisSQLParserBLACKHOLE                 = 46
	DorisSQLParserBLACKLIST                 = 47
	DorisSQLParserBODY                      = 48
	DorisSQLParserBOOLEAN                   = 49
	DorisSQLParserBOTH                      = 50
	DorisSQLParserBRANCH                    = 51
	DorisSQLParserBROKER                    = 52
	DorisSQLParserBUCKETS                   = 53
	DorisSQLParserBUILTIN                   = 54
	DorisSQLParserBY                        = 55
	DorisSQLParserCACHE                     = 56
	DorisSQLParserCANCEL                    = 57
	DorisSQLParserCASE                      = 58
	DorisSQLParserCAST                      = 59
	DorisSQLParserCATALOG                   = 60
	DorisSQLParserCATALOGS                  = 61
	DorisSQLParserCEIL                      = 62
	DorisSQLParserCHAIN                     = 63
	DorisSQLParserCHAR                      = 64
	DorisSQLParserCHARACTER                 = 65
	DorisSQLParserCHARSET                   = 66
	DorisSQLParserCHECK                     = 67
	DorisSQLParserCLEAN                     = 68
	DorisSQLParserCLEAR                     = 69
	DorisSQLParserCLUSTER                   = 70
	DorisSQLParserCLUSTERS                  = 71
	DorisSQLParserCNGROUP                   = 72
	DorisSQLParserCNGROUPS                  = 73
	DorisSQLParserCOLLATE                   = 74
	DorisSQLParserCOLLATION                 = 75
	DorisSQLParserCOLUMN                    = 76
	DorisSQLParserCOLUMNS                   = 77
	DorisSQLParserCOMMENT                   = 78
	DorisSQLParserCOMMIT                    = 79
	DorisSQLParserCOMMITTED                 = 80
	DorisSQLParserCOMPACT                   = 81
	DorisSQLParserCOMPACTION                = 82
	DorisSQLParserCOMPUTE                   = 83
	DorisSQLParserCONFIG                    = 84
	DorisSQLParserCONNECTION                = 85
	DorisSQLParserCONSISTENT                = 86
	DorisSQLParserCONVERT                   = 87
	DorisSQLParserCOSTS                     = 88
	DorisSQLParserCOUNT                     = 89
	DorisSQLParserCREATE                    = 90
	DorisSQLParserCROSS                     = 91
	DorisSQLParserCUBE                      = 92
	DorisSQLParserCUME_DIST                 = 93
	DorisSQLParserCUMULATIVE                = 94
	DorisSQLParserCURRENT                   = 95
	DorisSQLParserCURRENT_DATE              = 96
	DorisSQLParserCURRENT_GROUP             = 97
	DorisSQLParserCURRENT_ROLE              = 98
	DorisSQLParserCURRENT_TIME              = 99
	DorisSQLParserCURRENT_TIMESTAMP         = 100
	DorisSQLParserCURRENT_USER              = 101
	DorisSQLParserDATA                      = 102
	DorisSQLParserDATACACHE                 = 103
	DorisSQLParserDATABASE                  = 104
	DorisSQLParserDATABASES                 = 105
	DorisSQLParserDATE                      = 106
	DorisSQLParserDATETIME                  = 107
	DorisSQLParserDAY                       = 108
	DorisSQLParserDAYS                      = 109
	DorisSQLParserDEALLOCATE                = 110
	DorisSQLParserDECIMAL                   = 111
	DorisSQLParserDECIMALV2                 = 112
	DorisSQLParserDECIMAL32                 = 113
	DorisSQLParserDECIMAL64                 = 114
	DorisSQLParserDECIMAL128                = 115
	DorisSQLParserDECOMMISSION              = 116
	DorisSQLParserDEFAULT                   = 117
	DorisSQLParserDELETE                    = 118
	DorisSQLParserDENSE_RANK                = 119
	DorisSQLParserDEFERRED                  = 120
	DorisSQLParserDIALECT                   = 121
	DorisSQLParserDICTIONARY                = 122
	DorisSQLParserDICTIONARY_GET            = 123
	DorisSQLParserNTILE                     = 124
	DorisSQLParserDESC                      = 125
	DorisSQLParserDESCRIBE                  = 126
	DorisSQLParserDISABLE                   = 127
	DorisSQLParserDISTINCT                  = 128
	DorisSQLParserDISTRIBUTED               = 129
	DorisSQLParserDISTRIBUTION              = 130
	DorisSQLParserDOUBLE                    = 131
	DorisSQLParserDROP                      = 132
	DorisSQLParserDUAL                      = 133
	DorisSQLParserDUPLICATE                 = 134
	DorisSQLParserDYNAMIC                   = 135
	DorisSQLParserELSE                      = 136
	DorisSQLParserENABLE                    = 137
	DorisSQLParserENCLOSE                   = 138
	DorisSQLParserEND                       = 139
	DorisSQLParserENGINE                    = 140
	DorisSQLParserENGINES                   = 141
	DorisSQLParserERRORS                    = 142
	DorisSQLParserESCAPE                    = 143
	DorisSQLParserEVENTS                    = 144
	DorisSQLParserEXCEPT                    = 145
	DorisSQLParserEXCLUDE                   = 146
	DorisSQLParserEXECUTE                   = 147
	DorisSQLParserEXISTS                    = 148
	DorisSQLParserEXPLAIN                   = 149
	DorisSQLParserEXPORT                    = 150
	DorisSQLParserEXTERNAL                  = 151
	DorisSQLParserEXTRACT                   = 152
	DorisSQLParserEVERY                     = 153
	DorisSQLParserFAILPOINT                 = 154
	DorisSQLParserFAILPOINTS                = 155
	DorisSQLParserFALSE                     = 156
	DorisSQLParserFIELDS                    = 157
	DorisSQLParserFILE                      = 158
	DorisSQLParserFILES                     = 159
	DorisSQLParserFILTER                    = 160
	DorisSQLParserFIRST                     = 161
	DorisSQLParserFIRST_VALUE               = 162
	DorisSQLParserFLOAT                     = 163
	DorisSQLParserFLOOR                     = 164
	DorisSQLParserFN                        = 165
	DorisSQLParserFOLLOWING                 = 166
	DorisSQLParserFOLLOWER                  = 167
	DorisSQLParserFOR                       = 168
	DorisSQLParserFORCE                     = 169
	DorisSQLParserFORMAT                    = 170
	DorisSQLParserFREE                      = 171
	DorisSQLParserFROM                      = 172
	DorisSQLParserFRONTEND                  = 173
	DorisSQLParserFRONTENDS                 = 174
	DorisSQLParserFULL                      = 175
	DorisSQLParserFUNCTION                  = 176
	DorisSQLParserFUNCTIONS                 = 177
	DorisSQLParserGLOBAL                    = 178
	DorisSQLParserGRANT                     = 179
	DorisSQLParserGRANTS                    = 180
	DorisSQLParserGROUP                     = 181
	DorisSQLParserGROUPS                    = 182
	DorisSQLParserGROUPING                  = 183
	DorisSQLParserGROUPING_ID               = 184
	DorisSQLParserGROUP_CONCAT              = 185
	DorisSQLParserHASH                      = 186
	DorisSQLParserHAVING                    = 187
	DorisSQLParserHELP                      = 188
	DorisSQLParserHISTOGRAM                 = 189
	DorisSQLParserHLL                       = 190
	DorisSQLParserHLL_UNION                 = 191
	DorisSQLParserHOST                      = 192
	DorisSQLParserHOUR                      = 193
	DorisSQLParserHOURS                     = 194
	DorisSQLParserHUB                       = 195
	DorisSQLParserIDENTIFIED                = 196
	DorisSQLParserIF                        = 197
	DorisSQLParserIMPERSONATE               = 198
	DorisSQLParserIMMEDIATE                 = 199
	DorisSQLParserIGNORE                    = 200
	DorisSQLParserIMAGE                     = 201
	DorisSQLParserIN                        = 202
	DorisSQLParserINACTIVE                  = 203
	DorisSQLParserINCREMENTAL               = 204
	DorisSQLParserINDEX                     = 205
	DorisSQLParserINDEXES                   = 206
	DorisSQLParserINFILE                    = 207
	DorisSQLParserINNER                     = 208
	DorisSQLParserINSTALL                   = 209
	DorisSQLParserINSERT                    = 210
	DorisSQLParserINT                       = 211
	DorisSQLParserINTEGER                   = 212
	DorisSQLParserINTEGRATION               = 213
	DorisSQLParserINTEGRATIONS              = 214
	DorisSQLParserINTERMEDIATE              = 215
	DorisSQLParserINTERSECT                 = 216
	DorisSQLParserINTERVAL                  = 217
	DorisSQLParserINTO                      = 218
	DorisSQLParserINVOKER                   = 219
	DorisSQLParserGIN                       = 220
	DorisSQLParserOVERWRITE                 = 221
	DorisSQLParserIS                        = 222
	DorisSQLParserISOLATION                 = 223
	DorisSQLParserJOB                       = 224
	DorisSQLParserJOIN                      = 225
	DorisSQLParserJSON                      = 226
	DorisSQLParserKEY                       = 227
	DorisSQLParserKEYS                      = 228
	DorisSQLParserKILL                      = 229
	DorisSQLParserLABEL                     = 230
	DorisSQLParserLAG                       = 231
	DorisSQLParserLARGEINT                  = 232
	DorisSQLParserLAST                      = 233
	DorisSQLParserLAST_VALUE                = 234
	DorisSQLParserLATERAL                   = 235
	DorisSQLParserLEAD                      = 236
	DorisSQLParserLEFT                      = 237
	DorisSQLParserLESS                      = 238
	DorisSQLParserLEVEL                     = 239
	DorisSQLParserLIKE                      = 240
	DorisSQLParserLIMIT                     = 241
	DorisSQLParserLIST                      = 242
	DorisSQLParserLOAD                      = 243
	DorisSQLParserLOCAL                     = 244
	DorisSQLParserLOCALTIME                 = 245
	DorisSQLParserLOCALTIMESTAMP            = 246
	DorisSQLParserLOCATION                  = 247
	DorisSQLParserLOCATIONS                 = 248
	DorisSQLParserLOGS                      = 249
	DorisSQLParserLOGICAL                   = 250
	DorisSQLParserMANUAL                    = 251
	DorisSQLParserMAP                       = 252
	DorisSQLParserMAPPING                   = 253
	DorisSQLParserMAPPINGS                  = 254
	DorisSQLParserMASKING                   = 255
	DorisSQLParserMATCH                     = 256
	DorisSQLParserMATERIALIZED              = 257
	DorisSQLParserMAX                       = 258
	DorisSQLParserMAXVALUE                  = 259
	DorisSQLParserMERGE                     = 260
	DorisSQLParserMICROSECOND               = 261
	DorisSQLParserMILLISECOND               = 262
	DorisSQLParserMIN                       = 263
	DorisSQLParserMINUTE                    = 264
	DorisSQLParserMINUTES                   = 265
	DorisSQLParserMINUS                     = 266
	DorisSQLParserMETA                      = 267
	DorisSQLParserMOD                       = 268
	DorisSQLParserMODE                      = 269
	DorisSQLParserMODIFY                    = 270
	DorisSQLParserMONTH                     = 271
	DorisSQLParserMULTIPLE                  = 272
	DorisSQLParserNAME                      = 273
	DorisSQLParserNAMES                     = 274
	DorisSQLParserNEGATIVE                  = 275
	DorisSQLParserNGRAMBF                   = 276
	DorisSQLParserNO                        = 277
	DorisSQLParserNODE                      = 278
	DorisSQLParserNODES                     = 279
	DorisSQLParserNONE                      = 280
	DorisSQLParserNOT                       = 281
	DorisSQLParserNULL                      = 282
	DorisSQLParserNULLS                     = 283
	DorisSQLParserNUMBER                    = 284
	DorisSQLParserNUMERIC                   = 285
	DorisSQLParserOBSERVER                  = 286
	DorisSQLParserOF                        = 287
	DorisSQLParserOFF                       = 288
	DorisSQLParserOFFSET                    = 289
	DorisSQLParserON                        = 290
	DorisSQLParserONLY                      = 291
	DorisSQLParserOPEN                      = 292
	DorisSQLParserOPERATE                   = 293
	DorisSQLParserOPTIMIZE                  = 294
	DorisSQLParserOPTIMIZER                 = 295
	DorisSQLParserOPTION                    = 296
	DorisSQLParserOR                        = 297
	DorisSQLParserORDER                     = 298
	DorisSQLParserOUTER                     = 299
	DorisSQLParserOUTFILE                   = 300
	DorisSQLParserOVER                      = 301
	DorisSQLParserPARAMETER                 = 302
	DorisSQLParserPARTITION                 = 303
	DorisSQLParserPARTITIONS                = 304
	DorisSQLParserPASSWORD                  = 305
	DorisSQLParserPATH                      = 306
	DorisSQLParserPAUSE                     = 307
	DorisSQLParserPENDING                   = 308
	DorisSQLParserPERCENT_RANK              = 309
	DorisSQLParserPERCENTILE                = 310
	DorisSQLParserPERCENTILE_UNION          = 311
	DorisSQLParserPLAN                      = 312
	DorisSQLParserPLUGIN                    = 313
	DorisSQLParserPLUGINS                   = 314
	DorisSQLParserPIPE                      = 315
	DorisSQLParserPIPES                     = 316
	DorisSQLParserPIVOT                     = 317
	DorisSQLParserPOLICY                    = 318
	DorisSQLParserPOLICIES                  = 319
	DorisSQLParserPRECEDING                 = 320
	DorisSQLParserPREDICATE                 = 321
	DorisSQLParserPREPARE                   = 322
	DorisSQLParserPRIMARY                   = 323
	DorisSQLParserPRIORITY                  = 324
	DorisSQLParserPRIVILEGES                = 325
	DorisSQLParserPROBABILITY               = 326
	DorisSQLParserPROC                      = 327
	DorisSQLParserPROCEDURE                 = 328
	DorisSQLParserPROCESSLIST               = 329
	DorisSQLParserPROFILE                   = 330
	DorisSQLParserPROFILELIST               = 331
	DorisSQLParserPROPERTIES                = 332
	DorisSQLParserPROPERTY                  = 333
	DorisSQLParserPROVIDER                  = 334
	DorisSQLParserPROVIDERS                 = 335
	DorisSQLParserQUALIFY                   = 336
	DorisSQLParserQUARTER                   = 337
	DorisSQLParserQUERY                     = 338
	DorisSQLParserQUERIES                   = 339
	DorisSQLParserQUEUE                     = 340
	DorisSQLParserQUOTA                     = 341
	DorisSQLParserRANDOM                    = 342
	DorisSQLParserRANGE                     = 343
	DorisSQLParserRANK                      = 344
	DorisSQLParserREAD                      = 345
	DorisSQLParserREASON                    = 346
	DorisSQLParserRECOVER                   = 347
	DorisSQLParserREFRESH                   = 348
	DorisSQLParserREWRITE                   = 349
	DorisSQLParserREGEXP                    = 350
	DorisSQLParserRELEASE                   = 351
	DorisSQLParserREMOVE                    = 352
	DorisSQLParserRENAME                    = 353
	DorisSQLParserREPAIR                    = 354
	DorisSQLParserREPEATABLE                = 355
	DorisSQLParserREPLACE                   = 356
	DorisSQLParserREPLACE_IF_NOT_NULL       = 357
	DorisSQLParserREPLICA                   = 358
	DorisSQLParserREPOSITORY                = 359
	DorisSQLParserREPOSITORIES              = 360
	DorisSQLParserRESOURCE                  = 361
	DorisSQLParserRESOURCES                 = 362
	DorisSQLParserRESTORE                   = 363
	DorisSQLParserRESUME                    = 364
	DorisSQLParserRETAIN                    = 365
	DorisSQLParserRETENTION                 = 366
	DorisSQLParserRETURNS                   = 367
	DorisSQLParserRETRY                     = 368
	DorisSQLParserREVOKE                    = 369
	DorisSQLParserREVERT                    = 370
	DorisSQLParserRIGHT                     = 371
	DorisSQLParserRLIKE                     = 372
	DorisSQLParserROLE                      = 373
	DorisSQLParserROLES                     = 374
	DorisSQLParserROLLBACK                  = 375
	DorisSQLParserROLLUP                    = 376
	DorisSQLParserROUTINE                   = 377
	DorisSQLParserROW                       = 378
	DorisSQLParserROWS                      = 379
	DorisSQLParserROW_NUMBER                = 380
	DorisSQLParserRULE                      = 381
	DorisSQLParserRULES                     = 382
	DorisSQLParserRUNNING                   = 383
	DorisSQLParserSAMPLE                    = 384
	DorisSQLParserSCHEDULE                  = 385
	DorisSQLParserSCHEDULER                 = 386
	DorisSQLParserSCHEMA                    = 387
	DorisSQLParserSCHEMAS                   = 388
	DorisSQLParserSECOND                    = 389
	DorisSQLParserSECURITY                  = 390
	DorisSQLParserSELECT                    = 391
	DorisSQLParserSEMI                      = 392
	DorisSQLParserSEPARATOR                 = 393
	DorisSQLParserSERIALIZABLE              = 394
	DorisSQLParserSESSION                   = 395
	DorisSQLParserSET                       = 396
	DorisSQLParserSETS                      = 397
	DorisSQLParserSET_VAR                   = 398
	DorisSQLParserSIGNED                    = 399
	DorisSQLParserSKIP_HEADER               = 400
	DorisSQLParserSHOW                      = 401
	DorisSQLParserSMALLINT                  = 402
	DorisSQLParserSNAPSHOT                  = 403
	DorisSQLParserSNAPSHOTS                 = 404
	DorisSQLParserSQLBLACKLIST              = 405
	DorisSQLParserSTART                     = 406
	DorisSQLParserSTATS                     = 407
	DorisSQLParserSTATUS                    = 408
	DorisSQLParserSTOP                      = 409
	DorisSQLParserSTORAGE                   = 410
	DorisSQLParserSTREAM                    = 411
	DorisSQLParserSTRING                    = 412
	DorisSQLParserTEXT                      = 413
	DorisSQLParserSUBMIT                    = 414
	DorisSQLParserSUM                       = 415
	DorisSQLParserSUSPEND                   = 416
	DorisSQLParserSYNC                      = 417
	DorisSQLParserSYSTEM                    = 418
	DorisSQLParserSYSTEM_TIME               = 419
	DorisSQLParserSWAP                      = 420
	DorisSQLParserSTRUCT                    = 421
	DorisSQLParserTABLE                     = 422
	DorisSQLParserTABLES                    = 423
	DorisSQLParserTABLET                    = 424
	DorisSQLParserTABLETS                   = 425
	DorisSQLParserTAG                       = 426
	DorisSQLParserTASK                      = 427
	DorisSQLParserTEMPORARY                 = 428
	DorisSQLParserTERMINATED                = 429
	DorisSQLParserTHAN                      = 430
	DorisSQLParserTHEN                      = 431
	DorisSQLParserTIME                      = 432
	DorisSQLParserTIMES                     = 433
	DorisSQLParserTIMESTAMP                 = 434
	DorisSQLParserTIMESTAMPADD              = 435
	DorisSQLParserTIMESTAMPDIFF             = 436
	DorisSQLParserTINYINT                   = 437
	DorisSQLParserTRANSACTION               = 438
	DorisSQLParserTRANSLATE                 = 439
	DorisSQLParserTO                        = 440
	DorisSQLParserTRACE                     = 441
	DorisSQLParserTRIGGERS                  = 442
	DorisSQLParserTRIM_SPACE                = 443
	DorisSQLParserTRUE                      = 444
	DorisSQLParserTRUNCATE                  = 445
	DorisSQLParserTYPE                      = 446
	DorisSQLParserTYPES                     = 447
	DorisSQLParserUNBOUNDED                 = 448
	DorisSQLParserUNCOMMITTED               = 449
	DorisSQLParserUNION                     = 450
	DorisSQLParserUNIQUE                    = 451
	DorisSQLParserUNINSTALL                 = 452
	DorisSQLParserUNSET                     = 453
	DorisSQLParserUNSIGNED                  = 454
	DorisSQLParserUPDATE                    = 455
	DorisSQLParserUSAGE                     = 456
	DorisSQLParserUSE                       = 457
	DorisSQLParserUSER                      = 458
	DorisSQLParserUSERS                     = 459
	DorisSQLParserUSING                     = 460
	DorisSQLParserVALUE                     = 461
	DorisSQLParserVALUES                    = 462
	DorisSQLParserVARBINARY                 = 463
	DorisSQLParserVARCHAR                   = 464
	DorisSQLParserVARIABLES                 = 465
	DorisSQLParserVECTOR                    = 466
	DorisSQLParserVERBOSE                   = 467
	DorisSQLParserVERSION                   = 468
	DorisSQLParserVIEW                      = 469
	DorisSQLParserVIEWS                     = 470
	DorisSQLParserVOLUME                    = 471
	DorisSQLParserVOLUMES                   = 472
	DorisSQLParserWAREHOUSE                 = 473
	DorisSQLParserWAREHOUSES                = 474
	DorisSQLParserWARNINGS                  = 475
	DorisSQLParserWEEK                      = 476
	DorisSQLParserWHEN                      = 477
	DorisSQLParserWHERE                     = 478
	DorisSQLParserWHITELIST                 = 479
	DorisSQLParserWITH                      = 480
	DorisSQLParserWORK                      = 481
	DorisSQLParserWRITE                     = 482
	DorisSQLParserYEAR                      = 483
	DorisSQLParserLOCK                      = 484
	DorisSQLParserUNLOCK                    = 485
	DorisSQLParserLOW_PRIORITY              = 486
	DorisSQLParserDISK                      = 487
	DorisSQLParserBEFORE                    = 488
	DorisSQLParserDOUBLE_DOLLAR             = 489
	DorisSQLParserFIELD                     = 490
	DorisSQLParserPERSISTENT                = 491
	DorisSQLParserEQ                        = 492
	DorisSQLParserNEQ                       = 493
	DorisSQLParserLT                        = 494
	DorisSQLParserLTE                       = 495
	DorisSQLParserGT                        = 496
	DorisSQLParserGTE                       = 497
	DorisSQLParserEQ_FOR_NULL               = 498
	DorisSQLParserARRAY_ELEMENT             = 499
	DorisSQLParserPLUS_SYMBOL               = 500
	DorisSQLParserMINUS_SYMBOL              = 501
	DorisSQLParserASTERISK_SYMBOL           = 502
	DorisSQLParserSLASH_SYMBOL              = 503
	DorisSQLParserPERCENT_SYMBOL            = 504
	DorisSQLParserLOGICAL_OR                = 505
	DorisSQLParserLOGICAL_AND               = 506
	DorisSQLParserLOGICAL_NOT               = 507
	DorisSQLParserINT_DIV                   = 508
	DorisSQLParserBITAND                    = 509
	DorisSQLParserBITOR                     = 510
	DorisSQLParserBITXOR                    = 511
	DorisSQLParserBITNOT                    = 512
	DorisSQLParserBIT_SHIFT_LEFT            = 513
	DorisSQLParserBIT_SHIFT_RIGHT           = 514
	DorisSQLParserBIT_SHIFT_RIGHT_LOGICAL   = 515
	DorisSQLParserARROW                     = 516
	DorisSQLParserAT                        = 517
	DorisSQLParserINTEGER_VALUE             = 518
	DorisSQLParserDECIMAL_VALUE             = 519
	DorisSQLParserDOUBLE_VALUE              = 520
	DorisSQLParserSINGLE_QUOTED_TEXT        = 521
	DorisSQLParserDOUBLE_QUOTED_TEXT        = 522
	DorisSQLParserBINARY_SINGLE_QUOTED_TEXT = 523
	DorisSQLParserBINARY_DOUBLE_QUOTED_TEXT = 524
	DorisSQLParserLETTER_IDENTIFIER         = 525
	DorisSQLParserDIGIT_IDENTIFIER          = 526
	DorisSQLParserBACKQUOTED_IDENTIFIER     = 527
	DorisSQLParserDOT_IDENTIFIER            = 528
	DorisSQLParserSIMPLE_COMMENT            = 529
	DorisSQLParserBRACKETED_COMMENT         = 530
	DorisSQLParserOPTIMIZER_HINT            = 531
	DorisSQLParserSEMICOLON                 = 532
	DorisSQLParserDOTDOTDOT                 = 533
	DorisSQLParserWS                        = 534
	DorisSQLParserATTACHMENT                = 535
	DorisSQLParserCONCAT                    = 536
)

// DorisSQLParser rules.
const (
	DorisSQLParserRULE_sqlStatements                          = 0
	DorisSQLParserRULE_singleStatement                        = 1
	DorisSQLParserRULE_emptyStatement                         = 2
	DorisSQLParserRULE_statement                              = 3
	DorisSQLParserRULE_useDatabaseStatement                   = 4
	DorisSQLParserRULE_useCatalogStatement                    = 5
	DorisSQLParserRULE_setCatalogStatement                    = 6
	DorisSQLParserRULE_showDatabasesStatement                 = 7
	DorisSQLParserRULE_alterDbQuotaStatement                  = 8
	DorisSQLParserRULE_createDbStatement                      = 9
	DorisSQLParserRULE_dropDbStatement                        = 10
	DorisSQLParserRULE_showCreateDbStatement                  = 11
	DorisSQLParserRULE_alterDatabaseRenameStatement           = 12
	DorisSQLParserRULE_recoverDbStmt                          = 13
	DorisSQLParserRULE_showDataStmt                           = 14
	DorisSQLParserRULE_showDataDistributionStmt               = 15
	DorisSQLParserRULE_createTableStatement                   = 16
	DorisSQLParserRULE_columnDesc                             = 17
	DorisSQLParserRULE_charsetName                            = 18
	DorisSQLParserRULE_defaultDesc                            = 19
	DorisSQLParserRULE_generatedColumnDesc                    = 20
	DorisSQLParserRULE_indexDesc                              = 21
	DorisSQLParserRULE_engineDesc                             = 22
	DorisSQLParserRULE_charsetDesc                            = 23
	DorisSQLParserRULE_collateDesc                            = 24
	DorisSQLParserRULE_keyDesc                                = 25
	DorisSQLParserRULE_orderByDesc                            = 26
	DorisSQLParserRULE_columnNullable                         = 27
	DorisSQLParserRULE_typeWithNullable                       = 28
	DorisSQLParserRULE_aggStateDesc                           = 29
	DorisSQLParserRULE_aggDesc                                = 30
	DorisSQLParserRULE_rollupDesc                             = 31
	DorisSQLParserRULE_rollupItem                             = 32
	DorisSQLParserRULE_dupKeys                                = 33
	DorisSQLParserRULE_fromRollup                             = 34
	DorisSQLParserRULE_orReplace                              = 35
	DorisSQLParserRULE_ifNotExists                            = 36
	DorisSQLParserRULE_createTableAsSelectStatement           = 37
	DorisSQLParserRULE_dropTableStatement                     = 38
	DorisSQLParserRULE_cleanTemporaryTableStatement           = 39
	DorisSQLParserRULE_alterTableStatement                    = 40
	DorisSQLParserRULE_createIndexStatement                   = 41
	DorisSQLParserRULE_dropIndexStatement                     = 42
	DorisSQLParserRULE_indexType                              = 43
	DorisSQLParserRULE_showTableStatement                     = 44
	DorisSQLParserRULE_showTemporaryTablesStatement           = 45
	DorisSQLParserRULE_showCreateTableStatement               = 46
	DorisSQLParserRULE_showColumnStatement                    = 47
	DorisSQLParserRULE_showTableStatusStatement               = 48
	DorisSQLParserRULE_refreshTableStatement                  = 49
	DorisSQLParserRULE_showAlterStatement                     = 50
	DorisSQLParserRULE_descTableStatement                     = 51
	DorisSQLParserRULE_createTableLikeStatement               = 52
	DorisSQLParserRULE_showIndexStatement                     = 53
	DorisSQLParserRULE_recoverTableStatement                  = 54
	DorisSQLParserRULE_truncateTableStatement                 = 55
	DorisSQLParserRULE_cancelAlterTableStatement              = 56
	DorisSQLParserRULE_showPartitionsStatement                = 57
	DorisSQLParserRULE_recoverPartitionStatement              = 58
	DorisSQLParserRULE_createViewStatement                    = 59
	DorisSQLParserRULE_alterViewStatement                     = 60
	DorisSQLParserRULE_dropViewStatement                      = 61
	DorisSQLParserRULE_columnNameWithComment                  = 62
	DorisSQLParserRULE_submitTaskStatement                    = 63
	DorisSQLParserRULE_taskClause                             = 64
	DorisSQLParserRULE_dropTaskStatement                      = 65
	DorisSQLParserRULE_taskScheduleDesc                       = 66
	DorisSQLParserRULE_createMaterializedViewStatement        = 67
	DorisSQLParserRULE_mvPartitionExprs                       = 68
	DorisSQLParserRULE_materializedViewDesc                   = 69
	DorisSQLParserRULE_showMaterializedViewsStatement         = 70
	DorisSQLParserRULE_dropMaterializedViewStatement          = 71
	DorisSQLParserRULE_alterMaterializedViewStatement         = 72
	DorisSQLParserRULE_refreshMaterializedViewStatement       = 73
	DorisSQLParserRULE_cancelRefreshMaterializedViewStatement = 74
	DorisSQLParserRULE_adminSetConfigStatement                = 75
	DorisSQLParserRULE_adminSetReplicaStatusStatement         = 76
	DorisSQLParserRULE_adminShowConfigStatement               = 77
	DorisSQLParserRULE_adminShowReplicaDistributionStatement  = 78
	DorisSQLParserRULE_adminShowReplicaStatusStatement        = 79
	DorisSQLParserRULE_adminRepairTableStatement              = 80
	DorisSQLParserRULE_adminCancelRepairTableStatement        = 81
	DorisSQLParserRULE_adminCheckTabletsStatement             = 82
	DorisSQLParserRULE_adminSetPartitionVersion               = 83
	DorisSQLParserRULE_killStatement                          = 84
	DorisSQLParserRULE_syncStatement                          = 85
	DorisSQLParserRULE_adminSetAutomatedSnapshotOnStatement   = 86
	DorisSQLParserRULE_adminSetAutomatedSnapshotOffStatement  = 87
	DorisSQLParserRULE_alterSystemStatement                   = 88
	DorisSQLParserRULE_cancelAlterSystemStatement             = 89
	DorisSQLParserRULE_showComputeNodesStatement              = 90
	DorisSQLParserRULE_createExternalCatalogStatement         = 91
	DorisSQLParserRULE_showCreateExternalCatalogStatement     = 92
	DorisSQLParserRULE_dropExternalCatalogStatement           = 93
	DorisSQLParserRULE_showCatalogsStatement                  = 94
	DorisSQLParserRULE_alterCatalogStatement                  = 95
	DorisSQLParserRULE_createStorageVolumeStatement           = 96
	DorisSQLParserRULE_typeDesc                               = 97
	DorisSQLParserRULE_locationsDesc                          = 98
	DorisSQLParserRULE_showStorageVolumesStatement            = 99
	DorisSQLParserRULE_dropStorageVolumeStatement             = 100
	DorisSQLParserRULE_alterStorageVolumeStatement            = 101
	DorisSQLParserRULE_alterStorageVolumeClause               = 102
	DorisSQLParserRULE_modifyStorageVolumePropertiesClause    = 103
	DorisSQLParserRULE_modifyStorageVolumeCommentClause       = 104
	DorisSQLParserRULE_descStorageVolumeStatement             = 105
	DorisSQLParserRULE_setDefaultStorageVolumeStatement       = 106
	DorisSQLParserRULE_updateFailPointStatusStatement         = 107
	DorisSQLParserRULE_showFailPointStatement                 = 108
	DorisSQLParserRULE_createDictionaryStatement              = 109
	DorisSQLParserRULE_dropDictionaryStatement                = 110
	DorisSQLParserRULE_refreshDictionaryStatement             = 111
	DorisSQLParserRULE_showDictionaryStatement                = 112
	DorisSQLParserRULE_cancelRefreshDictionaryStatement       = 113
	DorisSQLParserRULE_dictionaryColumnDesc                   = 114
	DorisSQLParserRULE_dictionaryName                         = 115
	DorisSQLParserRULE_alterClause                            = 116
	DorisSQLParserRULE_addFrontendClause                      = 117
	DorisSQLParserRULE_dropFrontendClause                     = 118
	DorisSQLParserRULE_modifyFrontendHostClause               = 119
	DorisSQLParserRULE_addBackendClause                       = 120
	DorisSQLParserRULE_dropBackendClause                      = 121
	DorisSQLParserRULE_decommissionBackendClause              = 122
	DorisSQLParserRULE_modifyBackendClause                    = 123
	DorisSQLParserRULE_addComputeNodeClause                   = 124
	DorisSQLParserRULE_dropComputeNodeClause                  = 125
	DorisSQLParserRULE_modifyBrokerClause                     = 126
	DorisSQLParserRULE_alterLoadErrorUrlClause                = 127
	DorisSQLParserRULE_createImageClause                      = 128
	DorisSQLParserRULE_cleanTabletSchedQClause                = 129
	DorisSQLParserRULE_decommissionDiskClause                 = 130
	DorisSQLParserRULE_cancelDecommissionDiskClause           = 131
	DorisSQLParserRULE_disableDiskClause                      = 132
	DorisSQLParserRULE_cancelDisableDiskClause                = 133
	DorisSQLParserRULE_createIndexClause                      = 134
	DorisSQLParserRULE_dropIndexClause                        = 135
	DorisSQLParserRULE_tableRenameClause                      = 136
	DorisSQLParserRULE_swapTableClause                        = 137
	DorisSQLParserRULE_modifyPropertiesClause                 = 138
	DorisSQLParserRULE_modifyCommentClause                    = 139
	DorisSQLParserRULE_optimizeRange                          = 140
	DorisSQLParserRULE_optimizeClause                         = 141
	DorisSQLParserRULE_addColumnClause                        = 142
	DorisSQLParserRULE_addColumnsClause                       = 143
	DorisSQLParserRULE_dropColumnClause                       = 144
	DorisSQLParserRULE_modifyColumnClause                     = 145
	DorisSQLParserRULE_modifyColumnCommentClause              = 146
	DorisSQLParserRULE_columnRenameClause                     = 147
	DorisSQLParserRULE_reorderColumnsClause                   = 148
	DorisSQLParserRULE_rollupRenameClause                     = 149
	DorisSQLParserRULE_compactionClause                       = 150
	DorisSQLParserRULE_subfieldName                           = 151
	DorisSQLParserRULE_nestedFieldName                        = 152
	DorisSQLParserRULE_addFieldClause                         = 153
	DorisSQLParserRULE_dropFieldClause                        = 154
	DorisSQLParserRULE_createOrReplaceTagClause               = 155
	DorisSQLParserRULE_createOrReplaceBranchClause            = 156
	DorisSQLParserRULE_dropBranchClause                       = 157
	DorisSQLParserRULE_dropTagClause                          = 158
	DorisSQLParserRULE_tableOperationClause                   = 159
	DorisSQLParserRULE_tagOptions                             = 160
	DorisSQLParserRULE_branchOptions                          = 161
	DorisSQLParserRULE_snapshotRetention                      = 162
	DorisSQLParserRULE_refRetain                              = 163
	DorisSQLParserRULE_maxSnapshotAge                         = 164
	DorisSQLParserRULE_minSnapshotsToKeep                     = 165
	DorisSQLParserRULE_snapshotId                             = 166
	DorisSQLParserRULE_timeUnit                               = 167
	DorisSQLParserRULE_integer_list                           = 168
	DorisSQLParserRULE_dropPersistentIndexClause              = 169
	DorisSQLParserRULE_addPartitionClause                     = 170
	DorisSQLParserRULE_dropPartitionClause                    = 171
	DorisSQLParserRULE_truncatePartitionClause                = 172
	DorisSQLParserRULE_modifyPartitionClause                  = 173
	DorisSQLParserRULE_replacePartitionClause                 = 174
	DorisSQLParserRULE_partitionRenameClause                  = 175
	DorisSQLParserRULE_insertStatement                        = 176
	DorisSQLParserRULE_insertLabelOrColumnAliases             = 177
	DorisSQLParserRULE_columnAliasesOrByName                  = 178
	DorisSQLParserRULE_updateStatement                        = 179
	DorisSQLParserRULE_deleteStatement                        = 180
	DorisSQLParserRULE_createRoutineLoadStatement             = 181
	DorisSQLParserRULE_alterRoutineLoadStatement              = 182
	DorisSQLParserRULE_dataSource                             = 183
	DorisSQLParserRULE_loadProperties                         = 184
	DorisSQLParserRULE_colSeparatorProperty                   = 185
	DorisSQLParserRULE_rowDelimiterProperty                   = 186
	DorisSQLParserRULE_importColumns                          = 187
	DorisSQLParserRULE_columnProperties                       = 188
	DorisSQLParserRULE_jobProperties                          = 189
	DorisSQLParserRULE_dataSourceProperties                   = 190
	DorisSQLParserRULE_stopRoutineLoadStatement               = 191
	DorisSQLParserRULE_resumeRoutineLoadStatement             = 192
	DorisSQLParserRULE_pauseRoutineLoadStatement              = 193
	DorisSQLParserRULE_showRoutineLoadStatement               = 194
	DorisSQLParserRULE_showRoutineLoadTaskStatement           = 195
	DorisSQLParserRULE_showCreateRoutineLoadStatement         = 196
	DorisSQLParserRULE_showStreamLoadStatement                = 197
	DorisSQLParserRULE_analyzeStatement                       = 198
	DorisSQLParserRULE_analyzeColumnClause                    = 199
	DorisSQLParserRULE_dropStatsStatement                     = 200
	DorisSQLParserRULE_histogramStatement                     = 201
	DorisSQLParserRULE_analyzeHistogramStatement              = 202
	DorisSQLParserRULE_dropHistogramStatement                 = 203
	DorisSQLParserRULE_createAnalyzeStatement                 = 204
	DorisSQLParserRULE_dropAnalyzeJobStatement                = 205
	DorisSQLParserRULE_showAnalyzeStatement                   = 206
	DorisSQLParserRULE_showStatsMetaStatement                 = 207
	DorisSQLParserRULE_showHistogramMetaStatement             = 208
	DorisSQLParserRULE_killAnalyzeStatement                   = 209
	DorisSQLParserRULE_analyzeProfileStatement                = 210
	DorisSQLParserRULE_createBaselinePlanStatement            = 211
	DorisSQLParserRULE_dropBaselinePlanStatement              = 212
	DorisSQLParserRULE_showBaselinePlanStatement              = 213
	DorisSQLParserRULE_createResourceGroupStatement           = 214
	DorisSQLParserRULE_dropResourceGroupStatement             = 215
	DorisSQLParserRULE_alterResourceGroupStatement            = 216
	DorisSQLParserRULE_showResourceGroupStatement             = 217
	DorisSQLParserRULE_showResourceGroupUsageStatement        = 218
	DorisSQLParserRULE_createResourceStatement                = 219
	DorisSQLParserRULE_alterResourceStatement                 = 220
	DorisSQLParserRULE_dropResourceStatement                  = 221
	DorisSQLParserRULE_showResourceStatement                  = 222
	DorisSQLParserRULE_classifier                             = 223
	DorisSQLParserRULE_showFunctionsStatement                 = 224
	DorisSQLParserRULE_dropFunctionStatement                  = 225
	DorisSQLParserRULE_createFunctionStatement                = 226
	DorisSQLParserRULE_inlineFunction                         = 227
	DorisSQLParserRULE_typeList                               = 228
	DorisSQLParserRULE_loadStatement                          = 229
	DorisSQLParserRULE_labelName                              = 230
	DorisSQLParserRULE_dataDescList                           = 231
	DorisSQLParserRULE_dataDesc                               = 232
	DorisSQLParserRULE_formatProps                            = 233
	DorisSQLParserRULE_brokerDesc                             = 234
	DorisSQLParserRULE_resourceDesc                           = 235
	DorisSQLParserRULE_showLoadStatement                      = 236
	DorisSQLParserRULE_showLoadWarningsStatement              = 237
	DorisSQLParserRULE_cancelLoadStatement                    = 238
	DorisSQLParserRULE_alterLoadStatement                     = 239
	DorisSQLParserRULE_cancelCompactionStatement              = 240
	DorisSQLParserRULE_showAuthorStatement                    = 241
	DorisSQLParserRULE_showBackendsStatement                  = 242
	DorisSQLParserRULE_showBrokerStatement                    = 243
	DorisSQLParserRULE_showCharsetStatement                   = 244
	DorisSQLParserRULE_showCollationStatement                 = 245
	DorisSQLParserRULE_showDeleteStatement                    = 246
	DorisSQLParserRULE_showDynamicPartitionStatement          = 247
	DorisSQLParserRULE_showEventsStatement                    = 248
	DorisSQLParserRULE_showEnginesStatement                   = 249
	DorisSQLParserRULE_showFrontendsStatement                 = 250
	DorisSQLParserRULE_showPluginsStatement                   = 251
	DorisSQLParserRULE_showRepositoriesStatement              = 252
	DorisSQLParserRULE_showOpenTableStatement                 = 253
	DorisSQLParserRULE_showPrivilegesStatement                = 254
	DorisSQLParserRULE_showProcedureStatement                 = 255
	DorisSQLParserRULE_showProcStatement                      = 256
	DorisSQLParserRULE_showProcesslistStatement               = 257
	DorisSQLParserRULE_showProfilelistStatement               = 258
	DorisSQLParserRULE_showRunningQueriesStatement            = 259
	DorisSQLParserRULE_showStatusStatement                    = 260
	DorisSQLParserRULE_showTabletStatement                    = 261
	DorisSQLParserRULE_showTransactionStatement               = 262
	DorisSQLParserRULE_showTriggersStatement                  = 263
	DorisSQLParserRULE_showUserPropertyStatement              = 264
	DorisSQLParserRULE_showVariablesStatement                 = 265
	DorisSQLParserRULE_showWarningStatement                   = 266
	DorisSQLParserRULE_helpStatement                          = 267
	DorisSQLParserRULE_createUserStatement                    = 268
	DorisSQLParserRULE_dropUserStatement                      = 269
	DorisSQLParserRULE_alterUserStatement                     = 270
	DorisSQLParserRULE_showUserStatement                      = 271
	DorisSQLParserRULE_showAuthenticationStatement            = 272
	DorisSQLParserRULE_executeAsStatement                     = 273
	DorisSQLParserRULE_createRoleStatement                    = 274
	DorisSQLParserRULE_alterRoleStatement                     = 275
	DorisSQLParserRULE_dropRoleStatement                      = 276
	DorisSQLParserRULE_showRolesStatement                     = 277
	DorisSQLParserRULE_grantRoleStatement                     = 278
	DorisSQLParserRULE_revokeRoleStatement                    = 279
	DorisSQLParserRULE_setRoleStatement                       = 280
	DorisSQLParserRULE_setDefaultRoleStatement                = 281
	DorisSQLParserRULE_grantRevokeClause                      = 282
	DorisSQLParserRULE_grantPrivilegeStatement                = 283
	DorisSQLParserRULE_revokePrivilegeStatement               = 284
	DorisSQLParserRULE_showGrantsStatement                    = 285
	DorisSQLParserRULE_authOption                             = 286
	DorisSQLParserRULE_privObjectName                         = 287
	DorisSQLParserRULE_privObjectNameList                     = 288
	DorisSQLParserRULE_privFunctionObjectNameList             = 289
	DorisSQLParserRULE_privilegeTypeList                      = 290
	DorisSQLParserRULE_privilegeType                          = 291
	DorisSQLParserRULE_privObjectType                         = 292
	DorisSQLParserRULE_privObjectTypePlural                   = 293
	DorisSQLParserRULE_createSecurityIntegrationStatement     = 294
	DorisSQLParserRULE_alterSecurityIntegrationStatement      = 295
	DorisSQLParserRULE_dropSecurityIntegrationStatement       = 296
	DorisSQLParserRULE_showSecurityIntegrationStatement       = 297
	DorisSQLParserRULE_showCreateSecurityIntegrationStatement = 298
	DorisSQLParserRULE_createGroupProviderStatement           = 299
	DorisSQLParserRULE_dropGroupProviderStatement             = 300
	DorisSQLParserRULE_showGroupProvidersStatement            = 301
	DorisSQLParserRULE_showCreateGroupProviderStatement       = 302
	DorisSQLParserRULE_backupStatement                        = 303
	DorisSQLParserRULE_cancelBackupStatement                  = 304
	DorisSQLParserRULE_showBackupStatement                    = 305
	DorisSQLParserRULE_restoreStatement                       = 306
	DorisSQLParserRULE_cancelRestoreStatement                 = 307
	DorisSQLParserRULE_showRestoreStatement                   = 308
	DorisSQLParserRULE_showSnapshotStatement                  = 309
	DorisSQLParserRULE_createRepositoryStatement              = 310
	DorisSQLParserRULE_dropRepositoryStatement                = 311
	DorisSQLParserRULE_addSqlBlackListStatement               = 312
	DorisSQLParserRULE_delSqlBlackListStatement               = 313
	DorisSQLParserRULE_showSqlBlackListStatement              = 314
	DorisSQLParserRULE_showWhiteListStatement                 = 315
	DorisSQLParserRULE_addBackendBlackListStatement           = 316
	DorisSQLParserRULE_delBackendBlackListStatement           = 317
	DorisSQLParserRULE_showBackendBlackListStatement          = 318
	DorisSQLParserRULE_dataCacheTarget                        = 319
	DorisSQLParserRULE_createDataCacheRuleStatement           = 320
	DorisSQLParserRULE_showDataCacheRulesStatement            = 321
	DorisSQLParserRULE_dropDataCacheRuleStatement             = 322
	DorisSQLParserRULE_clearDataCacheRulesStatement           = 323
	DorisSQLParserRULE_dataCacheSelectStatement               = 324
	DorisSQLParserRULE_exportStatement                        = 325
	DorisSQLParserRULE_cancelExportStatement                  = 326
	DorisSQLParserRULE_showExportStatement                    = 327
	DorisSQLParserRULE_installPluginStatement                 = 328
	DorisSQLParserRULE_uninstallPluginStatement               = 329
	DorisSQLParserRULE_createFileStatement                    = 330
	DorisSQLParserRULE_dropFileStatement                      = 331
	DorisSQLParserRULE_showSmallFilesStatement                = 332
	DorisSQLParserRULE_createPipeStatement                    = 333
	DorisSQLParserRULE_dropPipeStatement                      = 334
	DorisSQLParserRULE_alterPipeClause                        = 335
	DorisSQLParserRULE_alterPipeStatement                     = 336
	DorisSQLParserRULE_descPipeStatement                      = 337
	DorisSQLParserRULE_showPipeStatement                      = 338
	DorisSQLParserRULE_setStatement                           = 339
	DorisSQLParserRULE_setVar                                 = 340
	DorisSQLParserRULE_transaction_characteristics            = 341
	DorisSQLParserRULE_transaction_access_mode                = 342
	DorisSQLParserRULE_isolation_level                        = 343
	DorisSQLParserRULE_isolation_types                        = 344
	DorisSQLParserRULE_setExprOrDefault                       = 345
	DorisSQLParserRULE_setUserPropertyStatement               = 346
	DorisSQLParserRULE_roleList                               = 347
	DorisSQLParserRULE_executeScriptStatement                 = 348
	DorisSQLParserRULE_unsupportedStatement                   = 349
	DorisSQLParserRULE_lock_item                              = 350
	DorisSQLParserRULE_lock_type                              = 351
	DorisSQLParserRULE_alterPlanAdvisorAddStatement           = 352
	DorisSQLParserRULE_truncatePlanAdvisorStatement           = 353
	DorisSQLParserRULE_alterPlanAdvisorDropStatement          = 354
	DorisSQLParserRULE_showPlanAdvisorStatement               = 355
	DorisSQLParserRULE_createWarehouseStatement               = 356
	DorisSQLParserRULE_dropWarehouseStatement                 = 357
	DorisSQLParserRULE_suspendWarehouseStatement              = 358
	DorisSQLParserRULE_resumeWarehouseStatement               = 359
	DorisSQLParserRULE_setWarehouseStatement                  = 360
	DorisSQLParserRULE_showWarehousesStatement                = 361
	DorisSQLParserRULE_showClustersStatement                  = 362
	DorisSQLParserRULE_showNodesStatement                     = 363
	DorisSQLParserRULE_alterWarehouseStatement                = 364
	DorisSQLParserRULE_createCNGroupStatement                 = 365
	DorisSQLParserRULE_dropCNGroupStatement                   = 366
	DorisSQLParserRULE_enableCNGroupStatement                 = 367
	DorisSQLParserRULE_disableCNGroupStatement                = 368
	DorisSQLParserRULE_alterCNGroupStatement                  = 369
	DorisSQLParserRULE_beginStatement                         = 370
	DorisSQLParserRULE_commitStatement                        = 371
	DorisSQLParserRULE_rollbackStatement                      = 372
	DorisSQLParserRULE_translateStatement                     = 373
	DorisSQLParserRULE_dialect                                = 374
	DorisSQLParserRULE_translateSQL                           = 375
	DorisSQLParserRULE_queryStatement                         = 376
	DorisSQLParserRULE_queryRelation                          = 377
	DorisSQLParserRULE_withClause                             = 378
	DorisSQLParserRULE_queryNoWith                            = 379
	DorisSQLParserRULE_queryPeriod                            = 380
	DorisSQLParserRULE_periodType                             = 381
	DorisSQLParserRULE_queryPrimary                           = 382
	DorisSQLParserRULE_subquery                               = 383
	DorisSQLParserRULE_rowConstructor                         = 384
	DorisSQLParserRULE_sortItem                               = 385
	DorisSQLParserRULE_limitConstExpr                         = 386
	DorisSQLParserRULE_limitElement                           = 387
	DorisSQLParserRULE_querySpecification                     = 388
	DorisSQLParserRULE_fromClause                             = 389
	DorisSQLParserRULE_groupingElement                        = 390
	DorisSQLParserRULE_groupingSet                            = 391
	DorisSQLParserRULE_commonTableExpression                  = 392
	DorisSQLParserRULE_setQuantifier                          = 393
	DorisSQLParserRULE_selectItem                             = 394
	DorisSQLParserRULE_excludeClause                          = 395
	DorisSQLParserRULE_relations                              = 396
	DorisSQLParserRULE_relation                               = 397
	DorisSQLParserRULE_relationPrimary                        = 398
	DorisSQLParserRULE_pivotClause                            = 399
	DorisSQLParserRULE_pivotAggregationExpression             = 400
	DorisSQLParserRULE_pivotValue                             = 401
	DorisSQLParserRULE_sampleClause                           = 402
	DorisSQLParserRULE_argumentList                           = 403
	DorisSQLParserRULE_namedArgumentList                      = 404
	DorisSQLParserRULE_namedArgument                          = 405
	DorisSQLParserRULE_joinRelation                           = 406
	DorisSQLParserRULE_crossOrInnerJoinType                   = 407
	DorisSQLParserRULE_outerAndSemiJoinType                   = 408
	DorisSQLParserRULE_bracketHint                            = 409
	DorisSQLParserRULE_hintMap                                = 410
	DorisSQLParserRULE_joinCriteria                           = 411
	DorisSQLParserRULE_columnAliases                          = 412
	DorisSQLParserRULE_partitionNames                         = 413
	DorisSQLParserRULE_keyPartitions                          = 414
	DorisSQLParserRULE_tabletList                             = 415
	DorisSQLParserRULE_prepareStatement                       = 416
	DorisSQLParserRULE_prepareSql                             = 417
	DorisSQLParserRULE_executeStatement                       = 418
	DorisSQLParserRULE_deallocateStatement                    = 419
	DorisSQLParserRULE_replicaList                            = 420
	DorisSQLParserRULE_expressionsWithDefault                 = 421
	DorisSQLParserRULE_expressionOrDefault                    = 422
	DorisSQLParserRULE_mapExpressionList                      = 423
	DorisSQLParserRULE_mapExpression                          = 424
	DorisSQLParserRULE_expressionSingleton                    = 425
	DorisSQLParserRULE_expression                             = 426
	DorisSQLParserRULE_expressionList                         = 427
	DorisSQLParserRULE_booleanExpression                      = 428
	DorisSQLParserRULE_predicate                              = 429
	DorisSQLParserRULE_tupleInSubquery                        = 430
	DorisSQLParserRULE_predicateOperations                    = 431
	DorisSQLParserRULE_valueExpression                        = 432
	DorisSQLParserRULE_primaryExpression                      = 433
	DorisSQLParserRULE_literalExpression                      = 434
	DorisSQLParserRULE_functionCall                           = 435
	DorisSQLParserRULE_aggregationFunction                    = 436
	DorisSQLParserRULE_userVariable                           = 437
	DorisSQLParserRULE_systemVariable                         = 438
	DorisSQLParserRULE_columnReference                        = 439
	DorisSQLParserRULE_informationFunctionExpression          = 440
	DorisSQLParserRULE_specialDateTimeExpression              = 441
	DorisSQLParserRULE_specialFunctionExpression              = 442
	DorisSQLParserRULE_windowFunction                         = 443
	DorisSQLParserRULE_whenClause                             = 444
	DorisSQLParserRULE_over                                   = 445
	DorisSQLParserRULE_ignoreNulls                            = 446
	DorisSQLParserRULE_windowFrame                            = 447
	DorisSQLParserRULE_frameBound                             = 448
	DorisSQLParserRULE_backupRestoreObjectDesc                = 449
	DorisSQLParserRULE_tableDesc                              = 450
	DorisSQLParserRULE_backupRestoreTableDesc                 = 451
	DorisSQLParserRULE_explainDesc                            = 452
	DorisSQLParserRULE_optimizerTrace                         = 453
	DorisSQLParserRULE_partitionExpr                          = 454
	DorisSQLParserRULE_partitionDesc                          = 455
	DorisSQLParserRULE_listPartitionDesc                      = 456
	DorisSQLParserRULE_singleItemListPartitionDesc            = 457
	DorisSQLParserRULE_multiItemListPartitionDesc             = 458
	DorisSQLParserRULE_multiListPartitionValues               = 459
	DorisSQLParserRULE_singleListPartitionValues              = 460
	DorisSQLParserRULE_listPartitionValues                    = 461
	DorisSQLParserRULE_listPartitionValue                     = 462
	DorisSQLParserRULE_stringList                             = 463
	DorisSQLParserRULE_literalExpressionList                  = 464
	DorisSQLParserRULE_rangePartitionDesc                     = 465
	DorisSQLParserRULE_singleRangePartition                   = 466
	DorisSQLParserRULE_multiRangePartition                    = 467
	DorisSQLParserRULE_partitionRangeDesc                     = 468
	DorisSQLParserRULE_partitionKeyDesc                       = 469
	DorisSQLParserRULE_partitionValueList                     = 470
	DorisSQLParserRULE_keyPartition                           = 471
	DorisSQLParserRULE_partitionValue                         = 472
	DorisSQLParserRULE_distributionClause                     = 473
	DorisSQLParserRULE_distributionDesc                       = 474
	DorisSQLParserRULE_refreshSchemeDesc                      = 475
	DorisSQLParserRULE_statusDesc                             = 476
	DorisSQLParserRULE_properties                             = 477
	DorisSQLParserRULE_extProperties                          = 478
	DorisSQLParserRULE_propertyList                           = 479
	DorisSQLParserRULE_userPropertyList                       = 480
	DorisSQLParserRULE_property                               = 481
	DorisSQLParserRULE_inlineProperties                       = 482
	DorisSQLParserRULE_inlineProperty                         = 483
	DorisSQLParserRULE_varType                                = 484
	DorisSQLParserRULE_comment                                = 485
	DorisSQLParserRULE_outfile                                = 486
	DorisSQLParserRULE_fileFormat                             = 487
	DorisSQLParserRULE_string                                 = 488
	DorisSQLParserRULE_binary                                 = 489
	DorisSQLParserRULE_comparisonOperator                     = 490
	DorisSQLParserRULE_booleanValue                           = 491
	DorisSQLParserRULE_interval                               = 492
	DorisSQLParserRULE_taskInterval                           = 493
	DorisSQLParserRULE_taskUnitIdentifier                     = 494
	DorisSQLParserRULE_unitIdentifier                         = 495
	DorisSQLParserRULE_unitBoundary                           = 496
	DorisSQLParserRULE_type                                   = 497
	DorisSQLParserRULE_arrayType                              = 498
	DorisSQLParserRULE_mapType                                = 499
	DorisSQLParserRULE_subfieldDesc                           = 500
	DorisSQLParserRULE_subfieldDescs                          = 501
	DorisSQLParserRULE_structType                             = 502
	DorisSQLParserRULE_typeParameter                          = 503
	DorisSQLParserRULE_baseType                               = 504
	DorisSQLParserRULE_decimalType                            = 505
	DorisSQLParserRULE_qualifiedName                          = 506
	DorisSQLParserRULE_tableName                              = 507
	DorisSQLParserRULE_writeBranch                            = 508
	DorisSQLParserRULE_identifier                             = 509
	DorisSQLParserRULE_identifierWithAlias                    = 510
	DorisSQLParserRULE_identifierWithAliasList                = 511
	DorisSQLParserRULE_identifierList                         = 512
	DorisSQLParserRULE_identifierOrString                     = 513
	DorisSQLParserRULE_identifierOrStringList                 = 514
	DorisSQLParserRULE_identifierOrStringOrStar               = 515
	DorisSQLParserRULE_user                                   = 516
	DorisSQLParserRULE_assignment                             = 517
	DorisSQLParserRULE_assignmentList                         = 518
	DorisSQLParserRULE_number                                 = 519
	DorisSQLParserRULE_nonReserved                            = 520
)

// ISqlStatementsContext is an interface to support dynamic dispatch.
type ISqlStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllSingleStatement() []ISingleStatementContext
	SingleStatement(i int) ISingleStatementContext

	// IsSqlStatementsContext differentiates from other interfaces.
	IsSqlStatementsContext()
}

type SqlStatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlStatementsContext() *SqlStatementsContext {
	var p = new(SqlStatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_sqlStatements
	return p
}

func InitEmptySqlStatementsContext(p *SqlStatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_sqlStatements
}

func (*SqlStatementsContext) IsSqlStatementsContext() {}

func NewSqlStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlStatementsContext {
	var p = new(SqlStatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_sqlStatements

	return p
}

func (s *SqlStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlStatementsContext) EOF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEOF, 0)
}

func (s *SqlStatementsContext) AllSingleStatement() []ISingleStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleStatementContext); ok {
			len++
		}
	}

	tst := make([]ISingleStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleStatementContext); ok {
			tst[i] = t.(ISingleStatementContext)
			i++
		}
	}

	return tst
}

func (s *SqlStatementsContext) SingleStatement(i int) ISingleStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleStatementContext)
}

func (s *SqlStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSqlStatements(s)
	}
}

func (s *SqlStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSqlStatements(s)
	}
}

func (s *SqlStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSqlStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SqlStatements() (localctx ISqlStatementsContext) {
	localctx = NewSqlStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, DorisSQLParserRULE_sqlStatements)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1043)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&216174019065962500) != 0) || ((int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&433475862185117699) != 0) || ((int64((_la-132)) & ^0x3f) == 0 && ((int64(1)<<(_la-132))&72198331526709249) != 0) || ((int64((_la-209)) & ^0x3f) == 0 && ((int64(1)<<(_la-209))&17180917763) != 0) || ((int64((_la-307)) & ^0x3f) == 0 && ((int64(1)<<(_la-307))&4827862099076087809) != 0) || ((int64((_la-375)) & ^0x3f) == 0 && ((int64(1)<<(_la-375))&7166222204929) != 0) || ((int64((_la-439)) & ^0x3f) == 0 && ((int64(1)<<(_la-439))&107752139857989) != 0) || _la == DorisSQLParserSEMICOLON {
		{
			p.SetState(1042)
			p.SingleStatement()
		}

		p.SetState(1045)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1047)
		p.Match(DorisSQLParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleStatementContext is an interface to support dynamic dispatch.
type ISingleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Statement() IStatementContext
	SEMICOLON() antlr.TerminalNode
	EOF() antlr.TerminalNode
	EmptyStatement() IEmptyStatementContext

	// IsSingleStatementContext differentiates from other interfaces.
	IsSingleStatementContext()
}

type SingleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleStatementContext() *SingleStatementContext {
	var p = new(SingleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_singleStatement
	return p
}

func InitEmptySingleStatementContext(p *SingleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_singleStatement
}

func (*SingleStatementContext) IsSingleStatementContext() {}

func NewSingleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleStatementContext {
	var p = new(SingleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_singleStatement

	return p
}

func (s *SingleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SingleStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSEMICOLON, 0)
}

func (s *SingleStatementContext) EOF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEOF, 0)
}

func (s *SingleStatementContext) EmptyStatement() IEmptyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatementContext)
}

func (s *SingleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSingleStatement(s)
	}
}

func (s *SingleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSingleStatement(s)
	}
}

func (s *SingleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSingleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SingleStatement() (localctx ISingleStatementContext) {
	localctx = NewSingleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, DorisSQLParserRULE_singleStatement)
	var _la int

	p.SetState(1053)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserT__1, DorisSQLParserADD, DorisSQLParserADMIN, DorisSQLParserALTER, DorisSQLParserANALYZE, DorisSQLParserBACKUP, DorisSQLParserBEGIN, DorisSQLParserCACHE, DorisSQLParserCANCEL, DorisSQLParserCLEAN, DorisSQLParserCLEAR, DorisSQLParserCOMMIT, DorisSQLParserCREATE, DorisSQLParserDEALLOCATE, DorisSQLParserDELETE, DorisSQLParserDESC, DorisSQLParserDESCRIBE, DorisSQLParserDROP, DorisSQLParserEXECUTE, DorisSQLParserEXPLAIN, DorisSQLParserEXPORT, DorisSQLParserGRANT, DorisSQLParserHELP, DorisSQLParserINSTALL, DorisSQLParserINSERT, DorisSQLParserKILL, DorisSQLParserLOAD, DorisSQLParserPAUSE, DorisSQLParserPREPARE, DorisSQLParserRECOVER, DorisSQLParserREFRESH, DorisSQLParserRESTORE, DorisSQLParserRESUME, DorisSQLParserREVOKE, DorisSQLParserROLLBACK, DorisSQLParserSELECT, DorisSQLParserSET, DorisSQLParserSHOW, DorisSQLParserSTART, DorisSQLParserSTOP, DorisSQLParserSUBMIT, DorisSQLParserSUSPEND, DorisSQLParserSYNC, DorisSQLParserTRANSLATE, DorisSQLParserTRACE, DorisSQLParserTRUNCATE, DorisSQLParserUNINSTALL, DorisSQLParserUPDATE, DorisSQLParserUSE, DorisSQLParserWITH, DorisSQLParserLOCK, DorisSQLParserUNLOCK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1049)
			p.Statement()
		}
		{
			p.SetState(1050)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserEOF || _la == DorisSQLParserSEMICOLON) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case DorisSQLParserSEMICOLON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1052)
			p.EmptyStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmptyStatementContext is an interface to support dynamic dispatch.
type IEmptyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMICOLON() antlr.TerminalNode

	// IsEmptyStatementContext differentiates from other interfaces.
	IsEmptyStatementContext()
}

type EmptyStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatementContext() *EmptyStatementContext {
	var p = new(EmptyStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_emptyStatement
	return p
}

func InitEmptyEmptyStatementContext(p *EmptyStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_emptyStatement
}

func (*EmptyStatementContext) IsEmptyStatementContext() {}

func NewEmptyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatementContext {
	var p = new(EmptyStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_emptyStatement

	return p
}

func (s *EmptyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EmptyStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSEMICOLON, 0)
}

func (s *EmptyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterEmptyStatement(s)
	}
}

func (s *EmptyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitEmptyStatement(s)
	}
}

func (s *EmptyStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitEmptyStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) EmptyStatement() (localctx IEmptyStatementContext) {
	localctx = NewEmptyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, DorisSQLParserRULE_emptyStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1055)
		p.Match(DorisSQLParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryStatement() IQueryStatementContext
	UseDatabaseStatement() IUseDatabaseStatementContext
	UseCatalogStatement() IUseCatalogStatementContext
	SetCatalogStatement() ISetCatalogStatementContext
	ShowDatabasesStatement() IShowDatabasesStatementContext
	AlterDbQuotaStatement() IAlterDbQuotaStatementContext
	CreateDbStatement() ICreateDbStatementContext
	DropDbStatement() IDropDbStatementContext
	ShowCreateDbStatement() IShowCreateDbStatementContext
	AlterDatabaseRenameStatement() IAlterDatabaseRenameStatementContext
	RecoverDbStmt() IRecoverDbStmtContext
	ShowDataStmt() IShowDataStmtContext
	ShowDataDistributionStmt() IShowDataDistributionStmtContext
	CreateTableStatement() ICreateTableStatementContext
	CreateTableAsSelectStatement() ICreateTableAsSelectStatementContext
	CreateTableLikeStatement() ICreateTableLikeStatementContext
	ShowCreateTableStatement() IShowCreateTableStatementContext
	DropTableStatement() IDropTableStatementContext
	CleanTemporaryTableStatement() ICleanTemporaryTableStatementContext
	RecoverTableStatement() IRecoverTableStatementContext
	TruncateTableStatement() ITruncateTableStatementContext
	ShowTableStatement() IShowTableStatementContext
	DescTableStatement() IDescTableStatementContext
	ShowTableStatusStatement() IShowTableStatusStatementContext
	ShowColumnStatement() IShowColumnStatementContext
	RefreshTableStatement() IRefreshTableStatementContext
	AlterTableStatement() IAlterTableStatementContext
	CancelAlterTableStatement() ICancelAlterTableStatementContext
	ShowAlterStatement() IShowAlterStatementContext
	ShowTemporaryTablesStatement() IShowTemporaryTablesStatementContext
	CreateViewStatement() ICreateViewStatementContext
	AlterViewStatement() IAlterViewStatementContext
	DropViewStatement() IDropViewStatementContext
	ShowPartitionsStatement() IShowPartitionsStatementContext
	RecoverPartitionStatement() IRecoverPartitionStatementContext
	CreateIndexStatement() ICreateIndexStatementContext
	DropIndexStatement() IDropIndexStatementContext
	ShowIndexStatement() IShowIndexStatementContext
	SubmitTaskStatement() ISubmitTaskStatementContext
	DropTaskStatement() IDropTaskStatementContext
	CreateMaterializedViewStatement() ICreateMaterializedViewStatementContext
	ShowMaterializedViewsStatement() IShowMaterializedViewsStatementContext
	DropMaterializedViewStatement() IDropMaterializedViewStatementContext
	AlterMaterializedViewStatement() IAlterMaterializedViewStatementContext
	RefreshMaterializedViewStatement() IRefreshMaterializedViewStatementContext
	CancelRefreshMaterializedViewStatement() ICancelRefreshMaterializedViewStatementContext
	CreateExternalCatalogStatement() ICreateExternalCatalogStatementContext
	DropExternalCatalogStatement() IDropExternalCatalogStatementContext
	ShowCatalogsStatement() IShowCatalogsStatementContext
	ShowCreateExternalCatalogStatement() IShowCreateExternalCatalogStatementContext
	AlterCatalogStatement() IAlterCatalogStatementContext
	InsertStatement() IInsertStatementContext
	UpdateStatement() IUpdateStatementContext
	DeleteStatement() IDeleteStatementContext
	CreateRoutineLoadStatement() ICreateRoutineLoadStatementContext
	AlterRoutineLoadStatement() IAlterRoutineLoadStatementContext
	StopRoutineLoadStatement() IStopRoutineLoadStatementContext
	ResumeRoutineLoadStatement() IResumeRoutineLoadStatementContext
	PauseRoutineLoadStatement() IPauseRoutineLoadStatementContext
	ShowRoutineLoadStatement() IShowRoutineLoadStatementContext
	ShowRoutineLoadTaskStatement() IShowRoutineLoadTaskStatementContext
	ShowCreateRoutineLoadStatement() IShowCreateRoutineLoadStatementContext
	ShowStreamLoadStatement() IShowStreamLoadStatementContext
	AdminSetConfigStatement() IAdminSetConfigStatementContext
	AdminSetReplicaStatusStatement() IAdminSetReplicaStatusStatementContext
	AdminShowConfigStatement() IAdminShowConfigStatementContext
	AdminShowReplicaDistributionStatement() IAdminShowReplicaDistributionStatementContext
	AdminShowReplicaStatusStatement() IAdminShowReplicaStatusStatementContext
	AdminRepairTableStatement() IAdminRepairTableStatementContext
	AdminCancelRepairTableStatement() IAdminCancelRepairTableStatementContext
	AdminCheckTabletsStatement() IAdminCheckTabletsStatementContext
	AdminSetPartitionVersion() IAdminSetPartitionVersionContext
	KillStatement() IKillStatementContext
	SyncStatement() ISyncStatementContext
	ExecuteScriptStatement() IExecuteScriptStatementContext
	AdminSetAutomatedSnapshotOnStatement() IAdminSetAutomatedSnapshotOnStatementContext
	AdminSetAutomatedSnapshotOffStatement() IAdminSetAutomatedSnapshotOffStatementContext
	AlterSystemStatement() IAlterSystemStatementContext
	CancelAlterSystemStatement() ICancelAlterSystemStatementContext
	ShowComputeNodesStatement() IShowComputeNodesStatementContext
	AnalyzeStatement() IAnalyzeStatementContext
	DropStatsStatement() IDropStatsStatementContext
	CreateAnalyzeStatement() ICreateAnalyzeStatementContext
	DropAnalyzeJobStatement() IDropAnalyzeJobStatementContext
	AnalyzeHistogramStatement() IAnalyzeHistogramStatementContext
	DropHistogramStatement() IDropHistogramStatementContext
	ShowAnalyzeStatement() IShowAnalyzeStatementContext
	ShowStatsMetaStatement() IShowStatsMetaStatementContext
	ShowHistogramMetaStatement() IShowHistogramMetaStatementContext
	KillAnalyzeStatement() IKillAnalyzeStatementContext
	AnalyzeProfileStatement() IAnalyzeProfileStatementContext
	CreateResourceGroupStatement() ICreateResourceGroupStatementContext
	DropResourceGroupStatement() IDropResourceGroupStatementContext
	AlterResourceGroupStatement() IAlterResourceGroupStatementContext
	ShowResourceGroupStatement() IShowResourceGroupStatementContext
	ShowResourceGroupUsageStatement() IShowResourceGroupUsageStatementContext
	CreateResourceStatement() ICreateResourceStatementContext
	AlterResourceStatement() IAlterResourceStatementContext
	DropResourceStatement() IDropResourceStatementContext
	ShowResourceStatement() IShowResourceStatementContext
	ShowFunctionsStatement() IShowFunctionsStatementContext
	DropFunctionStatement() IDropFunctionStatementContext
	CreateFunctionStatement() ICreateFunctionStatementContext
	LoadStatement() ILoadStatementContext
	ShowLoadStatement() IShowLoadStatementContext
	ShowLoadWarningsStatement() IShowLoadWarningsStatementContext
	CancelLoadStatement() ICancelLoadStatementContext
	AlterLoadStatement() IAlterLoadStatementContext
	ShowAuthorStatement() IShowAuthorStatementContext
	ShowBackendsStatement() IShowBackendsStatementContext
	ShowBrokerStatement() IShowBrokerStatementContext
	ShowCharsetStatement() IShowCharsetStatementContext
	ShowCollationStatement() IShowCollationStatementContext
	ShowDeleteStatement() IShowDeleteStatementContext
	ShowDynamicPartitionStatement() IShowDynamicPartitionStatementContext
	ShowEventsStatement() IShowEventsStatementContext
	ShowEnginesStatement() IShowEnginesStatementContext
	ShowFrontendsStatement() IShowFrontendsStatementContext
	ShowPluginsStatement() IShowPluginsStatementContext
	ShowRepositoriesStatement() IShowRepositoriesStatementContext
	ShowOpenTableStatement() IShowOpenTableStatementContext
	ShowPrivilegesStatement() IShowPrivilegesStatementContext
	ShowProcedureStatement() IShowProcedureStatementContext
	ShowProcStatement() IShowProcStatementContext
	ShowProcesslistStatement() IShowProcesslistStatementContext
	ShowProfilelistStatement() IShowProfilelistStatementContext
	ShowRunningQueriesStatement() IShowRunningQueriesStatementContext
	ShowStatusStatement() IShowStatusStatementContext
	ShowTabletStatement() IShowTabletStatementContext
	ShowTransactionStatement() IShowTransactionStatementContext
	ShowTriggersStatement() IShowTriggersStatementContext
	ShowUserPropertyStatement() IShowUserPropertyStatementContext
	ShowVariablesStatement() IShowVariablesStatementContext
	ShowWarningStatement() IShowWarningStatementContext
	HelpStatement() IHelpStatementContext
	CreateUserStatement() ICreateUserStatementContext
	DropUserStatement() IDropUserStatementContext
	AlterUserStatement() IAlterUserStatementContext
	ShowUserStatement() IShowUserStatementContext
	ShowAuthenticationStatement() IShowAuthenticationStatementContext
	ExecuteAsStatement() IExecuteAsStatementContext
	CreateRoleStatement() ICreateRoleStatementContext
	AlterRoleStatement() IAlterRoleStatementContext
	DropRoleStatement() IDropRoleStatementContext
	ShowRolesStatement() IShowRolesStatementContext
	GrantRoleStatement() IGrantRoleStatementContext
	RevokeRoleStatement() IRevokeRoleStatementContext
	SetRoleStatement() ISetRoleStatementContext
	SetDefaultRoleStatement() ISetDefaultRoleStatementContext
	GrantPrivilegeStatement() IGrantPrivilegeStatementContext
	RevokePrivilegeStatement() IRevokePrivilegeStatementContext
	ShowGrantsStatement() IShowGrantsStatementContext
	CreateSecurityIntegrationStatement() ICreateSecurityIntegrationStatementContext
	AlterSecurityIntegrationStatement() IAlterSecurityIntegrationStatementContext
	DropSecurityIntegrationStatement() IDropSecurityIntegrationStatementContext
	ShowSecurityIntegrationStatement() IShowSecurityIntegrationStatementContext
	ShowCreateSecurityIntegrationStatement() IShowCreateSecurityIntegrationStatementContext
	CreateGroupProviderStatement() ICreateGroupProviderStatementContext
	DropGroupProviderStatement() IDropGroupProviderStatementContext
	ShowGroupProvidersStatement() IShowGroupProvidersStatementContext
	ShowCreateGroupProviderStatement() IShowCreateGroupProviderStatementContext
	BackupStatement() IBackupStatementContext
	CancelBackupStatement() ICancelBackupStatementContext
	ShowBackupStatement() IShowBackupStatementContext
	RestoreStatement() IRestoreStatementContext
	CancelRestoreStatement() ICancelRestoreStatementContext
	ShowRestoreStatement() IShowRestoreStatementContext
	ShowSnapshotStatement() IShowSnapshotStatementContext
	CreateRepositoryStatement() ICreateRepositoryStatementContext
	DropRepositoryStatement() IDropRepositoryStatementContext
	AddSqlBlackListStatement() IAddSqlBlackListStatementContext
	DelSqlBlackListStatement() IDelSqlBlackListStatementContext
	ShowSqlBlackListStatement() IShowSqlBlackListStatementContext
	ShowWhiteListStatement() IShowWhiteListStatementContext
	AddBackendBlackListStatement() IAddBackendBlackListStatementContext
	DelBackendBlackListStatement() IDelBackendBlackListStatementContext
	ShowBackendBlackListStatement() IShowBackendBlackListStatementContext
	CreateDataCacheRuleStatement() ICreateDataCacheRuleStatementContext
	ShowDataCacheRulesStatement() IShowDataCacheRulesStatementContext
	DropDataCacheRuleStatement() IDropDataCacheRuleStatementContext
	ClearDataCacheRulesStatement() IClearDataCacheRulesStatementContext
	DataCacheSelectStatement() IDataCacheSelectStatementContext
	ExportStatement() IExportStatementContext
	CancelExportStatement() ICancelExportStatementContext
	ShowExportStatement() IShowExportStatementContext
	InstallPluginStatement() IInstallPluginStatementContext
	UninstallPluginStatement() IUninstallPluginStatementContext
	CreateFileStatement() ICreateFileStatementContext
	DropFileStatement() IDropFileStatementContext
	ShowSmallFilesStatement() IShowSmallFilesStatementContext
	SetStatement() ISetStatementContext
	SetUserPropertyStatement() ISetUserPropertyStatementContext
	CreateStorageVolumeStatement() ICreateStorageVolumeStatementContext
	AlterStorageVolumeStatement() IAlterStorageVolumeStatementContext
	DropStorageVolumeStatement() IDropStorageVolumeStatementContext
	ShowStorageVolumesStatement() IShowStorageVolumesStatementContext
	DescStorageVolumeStatement() IDescStorageVolumeStatementContext
	SetDefaultStorageVolumeStatement() ISetDefaultStorageVolumeStatementContext
	CreatePipeStatement() ICreatePipeStatementContext
	DropPipeStatement() IDropPipeStatementContext
	AlterPipeStatement() IAlterPipeStatementContext
	ShowPipeStatement() IShowPipeStatementContext
	DescPipeStatement() IDescPipeStatementContext
	CancelCompactionStatement() ICancelCompactionStatementContext
	UpdateFailPointStatusStatement() IUpdateFailPointStatusStatementContext
	ShowFailPointStatement() IShowFailPointStatementContext
	PrepareStatement() IPrepareStatementContext
	ExecuteStatement() IExecuteStatementContext
	DeallocateStatement() IDeallocateStatementContext
	CreateDictionaryStatement() ICreateDictionaryStatementContext
	DropDictionaryStatement() IDropDictionaryStatementContext
	RefreshDictionaryStatement() IRefreshDictionaryStatementContext
	ShowDictionaryStatement() IShowDictionaryStatementContext
	CancelRefreshDictionaryStatement() ICancelRefreshDictionaryStatementContext
	AlterPlanAdvisorAddStatement() IAlterPlanAdvisorAddStatementContext
	TruncatePlanAdvisorStatement() ITruncatePlanAdvisorStatementContext
	AlterPlanAdvisorDropStatement() IAlterPlanAdvisorDropStatementContext
	ShowPlanAdvisorStatement() IShowPlanAdvisorStatementContext
	CreateWarehouseStatement() ICreateWarehouseStatementContext
	DropWarehouseStatement() IDropWarehouseStatementContext
	SuspendWarehouseStatement() ISuspendWarehouseStatementContext
	ResumeWarehouseStatement() IResumeWarehouseStatementContext
	SetWarehouseStatement() ISetWarehouseStatementContext
	ShowWarehousesStatement() IShowWarehousesStatementContext
	ShowClustersStatement() IShowClustersStatementContext
	ShowNodesStatement() IShowNodesStatementContext
	AlterWarehouseStatement() IAlterWarehouseStatementContext
	CreateCNGroupStatement() ICreateCNGroupStatementContext
	DropCNGroupStatement() IDropCNGroupStatementContext
	EnableCNGroupStatement() IEnableCNGroupStatementContext
	DisableCNGroupStatement() IDisableCNGroupStatementContext
	AlterCNGroupStatement() IAlterCNGroupStatementContext
	BeginStatement() IBeginStatementContext
	CommitStatement() ICommitStatementContext
	RollbackStatement() IRollbackStatementContext
	TranslateStatement() ITranslateStatementContext
	CreateBaselinePlanStatement() ICreateBaselinePlanStatementContext
	DropBaselinePlanStatement() IDropBaselinePlanStatementContext
	ShowBaselinePlanStatement() IShowBaselinePlanStatementContext
	UnsupportedStatement() IUnsupportedStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *StatementContext) UseDatabaseStatement() IUseDatabaseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseDatabaseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseDatabaseStatementContext)
}

func (s *StatementContext) UseCatalogStatement() IUseCatalogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseCatalogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseCatalogStatementContext)
}

func (s *StatementContext) SetCatalogStatement() ISetCatalogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetCatalogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetCatalogStatementContext)
}

func (s *StatementContext) ShowDatabasesStatement() IShowDatabasesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDatabasesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDatabasesStatementContext)
}

func (s *StatementContext) AlterDbQuotaStatement() IAlterDbQuotaStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterDbQuotaStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterDbQuotaStatementContext)
}

func (s *StatementContext) CreateDbStatement() ICreateDbStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDbStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDbStatementContext)
}

func (s *StatementContext) DropDbStatement() IDropDbStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropDbStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropDbStatementContext)
}

func (s *StatementContext) ShowCreateDbStatement() IShowCreateDbStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCreateDbStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCreateDbStatementContext)
}

func (s *StatementContext) AlterDatabaseRenameStatement() IAlterDatabaseRenameStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterDatabaseRenameStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterDatabaseRenameStatementContext)
}

func (s *StatementContext) RecoverDbStmt() IRecoverDbStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecoverDbStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecoverDbStmtContext)
}

func (s *StatementContext) ShowDataStmt() IShowDataStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDataStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDataStmtContext)
}

func (s *StatementContext) ShowDataDistributionStmt() IShowDataDistributionStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDataDistributionStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDataDistributionStmtContext)
}

func (s *StatementContext) CreateTableStatement() ICreateTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableStatementContext)
}

func (s *StatementContext) CreateTableAsSelectStatement() ICreateTableAsSelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableAsSelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableAsSelectStatementContext)
}

func (s *StatementContext) CreateTableLikeStatement() ICreateTableLikeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableLikeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableLikeStatementContext)
}

func (s *StatementContext) ShowCreateTableStatement() IShowCreateTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCreateTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCreateTableStatementContext)
}

func (s *StatementContext) DropTableStatement() IDropTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTableStatementContext)
}

func (s *StatementContext) CleanTemporaryTableStatement() ICleanTemporaryTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICleanTemporaryTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICleanTemporaryTableStatementContext)
}

func (s *StatementContext) RecoverTableStatement() IRecoverTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecoverTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecoverTableStatementContext)
}

func (s *StatementContext) TruncateTableStatement() ITruncateTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncateTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncateTableStatementContext)
}

func (s *StatementContext) ShowTableStatement() IShowTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTableStatementContext)
}

func (s *StatementContext) DescTableStatement() IDescTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescTableStatementContext)
}

func (s *StatementContext) ShowTableStatusStatement() IShowTableStatusStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTableStatusStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTableStatusStatementContext)
}

func (s *StatementContext) ShowColumnStatement() IShowColumnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowColumnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowColumnStatementContext)
}

func (s *StatementContext) RefreshTableStatement() IRefreshTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshTableStatementContext)
}

func (s *StatementContext) AlterTableStatement() IAlterTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableStatementContext)
}

func (s *StatementContext) CancelAlterTableStatement() ICancelAlterTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelAlterTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelAlterTableStatementContext)
}

func (s *StatementContext) ShowAlterStatement() IShowAlterStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowAlterStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowAlterStatementContext)
}

func (s *StatementContext) ShowTemporaryTablesStatement() IShowTemporaryTablesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTemporaryTablesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTemporaryTablesStatementContext)
}

func (s *StatementContext) CreateViewStatement() ICreateViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateViewStatementContext)
}

func (s *StatementContext) AlterViewStatement() IAlterViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterViewStatementContext)
}

func (s *StatementContext) DropViewStatement() IDropViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropViewStatementContext)
}

func (s *StatementContext) ShowPartitionsStatement() IShowPartitionsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowPartitionsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowPartitionsStatementContext)
}

func (s *StatementContext) RecoverPartitionStatement() IRecoverPartitionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecoverPartitionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecoverPartitionStatementContext)
}

func (s *StatementContext) CreateIndexStatement() ICreateIndexStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateIndexStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateIndexStatementContext)
}

func (s *StatementContext) DropIndexStatement() IDropIndexStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropIndexStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropIndexStatementContext)
}

func (s *StatementContext) ShowIndexStatement() IShowIndexStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowIndexStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowIndexStatementContext)
}

func (s *StatementContext) SubmitTaskStatement() ISubmitTaskStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubmitTaskStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubmitTaskStatementContext)
}

func (s *StatementContext) DropTaskStatement() IDropTaskStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTaskStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTaskStatementContext)
}

func (s *StatementContext) CreateMaterializedViewStatement() ICreateMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateMaterializedViewStatementContext)
}

func (s *StatementContext) ShowMaterializedViewsStatement() IShowMaterializedViewsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowMaterializedViewsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowMaterializedViewsStatementContext)
}

func (s *StatementContext) DropMaterializedViewStatement() IDropMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropMaterializedViewStatementContext)
}

func (s *StatementContext) AlterMaterializedViewStatement() IAlterMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterMaterializedViewStatementContext)
}

func (s *StatementContext) RefreshMaterializedViewStatement() IRefreshMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshMaterializedViewStatementContext)
}

func (s *StatementContext) CancelRefreshMaterializedViewStatement() ICancelRefreshMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelRefreshMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelRefreshMaterializedViewStatementContext)
}

func (s *StatementContext) CreateExternalCatalogStatement() ICreateExternalCatalogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateExternalCatalogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateExternalCatalogStatementContext)
}

func (s *StatementContext) DropExternalCatalogStatement() IDropExternalCatalogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropExternalCatalogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropExternalCatalogStatementContext)
}

func (s *StatementContext) ShowCatalogsStatement() IShowCatalogsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCatalogsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCatalogsStatementContext)
}

func (s *StatementContext) ShowCreateExternalCatalogStatement() IShowCreateExternalCatalogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCreateExternalCatalogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCreateExternalCatalogStatementContext)
}

func (s *StatementContext) AlterCatalogStatement() IAlterCatalogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterCatalogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterCatalogStatementContext)
}

func (s *StatementContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *StatementContext) UpdateStatement() IUpdateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateStatementContext)
}

func (s *StatementContext) DeleteStatement() IDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteStatementContext)
}

func (s *StatementContext) CreateRoutineLoadStatement() ICreateRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRoutineLoadStatementContext)
}

func (s *StatementContext) AlterRoutineLoadStatement() IAlterRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterRoutineLoadStatementContext)
}

func (s *StatementContext) StopRoutineLoadStatement() IStopRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStopRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStopRoutineLoadStatementContext)
}

func (s *StatementContext) ResumeRoutineLoadStatement() IResumeRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResumeRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResumeRoutineLoadStatementContext)
}

func (s *StatementContext) PauseRoutineLoadStatement() IPauseRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPauseRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPauseRoutineLoadStatementContext)
}

func (s *StatementContext) ShowRoutineLoadStatement() IShowRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRoutineLoadStatementContext)
}

func (s *StatementContext) ShowRoutineLoadTaskStatement() IShowRoutineLoadTaskStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRoutineLoadTaskStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRoutineLoadTaskStatementContext)
}

func (s *StatementContext) ShowCreateRoutineLoadStatement() IShowCreateRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCreateRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCreateRoutineLoadStatementContext)
}

func (s *StatementContext) ShowStreamLoadStatement() IShowStreamLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStreamLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStreamLoadStatementContext)
}

func (s *StatementContext) AdminSetConfigStatement() IAdminSetConfigStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminSetConfigStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminSetConfigStatementContext)
}

func (s *StatementContext) AdminSetReplicaStatusStatement() IAdminSetReplicaStatusStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminSetReplicaStatusStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminSetReplicaStatusStatementContext)
}

func (s *StatementContext) AdminShowConfigStatement() IAdminShowConfigStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminShowConfigStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminShowConfigStatementContext)
}

func (s *StatementContext) AdminShowReplicaDistributionStatement() IAdminShowReplicaDistributionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminShowReplicaDistributionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminShowReplicaDistributionStatementContext)
}

func (s *StatementContext) AdminShowReplicaStatusStatement() IAdminShowReplicaStatusStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminShowReplicaStatusStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminShowReplicaStatusStatementContext)
}

func (s *StatementContext) AdminRepairTableStatement() IAdminRepairTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminRepairTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminRepairTableStatementContext)
}

func (s *StatementContext) AdminCancelRepairTableStatement() IAdminCancelRepairTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminCancelRepairTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminCancelRepairTableStatementContext)
}

func (s *StatementContext) AdminCheckTabletsStatement() IAdminCheckTabletsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminCheckTabletsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminCheckTabletsStatementContext)
}

func (s *StatementContext) AdminSetPartitionVersion() IAdminSetPartitionVersionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminSetPartitionVersionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminSetPartitionVersionContext)
}

func (s *StatementContext) KillStatement() IKillStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKillStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKillStatementContext)
}

func (s *StatementContext) SyncStatement() ISyncStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyncStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyncStatementContext)
}

func (s *StatementContext) ExecuteScriptStatement() IExecuteScriptStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteScriptStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteScriptStatementContext)
}

func (s *StatementContext) AdminSetAutomatedSnapshotOnStatement() IAdminSetAutomatedSnapshotOnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminSetAutomatedSnapshotOnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminSetAutomatedSnapshotOnStatementContext)
}

func (s *StatementContext) AdminSetAutomatedSnapshotOffStatement() IAdminSetAutomatedSnapshotOffStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminSetAutomatedSnapshotOffStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminSetAutomatedSnapshotOffStatementContext)
}

func (s *StatementContext) AlterSystemStatement() IAlterSystemStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterSystemStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterSystemStatementContext)
}

func (s *StatementContext) CancelAlterSystemStatement() ICancelAlterSystemStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelAlterSystemStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelAlterSystemStatementContext)
}

func (s *StatementContext) ShowComputeNodesStatement() IShowComputeNodesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowComputeNodesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowComputeNodesStatementContext)
}

func (s *StatementContext) AnalyzeStatement() IAnalyzeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeStatementContext)
}

func (s *StatementContext) DropStatsStatement() IDropStatsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropStatsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropStatsStatementContext)
}

func (s *StatementContext) CreateAnalyzeStatement() ICreateAnalyzeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateAnalyzeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateAnalyzeStatementContext)
}

func (s *StatementContext) DropAnalyzeJobStatement() IDropAnalyzeJobStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropAnalyzeJobStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropAnalyzeJobStatementContext)
}

func (s *StatementContext) AnalyzeHistogramStatement() IAnalyzeHistogramStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeHistogramStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeHistogramStatementContext)
}

func (s *StatementContext) DropHistogramStatement() IDropHistogramStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropHistogramStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropHistogramStatementContext)
}

func (s *StatementContext) ShowAnalyzeStatement() IShowAnalyzeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowAnalyzeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowAnalyzeStatementContext)
}

func (s *StatementContext) ShowStatsMetaStatement() IShowStatsMetaStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStatsMetaStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStatsMetaStatementContext)
}

func (s *StatementContext) ShowHistogramMetaStatement() IShowHistogramMetaStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowHistogramMetaStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowHistogramMetaStatementContext)
}

func (s *StatementContext) KillAnalyzeStatement() IKillAnalyzeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKillAnalyzeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKillAnalyzeStatementContext)
}

func (s *StatementContext) AnalyzeProfileStatement() IAnalyzeProfileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeProfileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeProfileStatementContext)
}

func (s *StatementContext) CreateResourceGroupStatement() ICreateResourceGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateResourceGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateResourceGroupStatementContext)
}

func (s *StatementContext) DropResourceGroupStatement() IDropResourceGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropResourceGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropResourceGroupStatementContext)
}

func (s *StatementContext) AlterResourceGroupStatement() IAlterResourceGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterResourceGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterResourceGroupStatementContext)
}

func (s *StatementContext) ShowResourceGroupStatement() IShowResourceGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowResourceGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowResourceGroupStatementContext)
}

func (s *StatementContext) ShowResourceGroupUsageStatement() IShowResourceGroupUsageStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowResourceGroupUsageStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowResourceGroupUsageStatementContext)
}

func (s *StatementContext) CreateResourceStatement() ICreateResourceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateResourceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateResourceStatementContext)
}

func (s *StatementContext) AlterResourceStatement() IAlterResourceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterResourceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterResourceStatementContext)
}

func (s *StatementContext) DropResourceStatement() IDropResourceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropResourceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropResourceStatementContext)
}

func (s *StatementContext) ShowResourceStatement() IShowResourceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowResourceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowResourceStatementContext)
}

func (s *StatementContext) ShowFunctionsStatement() IShowFunctionsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFunctionsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFunctionsStatementContext)
}

func (s *StatementContext) DropFunctionStatement() IDropFunctionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFunctionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFunctionStatementContext)
}

func (s *StatementContext) CreateFunctionStatement() ICreateFunctionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateFunctionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateFunctionStatementContext)
}

func (s *StatementContext) LoadStatement() ILoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadStatementContext)
}

func (s *StatementContext) ShowLoadStatement() IShowLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowLoadStatementContext)
}

func (s *StatementContext) ShowLoadWarningsStatement() IShowLoadWarningsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowLoadWarningsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowLoadWarningsStatementContext)
}

func (s *StatementContext) CancelLoadStatement() ICancelLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelLoadStatementContext)
}

func (s *StatementContext) AlterLoadStatement() IAlterLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterLoadStatementContext)
}

func (s *StatementContext) ShowAuthorStatement() IShowAuthorStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowAuthorStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowAuthorStatementContext)
}

func (s *StatementContext) ShowBackendsStatement() IShowBackendsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowBackendsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowBackendsStatementContext)
}

func (s *StatementContext) ShowBrokerStatement() IShowBrokerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowBrokerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowBrokerStatementContext)
}

func (s *StatementContext) ShowCharsetStatement() IShowCharsetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCharsetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCharsetStatementContext)
}

func (s *StatementContext) ShowCollationStatement() IShowCollationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCollationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCollationStatementContext)
}

func (s *StatementContext) ShowDeleteStatement() IShowDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDeleteStatementContext)
}

func (s *StatementContext) ShowDynamicPartitionStatement() IShowDynamicPartitionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDynamicPartitionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDynamicPartitionStatementContext)
}

func (s *StatementContext) ShowEventsStatement() IShowEventsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowEventsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowEventsStatementContext)
}

func (s *StatementContext) ShowEnginesStatement() IShowEnginesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowEnginesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowEnginesStatementContext)
}

func (s *StatementContext) ShowFrontendsStatement() IShowFrontendsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFrontendsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFrontendsStatementContext)
}

func (s *StatementContext) ShowPluginsStatement() IShowPluginsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowPluginsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowPluginsStatementContext)
}

func (s *StatementContext) ShowRepositoriesStatement() IShowRepositoriesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRepositoriesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRepositoriesStatementContext)
}

func (s *StatementContext) ShowOpenTableStatement() IShowOpenTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowOpenTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowOpenTableStatementContext)
}

func (s *StatementContext) ShowPrivilegesStatement() IShowPrivilegesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowPrivilegesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowPrivilegesStatementContext)
}

func (s *StatementContext) ShowProcedureStatement() IShowProcedureStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowProcedureStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowProcedureStatementContext)
}

func (s *StatementContext) ShowProcStatement() IShowProcStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowProcStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowProcStatementContext)
}

func (s *StatementContext) ShowProcesslistStatement() IShowProcesslistStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowProcesslistStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowProcesslistStatementContext)
}

func (s *StatementContext) ShowProfilelistStatement() IShowProfilelistStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowProfilelistStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowProfilelistStatementContext)
}

func (s *StatementContext) ShowRunningQueriesStatement() IShowRunningQueriesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRunningQueriesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRunningQueriesStatementContext)
}

func (s *StatementContext) ShowStatusStatement() IShowStatusStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStatusStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStatusStatementContext)
}

func (s *StatementContext) ShowTabletStatement() IShowTabletStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTabletStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTabletStatementContext)
}

func (s *StatementContext) ShowTransactionStatement() IShowTransactionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTransactionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTransactionStatementContext)
}

func (s *StatementContext) ShowTriggersStatement() IShowTriggersStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTriggersStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTriggersStatementContext)
}

func (s *StatementContext) ShowUserPropertyStatement() IShowUserPropertyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowUserPropertyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowUserPropertyStatementContext)
}

func (s *StatementContext) ShowVariablesStatement() IShowVariablesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowVariablesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowVariablesStatementContext)
}

func (s *StatementContext) ShowWarningStatement() IShowWarningStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowWarningStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowWarningStatementContext)
}

func (s *StatementContext) HelpStatement() IHelpStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelpStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelpStatementContext)
}

func (s *StatementContext) CreateUserStatement() ICreateUserStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserStatementContext)
}

func (s *StatementContext) DropUserStatement() IDropUserStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropUserStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropUserStatementContext)
}

func (s *StatementContext) AlterUserStatement() IAlterUserStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterUserStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterUserStatementContext)
}

func (s *StatementContext) ShowUserStatement() IShowUserStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowUserStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowUserStatementContext)
}

func (s *StatementContext) ShowAuthenticationStatement() IShowAuthenticationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowAuthenticationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowAuthenticationStatementContext)
}

func (s *StatementContext) ExecuteAsStatement() IExecuteAsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteAsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteAsStatementContext)
}

func (s *StatementContext) CreateRoleStatement() ICreateRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRoleStatementContext)
}

func (s *StatementContext) AlterRoleStatement() IAlterRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterRoleStatementContext)
}

func (s *StatementContext) DropRoleStatement() IDropRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropRoleStatementContext)
}

func (s *StatementContext) ShowRolesStatement() IShowRolesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRolesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRolesStatementContext)
}

func (s *StatementContext) GrantRoleStatement() IGrantRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRoleStatementContext)
}

func (s *StatementContext) RevokeRoleStatement() IRevokeRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokeRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokeRoleStatementContext)
}

func (s *StatementContext) SetRoleStatement() ISetRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetRoleStatementContext)
}

func (s *StatementContext) SetDefaultRoleStatement() ISetDefaultRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetDefaultRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetDefaultRoleStatementContext)
}

func (s *StatementContext) GrantPrivilegeStatement() IGrantPrivilegeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantPrivilegeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantPrivilegeStatementContext)
}

func (s *StatementContext) RevokePrivilegeStatement() IRevokePrivilegeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokePrivilegeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokePrivilegeStatementContext)
}

func (s *StatementContext) ShowGrantsStatement() IShowGrantsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowGrantsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowGrantsStatementContext)
}

func (s *StatementContext) CreateSecurityIntegrationStatement() ICreateSecurityIntegrationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateSecurityIntegrationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateSecurityIntegrationStatementContext)
}

func (s *StatementContext) AlterSecurityIntegrationStatement() IAlterSecurityIntegrationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterSecurityIntegrationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterSecurityIntegrationStatementContext)
}

func (s *StatementContext) DropSecurityIntegrationStatement() IDropSecurityIntegrationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropSecurityIntegrationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropSecurityIntegrationStatementContext)
}

func (s *StatementContext) ShowSecurityIntegrationStatement() IShowSecurityIntegrationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowSecurityIntegrationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowSecurityIntegrationStatementContext)
}

func (s *StatementContext) ShowCreateSecurityIntegrationStatement() IShowCreateSecurityIntegrationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCreateSecurityIntegrationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCreateSecurityIntegrationStatementContext)
}

func (s *StatementContext) CreateGroupProviderStatement() ICreateGroupProviderStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateGroupProviderStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateGroupProviderStatementContext)
}

func (s *StatementContext) DropGroupProviderStatement() IDropGroupProviderStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropGroupProviderStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropGroupProviderStatementContext)
}

func (s *StatementContext) ShowGroupProvidersStatement() IShowGroupProvidersStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowGroupProvidersStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowGroupProvidersStatementContext)
}

func (s *StatementContext) ShowCreateGroupProviderStatement() IShowCreateGroupProviderStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCreateGroupProviderStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCreateGroupProviderStatementContext)
}

func (s *StatementContext) BackupStatement() IBackupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackupStatementContext)
}

func (s *StatementContext) CancelBackupStatement() ICancelBackupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelBackupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelBackupStatementContext)
}

func (s *StatementContext) ShowBackupStatement() IShowBackupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowBackupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowBackupStatementContext)
}

func (s *StatementContext) RestoreStatement() IRestoreStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRestoreStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRestoreStatementContext)
}

func (s *StatementContext) CancelRestoreStatement() ICancelRestoreStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelRestoreStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelRestoreStatementContext)
}

func (s *StatementContext) ShowRestoreStatement() IShowRestoreStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRestoreStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRestoreStatementContext)
}

func (s *StatementContext) ShowSnapshotStatement() IShowSnapshotStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowSnapshotStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowSnapshotStatementContext)
}

func (s *StatementContext) CreateRepositoryStatement() ICreateRepositoryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRepositoryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRepositoryStatementContext)
}

func (s *StatementContext) DropRepositoryStatement() IDropRepositoryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropRepositoryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropRepositoryStatementContext)
}

func (s *StatementContext) AddSqlBlackListStatement() IAddSqlBlackListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddSqlBlackListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddSqlBlackListStatementContext)
}

func (s *StatementContext) DelSqlBlackListStatement() IDelSqlBlackListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelSqlBlackListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelSqlBlackListStatementContext)
}

func (s *StatementContext) ShowSqlBlackListStatement() IShowSqlBlackListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowSqlBlackListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowSqlBlackListStatementContext)
}

func (s *StatementContext) ShowWhiteListStatement() IShowWhiteListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowWhiteListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowWhiteListStatementContext)
}

func (s *StatementContext) AddBackendBlackListStatement() IAddBackendBlackListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddBackendBlackListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddBackendBlackListStatementContext)
}

func (s *StatementContext) DelBackendBlackListStatement() IDelBackendBlackListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelBackendBlackListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelBackendBlackListStatementContext)
}

func (s *StatementContext) ShowBackendBlackListStatement() IShowBackendBlackListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowBackendBlackListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowBackendBlackListStatementContext)
}

func (s *StatementContext) CreateDataCacheRuleStatement() ICreateDataCacheRuleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDataCacheRuleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDataCacheRuleStatementContext)
}

func (s *StatementContext) ShowDataCacheRulesStatement() IShowDataCacheRulesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDataCacheRulesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDataCacheRulesStatementContext)
}

func (s *StatementContext) DropDataCacheRuleStatement() IDropDataCacheRuleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropDataCacheRuleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropDataCacheRuleStatementContext)
}

func (s *StatementContext) ClearDataCacheRulesStatement() IClearDataCacheRulesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClearDataCacheRulesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClearDataCacheRulesStatementContext)
}

func (s *StatementContext) DataCacheSelectStatement() IDataCacheSelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataCacheSelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataCacheSelectStatementContext)
}

func (s *StatementContext) ExportStatement() IExportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportStatementContext)
}

func (s *StatementContext) CancelExportStatement() ICancelExportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelExportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelExportStatementContext)
}

func (s *StatementContext) ShowExportStatement() IShowExportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowExportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowExportStatementContext)
}

func (s *StatementContext) InstallPluginStatement() IInstallPluginStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstallPluginStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstallPluginStatementContext)
}

func (s *StatementContext) UninstallPluginStatement() IUninstallPluginStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUninstallPluginStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUninstallPluginStatementContext)
}

func (s *StatementContext) CreateFileStatement() ICreateFileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateFileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateFileStatementContext)
}

func (s *StatementContext) DropFileStatement() IDropFileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFileStatementContext)
}

func (s *StatementContext) ShowSmallFilesStatement() IShowSmallFilesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowSmallFilesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowSmallFilesStatementContext)
}

func (s *StatementContext) SetStatement() ISetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetStatementContext)
}

func (s *StatementContext) SetUserPropertyStatement() ISetUserPropertyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetUserPropertyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetUserPropertyStatementContext)
}

func (s *StatementContext) CreateStorageVolumeStatement() ICreateStorageVolumeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateStorageVolumeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateStorageVolumeStatementContext)
}

func (s *StatementContext) AlterStorageVolumeStatement() IAlterStorageVolumeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStorageVolumeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStorageVolumeStatementContext)
}

func (s *StatementContext) DropStorageVolumeStatement() IDropStorageVolumeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropStorageVolumeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropStorageVolumeStatementContext)
}

func (s *StatementContext) ShowStorageVolumesStatement() IShowStorageVolumesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStorageVolumesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStorageVolumesStatementContext)
}

func (s *StatementContext) DescStorageVolumeStatement() IDescStorageVolumeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescStorageVolumeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescStorageVolumeStatementContext)
}

func (s *StatementContext) SetDefaultStorageVolumeStatement() ISetDefaultStorageVolumeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetDefaultStorageVolumeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetDefaultStorageVolumeStatementContext)
}

func (s *StatementContext) CreatePipeStatement() ICreatePipeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreatePipeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreatePipeStatementContext)
}

func (s *StatementContext) DropPipeStatement() IDropPipeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropPipeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropPipeStatementContext)
}

func (s *StatementContext) AlterPipeStatement() IAlterPipeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterPipeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterPipeStatementContext)
}

func (s *StatementContext) ShowPipeStatement() IShowPipeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowPipeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowPipeStatementContext)
}

func (s *StatementContext) DescPipeStatement() IDescPipeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescPipeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescPipeStatementContext)
}

func (s *StatementContext) CancelCompactionStatement() ICancelCompactionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelCompactionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelCompactionStatementContext)
}

func (s *StatementContext) UpdateFailPointStatusStatement() IUpdateFailPointStatusStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateFailPointStatusStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateFailPointStatusStatementContext)
}

func (s *StatementContext) ShowFailPointStatement() IShowFailPointStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFailPointStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFailPointStatementContext)
}

func (s *StatementContext) PrepareStatement() IPrepareStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrepareStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrepareStatementContext)
}

func (s *StatementContext) ExecuteStatement() IExecuteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteStatementContext)
}

func (s *StatementContext) DeallocateStatement() IDeallocateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeallocateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeallocateStatementContext)
}

func (s *StatementContext) CreateDictionaryStatement() ICreateDictionaryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDictionaryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDictionaryStatementContext)
}

func (s *StatementContext) DropDictionaryStatement() IDropDictionaryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropDictionaryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropDictionaryStatementContext)
}

func (s *StatementContext) RefreshDictionaryStatement() IRefreshDictionaryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshDictionaryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshDictionaryStatementContext)
}

func (s *StatementContext) ShowDictionaryStatement() IShowDictionaryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDictionaryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDictionaryStatementContext)
}

func (s *StatementContext) CancelRefreshDictionaryStatement() ICancelRefreshDictionaryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelRefreshDictionaryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelRefreshDictionaryStatementContext)
}

func (s *StatementContext) AlterPlanAdvisorAddStatement() IAlterPlanAdvisorAddStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterPlanAdvisorAddStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterPlanAdvisorAddStatementContext)
}

func (s *StatementContext) TruncatePlanAdvisorStatement() ITruncatePlanAdvisorStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncatePlanAdvisorStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncatePlanAdvisorStatementContext)
}

func (s *StatementContext) AlterPlanAdvisorDropStatement() IAlterPlanAdvisorDropStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterPlanAdvisorDropStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterPlanAdvisorDropStatementContext)
}

func (s *StatementContext) ShowPlanAdvisorStatement() IShowPlanAdvisorStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowPlanAdvisorStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowPlanAdvisorStatementContext)
}

func (s *StatementContext) CreateWarehouseStatement() ICreateWarehouseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateWarehouseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateWarehouseStatementContext)
}

func (s *StatementContext) DropWarehouseStatement() IDropWarehouseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropWarehouseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropWarehouseStatementContext)
}

func (s *StatementContext) SuspendWarehouseStatement() ISuspendWarehouseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuspendWarehouseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuspendWarehouseStatementContext)
}

func (s *StatementContext) ResumeWarehouseStatement() IResumeWarehouseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResumeWarehouseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResumeWarehouseStatementContext)
}

func (s *StatementContext) SetWarehouseStatement() ISetWarehouseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetWarehouseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetWarehouseStatementContext)
}

func (s *StatementContext) ShowWarehousesStatement() IShowWarehousesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowWarehousesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowWarehousesStatementContext)
}

func (s *StatementContext) ShowClustersStatement() IShowClustersStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowClustersStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowClustersStatementContext)
}

func (s *StatementContext) ShowNodesStatement() IShowNodesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowNodesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowNodesStatementContext)
}

func (s *StatementContext) AlterWarehouseStatement() IAlterWarehouseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterWarehouseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterWarehouseStatementContext)
}

func (s *StatementContext) CreateCNGroupStatement() ICreateCNGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateCNGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateCNGroupStatementContext)
}

func (s *StatementContext) DropCNGroupStatement() IDropCNGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropCNGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropCNGroupStatementContext)
}

func (s *StatementContext) EnableCNGroupStatement() IEnableCNGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnableCNGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnableCNGroupStatementContext)
}

func (s *StatementContext) DisableCNGroupStatement() IDisableCNGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisableCNGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisableCNGroupStatementContext)
}

func (s *StatementContext) AlterCNGroupStatement() IAlterCNGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterCNGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterCNGroupStatementContext)
}

func (s *StatementContext) BeginStatement() IBeginStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBeginStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBeginStatementContext)
}

func (s *StatementContext) CommitStatement() ICommitStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommitStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommitStatementContext)
}

func (s *StatementContext) RollbackStatement() IRollbackStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollbackStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollbackStatementContext)
}

func (s *StatementContext) TranslateStatement() ITranslateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITranslateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITranslateStatementContext)
}

func (s *StatementContext) CreateBaselinePlanStatement() ICreateBaselinePlanStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateBaselinePlanStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateBaselinePlanStatementContext)
}

func (s *StatementContext) DropBaselinePlanStatement() IDropBaselinePlanStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropBaselinePlanStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropBaselinePlanStatementContext)
}

func (s *StatementContext) ShowBaselinePlanStatement() IShowBaselinePlanStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowBaselinePlanStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowBaselinePlanStatementContext)
}

func (s *StatementContext) UnsupportedStatement() IUnsupportedStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, DorisSQLParserRULE_statement)
	p.SetState(1297)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1057)
			p.QueryStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1058)
			p.UseDatabaseStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1059)
			p.UseCatalogStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1060)
			p.SetCatalogStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1061)
			p.ShowDatabasesStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1062)
			p.AlterDbQuotaStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1063)
			p.CreateDbStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1064)
			p.DropDbStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1065)
			p.ShowCreateDbStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1066)
			p.AlterDatabaseRenameStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1067)
			p.RecoverDbStmt()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1068)
			p.ShowDataStmt()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1069)
			p.ShowDataDistributionStmt()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1070)
			p.CreateTableStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1071)
			p.CreateTableAsSelectStatement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1072)
			p.CreateTableLikeStatement()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1073)
			p.ShowCreateTableStatement()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1074)
			p.DropTableStatement()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1075)
			p.CleanTemporaryTableStatement()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1076)
			p.RecoverTableStatement()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1077)
			p.TruncateTableStatement()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1078)
			p.ShowTableStatement()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1079)
			p.DescTableStatement()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1080)
			p.ShowTableStatusStatement()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1081)
			p.ShowColumnStatement()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1082)
			p.RefreshTableStatement()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1083)
			p.AlterTableStatement()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1084)
			p.CancelAlterTableStatement()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1085)
			p.ShowAlterStatement()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1086)
			p.ShowTemporaryTablesStatement()
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(1087)
			p.CreateViewStatement()
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(1088)
			p.AlterViewStatement()
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(1089)
			p.DropViewStatement()
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(1090)
			p.ShowPartitionsStatement()
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(1091)
			p.RecoverPartitionStatement()
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(1092)
			p.CreateIndexStatement()
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(1093)
			p.DropIndexStatement()
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(1094)
			p.ShowIndexStatement()
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(1095)
			p.SubmitTaskStatement()
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(1096)
			p.DropTaskStatement()
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(1097)
			p.CreateMaterializedViewStatement()
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(1098)
			p.ShowMaterializedViewsStatement()
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(1099)
			p.DropMaterializedViewStatement()
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(1100)
			p.AlterMaterializedViewStatement()
		}

	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(1101)
			p.RefreshMaterializedViewStatement()
		}

	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(1102)
			p.CancelRefreshMaterializedViewStatement()
		}

	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(1103)
			p.CreateExternalCatalogStatement()
		}

	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(1104)
			p.DropExternalCatalogStatement()
		}

	case 49:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(1105)
			p.ShowCatalogsStatement()
		}

	case 50:
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(1106)
			p.ShowCreateExternalCatalogStatement()
		}

	case 51:
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(1107)
			p.AlterCatalogStatement()
		}

	case 52:
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(1108)
			p.InsertStatement()
		}

	case 53:
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(1109)
			p.UpdateStatement()
		}

	case 54:
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(1110)
			p.DeleteStatement()
		}

	case 55:
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(1111)
			p.CreateRoutineLoadStatement()
		}

	case 56:
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(1112)
			p.AlterRoutineLoadStatement()
		}

	case 57:
		p.EnterOuterAlt(localctx, 57)
		{
			p.SetState(1113)
			p.StopRoutineLoadStatement()
		}

	case 58:
		p.EnterOuterAlt(localctx, 58)
		{
			p.SetState(1114)
			p.ResumeRoutineLoadStatement()
		}

	case 59:
		p.EnterOuterAlt(localctx, 59)
		{
			p.SetState(1115)
			p.PauseRoutineLoadStatement()
		}

	case 60:
		p.EnterOuterAlt(localctx, 60)
		{
			p.SetState(1116)
			p.ShowRoutineLoadStatement()
		}

	case 61:
		p.EnterOuterAlt(localctx, 61)
		{
			p.SetState(1117)
			p.ShowRoutineLoadTaskStatement()
		}

	case 62:
		p.EnterOuterAlt(localctx, 62)
		{
			p.SetState(1118)
			p.ShowCreateRoutineLoadStatement()
		}

	case 63:
		p.EnterOuterAlt(localctx, 63)
		{
			p.SetState(1119)
			p.ShowStreamLoadStatement()
		}

	case 64:
		p.EnterOuterAlt(localctx, 64)
		{
			p.SetState(1120)
			p.AdminSetConfigStatement()
		}

	case 65:
		p.EnterOuterAlt(localctx, 65)
		{
			p.SetState(1121)
			p.AdminSetReplicaStatusStatement()
		}

	case 66:
		p.EnterOuterAlt(localctx, 66)
		{
			p.SetState(1122)
			p.AdminShowConfigStatement()
		}

	case 67:
		p.EnterOuterAlt(localctx, 67)
		{
			p.SetState(1123)
			p.AdminShowReplicaDistributionStatement()
		}

	case 68:
		p.EnterOuterAlt(localctx, 68)
		{
			p.SetState(1124)
			p.AdminShowReplicaStatusStatement()
		}

	case 69:
		p.EnterOuterAlt(localctx, 69)
		{
			p.SetState(1125)
			p.AdminRepairTableStatement()
		}

	case 70:
		p.EnterOuterAlt(localctx, 70)
		{
			p.SetState(1126)
			p.AdminCancelRepairTableStatement()
		}

	case 71:
		p.EnterOuterAlt(localctx, 71)
		{
			p.SetState(1127)
			p.AdminCheckTabletsStatement()
		}

	case 72:
		p.EnterOuterAlt(localctx, 72)
		{
			p.SetState(1128)
			p.AdminSetPartitionVersion()
		}

	case 73:
		p.EnterOuterAlt(localctx, 73)
		{
			p.SetState(1129)
			p.KillStatement()
		}

	case 74:
		p.EnterOuterAlt(localctx, 74)
		{
			p.SetState(1130)
			p.SyncStatement()
		}

	case 75:
		p.EnterOuterAlt(localctx, 75)
		{
			p.SetState(1131)
			p.ExecuteScriptStatement()
		}

	case 76:
		p.EnterOuterAlt(localctx, 76)
		{
			p.SetState(1132)
			p.AdminSetAutomatedSnapshotOnStatement()
		}

	case 77:
		p.EnterOuterAlt(localctx, 77)
		{
			p.SetState(1133)
			p.AdminSetAutomatedSnapshotOffStatement()
		}

	case 78:
		p.EnterOuterAlt(localctx, 78)
		{
			p.SetState(1134)
			p.AlterSystemStatement()
		}

	case 79:
		p.EnterOuterAlt(localctx, 79)
		{
			p.SetState(1135)
			p.CancelAlterSystemStatement()
		}

	case 80:
		p.EnterOuterAlt(localctx, 80)
		{
			p.SetState(1136)
			p.ShowComputeNodesStatement()
		}

	case 81:
		p.EnterOuterAlt(localctx, 81)
		{
			p.SetState(1137)
			p.AnalyzeStatement()
		}

	case 82:
		p.EnterOuterAlt(localctx, 82)
		{
			p.SetState(1138)
			p.DropStatsStatement()
		}

	case 83:
		p.EnterOuterAlt(localctx, 83)
		{
			p.SetState(1139)
			p.CreateAnalyzeStatement()
		}

	case 84:
		p.EnterOuterAlt(localctx, 84)
		{
			p.SetState(1140)
			p.DropAnalyzeJobStatement()
		}

	case 85:
		p.EnterOuterAlt(localctx, 85)
		{
			p.SetState(1141)
			p.AnalyzeHistogramStatement()
		}

	case 86:
		p.EnterOuterAlt(localctx, 86)
		{
			p.SetState(1142)
			p.DropHistogramStatement()
		}

	case 87:
		p.EnterOuterAlt(localctx, 87)
		{
			p.SetState(1143)
			p.ShowAnalyzeStatement()
		}

	case 88:
		p.EnterOuterAlt(localctx, 88)
		{
			p.SetState(1144)
			p.ShowStatsMetaStatement()
		}

	case 89:
		p.EnterOuterAlt(localctx, 89)
		{
			p.SetState(1145)
			p.ShowHistogramMetaStatement()
		}

	case 90:
		p.EnterOuterAlt(localctx, 90)
		{
			p.SetState(1146)
			p.KillAnalyzeStatement()
		}

	case 91:
		p.EnterOuterAlt(localctx, 91)
		{
			p.SetState(1147)
			p.AnalyzeProfileStatement()
		}

	case 92:
		p.EnterOuterAlt(localctx, 92)
		{
			p.SetState(1148)
			p.CreateResourceGroupStatement()
		}

	case 93:
		p.EnterOuterAlt(localctx, 93)
		{
			p.SetState(1149)
			p.DropResourceGroupStatement()
		}

	case 94:
		p.EnterOuterAlt(localctx, 94)
		{
			p.SetState(1150)
			p.AlterResourceGroupStatement()
		}

	case 95:
		p.EnterOuterAlt(localctx, 95)
		{
			p.SetState(1151)
			p.ShowResourceGroupStatement()
		}

	case 96:
		p.EnterOuterAlt(localctx, 96)
		{
			p.SetState(1152)
			p.ShowResourceGroupUsageStatement()
		}

	case 97:
		p.EnterOuterAlt(localctx, 97)
		{
			p.SetState(1153)
			p.CreateResourceStatement()
		}

	case 98:
		p.EnterOuterAlt(localctx, 98)
		{
			p.SetState(1154)
			p.AlterResourceStatement()
		}

	case 99:
		p.EnterOuterAlt(localctx, 99)
		{
			p.SetState(1155)
			p.DropResourceStatement()
		}

	case 100:
		p.EnterOuterAlt(localctx, 100)
		{
			p.SetState(1156)
			p.ShowResourceStatement()
		}

	case 101:
		p.EnterOuterAlt(localctx, 101)
		{
			p.SetState(1157)
			p.ShowFunctionsStatement()
		}

	case 102:
		p.EnterOuterAlt(localctx, 102)
		{
			p.SetState(1158)
			p.DropFunctionStatement()
		}

	case 103:
		p.EnterOuterAlt(localctx, 103)
		{
			p.SetState(1159)
			p.CreateFunctionStatement()
		}

	case 104:
		p.EnterOuterAlt(localctx, 104)
		{
			p.SetState(1160)
			p.LoadStatement()
		}

	case 105:
		p.EnterOuterAlt(localctx, 105)
		{
			p.SetState(1161)
			p.ShowLoadStatement()
		}

	case 106:
		p.EnterOuterAlt(localctx, 106)
		{
			p.SetState(1162)
			p.ShowLoadWarningsStatement()
		}

	case 107:
		p.EnterOuterAlt(localctx, 107)
		{
			p.SetState(1163)
			p.CancelLoadStatement()
		}

	case 108:
		p.EnterOuterAlt(localctx, 108)
		{
			p.SetState(1164)
			p.AlterLoadStatement()
		}

	case 109:
		p.EnterOuterAlt(localctx, 109)
		{
			p.SetState(1165)
			p.ShowAuthorStatement()
		}

	case 110:
		p.EnterOuterAlt(localctx, 110)
		{
			p.SetState(1166)
			p.ShowBackendsStatement()
		}

	case 111:
		p.EnterOuterAlt(localctx, 111)
		{
			p.SetState(1167)
			p.ShowBrokerStatement()
		}

	case 112:
		p.EnterOuterAlt(localctx, 112)
		{
			p.SetState(1168)
			p.ShowCharsetStatement()
		}

	case 113:
		p.EnterOuterAlt(localctx, 113)
		{
			p.SetState(1169)
			p.ShowCollationStatement()
		}

	case 114:
		p.EnterOuterAlt(localctx, 114)
		{
			p.SetState(1170)
			p.ShowDeleteStatement()
		}

	case 115:
		p.EnterOuterAlt(localctx, 115)
		{
			p.SetState(1171)
			p.ShowDynamicPartitionStatement()
		}

	case 116:
		p.EnterOuterAlt(localctx, 116)
		{
			p.SetState(1172)
			p.ShowEventsStatement()
		}

	case 117:
		p.EnterOuterAlt(localctx, 117)
		{
			p.SetState(1173)
			p.ShowEnginesStatement()
		}

	case 118:
		p.EnterOuterAlt(localctx, 118)
		{
			p.SetState(1174)
			p.ShowFrontendsStatement()
		}

	case 119:
		p.EnterOuterAlt(localctx, 119)
		{
			p.SetState(1175)
			p.ShowPluginsStatement()
		}

	case 120:
		p.EnterOuterAlt(localctx, 120)
		{
			p.SetState(1176)
			p.ShowRepositoriesStatement()
		}

	case 121:
		p.EnterOuterAlt(localctx, 121)
		{
			p.SetState(1177)
			p.ShowOpenTableStatement()
		}

	case 122:
		p.EnterOuterAlt(localctx, 122)
		{
			p.SetState(1178)
			p.ShowPrivilegesStatement()
		}

	case 123:
		p.EnterOuterAlt(localctx, 123)
		{
			p.SetState(1179)
			p.ShowProcedureStatement()
		}

	case 124:
		p.EnterOuterAlt(localctx, 124)
		{
			p.SetState(1180)
			p.ShowProcStatement()
		}

	case 125:
		p.EnterOuterAlt(localctx, 125)
		{
			p.SetState(1181)
			p.ShowProcesslistStatement()
		}

	case 126:
		p.EnterOuterAlt(localctx, 126)
		{
			p.SetState(1182)
			p.ShowProfilelistStatement()
		}

	case 127:
		p.EnterOuterAlt(localctx, 127)
		{
			p.SetState(1183)
			p.ShowRunningQueriesStatement()
		}

	case 128:
		p.EnterOuterAlt(localctx, 128)
		{
			p.SetState(1184)
			p.ShowStatusStatement()
		}

	case 129:
		p.EnterOuterAlt(localctx, 129)
		{
			p.SetState(1185)
			p.ShowTabletStatement()
		}

	case 130:
		p.EnterOuterAlt(localctx, 130)
		{
			p.SetState(1186)
			p.ShowTransactionStatement()
		}

	case 131:
		p.EnterOuterAlt(localctx, 131)
		{
			p.SetState(1187)
			p.ShowTriggersStatement()
		}

	case 132:
		p.EnterOuterAlt(localctx, 132)
		{
			p.SetState(1188)
			p.ShowUserPropertyStatement()
		}

	case 133:
		p.EnterOuterAlt(localctx, 133)
		{
			p.SetState(1189)
			p.ShowVariablesStatement()
		}

	case 134:
		p.EnterOuterAlt(localctx, 134)
		{
			p.SetState(1190)
			p.ShowWarningStatement()
		}

	case 135:
		p.EnterOuterAlt(localctx, 135)
		{
			p.SetState(1191)
			p.HelpStatement()
		}

	case 136:
		p.EnterOuterAlt(localctx, 136)
		{
			p.SetState(1192)
			p.CreateUserStatement()
		}

	case 137:
		p.EnterOuterAlt(localctx, 137)
		{
			p.SetState(1193)
			p.DropUserStatement()
		}

	case 138:
		p.EnterOuterAlt(localctx, 138)
		{
			p.SetState(1194)
			p.AlterUserStatement()
		}

	case 139:
		p.EnterOuterAlt(localctx, 139)
		{
			p.SetState(1195)
			p.ShowUserStatement()
		}

	case 140:
		p.EnterOuterAlt(localctx, 140)
		{
			p.SetState(1196)
			p.ShowAuthenticationStatement()
		}

	case 141:
		p.EnterOuterAlt(localctx, 141)
		{
			p.SetState(1197)
			p.ExecuteAsStatement()
		}

	case 142:
		p.EnterOuterAlt(localctx, 142)
		{
			p.SetState(1198)
			p.CreateRoleStatement()
		}

	case 143:
		p.EnterOuterAlt(localctx, 143)
		{
			p.SetState(1199)
			p.AlterRoleStatement()
		}

	case 144:
		p.EnterOuterAlt(localctx, 144)
		{
			p.SetState(1200)
			p.DropRoleStatement()
		}

	case 145:
		p.EnterOuterAlt(localctx, 145)
		{
			p.SetState(1201)
			p.ShowRolesStatement()
		}

	case 146:
		p.EnterOuterAlt(localctx, 146)
		{
			p.SetState(1202)
			p.GrantRoleStatement()
		}

	case 147:
		p.EnterOuterAlt(localctx, 147)
		{
			p.SetState(1203)
			p.RevokeRoleStatement()
		}

	case 148:
		p.EnterOuterAlt(localctx, 148)
		{
			p.SetState(1204)
			p.SetRoleStatement()
		}

	case 149:
		p.EnterOuterAlt(localctx, 149)
		{
			p.SetState(1205)
			p.SetDefaultRoleStatement()
		}

	case 150:
		p.EnterOuterAlt(localctx, 150)
		{
			p.SetState(1206)
			p.GrantPrivilegeStatement()
		}

	case 151:
		p.EnterOuterAlt(localctx, 151)
		{
			p.SetState(1207)
			p.RevokePrivilegeStatement()
		}

	case 152:
		p.EnterOuterAlt(localctx, 152)
		{
			p.SetState(1208)
			p.ShowGrantsStatement()
		}

	case 153:
		p.EnterOuterAlt(localctx, 153)
		{
			p.SetState(1209)
			p.CreateSecurityIntegrationStatement()
		}

	case 154:
		p.EnterOuterAlt(localctx, 154)
		{
			p.SetState(1210)
			p.AlterSecurityIntegrationStatement()
		}

	case 155:
		p.EnterOuterAlt(localctx, 155)
		{
			p.SetState(1211)
			p.DropSecurityIntegrationStatement()
		}

	case 156:
		p.EnterOuterAlt(localctx, 156)
		{
			p.SetState(1212)
			p.ShowSecurityIntegrationStatement()
		}

	case 157:
		p.EnterOuterAlt(localctx, 157)
		{
			p.SetState(1213)
			p.ShowCreateSecurityIntegrationStatement()
		}

	case 158:
		p.EnterOuterAlt(localctx, 158)
		{
			p.SetState(1214)
			p.CreateGroupProviderStatement()
		}

	case 159:
		p.EnterOuterAlt(localctx, 159)
		{
			p.SetState(1215)
			p.DropGroupProviderStatement()
		}

	case 160:
		p.EnterOuterAlt(localctx, 160)
		{
			p.SetState(1216)
			p.ShowGroupProvidersStatement()
		}

	case 161:
		p.EnterOuterAlt(localctx, 161)
		{
			p.SetState(1217)
			p.ShowCreateGroupProviderStatement()
		}

	case 162:
		p.EnterOuterAlt(localctx, 162)
		{
			p.SetState(1218)
			p.BackupStatement()
		}

	case 163:
		p.EnterOuterAlt(localctx, 163)
		{
			p.SetState(1219)
			p.CancelBackupStatement()
		}

	case 164:
		p.EnterOuterAlt(localctx, 164)
		{
			p.SetState(1220)
			p.ShowBackupStatement()
		}

	case 165:
		p.EnterOuterAlt(localctx, 165)
		{
			p.SetState(1221)
			p.RestoreStatement()
		}

	case 166:
		p.EnterOuterAlt(localctx, 166)
		{
			p.SetState(1222)
			p.CancelRestoreStatement()
		}

	case 167:
		p.EnterOuterAlt(localctx, 167)
		{
			p.SetState(1223)
			p.ShowRestoreStatement()
		}

	case 168:
		p.EnterOuterAlt(localctx, 168)
		{
			p.SetState(1224)
			p.ShowSnapshotStatement()
		}

	case 169:
		p.EnterOuterAlt(localctx, 169)
		{
			p.SetState(1225)
			p.CreateRepositoryStatement()
		}

	case 170:
		p.EnterOuterAlt(localctx, 170)
		{
			p.SetState(1226)
			p.DropRepositoryStatement()
		}

	case 171:
		p.EnterOuterAlt(localctx, 171)
		{
			p.SetState(1227)
			p.AddSqlBlackListStatement()
		}

	case 172:
		p.EnterOuterAlt(localctx, 172)
		{
			p.SetState(1228)
			p.DelSqlBlackListStatement()
		}

	case 173:
		p.EnterOuterAlt(localctx, 173)
		{
			p.SetState(1229)
			p.ShowSqlBlackListStatement()
		}

	case 174:
		p.EnterOuterAlt(localctx, 174)
		{
			p.SetState(1230)
			p.ShowWhiteListStatement()
		}

	case 175:
		p.EnterOuterAlt(localctx, 175)
		{
			p.SetState(1231)
			p.AddBackendBlackListStatement()
		}

	case 176:
		p.EnterOuterAlt(localctx, 176)
		{
			p.SetState(1232)
			p.DelBackendBlackListStatement()
		}

	case 177:
		p.EnterOuterAlt(localctx, 177)
		{
			p.SetState(1233)
			p.ShowBackendBlackListStatement()
		}

	case 178:
		p.EnterOuterAlt(localctx, 178)
		{
			p.SetState(1234)
			p.CreateDataCacheRuleStatement()
		}

	case 179:
		p.EnterOuterAlt(localctx, 179)
		{
			p.SetState(1235)
			p.ShowDataCacheRulesStatement()
		}

	case 180:
		p.EnterOuterAlt(localctx, 180)
		{
			p.SetState(1236)
			p.DropDataCacheRuleStatement()
		}

	case 181:
		p.EnterOuterAlt(localctx, 181)
		{
			p.SetState(1237)
			p.ClearDataCacheRulesStatement()
		}

	case 182:
		p.EnterOuterAlt(localctx, 182)
		{
			p.SetState(1238)
			p.DataCacheSelectStatement()
		}

	case 183:
		p.EnterOuterAlt(localctx, 183)
		{
			p.SetState(1239)
			p.ExportStatement()
		}

	case 184:
		p.EnterOuterAlt(localctx, 184)
		{
			p.SetState(1240)
			p.CancelExportStatement()
		}

	case 185:
		p.EnterOuterAlt(localctx, 185)
		{
			p.SetState(1241)
			p.ShowExportStatement()
		}

	case 186:
		p.EnterOuterAlt(localctx, 186)
		{
			p.SetState(1242)
			p.InstallPluginStatement()
		}

	case 187:
		p.EnterOuterAlt(localctx, 187)
		{
			p.SetState(1243)
			p.UninstallPluginStatement()
		}

	case 188:
		p.EnterOuterAlt(localctx, 188)
		{
			p.SetState(1244)
			p.CreateFileStatement()
		}

	case 189:
		p.EnterOuterAlt(localctx, 189)
		{
			p.SetState(1245)
			p.DropFileStatement()
		}

	case 190:
		p.EnterOuterAlt(localctx, 190)
		{
			p.SetState(1246)
			p.ShowSmallFilesStatement()
		}

	case 191:
		p.EnterOuterAlt(localctx, 191)
		{
			p.SetState(1247)
			p.SetStatement()
		}

	case 192:
		p.EnterOuterAlt(localctx, 192)
		{
			p.SetState(1248)
			p.SetUserPropertyStatement()
		}

	case 193:
		p.EnterOuterAlt(localctx, 193)
		{
			p.SetState(1249)
			p.CreateStorageVolumeStatement()
		}

	case 194:
		p.EnterOuterAlt(localctx, 194)
		{
			p.SetState(1250)
			p.AlterStorageVolumeStatement()
		}

	case 195:
		p.EnterOuterAlt(localctx, 195)
		{
			p.SetState(1251)
			p.DropStorageVolumeStatement()
		}

	case 196:
		p.EnterOuterAlt(localctx, 196)
		{
			p.SetState(1252)
			p.ShowStorageVolumesStatement()
		}

	case 197:
		p.EnterOuterAlt(localctx, 197)
		{
			p.SetState(1253)
			p.DescStorageVolumeStatement()
		}

	case 198:
		p.EnterOuterAlt(localctx, 198)
		{
			p.SetState(1254)
			p.SetDefaultStorageVolumeStatement()
		}

	case 199:
		p.EnterOuterAlt(localctx, 199)
		{
			p.SetState(1255)
			p.CreatePipeStatement()
		}

	case 200:
		p.EnterOuterAlt(localctx, 200)
		{
			p.SetState(1256)
			p.DropPipeStatement()
		}

	case 201:
		p.EnterOuterAlt(localctx, 201)
		{
			p.SetState(1257)
			p.AlterPipeStatement()
		}

	case 202:
		p.EnterOuterAlt(localctx, 202)
		{
			p.SetState(1258)
			p.ShowPipeStatement()
		}

	case 203:
		p.EnterOuterAlt(localctx, 203)
		{
			p.SetState(1259)
			p.DescPipeStatement()
		}

	case 204:
		p.EnterOuterAlt(localctx, 204)
		{
			p.SetState(1260)
			p.CancelCompactionStatement()
		}

	case 205:
		p.EnterOuterAlt(localctx, 205)
		{
			p.SetState(1261)
			p.UpdateFailPointStatusStatement()
		}

	case 206:
		p.EnterOuterAlt(localctx, 206)
		{
			p.SetState(1262)
			p.ShowFailPointStatement()
		}

	case 207:
		p.EnterOuterAlt(localctx, 207)
		{
			p.SetState(1263)
			p.PrepareStatement()
		}

	case 208:
		p.EnterOuterAlt(localctx, 208)
		{
			p.SetState(1264)
			p.ExecuteStatement()
		}

	case 209:
		p.EnterOuterAlt(localctx, 209)
		{
			p.SetState(1265)
			p.DeallocateStatement()
		}

	case 210:
		p.EnterOuterAlt(localctx, 210)
		{
			p.SetState(1266)
			p.CreateDictionaryStatement()
		}

	case 211:
		p.EnterOuterAlt(localctx, 211)
		{
			p.SetState(1267)
			p.DropDictionaryStatement()
		}

	case 212:
		p.EnterOuterAlt(localctx, 212)
		{
			p.SetState(1268)
			p.RefreshDictionaryStatement()
		}

	case 213:
		p.EnterOuterAlt(localctx, 213)
		{
			p.SetState(1269)
			p.ShowDictionaryStatement()
		}

	case 214:
		p.EnterOuterAlt(localctx, 214)
		{
			p.SetState(1270)
			p.CancelRefreshDictionaryStatement()
		}

	case 215:
		p.EnterOuterAlt(localctx, 215)
		{
			p.SetState(1271)
			p.AlterPlanAdvisorAddStatement()
		}

	case 216:
		p.EnterOuterAlt(localctx, 216)
		{
			p.SetState(1272)
			p.TruncatePlanAdvisorStatement()
		}

	case 217:
		p.EnterOuterAlt(localctx, 217)
		{
			p.SetState(1273)
			p.AlterPlanAdvisorDropStatement()
		}

	case 218:
		p.EnterOuterAlt(localctx, 218)
		{
			p.SetState(1274)
			p.ShowPlanAdvisorStatement()
		}

	case 219:
		p.EnterOuterAlt(localctx, 219)
		{
			p.SetState(1275)
			p.CreateWarehouseStatement()
		}

	case 220:
		p.EnterOuterAlt(localctx, 220)
		{
			p.SetState(1276)
			p.DropWarehouseStatement()
		}

	case 221:
		p.EnterOuterAlt(localctx, 221)
		{
			p.SetState(1277)
			p.SuspendWarehouseStatement()
		}

	case 222:
		p.EnterOuterAlt(localctx, 222)
		{
			p.SetState(1278)
			p.ResumeWarehouseStatement()
		}

	case 223:
		p.EnterOuterAlt(localctx, 223)
		{
			p.SetState(1279)
			p.SetWarehouseStatement()
		}

	case 224:
		p.EnterOuterAlt(localctx, 224)
		{
			p.SetState(1280)
			p.ShowWarehousesStatement()
		}

	case 225:
		p.EnterOuterAlt(localctx, 225)
		{
			p.SetState(1281)
			p.ShowClustersStatement()
		}

	case 226:
		p.EnterOuterAlt(localctx, 226)
		{
			p.SetState(1282)
			p.ShowNodesStatement()
		}

	case 227:
		p.EnterOuterAlt(localctx, 227)
		{
			p.SetState(1283)
			p.AlterWarehouseStatement()
		}

	case 228:
		p.EnterOuterAlt(localctx, 228)
		{
			p.SetState(1284)
			p.CreateCNGroupStatement()
		}

	case 229:
		p.EnterOuterAlt(localctx, 229)
		{
			p.SetState(1285)
			p.DropCNGroupStatement()
		}

	case 230:
		p.EnterOuterAlt(localctx, 230)
		{
			p.SetState(1286)
			p.EnableCNGroupStatement()
		}

	case 231:
		p.EnterOuterAlt(localctx, 231)
		{
			p.SetState(1287)
			p.DisableCNGroupStatement()
		}

	case 232:
		p.EnterOuterAlt(localctx, 232)
		{
			p.SetState(1288)
			p.AlterCNGroupStatement()
		}

	case 233:
		p.EnterOuterAlt(localctx, 233)
		{
			p.SetState(1289)
			p.BeginStatement()
		}

	case 234:
		p.EnterOuterAlt(localctx, 234)
		{
			p.SetState(1290)
			p.CommitStatement()
		}

	case 235:
		p.EnterOuterAlt(localctx, 235)
		{
			p.SetState(1291)
			p.RollbackStatement()
		}

	case 236:
		p.EnterOuterAlt(localctx, 236)
		{
			p.SetState(1292)
			p.TranslateStatement()
		}

	case 237:
		p.EnterOuterAlt(localctx, 237)
		{
			p.SetState(1293)
			p.CreateBaselinePlanStatement()
		}

	case 238:
		p.EnterOuterAlt(localctx, 238)
		{
			p.SetState(1294)
			p.DropBaselinePlanStatement()
		}

	case 239:
		p.EnterOuterAlt(localctx, 239)
		{
			p.SetState(1295)
			p.ShowBaselinePlanStatement()
		}

	case 240:
		p.EnterOuterAlt(localctx, 240)
		{
			p.SetState(1296)
			p.UnsupportedStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUseDatabaseStatementContext is an interface to support dynamic dispatch.
type IUseDatabaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsUseDatabaseStatementContext differentiates from other interfaces.
	IsUseDatabaseStatementContext()
}

type UseDatabaseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseDatabaseStatementContext() *UseDatabaseStatementContext {
	var p = new(UseDatabaseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_useDatabaseStatement
	return p
}

func InitEmptyUseDatabaseStatementContext(p *UseDatabaseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_useDatabaseStatement
}

func (*UseDatabaseStatementContext) IsUseDatabaseStatementContext() {}

func NewUseDatabaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseDatabaseStatementContext {
	var p = new(UseDatabaseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_useDatabaseStatement

	return p
}

func (s *UseDatabaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UseDatabaseStatementContext) USE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSE, 0)
}

func (s *UseDatabaseStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *UseDatabaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseDatabaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseDatabaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterUseDatabaseStatement(s)
	}
}

func (s *UseDatabaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitUseDatabaseStatement(s)
	}
}

func (s *UseDatabaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitUseDatabaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) UseDatabaseStatement() (localctx IUseDatabaseStatementContext) {
	localctx = NewUseDatabaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, DorisSQLParserRULE_useDatabaseStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1299)
		p.Match(DorisSQLParserUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1300)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUseCatalogStatementContext is an interface to support dynamic dispatch.
type IUseCatalogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USE() antlr.TerminalNode
	String_() IStringContext

	// IsUseCatalogStatementContext differentiates from other interfaces.
	IsUseCatalogStatementContext()
}

type UseCatalogStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseCatalogStatementContext() *UseCatalogStatementContext {
	var p = new(UseCatalogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_useCatalogStatement
	return p
}

func InitEmptyUseCatalogStatementContext(p *UseCatalogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_useCatalogStatement
}

func (*UseCatalogStatementContext) IsUseCatalogStatementContext() {}

func NewUseCatalogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseCatalogStatementContext {
	var p = new(UseCatalogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_useCatalogStatement

	return p
}

func (s *UseCatalogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UseCatalogStatementContext) USE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSE, 0)
}

func (s *UseCatalogStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *UseCatalogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseCatalogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseCatalogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterUseCatalogStatement(s)
	}
}

func (s *UseCatalogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitUseCatalogStatement(s)
	}
}

func (s *UseCatalogStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitUseCatalogStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) UseCatalogStatement() (localctx IUseCatalogStatementContext) {
	localctx = NewUseCatalogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, DorisSQLParserRULE_useCatalogStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1302)
		p.Match(DorisSQLParserUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1303)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetCatalogStatementContext is an interface to support dynamic dispatch.
type ISetCatalogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsSetCatalogStatementContext differentiates from other interfaces.
	IsSetCatalogStatementContext()
}

type SetCatalogStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetCatalogStatementContext() *SetCatalogStatementContext {
	var p = new(SetCatalogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_setCatalogStatement
	return p
}

func InitEmptySetCatalogStatementContext(p *SetCatalogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_setCatalogStatement
}

func (*SetCatalogStatementContext) IsSetCatalogStatementContext() {}

func NewSetCatalogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetCatalogStatementContext {
	var p = new(SetCatalogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_setCatalogStatement

	return p
}

func (s *SetCatalogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetCatalogStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *SetCatalogStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCATALOG, 0)
}

func (s *SetCatalogStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *SetCatalogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetCatalogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetCatalogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSetCatalogStatement(s)
	}
}

func (s *SetCatalogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSetCatalogStatement(s)
	}
}

func (s *SetCatalogStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSetCatalogStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SetCatalogStatement() (localctx ISetCatalogStatementContext) {
	localctx = NewSetCatalogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, DorisSQLParserRULE_setCatalogStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1305)
		p.Match(DorisSQLParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1306)
		p.Match(DorisSQLParserCATALOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1307)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDatabasesStatementContext is an interface to support dynamic dispatch.
type IShowDatabasesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	DATABASES() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext
	SCHEMAS() antlr.TerminalNode

	// IsShowDatabasesStatementContext differentiates from other interfaces.
	IsShowDatabasesStatementContext()
}

type ShowDatabasesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowDatabasesStatementContext() *ShowDatabasesStatementContext {
	var p = new(ShowDatabasesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showDatabasesStatement
	return p
}

func InitEmptyShowDatabasesStatementContext(p *ShowDatabasesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showDatabasesStatement
}

func (*ShowDatabasesStatementContext) IsShowDatabasesStatementContext() {}

func NewShowDatabasesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDatabasesStatementContext {
	var p = new(ShowDatabasesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showDatabasesStatement

	return p
}

func (s *ShowDatabasesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDatabasesStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *ShowDatabasesStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowDatabasesStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *ShowDatabasesStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowDatabasesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowDatabasesStatementContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATABASES, 0)
}

func (s *ShowDatabasesStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowDatabasesStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *ShowDatabasesStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowDatabasesStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *ShowDatabasesStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowDatabasesStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowDatabasesStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowDatabasesStatementContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSCHEMAS, 0)
}

func (s *ShowDatabasesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDatabasesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDatabasesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowDatabasesStatement(s)
	}
}

func (s *ShowDatabasesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowDatabasesStatement(s)
	}
}

func (s *ShowDatabasesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowDatabasesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowDatabasesStatement() (localctx IShowDatabasesStatementContext) {
	localctx = NewShowDatabasesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, DorisSQLParserRULE_showDatabasesStatement)
	var _la int

	p.SetState(1329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1309)
			p.Match(DorisSQLParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1310)
			p.Match(DorisSQLParserDATABASES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1313)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserFROM || _la == DorisSQLParserIN {
			{
				p.SetState(1311)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1312)

				var _x = p.QualifiedName()

				localctx.(*ShowDatabasesStatementContext).catalog = _x
			}

		}
		p.SetState(1319)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserLIKE:
			{
				p.SetState(1315)
				p.Match(DorisSQLParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1316)

				var _x = p.String_()

				localctx.(*ShowDatabasesStatementContext).pattern = _x
			}

		case DorisSQLParserWHERE:
			{
				p.SetState(1317)
				p.Match(DorisSQLParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1318)
				p.expression(0)
			}

		case DorisSQLParserEOF, DorisSQLParserSEMICOLON:

		default:
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1321)
			p.Match(DorisSQLParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1322)
			p.Match(DorisSQLParserSCHEMAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1327)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserLIKE:
			{
				p.SetState(1323)
				p.Match(DorisSQLParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1324)

				var _x = p.String_()

				localctx.(*ShowDatabasesStatementContext).pattern = _x
			}

		case DorisSQLParserWHERE:
			{
				p.SetState(1325)
				p.Match(DorisSQLParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1326)
				p.expression(0)
			}

		case DorisSQLParserEOF, DorisSQLParserSEMICOLON:

		default:
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterDbQuotaStatementContext is an interface to support dynamic dispatch.
type IAlterDbQuotaStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	SET() antlr.TerminalNode
	DATA() antlr.TerminalNode
	QUOTA() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsAlterDbQuotaStatementContext differentiates from other interfaces.
	IsAlterDbQuotaStatementContext()
}

type AlterDbQuotaStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterDbQuotaStatementContext() *AlterDbQuotaStatementContext {
	var p = new(AlterDbQuotaStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterDbQuotaStatement
	return p
}

func InitEmptyAlterDbQuotaStatementContext(p *AlterDbQuotaStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterDbQuotaStatement
}

func (*AlterDbQuotaStatementContext) IsAlterDbQuotaStatementContext() {}

func NewAlterDbQuotaStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDbQuotaStatementContext {
	var p = new(AlterDbQuotaStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_alterDbQuotaStatement

	return p
}

func (s *AlterDbQuotaStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDbQuotaStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *AlterDbQuotaStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATABASE, 0)
}

func (s *AlterDbQuotaStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterDbQuotaStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterDbQuotaStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *AlterDbQuotaStatementContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATA, 0)
}

func (s *AlterDbQuotaStatementContext) QUOTA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserQUOTA, 0)
}

func (s *AlterDbQuotaStatementContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPLICA, 0)
}

func (s *AlterDbQuotaStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, 0)
}

func (s *AlterDbQuotaStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDbQuotaStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterDbQuotaStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAlterDbQuotaStatement(s)
	}
}

func (s *AlterDbQuotaStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAlterDbQuotaStatement(s)
	}
}

func (s *AlterDbQuotaStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAlterDbQuotaStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AlterDbQuotaStatement() (localctx IAlterDbQuotaStatementContext) {
	localctx = NewAlterDbQuotaStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, DorisSQLParserRULE_alterDbQuotaStatement)
	p.SetState(1347)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1331)
			p.Match(DorisSQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1332)
			p.Match(DorisSQLParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1333)
			p.Identifier()
		}
		{
			p.SetState(1334)
			p.Match(DorisSQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1335)
			p.Match(DorisSQLParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1336)
			p.Match(DorisSQLParserQUOTA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1337)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1339)
			p.Match(DorisSQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1340)
			p.Match(DorisSQLParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1341)
			p.Identifier()
		}
		{
			p.SetState(1342)
			p.Match(DorisSQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1343)
			p.Match(DorisSQLParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1344)
			p.Match(DorisSQLParserQUOTA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1345)
			p.Match(DorisSQLParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDbStatementContext is an interface to support dynamic dispatch.
type ICreateDbStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IIdentifierContext

	// GetDatabase returns the database rule contexts.
	GetDatabase() IQualifiedNameContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IIdentifierContext)

	// SetDatabase sets the database rule contexts.
	SetDatabase(IQualifiedNameContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	CharsetDesc() ICharsetDescContext
	CollateDesc() ICollateDescContext
	Properties() IPropertiesContext
	Identifier() IIdentifierContext

	// IsCreateDbStatementContext differentiates from other interfaces.
	IsCreateDbStatementContext()
}

type CreateDbStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	catalog  IIdentifierContext
	database IQualifiedNameContext
}

func NewEmptyCreateDbStatementContext() *CreateDbStatementContext {
	var p = new(CreateDbStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createDbStatement
	return p
}

func InitEmptyCreateDbStatementContext(p *CreateDbStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createDbStatement
}

func (*CreateDbStatementContext) IsCreateDbStatementContext() {}

func NewCreateDbStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDbStatementContext {
	var p = new(CreateDbStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createDbStatement

	return p
}

func (s *CreateDbStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDbStatementContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *CreateDbStatementContext) GetDatabase() IQualifiedNameContext { return s.database }

func (s *CreateDbStatementContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *CreateDbStatementContext) SetDatabase(v IQualifiedNameContext) { s.database = v }

func (s *CreateDbStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateDbStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATABASE, 0)
}

func (s *CreateDbStatementContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSCHEMA, 0)
}

func (s *CreateDbStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateDbStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *CreateDbStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *CreateDbStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *CreateDbStatementContext) CharsetDesc() ICharsetDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetDescContext)
}

func (s *CreateDbStatementContext) CollateDesc() ICollateDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollateDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollateDescContext)
}

func (s *CreateDbStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateDbStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateDbStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDbStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDbStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateDbStatement(s)
	}
}

func (s *CreateDbStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateDbStatement(s)
	}
}

func (s *CreateDbStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateDbStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateDbStatement() (localctx ICreateDbStatementContext) {
	localctx = NewCreateDbStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, DorisSQLParserRULE_createDbStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1349)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1350)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserDATABASE || _la == DorisSQLParserSCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1354)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(1351)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1352)
			p.Match(DorisSQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1353)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1359)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1356)

			var _x = p.Identifier()

			localctx.(*CreateDbStatementContext).catalog = _x
		}
		{
			p.SetState(1357)
			p.Match(DorisSQLParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1361)

		var _x = p.QualifiedName()

		localctx.(*CreateDbStatementContext).database = _x
	}
	p.SetState(1363)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1362)
			p.CharsetDesc()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1366)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserCOLLATE || _la == DorisSQLParserDEFAULT {
		{
			p.SetState(1365)
			p.CollateDesc()
		}

	}
	p.SetState(1369)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(1368)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropDbStatementContext is an interface to support dynamic dispatch.
type IDropDbStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IIdentifierContext

	// GetDatabase returns the database rule contexts.
	GetDatabase() IQualifiedNameContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IIdentifierContext)

	// SetDatabase sets the database rule contexts.
	SetDatabase(IQualifiedNameContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	FORCE() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDropDbStatementContext differentiates from other interfaces.
	IsDropDbStatementContext()
}

type DropDbStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	catalog  IIdentifierContext
	database IQualifiedNameContext
}

func NewEmptyDropDbStatementContext() *DropDbStatementContext {
	var p = new(DropDbStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropDbStatement
	return p
}

func InitEmptyDropDbStatementContext(p *DropDbStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropDbStatement
}

func (*DropDbStatementContext) IsDropDbStatementContext() {}

func NewDropDbStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropDbStatementContext {
	var p = new(DropDbStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropDbStatement

	return p
}

func (s *DropDbStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropDbStatementContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *DropDbStatementContext) GetDatabase() IQualifiedNameContext { return s.database }

func (s *DropDbStatementContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *DropDbStatementContext) SetDatabase(v IQualifiedNameContext) { s.database = v }

func (s *DropDbStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropDbStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATABASE, 0)
}

func (s *DropDbStatementContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSCHEMA, 0)
}

func (s *DropDbStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropDbStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *DropDbStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *DropDbStatementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFORCE, 0)
}

func (s *DropDbStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropDbStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDbStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropDbStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropDbStatement(s)
	}
}

func (s *DropDbStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropDbStatement(s)
	}
}

func (s *DropDbStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropDbStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropDbStatement() (localctx IDropDbStatementContext) {
	localctx = NewDropDbStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, DorisSQLParserRULE_dropDbStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1371)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1372)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserDATABASE || _la == DorisSQLParserSCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1375)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(1373)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1374)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1380)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1377)

			var _x = p.Identifier()

			localctx.(*DropDbStatementContext).catalog = _x
		}
		{
			p.SetState(1378)
			p.Match(DorisSQLParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1382)

		var _x = p.QualifiedName()

		localctx.(*DropDbStatementContext).database = _x
	}
	p.SetState(1384)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFORCE {
		{
			p.SetState(1383)
			p.Match(DorisSQLParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCreateDbStatementContext is an interface to support dynamic dispatch.
type IShowCreateDbStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	Identifier() IIdentifierContext
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode

	// IsShowCreateDbStatementContext differentiates from other interfaces.
	IsShowCreateDbStatementContext()
}

type ShowCreateDbStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowCreateDbStatementContext() *ShowCreateDbStatementContext {
	var p = new(ShowCreateDbStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showCreateDbStatement
	return p
}

func InitEmptyShowCreateDbStatementContext(p *ShowCreateDbStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showCreateDbStatement
}

func (*ShowCreateDbStatementContext) IsShowCreateDbStatementContext() {}

func NewShowCreateDbStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCreateDbStatementContext {
	var p = new(ShowCreateDbStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showCreateDbStatement

	return p
}

func (s *ShowCreateDbStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCreateDbStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowCreateDbStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *ShowCreateDbStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateDbStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATABASE, 0)
}

func (s *ShowCreateDbStatementContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSCHEMA, 0)
}

func (s *ShowCreateDbStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateDbStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCreateDbStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowCreateDbStatement(s)
	}
}

func (s *ShowCreateDbStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowCreateDbStatement(s)
	}
}

func (s *ShowCreateDbStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowCreateDbStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowCreateDbStatement() (localctx IShowCreateDbStatementContext) {
	localctx = NewShowCreateDbStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, DorisSQLParserRULE_showCreateDbStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1386)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1387)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1388)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserDATABASE || _la == DorisSQLParserSCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1389)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterDatabaseRenameStatementContext is an interface to support dynamic dispatch.
type IAlterDatabaseRenameStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	RENAME() antlr.TerminalNode

	// IsAlterDatabaseRenameStatementContext differentiates from other interfaces.
	IsAlterDatabaseRenameStatementContext()
}

type AlterDatabaseRenameStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterDatabaseRenameStatementContext() *AlterDatabaseRenameStatementContext {
	var p = new(AlterDatabaseRenameStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterDatabaseRenameStatement
	return p
}

func InitEmptyAlterDatabaseRenameStatementContext(p *AlterDatabaseRenameStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterDatabaseRenameStatement
}

func (*AlterDatabaseRenameStatementContext) IsAlterDatabaseRenameStatementContext() {}

func NewAlterDatabaseRenameStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDatabaseRenameStatementContext {
	var p = new(AlterDatabaseRenameStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_alterDatabaseRenameStatement

	return p
}

func (s *AlterDatabaseRenameStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDatabaseRenameStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *AlterDatabaseRenameStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATABASE, 0)
}

func (s *AlterDatabaseRenameStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterDatabaseRenameStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterDatabaseRenameStatementContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRENAME, 0)
}

func (s *AlterDatabaseRenameStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseRenameStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterDatabaseRenameStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAlterDatabaseRenameStatement(s)
	}
}

func (s *AlterDatabaseRenameStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAlterDatabaseRenameStatement(s)
	}
}

func (s *AlterDatabaseRenameStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAlterDatabaseRenameStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AlterDatabaseRenameStatement() (localctx IAlterDatabaseRenameStatementContext) {
	localctx = NewAlterDatabaseRenameStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, DorisSQLParserRULE_alterDatabaseRenameStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1391)
		p.Match(DorisSQLParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1392)
		p.Match(DorisSQLParserDATABASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1393)
		p.Identifier()
	}
	{
		p.SetState(1394)
		p.Match(DorisSQLParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1395)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecoverDbStmtContext is an interface to support dynamic dispatch.
type IRecoverDbStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RECOVER() antlr.TerminalNode
	Identifier() IIdentifierContext
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode

	// IsRecoverDbStmtContext differentiates from other interfaces.
	IsRecoverDbStmtContext()
}

type RecoverDbStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecoverDbStmtContext() *RecoverDbStmtContext {
	var p = new(RecoverDbStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_recoverDbStmt
	return p
}

func InitEmptyRecoverDbStmtContext(p *RecoverDbStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_recoverDbStmt
}

func (*RecoverDbStmtContext) IsRecoverDbStmtContext() {}

func NewRecoverDbStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecoverDbStmtContext {
	var p = new(RecoverDbStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_recoverDbStmt

	return p
}

func (s *RecoverDbStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *RecoverDbStmtContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRECOVER, 0)
}

func (s *RecoverDbStmtContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RecoverDbStmtContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATABASE, 0)
}

func (s *RecoverDbStmtContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSCHEMA, 0)
}

func (s *RecoverDbStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecoverDbStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecoverDbStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRecoverDbStmt(s)
	}
}

func (s *RecoverDbStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRecoverDbStmt(s)
	}
}

func (s *RecoverDbStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRecoverDbStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) RecoverDbStmt() (localctx IRecoverDbStmtContext) {
	localctx = NewRecoverDbStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, DorisSQLParserRULE_recoverDbStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1397)
		p.Match(DorisSQLParserRECOVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1398)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserDATABASE || _la == DorisSQLParserSCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1399)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDataStmtContext is an interface to support dynamic dispatch.
type IShowDataStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	DATA() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowDataStmtContext differentiates from other interfaces.
	IsShowDataStmtContext()
}

type ShowDataStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowDataStmtContext() *ShowDataStmtContext {
	var p = new(ShowDataStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showDataStmt
	return p
}

func InitEmptyShowDataStmtContext(p *ShowDataStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showDataStmt
}

func (*ShowDataStmtContext) IsShowDataStmtContext() {}

func NewShowDataStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDataStmtContext {
	var p = new(ShowDataStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showDataStmt

	return p
}

func (s *ShowDataStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDataStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowDataStmtContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATA, 0)
}

func (s *ShowDataStmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowDataStmtContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowDataStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDataStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDataStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowDataStmt(s)
	}
}

func (s *ShowDataStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowDataStmt(s)
	}
}

func (s *ShowDataStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowDataStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowDataStmt() (localctx IShowDataStmtContext) {
	localctx = NewShowDataStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, DorisSQLParserRULE_showDataStmt)
	p.SetState(1407)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1401)
			p.Match(DorisSQLParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1402)
			p.Match(DorisSQLParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1403)
			p.Match(DorisSQLParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1404)
			p.Match(DorisSQLParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1405)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1406)
			p.QualifiedName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDataDistributionStmtContext is an interface to support dynamic dispatch.
type IShowDataDistributionStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DISTRIBUTION() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext

	// IsShowDataDistributionStmtContext differentiates from other interfaces.
	IsShowDataDistributionStmtContext()
}

type ShowDataDistributionStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowDataDistributionStmtContext() *ShowDataDistributionStmtContext {
	var p = new(ShowDataDistributionStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showDataDistributionStmt
	return p
}

func InitEmptyShowDataDistributionStmtContext(p *ShowDataDistributionStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showDataDistributionStmt
}

func (*ShowDataDistributionStmtContext) IsShowDataDistributionStmtContext() {}

func NewShowDataDistributionStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDataDistributionStmtContext {
	var p = new(ShowDataDistributionStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showDataDistributionStmt

	return p
}

func (s *ShowDataDistributionStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDataDistributionStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowDataDistributionStmtContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATA, 0)
}

func (s *ShowDataDistributionStmtContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDISTRIBUTION, 0)
}

func (s *ShowDataDistributionStmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowDataDistributionStmtContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowDataDistributionStmtContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *ShowDataDistributionStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDataDistributionStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDataDistributionStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowDataDistributionStmt(s)
	}
}

func (s *ShowDataDistributionStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowDataDistributionStmt(s)
	}
}

func (s *ShowDataDistributionStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowDataDistributionStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowDataDistributionStmt() (localctx IShowDataDistributionStmtContext) {
	localctx = NewShowDataDistributionStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, DorisSQLParserRULE_showDataDistributionStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1409)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1410)
		p.Match(DorisSQLParserDATA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1411)
		p.Match(DorisSQLParserDISTRIBUTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1412)
		p.Match(DorisSQLParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1413)
		p.QualifiedName()
	}
	p.SetState(1415)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPARTITION || _la == DorisSQLParserPARTITIONS || _la == DorisSQLParserTEMPORARY {
		{
			p.SetState(1414)
			p.PartitionNames()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableStatementContext is an interface to support dynamic dispatch.
type ICreateTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AllColumnDesc() []IColumnDescContext
	ColumnDesc(i int) IColumnDescContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AllIndexDesc() []IIndexDescContext
	IndexDesc(i int) IIndexDescContext
	EngineDesc() IEngineDescContext
	CharsetDesc() ICharsetDescContext
	KeyDesc() IKeyDescContext
	Comment() ICommentContext
	PartitionDesc() IPartitionDescContext
	DistributionDesc() IDistributionDescContext
	OrderByDesc() IOrderByDescContext
	RollupDesc() IRollupDescContext
	Properties() IPropertiesContext
	ExtProperties() IExtPropertiesContext
	TEMPORARY() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode

	// IsCreateTableStatementContext differentiates from other interfaces.
	IsCreateTableStatementContext()
}

type CreateTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableStatementContext() *CreateTableStatementContext {
	var p = new(CreateTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createTableStatement
	return p
}

func InitEmptyCreateTableStatementContext(p *CreateTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createTableStatement
}

func (*CreateTableStatementContext) IsCreateTableStatementContext() {}

func NewCreateTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableStatementContext {
	var p = new(CreateTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createTableStatement

	return p
}

func (s *CreateTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *CreateTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateTableStatementContext) AllColumnDesc() []IColumnDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnDescContext); ok {
			len++
		}
	}

	tst := make([]IColumnDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnDescContext); ok {
			tst[i] = t.(IColumnDescContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableStatementContext) ColumnDesc(i int) IColumnDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDescContext)
}

func (s *CreateTableStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *CreateTableStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *CreateTableStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *CreateTableStatementContext) AllIndexDesc() []IIndexDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexDescContext); ok {
			len++
		}
	}

	tst := make([]IIndexDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexDescContext); ok {
			tst[i] = t.(IIndexDescContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableStatementContext) IndexDesc(i int) IIndexDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexDescContext)
}

func (s *CreateTableStatementContext) EngineDesc() IEngineDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineDescContext)
}

func (s *CreateTableStatementContext) CharsetDesc() ICharsetDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetDescContext)
}

func (s *CreateTableStatementContext) KeyDesc() IKeyDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyDescContext)
}

func (s *CreateTableStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateTableStatementContext) PartitionDesc() IPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDescContext)
}

func (s *CreateTableStatementContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *CreateTableStatementContext) OrderByDesc() IOrderByDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByDescContext)
}

func (s *CreateTableStatementContext) RollupDesc() IRollupDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupDescContext)
}

func (s *CreateTableStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateTableStatementContext) ExtProperties() IExtPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtPropertiesContext)
}

func (s *CreateTableStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTEMPORARY, 0)
}

func (s *CreateTableStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXTERNAL, 0)
}

func (s *CreateTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateTableStatement(s)
	}
}

func (s *CreateTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateTableStatement(s)
	}
}

func (s *CreateTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateTableStatement() (localctx ICreateTableStatementContext) {
	localctx = NewCreateTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, DorisSQLParserRULE_createTableStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1417)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserEXTERNAL || _la == DorisSQLParserTEMPORARY {
		{
			p.SetState(1418)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserEXTERNAL || _la == DorisSQLParserTEMPORARY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1421)
		p.Match(DorisSQLParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1425)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(1422)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1423)
			p.Match(DorisSQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1424)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1427)
		p.QualifiedName()
	}
	{
		p.SetState(1428)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1429)
		p.ColumnDesc()
	}
	p.SetState(1434)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1430)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1431)
				p.ColumnDesc()
			}

		}
		p.SetState(1436)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1441)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(1437)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1438)
			p.IndexDesc()
		}

		p.SetState(1443)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1444)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1446)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserENGINE {
		{
			p.SetState(1445)
			p.EngineDesc()
		}

	}
	p.SetState(1449)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&9007199254740999) != 0 {
		{
			p.SetState(1448)
			p.CharsetDesc()
		}

	}
	p.SetState(1452)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserAGGREGATE || _la == DorisSQLParserDUPLICATE || _la == DorisSQLParserPRIMARY || _la == DorisSQLParserUNIQUE {
		{
			p.SetState(1451)
			p.KeyDesc()
		}

	}
	p.SetState(1455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserCOMMENT {
		{
			p.SetState(1454)
			p.Comment()
		}

	}
	p.SetState(1458)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPARTITION {
		{
			p.SetState(1457)
			p.PartitionDesc()
		}

	}
	p.SetState(1461)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserDISTRIBUTED {
		{
			p.SetState(1460)
			p.DistributionDesc()
		}

	}
	p.SetState(1464)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserORDER {
		{
			p.SetState(1463)
			p.OrderByDesc()
		}

	}
	p.SetState(1467)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserROLLUP {
		{
			p.SetState(1466)
			p.RollupDesc()
		}

	}
	p.SetState(1470)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(1469)
			p.Properties()
		}

	}
	p.SetState(1473)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserBROKER {
		{
			p.SetState(1472)
			p.ExtProperties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDescContext is an interface to support dynamic dispatch.
type IColumnDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Type_() ITypeContext
	CharsetName() ICharsetNameContext
	KEY() antlr.TerminalNode
	AggDesc() IAggDescContext
	ColumnNullable() IColumnNullableContext
	DefaultDesc() IDefaultDescContext
	AUTO_INCREMENT() antlr.TerminalNode
	GeneratedColumnDesc() IGeneratedColumnDescContext
	Comment() ICommentContext

	// IsColumnDescContext differentiates from other interfaces.
	IsColumnDescContext()
}

type ColumnDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDescContext() *ColumnDescContext {
	var p = new(ColumnDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_columnDesc
	return p
}

func InitEmptyColumnDescContext(p *ColumnDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_columnDesc
}

func (*ColumnDescContext) IsColumnDescContext() {}

func NewColumnDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDescContext {
	var p = new(ColumnDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_columnDesc

	return p
}

func (s *ColumnDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnDescContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ColumnDescContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *ColumnDescContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserKEY, 0)
}

func (s *ColumnDescContext) AggDesc() IAggDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggDescContext)
}

func (s *ColumnDescContext) ColumnNullable() IColumnNullableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNullableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNullableContext)
}

func (s *ColumnDescContext) DefaultDesc() IDefaultDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultDescContext)
}

func (s *ColumnDescContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAUTO_INCREMENT, 0)
}

func (s *ColumnDescContext) GeneratedColumnDesc() IGeneratedColumnDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneratedColumnDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneratedColumnDescContext)
}

func (s *ColumnDescContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *ColumnDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterColumnDesc(s)
	}
}

func (s *ColumnDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitColumnDesc(s)
	}
}

func (s *ColumnDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitColumnDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ColumnDesc() (localctx IColumnDescContext) {
	localctx = NewColumnDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, DorisSQLParserRULE_columnDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1475)
		p.Identifier()
	}
	p.SetState(1477)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1476)
			p.Type_()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1480)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1479)
			p.CharsetName()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1483)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserKEY {
		{
			p.SetState(1482)
			p.Match(DorisSQLParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1486)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1485)
			p.AggDesc()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1489)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserNOT || _la == DorisSQLParserNULL {
		{
			p.SetState(1488)
			p.ColumnNullable()
		}

	}
	p.SetState(1494)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserDEFAULT:
		{
			p.SetState(1491)
			p.DefaultDesc()
		}

	case DorisSQLParserAUTO_INCREMENT:
		{
			p.SetState(1492)
			p.Match(DorisSQLParserAUTO_INCREMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserAS:
		{
			p.SetState(1493)
			p.GeneratedColumnDesc()
		}

	case DorisSQLParserEOF, DorisSQLParserT__2, DorisSQLParserT__3, DorisSQLParserAFTER, DorisSQLParserCOMMENT, DorisSQLParserFIRST, DorisSQLParserFROM, DorisSQLParserIN, DorisSQLParserPROPERTIES, DorisSQLParserTO, DorisSQLParserSEMICOLON:

	default:
	}
	p.SetState(1497)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserCOMMENT {
		{
			p.SetState(1496)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharsetNameContext is an interface to support dynamic dispatch.
type ICharsetNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHAR() antlr.TerminalNode
	SET() antlr.TerminalNode
	Identifier() IIdentifierContext
	CHARSET() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode

	// IsCharsetNameContext differentiates from other interfaces.
	IsCharsetNameContext()
}

type CharsetNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetNameContext() *CharsetNameContext {
	var p = new(CharsetNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_charsetName
	return p
}

func InitEmptyCharsetNameContext(p *CharsetNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_charsetName
}

func (*CharsetNameContext) IsCharsetNameContext() {}

func NewCharsetNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetNameContext {
	var p = new(CharsetNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_charsetName

	return p
}

func (s *CharsetNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetNameContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCHAR, 0)
}

func (s *CharsetNameContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *CharsetNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CharsetNameContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCHARSET, 0)
}

func (s *CharsetNameContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCHARACTER, 0)
}

func (s *CharsetNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCharsetName(s)
	}
}

func (s *CharsetNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCharsetName(s)
	}
}

func (s *CharsetNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCharsetName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CharsetName() (localctx ICharsetNameContext) {
	localctx = NewCharsetNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, DorisSQLParserRULE_charsetName)
	p.SetState(1507)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserCHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1499)
			p.Match(DorisSQLParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1500)
			p.Match(DorisSQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1501)
			p.Identifier()
		}

	case DorisSQLParserCHARSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1502)
			p.Match(DorisSQLParserCHARSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1503)
			p.Identifier()
		}

	case DorisSQLParserCHARACTER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1504)
			p.Match(DorisSQLParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1505)
			p.Match(DorisSQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1506)
			p.Identifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultDescContext is an interface to support dynamic dispatch.
type IDefaultDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	String_() IStringContext
	NULL() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsDefaultDescContext differentiates from other interfaces.
	IsDefaultDescContext()
}

type DefaultDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultDescContext() *DefaultDescContext {
	var p = new(DefaultDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_defaultDesc
	return p
}

func InitEmptyDefaultDescContext(p *DefaultDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_defaultDesc
}

func (*DefaultDescContext) IsDefaultDescContext() {}

func NewDefaultDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultDescContext {
	var p = new(DefaultDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_defaultDesc

	return p
}

func (s *DefaultDescContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultDescContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDEFAULT, 0)
}

func (s *DefaultDescContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DefaultDescContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNULL, 0)
}

func (s *DefaultDescContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCURRENT_TIMESTAMP, 0)
}

func (s *DefaultDescContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DefaultDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDefaultDesc(s)
	}
}

func (s *DefaultDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDefaultDesc(s)
	}
}

func (s *DefaultDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDefaultDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DefaultDesc() (localctx IDefaultDescContext) {
	localctx = NewDefaultDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, DorisSQLParserRULE_defaultDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1509)
		p.Match(DorisSQLParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1519)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserSINGLE_QUOTED_TEXT, DorisSQLParserDOUBLE_QUOTED_TEXT:
		{
			p.SetState(1510)
			p.String_()
		}

	case DorisSQLParserNULL:
		{
			p.SetState(1511)
			p.Match(DorisSQLParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserCURRENT_TIMESTAMP:
		{
			p.SetState(1512)
			p.Match(DorisSQLParserCURRENT_TIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserT__1:
		{
			p.SetState(1513)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1514)
			p.QualifiedName()
		}
		{
			p.SetState(1515)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1516)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1517)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeneratedColumnDescContext is an interface to support dynamic dispatch.
type IGeneratedColumnDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	Expression() IExpressionContext

	// IsGeneratedColumnDescContext differentiates from other interfaces.
	IsGeneratedColumnDescContext()
}

type GeneratedColumnDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneratedColumnDescContext() *GeneratedColumnDescContext {
	var p = new(GeneratedColumnDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_generatedColumnDesc
	return p
}

func InitEmptyGeneratedColumnDescContext(p *GeneratedColumnDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_generatedColumnDesc
}

func (*GeneratedColumnDescContext) IsGeneratedColumnDescContext() {}

func NewGeneratedColumnDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneratedColumnDescContext {
	var p = new(GeneratedColumnDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_generatedColumnDesc

	return p
}

func (s *GeneratedColumnDescContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneratedColumnDescContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *GeneratedColumnDescContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GeneratedColumnDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratedColumnDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneratedColumnDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterGeneratedColumnDesc(s)
	}
}

func (s *GeneratedColumnDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitGeneratedColumnDesc(s)
	}
}

func (s *GeneratedColumnDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitGeneratedColumnDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) GeneratedColumnDesc() (localctx IGeneratedColumnDescContext) {
	localctx = NewGeneratedColumnDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, DorisSQLParserRULE_generatedColumnDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1521)
		p.Match(DorisSQLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1522)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexDescContext is an interface to support dynamic dispatch.
type IIndexDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// Getter signatures
	INDEX() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	Identifier() IIdentifierContext
	IndexType() IIndexTypeContext
	Comment() ICommentContext
	PropertyList() IPropertyListContext

	// IsIndexDescContext differentiates from other interfaces.
	IsIndexDescContext()
}

type IndexDescContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	indexName IIdentifierContext
}

func NewEmptyIndexDescContext() *IndexDescContext {
	var p = new(IndexDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_indexDesc
	return p
}

func InitEmptyIndexDescContext(p *IndexDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_indexDesc
}

func (*IndexDescContext) IsIndexDescContext() {}

func NewIndexDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexDescContext {
	var p = new(IndexDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_indexDesc

	return p
}

func (s *IndexDescContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexDescContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *IndexDescContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *IndexDescContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINDEX, 0)
}

func (s *IndexDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *IndexDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IndexDescContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *IndexDescContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *IndexDescContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *IndexDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterIndexDesc(s)
	}
}

func (s *IndexDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitIndexDesc(s)
	}
}

func (s *IndexDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitIndexDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) IndexDesc() (localctx IIndexDescContext) {
	localctx = NewIndexDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, DorisSQLParserRULE_indexDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1524)
		p.Match(DorisSQLParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1525)

		var _x = p.Identifier()

		localctx.(*IndexDescContext).indexName = _x
	}
	{
		p.SetState(1526)
		p.IdentifierList()
	}
	p.SetState(1531)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserUSING {
		{
			p.SetState(1527)
			p.IndexType()
		}
		p.SetState(1529)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__1 {
			{
				p.SetState(1528)
				p.PropertyList()
			}

		}

	}
	p.SetState(1534)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserCOMMENT {
		{
			p.SetState(1533)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEngineDescContext is an interface to support dynamic dispatch.
type IEngineDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENGINE() antlr.TerminalNode
	EQ() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsEngineDescContext differentiates from other interfaces.
	IsEngineDescContext()
}

type EngineDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEngineDescContext() *EngineDescContext {
	var p = new(EngineDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_engineDesc
	return p
}

func InitEmptyEngineDescContext(p *EngineDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_engineDesc
}

func (*EngineDescContext) IsEngineDescContext() {}

func NewEngineDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EngineDescContext {
	var p = new(EngineDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_engineDesc

	return p
}

func (s *EngineDescContext) GetParser() antlr.Parser { return s.parser }

func (s *EngineDescContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserENGINE, 0)
}

func (s *EngineDescContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEQ, 0)
}

func (s *EngineDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EngineDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EngineDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EngineDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterEngineDesc(s)
	}
}

func (s *EngineDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitEngineDesc(s)
	}
}

func (s *EngineDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitEngineDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) EngineDesc() (localctx IEngineDescContext) {
	localctx = NewEngineDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, DorisSQLParserRULE_engineDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1536)
		p.Match(DorisSQLParserENGINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1537)
		p.Match(DorisSQLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1538)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharsetDescContext is an interface to support dynamic dispatch.
type ICharsetDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierOrString() IIdentifierOrStringContext
	CHAR() antlr.TerminalNode
	SET() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	EQ() antlr.TerminalNode

	// IsCharsetDescContext differentiates from other interfaces.
	IsCharsetDescContext()
}

type CharsetDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetDescContext() *CharsetDescContext {
	var p = new(CharsetDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_charsetDesc
	return p
}

func InitEmptyCharsetDescContext(p *CharsetDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_charsetDesc
}

func (*CharsetDescContext) IsCharsetDescContext() {}

func NewCharsetDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetDescContext {
	var p = new(CharsetDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_charsetDesc

	return p
}

func (s *CharsetDescContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetDescContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CharsetDescContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCHAR, 0)
}

func (s *CharsetDescContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *CharsetDescContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCHARSET, 0)
}

func (s *CharsetDescContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCHARACTER, 0)
}

func (s *CharsetDescContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDEFAULT, 0)
}

func (s *CharsetDescContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEQ, 0)
}

func (s *CharsetDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCharsetDesc(s)
	}
}

func (s *CharsetDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCharsetDesc(s)
	}
}

func (s *CharsetDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCharsetDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CharsetDesc() (localctx ICharsetDescContext) {
	localctx = NewCharsetDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, DorisSQLParserRULE_charsetDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1541)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserDEFAULT {
		{
			p.SetState(1540)
			p.Match(DorisSQLParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1548)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserCHAR:
		{
			p.SetState(1543)
			p.Match(DorisSQLParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1544)
			p.Match(DorisSQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserCHARSET:
		{
			p.SetState(1545)
			p.Match(DorisSQLParserCHARSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserCHARACTER:
		{
			p.SetState(1546)
			p.Match(DorisSQLParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1547)
			p.Match(DorisSQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1551)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserEQ {
		{
			p.SetState(1550)
			p.Match(DorisSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1553)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollateDescContext is an interface to support dynamic dispatch.
type ICollateDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLLATE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	DEFAULT() antlr.TerminalNode
	EQ() antlr.TerminalNode

	// IsCollateDescContext differentiates from other interfaces.
	IsCollateDescContext()
}

type CollateDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollateDescContext() *CollateDescContext {
	var p = new(CollateDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_collateDesc
	return p
}

func InitEmptyCollateDescContext(p *CollateDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_collateDesc
}

func (*CollateDescContext) IsCollateDescContext() {}

func NewCollateDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollateDescContext {
	var p = new(CollateDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_collateDesc

	return p
}

func (s *CollateDescContext) GetParser() antlr.Parser { return s.parser }

func (s *CollateDescContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLLATE, 0)
}

func (s *CollateDescContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CollateDescContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDEFAULT, 0)
}

func (s *CollateDescContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEQ, 0)
}

func (s *CollateDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollateDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCollateDesc(s)
	}
}

func (s *CollateDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCollateDesc(s)
	}
}

func (s *CollateDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCollateDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CollateDesc() (localctx ICollateDescContext) {
	localctx = NewCollateDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, DorisSQLParserRULE_collateDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserDEFAULT {
		{
			p.SetState(1555)
			p.Match(DorisSQLParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1558)
		p.Match(DorisSQLParserCOLLATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1560)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserEQ {
		{
			p.SetState(1559)
			p.Match(DorisSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1562)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyDescContext is an interface to support dynamic dispatch.
type IKeyDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEY() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	AGGREGATE() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	DUPLICATE() antlr.TerminalNode

	// IsKeyDescContext differentiates from other interfaces.
	IsKeyDescContext()
}

type KeyDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyDescContext() *KeyDescContext {
	var p = new(KeyDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_keyDesc
	return p
}

func InitEmptyKeyDescContext(p *KeyDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_keyDesc
}

func (*KeyDescContext) IsKeyDescContext() {}

func NewKeyDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyDescContext {
	var p = new(KeyDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_keyDesc

	return p
}

func (s *KeyDescContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyDescContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserKEY, 0)
}

func (s *KeyDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *KeyDescContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAGGREGATE, 0)
}

func (s *KeyDescContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUNIQUE, 0)
}

func (s *KeyDescContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPRIMARY, 0)
}

func (s *KeyDescContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDUPLICATE, 0)
}

func (s *KeyDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterKeyDesc(s)
	}
}

func (s *KeyDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitKeyDesc(s)
	}
}

func (s *KeyDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitKeyDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) KeyDesc() (localctx IKeyDescContext) {
	localctx = NewKeyDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, DorisSQLParserRULE_keyDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1564)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserAGGREGATE || _la == DorisSQLParserDUPLICATE || _la == DorisSQLParserPRIMARY || _la == DorisSQLParserUNIQUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1565)
		p.Match(DorisSQLParserKEY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1566)
		p.IdentifierList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderByDescContext is an interface to support dynamic dispatch.
type IOrderByDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsOrderByDescContext differentiates from other interfaces.
	IsOrderByDescContext()
}

type OrderByDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByDescContext() *OrderByDescContext {
	var p = new(OrderByDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_orderByDesc
	return p
}

func InitEmptyOrderByDescContext(p *OrderByDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_orderByDesc
}

func (*OrderByDescContext) IsOrderByDescContext() {}

func NewOrderByDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByDescContext {
	var p = new(OrderByDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_orderByDesc

	return p
}

func (s *OrderByDescContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByDescContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserORDER, 0)
}

func (s *OrderByDescContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *OrderByDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *OrderByDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterOrderByDesc(s)
	}
}

func (s *OrderByDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitOrderByDesc(s)
	}
}

func (s *OrderByDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitOrderByDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) OrderByDesc() (localctx IOrderByDescContext) {
	localctx = NewOrderByDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, DorisSQLParserRULE_orderByDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1568)
		p.Match(DorisSQLParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1569)
		p.Match(DorisSQLParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1570)
		p.IdentifierList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnNullableContext is an interface to support dynamic dispatch.
type IColumnNullableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsColumnNullableContext differentiates from other interfaces.
	IsColumnNullableContext()
}

type ColumnNullableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNullableContext() *ColumnNullableContext {
	var p = new(ColumnNullableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_columnNullable
	return p
}

func InitEmptyColumnNullableContext(p *ColumnNullableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_columnNullable
}

func (*ColumnNullableContext) IsColumnNullableContext() {}

func NewColumnNullableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNullableContext {
	var p = new(ColumnNullableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_columnNullable

	return p
}

func (s *ColumnNullableContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNullableContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNULL, 0)
}

func (s *ColumnNullableContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *ColumnNullableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNullableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNullableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterColumnNullable(s)
	}
}

func (s *ColumnNullableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitColumnNullable(s)
	}
}

func (s *ColumnNullableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitColumnNullable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ColumnNullable() (localctx IColumnNullableContext) {
	localctx = NewColumnNullableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, DorisSQLParserRULE_columnNullable)
	p.SetState(1575)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserNULL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1572)
			p.Match(DorisSQLParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserNOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1573)
			p.Match(DorisSQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1574)
			p.Match(DorisSQLParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeWithNullableContext is an interface to support dynamic dispatch.
type ITypeWithNullableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext
	ColumnNullable() IColumnNullableContext

	// IsTypeWithNullableContext differentiates from other interfaces.
	IsTypeWithNullableContext()
}

type TypeWithNullableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeWithNullableContext() *TypeWithNullableContext {
	var p = new(TypeWithNullableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_typeWithNullable
	return p
}

func InitEmptyTypeWithNullableContext(p *TypeWithNullableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_typeWithNullable
}

func (*TypeWithNullableContext) IsTypeWithNullableContext() {}

func NewTypeWithNullableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeWithNullableContext {
	var p = new(TypeWithNullableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_typeWithNullable

	return p
}

func (s *TypeWithNullableContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeWithNullableContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeWithNullableContext) ColumnNullable() IColumnNullableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNullableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNullableContext)
}

func (s *TypeWithNullableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeWithNullableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeWithNullableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTypeWithNullable(s)
	}
}

func (s *TypeWithNullableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTypeWithNullable(s)
	}
}

func (s *TypeWithNullableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTypeWithNullable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) TypeWithNullable() (localctx ITypeWithNullableContext) {
	localctx = NewTypeWithNullableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, DorisSQLParserRULE_typeWithNullable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1577)
		p.Type_()
	}
	p.SetState(1579)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserNOT || _la == DorisSQLParserNULL {
		{
			p.SetState(1578)
			p.ColumnNullable()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggStateDescContext is an interface to support dynamic dispatch.
type IAggStateDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AllTypeWithNullable() []ITypeWithNullableContext
	TypeWithNullable(i int) ITypeWithNullableContext

	// IsAggStateDescContext differentiates from other interfaces.
	IsAggStateDescContext()
}

type AggStateDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggStateDescContext() *AggStateDescContext {
	var p = new(AggStateDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_aggStateDesc
	return p
}

func InitEmptyAggStateDescContext(p *AggStateDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_aggStateDesc
}

func (*AggStateDescContext) IsAggStateDescContext() {}

func NewAggStateDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggStateDescContext {
	var p = new(AggStateDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_aggStateDesc

	return p
}

func (s *AggStateDescContext) GetParser() antlr.Parser { return s.parser }

func (s *AggStateDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AggStateDescContext) AllTypeWithNullable() []ITypeWithNullableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeWithNullableContext); ok {
			len++
		}
	}

	tst := make([]ITypeWithNullableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeWithNullableContext); ok {
			tst[i] = t.(ITypeWithNullableContext)
			i++
		}
	}

	return tst
}

func (s *AggStateDescContext) TypeWithNullable(i int) ITypeWithNullableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeWithNullableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeWithNullableContext)
}

func (s *AggStateDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggStateDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggStateDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAggStateDesc(s)
	}
}

func (s *AggStateDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAggStateDesc(s)
	}
}

func (s *AggStateDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAggStateDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AggStateDesc() (localctx IAggStateDescContext) {
	localctx = NewAggStateDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, DorisSQLParserRULE_aggStateDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1581)
		p.Identifier()
	}
	{
		p.SetState(1582)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1583)
		p.TypeWithNullable()
	}
	p.SetState(1588)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(1584)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1585)
			p.TypeWithNullable()
		}

		p.SetState(1590)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1591)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggDescContext is an interface to support dynamic dispatch.
type IAggDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUM() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MIN() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	HLL_UNION() antlr.TerminalNode
	BITMAP_UNION() antlr.TerminalNode
	PERCENTILE_UNION() antlr.TerminalNode
	REPLACE_IF_NOT_NULL() antlr.TerminalNode
	AggStateDesc() IAggStateDescContext

	// IsAggDescContext differentiates from other interfaces.
	IsAggDescContext()
}

type AggDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggDescContext() *AggDescContext {
	var p = new(AggDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_aggDesc
	return p
}

func InitEmptyAggDescContext(p *AggDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_aggDesc
}

func (*AggDescContext) IsAggDescContext() {}

func NewAggDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggDescContext {
	var p = new(AggDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_aggDesc

	return p
}

func (s *AggDescContext) GetParser() antlr.Parser { return s.parser }

func (s *AggDescContext) SUM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSUM, 0)
}

func (s *AggDescContext) MAX() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMAX, 0)
}

func (s *AggDescContext) MIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMIN, 0)
}

func (s *AggDescContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPLACE, 0)
}

func (s *AggDescContext) HLL_UNION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserHLL_UNION, 0)
}

func (s *AggDescContext) BITMAP_UNION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBITMAP_UNION, 0)
}

func (s *AggDescContext) PERCENTILE_UNION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPERCENTILE_UNION, 0)
}

func (s *AggDescContext) REPLACE_IF_NOT_NULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPLACE_IF_NOT_NULL, 0)
}

func (s *AggDescContext) AggStateDesc() IAggStateDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggStateDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggStateDescContext)
}

func (s *AggDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAggDesc(s)
	}
}

func (s *AggDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAggDesc(s)
	}
}

func (s *AggDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAggDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AggDesc() (localctx IAggDescContext) {
	localctx = NewAggDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, DorisSQLParserRULE_aggDesc)
	p.SetState(1602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1593)
			p.Match(DorisSQLParserSUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1594)
			p.Match(DorisSQLParserMAX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1595)
			p.Match(DorisSQLParserMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1596)
			p.Match(DorisSQLParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1597)
			p.Match(DorisSQLParserHLL_UNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1598)
			p.Match(DorisSQLParserBITMAP_UNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1599)
			p.Match(DorisSQLParserPERCENTILE_UNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1600)
			p.Match(DorisSQLParserREPLACE_IF_NOT_NULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1601)
			p.AggStateDesc()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollupDescContext is an interface to support dynamic dispatch.
type IRollupDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLLUP() antlr.TerminalNode
	AllRollupItem() []IRollupItemContext
	RollupItem(i int) IRollupItemContext

	// IsRollupDescContext differentiates from other interfaces.
	IsRollupDescContext()
}

type RollupDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollupDescContext() *RollupDescContext {
	var p = new(RollupDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_rollupDesc
	return p
}

func InitEmptyRollupDescContext(p *RollupDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_rollupDesc
}

func (*RollupDescContext) IsRollupDescContext() {}

func NewRollupDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollupDescContext {
	var p = new(RollupDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_rollupDesc

	return p
}

func (s *RollupDescContext) GetParser() antlr.Parser { return s.parser }

func (s *RollupDescContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROLLUP, 0)
}

func (s *RollupDescContext) AllRollupItem() []IRollupItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRollupItemContext); ok {
			len++
		}
	}

	tst := make([]IRollupItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRollupItemContext); ok {
			tst[i] = t.(IRollupItemContext)
			i++
		}
	}

	return tst
}

func (s *RollupDescContext) RollupItem(i int) IRollupItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupItemContext)
}

func (s *RollupDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollupDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRollupDesc(s)
	}
}

func (s *RollupDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRollupDesc(s)
	}
}

func (s *RollupDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRollupDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) RollupDesc() (localctx IRollupDescContext) {
	localctx = NewRollupDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, DorisSQLParserRULE_rollupDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1604)
		p.Match(DorisSQLParserROLLUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1605)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1606)
		p.RollupItem()
	}
	p.SetState(1611)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(1607)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1608)
			p.RollupItem()
		}

		p.SetState(1613)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1614)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollupItemContext is an interface to support dynamic dispatch.
type IRollupItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// Getter signatures
	IdentifierList() IIdentifierListContext
	Identifier() IIdentifierContext
	DupKeys() IDupKeysContext
	FromRollup() IFromRollupContext
	Properties() IPropertiesContext

	// IsRollupItemContext differentiates from other interfaces.
	IsRollupItemContext()
}

type RollupItemContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
}

func NewEmptyRollupItemContext() *RollupItemContext {
	var p = new(RollupItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_rollupItem
	return p
}

func InitEmptyRollupItemContext(p *RollupItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_rollupItem
}

func (*RollupItemContext) IsRollupItemContext() {}

func NewRollupItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollupItemContext {
	var p = new(RollupItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_rollupItem

	return p
}

func (s *RollupItemContext) GetParser() antlr.Parser { return s.parser }

func (s *RollupItemContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *RollupItemContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *RollupItemContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *RollupItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RollupItemContext) DupKeys() IDupKeysContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDupKeysContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDupKeysContext)
}

func (s *RollupItemContext) FromRollup() IFromRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromRollupContext)
}

func (s *RollupItemContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *RollupItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollupItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRollupItem(s)
	}
}

func (s *RollupItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRollupItem(s)
	}
}

func (s *RollupItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRollupItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) RollupItem() (localctx IRollupItemContext) {
	localctx = NewRollupItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, DorisSQLParserRULE_rollupItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1616)

		var _x = p.Identifier()

		localctx.(*RollupItemContext).rollupName = _x
	}
	{
		p.SetState(1617)
		p.IdentifierList()
	}
	p.SetState(1619)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserDUPLICATE {
		{
			p.SetState(1618)
			p.DupKeys()
		}

	}
	p.SetState(1622)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM {
		{
			p.SetState(1621)
			p.FromRollup()
		}

	}
	p.SetState(1625)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(1624)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDupKeysContext is an interface to support dynamic dispatch.
type IDupKeysContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DUPLICATE() antlr.TerminalNode
	KEY() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsDupKeysContext differentiates from other interfaces.
	IsDupKeysContext()
}

type DupKeysContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDupKeysContext() *DupKeysContext {
	var p = new(DupKeysContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dupKeys
	return p
}

func InitEmptyDupKeysContext(p *DupKeysContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dupKeys
}

func (*DupKeysContext) IsDupKeysContext() {}

func NewDupKeysContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DupKeysContext {
	var p = new(DupKeysContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dupKeys

	return p
}

func (s *DupKeysContext) GetParser() antlr.Parser { return s.parser }

func (s *DupKeysContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDUPLICATE, 0)
}

func (s *DupKeysContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserKEY, 0)
}

func (s *DupKeysContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DupKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DupKeysContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DupKeysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDupKeys(s)
	}
}

func (s *DupKeysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDupKeys(s)
	}
}

func (s *DupKeysContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDupKeys(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DupKeys() (localctx IDupKeysContext) {
	localctx = NewDupKeysContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, DorisSQLParserRULE_dupKeys)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1627)
		p.Match(DorisSQLParserDUPLICATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1628)
		p.Match(DorisSQLParserKEY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1629)
		p.IdentifierList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromRollupContext is an interface to support dynamic dispatch.
type IFromRollupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsFromRollupContext differentiates from other interfaces.
	IsFromRollupContext()
}

type FromRollupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromRollupContext() *FromRollupContext {
	var p = new(FromRollupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_fromRollup
	return p
}

func InitEmptyFromRollupContext(p *FromRollupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_fromRollup
}

func (*FromRollupContext) IsFromRollupContext() {}

func NewFromRollupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromRollupContext {
	var p = new(FromRollupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_fromRollup

	return p
}

func (s *FromRollupContext) GetParser() antlr.Parser { return s.parser }

func (s *FromRollupContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *FromRollupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FromRollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromRollupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromRollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterFromRollup(s)
	}
}

func (s *FromRollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitFromRollup(s)
	}
}

func (s *FromRollupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitFromRollup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) FromRollup() (localctx IFromRollupContext) {
	localctx = NewFromRollupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, DorisSQLParserRULE_fromRollup)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1631)
		p.Match(DorisSQLParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1632)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrReplaceContext is an interface to support dynamic dispatch.
type IOrReplaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode

	// IsOrReplaceContext differentiates from other interfaces.
	IsOrReplaceContext()
}

type OrReplaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrReplaceContext() *OrReplaceContext {
	var p = new(OrReplaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_orReplace
	return p
}

func InitEmptyOrReplaceContext(p *OrReplaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_orReplace
}

func (*OrReplaceContext) IsOrReplaceContext() {}

func NewOrReplaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrReplaceContext {
	var p = new(OrReplaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_orReplace

	return p
}

func (s *OrReplaceContext) GetParser() antlr.Parser { return s.parser }

func (s *OrReplaceContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOR, 0)
}

func (s *OrReplaceContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPLACE, 0)
}

func (s *OrReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrReplaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrReplaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterOrReplace(s)
	}
}

func (s *OrReplaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitOrReplace(s)
	}
}

func (s *OrReplaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitOrReplace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) OrReplace() (localctx IOrReplaceContext) {
	localctx = NewOrReplaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, DorisSQLParserRULE_orReplace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1636)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserOR {
		{
			p.SetState(1634)
			p.Match(DorisSQLParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1635)
			p.Match(DorisSQLParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfNotExistsContext is an interface to support dynamic dispatch.
type IIfNotExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsIfNotExistsContext differentiates from other interfaces.
	IsIfNotExistsContext()
}

type IfNotExistsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfNotExistsContext() *IfNotExistsContext {
	var p = new(IfNotExistsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_ifNotExists
	return p
}

func InitEmptyIfNotExistsContext(p *IfNotExistsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_ifNotExists
}

func (*IfNotExistsContext) IsIfNotExistsContext() {}

func NewIfNotExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfNotExistsContext {
	var p = new(IfNotExistsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_ifNotExists

	return p
}

func (s *IfNotExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfNotExistsContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *IfNotExistsContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *IfNotExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *IfNotExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfNotExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfNotExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterIfNotExists(s)
	}
}

func (s *IfNotExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitIfNotExists(s)
	}
}

func (s *IfNotExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitIfNotExists(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) IfNotExists() (localctx IIfNotExistsContext) {
	localctx = NewIfNotExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, DorisSQLParserRULE_ifNotExists)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1641)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(1638)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1639)
			p.Match(DorisSQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1640)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableAsSelectStatementContext is an interface to support dynamic dispatch.
type ICreateTableAsSelectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AS() antlr.TerminalNode
	QueryStatement() IQueryStatementContext
	TEMPORARY() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	KeyDesc() IKeyDescContext
	Comment() ICommentContext
	PartitionDesc() IPartitionDescContext
	DistributionDesc() IDistributionDescContext
	OrderByDesc() IOrderByDescContext
	Properties() IPropertiesContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllIndexDesc() []IIndexDescContext
	IndexDesc(i int) IIndexDescContext

	// IsCreateTableAsSelectStatementContext differentiates from other interfaces.
	IsCreateTableAsSelectStatementContext()
}

type CreateTableAsSelectStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableAsSelectStatementContext() *CreateTableAsSelectStatementContext {
	var p = new(CreateTableAsSelectStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createTableAsSelectStatement
	return p
}

func InitEmptyCreateTableAsSelectStatementContext(p *CreateTableAsSelectStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createTableAsSelectStatement
}

func (*CreateTableAsSelectStatementContext) IsCreateTableAsSelectStatementContext() {}

func NewCreateTableAsSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableAsSelectStatementContext {
	var p = new(CreateTableAsSelectStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createTableAsSelectStatement

	return p
}

func (s *CreateTableAsSelectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableAsSelectStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateTableAsSelectStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *CreateTableAsSelectStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateTableAsSelectStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *CreateTableAsSelectStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *CreateTableAsSelectStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTEMPORARY, 0)
}

func (s *CreateTableAsSelectStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *CreateTableAsSelectStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *CreateTableAsSelectStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *CreateTableAsSelectStatementContext) KeyDesc() IKeyDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyDescContext)
}

func (s *CreateTableAsSelectStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateTableAsSelectStatementContext) PartitionDesc() IPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDescContext)
}

func (s *CreateTableAsSelectStatementContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *CreateTableAsSelectStatementContext) OrderByDesc() IOrderByDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByDescContext)
}

func (s *CreateTableAsSelectStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateTableAsSelectStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableAsSelectStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateTableAsSelectStatementContext) AllIndexDesc() []IIndexDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexDescContext); ok {
			len++
		}
	}

	tst := make([]IIndexDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexDescContext); ok {
			tst[i] = t.(IIndexDescContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableAsSelectStatementContext) IndexDesc(i int) IIndexDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexDescContext)
}

func (s *CreateTableAsSelectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableAsSelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableAsSelectStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateTableAsSelectStatement(s)
	}
}

func (s *CreateTableAsSelectStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateTableAsSelectStatement(s)
	}
}

func (s *CreateTableAsSelectStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateTableAsSelectStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateTableAsSelectStatement() (localctx ICreateTableAsSelectStatementContext) {
	localctx = NewCreateTableAsSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, DorisSQLParserRULE_createTableAsSelectStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1643)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1645)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserTEMPORARY {
		{
			p.SetState(1644)
			p.Match(DorisSQLParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1647)
		p.Match(DorisSQLParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1651)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(1648)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1649)
			p.Match(DorisSQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1650)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1653)
		p.QualifiedName()
	}
	p.SetState(1682)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserT__1 {
		{
			p.SetState(1654)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1678)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserACCESS, DorisSQLParserACTIVE, DorisSQLParserADMIN, DorisSQLParserADVISOR, DorisSQLParserAFTER, DorisSQLParserAGGREGATE, DorisSQLParserANTI, DorisSQLParserAPPLY, DorisSQLParserARRAY_AGG, DorisSQLParserARRAY_AGG_DISTINCT, DorisSQLParserASYNC, DorisSQLParserAUTHORS, DorisSQLParserAUTHENTICATION, DorisSQLParserAUTOMATED, DorisSQLParserAUTO_INCREMENT, DorisSQLParserAVG, DorisSQLParserBACKEND, DorisSQLParserBACKENDS, DorisSQLParserBACKUP, DorisSQLParserBASE, DorisSQLParserBASELINE, DorisSQLParserBEGIN, DorisSQLParserBINARY, DorisSQLParserBITMAP_UNION, DorisSQLParserBLACKHOLE, DorisSQLParserBLACKLIST, DorisSQLParserBODY, DorisSQLParserBOOLEAN, DorisSQLParserBRANCH, DorisSQLParserBROKER, DorisSQLParserBUCKETS, DorisSQLParserBUILTIN, DorisSQLParserCACHE, DorisSQLParserCANCEL, DorisSQLParserCAST, DorisSQLParserCATALOG, DorisSQLParserCATALOGS, DorisSQLParserCEIL, DorisSQLParserCHAIN, DorisSQLParserCHARSET, DorisSQLParserCLEAN, DorisSQLParserCLEAR, DorisSQLParserCLUSTER, DorisSQLParserCLUSTERS, DorisSQLParserCNGROUP, DorisSQLParserCNGROUPS, DorisSQLParserCOLLATION, DorisSQLParserCOLUMNS, DorisSQLParserCOMMENT, DorisSQLParserCOMMIT, DorisSQLParserCOMMITTED, DorisSQLParserCOMPACT, DorisSQLParserCOMPUTE, DorisSQLParserCONFIG, DorisSQLParserCONNECTION, DorisSQLParserCONSISTENT, DorisSQLParserCOSTS, DorisSQLParserCOUNT, DorisSQLParserCUME_DIST, DorisSQLParserCUMULATIVE, DorisSQLParserCURRENT, DorisSQLParserDATA, DorisSQLParserDATACACHE, DorisSQLParserDATE, DorisSQLParserDATETIME, DorisSQLParserDAY, DorisSQLParserDAYS, DorisSQLParserDEALLOCATE, DorisSQLParserDECOMMISSION, DorisSQLParserDIALECT, DorisSQLParserDICTIONARY, DorisSQLParserDICTIONARY_GET, DorisSQLParserDISABLE, DorisSQLParserDISTRIBUTED, DorisSQLParserDISTRIBUTION, DorisSQLParserDUPLICATE, DorisSQLParserDYNAMIC, DorisSQLParserENABLE, DorisSQLParserENCLOSE, DorisSQLParserEND, DorisSQLParserENGINE, DorisSQLParserENGINES, DorisSQLParserERRORS, DorisSQLParserESCAPE, DorisSQLParserEVENTS, DorisSQLParserEXCEPT, DorisSQLParserEXCLUDE, DorisSQLParserEXECUTE, DorisSQLParserEXPORT, DorisSQLParserEXTERNAL, DorisSQLParserEXTRACT, DorisSQLParserEVERY, DorisSQLParserFAILPOINT, DorisSQLParserFAILPOINTS, DorisSQLParserFIELDS, DorisSQLParserFILE, DorisSQLParserFILTER, DorisSQLParserFIRST, DorisSQLParserFLOOR, DorisSQLParserFN, DorisSQLParserFOLLOWING, DorisSQLParserFOLLOWER, DorisSQLParserFORMAT, DorisSQLParserFREE, DorisSQLParserFRONTEND, DorisSQLParserFRONTENDS, DorisSQLParserFUNCTIONS, DorisSQLParserGLOBAL, DorisSQLParserGRANTS, DorisSQLParserGROUP_CONCAT, DorisSQLParserHASH, DorisSQLParserHELP, DorisSQLParserHISTOGRAM, DorisSQLParserHLL_UNION, DorisSQLParserHOST, DorisSQLParserHOUR, DorisSQLParserHOURS, DorisSQLParserHUB, DorisSQLParserIDENTIFIED, DorisSQLParserIMPERSONATE, DorisSQLParserIMAGE, DorisSQLParserINACTIVE, DorisSQLParserINCREMENTAL, DorisSQLParserINDEXES, DorisSQLParserINSTALL, DorisSQLParserINTEGRATION, DorisSQLParserINTEGRATIONS, DorisSQLParserINTERMEDIATE, DorisSQLParserINTERVAL, DorisSQLParserOVERWRITE, DorisSQLParserISOLATION, DorisSQLParserJOB, DorisSQLParserLABEL, DorisSQLParserLAST, DorisSQLParserLESS, DorisSQLParserLEVEL, DorisSQLParserLIST, DorisSQLParserLOCAL, DorisSQLParserLOCATION, DorisSQLParserLOCATIONS, DorisSQLParserLOGS, DorisSQLParserLOGICAL, DorisSQLParserMANUAL, DorisSQLParserMAP, DorisSQLParserMAPPING, DorisSQLParserMAPPINGS, DorisSQLParserMASKING, DorisSQLParserMATCH, DorisSQLParserMATERIALIZED, DorisSQLParserMAX, DorisSQLParserMERGE, DorisSQLParserMIN, DorisSQLParserMINUTE, DorisSQLParserMINUTES, DorisSQLParserMINUS, DorisSQLParserMETA, DorisSQLParserMODE, DorisSQLParserMODIFY, DorisSQLParserMONTH, DorisSQLParserMULTIPLE, DorisSQLParserNAME, DorisSQLParserNAMES, DorisSQLParserNEGATIVE, DorisSQLParserNGRAMBF, DorisSQLParserNO, DorisSQLParserNODE, DorisSQLParserNODES, DorisSQLParserNONE, DorisSQLParserNULLS, DorisSQLParserNUMBER, DorisSQLParserNUMERIC, DorisSQLParserOBSERVER, DorisSQLParserOF, DorisSQLParserOFF, DorisSQLParserOFFSET, DorisSQLParserONLY, DorisSQLParserOPEN, DorisSQLParserOPERATE, DorisSQLParserOPTIMIZER, DorisSQLParserOPTION, DorisSQLParserPARTITIONS, DorisSQLParserPASSWORD, DorisSQLParserPATH, DorisSQLParserPAUSE, DorisSQLParserPENDING, DorisSQLParserPERCENT_RANK, DorisSQLParserPERCENTILE_UNION, DorisSQLParserPLAN, DorisSQLParserPLUGIN, DorisSQLParserPLUGINS, DorisSQLParserPIPE, DorisSQLParserPIPES, DorisSQLParserPIVOT, DorisSQLParserPOLICY, DorisSQLParserPOLICIES, DorisSQLParserPRECEDING, DorisSQLParserPREDICATE, DorisSQLParserPRIORITY, DorisSQLParserPRIVILEGES, DorisSQLParserPROBABILITY, DorisSQLParserPROC, DorisSQLParserPROCESSLIST, DorisSQLParserPROFILE, DorisSQLParserPROFILELIST, DorisSQLParserPROPERTIES, DorisSQLParserPROPERTY, DorisSQLParserPROVIDER, DorisSQLParserPROVIDERS, DorisSQLParserQUALIFY, DorisSQLParserQUARTER, DorisSQLParserQUERY, DorisSQLParserQUERIES, DorisSQLParserQUEUE, DorisSQLParserQUOTA, DorisSQLParserRANDOM, DorisSQLParserRANK, DorisSQLParserREASON, DorisSQLParserRECOVER, DorisSQLParserREFRESH, DorisSQLParserREWRITE, DorisSQLParserREMOVE, DorisSQLParserREPAIR, DorisSQLParserREPEATABLE, DorisSQLParserREPLACE_IF_NOT_NULL, DorisSQLParserREPLICA, DorisSQLParserREPOSITORY, DorisSQLParserREPOSITORIES, DorisSQLParserRESOURCE, DorisSQLParserRESOURCES, DorisSQLParserRESTORE, DorisSQLParserRESUME, DorisSQLParserRETAIN, DorisSQLParserRETENTION, DorisSQLParserRETURNS, DorisSQLParserRETRY, DorisSQLParserREVERT, DorisSQLParserROLE, DorisSQLParserROLES, DorisSQLParserROLLBACK, DorisSQLParserROLLUP, DorisSQLParserROUTINE, DorisSQLParserROW, DorisSQLParserRULE, DorisSQLParserRULES, DorisSQLParserRUNNING, DorisSQLParserSAMPLE, DorisSQLParserSCHEDULE, DorisSQLParserSCHEDULER, DorisSQLParserSECOND, DorisSQLParserSECURITY, DorisSQLParserSEMI, DorisSQLParserSEPARATOR, DorisSQLParserSERIALIZABLE, DorisSQLParserSESSION, DorisSQLParserSETS, DorisSQLParserSIGNED, DorisSQLParserSKIP_HEADER, DorisSQLParserSNAPSHOT, DorisSQLParserSNAPSHOTS, DorisSQLParserSQLBLACKLIST, DorisSQLParserSTART, DorisSQLParserSTATS, DorisSQLParserSTATUS, DorisSQLParserSTOP, DorisSQLParserSTORAGE, DorisSQLParserSTREAM, DorisSQLParserSTRING, DorisSQLParserSUBMIT, DorisSQLParserSUM, DorisSQLParserSUSPEND, DorisSQLParserSYNC, DorisSQLParserSYSTEM_TIME, DorisSQLParserSWAP, DorisSQLParserSTRUCT, DorisSQLParserTABLES, DorisSQLParserTABLET, DorisSQLParserTABLETS, DorisSQLParserTAG, DorisSQLParserTASK, DorisSQLParserTEMPORARY, DorisSQLParserTHAN, DorisSQLParserTIME, DorisSQLParserTIMES, DorisSQLParserTIMESTAMP, DorisSQLParserTIMESTAMPADD, DorisSQLParserTIMESTAMPDIFF, DorisSQLParserTRANSACTION, DorisSQLParserTRANSLATE, DorisSQLParserTRACE, DorisSQLParserTRIGGERS, DorisSQLParserTRIM_SPACE, DorisSQLParserTRUNCATE, DorisSQLParserTYPE, DorisSQLParserTYPES, DorisSQLParserUNBOUNDED, DorisSQLParserUNCOMMITTED, DorisSQLParserUNINSTALL, DorisSQLParserUNSET, DorisSQLParserUSAGE, DorisSQLParserUSER, DorisSQLParserUSERS, DorisSQLParserVALUE, DorisSQLParserVARBINARY, DorisSQLParserVARIABLES, DorisSQLParserVECTOR, DorisSQLParserVERBOSE, DorisSQLParserVERSION, DorisSQLParserVIEW, DorisSQLParserVIEWS, DorisSQLParserVOLUME, DorisSQLParserVOLUMES, DorisSQLParserWAREHOUSE, DorisSQLParserWAREHOUSES, DorisSQLParserWARNINGS, DorisSQLParserWEEK, DorisSQLParserWHITELIST, DorisSQLParserWORK, DorisSQLParserWRITE, DorisSQLParserYEAR, DorisSQLParserLOCK, DorisSQLParserUNLOCK, DorisSQLParserLOW_PRIORITY, DorisSQLParserDISK, DorisSQLParserBEFORE, DorisSQLParserFIELD, DorisSQLParserPERSISTENT, DorisSQLParserARRAY_ELEMENT, DorisSQLParserLETTER_IDENTIFIER, DorisSQLParserDIGIT_IDENTIFIER, DorisSQLParserBACKQUOTED_IDENTIFIER, DorisSQLParserDOTDOTDOT:
			{
				p.SetState(1655)
				p.Identifier()
			}
			p.SetState(1660)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1656)
						p.Match(DorisSQLParserT__2)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1657)
						p.Identifier()
					}

				}
				p.SetState(1662)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(1667)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(1663)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1664)
					p.IndexDesc()
				}

				p.SetState(1669)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		case DorisSQLParserINDEX:
			{
				p.SetState(1670)
				p.IndexDesc()
			}
			p.SetState(1675)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(1671)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1672)
					p.IndexDesc()
				}

				p.SetState(1677)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(1680)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1685)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserAGGREGATE || _la == DorisSQLParserDUPLICATE || _la == DorisSQLParserPRIMARY || _la == DorisSQLParserUNIQUE {
		{
			p.SetState(1684)
			p.KeyDesc()
		}

	}
	p.SetState(1688)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserCOMMENT {
		{
			p.SetState(1687)
			p.Comment()
		}

	}
	p.SetState(1691)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPARTITION {
		{
			p.SetState(1690)
			p.PartitionDesc()
		}

	}
	p.SetState(1694)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserDISTRIBUTED {
		{
			p.SetState(1693)
			p.DistributionDesc()
		}

	}
	p.SetState(1697)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserORDER {
		{
			p.SetState(1696)
			p.OrderByDesc()
		}

	}
	p.SetState(1700)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(1699)
			p.Properties()
		}

	}
	{
		p.SetState(1702)
		p.Match(DorisSQLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1703)
		p.QueryStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTableStatementContext is an interface to support dynamic dispatch.
type IDropTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	TEMPORARY() antlr.TerminalNode
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	FORCE() antlr.TerminalNode

	// IsDropTableStatementContext differentiates from other interfaces.
	IsDropTableStatementContext()
}

type DropTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTableStatementContext() *DropTableStatementContext {
	var p = new(DropTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropTableStatement
	return p
}

func InitEmptyDropTableStatementContext(p *DropTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropTableStatement
}

func (*DropTableStatementContext) IsDropTableStatementContext() {}

func NewDropTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTableStatementContext {
	var p = new(DropTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropTableStatement

	return p
}

func (s *DropTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTableStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *DropTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropTableStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTEMPORARY, 0)
}

func (s *DropTableStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *DropTableStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *DropTableStatementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFORCE, 0)
}

func (s *DropTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropTableStatement(s)
	}
}

func (s *DropTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropTableStatement(s)
	}
}

func (s *DropTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropTableStatement() (localctx IDropTableStatementContext) {
	localctx = NewDropTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, DorisSQLParserRULE_dropTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1705)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1707)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserTEMPORARY {
		{
			p.SetState(1706)
			p.Match(DorisSQLParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1709)
		p.Match(DorisSQLParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1712)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(1710)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1711)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1714)
		p.QualifiedName()
	}
	p.SetState(1716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFORCE {
		{
			p.SetState(1715)
			p.Match(DorisSQLParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICleanTemporaryTableStatementContext is an interface to support dynamic dispatch.
type ICleanTemporaryTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLEAN() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	ON() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	String_() IStringContext

	// IsCleanTemporaryTableStatementContext differentiates from other interfaces.
	IsCleanTemporaryTableStatementContext()
}

type CleanTemporaryTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCleanTemporaryTableStatementContext() *CleanTemporaryTableStatementContext {
	var p = new(CleanTemporaryTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cleanTemporaryTableStatement
	return p
}

func InitEmptyCleanTemporaryTableStatementContext(p *CleanTemporaryTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cleanTemporaryTableStatement
}

func (*CleanTemporaryTableStatementContext) IsCleanTemporaryTableStatementContext() {}

func NewCleanTemporaryTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CleanTemporaryTableStatementContext {
	var p = new(CleanTemporaryTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_cleanTemporaryTableStatement

	return p
}

func (s *CleanTemporaryTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CleanTemporaryTableStatementContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCLEAN, 0)
}

func (s *CleanTemporaryTableStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTEMPORARY, 0)
}

func (s *CleanTemporaryTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *CleanTemporaryTableStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *CleanTemporaryTableStatementContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSESSION, 0)
}

func (s *CleanTemporaryTableStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CleanTemporaryTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CleanTemporaryTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CleanTemporaryTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCleanTemporaryTableStatement(s)
	}
}

func (s *CleanTemporaryTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCleanTemporaryTableStatement(s)
	}
}

func (s *CleanTemporaryTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCleanTemporaryTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CleanTemporaryTableStatement() (localctx ICleanTemporaryTableStatementContext) {
	localctx = NewCleanTemporaryTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, DorisSQLParserRULE_cleanTemporaryTableStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1718)
		p.Match(DorisSQLParserCLEAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1719)
		p.Match(DorisSQLParserTEMPORARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1720)
		p.Match(DorisSQLParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1721)
		p.Match(DorisSQLParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1722)
		p.Match(DorisSQLParserSESSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1723)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableStatementContext is an interface to support dynamic dispatch.
type IAlterTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AllAlterClause() []IAlterClauseContext
	AlterClause(i int) IAlterClauseContext
	ADD() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	AllRollupItem() []IRollupItemContext
	RollupItem(i int) IRollupItemContext
	DROP() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsAlterTableStatementContext differentiates from other interfaces.
	IsAlterTableStatementContext()
}

type AlterTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableStatementContext() *AlterTableStatementContext {
	var p = new(AlterTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterTableStatement
	return p
}

func InitEmptyAlterTableStatementContext(p *AlterTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterTableStatement
}

func (*AlterTableStatementContext) IsAlterTableStatementContext() {}

func NewAlterTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableStatementContext {
	var p = new(AlterTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_alterTableStatement

	return p
}

func (s *AlterTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *AlterTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *AlterTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterTableStatementContext) AllAlterClause() []IAlterClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterClauseContext); ok {
			len++
		}
	}

	tst := make([]IAlterClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterClauseContext); ok {
			tst[i] = t.(IAlterClauseContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableStatementContext) AlterClause(i int) IAlterClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterClauseContext)
}

func (s *AlterTableStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADD, 0)
}

func (s *AlterTableStatementContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROLLUP, 0)
}

func (s *AlterTableStatementContext) AllRollupItem() []IRollupItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRollupItemContext); ok {
			len++
		}
	}

	tst := make([]IRollupItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRollupItemContext); ok {
			tst[i] = t.(IRollupItemContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableStatementContext) RollupItem(i int) IRollupItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupItemContext)
}

func (s *AlterTableStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *AlterTableStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAlterTableStatement(s)
	}
}

func (s *AlterTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAlterTableStatement(s)
	}
}

func (s *AlterTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAlterTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AlterTableStatement() (localctx IAlterTableStatementContext) {
	localctx = NewAlterTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, DorisSQLParserRULE_alterTableStatement)
	var _la int

	p.SetState(1762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1725)
			p.Match(DorisSQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1726)
			p.Match(DorisSQLParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1727)
			p.QualifiedName()
		}
		{
			p.SetState(1728)
			p.AlterClause()
		}
		p.SetState(1733)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(1729)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1730)
				p.AlterClause()
			}

			p.SetState(1735)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1736)
			p.Match(DorisSQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1737)
			p.Match(DorisSQLParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1738)
			p.QualifiedName()
		}
		{
			p.SetState(1739)
			p.Match(DorisSQLParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1740)
			p.Match(DorisSQLParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1741)
			p.RollupItem()
		}
		p.SetState(1746)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(1742)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1743)
				p.RollupItem()
			}

			p.SetState(1748)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1749)
			p.Match(DorisSQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1750)
			p.Match(DorisSQLParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1751)
			p.QualifiedName()
		}
		{
			p.SetState(1752)
			p.Match(DorisSQLParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1753)
			p.Match(DorisSQLParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1754)
			p.Identifier()
		}
		p.SetState(1759)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(1755)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1756)
				p.Identifier()
			}

			p.SetState(1761)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateIndexStatementContext is an interface to support dynamic dispatch.
type ICreateIndexStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	ON() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IdentifierList() IIdentifierListContext
	Identifier() IIdentifierContext
	IndexType() IIndexTypeContext
	Comment() ICommentContext
	PropertyList() IPropertyListContext

	// IsCreateIndexStatementContext differentiates from other interfaces.
	IsCreateIndexStatementContext()
}

type CreateIndexStatementContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	indexName IIdentifierContext
}

func NewEmptyCreateIndexStatementContext() *CreateIndexStatementContext {
	var p = new(CreateIndexStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createIndexStatement
	return p
}

func InitEmptyCreateIndexStatementContext(p *CreateIndexStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createIndexStatement
}

func (*CreateIndexStatementContext) IsCreateIndexStatementContext() {}

func NewCreateIndexStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateIndexStatementContext {
	var p = new(CreateIndexStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createIndexStatement

	return p
}

func (s *CreateIndexStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateIndexStatementContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *CreateIndexStatementContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *CreateIndexStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateIndexStatementContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINDEX, 0)
}

func (s *CreateIndexStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *CreateIndexStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateIndexStatementContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateIndexStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateIndexStatementContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *CreateIndexStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateIndexStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *CreateIndexStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateIndexStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateIndexStatement(s)
	}
}

func (s *CreateIndexStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateIndexStatement(s)
	}
}

func (s *CreateIndexStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateIndexStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateIndexStatement() (localctx ICreateIndexStatementContext) {
	localctx = NewCreateIndexStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, DorisSQLParserRULE_createIndexStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1764)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1765)
		p.Match(DorisSQLParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1766)

		var _x = p.Identifier()

		localctx.(*CreateIndexStatementContext).indexName = _x
	}
	{
		p.SetState(1767)
		p.Match(DorisSQLParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1768)
		p.QualifiedName()
	}
	{
		p.SetState(1769)
		p.IdentifierList()
	}
	p.SetState(1774)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserUSING {
		{
			p.SetState(1770)
			p.IndexType()
		}
		p.SetState(1772)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__1 {
			{
				p.SetState(1771)
				p.PropertyList()
			}

		}

	}
	p.SetState(1777)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserCOMMENT {
		{
			p.SetState(1776)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropIndexStatementContext is an interface to support dynamic dispatch.
type IDropIndexStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	ON() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	Identifier() IIdentifierContext

	// IsDropIndexStatementContext differentiates from other interfaces.
	IsDropIndexStatementContext()
}

type DropIndexStatementContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	indexName IIdentifierContext
}

func NewEmptyDropIndexStatementContext() *DropIndexStatementContext {
	var p = new(DropIndexStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropIndexStatement
	return p
}

func InitEmptyDropIndexStatementContext(p *DropIndexStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropIndexStatement
}

func (*DropIndexStatementContext) IsDropIndexStatementContext() {}

func NewDropIndexStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropIndexStatementContext {
	var p = new(DropIndexStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropIndexStatement

	return p
}

func (s *DropIndexStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropIndexStatementContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *DropIndexStatementContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *DropIndexStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropIndexStatementContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINDEX, 0)
}

func (s *DropIndexStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *DropIndexStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropIndexStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropIndexStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropIndexStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropIndexStatement(s)
	}
}

func (s *DropIndexStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropIndexStatement(s)
	}
}

func (s *DropIndexStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropIndexStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropIndexStatement() (localctx IDropIndexStatementContext) {
	localctx = NewDropIndexStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, DorisSQLParserRULE_dropIndexStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1779)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1780)
		p.Match(DorisSQLParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1781)

		var _x = p.Identifier()

		localctx.(*DropIndexStatementContext).indexName = _x
	}
	{
		p.SetState(1782)
		p.Match(DorisSQLParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1783)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexTypeContext is an interface to support dynamic dispatch.
type IIndexTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USING() antlr.TerminalNode
	BITMAP() antlr.TerminalNode
	GIN() antlr.TerminalNode
	NGRAMBF() antlr.TerminalNode
	VECTOR() antlr.TerminalNode

	// IsIndexTypeContext differentiates from other interfaces.
	IsIndexTypeContext()
}

type IndexTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexTypeContext() *IndexTypeContext {
	var p = new(IndexTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_indexType
	return p
}

func InitEmptyIndexTypeContext(p *IndexTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_indexType
}

func (*IndexTypeContext) IsIndexTypeContext() {}

func NewIndexTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexTypeContext {
	var p = new(IndexTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_indexType

	return p
}

func (s *IndexTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexTypeContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSING, 0)
}

func (s *IndexTypeContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBITMAP, 0)
}

func (s *IndexTypeContext) GIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGIN, 0)
}

func (s *IndexTypeContext) NGRAMBF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNGRAMBF, 0)
}

func (s *IndexTypeContext) VECTOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVECTOR, 0)
}

func (s *IndexTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterIndexType(s)
	}
}

func (s *IndexTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitIndexType(s)
	}
}

func (s *IndexTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitIndexType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) IndexType() (localctx IIndexTypeContext) {
	localctx = NewIndexTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, DorisSQLParserRULE_indexType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1785)
		p.Match(DorisSQLParserUSING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1786)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserBITMAP || _la == DorisSQLParserGIN || _la == DorisSQLParserNGRAMBF || _la == DorisSQLParserVECTOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowTableStatementContext is an interface to support dynamic dispatch.
type IShowTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	FULL() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowTableStatementContext differentiates from other interfaces.
	IsShowTableStatementContext()
}

type ShowTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	db      IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowTableStatementContext() *ShowTableStatementContext {
	var p = new(ShowTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showTableStatement
	return p
}

func InitEmptyShowTableStatementContext(p *ShowTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showTableStatement
}

func (*ShowTableStatementContext) IsShowTableStatementContext() {}

func NewShowTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTableStatementContext {
	var p = new(ShowTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showTableStatement

	return p
}

func (s *ShowTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTableStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowTableStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowTableStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowTableStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowTableStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowTableStatementContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLES, 0)
}

func (s *ShowTableStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFULL, 0)
}

func (s *ShowTableStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowTableStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *ShowTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTableStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *ShowTableStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowTableStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowTableStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowTableStatement(s)
	}
}

func (s *ShowTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowTableStatement(s)
	}
}

func (s *ShowTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowTableStatement() (localctx IShowTableStatementContext) {
	localctx = NewShowTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, DorisSQLParserRULE_showTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1788)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1790)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFULL {
		{
			p.SetState(1789)
			p.Match(DorisSQLParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1792)
		p.Match(DorisSQLParserTABLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1795)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM || _la == DorisSQLParserIN {
		{
			p.SetState(1793)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1794)

			var _x = p.QualifiedName()

			localctx.(*ShowTableStatementContext).db = _x
		}

	}
	p.SetState(1801)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserLIKE:
		{
			p.SetState(1797)
			p.Match(DorisSQLParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1798)

			var _x = p.String_()

			localctx.(*ShowTableStatementContext).pattern = _x
		}

	case DorisSQLParserWHERE:
		{
			p.SetState(1799)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1800)
			p.expression(0)
		}

	case DorisSQLParserEOF, DorisSQLParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowTemporaryTablesStatementContext is an interface to support dynamic dispatch.
type IShowTemporaryTablesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowTemporaryTablesStatementContext differentiates from other interfaces.
	IsShowTemporaryTablesStatementContext()
}

type ShowTemporaryTablesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	db      IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowTemporaryTablesStatementContext() *ShowTemporaryTablesStatementContext {
	var p = new(ShowTemporaryTablesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showTemporaryTablesStatement
	return p
}

func InitEmptyShowTemporaryTablesStatementContext(p *ShowTemporaryTablesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showTemporaryTablesStatement
}

func (*ShowTemporaryTablesStatementContext) IsShowTemporaryTablesStatementContext() {}

func NewShowTemporaryTablesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTemporaryTablesStatementContext {
	var p = new(ShowTemporaryTablesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showTemporaryTablesStatement

	return p
}

func (s *ShowTemporaryTablesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTemporaryTablesStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowTemporaryTablesStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowTemporaryTablesStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowTemporaryTablesStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowTemporaryTablesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowTemporaryTablesStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTEMPORARY, 0)
}

func (s *ShowTemporaryTablesStatementContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLES, 0)
}

func (s *ShowTemporaryTablesStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowTemporaryTablesStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *ShowTemporaryTablesStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTemporaryTablesStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *ShowTemporaryTablesStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowTemporaryTablesStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowTemporaryTablesStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowTemporaryTablesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTemporaryTablesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowTemporaryTablesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowTemporaryTablesStatement(s)
	}
}

func (s *ShowTemporaryTablesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowTemporaryTablesStatement(s)
	}
}

func (s *ShowTemporaryTablesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowTemporaryTablesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowTemporaryTablesStatement() (localctx IShowTemporaryTablesStatementContext) {
	localctx = NewShowTemporaryTablesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, DorisSQLParserRULE_showTemporaryTablesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1803)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1804)
		p.Match(DorisSQLParserTEMPORARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1805)
		p.Match(DorisSQLParserTABLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1808)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM || _la == DorisSQLParserIN {
		{
			p.SetState(1806)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1807)

			var _x = p.QualifiedName()

			localctx.(*ShowTemporaryTablesStatementContext).db = _x
		}

	}
	p.SetState(1814)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserLIKE:
		{
			p.SetState(1810)
			p.Match(DorisSQLParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1811)

			var _x = p.String_()

			localctx.(*ShowTemporaryTablesStatementContext).pattern = _x
		}

	case DorisSQLParserWHERE:
		{
			p.SetState(1812)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1813)
			p.expression(0)
		}

	case DorisSQLParserEOF, DorisSQLParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCreateTableStatementContext is an interface to support dynamic dispatch.
type IShowCreateTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	TABLE() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode

	// IsShowCreateTableStatementContext differentiates from other interfaces.
	IsShowCreateTableStatementContext()
}

type ShowCreateTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	table  IQualifiedNameContext
}

func NewEmptyShowCreateTableStatementContext() *ShowCreateTableStatementContext {
	var p = new(ShowCreateTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showCreateTableStatement
	return p
}

func InitEmptyShowCreateTableStatementContext(p *ShowCreateTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showCreateTableStatement
}

func (*ShowCreateTableStatementContext) IsShowCreateTableStatementContext() {}

func NewShowCreateTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCreateTableStatementContext {
	var p = new(ShowCreateTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showCreateTableStatement

	return p
}

func (s *ShowCreateTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCreateTableStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *ShowCreateTableStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *ShowCreateTableStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowCreateTableStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *ShowCreateTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCreateTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *ShowCreateTableStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVIEW, 0)
}

func (s *ShowCreateTableStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMATERIALIZED, 0)
}

func (s *ShowCreateTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCreateTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowCreateTableStatement(s)
	}
}

func (s *ShowCreateTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowCreateTableStatement(s)
	}
}

func (s *ShowCreateTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowCreateTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowCreateTableStatement() (localctx IShowCreateTableStatementContext) {
	localctx = NewShowCreateTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, DorisSQLParserRULE_showCreateTableStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1816)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1817)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1822)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserTABLE:
		{
			p.SetState(1818)
			p.Match(DorisSQLParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserVIEW:
		{
			p.SetState(1819)
			p.Match(DorisSQLParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserMATERIALIZED:
		{
			p.SetState(1820)
			p.Match(DorisSQLParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1821)
			p.Match(DorisSQLParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1824)

		var _x = p.QualifiedName()

		localctx.(*ShowCreateTableStatementContext).table = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowColumnStatementContext is an interface to support dynamic dispatch.
type IShowColumnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	FULL() antlr.TerminalNode
	AllFROM() []antlr.TerminalNode
	FROM(i int) antlr.TerminalNode
	AllIN() []antlr.TerminalNode
	IN(i int) antlr.TerminalNode
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowColumnStatementContext differentiates from other interfaces.
	IsShowColumnStatementContext()
}

type ShowColumnStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	table   IQualifiedNameContext
	db      IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowColumnStatementContext() *ShowColumnStatementContext {
	var p = new(ShowColumnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showColumnStatement
	return p
}

func InitEmptyShowColumnStatementContext(p *ShowColumnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showColumnStatement
}

func (*ShowColumnStatementContext) IsShowColumnStatementContext() {}

func NewShowColumnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowColumnStatementContext {
	var p = new(ShowColumnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showColumnStatement

	return p
}

func (s *ShowColumnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowColumnStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *ShowColumnStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowColumnStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowColumnStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *ShowColumnStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowColumnStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowColumnStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowColumnStatementContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLUMNS, 0)
}

func (s *ShowColumnStatementContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFIELDS, 0)
}

func (s *ShowColumnStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFULL, 0)
}

func (s *ShowColumnStatementContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserFROM)
}

func (s *ShowColumnStatementContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, i)
}

func (s *ShowColumnStatementContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserIN)
}

func (s *ShowColumnStatementContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, i)
}

func (s *ShowColumnStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *ShowColumnStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowColumnStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *ShowColumnStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowColumnStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowColumnStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowColumnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowColumnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowColumnStatement(s)
	}
}

func (s *ShowColumnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowColumnStatement(s)
	}
}

func (s *ShowColumnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowColumnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowColumnStatement() (localctx IShowColumnStatementContext) {
	localctx = NewShowColumnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, DorisSQLParserRULE_showColumnStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1826)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1828)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFULL {
		{
			p.SetState(1827)
			p.Match(DorisSQLParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1830)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserCOLUMNS || _la == DorisSQLParserFIELDS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	{
		p.SetState(1831)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1832)

		var _x = p.QualifiedName()

		localctx.(*ShowColumnStatementContext).table = _x
	}

	p.SetState(1836)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM || _la == DorisSQLParserIN {
		{
			p.SetState(1834)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1835)

			var _x = p.QualifiedName()

			localctx.(*ShowColumnStatementContext).db = _x
		}

	}
	p.SetState(1842)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserLIKE:
		{
			p.SetState(1838)
			p.Match(DorisSQLParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1839)

			var _x = p.String_()

			localctx.(*ShowColumnStatementContext).pattern = _x
		}

	case DorisSQLParserWHERE:
		{
			p.SetState(1840)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1841)
			p.expression(0)
		}

	case DorisSQLParserEOF, DorisSQLParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowTableStatusStatementContext is an interface to support dynamic dispatch.
type IShowTableStatusStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowTableStatusStatementContext differentiates from other interfaces.
	IsShowTableStatusStatementContext()
}

type ShowTableStatusStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	db      IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowTableStatusStatementContext() *ShowTableStatusStatementContext {
	var p = new(ShowTableStatusStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showTableStatusStatement
	return p
}

func InitEmptyShowTableStatusStatementContext(p *ShowTableStatusStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showTableStatusStatement
}

func (*ShowTableStatusStatementContext) IsShowTableStatusStatementContext() {}

func NewShowTableStatusStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTableStatusStatementContext {
	var p = new(ShowTableStatusStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showTableStatusStatement

	return p
}

func (s *ShowTableStatusStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTableStatusStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowTableStatusStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowTableStatusStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowTableStatusStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowTableStatusStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowTableStatusStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *ShowTableStatusStatementContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTATUS, 0)
}

func (s *ShowTableStatusStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowTableStatusStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *ShowTableStatusStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTableStatusStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *ShowTableStatusStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowTableStatusStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowTableStatusStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowTableStatusStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTableStatusStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowTableStatusStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowTableStatusStatement(s)
	}
}

func (s *ShowTableStatusStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowTableStatusStatement(s)
	}
}

func (s *ShowTableStatusStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowTableStatusStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowTableStatusStatement() (localctx IShowTableStatusStatementContext) {
	localctx = NewShowTableStatusStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, DorisSQLParserRULE_showTableStatusStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1844)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1845)
		p.Match(DorisSQLParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1846)
		p.Match(DorisSQLParserSTATUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1849)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM || _la == DorisSQLParserIN {
		{
			p.SetState(1847)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1848)

			var _x = p.QualifiedName()

			localctx.(*ShowTableStatusStatementContext).db = _x
		}

	}
	p.SetState(1855)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserLIKE:
		{
			p.SetState(1851)
			p.Match(DorisSQLParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1852)

			var _x = p.String_()

			localctx.(*ShowTableStatusStatementContext).pattern = _x
		}

	case DorisSQLParserWHERE:
		{
			p.SetState(1853)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1854)
			p.expression(0)
		}

	case DorisSQLParserEOF, DorisSQLParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshTableStatementContext is an interface to support dynamic dispatch.
type IRefreshTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REFRESH() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PARTITION() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsRefreshTableStatementContext differentiates from other interfaces.
	IsRefreshTableStatementContext()
}

type RefreshTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefreshTableStatementContext() *RefreshTableStatementContext {
	var p = new(RefreshTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_refreshTableStatement
	return p
}

func InitEmptyRefreshTableStatementContext(p *RefreshTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_refreshTableStatement
}

func (*RefreshTableStatementContext) IsRefreshTableStatementContext() {}

func NewRefreshTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshTableStatementContext {
	var p = new(RefreshTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_refreshTableStatement

	return p
}

func (s *RefreshTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshTableStatementContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREFRESH, 0)
}

func (s *RefreshTableStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXTERNAL, 0)
}

func (s *RefreshTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *RefreshTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RefreshTableStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPARTITION, 0)
}

func (s *RefreshTableStatementContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *RefreshTableStatementContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *RefreshTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRefreshTableStatement(s)
	}
}

func (s *RefreshTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRefreshTableStatement(s)
	}
}

func (s *RefreshTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRefreshTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) RefreshTableStatement() (localctx IRefreshTableStatementContext) {
	localctx = NewRefreshTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, DorisSQLParserRULE_refreshTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1857)
		p.Match(DorisSQLParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1858)
		p.Match(DorisSQLParserEXTERNAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1859)
		p.Match(DorisSQLParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1860)
		p.QualifiedName()
	}
	p.SetState(1873)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPARTITION {
		{
			p.SetState(1861)
			p.Match(DorisSQLParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1862)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1863)
			p.String_()
		}
		p.SetState(1868)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(1864)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1865)
				p.String_()
			}

			p.SetState(1870)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1871)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowAlterStatementContext is an interface to support dynamic dispatch.
type IShowAlterStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	OPTIMIZE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode

	// IsShowAlterStatementContext differentiates from other interfaces.
	IsShowAlterStatementContext()
}

type ShowAlterStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
}

func NewEmptyShowAlterStatementContext() *ShowAlterStatementContext {
	var p = new(ShowAlterStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showAlterStatement
	return p
}

func InitEmptyShowAlterStatementContext(p *ShowAlterStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showAlterStatement
}

func (*ShowAlterStatementContext) IsShowAlterStatementContext() {}

func NewShowAlterStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowAlterStatementContext {
	var p = new(ShowAlterStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showAlterStatement

	return p
}

func (s *ShowAlterStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowAlterStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowAlterStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowAlterStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowAlterStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *ShowAlterStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *ShowAlterStatementContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLUMN, 0)
}

func (s *ShowAlterStatementContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROLLUP, 0)
}

func (s *ShowAlterStatementContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOPTIMIZE, 0)
}

func (s *ShowAlterStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowAlterStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowAlterStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserORDER, 0)
}

func (s *ShowAlterStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *ShowAlterStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowAlterStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowAlterStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowAlterStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowAlterStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *ShowAlterStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowAlterStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMATERIALIZED, 0)
}

func (s *ShowAlterStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVIEW, 0)
}

func (s *ShowAlterStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAlterStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowAlterStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowAlterStatement(s)
	}
}

func (s *ShowAlterStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowAlterStatement(s)
	}
}

func (s *ShowAlterStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowAlterStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowAlterStatement() (localctx IShowAlterStatementContext) {
	localctx = NewShowAlterStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, DorisSQLParserRULE_showAlterStatement)
	var _la int

	p.SetState(1929)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1875)
			p.Match(DorisSQLParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1876)
			p.Match(DorisSQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1877)
			p.Match(DorisSQLParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1878)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserCOLUMN || _la == DorisSQLParserOPTIMIZE || _la == DorisSQLParserROLLUP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1881)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserFROM || _la == DorisSQLParserIN {
			{
				p.SetState(1879)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1880)

				var _x = p.QualifiedName()

				localctx.(*ShowAlterStatementContext).db = _x
			}

		}
		p.SetState(1885)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserWHERE {
			{
				p.SetState(1883)
				p.Match(DorisSQLParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1884)
				p.expression(0)
			}

		}
		p.SetState(1897)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserORDER {
			{
				p.SetState(1887)
				p.Match(DorisSQLParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1888)
				p.Match(DorisSQLParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1889)
				p.SortItem()
			}
			p.SetState(1894)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(1890)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1891)
					p.SortItem()
				}

				p.SetState(1896)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(1900)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserLIMIT {
			{
				p.SetState(1899)
				p.LimitElement()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1902)
			p.Match(DorisSQLParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1903)
			p.Match(DorisSQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1904)
			p.Match(DorisSQLParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1905)
			p.Match(DorisSQLParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1908)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserFROM || _la == DorisSQLParserIN {
			{
				p.SetState(1906)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1907)

				var _x = p.QualifiedName()

				localctx.(*ShowAlterStatementContext).db = _x
			}

		}
		p.SetState(1912)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserWHERE {
			{
				p.SetState(1910)
				p.Match(DorisSQLParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1911)
				p.expression(0)
			}

		}
		p.SetState(1924)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserORDER {
			{
				p.SetState(1914)
				p.Match(DorisSQLParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1915)
				p.Match(DorisSQLParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1916)
				p.SortItem()
			}
			p.SetState(1921)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(1917)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1918)
					p.SortItem()
				}

				p.SetState(1923)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(1927)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserLIMIT {
			{
				p.SetState(1926)
				p.LimitElement()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescTableStatementContext is an interface to support dynamic dispatch.
type IDescTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// Getter signatures
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	FILES() antlr.TerminalNode
	PropertyList() IPropertyListContext
	QualifiedName() IQualifiedNameContext
	ALL() antlr.TerminalNode

	// IsDescTableStatementContext differentiates from other interfaces.
	IsDescTableStatementContext()
}

type DescTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	table  IQualifiedNameContext
}

func NewEmptyDescTableStatementContext() *DescTableStatementContext {
	var p = new(DescTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_descTableStatement
	return p
}

func InitEmptyDescTableStatementContext(p *DescTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_descTableStatement
}

func (*DescTableStatementContext) IsDescTableStatementContext() {}

func NewDescTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescTableStatementContext {
	var p = new(DescTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_descTableStatement

	return p
}

func (s *DescTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DescTableStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *DescTableStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *DescTableStatementContext) DESC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDESC, 0)
}

func (s *DescTableStatementContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDESCRIBE, 0)
}

func (s *DescTableStatementContext) FILES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFILES, 0)
}

func (s *DescTableStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *DescTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DescTableStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, 0)
}

func (s *DescTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDescTableStatement(s)
	}
}

func (s *DescTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDescTableStatement(s)
	}
}

func (s *DescTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDescTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DescTableStatement() (localctx IDescTableStatementContext) {
	localctx = NewDescTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, DorisSQLParserRULE_descTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1931)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserDESC || _la == DorisSQLParserDESCRIBE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1938)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserACCESS, DorisSQLParserACTIVE, DorisSQLParserADMIN, DorisSQLParserADVISOR, DorisSQLParserAFTER, DorisSQLParserAGGREGATE, DorisSQLParserANTI, DorisSQLParserAPPLY, DorisSQLParserARRAY_AGG, DorisSQLParserARRAY_AGG_DISTINCT, DorisSQLParserASYNC, DorisSQLParserAUTHORS, DorisSQLParserAUTHENTICATION, DorisSQLParserAUTOMATED, DorisSQLParserAUTO_INCREMENT, DorisSQLParserAVG, DorisSQLParserBACKEND, DorisSQLParserBACKENDS, DorisSQLParserBACKUP, DorisSQLParserBASE, DorisSQLParserBASELINE, DorisSQLParserBEGIN, DorisSQLParserBINARY, DorisSQLParserBITMAP_UNION, DorisSQLParserBLACKHOLE, DorisSQLParserBLACKLIST, DorisSQLParserBODY, DorisSQLParserBOOLEAN, DorisSQLParserBRANCH, DorisSQLParserBROKER, DorisSQLParserBUCKETS, DorisSQLParserBUILTIN, DorisSQLParserCACHE, DorisSQLParserCANCEL, DorisSQLParserCAST, DorisSQLParserCATALOG, DorisSQLParserCATALOGS, DorisSQLParserCEIL, DorisSQLParserCHAIN, DorisSQLParserCHARSET, DorisSQLParserCLEAN, DorisSQLParserCLEAR, DorisSQLParserCLUSTER, DorisSQLParserCLUSTERS, DorisSQLParserCNGROUP, DorisSQLParserCNGROUPS, DorisSQLParserCOLLATION, DorisSQLParserCOLUMNS, DorisSQLParserCOMMENT, DorisSQLParserCOMMIT, DorisSQLParserCOMMITTED, DorisSQLParserCOMPACT, DorisSQLParserCOMPUTE, DorisSQLParserCONFIG, DorisSQLParserCONNECTION, DorisSQLParserCONSISTENT, DorisSQLParserCOSTS, DorisSQLParserCOUNT, DorisSQLParserCUME_DIST, DorisSQLParserCUMULATIVE, DorisSQLParserCURRENT, DorisSQLParserDATA, DorisSQLParserDATACACHE, DorisSQLParserDATE, DorisSQLParserDATETIME, DorisSQLParserDAY, DorisSQLParserDAYS, DorisSQLParserDEALLOCATE, DorisSQLParserDECOMMISSION, DorisSQLParserDIALECT, DorisSQLParserDICTIONARY, DorisSQLParserDICTIONARY_GET, DorisSQLParserDISABLE, DorisSQLParserDISTRIBUTED, DorisSQLParserDISTRIBUTION, DorisSQLParserDUPLICATE, DorisSQLParserDYNAMIC, DorisSQLParserENABLE, DorisSQLParserENCLOSE, DorisSQLParserEND, DorisSQLParserENGINE, DorisSQLParserENGINES, DorisSQLParserERRORS, DorisSQLParserESCAPE, DorisSQLParserEVENTS, DorisSQLParserEXCEPT, DorisSQLParserEXCLUDE, DorisSQLParserEXECUTE, DorisSQLParserEXPORT, DorisSQLParserEXTERNAL, DorisSQLParserEXTRACT, DorisSQLParserEVERY, DorisSQLParserFAILPOINT, DorisSQLParserFAILPOINTS, DorisSQLParserFIELDS, DorisSQLParserFILE, DorisSQLParserFILTER, DorisSQLParserFIRST, DorisSQLParserFLOOR, DorisSQLParserFN, DorisSQLParserFOLLOWING, DorisSQLParserFOLLOWER, DorisSQLParserFORMAT, DorisSQLParserFREE, DorisSQLParserFRONTEND, DorisSQLParserFRONTENDS, DorisSQLParserFUNCTIONS, DorisSQLParserGLOBAL, DorisSQLParserGRANTS, DorisSQLParserGROUP_CONCAT, DorisSQLParserHASH, DorisSQLParserHELP, DorisSQLParserHISTOGRAM, DorisSQLParserHLL_UNION, DorisSQLParserHOST, DorisSQLParserHOUR, DorisSQLParserHOURS, DorisSQLParserHUB, DorisSQLParserIDENTIFIED, DorisSQLParserIMPERSONATE, DorisSQLParserIMAGE, DorisSQLParserINACTIVE, DorisSQLParserINCREMENTAL, DorisSQLParserINDEXES, DorisSQLParserINSTALL, DorisSQLParserINTEGRATION, DorisSQLParserINTEGRATIONS, DorisSQLParserINTERMEDIATE, DorisSQLParserINTERVAL, DorisSQLParserOVERWRITE, DorisSQLParserISOLATION, DorisSQLParserJOB, DorisSQLParserLABEL, DorisSQLParserLAST, DorisSQLParserLESS, DorisSQLParserLEVEL, DorisSQLParserLIST, DorisSQLParserLOCAL, DorisSQLParserLOCATION, DorisSQLParserLOCATIONS, DorisSQLParserLOGS, DorisSQLParserLOGICAL, DorisSQLParserMANUAL, DorisSQLParserMAP, DorisSQLParserMAPPING, DorisSQLParserMAPPINGS, DorisSQLParserMASKING, DorisSQLParserMATCH, DorisSQLParserMATERIALIZED, DorisSQLParserMAX, DorisSQLParserMERGE, DorisSQLParserMIN, DorisSQLParserMINUTE, DorisSQLParserMINUTES, DorisSQLParserMINUS, DorisSQLParserMETA, DorisSQLParserMODE, DorisSQLParserMODIFY, DorisSQLParserMONTH, DorisSQLParserMULTIPLE, DorisSQLParserNAME, DorisSQLParserNAMES, DorisSQLParserNEGATIVE, DorisSQLParserNGRAMBF, DorisSQLParserNO, DorisSQLParserNODE, DorisSQLParserNODES, DorisSQLParserNONE, DorisSQLParserNULLS, DorisSQLParserNUMBER, DorisSQLParserNUMERIC, DorisSQLParserOBSERVER, DorisSQLParserOF, DorisSQLParserOFF, DorisSQLParserOFFSET, DorisSQLParserONLY, DorisSQLParserOPEN, DorisSQLParserOPERATE, DorisSQLParserOPTIMIZER, DorisSQLParserOPTION, DorisSQLParserPARTITIONS, DorisSQLParserPASSWORD, DorisSQLParserPATH, DorisSQLParserPAUSE, DorisSQLParserPENDING, DorisSQLParserPERCENT_RANK, DorisSQLParserPERCENTILE_UNION, DorisSQLParserPLAN, DorisSQLParserPLUGIN, DorisSQLParserPLUGINS, DorisSQLParserPIPE, DorisSQLParserPIPES, DorisSQLParserPIVOT, DorisSQLParserPOLICY, DorisSQLParserPOLICIES, DorisSQLParserPRECEDING, DorisSQLParserPREDICATE, DorisSQLParserPRIORITY, DorisSQLParserPRIVILEGES, DorisSQLParserPROBABILITY, DorisSQLParserPROC, DorisSQLParserPROCESSLIST, DorisSQLParserPROFILE, DorisSQLParserPROFILELIST, DorisSQLParserPROPERTIES, DorisSQLParserPROPERTY, DorisSQLParserPROVIDER, DorisSQLParserPROVIDERS, DorisSQLParserQUALIFY, DorisSQLParserQUARTER, DorisSQLParserQUERY, DorisSQLParserQUERIES, DorisSQLParserQUEUE, DorisSQLParserQUOTA, DorisSQLParserRANDOM, DorisSQLParserRANK, DorisSQLParserREASON, DorisSQLParserRECOVER, DorisSQLParserREFRESH, DorisSQLParserREWRITE, DorisSQLParserREMOVE, DorisSQLParserREPAIR, DorisSQLParserREPEATABLE, DorisSQLParserREPLACE_IF_NOT_NULL, DorisSQLParserREPLICA, DorisSQLParserREPOSITORY, DorisSQLParserREPOSITORIES, DorisSQLParserRESOURCE, DorisSQLParserRESOURCES, DorisSQLParserRESTORE, DorisSQLParserRESUME, DorisSQLParserRETAIN, DorisSQLParserRETENTION, DorisSQLParserRETURNS, DorisSQLParserRETRY, DorisSQLParserREVERT, DorisSQLParserROLE, DorisSQLParserROLES, DorisSQLParserROLLBACK, DorisSQLParserROLLUP, DorisSQLParserROUTINE, DorisSQLParserROW, DorisSQLParserRULE, DorisSQLParserRULES, DorisSQLParserRUNNING, DorisSQLParserSAMPLE, DorisSQLParserSCHEDULE, DorisSQLParserSCHEDULER, DorisSQLParserSECOND, DorisSQLParserSECURITY, DorisSQLParserSEMI, DorisSQLParserSEPARATOR, DorisSQLParserSERIALIZABLE, DorisSQLParserSESSION, DorisSQLParserSETS, DorisSQLParserSIGNED, DorisSQLParserSKIP_HEADER, DorisSQLParserSNAPSHOT, DorisSQLParserSNAPSHOTS, DorisSQLParserSQLBLACKLIST, DorisSQLParserSTART, DorisSQLParserSTATS, DorisSQLParserSTATUS, DorisSQLParserSTOP, DorisSQLParserSTORAGE, DorisSQLParserSTREAM, DorisSQLParserSTRING, DorisSQLParserSUBMIT, DorisSQLParserSUM, DorisSQLParserSUSPEND, DorisSQLParserSYNC, DorisSQLParserSYSTEM_TIME, DorisSQLParserSWAP, DorisSQLParserSTRUCT, DorisSQLParserTABLES, DorisSQLParserTABLET, DorisSQLParserTABLETS, DorisSQLParserTAG, DorisSQLParserTASK, DorisSQLParserTEMPORARY, DorisSQLParserTHAN, DorisSQLParserTIME, DorisSQLParserTIMES, DorisSQLParserTIMESTAMP, DorisSQLParserTIMESTAMPADD, DorisSQLParserTIMESTAMPDIFF, DorisSQLParserTRANSACTION, DorisSQLParserTRANSLATE, DorisSQLParserTRACE, DorisSQLParserTRIGGERS, DorisSQLParserTRIM_SPACE, DorisSQLParserTRUNCATE, DorisSQLParserTYPE, DorisSQLParserTYPES, DorisSQLParserUNBOUNDED, DorisSQLParserUNCOMMITTED, DorisSQLParserUNINSTALL, DorisSQLParserUNSET, DorisSQLParserUSAGE, DorisSQLParserUSER, DorisSQLParserUSERS, DorisSQLParserVALUE, DorisSQLParserVARBINARY, DorisSQLParserVARIABLES, DorisSQLParserVECTOR, DorisSQLParserVERBOSE, DorisSQLParserVERSION, DorisSQLParserVIEW, DorisSQLParserVIEWS, DorisSQLParserVOLUME, DorisSQLParserVOLUMES, DorisSQLParserWAREHOUSE, DorisSQLParserWAREHOUSES, DorisSQLParserWARNINGS, DorisSQLParserWEEK, DorisSQLParserWHITELIST, DorisSQLParserWORK, DorisSQLParserWRITE, DorisSQLParserYEAR, DorisSQLParserLOCK, DorisSQLParserUNLOCK, DorisSQLParserLOW_PRIORITY, DorisSQLParserDISK, DorisSQLParserBEFORE, DorisSQLParserFIELD, DorisSQLParserPERSISTENT, DorisSQLParserARRAY_ELEMENT, DorisSQLParserLETTER_IDENTIFIER, DorisSQLParserDIGIT_IDENTIFIER, DorisSQLParserBACKQUOTED_IDENTIFIER, DorisSQLParserDOTDOTDOT:
		{
			p.SetState(1932)

			var _x = p.QualifiedName()

			localctx.(*DescTableStatementContext).table = _x
		}
		p.SetState(1934)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserALL {
			{
				p.SetState(1933)
				p.Match(DorisSQLParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DorisSQLParserFILES:
		{
			p.SetState(1936)
			p.Match(DorisSQLParserFILES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1937)
			p.PropertyList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableLikeStatementContext is an interface to support dynamic dispatch.
type ICreateTableLikeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	LIKE() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	PartitionDesc() IPartitionDescContext
	DistributionDesc() IDistributionDescContext
	Properties() IPropertiesContext
	TEMPORARY() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode

	// IsCreateTableLikeStatementContext differentiates from other interfaces.
	IsCreateTableLikeStatementContext()
}

type CreateTableLikeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableLikeStatementContext() *CreateTableLikeStatementContext {
	var p = new(CreateTableLikeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createTableLikeStatement
	return p
}

func InitEmptyCreateTableLikeStatementContext(p *CreateTableLikeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createTableLikeStatement
}

func (*CreateTableLikeStatementContext) IsCreateTableLikeStatementContext() {}

func NewCreateTableLikeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableLikeStatementContext {
	var p = new(CreateTableLikeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createTableLikeStatement

	return p
}

func (s *CreateTableLikeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableLikeStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateTableLikeStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *CreateTableLikeStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableLikeStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateTableLikeStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *CreateTableLikeStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *CreateTableLikeStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *CreateTableLikeStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *CreateTableLikeStatementContext) PartitionDesc() IPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDescContext)
}

func (s *CreateTableLikeStatementContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *CreateTableLikeStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateTableLikeStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTEMPORARY, 0)
}

func (s *CreateTableLikeStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXTERNAL, 0)
}

func (s *CreateTableLikeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableLikeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableLikeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateTableLikeStatement(s)
	}
}

func (s *CreateTableLikeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateTableLikeStatement(s)
	}
}

func (s *CreateTableLikeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateTableLikeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateTableLikeStatement() (localctx ICreateTableLikeStatementContext) {
	localctx = NewCreateTableLikeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, DorisSQLParserRULE_createTableLikeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1940)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1942)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserEXTERNAL || _la == DorisSQLParserTEMPORARY {
		{
			p.SetState(1941)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserEXTERNAL || _la == DorisSQLParserTEMPORARY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1944)
		p.Match(DorisSQLParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1948)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(1945)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1946)
			p.Match(DorisSQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1947)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1950)
		p.QualifiedName()
	}
	p.SetState(1952)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPARTITION {
		{
			p.SetState(1951)
			p.PartitionDesc()
		}

	}
	p.SetState(1955)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserDISTRIBUTED {
		{
			p.SetState(1954)
			p.DistributionDesc()
		}

	}
	p.SetState(1958)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(1957)
			p.Properties()
		}

	}
	{
		p.SetState(1960)
		p.Match(DorisSQLParserLIKE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1961)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowIndexStatementContext is an interface to support dynamic dispatch.
type IShowIndexStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	INDEXES() antlr.TerminalNode
	KEY() antlr.TerminalNode
	KEYS() antlr.TerminalNode
	AllFROM() []antlr.TerminalNode
	FROM(i int) antlr.TerminalNode
	AllIN() []antlr.TerminalNode
	IN(i int) antlr.TerminalNode
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext

	// IsShowIndexStatementContext differentiates from other interfaces.
	IsShowIndexStatementContext()
}

type ShowIndexStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	table  IQualifiedNameContext
	db     IQualifiedNameContext
}

func NewEmptyShowIndexStatementContext() *ShowIndexStatementContext {
	var p = new(ShowIndexStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showIndexStatement
	return p
}

func InitEmptyShowIndexStatementContext(p *ShowIndexStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showIndexStatement
}

func (*ShowIndexStatementContext) IsShowIndexStatementContext() {}

func NewShowIndexStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowIndexStatementContext {
	var p = new(ShowIndexStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showIndexStatement

	return p
}

func (s *ShowIndexStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowIndexStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *ShowIndexStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowIndexStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *ShowIndexStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowIndexStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowIndexStatementContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINDEX, 0)
}

func (s *ShowIndexStatementContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINDEXES, 0)
}

func (s *ShowIndexStatementContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserKEY, 0)
}

func (s *ShowIndexStatementContext) KEYS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserKEYS, 0)
}

func (s *ShowIndexStatementContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserFROM)
}

func (s *ShowIndexStatementContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, i)
}

func (s *ShowIndexStatementContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserIN)
}

func (s *ShowIndexStatementContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, i)
}

func (s *ShowIndexStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *ShowIndexStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowIndexStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowIndexStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowIndexStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowIndexStatement(s)
	}
}

func (s *ShowIndexStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowIndexStatement(s)
	}
}

func (s *ShowIndexStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowIndexStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowIndexStatement() (localctx IShowIndexStatementContext) {
	localctx = NewShowIndexStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, DorisSQLParserRULE_showIndexStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1963)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1964)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-205)) & ^0x3f) == 0 && ((int64(1)<<(_la-205))&12582915) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	{
		p.SetState(1965)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1966)

		var _x = p.QualifiedName()

		localctx.(*ShowIndexStatementContext).table = _x
	}

	p.SetState(1970)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM || _la == DorisSQLParserIN {
		{
			p.SetState(1968)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1969)

			var _x = p.QualifiedName()

			localctx.(*ShowIndexStatementContext).db = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecoverTableStatementContext is an interface to support dynamic dispatch.
type IRecoverTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RECOVER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsRecoverTableStatementContext differentiates from other interfaces.
	IsRecoverTableStatementContext()
}

type RecoverTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecoverTableStatementContext() *RecoverTableStatementContext {
	var p = new(RecoverTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_recoverTableStatement
	return p
}

func InitEmptyRecoverTableStatementContext(p *RecoverTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_recoverTableStatement
}

func (*RecoverTableStatementContext) IsRecoverTableStatementContext() {}

func NewRecoverTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecoverTableStatementContext {
	var p = new(RecoverTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_recoverTableStatement

	return p
}

func (s *RecoverTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RecoverTableStatementContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRECOVER, 0)
}

func (s *RecoverTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *RecoverTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RecoverTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecoverTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecoverTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRecoverTableStatement(s)
	}
}

func (s *RecoverTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRecoverTableStatement(s)
	}
}

func (s *RecoverTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRecoverTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) RecoverTableStatement() (localctx IRecoverTableStatementContext) {
	localctx = NewRecoverTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, DorisSQLParserRULE_recoverTableStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1972)
		p.Match(DorisSQLParserRECOVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1973)
		p.Match(DorisSQLParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1974)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITruncateTableStatementContext is an interface to support dynamic dispatch.
type ITruncateTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUNCATE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext

	// IsTruncateTableStatementContext differentiates from other interfaces.
	IsTruncateTableStatementContext()
}

type TruncateTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncateTableStatementContext() *TruncateTableStatementContext {
	var p = new(TruncateTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_truncateTableStatement
	return p
}

func InitEmptyTruncateTableStatementContext(p *TruncateTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_truncateTableStatement
}

func (*TruncateTableStatementContext) IsTruncateTableStatementContext() {}

func NewTruncateTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncateTableStatementContext {
	var p = new(TruncateTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_truncateTableStatement

	return p
}

func (s *TruncateTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncateTableStatementContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTRUNCATE, 0)
}

func (s *TruncateTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *TruncateTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TruncateTableStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *TruncateTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncateTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TruncateTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTruncateTableStatement(s)
	}
}

func (s *TruncateTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTruncateTableStatement(s)
	}
}

func (s *TruncateTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTruncateTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) TruncateTableStatement() (localctx ITruncateTableStatementContext) {
	localctx = NewTruncateTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, DorisSQLParserRULE_truncateTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1976)
		p.Match(DorisSQLParserTRUNCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1977)
		p.Match(DorisSQLParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1978)
		p.QualifiedName()
	}
	p.SetState(1980)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPARTITION || _la == DorisSQLParserPARTITIONS || _la == DorisSQLParserTEMPORARY {
		{
			p.SetState(1979)
			p.PartitionNames()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelAlterTableStatementContext is an interface to support dynamic dispatch.
type ICancelAlterTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	OPTIMIZE() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode

	// IsCancelAlterTableStatementContext differentiates from other interfaces.
	IsCancelAlterTableStatementContext()
}

type CancelAlterTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelAlterTableStatementContext() *CancelAlterTableStatementContext {
	var p = new(CancelAlterTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cancelAlterTableStatement
	return p
}

func InitEmptyCancelAlterTableStatementContext(p *CancelAlterTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cancelAlterTableStatement
}

func (*CancelAlterTableStatementContext) IsCancelAlterTableStatementContext() {}

func NewCancelAlterTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelAlterTableStatementContext {
	var p = new(CancelAlterTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_cancelAlterTableStatement

	return p
}

func (s *CancelAlterTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelAlterTableStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCANCEL, 0)
}

func (s *CancelAlterTableStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *CancelAlterTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *CancelAlterTableStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *CancelAlterTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CancelAlterTableStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserINTEGER_VALUE)
}

func (s *CancelAlterTableStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, i)
}

func (s *CancelAlterTableStatementContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLUMN, 0)
}

func (s *CancelAlterTableStatementContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROLLUP, 0)
}

func (s *CancelAlterTableStatementContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOPTIMIZE, 0)
}

func (s *CancelAlterTableStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMATERIALIZED, 0)
}

func (s *CancelAlterTableStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVIEW, 0)
}

func (s *CancelAlterTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelAlterTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelAlterTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCancelAlterTableStatement(s)
	}
}

func (s *CancelAlterTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCancelAlterTableStatement(s)
	}
}

func (s *CancelAlterTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCancelAlterTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CancelAlterTableStatement() (localctx ICancelAlterTableStatementContext) {
	localctx = NewCancelAlterTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, DorisSQLParserRULE_cancelAlterTableStatement)
	var _la int

	p.SetState(2008)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1982)
			p.Match(DorisSQLParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1983)
			p.Match(DorisSQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1984)
			p.Match(DorisSQLParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1986)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserCOLUMN || _la == DorisSQLParserOPTIMIZE || _la == DorisSQLParserROLLUP {
			{
				p.SetState(1985)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserCOLUMN || _la == DorisSQLParserOPTIMIZE || _la == DorisSQLParserROLLUP) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1988)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1989)
			p.QualifiedName()
		}
		p.SetState(2000)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__1 {
			{
				p.SetState(1990)
				p.Match(DorisSQLParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1991)
				p.Match(DorisSQLParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1996)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(1992)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1993)
					p.Match(DorisSQLParserINTEGER_VALUE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1998)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1999)
				p.Match(DorisSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2002)
			p.Match(DorisSQLParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2003)
			p.Match(DorisSQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2004)
			p.Match(DorisSQLParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2005)
			p.Match(DorisSQLParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2006)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2007)
			p.QualifiedName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowPartitionsStatementContext is an interface to support dynamic dispatch.
type IShowPartitionsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	TEMPORARY() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext

	// IsShowPartitionsStatementContext differentiates from other interfaces.
	IsShowPartitionsStatementContext()
}

type ShowPartitionsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	table  IQualifiedNameContext
}

func NewEmptyShowPartitionsStatementContext() *ShowPartitionsStatementContext {
	var p = new(ShowPartitionsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showPartitionsStatement
	return p
}

func InitEmptyShowPartitionsStatementContext(p *ShowPartitionsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showPartitionsStatement
}

func (*ShowPartitionsStatementContext) IsShowPartitionsStatementContext() {}

func NewShowPartitionsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowPartitionsStatementContext {
	var p = new(ShowPartitionsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showPartitionsStatement

	return p
}

func (s *ShowPartitionsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowPartitionsStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *ShowPartitionsStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *ShowPartitionsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowPartitionsStatementContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPARTITIONS, 0)
}

func (s *ShowPartitionsStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowPartitionsStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowPartitionsStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTEMPORARY, 0)
}

func (s *ShowPartitionsStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowPartitionsStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowPartitionsStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserORDER, 0)
}

func (s *ShowPartitionsStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *ShowPartitionsStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowPartitionsStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowPartitionsStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowPartitionsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPartitionsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowPartitionsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowPartitionsStatement(s)
	}
}

func (s *ShowPartitionsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowPartitionsStatement(s)
	}
}

func (s *ShowPartitionsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowPartitionsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowPartitionsStatement() (localctx IShowPartitionsStatementContext) {
	localctx = NewShowPartitionsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, DorisSQLParserRULE_showPartitionsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2010)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2012)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserTEMPORARY {
		{
			p.SetState(2011)
			p.Match(DorisSQLParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2014)
		p.Match(DorisSQLParserPARTITIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2015)
		p.Match(DorisSQLParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2016)

		var _x = p.QualifiedName()

		localctx.(*ShowPartitionsStatementContext).table = _x
	}
	p.SetState(2019)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWHERE {
		{
			p.SetState(2017)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2018)
			p.expression(0)
		}

	}
	p.SetState(2031)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserORDER {
		{
			p.SetState(2021)
			p.Match(DorisSQLParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2022)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2023)
			p.SortItem()
		}
		p.SetState(2028)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(2024)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2025)
				p.SortItem()
			}

			p.SetState(2030)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(2034)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserLIMIT {
		{
			p.SetState(2033)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecoverPartitionStatementContext is an interface to support dynamic dispatch.
type IRecoverPartitionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// Getter signatures
	RECOVER() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsRecoverPartitionStatementContext differentiates from other interfaces.
	IsRecoverPartitionStatementContext()
}

type RecoverPartitionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	table  IQualifiedNameContext
}

func NewEmptyRecoverPartitionStatementContext() *RecoverPartitionStatementContext {
	var p = new(RecoverPartitionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_recoverPartitionStatement
	return p
}

func InitEmptyRecoverPartitionStatementContext(p *RecoverPartitionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_recoverPartitionStatement
}

func (*RecoverPartitionStatementContext) IsRecoverPartitionStatementContext() {}

func NewRecoverPartitionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecoverPartitionStatementContext {
	var p = new(RecoverPartitionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_recoverPartitionStatement

	return p
}

func (s *RecoverPartitionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RecoverPartitionStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *RecoverPartitionStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *RecoverPartitionStatementContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRECOVER, 0)
}

func (s *RecoverPartitionStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPARTITION, 0)
}

func (s *RecoverPartitionStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RecoverPartitionStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *RecoverPartitionStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RecoverPartitionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecoverPartitionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecoverPartitionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRecoverPartitionStatement(s)
	}
}

func (s *RecoverPartitionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRecoverPartitionStatement(s)
	}
}

func (s *RecoverPartitionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRecoverPartitionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) RecoverPartitionStatement() (localctx IRecoverPartitionStatementContext) {
	localctx = NewRecoverPartitionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, DorisSQLParserRULE_recoverPartitionStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2036)
		p.Match(DorisSQLParserRECOVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2037)
		p.Match(DorisSQLParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2038)
		p.Identifier()
	}
	{
		p.SetState(2039)
		p.Match(DorisSQLParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2040)

		var _x = p.QualifiedName()

		localctx.(*RecoverPartitionStatementContext).table = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateViewStatementContext is an interface to support dynamic dispatch.
type ICreateViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AS() antlr.TerminalNode
	QueryStatement() IQueryStatementContext
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AllColumnNameWithComment() []IColumnNameWithCommentContext
	ColumnNameWithComment(i int) IColumnNameWithCommentContext
	Comment() ICommentContext
	SECURITY() antlr.TerminalNode
	NONE() antlr.TerminalNode
	INVOKER() antlr.TerminalNode

	// IsCreateViewStatementContext differentiates from other interfaces.
	IsCreateViewStatementContext()
}

type CreateViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateViewStatementContext() *CreateViewStatementContext {
	var p = new(CreateViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createViewStatement
	return p
}

func InitEmptyCreateViewStatementContext(p *CreateViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createViewStatement
}

func (*CreateViewStatementContext) IsCreateViewStatementContext() {}

func NewCreateViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateViewStatementContext {
	var p = new(CreateViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createViewStatement

	return p
}

func (s *CreateViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateViewStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVIEW, 0)
}

func (s *CreateViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateViewStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *CreateViewStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *CreateViewStatementContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOR, 0)
}

func (s *CreateViewStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPLACE, 0)
}

func (s *CreateViewStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *CreateViewStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *CreateViewStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *CreateViewStatementContext) AllColumnNameWithComment() []IColumnNameWithCommentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameWithCommentContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameWithCommentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameWithCommentContext); ok {
			tst[i] = t.(IColumnNameWithCommentContext)
			i++
		}
	}

	return tst
}

func (s *CreateViewStatementContext) ColumnNameWithComment(i int) IColumnNameWithCommentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameWithCommentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameWithCommentContext)
}

func (s *CreateViewStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateViewStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSECURITY, 0)
}

func (s *CreateViewStatementContext) NONE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNONE, 0)
}

func (s *CreateViewStatementContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINVOKER, 0)
}

func (s *CreateViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateViewStatement(s)
	}
}

func (s *CreateViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateViewStatement(s)
	}
}

func (s *CreateViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateViewStatement() (localctx ICreateViewStatementContext) {
	localctx = NewCreateViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, DorisSQLParserRULE_createViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2042)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2045)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserOR {
		{
			p.SetState(2043)
			p.Match(DorisSQLParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2044)
			p.Match(DorisSQLParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2047)
		p.Match(DorisSQLParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2051)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(2048)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2049)
			p.Match(DorisSQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2050)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2053)
		p.QualifiedName()
	}
	p.SetState(2065)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserT__1 {
		{
			p.SetState(2054)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2055)
			p.ColumnNameWithComment()
		}
		p.SetState(2060)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(2056)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2057)
				p.ColumnNameWithComment()
			}

			p.SetState(2062)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2063)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2068)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserCOMMENT {
		{
			p.SetState(2067)
			p.Comment()
		}

	}
	p.SetState(2072)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserSECURITY {
		{
			p.SetState(2070)
			p.Match(DorisSQLParserSECURITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2071)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserINVOKER || _la == DorisSQLParserNONE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(2074)
		p.Match(DorisSQLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2075)
		p.QueryStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterViewStatementContext is an interface to support dynamic dispatch.
type IAlterViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AS() antlr.TerminalNode
	QueryStatement() IQueryStatementContext
	AllColumnNameWithComment() []IColumnNameWithCommentContext
	ColumnNameWithComment(i int) IColumnNameWithCommentContext
	SET() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	NONE() antlr.TerminalNode
	INVOKER() antlr.TerminalNode
	Properties() IPropertiesContext
	DIALECT() antlr.TerminalNode
	ADD() antlr.TerminalNode
	MODIFY() antlr.TerminalNode

	// IsAlterViewStatementContext differentiates from other interfaces.
	IsAlterViewStatementContext()
}

type AlterViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterViewStatementContext() *AlterViewStatementContext {
	var p = new(AlterViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterViewStatement
	return p
}

func InitEmptyAlterViewStatementContext(p *AlterViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterViewStatement
}

func (*AlterViewStatementContext) IsAlterViewStatementContext() {}

func NewAlterViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterViewStatementContext {
	var p = new(AlterViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_alterViewStatement

	return p
}

func (s *AlterViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterViewStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *AlterViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVIEW, 0)
}

func (s *AlterViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterViewStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *AlterViewStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *AlterViewStatementContext) AllColumnNameWithComment() []IColumnNameWithCommentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameWithCommentContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameWithCommentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameWithCommentContext); ok {
			tst[i] = t.(IColumnNameWithCommentContext)
			i++
		}
	}

	return tst
}

func (s *AlterViewStatementContext) ColumnNameWithComment(i int) IColumnNameWithCommentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameWithCommentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameWithCommentContext)
}

func (s *AlterViewStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *AlterViewStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSECURITY, 0)
}

func (s *AlterViewStatementContext) NONE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNONE, 0)
}

func (s *AlterViewStatementContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINVOKER, 0)
}

func (s *AlterViewStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AlterViewStatementContext) DIALECT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDIALECT, 0)
}

func (s *AlterViewStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADD, 0)
}

func (s *AlterViewStatementContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMODIFY, 0)
}

func (s *AlterViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAlterViewStatement(s)
	}
}

func (s *AlterViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAlterViewStatement(s)
	}
}

func (s *AlterViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAlterViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AlterViewStatement() (localctx IAlterViewStatementContext) {
	localctx = NewAlterViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, DorisSQLParserRULE_alterViewStatement)
	var _la int

	p.SetState(2116)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 132, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2077)
			p.Match(DorisSQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2078)
			p.Match(DorisSQLParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2079)
			p.QualifiedName()
		}
		p.SetState(2091)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__1 {
			{
				p.SetState(2080)
				p.Match(DorisSQLParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2081)
				p.ColumnNameWithComment()
			}
			p.SetState(2086)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(2082)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2083)
					p.ColumnNameWithComment()
				}

				p.SetState(2088)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2089)
				p.Match(DorisSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2093)
			p.Match(DorisSQLParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2094)
			p.QueryStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2096)
			p.Match(DorisSQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2097)
			p.Match(DorisSQLParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2098)
			p.QualifiedName()
		}
		{
			p.SetState(2099)
			p.Match(DorisSQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2100)
			p.Match(DorisSQLParserSECURITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2101)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserINVOKER || _la == DorisSQLParserNONE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2103)
			p.Match(DorisSQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2104)
			p.Match(DorisSQLParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2105)
			p.QualifiedName()
		}
		{
			p.SetState(2106)
			p.Match(DorisSQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2107)
			p.Properties()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2109)
			p.Match(DorisSQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2110)
			p.Match(DorisSQLParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2111)
			p.QualifiedName()
		}
		{
			p.SetState(2112)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserADD || _la == DorisSQLParserMODIFY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2113)
			p.Match(DorisSQLParserDIALECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2114)
			p.QueryStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropViewStatementContext is an interface to support dynamic dispatch.
type IDropViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropViewStatementContext differentiates from other interfaces.
	IsDropViewStatementContext()
}

type DropViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropViewStatementContext() *DropViewStatementContext {
	var p = new(DropViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropViewStatement
	return p
}

func InitEmptyDropViewStatementContext(p *DropViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropViewStatement
}

func (*DropViewStatementContext) IsDropViewStatementContext() {}

func NewDropViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropViewStatementContext {
	var p = new(DropViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropViewStatement

	return p
}

func (s *DropViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropViewStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVIEW, 0)
}

func (s *DropViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropViewStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *DropViewStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *DropViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropViewStatement(s)
	}
}

func (s *DropViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropViewStatement(s)
	}
}

func (s *DropViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropViewStatement() (localctx IDropViewStatementContext) {
	localctx = NewDropViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, DorisSQLParserRULE_dropViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2118)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2119)
		p.Match(DorisSQLParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2122)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(2120)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2121)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2124)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnNameWithCommentContext is an interface to support dynamic dispatch.
type IColumnNameWithCommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetColumnName returns the columnName rule contexts.
	GetColumnName() IIdentifierContext

	// SetColumnName sets the columnName rule contexts.
	SetColumnName(IIdentifierContext)

	// Getter signatures
	Identifier() IIdentifierContext
	Comment() ICommentContext

	// IsColumnNameWithCommentContext differentiates from other interfaces.
	IsColumnNameWithCommentContext()
}

type ColumnNameWithCommentContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	columnName IIdentifierContext
}

func NewEmptyColumnNameWithCommentContext() *ColumnNameWithCommentContext {
	var p = new(ColumnNameWithCommentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_columnNameWithComment
	return p
}

func InitEmptyColumnNameWithCommentContext(p *ColumnNameWithCommentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_columnNameWithComment
}

func (*ColumnNameWithCommentContext) IsColumnNameWithCommentContext() {}

func NewColumnNameWithCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameWithCommentContext {
	var p = new(ColumnNameWithCommentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_columnNameWithComment

	return p
}

func (s *ColumnNameWithCommentContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameWithCommentContext) GetColumnName() IIdentifierContext { return s.columnName }

func (s *ColumnNameWithCommentContext) SetColumnName(v IIdentifierContext) { s.columnName = v }

func (s *ColumnNameWithCommentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnNameWithCommentContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *ColumnNameWithCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameWithCommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNameWithCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterColumnNameWithComment(s)
	}
}

func (s *ColumnNameWithCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitColumnNameWithComment(s)
	}
}

func (s *ColumnNameWithCommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitColumnNameWithComment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ColumnNameWithComment() (localctx IColumnNameWithCommentContext) {
	localctx = NewColumnNameWithCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, DorisSQLParserRULE_columnNameWithComment)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2126)

		var _x = p.Identifier()

		localctx.(*ColumnNameWithCommentContext).columnName = _x
	}
	p.SetState(2128)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserCOMMENT {
		{
			p.SetState(2127)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubmitTaskStatementContext is an interface to support dynamic dispatch.
type ISubmitTaskStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBMIT() antlr.TerminalNode
	TASK() antlr.TerminalNode
	AS() antlr.TerminalNode
	CreateTableAsSelectStatement() ICreateTableAsSelectStatementContext
	InsertStatement() IInsertStatementContext
	DataCacheSelectStatement() IDataCacheSelectStatementContext
	QualifiedName() IQualifiedNameContext
	AllTaskClause() []ITaskClauseContext
	TaskClause(i int) ITaskClauseContext

	// IsSubmitTaskStatementContext differentiates from other interfaces.
	IsSubmitTaskStatementContext()
}

type SubmitTaskStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubmitTaskStatementContext() *SubmitTaskStatementContext {
	var p = new(SubmitTaskStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_submitTaskStatement
	return p
}

func InitEmptySubmitTaskStatementContext(p *SubmitTaskStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_submitTaskStatement
}

func (*SubmitTaskStatementContext) IsSubmitTaskStatementContext() {}

func NewSubmitTaskStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubmitTaskStatementContext {
	var p = new(SubmitTaskStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_submitTaskStatement

	return p
}

func (s *SubmitTaskStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SubmitTaskStatementContext) SUBMIT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSUBMIT, 0)
}

func (s *SubmitTaskStatementContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTASK, 0)
}

func (s *SubmitTaskStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *SubmitTaskStatementContext) CreateTableAsSelectStatement() ICreateTableAsSelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableAsSelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableAsSelectStatementContext)
}

func (s *SubmitTaskStatementContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *SubmitTaskStatementContext) DataCacheSelectStatement() IDataCacheSelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataCacheSelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataCacheSelectStatementContext)
}

func (s *SubmitTaskStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SubmitTaskStatementContext) AllTaskClause() []ITaskClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITaskClauseContext); ok {
			len++
		}
	}

	tst := make([]ITaskClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITaskClauseContext); ok {
			tst[i] = t.(ITaskClauseContext)
			i++
		}
	}

	return tst
}

func (s *SubmitTaskStatementContext) TaskClause(i int) ITaskClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITaskClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITaskClauseContext)
}

func (s *SubmitTaskStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubmitTaskStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubmitTaskStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSubmitTaskStatement(s)
	}
}

func (s *SubmitTaskStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSubmitTaskStatement(s)
	}
}

func (s *SubmitTaskStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSubmitTaskStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SubmitTaskStatement() (localctx ISubmitTaskStatementContext) {
	localctx = NewSubmitTaskStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, DorisSQLParserRULE_submitTaskStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2130)
		p.Match(DorisSQLParserSUBMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2131)
		p.Match(DorisSQLParserTASK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2133)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2132)
			p.QualifiedName()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2138)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserPROPERTIES || _la == DorisSQLParserSCHEDULE {
		{
			p.SetState(2135)
			p.TaskClause()
		}

		p.SetState(2140)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2141)
		p.Match(DorisSQLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2145)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserCREATE:
		{
			p.SetState(2142)
			p.CreateTableAsSelectStatement()
		}

	case DorisSQLParserDESC, DorisSQLParserDESCRIBE, DorisSQLParserEXPLAIN, DorisSQLParserINSERT:
		{
			p.SetState(2143)
			p.InsertStatement()
		}

	case DorisSQLParserCACHE:
		{
			p.SetState(2144)
			p.DataCacheSelectStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITaskClauseContext is an interface to support dynamic dispatch.
type ITaskClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Properties() IPropertiesContext
	TaskScheduleDesc() ITaskScheduleDescContext

	// IsTaskClauseContext differentiates from other interfaces.
	IsTaskClauseContext()
}

type TaskClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTaskClauseContext() *TaskClauseContext {
	var p = new(TaskClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_taskClause
	return p
}

func InitEmptyTaskClauseContext(p *TaskClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_taskClause
}

func (*TaskClauseContext) IsTaskClauseContext() {}

func NewTaskClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TaskClauseContext {
	var p = new(TaskClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_taskClause

	return p
}

func (s *TaskClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TaskClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *TaskClauseContext) TaskScheduleDesc() ITaskScheduleDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITaskScheduleDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITaskScheduleDescContext)
}

func (s *TaskClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TaskClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TaskClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTaskClause(s)
	}
}

func (s *TaskClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTaskClause(s)
	}
}

func (s *TaskClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTaskClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) TaskClause() (localctx ITaskClauseContext) {
	localctx = NewTaskClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, DorisSQLParserRULE_taskClause)
	p.SetState(2149)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserPROPERTIES:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2147)
			p.Properties()
		}

	case DorisSQLParserSCHEDULE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2148)
			p.TaskScheduleDesc()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTaskStatementContext is an interface to support dynamic dispatch.
type IDropTaskStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TASK() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	FORCE() antlr.TerminalNode

	// IsDropTaskStatementContext differentiates from other interfaces.
	IsDropTaskStatementContext()
}

type DropTaskStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTaskStatementContext() *DropTaskStatementContext {
	var p = new(DropTaskStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropTaskStatement
	return p
}

func InitEmptyDropTaskStatementContext(p *DropTaskStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropTaskStatement
}

func (*DropTaskStatementContext) IsDropTaskStatementContext() {}

func NewDropTaskStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTaskStatementContext {
	var p = new(DropTaskStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropTaskStatement

	return p
}

func (s *DropTaskStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTaskStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropTaskStatementContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTASK, 0)
}

func (s *DropTaskStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropTaskStatementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFORCE, 0)
}

func (s *DropTaskStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTaskStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTaskStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropTaskStatement(s)
	}
}

func (s *DropTaskStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropTaskStatement(s)
	}
}

func (s *DropTaskStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropTaskStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropTaskStatement() (localctx IDropTaskStatementContext) {
	localctx = NewDropTaskStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, DorisSQLParserRULE_dropTaskStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2151)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2152)
		p.Match(DorisSQLParserTASK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2153)
		p.QualifiedName()
	}
	p.SetState(2155)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFORCE {
		{
			p.SetState(2154)
			p.Match(DorisSQLParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITaskScheduleDescContext is an interface to support dynamic dispatch.
type ITaskScheduleDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SCHEDULE() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	TaskInterval() ITaskIntervalContext
	START() antlr.TerminalNode
	String_() IStringContext

	// IsTaskScheduleDescContext differentiates from other interfaces.
	IsTaskScheduleDescContext()
}

type TaskScheduleDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTaskScheduleDescContext() *TaskScheduleDescContext {
	var p = new(TaskScheduleDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_taskScheduleDesc
	return p
}

func InitEmptyTaskScheduleDescContext(p *TaskScheduleDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_taskScheduleDesc
}

func (*TaskScheduleDescContext) IsTaskScheduleDescContext() {}

func NewTaskScheduleDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TaskScheduleDescContext {
	var p = new(TaskScheduleDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_taskScheduleDesc

	return p
}

func (s *TaskScheduleDescContext) GetParser() antlr.Parser { return s.parser }

func (s *TaskScheduleDescContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSCHEDULE, 0)
}

func (s *TaskScheduleDescContext) EVERY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEVERY, 0)
}

func (s *TaskScheduleDescContext) TaskInterval() ITaskIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITaskIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITaskIntervalContext)
}

func (s *TaskScheduleDescContext) START() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTART, 0)
}

func (s *TaskScheduleDescContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *TaskScheduleDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TaskScheduleDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TaskScheduleDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTaskScheduleDesc(s)
	}
}

func (s *TaskScheduleDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTaskScheduleDesc(s)
	}
}

func (s *TaskScheduleDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTaskScheduleDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) TaskScheduleDesc() (localctx ITaskScheduleDescContext) {
	localctx = NewTaskScheduleDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, DorisSQLParserRULE_taskScheduleDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2157)
		p.Match(DorisSQLParserSCHEDULE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2163)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserSTART {
		{
			p.SetState(2158)
			p.Match(DorisSQLParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2159)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2160)
			p.String_()
		}
		{
			p.SetState(2161)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2165)
		p.Match(DorisSQLParserEVERY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2166)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2167)
		p.TaskInterval()
	}
	{
		p.SetState(2168)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateMaterializedViewStatementContext is an interface to support dynamic dispatch.
type ICreateMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMvName returns the mvName rule contexts.
	GetMvName() IQualifiedNameContext

	// SetMvName sets the mvName rule contexts.
	SetMvName(IQualifiedNameContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	AS() antlr.TerminalNode
	QueryStatement() IQueryStatementContext
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AllColumnNameWithComment() []IColumnNameWithCommentContext
	ColumnNameWithComment(i int) IColumnNameWithCommentContext
	Comment() ICommentContext
	AllMaterializedViewDesc() []IMaterializedViewDescContext
	MaterializedViewDesc(i int) IMaterializedViewDescContext
	AllIndexDesc() []IIndexDescContext
	IndexDesc(i int) IIndexDescContext

	// IsCreateMaterializedViewStatementContext differentiates from other interfaces.
	IsCreateMaterializedViewStatementContext()
}

type CreateMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	mvName IQualifiedNameContext
}

func NewEmptyCreateMaterializedViewStatementContext() *CreateMaterializedViewStatementContext {
	var p = new(CreateMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createMaterializedViewStatement
	return p
}

func InitEmptyCreateMaterializedViewStatementContext(p *CreateMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createMaterializedViewStatement
}

func (*CreateMaterializedViewStatementContext) IsCreateMaterializedViewStatementContext() {}

func NewCreateMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateMaterializedViewStatementContext {
	var p = new(CreateMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createMaterializedViewStatement

	return p
}

func (s *CreateMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateMaterializedViewStatementContext) GetMvName() IQualifiedNameContext { return s.mvName }

func (s *CreateMaterializedViewStatementContext) SetMvName(v IQualifiedNameContext) { s.mvName = v }

func (s *CreateMaterializedViewStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateMaterializedViewStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMATERIALIZED, 0)
}

func (s *CreateMaterializedViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVIEW, 0)
}

func (s *CreateMaterializedViewStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *CreateMaterializedViewStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *CreateMaterializedViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateMaterializedViewStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *CreateMaterializedViewStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *CreateMaterializedViewStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *CreateMaterializedViewStatementContext) AllColumnNameWithComment() []IColumnNameWithCommentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameWithCommentContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameWithCommentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameWithCommentContext); ok {
			tst[i] = t.(IColumnNameWithCommentContext)
			i++
		}
	}

	return tst
}

func (s *CreateMaterializedViewStatementContext) ColumnNameWithComment(i int) IColumnNameWithCommentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameWithCommentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameWithCommentContext)
}

func (s *CreateMaterializedViewStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateMaterializedViewStatementContext) AllMaterializedViewDesc() []IMaterializedViewDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMaterializedViewDescContext); ok {
			len++
		}
	}

	tst := make([]IMaterializedViewDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMaterializedViewDescContext); ok {
			tst[i] = t.(IMaterializedViewDescContext)
			i++
		}
	}

	return tst
}

func (s *CreateMaterializedViewStatementContext) MaterializedViewDesc(i int) IMaterializedViewDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaterializedViewDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaterializedViewDescContext)
}

func (s *CreateMaterializedViewStatementContext) AllIndexDesc() []IIndexDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexDescContext); ok {
			len++
		}
	}

	tst := make([]IIndexDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexDescContext); ok {
			tst[i] = t.(IIndexDescContext)
			i++
		}
	}

	return tst
}

func (s *CreateMaterializedViewStatementContext) IndexDesc(i int) IIndexDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexDescContext)
}

func (s *CreateMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateMaterializedViewStatement(s)
	}
}

func (s *CreateMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateMaterializedViewStatement(s)
	}
}

func (s *CreateMaterializedViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateMaterializedViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateMaterializedViewStatement() (localctx ICreateMaterializedViewStatementContext) {
	localctx = NewCreateMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, DorisSQLParserRULE_createMaterializedViewStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2170)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2171)
		p.Match(DorisSQLParserMATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2172)
		p.Match(DorisSQLParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2176)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(2173)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2174)
			p.Match(DorisSQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2175)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2178)

		var _x = p.QualifiedName()

		localctx.(*CreateMaterializedViewStatementContext).mvName = _x
	}
	p.SetState(2197)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserT__1 {
		{
			p.SetState(2179)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2180)
			p.ColumnNameWithComment()
		}
		p.SetState(2185)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2181)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2182)
					p.ColumnNameWithComment()
				}

			}
			p.SetState(2187)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(2192)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(2188)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2189)
				p.IndexDesc()
			}

			p.SetState(2194)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2195)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2200)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserCOMMENT {
		{
			p.SetState(2199)
			p.Comment()
		}

	}
	p.SetState(2205)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserDISTRIBUTED || ((int64((_la-298)) & ^0x3f) == 0 && ((int64(1)<<(_la-298))&1125917086711841) != 0) {
		{
			p.SetState(2202)
			p.MaterializedViewDesc()
		}

		p.SetState(2207)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2208)
		p.Match(DorisSQLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2209)
		p.QueryStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMvPartitionExprsContext is an interface to support dynamic dispatch.
type IMvPartitionExprsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrimaryExpression() []IPrimaryExpressionContext
	PrimaryExpression(i int) IPrimaryExpressionContext

	// IsMvPartitionExprsContext differentiates from other interfaces.
	IsMvPartitionExprsContext()
}

type MvPartitionExprsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMvPartitionExprsContext() *MvPartitionExprsContext {
	var p = new(MvPartitionExprsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_mvPartitionExprs
	return p
}

func InitEmptyMvPartitionExprsContext(p *MvPartitionExprsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_mvPartitionExprs
}

func (*MvPartitionExprsContext) IsMvPartitionExprsContext() {}

func NewMvPartitionExprsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MvPartitionExprsContext {
	var p = new(MvPartitionExprsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_mvPartitionExprs

	return p
}

func (s *MvPartitionExprsContext) GetParser() antlr.Parser { return s.parser }

func (s *MvPartitionExprsContext) AllPrimaryExpression() []IPrimaryExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrimaryExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrimaryExpressionContext); ok {
			tst[i] = t.(IPrimaryExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MvPartitionExprsContext) PrimaryExpression(i int) IPrimaryExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *MvPartitionExprsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MvPartitionExprsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MvPartitionExprsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterMvPartitionExprs(s)
	}
}

func (s *MvPartitionExprsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitMvPartitionExprs(s)
	}
}

func (s *MvPartitionExprsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitMvPartitionExprs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) MvPartitionExprs() (localctx IMvPartitionExprsContext) {
	localctx = NewMvPartitionExprsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, DorisSQLParserRULE_mvPartitionExprs)
	var _la int

	p.SetState(2223)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2211)
			p.primaryExpression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2212)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2213)
			p.primaryExpression(0)
		}
		p.SetState(2218)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(2214)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2215)
				p.primaryExpression(0)
			}

			p.SetState(2220)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2221)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaterializedViewDescContext is an interface to support dynamic dispatch.
type IMaterializedViewDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	MvPartitionExprs() IMvPartitionExprsContext
	DistributionDesc() IDistributionDescContext
	OrderByDesc() IOrderByDescContext
	RefreshSchemeDesc() IRefreshSchemeDescContext
	Properties() IPropertiesContext

	// IsMaterializedViewDescContext differentiates from other interfaces.
	IsMaterializedViewDescContext()
}

type MaterializedViewDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaterializedViewDescContext() *MaterializedViewDescContext {
	var p = new(MaterializedViewDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_materializedViewDesc
	return p
}

func InitEmptyMaterializedViewDescContext(p *MaterializedViewDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_materializedViewDesc
}

func (*MaterializedViewDescContext) IsMaterializedViewDescContext() {}

func NewMaterializedViewDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaterializedViewDescContext {
	var p = new(MaterializedViewDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_materializedViewDesc

	return p
}

func (s *MaterializedViewDescContext) GetParser() antlr.Parser { return s.parser }

func (s *MaterializedViewDescContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPARTITION, 0)
}

func (s *MaterializedViewDescContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *MaterializedViewDescContext) MvPartitionExprs() IMvPartitionExprsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMvPartitionExprsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMvPartitionExprsContext)
}

func (s *MaterializedViewDescContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *MaterializedViewDescContext) OrderByDesc() IOrderByDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByDescContext)
}

func (s *MaterializedViewDescContext) RefreshSchemeDesc() IRefreshSchemeDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshSchemeDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshSchemeDescContext)
}

func (s *MaterializedViewDescContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *MaterializedViewDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaterializedViewDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaterializedViewDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterMaterializedViewDesc(s)
	}
}

func (s *MaterializedViewDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitMaterializedViewDesc(s)
	}
}

func (s *MaterializedViewDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitMaterializedViewDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) MaterializedViewDesc() (localctx IMaterializedViewDescContext) {
	localctx = NewMaterializedViewDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, DorisSQLParserRULE_materializedViewDesc)
	p.SetState(2232)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserPARTITION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2225)
			p.Match(DorisSQLParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2226)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2227)
			p.MvPartitionExprs()
		}

	case DorisSQLParserDISTRIBUTED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2228)
			p.DistributionDesc()
		}

	case DorisSQLParserORDER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2229)
			p.OrderByDesc()
		}

	case DorisSQLParserREFRESH:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2230)
			p.RefreshSchemeDesc()
		}

	case DorisSQLParserPROPERTIES:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2231)
			p.Properties()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowMaterializedViewsStatementContext is an interface to support dynamic dispatch.
type IShowMaterializedViewsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEWS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowMaterializedViewsStatementContext differentiates from other interfaces.
	IsShowMaterializedViewsStatementContext()
}

type ShowMaterializedViewsStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	db      IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowMaterializedViewsStatementContext() *ShowMaterializedViewsStatementContext {
	var p = new(ShowMaterializedViewsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showMaterializedViewsStatement
	return p
}

func InitEmptyShowMaterializedViewsStatementContext(p *ShowMaterializedViewsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showMaterializedViewsStatement
}

func (*ShowMaterializedViewsStatementContext) IsShowMaterializedViewsStatementContext() {}

func NewShowMaterializedViewsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowMaterializedViewsStatementContext {
	var p = new(ShowMaterializedViewsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showMaterializedViewsStatement

	return p
}

func (s *ShowMaterializedViewsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowMaterializedViewsStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowMaterializedViewsStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowMaterializedViewsStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowMaterializedViewsStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowMaterializedViewsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowMaterializedViewsStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMATERIALIZED, 0)
}

func (s *ShowMaterializedViewsStatementContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVIEWS, 0)
}

func (s *ShowMaterializedViewsStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowMaterializedViewsStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *ShowMaterializedViewsStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowMaterializedViewsStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *ShowMaterializedViewsStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowMaterializedViewsStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowMaterializedViewsStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowMaterializedViewsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowMaterializedViewsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowMaterializedViewsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowMaterializedViewsStatement(s)
	}
}

func (s *ShowMaterializedViewsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowMaterializedViewsStatement(s)
	}
}

func (s *ShowMaterializedViewsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowMaterializedViewsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowMaterializedViewsStatement() (localctx IShowMaterializedViewsStatementContext) {
	localctx = NewShowMaterializedViewsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, DorisSQLParserRULE_showMaterializedViewsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2234)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2235)
		p.Match(DorisSQLParserMATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2236)
		p.Match(DorisSQLParserVIEWS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2239)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM || _la == DorisSQLParserIN {
		{
			p.SetState(2237)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2238)

			var _x = p.QualifiedName()

			localctx.(*ShowMaterializedViewsStatementContext).db = _x
		}

	}
	p.SetState(2245)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserLIKE:
		{
			p.SetState(2241)
			p.Match(DorisSQLParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2242)

			var _x = p.String_()

			localctx.(*ShowMaterializedViewsStatementContext).pattern = _x
		}

	case DorisSQLParserWHERE:
		{
			p.SetState(2243)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2244)
			p.expression(0)
		}

	case DorisSQLParserEOF, DorisSQLParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropMaterializedViewStatementContext is an interface to support dynamic dispatch.
type IDropMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMvName returns the mvName rule contexts.
	GetMvName() IQualifiedNameContext

	// SetMvName sets the mvName rule contexts.
	SetMvName(IQualifiedNameContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropMaterializedViewStatementContext differentiates from other interfaces.
	IsDropMaterializedViewStatementContext()
}

type DropMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	mvName IQualifiedNameContext
}

func NewEmptyDropMaterializedViewStatementContext() *DropMaterializedViewStatementContext {
	var p = new(DropMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropMaterializedViewStatement
	return p
}

func InitEmptyDropMaterializedViewStatementContext(p *DropMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropMaterializedViewStatement
}

func (*DropMaterializedViewStatementContext) IsDropMaterializedViewStatementContext() {}

func NewDropMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropMaterializedViewStatementContext {
	var p = new(DropMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropMaterializedViewStatement

	return p
}

func (s *DropMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropMaterializedViewStatementContext) GetMvName() IQualifiedNameContext { return s.mvName }

func (s *DropMaterializedViewStatementContext) SetMvName(v IQualifiedNameContext) { s.mvName = v }

func (s *DropMaterializedViewStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropMaterializedViewStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMATERIALIZED, 0)
}

func (s *DropMaterializedViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVIEW, 0)
}

func (s *DropMaterializedViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropMaterializedViewStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *DropMaterializedViewStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *DropMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropMaterializedViewStatement(s)
	}
}

func (s *DropMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropMaterializedViewStatement(s)
	}
}

func (s *DropMaterializedViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropMaterializedViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropMaterializedViewStatement() (localctx IDropMaterializedViewStatementContext) {
	localctx = NewDropMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, DorisSQLParserRULE_dropMaterializedViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2247)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2248)
		p.Match(DorisSQLParserMATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2249)
		p.Match(DorisSQLParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2252)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(2250)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2251)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2254)

		var _x = p.QualifiedName()

		localctx.(*DropMaterializedViewStatementContext).mvName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterMaterializedViewStatementContext is an interface to support dynamic dispatch.
type IAlterMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMvName returns the mvName rule contexts.
	GetMvName() IQualifiedNameContext

	// SetMvName sets the mvName rule contexts.
	SetMvName(IQualifiedNameContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	RefreshSchemeDesc() IRefreshSchemeDescContext
	TableRenameClause() ITableRenameClauseContext
	ModifyPropertiesClause() IModifyPropertiesClauseContext
	SwapTableClause() ISwapTableClauseContext
	StatusDesc() IStatusDescContext

	// IsAlterMaterializedViewStatementContext differentiates from other interfaces.
	IsAlterMaterializedViewStatementContext()
}

type AlterMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	mvName IQualifiedNameContext
}

func NewEmptyAlterMaterializedViewStatementContext() *AlterMaterializedViewStatementContext {
	var p = new(AlterMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterMaterializedViewStatement
	return p
}

func InitEmptyAlterMaterializedViewStatementContext(p *AlterMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterMaterializedViewStatement
}

func (*AlterMaterializedViewStatementContext) IsAlterMaterializedViewStatementContext() {}

func NewAlterMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterMaterializedViewStatementContext {
	var p = new(AlterMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_alterMaterializedViewStatement

	return p
}

func (s *AlterMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterMaterializedViewStatementContext) GetMvName() IQualifiedNameContext { return s.mvName }

func (s *AlterMaterializedViewStatementContext) SetMvName(v IQualifiedNameContext) { s.mvName = v }

func (s *AlterMaterializedViewStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *AlterMaterializedViewStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMATERIALIZED, 0)
}

func (s *AlterMaterializedViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVIEW, 0)
}

func (s *AlterMaterializedViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterMaterializedViewStatementContext) RefreshSchemeDesc() IRefreshSchemeDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshSchemeDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshSchemeDescContext)
}

func (s *AlterMaterializedViewStatementContext) TableRenameClause() ITableRenameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRenameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRenameClauseContext)
}

func (s *AlterMaterializedViewStatementContext) ModifyPropertiesClause() IModifyPropertiesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyPropertiesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyPropertiesClauseContext)
}

func (s *AlterMaterializedViewStatementContext) SwapTableClause() ISwapTableClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwapTableClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwapTableClauseContext)
}

func (s *AlterMaterializedViewStatementContext) StatusDesc() IStatusDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatusDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatusDescContext)
}

func (s *AlterMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAlterMaterializedViewStatement(s)
	}
}

func (s *AlterMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAlterMaterializedViewStatement(s)
	}
}

func (s *AlterMaterializedViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAlterMaterializedViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AlterMaterializedViewStatement() (localctx IAlterMaterializedViewStatementContext) {
	localctx = NewAlterMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, DorisSQLParserRULE_alterMaterializedViewStatement)
	p.SetState(2272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 154, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2256)
			p.Match(DorisSQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2257)
			p.Match(DorisSQLParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2258)
			p.Match(DorisSQLParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2259)

			var _x = p.QualifiedName()

			localctx.(*AlterMaterializedViewStatementContext).mvName = _x
		}
		p.SetState(2264)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserREFRESH:
			{
				p.SetState(2260)
				p.RefreshSchemeDesc()
			}

		case DorisSQLParserRENAME:
			{
				p.SetState(2261)
				p.TableRenameClause()
			}

		case DorisSQLParserSET:
			{
				p.SetState(2262)
				p.ModifyPropertiesClause()
			}

		case DorisSQLParserSWAP:
			{
				p.SetState(2263)
				p.SwapTableClause()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2266)
			p.Match(DorisSQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2267)
			p.Match(DorisSQLParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2268)
			p.Match(DorisSQLParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2269)

			var _x = p.QualifiedName()

			localctx.(*AlterMaterializedViewStatementContext).mvName = _x
		}
		{
			p.SetState(2270)
			p.StatusDesc()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshMaterializedViewStatementContext is an interface to support dynamic dispatch.
type IRefreshMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// GetMvName returns the mvName rule contexts.
	GetMvName() IQualifiedNameContext

	// SetMvName sets the mvName rule contexts.
	SetMvName(IQualifiedNameContext)

	// Getter signatures
	REFRESH() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PARTITION() antlr.TerminalNode
	FORCE() antlr.TerminalNode
	AllWITH() []antlr.TerminalNode
	WITH(i int) antlr.TerminalNode
	MODE() antlr.TerminalNode
	PRIORITY() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	PartitionRangeDesc() IPartitionRangeDescContext
	ListPartitionValues() IListPartitionValuesContext

	// IsRefreshMaterializedViewStatementContext differentiates from other interfaces.
	IsRefreshMaterializedViewStatementContext()
}

type RefreshMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	mvName   IQualifiedNameContext
	priority antlr.Token
}

func NewEmptyRefreshMaterializedViewStatementContext() *RefreshMaterializedViewStatementContext {
	var p = new(RefreshMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_refreshMaterializedViewStatement
	return p
}

func InitEmptyRefreshMaterializedViewStatementContext(p *RefreshMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_refreshMaterializedViewStatement
}

func (*RefreshMaterializedViewStatementContext) IsRefreshMaterializedViewStatementContext() {}

func NewRefreshMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshMaterializedViewStatementContext {
	var p = new(RefreshMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_refreshMaterializedViewStatement

	return p
}

func (s *RefreshMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshMaterializedViewStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *RefreshMaterializedViewStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *RefreshMaterializedViewStatementContext) GetMvName() IQualifiedNameContext { return s.mvName }

func (s *RefreshMaterializedViewStatementContext) SetMvName(v IQualifiedNameContext) { s.mvName = v }

func (s *RefreshMaterializedViewStatementContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREFRESH, 0)
}

func (s *RefreshMaterializedViewStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMATERIALIZED, 0)
}

func (s *RefreshMaterializedViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVIEW, 0)
}

func (s *RefreshMaterializedViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RefreshMaterializedViewStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPARTITION, 0)
}

func (s *RefreshMaterializedViewStatementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFORCE, 0)
}

func (s *RefreshMaterializedViewStatementContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserWITH)
}

func (s *RefreshMaterializedViewStatementContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, i)
}

func (s *RefreshMaterializedViewStatementContext) MODE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMODE, 0)
}

func (s *RefreshMaterializedViewStatementContext) PRIORITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPRIORITY, 0)
}

func (s *RefreshMaterializedViewStatementContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSYNC, 0)
}

func (s *RefreshMaterializedViewStatementContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserASYNC, 0)
}

func (s *RefreshMaterializedViewStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, 0)
}

func (s *RefreshMaterializedViewStatementContext) PartitionRangeDesc() IPartitionRangeDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionRangeDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionRangeDescContext)
}

func (s *RefreshMaterializedViewStatementContext) ListPartitionValues() IListPartitionValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListPartitionValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListPartitionValuesContext)
}

func (s *RefreshMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRefreshMaterializedViewStatement(s)
	}
}

func (s *RefreshMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRefreshMaterializedViewStatement(s)
	}
}

func (s *RefreshMaterializedViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRefreshMaterializedViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) RefreshMaterializedViewStatement() (localctx IRefreshMaterializedViewStatementContext) {
	localctx = NewRefreshMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, DorisSQLParserRULE_refreshMaterializedViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2274)
		p.Match(DorisSQLParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2275)
		p.Match(DorisSQLParserMATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2276)
		p.Match(DorisSQLParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2277)

		var _x = p.QualifiedName()

		localctx.(*RefreshMaterializedViewStatementContext).mvName = _x
	}
	p.SetState(2283)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPARTITION {
		{
			p.SetState(2278)
			p.Match(DorisSQLParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2281)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserSTART:
			{
				p.SetState(2279)
				p.PartitionRangeDesc()
			}

		case DorisSQLParserT__1:
			{
				p.SetState(2280)
				p.ListPartitionValues()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(2286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFORCE {
		{
			p.SetState(2285)
			p.Match(DorisSQLParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2291)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 158, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2288)
			p.Match(DorisSQLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2289)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserASYNC || _la == DorisSQLParserSYNC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2290)
			p.Match(DorisSQLParserMODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2296)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWITH {
		{
			p.SetState(2293)
			p.Match(DorisSQLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2294)
			p.Match(DorisSQLParserPRIORITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2295)

			var _m = p.Match(DorisSQLParserINTEGER_VALUE)

			localctx.(*RefreshMaterializedViewStatementContext).priority = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelRefreshMaterializedViewStatementContext is an interface to support dynamic dispatch.
type ICancelRefreshMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMvName returns the mvName rule contexts.
	GetMvName() IQualifiedNameContext

	// SetMvName sets the mvName rule contexts.
	SetMvName(IQualifiedNameContext)

	// Getter signatures
	CANCEL() antlr.TerminalNode
	REFRESH() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	FORCE() antlr.TerminalNode

	// IsCancelRefreshMaterializedViewStatementContext differentiates from other interfaces.
	IsCancelRefreshMaterializedViewStatementContext()
}

type CancelRefreshMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	mvName IQualifiedNameContext
}

func NewEmptyCancelRefreshMaterializedViewStatementContext() *CancelRefreshMaterializedViewStatementContext {
	var p = new(CancelRefreshMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cancelRefreshMaterializedViewStatement
	return p
}

func InitEmptyCancelRefreshMaterializedViewStatementContext(p *CancelRefreshMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cancelRefreshMaterializedViewStatement
}

func (*CancelRefreshMaterializedViewStatementContext) IsCancelRefreshMaterializedViewStatementContext() {
}

func NewCancelRefreshMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelRefreshMaterializedViewStatementContext {
	var p = new(CancelRefreshMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_cancelRefreshMaterializedViewStatement

	return p
}

func (s *CancelRefreshMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelRefreshMaterializedViewStatementContext) GetMvName() IQualifiedNameContext {
	return s.mvName
}

func (s *CancelRefreshMaterializedViewStatementContext) SetMvName(v IQualifiedNameContext) {
	s.mvName = v
}

func (s *CancelRefreshMaterializedViewStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCANCEL, 0)
}

func (s *CancelRefreshMaterializedViewStatementContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREFRESH, 0)
}

func (s *CancelRefreshMaterializedViewStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMATERIALIZED, 0)
}

func (s *CancelRefreshMaterializedViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVIEW, 0)
}

func (s *CancelRefreshMaterializedViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CancelRefreshMaterializedViewStatementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFORCE, 0)
}

func (s *CancelRefreshMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelRefreshMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelRefreshMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCancelRefreshMaterializedViewStatement(s)
	}
}

func (s *CancelRefreshMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCancelRefreshMaterializedViewStatement(s)
	}
}

func (s *CancelRefreshMaterializedViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCancelRefreshMaterializedViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CancelRefreshMaterializedViewStatement() (localctx ICancelRefreshMaterializedViewStatementContext) {
	localctx = NewCancelRefreshMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, DorisSQLParserRULE_cancelRefreshMaterializedViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2298)
		p.Match(DorisSQLParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2299)
		p.Match(DorisSQLParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2300)
		p.Match(DorisSQLParserMATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2301)
		p.Match(DorisSQLParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2302)

		var _x = p.QualifiedName()

		localctx.(*CancelRefreshMaterializedViewStatementContext).mvName = _x
	}
	p.SetState(2304)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFORCE {
		{
			p.SetState(2303)
			p.Match(DorisSQLParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminSetConfigStatementContext is an interface to support dynamic dispatch.
type IAdminSetConfigStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SET() antlr.TerminalNode
	FRONTEND() antlr.TerminalNode
	CONFIG() antlr.TerminalNode
	Property() IPropertyContext
	WITH() antlr.TerminalNode
	PERSISTENT() antlr.TerminalNode

	// IsAdminSetConfigStatementContext differentiates from other interfaces.
	IsAdminSetConfigStatementContext()
}

type AdminSetConfigStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminSetConfigStatementContext() *AdminSetConfigStatementContext {
	var p = new(AdminSetConfigStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_adminSetConfigStatement
	return p
}

func InitEmptyAdminSetConfigStatementContext(p *AdminSetConfigStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_adminSetConfigStatement
}

func (*AdminSetConfigStatementContext) IsAdminSetConfigStatementContext() {}

func NewAdminSetConfigStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminSetConfigStatementContext {
	var p = new(AdminSetConfigStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_adminSetConfigStatement

	return p
}

func (s *AdminSetConfigStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminSetConfigStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADMIN, 0)
}

func (s *AdminSetConfigStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *AdminSetConfigStatementContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFRONTEND, 0)
}

func (s *AdminSetConfigStatementContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCONFIG, 0)
}

func (s *AdminSetConfigStatementContext) Property() IPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *AdminSetConfigStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *AdminSetConfigStatementContext) PERSISTENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPERSISTENT, 0)
}

func (s *AdminSetConfigStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetConfigStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminSetConfigStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAdminSetConfigStatement(s)
	}
}

func (s *AdminSetConfigStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAdminSetConfigStatement(s)
	}
}

func (s *AdminSetConfigStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAdminSetConfigStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AdminSetConfigStatement() (localctx IAdminSetConfigStatementContext) {
	localctx = NewAdminSetConfigStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, DorisSQLParserRULE_adminSetConfigStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2306)
		p.Match(DorisSQLParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2307)
		p.Match(DorisSQLParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2308)
		p.Match(DorisSQLParserFRONTEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2309)
		p.Match(DorisSQLParserCONFIG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2310)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2311)
		p.Property()
	}
	{
		p.SetState(2312)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2315)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWITH {
		{
			p.SetState(2313)
			p.Match(DorisSQLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2314)
			p.Match(DorisSQLParserPERSISTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminSetReplicaStatusStatementContext is an interface to support dynamic dispatch.
type IAdminSetReplicaStatusStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SET() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsAdminSetReplicaStatusStatementContext differentiates from other interfaces.
	IsAdminSetReplicaStatusStatementContext()
}

type AdminSetReplicaStatusStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminSetReplicaStatusStatementContext() *AdminSetReplicaStatusStatementContext {
	var p = new(AdminSetReplicaStatusStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_adminSetReplicaStatusStatement
	return p
}

func InitEmptyAdminSetReplicaStatusStatementContext(p *AdminSetReplicaStatusStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_adminSetReplicaStatusStatement
}

func (*AdminSetReplicaStatusStatementContext) IsAdminSetReplicaStatusStatementContext() {}

func NewAdminSetReplicaStatusStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminSetReplicaStatusStatementContext {
	var p = new(AdminSetReplicaStatusStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_adminSetReplicaStatusStatement

	return p
}

func (s *AdminSetReplicaStatusStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminSetReplicaStatusStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADMIN, 0)
}

func (s *AdminSetReplicaStatusStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *AdminSetReplicaStatusStatementContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPLICA, 0)
}

func (s *AdminSetReplicaStatusStatementContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTATUS, 0)
}

func (s *AdminSetReplicaStatusStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AdminSetReplicaStatusStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetReplicaStatusStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminSetReplicaStatusStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAdminSetReplicaStatusStatement(s)
	}
}

func (s *AdminSetReplicaStatusStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAdminSetReplicaStatusStatement(s)
	}
}

func (s *AdminSetReplicaStatusStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAdminSetReplicaStatusStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AdminSetReplicaStatusStatement() (localctx IAdminSetReplicaStatusStatementContext) {
	localctx = NewAdminSetReplicaStatusStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, DorisSQLParserRULE_adminSetReplicaStatusStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2317)
		p.Match(DorisSQLParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2318)
		p.Match(DorisSQLParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2319)
		p.Match(DorisSQLParserREPLICA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2320)
		p.Match(DorisSQLParserSTATUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2321)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminShowConfigStatementContext is an interface to support dynamic dispatch.
type IAdminShowConfigStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	FRONTEND() antlr.TerminalNode
	CONFIG() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	String_() IStringContext

	// IsAdminShowConfigStatementContext differentiates from other interfaces.
	IsAdminShowConfigStatementContext()
}

type AdminShowConfigStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyAdminShowConfigStatementContext() *AdminShowConfigStatementContext {
	var p = new(AdminShowConfigStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_adminShowConfigStatement
	return p
}

func InitEmptyAdminShowConfigStatementContext(p *AdminShowConfigStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_adminShowConfigStatement
}

func (*AdminShowConfigStatementContext) IsAdminShowConfigStatementContext() {}

func NewAdminShowConfigStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminShowConfigStatementContext {
	var p = new(AdminShowConfigStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_adminShowConfigStatement

	return p
}

func (s *AdminShowConfigStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminShowConfigStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *AdminShowConfigStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *AdminShowConfigStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADMIN, 0)
}

func (s *AdminShowConfigStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *AdminShowConfigStatementContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFRONTEND, 0)
}

func (s *AdminShowConfigStatementContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCONFIG, 0)
}

func (s *AdminShowConfigStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *AdminShowConfigStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AdminShowConfigStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminShowConfigStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminShowConfigStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAdminShowConfigStatement(s)
	}
}

func (s *AdminShowConfigStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAdminShowConfigStatement(s)
	}
}

func (s *AdminShowConfigStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAdminShowConfigStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AdminShowConfigStatement() (localctx IAdminShowConfigStatementContext) {
	localctx = NewAdminShowConfigStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, DorisSQLParserRULE_adminShowConfigStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2323)
		p.Match(DorisSQLParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2324)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2325)
		p.Match(DorisSQLParserFRONTEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2326)
		p.Match(DorisSQLParserCONFIG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserLIKE {
		{
			p.SetState(2327)
			p.Match(DorisSQLParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2328)

			var _x = p.String_()

			localctx.(*AdminShowConfigStatementContext).pattern = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminShowReplicaDistributionStatementContext is an interface to support dynamic dispatch.
type IAdminShowReplicaDistributionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	DISTRIBUTION() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext

	// IsAdminShowReplicaDistributionStatementContext differentiates from other interfaces.
	IsAdminShowReplicaDistributionStatementContext()
}

type AdminShowReplicaDistributionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminShowReplicaDistributionStatementContext() *AdminShowReplicaDistributionStatementContext {
	var p = new(AdminShowReplicaDistributionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_adminShowReplicaDistributionStatement
	return p
}

func InitEmptyAdminShowReplicaDistributionStatementContext(p *AdminShowReplicaDistributionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_adminShowReplicaDistributionStatement
}

func (*AdminShowReplicaDistributionStatementContext) IsAdminShowReplicaDistributionStatementContext() {
}

func NewAdminShowReplicaDistributionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminShowReplicaDistributionStatementContext {
	var p = new(AdminShowReplicaDistributionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_adminShowReplicaDistributionStatement

	return p
}

func (s *AdminShowReplicaDistributionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminShowReplicaDistributionStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADMIN, 0)
}

func (s *AdminShowReplicaDistributionStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *AdminShowReplicaDistributionStatementContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPLICA, 0)
}

func (s *AdminShowReplicaDistributionStatementContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDISTRIBUTION, 0)
}

func (s *AdminShowReplicaDistributionStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *AdminShowReplicaDistributionStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AdminShowReplicaDistributionStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *AdminShowReplicaDistributionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminShowReplicaDistributionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminShowReplicaDistributionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAdminShowReplicaDistributionStatement(s)
	}
}

func (s *AdminShowReplicaDistributionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAdminShowReplicaDistributionStatement(s)
	}
}

func (s *AdminShowReplicaDistributionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAdminShowReplicaDistributionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AdminShowReplicaDistributionStatement() (localctx IAdminShowReplicaDistributionStatementContext) {
	localctx = NewAdminShowReplicaDistributionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, DorisSQLParserRULE_adminShowReplicaDistributionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2331)
		p.Match(DorisSQLParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2332)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2333)
		p.Match(DorisSQLParserREPLICA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2334)
		p.Match(DorisSQLParserDISTRIBUTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2335)
		p.Match(DorisSQLParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2336)
		p.QualifiedName()
	}
	p.SetState(2338)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPARTITION || _la == DorisSQLParserPARTITIONS || _la == DorisSQLParserTEMPORARY {
		{
			p.SetState(2337)
			p.PartitionNames()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminShowReplicaStatusStatementContext is an interface to support dynamic dispatch.
type IAdminShowReplicaStatusStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsAdminShowReplicaStatusStatementContext differentiates from other interfaces.
	IsAdminShowReplicaStatusStatementContext()
}

type AdminShowReplicaStatusStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IExpressionContext
}

func NewEmptyAdminShowReplicaStatusStatementContext() *AdminShowReplicaStatusStatementContext {
	var p = new(AdminShowReplicaStatusStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_adminShowReplicaStatusStatement
	return p
}

func InitEmptyAdminShowReplicaStatusStatementContext(p *AdminShowReplicaStatusStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_adminShowReplicaStatusStatement
}

func (*AdminShowReplicaStatusStatementContext) IsAdminShowReplicaStatusStatementContext() {}

func NewAdminShowReplicaStatusStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminShowReplicaStatusStatementContext {
	var p = new(AdminShowReplicaStatusStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_adminShowReplicaStatusStatement

	return p
}

func (s *AdminShowReplicaStatusStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminShowReplicaStatusStatementContext) GetWhere() IExpressionContext { return s.where }

func (s *AdminShowReplicaStatusStatementContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *AdminShowReplicaStatusStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADMIN, 0)
}

func (s *AdminShowReplicaStatusStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *AdminShowReplicaStatusStatementContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPLICA, 0)
}

func (s *AdminShowReplicaStatusStatementContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTATUS, 0)
}

func (s *AdminShowReplicaStatusStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *AdminShowReplicaStatusStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AdminShowReplicaStatusStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *AdminShowReplicaStatusStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *AdminShowReplicaStatusStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AdminShowReplicaStatusStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminShowReplicaStatusStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminShowReplicaStatusStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAdminShowReplicaStatusStatement(s)
	}
}

func (s *AdminShowReplicaStatusStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAdminShowReplicaStatusStatement(s)
	}
}

func (s *AdminShowReplicaStatusStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAdminShowReplicaStatusStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AdminShowReplicaStatusStatement() (localctx IAdminShowReplicaStatusStatementContext) {
	localctx = NewAdminShowReplicaStatusStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, DorisSQLParserRULE_adminShowReplicaStatusStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2340)
		p.Match(DorisSQLParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2341)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2342)
		p.Match(DorisSQLParserREPLICA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2343)
		p.Match(DorisSQLParserSTATUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2344)
		p.Match(DorisSQLParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2345)
		p.QualifiedName()
	}
	p.SetState(2347)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPARTITION || _la == DorisSQLParserPARTITIONS || _la == DorisSQLParserTEMPORARY {
		{
			p.SetState(2346)
			p.PartitionNames()
		}

	}
	p.SetState(2351)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWHERE {
		{
			p.SetState(2349)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2350)

			var _x = p.expression(0)

			localctx.(*AdminShowReplicaStatusStatementContext).where = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminRepairTableStatementContext is an interface to support dynamic dispatch.
type IAdminRepairTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	REPAIR() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext

	// IsAdminRepairTableStatementContext differentiates from other interfaces.
	IsAdminRepairTableStatementContext()
}

type AdminRepairTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminRepairTableStatementContext() *AdminRepairTableStatementContext {
	var p = new(AdminRepairTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_adminRepairTableStatement
	return p
}

func InitEmptyAdminRepairTableStatementContext(p *AdminRepairTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_adminRepairTableStatement
}

func (*AdminRepairTableStatementContext) IsAdminRepairTableStatementContext() {}

func NewAdminRepairTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminRepairTableStatementContext {
	var p = new(AdminRepairTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_adminRepairTableStatement

	return p
}

func (s *AdminRepairTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminRepairTableStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADMIN, 0)
}

func (s *AdminRepairTableStatementContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPAIR, 0)
}

func (s *AdminRepairTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *AdminRepairTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AdminRepairTableStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *AdminRepairTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminRepairTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminRepairTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAdminRepairTableStatement(s)
	}
}

func (s *AdminRepairTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAdminRepairTableStatement(s)
	}
}

func (s *AdminRepairTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAdminRepairTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AdminRepairTableStatement() (localctx IAdminRepairTableStatementContext) {
	localctx = NewAdminRepairTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, DorisSQLParserRULE_adminRepairTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2353)
		p.Match(DorisSQLParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2354)
		p.Match(DorisSQLParserREPAIR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2355)
		p.Match(DorisSQLParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2356)
		p.QualifiedName()
	}
	p.SetState(2358)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPARTITION || _la == DorisSQLParserPARTITIONS || _la == DorisSQLParserTEMPORARY {
		{
			p.SetState(2357)
			p.PartitionNames()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminCancelRepairTableStatementContext is an interface to support dynamic dispatch.
type IAdminCancelRepairTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	CANCEL() antlr.TerminalNode
	REPAIR() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext

	// IsAdminCancelRepairTableStatementContext differentiates from other interfaces.
	IsAdminCancelRepairTableStatementContext()
}

type AdminCancelRepairTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminCancelRepairTableStatementContext() *AdminCancelRepairTableStatementContext {
	var p = new(AdminCancelRepairTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_adminCancelRepairTableStatement
	return p
}

func InitEmptyAdminCancelRepairTableStatementContext(p *AdminCancelRepairTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_adminCancelRepairTableStatement
}

func (*AdminCancelRepairTableStatementContext) IsAdminCancelRepairTableStatementContext() {}

func NewAdminCancelRepairTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminCancelRepairTableStatementContext {
	var p = new(AdminCancelRepairTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_adminCancelRepairTableStatement

	return p
}

func (s *AdminCancelRepairTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminCancelRepairTableStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADMIN, 0)
}

func (s *AdminCancelRepairTableStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCANCEL, 0)
}

func (s *AdminCancelRepairTableStatementContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPAIR, 0)
}

func (s *AdminCancelRepairTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *AdminCancelRepairTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AdminCancelRepairTableStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *AdminCancelRepairTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCancelRepairTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminCancelRepairTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAdminCancelRepairTableStatement(s)
	}
}

func (s *AdminCancelRepairTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAdminCancelRepairTableStatement(s)
	}
}

func (s *AdminCancelRepairTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAdminCancelRepairTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AdminCancelRepairTableStatement() (localctx IAdminCancelRepairTableStatementContext) {
	localctx = NewAdminCancelRepairTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, DorisSQLParserRULE_adminCancelRepairTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2360)
		p.Match(DorisSQLParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2361)
		p.Match(DorisSQLParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2362)
		p.Match(DorisSQLParserREPAIR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2363)
		p.Match(DorisSQLParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2364)
		p.QualifiedName()
	}
	p.SetState(2366)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPARTITION || _la == DorisSQLParserPARTITIONS || _la == DorisSQLParserTEMPORARY {
		{
			p.SetState(2365)
			p.PartitionNames()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminCheckTabletsStatementContext is an interface to support dynamic dispatch.
type IAdminCheckTabletsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	TabletList() ITabletListContext
	PROPERTIES() antlr.TerminalNode
	Property() IPropertyContext

	// IsAdminCheckTabletsStatementContext differentiates from other interfaces.
	IsAdminCheckTabletsStatementContext()
}

type AdminCheckTabletsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminCheckTabletsStatementContext() *AdminCheckTabletsStatementContext {
	var p = new(AdminCheckTabletsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_adminCheckTabletsStatement
	return p
}

func InitEmptyAdminCheckTabletsStatementContext(p *AdminCheckTabletsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_adminCheckTabletsStatement
}

func (*AdminCheckTabletsStatementContext) IsAdminCheckTabletsStatementContext() {}

func NewAdminCheckTabletsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminCheckTabletsStatementContext {
	var p = new(AdminCheckTabletsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_adminCheckTabletsStatement

	return p
}

func (s *AdminCheckTabletsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminCheckTabletsStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADMIN, 0)
}

func (s *AdminCheckTabletsStatementContext) CHECK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCHECK, 0)
}

func (s *AdminCheckTabletsStatementContext) TabletList() ITabletListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabletListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabletListContext)
}

func (s *AdminCheckTabletsStatementContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROPERTIES, 0)
}

func (s *AdminCheckTabletsStatementContext) Property() IPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *AdminCheckTabletsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCheckTabletsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminCheckTabletsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAdminCheckTabletsStatement(s)
	}
}

func (s *AdminCheckTabletsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAdminCheckTabletsStatement(s)
	}
}

func (s *AdminCheckTabletsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAdminCheckTabletsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AdminCheckTabletsStatement() (localctx IAdminCheckTabletsStatementContext) {
	localctx = NewAdminCheckTabletsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, DorisSQLParserRULE_adminCheckTabletsStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2368)
		p.Match(DorisSQLParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2369)
		p.Match(DorisSQLParserCHECK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2370)
		p.TabletList()
	}
	{
		p.SetState(2371)
		p.Match(DorisSQLParserPROPERTIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2372)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2373)
		p.Property()
	}
	{
		p.SetState(2374)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminSetPartitionVersionContext is an interface to support dynamic dispatch.
type IAdminSetPartitionVersionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionId returns the partitionId token.
	GetPartitionId() antlr.Token

	// GetVersion returns the version token.
	GetVersion() antlr.Token

	// SetPartitionId sets the partitionId token.
	SetPartitionId(antlr.Token)

	// SetVersion sets the version token.
	SetVersion(antlr.Token)

	// GetPartitionName returns the partitionName rule contexts.
	GetPartitionName() IIdentifierOrStringContext

	// SetPartitionName sets the partitionName rule contexts.
	SetPartitionName(IIdentifierOrStringContext)

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SET() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PARTITION() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	TO() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsAdminSetPartitionVersionContext differentiates from other interfaces.
	IsAdminSetPartitionVersionContext()
}

type AdminSetPartitionVersionContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	partitionName IIdentifierOrStringContext
	partitionId   antlr.Token
	version       antlr.Token
}

func NewEmptyAdminSetPartitionVersionContext() *AdminSetPartitionVersionContext {
	var p = new(AdminSetPartitionVersionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_adminSetPartitionVersion
	return p
}

func InitEmptyAdminSetPartitionVersionContext(p *AdminSetPartitionVersionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_adminSetPartitionVersion
}

func (*AdminSetPartitionVersionContext) IsAdminSetPartitionVersionContext() {}

func NewAdminSetPartitionVersionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminSetPartitionVersionContext {
	var p = new(AdminSetPartitionVersionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_adminSetPartitionVersion

	return p
}

func (s *AdminSetPartitionVersionContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminSetPartitionVersionContext) GetPartitionId() antlr.Token { return s.partitionId }

func (s *AdminSetPartitionVersionContext) GetVersion() antlr.Token { return s.version }

func (s *AdminSetPartitionVersionContext) SetPartitionId(v antlr.Token) { s.partitionId = v }

func (s *AdminSetPartitionVersionContext) SetVersion(v antlr.Token) { s.version = v }

func (s *AdminSetPartitionVersionContext) GetPartitionName() IIdentifierOrStringContext {
	return s.partitionName
}

func (s *AdminSetPartitionVersionContext) SetPartitionName(v IIdentifierOrStringContext) {
	s.partitionName = v
}

func (s *AdminSetPartitionVersionContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADMIN, 0)
}

func (s *AdminSetPartitionVersionContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *AdminSetPartitionVersionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *AdminSetPartitionVersionContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AdminSetPartitionVersionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPARTITION, 0)
}

func (s *AdminSetPartitionVersionContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVERSION, 0)
}

func (s *AdminSetPartitionVersionContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTO, 0)
}

func (s *AdminSetPartitionVersionContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserINTEGER_VALUE)
}

func (s *AdminSetPartitionVersionContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, i)
}

func (s *AdminSetPartitionVersionContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AdminSetPartitionVersionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetPartitionVersionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminSetPartitionVersionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAdminSetPartitionVersion(s)
	}
}

func (s *AdminSetPartitionVersionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAdminSetPartitionVersion(s)
	}
}

func (s *AdminSetPartitionVersionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAdminSetPartitionVersion(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AdminSetPartitionVersion() (localctx IAdminSetPartitionVersionContext) {
	localctx = NewAdminSetPartitionVersionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, DorisSQLParserRULE_adminSetPartitionVersion)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2376)
		p.Match(DorisSQLParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2377)
		p.Match(DorisSQLParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2378)
		p.Match(DorisSQLParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2379)
		p.QualifiedName()
	}
	{
		p.SetState(2380)
		p.Match(DorisSQLParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2381)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2384)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserACCESS, DorisSQLParserACTIVE, DorisSQLParserADMIN, DorisSQLParserADVISOR, DorisSQLParserAFTER, DorisSQLParserAGGREGATE, DorisSQLParserANTI, DorisSQLParserAPPLY, DorisSQLParserARRAY_AGG, DorisSQLParserARRAY_AGG_DISTINCT, DorisSQLParserASYNC, DorisSQLParserAUTHORS, DorisSQLParserAUTHENTICATION, DorisSQLParserAUTOMATED, DorisSQLParserAUTO_INCREMENT, DorisSQLParserAVG, DorisSQLParserBACKEND, DorisSQLParserBACKENDS, DorisSQLParserBACKUP, DorisSQLParserBASE, DorisSQLParserBASELINE, DorisSQLParserBEGIN, DorisSQLParserBINARY, DorisSQLParserBITMAP_UNION, DorisSQLParserBLACKHOLE, DorisSQLParserBLACKLIST, DorisSQLParserBODY, DorisSQLParserBOOLEAN, DorisSQLParserBRANCH, DorisSQLParserBROKER, DorisSQLParserBUCKETS, DorisSQLParserBUILTIN, DorisSQLParserCACHE, DorisSQLParserCANCEL, DorisSQLParserCAST, DorisSQLParserCATALOG, DorisSQLParserCATALOGS, DorisSQLParserCEIL, DorisSQLParserCHAIN, DorisSQLParserCHARSET, DorisSQLParserCLEAN, DorisSQLParserCLEAR, DorisSQLParserCLUSTER, DorisSQLParserCLUSTERS, DorisSQLParserCNGROUP, DorisSQLParserCNGROUPS, DorisSQLParserCOLLATION, DorisSQLParserCOLUMNS, DorisSQLParserCOMMENT, DorisSQLParserCOMMIT, DorisSQLParserCOMMITTED, DorisSQLParserCOMPACT, DorisSQLParserCOMPUTE, DorisSQLParserCONFIG, DorisSQLParserCONNECTION, DorisSQLParserCONSISTENT, DorisSQLParserCOSTS, DorisSQLParserCOUNT, DorisSQLParserCUME_DIST, DorisSQLParserCUMULATIVE, DorisSQLParserCURRENT, DorisSQLParserDATA, DorisSQLParserDATACACHE, DorisSQLParserDATE, DorisSQLParserDATETIME, DorisSQLParserDAY, DorisSQLParserDAYS, DorisSQLParserDEALLOCATE, DorisSQLParserDECOMMISSION, DorisSQLParserDIALECT, DorisSQLParserDICTIONARY, DorisSQLParserDICTIONARY_GET, DorisSQLParserDISABLE, DorisSQLParserDISTRIBUTED, DorisSQLParserDISTRIBUTION, DorisSQLParserDUPLICATE, DorisSQLParserDYNAMIC, DorisSQLParserENABLE, DorisSQLParserENCLOSE, DorisSQLParserEND, DorisSQLParserENGINE, DorisSQLParserENGINES, DorisSQLParserERRORS, DorisSQLParserESCAPE, DorisSQLParserEVENTS, DorisSQLParserEXCEPT, DorisSQLParserEXCLUDE, DorisSQLParserEXECUTE, DorisSQLParserEXPORT, DorisSQLParserEXTERNAL, DorisSQLParserEXTRACT, DorisSQLParserEVERY, DorisSQLParserFAILPOINT, DorisSQLParserFAILPOINTS, DorisSQLParserFIELDS, DorisSQLParserFILE, DorisSQLParserFILTER, DorisSQLParserFIRST, DorisSQLParserFLOOR, DorisSQLParserFN, DorisSQLParserFOLLOWING, DorisSQLParserFOLLOWER, DorisSQLParserFORMAT, DorisSQLParserFREE, DorisSQLParserFRONTEND, DorisSQLParserFRONTENDS, DorisSQLParserFUNCTIONS, DorisSQLParserGLOBAL, DorisSQLParserGRANTS, DorisSQLParserGROUP_CONCAT, DorisSQLParserHASH, DorisSQLParserHELP, DorisSQLParserHISTOGRAM, DorisSQLParserHLL_UNION, DorisSQLParserHOST, DorisSQLParserHOUR, DorisSQLParserHOURS, DorisSQLParserHUB, DorisSQLParserIDENTIFIED, DorisSQLParserIMPERSONATE, DorisSQLParserIMAGE, DorisSQLParserINACTIVE, DorisSQLParserINCREMENTAL, DorisSQLParserINDEXES, DorisSQLParserINSTALL, DorisSQLParserINTEGRATION, DorisSQLParserINTEGRATIONS, DorisSQLParserINTERMEDIATE, DorisSQLParserINTERVAL, DorisSQLParserOVERWRITE, DorisSQLParserISOLATION, DorisSQLParserJOB, DorisSQLParserLABEL, DorisSQLParserLAST, DorisSQLParserLESS, DorisSQLParserLEVEL, DorisSQLParserLIST, DorisSQLParserLOCAL, DorisSQLParserLOCATION, DorisSQLParserLOCATIONS, DorisSQLParserLOGS, DorisSQLParserLOGICAL, DorisSQLParserMANUAL, DorisSQLParserMAP, DorisSQLParserMAPPING, DorisSQLParserMAPPINGS, DorisSQLParserMASKING, DorisSQLParserMATCH, DorisSQLParserMATERIALIZED, DorisSQLParserMAX, DorisSQLParserMERGE, DorisSQLParserMIN, DorisSQLParserMINUTE, DorisSQLParserMINUTES, DorisSQLParserMINUS, DorisSQLParserMETA, DorisSQLParserMODE, DorisSQLParserMODIFY, DorisSQLParserMONTH, DorisSQLParserMULTIPLE, DorisSQLParserNAME, DorisSQLParserNAMES, DorisSQLParserNEGATIVE, DorisSQLParserNGRAMBF, DorisSQLParserNO, DorisSQLParserNODE, DorisSQLParserNODES, DorisSQLParserNONE, DorisSQLParserNULLS, DorisSQLParserNUMBER, DorisSQLParserNUMERIC, DorisSQLParserOBSERVER, DorisSQLParserOF, DorisSQLParserOFF, DorisSQLParserOFFSET, DorisSQLParserONLY, DorisSQLParserOPEN, DorisSQLParserOPERATE, DorisSQLParserOPTIMIZER, DorisSQLParserOPTION, DorisSQLParserPARTITIONS, DorisSQLParserPASSWORD, DorisSQLParserPATH, DorisSQLParserPAUSE, DorisSQLParserPENDING, DorisSQLParserPERCENT_RANK, DorisSQLParserPERCENTILE_UNION, DorisSQLParserPLAN, DorisSQLParserPLUGIN, DorisSQLParserPLUGINS, DorisSQLParserPIPE, DorisSQLParserPIPES, DorisSQLParserPIVOT, DorisSQLParserPOLICY, DorisSQLParserPOLICIES, DorisSQLParserPRECEDING, DorisSQLParserPREDICATE, DorisSQLParserPRIORITY, DorisSQLParserPRIVILEGES, DorisSQLParserPROBABILITY, DorisSQLParserPROC, DorisSQLParserPROCESSLIST, DorisSQLParserPROFILE, DorisSQLParserPROFILELIST, DorisSQLParserPROPERTIES, DorisSQLParserPROPERTY, DorisSQLParserPROVIDER, DorisSQLParserPROVIDERS, DorisSQLParserQUALIFY, DorisSQLParserQUARTER, DorisSQLParserQUERY, DorisSQLParserQUERIES, DorisSQLParserQUEUE, DorisSQLParserQUOTA, DorisSQLParserRANDOM, DorisSQLParserRANK, DorisSQLParserREASON, DorisSQLParserRECOVER, DorisSQLParserREFRESH, DorisSQLParserREWRITE, DorisSQLParserREMOVE, DorisSQLParserREPAIR, DorisSQLParserREPEATABLE, DorisSQLParserREPLACE_IF_NOT_NULL, DorisSQLParserREPLICA, DorisSQLParserREPOSITORY, DorisSQLParserREPOSITORIES, DorisSQLParserRESOURCE, DorisSQLParserRESOURCES, DorisSQLParserRESTORE, DorisSQLParserRESUME, DorisSQLParserRETAIN, DorisSQLParserRETENTION, DorisSQLParserRETURNS, DorisSQLParserRETRY, DorisSQLParserREVERT, DorisSQLParserROLE, DorisSQLParserROLES, DorisSQLParserROLLBACK, DorisSQLParserROLLUP, DorisSQLParserROUTINE, DorisSQLParserROW, DorisSQLParserRULE, DorisSQLParserRULES, DorisSQLParserRUNNING, DorisSQLParserSAMPLE, DorisSQLParserSCHEDULE, DorisSQLParserSCHEDULER, DorisSQLParserSECOND, DorisSQLParserSECURITY, DorisSQLParserSEMI, DorisSQLParserSEPARATOR, DorisSQLParserSERIALIZABLE, DorisSQLParserSESSION, DorisSQLParserSETS, DorisSQLParserSIGNED, DorisSQLParserSKIP_HEADER, DorisSQLParserSNAPSHOT, DorisSQLParserSNAPSHOTS, DorisSQLParserSQLBLACKLIST, DorisSQLParserSTART, DorisSQLParserSTATS, DorisSQLParserSTATUS, DorisSQLParserSTOP, DorisSQLParserSTORAGE, DorisSQLParserSTREAM, DorisSQLParserSTRING, DorisSQLParserSUBMIT, DorisSQLParserSUM, DorisSQLParserSUSPEND, DorisSQLParserSYNC, DorisSQLParserSYSTEM_TIME, DorisSQLParserSWAP, DorisSQLParserSTRUCT, DorisSQLParserTABLES, DorisSQLParserTABLET, DorisSQLParserTABLETS, DorisSQLParserTAG, DorisSQLParserTASK, DorisSQLParserTEMPORARY, DorisSQLParserTHAN, DorisSQLParserTIME, DorisSQLParserTIMES, DorisSQLParserTIMESTAMP, DorisSQLParserTIMESTAMPADD, DorisSQLParserTIMESTAMPDIFF, DorisSQLParserTRANSACTION, DorisSQLParserTRANSLATE, DorisSQLParserTRACE, DorisSQLParserTRIGGERS, DorisSQLParserTRIM_SPACE, DorisSQLParserTRUNCATE, DorisSQLParserTYPE, DorisSQLParserTYPES, DorisSQLParserUNBOUNDED, DorisSQLParserUNCOMMITTED, DorisSQLParserUNINSTALL, DorisSQLParserUNSET, DorisSQLParserUSAGE, DorisSQLParserUSER, DorisSQLParserUSERS, DorisSQLParserVALUE, DorisSQLParserVARBINARY, DorisSQLParserVARIABLES, DorisSQLParserVECTOR, DorisSQLParserVERBOSE, DorisSQLParserVERSION, DorisSQLParserVIEW, DorisSQLParserVIEWS, DorisSQLParserVOLUME, DorisSQLParserVOLUMES, DorisSQLParserWAREHOUSE, DorisSQLParserWAREHOUSES, DorisSQLParserWARNINGS, DorisSQLParserWEEK, DorisSQLParserWHITELIST, DorisSQLParserWORK, DorisSQLParserWRITE, DorisSQLParserYEAR, DorisSQLParserLOCK, DorisSQLParserUNLOCK, DorisSQLParserLOW_PRIORITY, DorisSQLParserDISK, DorisSQLParserBEFORE, DorisSQLParserFIELD, DorisSQLParserPERSISTENT, DorisSQLParserARRAY_ELEMENT, DorisSQLParserSINGLE_QUOTED_TEXT, DorisSQLParserDOUBLE_QUOTED_TEXT, DorisSQLParserLETTER_IDENTIFIER, DorisSQLParserDIGIT_IDENTIFIER, DorisSQLParserBACKQUOTED_IDENTIFIER, DorisSQLParserDOTDOTDOT:
		{
			p.SetState(2382)

			var _x = p.IdentifierOrString()

			localctx.(*AdminSetPartitionVersionContext).partitionName = _x
		}

	case DorisSQLParserINTEGER_VALUE:
		{
			p.SetState(2383)

			var _m = p.Match(DorisSQLParserINTEGER_VALUE)

			localctx.(*AdminSetPartitionVersionContext).partitionId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(2386)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2387)
		p.Match(DorisSQLParserVERSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2388)
		p.Match(DorisSQLParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2389)

		var _m = p.Match(DorisSQLParserINTEGER_VALUE)

		localctx.(*AdminSetPartitionVersionContext).version = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKillStatementContext is an interface to support dynamic dispatch.
type IKillStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetConnId returns the connId token.
	GetConnId() antlr.Token

	// SetConnId sets the connId token.
	SetConnId(antlr.Token)

	// GetQueryId returns the queryId rule contexts.
	GetQueryId() IStringContext

	// SetQueryId sets the queryId rule contexts.
	SetQueryId(IStringContext)

	// Getter signatures
	KILL() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	String_() IStringContext
	CONNECTION() antlr.TerminalNode

	// IsKillStatementContext differentiates from other interfaces.
	IsKillStatementContext()
}

type KillStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	connId  antlr.Token
	queryId IStringContext
}

func NewEmptyKillStatementContext() *KillStatementContext {
	var p = new(KillStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_killStatement
	return p
}

func InitEmptyKillStatementContext(p *KillStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_killStatement
}

func (*KillStatementContext) IsKillStatementContext() {}

func NewKillStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KillStatementContext {
	var p = new(KillStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_killStatement

	return p
}

func (s *KillStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *KillStatementContext) GetConnId() antlr.Token { return s.connId }

func (s *KillStatementContext) SetConnId(v antlr.Token) { s.connId = v }

func (s *KillStatementContext) GetQueryId() IStringContext { return s.queryId }

func (s *KillStatementContext) SetQueryId(v IStringContext) { s.queryId = v }

func (s *KillStatementContext) KILL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserKILL, 0)
}

func (s *KillStatementContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserQUERY, 0)
}

func (s *KillStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, 0)
}

func (s *KillStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *KillStatementContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCONNECTION, 0)
}

func (s *KillStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KillStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterKillStatement(s)
	}
}

func (s *KillStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitKillStatement(s)
	}
}

func (s *KillStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitKillStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) KillStatement() (localctx IKillStatementContext) {
	localctx = NewKillStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, DorisSQLParserRULE_killStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2391)
		p.Match(DorisSQLParserKILL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2396)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserCONNECTION, DorisSQLParserINTEGER_VALUE, DorisSQLParserSINGLE_QUOTED_TEXT, DorisSQLParserDOUBLE_QUOTED_TEXT:
		p.SetState(2393)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserCONNECTION {
			{
				p.SetState(2392)
				p.Match(DorisSQLParserCONNECTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DorisSQLParserQUERY:
		{
			p.SetState(2395)
			p.Match(DorisSQLParserQUERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(2400)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserINTEGER_VALUE:
		{
			p.SetState(2398)

			var _m = p.Match(DorisSQLParserINTEGER_VALUE)

			localctx.(*KillStatementContext).connId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserSINGLE_QUOTED_TEXT, DorisSQLParserDOUBLE_QUOTED_TEXT:
		{
			p.SetState(2399)

			var _x = p.String_()

			localctx.(*KillStatementContext).queryId = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISyncStatementContext is an interface to support dynamic dispatch.
type ISyncStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SYNC() antlr.TerminalNode

	// IsSyncStatementContext differentiates from other interfaces.
	IsSyncStatementContext()
}

type SyncStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyncStatementContext() *SyncStatementContext {
	var p = new(SyncStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_syncStatement
	return p
}

func InitEmptySyncStatementContext(p *SyncStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_syncStatement
}

func (*SyncStatementContext) IsSyncStatementContext() {}

func NewSyncStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyncStatementContext {
	var p = new(SyncStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_syncStatement

	return p
}

func (s *SyncStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SyncStatementContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSYNC, 0)
}

func (s *SyncStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyncStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyncStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSyncStatement(s)
	}
}

func (s *SyncStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSyncStatement(s)
	}
}

func (s *SyncStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSyncStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SyncStatement() (localctx ISyncStatementContext) {
	localctx = NewSyncStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, DorisSQLParserRULE_syncStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2402)
		p.Match(DorisSQLParserSYNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminSetAutomatedSnapshotOnStatementContext is an interface to support dynamic dispatch.
type IAdminSetAutomatedSnapshotOnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSvName returns the svName rule contexts.
	GetSvName() IIdentifierContext

	// SetSvName sets the svName rule contexts.
	SetSvName(IIdentifierContext)

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SET() antlr.TerminalNode
	AUTOMATED() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	ON() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsAdminSetAutomatedSnapshotOnStatementContext differentiates from other interfaces.
	IsAdminSetAutomatedSnapshotOnStatementContext()
}

type AdminSetAutomatedSnapshotOnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	svName IIdentifierContext
}

func NewEmptyAdminSetAutomatedSnapshotOnStatementContext() *AdminSetAutomatedSnapshotOnStatementContext {
	var p = new(AdminSetAutomatedSnapshotOnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_adminSetAutomatedSnapshotOnStatement
	return p
}

func InitEmptyAdminSetAutomatedSnapshotOnStatementContext(p *AdminSetAutomatedSnapshotOnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_adminSetAutomatedSnapshotOnStatement
}

func (*AdminSetAutomatedSnapshotOnStatementContext) IsAdminSetAutomatedSnapshotOnStatementContext() {}

func NewAdminSetAutomatedSnapshotOnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminSetAutomatedSnapshotOnStatementContext {
	var p = new(AdminSetAutomatedSnapshotOnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_adminSetAutomatedSnapshotOnStatement

	return p
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminSetAutomatedSnapshotOnStatementContext) GetSvName() IIdentifierContext { return s.svName }

func (s *AdminSetAutomatedSnapshotOnStatementContext) SetSvName(v IIdentifierContext) { s.svName = v }

func (s *AdminSetAutomatedSnapshotOnStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADMIN, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) AUTOMATED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAUTOMATED, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCLUSTER, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSNAPSHOT, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTORAGE, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVOLUME, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAdminSetAutomatedSnapshotOnStatement(s)
	}
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAdminSetAutomatedSnapshotOnStatement(s)
	}
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAdminSetAutomatedSnapshotOnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AdminSetAutomatedSnapshotOnStatement() (localctx IAdminSetAutomatedSnapshotOnStatementContext) {
	localctx = NewAdminSetAutomatedSnapshotOnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, DorisSQLParserRULE_adminSetAutomatedSnapshotOnStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2404)
		p.Match(DorisSQLParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2405)
		p.Match(DorisSQLParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2406)
		p.Match(DorisSQLParserAUTOMATED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2407)
		p.Match(DorisSQLParserCLUSTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2408)
		p.Match(DorisSQLParserSNAPSHOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2409)
		p.Match(DorisSQLParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2413)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserSTORAGE {
		{
			p.SetState(2410)
			p.Match(DorisSQLParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2411)
			p.Match(DorisSQLParserVOLUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2412)

			var _x = p.Identifier()

			localctx.(*AdminSetAutomatedSnapshotOnStatementContext).svName = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminSetAutomatedSnapshotOffStatementContext is an interface to support dynamic dispatch.
type IAdminSetAutomatedSnapshotOffStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SET() antlr.TerminalNode
	AUTOMATED() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	OFF() antlr.TerminalNode

	// IsAdminSetAutomatedSnapshotOffStatementContext differentiates from other interfaces.
	IsAdminSetAutomatedSnapshotOffStatementContext()
}

type AdminSetAutomatedSnapshotOffStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminSetAutomatedSnapshotOffStatementContext() *AdminSetAutomatedSnapshotOffStatementContext {
	var p = new(AdminSetAutomatedSnapshotOffStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_adminSetAutomatedSnapshotOffStatement
	return p
}

func InitEmptyAdminSetAutomatedSnapshotOffStatementContext(p *AdminSetAutomatedSnapshotOffStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_adminSetAutomatedSnapshotOffStatement
}

func (*AdminSetAutomatedSnapshotOffStatementContext) IsAdminSetAutomatedSnapshotOffStatementContext() {
}

func NewAdminSetAutomatedSnapshotOffStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminSetAutomatedSnapshotOffStatementContext {
	var p = new(AdminSetAutomatedSnapshotOffStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_adminSetAutomatedSnapshotOffStatement

	return p
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminSetAutomatedSnapshotOffStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADMIN, 0)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) AUTOMATED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAUTOMATED, 0)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCLUSTER, 0)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSNAPSHOT, 0)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) OFF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOFF, 0)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAdminSetAutomatedSnapshotOffStatement(s)
	}
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAdminSetAutomatedSnapshotOffStatement(s)
	}
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAdminSetAutomatedSnapshotOffStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AdminSetAutomatedSnapshotOffStatement() (localctx IAdminSetAutomatedSnapshotOffStatementContext) {
	localctx = NewAdminSetAutomatedSnapshotOffStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, DorisSQLParserRULE_adminSetAutomatedSnapshotOffStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2415)
		p.Match(DorisSQLParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2416)
		p.Match(DorisSQLParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2417)
		p.Match(DorisSQLParserAUTOMATED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2418)
		p.Match(DorisSQLParserCLUSTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2419)
		p.Match(DorisSQLParserSNAPSHOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2420)
		p.Match(DorisSQLParserOFF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterSystemStatementContext is an interface to support dynamic dispatch.
type IAlterSystemStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	AlterClause() IAlterClauseContext

	// IsAlterSystemStatementContext differentiates from other interfaces.
	IsAlterSystemStatementContext()
}

type AlterSystemStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterSystemStatementContext() *AlterSystemStatementContext {
	var p = new(AlterSystemStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterSystemStatement
	return p
}

func InitEmptyAlterSystemStatementContext(p *AlterSystemStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterSystemStatement
}

func (*AlterSystemStatementContext) IsAlterSystemStatementContext() {}

func NewAlterSystemStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterSystemStatementContext {
	var p = new(AlterSystemStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_alterSystemStatement

	return p
}

func (s *AlterSystemStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterSystemStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *AlterSystemStatementContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSYSTEM, 0)
}

func (s *AlterSystemStatementContext) AlterClause() IAlterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterClauseContext)
}

func (s *AlterSystemStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSystemStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterSystemStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAlterSystemStatement(s)
	}
}

func (s *AlterSystemStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAlterSystemStatement(s)
	}
}

func (s *AlterSystemStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAlterSystemStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AlterSystemStatement() (localctx IAlterSystemStatementContext) {
	localctx = NewAlterSystemStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, DorisSQLParserRULE_alterSystemStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2422)
		p.Match(DorisSQLParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2423)
		p.Match(DorisSQLParserSYSTEM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2424)
		p.AlterClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelAlterSystemStatementContext is an interface to support dynamic dispatch.
type ICancelAlterSystemStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	DECOMMISSION() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsCancelAlterSystemStatementContext differentiates from other interfaces.
	IsCancelAlterSystemStatementContext()
}

type CancelAlterSystemStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelAlterSystemStatementContext() *CancelAlterSystemStatementContext {
	var p = new(CancelAlterSystemStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cancelAlterSystemStatement
	return p
}

func InitEmptyCancelAlterSystemStatementContext(p *CancelAlterSystemStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cancelAlterSystemStatement
}

func (*CancelAlterSystemStatementContext) IsCancelAlterSystemStatementContext() {}

func NewCancelAlterSystemStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelAlterSystemStatementContext {
	var p = new(CancelAlterSystemStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_cancelAlterSystemStatement

	return p
}

func (s *CancelAlterSystemStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelAlterSystemStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCANCEL, 0)
}

func (s *CancelAlterSystemStatementContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDECOMMISSION, 0)
}

func (s *CancelAlterSystemStatementContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBACKEND, 0)
}

func (s *CancelAlterSystemStatementContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *CancelAlterSystemStatementContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CancelAlterSystemStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelAlterSystemStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelAlterSystemStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCancelAlterSystemStatement(s)
	}
}

func (s *CancelAlterSystemStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCancelAlterSystemStatement(s)
	}
}

func (s *CancelAlterSystemStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCancelAlterSystemStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CancelAlterSystemStatement() (localctx ICancelAlterSystemStatementContext) {
	localctx = NewCancelAlterSystemStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, DorisSQLParserRULE_cancelAlterSystemStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2426)
		p.Match(DorisSQLParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2427)
		p.Match(DorisSQLParserDECOMMISSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2428)
		p.Match(DorisSQLParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2429)
		p.String_()
	}
	p.SetState(2434)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(2430)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2431)
			p.String_()
		}

		p.SetState(2436)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowComputeNodesStatementContext is an interface to support dynamic dispatch.
type IShowComputeNodesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	COMPUTE() antlr.TerminalNode
	NODES() antlr.TerminalNode

	// IsShowComputeNodesStatementContext differentiates from other interfaces.
	IsShowComputeNodesStatementContext()
}

type ShowComputeNodesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowComputeNodesStatementContext() *ShowComputeNodesStatementContext {
	var p = new(ShowComputeNodesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showComputeNodesStatement
	return p
}

func InitEmptyShowComputeNodesStatementContext(p *ShowComputeNodesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showComputeNodesStatement
}

func (*ShowComputeNodesStatementContext) IsShowComputeNodesStatementContext() {}

func NewShowComputeNodesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowComputeNodesStatementContext {
	var p = new(ShowComputeNodesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showComputeNodesStatement

	return p
}

func (s *ShowComputeNodesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowComputeNodesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowComputeNodesStatementContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOMPUTE, 0)
}

func (s *ShowComputeNodesStatementContext) NODES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNODES, 0)
}

func (s *ShowComputeNodesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowComputeNodesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowComputeNodesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowComputeNodesStatement(s)
	}
}

func (s *ShowComputeNodesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowComputeNodesStatement(s)
	}
}

func (s *ShowComputeNodesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowComputeNodesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowComputeNodesStatement() (localctx IShowComputeNodesStatementContext) {
	localctx = NewShowComputeNodesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, DorisSQLParserRULE_showComputeNodesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2437)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2438)
		p.Match(DorisSQLParserCOMPUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2439)
		p.Match(DorisSQLParserNODES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateExternalCatalogStatementContext is an interface to support dynamic dispatch.
type ICreateExternalCatalogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalogName returns the catalogName rule contexts.
	GetCatalogName() IIdentifierOrStringContext

	// SetCatalogName sets the catalogName rule contexts.
	SetCatalogName(IIdentifierOrStringContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	Properties() IPropertiesContext
	IdentifierOrString() IIdentifierOrStringContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Comment() ICommentContext

	// IsCreateExternalCatalogStatementContext differentiates from other interfaces.
	IsCreateExternalCatalogStatementContext()
}

type CreateExternalCatalogStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	catalogName IIdentifierOrStringContext
}

func NewEmptyCreateExternalCatalogStatementContext() *CreateExternalCatalogStatementContext {
	var p = new(CreateExternalCatalogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createExternalCatalogStatement
	return p
}

func InitEmptyCreateExternalCatalogStatementContext(p *CreateExternalCatalogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createExternalCatalogStatement
}

func (*CreateExternalCatalogStatementContext) IsCreateExternalCatalogStatementContext() {}

func NewCreateExternalCatalogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateExternalCatalogStatementContext {
	var p = new(CreateExternalCatalogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createExternalCatalogStatement

	return p
}

func (s *CreateExternalCatalogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateExternalCatalogStatementContext) GetCatalogName() IIdentifierOrStringContext {
	return s.catalogName
}

func (s *CreateExternalCatalogStatementContext) SetCatalogName(v IIdentifierOrStringContext) {
	s.catalogName = v
}

func (s *CreateExternalCatalogStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateExternalCatalogStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXTERNAL, 0)
}

func (s *CreateExternalCatalogStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCATALOG, 0)
}

func (s *CreateExternalCatalogStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateExternalCatalogStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CreateExternalCatalogStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *CreateExternalCatalogStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *CreateExternalCatalogStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *CreateExternalCatalogStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateExternalCatalogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateExternalCatalogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateExternalCatalogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateExternalCatalogStatement(s)
	}
}

func (s *CreateExternalCatalogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateExternalCatalogStatement(s)
	}
}

func (s *CreateExternalCatalogStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateExternalCatalogStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateExternalCatalogStatement() (localctx ICreateExternalCatalogStatementContext) {
	localctx = NewCreateExternalCatalogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, DorisSQLParserRULE_createExternalCatalogStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2441)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2442)
		p.Match(DorisSQLParserEXTERNAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2443)
		p.Match(DorisSQLParserCATALOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(2444)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2445)
			p.Match(DorisSQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2446)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2449)

		var _x = p.IdentifierOrString()

		localctx.(*CreateExternalCatalogStatementContext).catalogName = _x
	}
	p.SetState(2451)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserCOMMENT {
		{
			p.SetState(2450)
			p.Comment()
		}

	}
	{
		p.SetState(2453)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCreateExternalCatalogStatementContext is an interface to support dynamic dispatch.
type IShowCreateExternalCatalogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalogName returns the catalogName rule contexts.
	GetCatalogName() IIdentifierOrStringContext

	// SetCatalogName sets the catalogName rule contexts.
	SetCatalogName(IIdentifierOrStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsShowCreateExternalCatalogStatementContext differentiates from other interfaces.
	IsShowCreateExternalCatalogStatementContext()
}

type ShowCreateExternalCatalogStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	catalogName IIdentifierOrStringContext
}

func NewEmptyShowCreateExternalCatalogStatementContext() *ShowCreateExternalCatalogStatementContext {
	var p = new(ShowCreateExternalCatalogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showCreateExternalCatalogStatement
	return p
}

func InitEmptyShowCreateExternalCatalogStatementContext(p *ShowCreateExternalCatalogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showCreateExternalCatalogStatement
}

func (*ShowCreateExternalCatalogStatementContext) IsShowCreateExternalCatalogStatementContext() {}

func NewShowCreateExternalCatalogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCreateExternalCatalogStatementContext {
	var p = new(ShowCreateExternalCatalogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showCreateExternalCatalogStatement

	return p
}

func (s *ShowCreateExternalCatalogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCreateExternalCatalogStatementContext) GetCatalogName() IIdentifierOrStringContext {
	return s.catalogName
}

func (s *ShowCreateExternalCatalogStatementContext) SetCatalogName(v IIdentifierOrStringContext) {
	s.catalogName = v
}

func (s *ShowCreateExternalCatalogStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowCreateExternalCatalogStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *ShowCreateExternalCatalogStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCATALOG, 0)
}

func (s *ShowCreateExternalCatalogStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *ShowCreateExternalCatalogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateExternalCatalogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCreateExternalCatalogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowCreateExternalCatalogStatement(s)
	}
}

func (s *ShowCreateExternalCatalogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowCreateExternalCatalogStatement(s)
	}
}

func (s *ShowCreateExternalCatalogStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowCreateExternalCatalogStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowCreateExternalCatalogStatement() (localctx IShowCreateExternalCatalogStatementContext) {
	localctx = NewShowCreateExternalCatalogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, DorisSQLParserRULE_showCreateExternalCatalogStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2455)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2456)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2457)
		p.Match(DorisSQLParserCATALOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2458)

		var _x = p.IdentifierOrString()

		localctx.(*ShowCreateExternalCatalogStatementContext).catalogName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropExternalCatalogStatementContext is an interface to support dynamic dispatch.
type IDropExternalCatalogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalogName returns the catalogName rule contexts.
	GetCatalogName() IIdentifierOrStringContext

	// SetCatalogName sets the catalogName rule contexts.
	SetCatalogName(IIdentifierOrStringContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropExternalCatalogStatementContext differentiates from other interfaces.
	IsDropExternalCatalogStatementContext()
}

type DropExternalCatalogStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	catalogName IIdentifierOrStringContext
}

func NewEmptyDropExternalCatalogStatementContext() *DropExternalCatalogStatementContext {
	var p = new(DropExternalCatalogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropExternalCatalogStatement
	return p
}

func InitEmptyDropExternalCatalogStatementContext(p *DropExternalCatalogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropExternalCatalogStatement
}

func (*DropExternalCatalogStatementContext) IsDropExternalCatalogStatementContext() {}

func NewDropExternalCatalogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropExternalCatalogStatementContext {
	var p = new(DropExternalCatalogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropExternalCatalogStatement

	return p
}

func (s *DropExternalCatalogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropExternalCatalogStatementContext) GetCatalogName() IIdentifierOrStringContext {
	return s.catalogName
}

func (s *DropExternalCatalogStatementContext) SetCatalogName(v IIdentifierOrStringContext) {
	s.catalogName = v
}

func (s *DropExternalCatalogStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropExternalCatalogStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCATALOG, 0)
}

func (s *DropExternalCatalogStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropExternalCatalogStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *DropExternalCatalogStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *DropExternalCatalogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropExternalCatalogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropExternalCatalogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropExternalCatalogStatement(s)
	}
}

func (s *DropExternalCatalogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropExternalCatalogStatement(s)
	}
}

func (s *DropExternalCatalogStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropExternalCatalogStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropExternalCatalogStatement() (localctx IDropExternalCatalogStatementContext) {
	localctx = NewDropExternalCatalogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, DorisSQLParserRULE_dropExternalCatalogStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2460)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2461)
		p.Match(DorisSQLParserCATALOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2464)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(2462)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2463)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2466)

		var _x = p.IdentifierOrString()

		localctx.(*DropExternalCatalogStatementContext).catalogName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCatalogsStatementContext is an interface to support dynamic dispatch.
type IShowCatalogsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	CATALOGS() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	String_() IStringContext

	// IsShowCatalogsStatementContext differentiates from other interfaces.
	IsShowCatalogsStatementContext()
}

type ShowCatalogsStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowCatalogsStatementContext() *ShowCatalogsStatementContext {
	var p = new(ShowCatalogsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showCatalogsStatement
	return p
}

func InitEmptyShowCatalogsStatementContext(p *ShowCatalogsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showCatalogsStatement
}

func (*ShowCatalogsStatementContext) IsShowCatalogsStatementContext() {}

func NewShowCatalogsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCatalogsStatementContext {
	var p = new(ShowCatalogsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showCatalogsStatement

	return p
}

func (s *ShowCatalogsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCatalogsStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowCatalogsStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowCatalogsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowCatalogsStatementContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCATALOGS, 0)
}

func (s *ShowCatalogsStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *ShowCatalogsStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowCatalogsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCatalogsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCatalogsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowCatalogsStatement(s)
	}
}

func (s *ShowCatalogsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowCatalogsStatement(s)
	}
}

func (s *ShowCatalogsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowCatalogsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowCatalogsStatement() (localctx IShowCatalogsStatementContext) {
	localctx = NewShowCatalogsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, DorisSQLParserRULE_showCatalogsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2468)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2469)
		p.Match(DorisSQLParserCATALOGS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserLIKE {
		{
			p.SetState(2470)
			p.Match(DorisSQLParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2471)

			var _x = p.String_()

			localctx.(*ShowCatalogsStatementContext).pattern = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterCatalogStatementContext is an interface to support dynamic dispatch.
type IAlterCatalogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalogName returns the catalogName rule contexts.
	GetCatalogName() IIdentifierOrStringContext

	// SetCatalogName sets the catalogName rule contexts.
	SetCatalogName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	ModifyPropertiesClause() IModifyPropertiesClauseContext
	IdentifierOrString() IIdentifierOrStringContext

	// IsAlterCatalogStatementContext differentiates from other interfaces.
	IsAlterCatalogStatementContext()
}

type AlterCatalogStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	catalogName IIdentifierOrStringContext
}

func NewEmptyAlterCatalogStatementContext() *AlterCatalogStatementContext {
	var p = new(AlterCatalogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterCatalogStatement
	return p
}

func InitEmptyAlterCatalogStatementContext(p *AlterCatalogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterCatalogStatement
}

func (*AlterCatalogStatementContext) IsAlterCatalogStatementContext() {}

func NewAlterCatalogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterCatalogStatementContext {
	var p = new(AlterCatalogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_alterCatalogStatement

	return p
}

func (s *AlterCatalogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterCatalogStatementContext) GetCatalogName() IIdentifierOrStringContext {
	return s.catalogName
}

func (s *AlterCatalogStatementContext) SetCatalogName(v IIdentifierOrStringContext) {
	s.catalogName = v
}

func (s *AlterCatalogStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *AlterCatalogStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCATALOG, 0)
}

func (s *AlterCatalogStatementContext) ModifyPropertiesClause() IModifyPropertiesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyPropertiesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyPropertiesClauseContext)
}

func (s *AlterCatalogStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AlterCatalogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterCatalogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterCatalogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAlterCatalogStatement(s)
	}
}

func (s *AlterCatalogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAlterCatalogStatement(s)
	}
}

func (s *AlterCatalogStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAlterCatalogStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AlterCatalogStatement() (localctx IAlterCatalogStatementContext) {
	localctx = NewAlterCatalogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, DorisSQLParserRULE_alterCatalogStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2474)
		p.Match(DorisSQLParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2475)
		p.Match(DorisSQLParserCATALOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2476)

		var _x = p.IdentifierOrString()

		localctx.(*AlterCatalogStatementContext).catalogName = _x
	}
	{
		p.SetState(2477)
		p.ModifyPropertiesClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateStorageVolumeStatementContext is an interface to support dynamic dispatch.
type ICreateStorageVolumeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStorageVolumeName returns the storageVolumeName rule contexts.
	GetStorageVolumeName() IIdentifierOrStringContext

	// SetStorageVolumeName sets the storageVolumeName rule contexts.
	SetStorageVolumeName(IIdentifierOrStringContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	TypeDesc() ITypeDescContext
	LocationsDesc() ILocationsDescContext
	IdentifierOrString() IIdentifierOrStringContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Comment() ICommentContext
	Properties() IPropertiesContext

	// IsCreateStorageVolumeStatementContext differentiates from other interfaces.
	IsCreateStorageVolumeStatementContext()
}

type CreateStorageVolumeStatementContext struct {
	antlr.BaseParserRuleContext
	parser            antlr.Parser
	storageVolumeName IIdentifierOrStringContext
}

func NewEmptyCreateStorageVolumeStatementContext() *CreateStorageVolumeStatementContext {
	var p = new(CreateStorageVolumeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createStorageVolumeStatement
	return p
}

func InitEmptyCreateStorageVolumeStatementContext(p *CreateStorageVolumeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createStorageVolumeStatement
}

func (*CreateStorageVolumeStatementContext) IsCreateStorageVolumeStatementContext() {}

func NewCreateStorageVolumeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateStorageVolumeStatementContext {
	var p = new(CreateStorageVolumeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createStorageVolumeStatement

	return p
}

func (s *CreateStorageVolumeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateStorageVolumeStatementContext) GetStorageVolumeName() IIdentifierOrStringContext {
	return s.storageVolumeName
}

func (s *CreateStorageVolumeStatementContext) SetStorageVolumeName(v IIdentifierOrStringContext) {
	s.storageVolumeName = v
}

func (s *CreateStorageVolumeStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateStorageVolumeStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTORAGE, 0)
}

func (s *CreateStorageVolumeStatementContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVOLUME, 0)
}

func (s *CreateStorageVolumeStatementContext) TypeDesc() ITypeDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDescContext)
}

func (s *CreateStorageVolumeStatementContext) LocationsDesc() ILocationsDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocationsDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocationsDescContext)
}

func (s *CreateStorageVolumeStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CreateStorageVolumeStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *CreateStorageVolumeStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *CreateStorageVolumeStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *CreateStorageVolumeStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateStorageVolumeStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateStorageVolumeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStorageVolumeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateStorageVolumeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateStorageVolumeStatement(s)
	}
}

func (s *CreateStorageVolumeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateStorageVolumeStatement(s)
	}
}

func (s *CreateStorageVolumeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateStorageVolumeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateStorageVolumeStatement() (localctx ICreateStorageVolumeStatementContext) {
	localctx = NewCreateStorageVolumeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, DorisSQLParserRULE_createStorageVolumeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2479)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2480)
		p.Match(DorisSQLParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2481)
		p.Match(DorisSQLParserVOLUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2485)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(2482)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2483)
			p.Match(DorisSQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2484)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2487)

		var _x = p.IdentifierOrString()

		localctx.(*CreateStorageVolumeStatementContext).storageVolumeName = _x
	}
	{
		p.SetState(2488)
		p.TypeDesc()
	}
	{
		p.SetState(2489)
		p.LocationsDesc()
	}
	p.SetState(2491)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserCOMMENT {
		{
			p.SetState(2490)
			p.Comment()
		}

	}
	p.SetState(2494)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(2493)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDescContext is an interface to support dynamic dispatch.
type ITypeDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE() antlr.TerminalNode
	EQ() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsTypeDescContext differentiates from other interfaces.
	IsTypeDescContext()
}

type TypeDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDescContext() *TypeDescContext {
	var p = new(TypeDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_typeDesc
	return p
}

func InitEmptyTypeDescContext(p *TypeDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_typeDesc
}

func (*TypeDescContext) IsTypeDescContext() {}

func NewTypeDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDescContext {
	var p = new(TypeDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_typeDesc

	return p
}

func (s *TypeDescContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDescContext) TYPE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTYPE, 0)
}

func (s *TypeDescContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEQ, 0)
}

func (s *TypeDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTypeDesc(s)
	}
}

func (s *TypeDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTypeDesc(s)
	}
}

func (s *TypeDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTypeDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) TypeDesc() (localctx ITypeDescContext) {
	localctx = NewTypeDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, DorisSQLParserRULE_typeDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2496)
		p.Match(DorisSQLParserTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2497)
		p.Match(DorisSQLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2498)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILocationsDescContext is an interface to support dynamic dispatch.
type ILocationsDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCATIONS() antlr.TerminalNode
	EQ() antlr.TerminalNode
	StringList() IStringListContext

	// IsLocationsDescContext differentiates from other interfaces.
	IsLocationsDescContext()
}

type LocationsDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocationsDescContext() *LocationsDescContext {
	var p = new(LocationsDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_locationsDesc
	return p
}

func InitEmptyLocationsDescContext(p *LocationsDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_locationsDesc
}

func (*LocationsDescContext) IsLocationsDescContext() {}

func NewLocationsDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocationsDescContext {
	var p = new(LocationsDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_locationsDesc

	return p
}

func (s *LocationsDescContext) GetParser() antlr.Parser { return s.parser }

func (s *LocationsDescContext) LOCATIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOCATIONS, 0)
}

func (s *LocationsDescContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEQ, 0)
}

func (s *LocationsDescContext) StringList() IStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringListContext)
}

func (s *LocationsDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocationsDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocationsDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterLocationsDesc(s)
	}
}

func (s *LocationsDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitLocationsDesc(s)
	}
}

func (s *LocationsDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitLocationsDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) LocationsDesc() (localctx ILocationsDescContext) {
	localctx = NewLocationsDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, DorisSQLParserRULE_locationsDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2500)
		p.Match(DorisSQLParserLOCATIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2501)
		p.Match(DorisSQLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2502)
		p.StringList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowStorageVolumesStatementContext is an interface to support dynamic dispatch.
type IShowStorageVolumesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUMES() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	String_() IStringContext

	// IsShowStorageVolumesStatementContext differentiates from other interfaces.
	IsShowStorageVolumesStatementContext()
}

type ShowStorageVolumesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowStorageVolumesStatementContext() *ShowStorageVolumesStatementContext {
	var p = new(ShowStorageVolumesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showStorageVolumesStatement
	return p
}

func InitEmptyShowStorageVolumesStatementContext(p *ShowStorageVolumesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showStorageVolumesStatement
}

func (*ShowStorageVolumesStatementContext) IsShowStorageVolumesStatementContext() {}

func NewShowStorageVolumesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStorageVolumesStatementContext {
	var p = new(ShowStorageVolumesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showStorageVolumesStatement

	return p
}

func (s *ShowStorageVolumesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStorageVolumesStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowStorageVolumesStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowStorageVolumesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowStorageVolumesStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTORAGE, 0)
}

func (s *ShowStorageVolumesStatementContext) VOLUMES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVOLUMES, 0)
}

func (s *ShowStorageVolumesStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *ShowStorageVolumesStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowStorageVolumesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStorageVolumesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowStorageVolumesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowStorageVolumesStatement(s)
	}
}

func (s *ShowStorageVolumesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowStorageVolumesStatement(s)
	}
}

func (s *ShowStorageVolumesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowStorageVolumesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowStorageVolumesStatement() (localctx IShowStorageVolumesStatementContext) {
	localctx = NewShowStorageVolumesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, DorisSQLParserRULE_showStorageVolumesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2504)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2505)
		p.Match(DorisSQLParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2506)
		p.Match(DorisSQLParserVOLUMES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2509)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserLIKE {
		{
			p.SetState(2507)
			p.Match(DorisSQLParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2508)

			var _x = p.String_()

			localctx.(*ShowStorageVolumesStatementContext).pattern = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropStorageVolumeStatementContext is an interface to support dynamic dispatch.
type IDropStorageVolumeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStorageVolumeName returns the storageVolumeName rule contexts.
	GetStorageVolumeName() IIdentifierOrStringContext

	// SetStorageVolumeName sets the storageVolumeName rule contexts.
	SetStorageVolumeName(IIdentifierOrStringContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropStorageVolumeStatementContext differentiates from other interfaces.
	IsDropStorageVolumeStatementContext()
}

type DropStorageVolumeStatementContext struct {
	antlr.BaseParserRuleContext
	parser            antlr.Parser
	storageVolumeName IIdentifierOrStringContext
}

func NewEmptyDropStorageVolumeStatementContext() *DropStorageVolumeStatementContext {
	var p = new(DropStorageVolumeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropStorageVolumeStatement
	return p
}

func InitEmptyDropStorageVolumeStatementContext(p *DropStorageVolumeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropStorageVolumeStatement
}

func (*DropStorageVolumeStatementContext) IsDropStorageVolumeStatementContext() {}

func NewDropStorageVolumeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropStorageVolumeStatementContext {
	var p = new(DropStorageVolumeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropStorageVolumeStatement

	return p
}

func (s *DropStorageVolumeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropStorageVolumeStatementContext) GetStorageVolumeName() IIdentifierOrStringContext {
	return s.storageVolumeName
}

func (s *DropStorageVolumeStatementContext) SetStorageVolumeName(v IIdentifierOrStringContext) {
	s.storageVolumeName = v
}

func (s *DropStorageVolumeStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropStorageVolumeStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTORAGE, 0)
}

func (s *DropStorageVolumeStatementContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVOLUME, 0)
}

func (s *DropStorageVolumeStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropStorageVolumeStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *DropStorageVolumeStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *DropStorageVolumeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStorageVolumeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropStorageVolumeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropStorageVolumeStatement(s)
	}
}

func (s *DropStorageVolumeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropStorageVolumeStatement(s)
	}
}

func (s *DropStorageVolumeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropStorageVolumeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropStorageVolumeStatement() (localctx IDropStorageVolumeStatementContext) {
	localctx = NewDropStorageVolumeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, DorisSQLParserRULE_dropStorageVolumeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2511)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2512)
		p.Match(DorisSQLParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2513)
		p.Match(DorisSQLParserVOLUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2516)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(2514)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2515)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2518)

		var _x = p.IdentifierOrString()

		localctx.(*DropStorageVolumeStatementContext).storageVolumeName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterStorageVolumeStatementContext is an interface to support dynamic dispatch.
type IAlterStorageVolumeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	AllAlterStorageVolumeClause() []IAlterStorageVolumeClauseContext
	AlterStorageVolumeClause(i int) IAlterStorageVolumeClauseContext

	// IsAlterStorageVolumeStatementContext differentiates from other interfaces.
	IsAlterStorageVolumeStatementContext()
}

type AlterStorageVolumeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStorageVolumeStatementContext() *AlterStorageVolumeStatementContext {
	var p = new(AlterStorageVolumeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterStorageVolumeStatement
	return p
}

func InitEmptyAlterStorageVolumeStatementContext(p *AlterStorageVolumeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterStorageVolumeStatement
}

func (*AlterStorageVolumeStatementContext) IsAlterStorageVolumeStatementContext() {}

func NewAlterStorageVolumeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStorageVolumeStatementContext {
	var p = new(AlterStorageVolumeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_alterStorageVolumeStatement

	return p
}

func (s *AlterStorageVolumeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStorageVolumeStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *AlterStorageVolumeStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTORAGE, 0)
}

func (s *AlterStorageVolumeStatementContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVOLUME, 0)
}

func (s *AlterStorageVolumeStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AlterStorageVolumeStatementContext) AllAlterStorageVolumeClause() []IAlterStorageVolumeClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterStorageVolumeClauseContext); ok {
			len++
		}
	}

	tst := make([]IAlterStorageVolumeClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterStorageVolumeClauseContext); ok {
			tst[i] = t.(IAlterStorageVolumeClauseContext)
			i++
		}
	}

	return tst
}

func (s *AlterStorageVolumeStatementContext) AlterStorageVolumeClause(i int) IAlterStorageVolumeClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStorageVolumeClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStorageVolumeClauseContext)
}

func (s *AlterStorageVolumeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStorageVolumeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterStorageVolumeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAlterStorageVolumeStatement(s)
	}
}

func (s *AlterStorageVolumeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAlterStorageVolumeStatement(s)
	}
}

func (s *AlterStorageVolumeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAlterStorageVolumeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AlterStorageVolumeStatement() (localctx IAlterStorageVolumeStatementContext) {
	localctx = NewAlterStorageVolumeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, DorisSQLParserRULE_alterStorageVolumeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2520)
		p.Match(DorisSQLParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2521)
		p.Match(DorisSQLParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2522)
		p.Match(DorisSQLParserVOLUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2523)
		p.IdentifierOrString()
	}
	{
		p.SetState(2524)
		p.AlterStorageVolumeClause()
	}
	p.SetState(2529)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(2525)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2526)
			p.AlterStorageVolumeClause()
		}

		p.SetState(2531)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterStorageVolumeClauseContext is an interface to support dynamic dispatch.
type IAlterStorageVolumeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ModifyStorageVolumeCommentClause() IModifyStorageVolumeCommentClauseContext
	ModifyStorageVolumePropertiesClause() IModifyStorageVolumePropertiesClauseContext

	// IsAlterStorageVolumeClauseContext differentiates from other interfaces.
	IsAlterStorageVolumeClauseContext()
}

type AlterStorageVolumeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStorageVolumeClauseContext() *AlterStorageVolumeClauseContext {
	var p = new(AlterStorageVolumeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterStorageVolumeClause
	return p
}

func InitEmptyAlterStorageVolumeClauseContext(p *AlterStorageVolumeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterStorageVolumeClause
}

func (*AlterStorageVolumeClauseContext) IsAlterStorageVolumeClauseContext() {}

func NewAlterStorageVolumeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStorageVolumeClauseContext {
	var p = new(AlterStorageVolumeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_alterStorageVolumeClause

	return p
}

func (s *AlterStorageVolumeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStorageVolumeClauseContext) ModifyStorageVolumeCommentClause() IModifyStorageVolumeCommentClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyStorageVolumeCommentClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyStorageVolumeCommentClauseContext)
}

func (s *AlterStorageVolumeClauseContext) ModifyStorageVolumePropertiesClause() IModifyStorageVolumePropertiesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyStorageVolumePropertiesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyStorageVolumePropertiesClauseContext)
}

func (s *AlterStorageVolumeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStorageVolumeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterStorageVolumeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAlterStorageVolumeClause(s)
	}
}

func (s *AlterStorageVolumeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAlterStorageVolumeClause(s)
	}
}

func (s *AlterStorageVolumeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAlterStorageVolumeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AlterStorageVolumeClause() (localctx IAlterStorageVolumeClauseContext) {
	localctx = NewAlterStorageVolumeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, DorisSQLParserRULE_alterStorageVolumeClause)
	p.SetState(2534)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserCOMMENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2532)
			p.ModifyStorageVolumeCommentClause()
		}

	case DorisSQLParserSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2533)
			p.ModifyStorageVolumePropertiesClause()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyStorageVolumePropertiesClauseContext is an interface to support dynamic dispatch.
type IModifyStorageVolumePropertiesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsModifyStorageVolumePropertiesClauseContext differentiates from other interfaces.
	IsModifyStorageVolumePropertiesClauseContext()
}

type ModifyStorageVolumePropertiesClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyStorageVolumePropertiesClauseContext() *ModifyStorageVolumePropertiesClauseContext {
	var p = new(ModifyStorageVolumePropertiesClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_modifyStorageVolumePropertiesClause
	return p
}

func InitEmptyModifyStorageVolumePropertiesClauseContext(p *ModifyStorageVolumePropertiesClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_modifyStorageVolumePropertiesClause
}

func (*ModifyStorageVolumePropertiesClauseContext) IsModifyStorageVolumePropertiesClauseContext() {}

func NewModifyStorageVolumePropertiesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyStorageVolumePropertiesClauseContext {
	var p = new(ModifyStorageVolumePropertiesClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_modifyStorageVolumePropertiesClause

	return p
}

func (s *ModifyStorageVolumePropertiesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyStorageVolumePropertiesClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *ModifyStorageVolumePropertiesClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *ModifyStorageVolumePropertiesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyStorageVolumePropertiesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyStorageVolumePropertiesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterModifyStorageVolumePropertiesClause(s)
	}
}

func (s *ModifyStorageVolumePropertiesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitModifyStorageVolumePropertiesClause(s)
	}
}

func (s *ModifyStorageVolumePropertiesClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitModifyStorageVolumePropertiesClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ModifyStorageVolumePropertiesClause() (localctx IModifyStorageVolumePropertiesClauseContext) {
	localctx = NewModifyStorageVolumePropertiesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, DorisSQLParserRULE_modifyStorageVolumePropertiesClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2536)
		p.Match(DorisSQLParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2537)
		p.PropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyStorageVolumeCommentClauseContext is an interface to support dynamic dispatch.
type IModifyStorageVolumeCommentClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMENT() antlr.TerminalNode
	EQ() antlr.TerminalNode
	String_() IStringContext

	// IsModifyStorageVolumeCommentClauseContext differentiates from other interfaces.
	IsModifyStorageVolumeCommentClauseContext()
}

type ModifyStorageVolumeCommentClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyStorageVolumeCommentClauseContext() *ModifyStorageVolumeCommentClauseContext {
	var p = new(ModifyStorageVolumeCommentClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_modifyStorageVolumeCommentClause
	return p
}

func InitEmptyModifyStorageVolumeCommentClauseContext(p *ModifyStorageVolumeCommentClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_modifyStorageVolumeCommentClause
}

func (*ModifyStorageVolumeCommentClauseContext) IsModifyStorageVolumeCommentClauseContext() {}

func NewModifyStorageVolumeCommentClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyStorageVolumeCommentClauseContext {
	var p = new(ModifyStorageVolumeCommentClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_modifyStorageVolumeCommentClause

	return p
}

func (s *ModifyStorageVolumeCommentClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyStorageVolumeCommentClauseContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOMMENT, 0)
}

func (s *ModifyStorageVolumeCommentClauseContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEQ, 0)
}

func (s *ModifyStorageVolumeCommentClauseContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ModifyStorageVolumeCommentClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyStorageVolumeCommentClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyStorageVolumeCommentClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterModifyStorageVolumeCommentClause(s)
	}
}

func (s *ModifyStorageVolumeCommentClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitModifyStorageVolumeCommentClause(s)
	}
}

func (s *ModifyStorageVolumeCommentClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitModifyStorageVolumeCommentClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ModifyStorageVolumeCommentClause() (localctx IModifyStorageVolumeCommentClauseContext) {
	localctx = NewModifyStorageVolumeCommentClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, DorisSQLParserRULE_modifyStorageVolumeCommentClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2539)
		p.Match(DorisSQLParserCOMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2540)
		p.Match(DorisSQLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2541)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescStorageVolumeStatementContext is an interface to support dynamic dispatch.
type IDescStorageVolumeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode

	// IsDescStorageVolumeStatementContext differentiates from other interfaces.
	IsDescStorageVolumeStatementContext()
}

type DescStorageVolumeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescStorageVolumeStatementContext() *DescStorageVolumeStatementContext {
	var p = new(DescStorageVolumeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_descStorageVolumeStatement
	return p
}

func InitEmptyDescStorageVolumeStatementContext(p *DescStorageVolumeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_descStorageVolumeStatement
}

func (*DescStorageVolumeStatementContext) IsDescStorageVolumeStatementContext() {}

func NewDescStorageVolumeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescStorageVolumeStatementContext {
	var p = new(DescStorageVolumeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_descStorageVolumeStatement

	return p
}

func (s *DescStorageVolumeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DescStorageVolumeStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTORAGE, 0)
}

func (s *DescStorageVolumeStatementContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVOLUME, 0)
}

func (s *DescStorageVolumeStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DescStorageVolumeStatementContext) DESC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDESC, 0)
}

func (s *DescStorageVolumeStatementContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDESCRIBE, 0)
}

func (s *DescStorageVolumeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescStorageVolumeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescStorageVolumeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDescStorageVolumeStatement(s)
	}
}

func (s *DescStorageVolumeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDescStorageVolumeStatement(s)
	}
}

func (s *DescStorageVolumeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDescStorageVolumeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DescStorageVolumeStatement() (localctx IDescStorageVolumeStatementContext) {
	localctx = NewDescStorageVolumeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, DorisSQLParserRULE_descStorageVolumeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2543)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserDESC || _la == DorisSQLParserDESCRIBE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2544)
		p.Match(DorisSQLParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2545)
		p.Match(DorisSQLParserVOLUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2546)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetDefaultStorageVolumeStatementContext is an interface to support dynamic dispatch.
type ISetDefaultStorageVolumeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	AS() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode

	// IsSetDefaultStorageVolumeStatementContext differentiates from other interfaces.
	IsSetDefaultStorageVolumeStatementContext()
}

type SetDefaultStorageVolumeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetDefaultStorageVolumeStatementContext() *SetDefaultStorageVolumeStatementContext {
	var p = new(SetDefaultStorageVolumeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_setDefaultStorageVolumeStatement
	return p
}

func InitEmptySetDefaultStorageVolumeStatementContext(p *SetDefaultStorageVolumeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_setDefaultStorageVolumeStatement
}

func (*SetDefaultStorageVolumeStatementContext) IsSetDefaultStorageVolumeStatementContext() {}

func NewSetDefaultStorageVolumeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetDefaultStorageVolumeStatementContext {
	var p = new(SetDefaultStorageVolumeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_setDefaultStorageVolumeStatement

	return p
}

func (s *SetDefaultStorageVolumeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetDefaultStorageVolumeStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *SetDefaultStorageVolumeStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *SetDefaultStorageVolumeStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *SetDefaultStorageVolumeStatementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDEFAULT, 0)
}

func (s *SetDefaultStorageVolumeStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTORAGE, 0)
}

func (s *SetDefaultStorageVolumeStatementContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVOLUME, 0)
}

func (s *SetDefaultStorageVolumeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetDefaultStorageVolumeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetDefaultStorageVolumeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSetDefaultStorageVolumeStatement(s)
	}
}

func (s *SetDefaultStorageVolumeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSetDefaultStorageVolumeStatement(s)
	}
}

func (s *SetDefaultStorageVolumeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSetDefaultStorageVolumeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SetDefaultStorageVolumeStatement() (localctx ISetDefaultStorageVolumeStatementContext) {
	localctx = NewSetDefaultStorageVolumeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, DorisSQLParserRULE_setDefaultStorageVolumeStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2548)
		p.Match(DorisSQLParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2549)
		p.IdentifierOrString()
	}
	{
		p.SetState(2550)
		p.Match(DorisSQLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2551)
		p.Match(DorisSQLParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2552)
		p.Match(DorisSQLParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2553)
		p.Match(DorisSQLParserVOLUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateFailPointStatusStatementContext is an interface to support dynamic dispatch.
type IUpdateFailPointStatusStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTimes returns the times token.
	GetTimes() antlr.Token

	// GetProb returns the prob token.
	GetProb() antlr.Token

	// SetTimes sets the times token.
	SetTimes(antlr.Token)

	// SetProb sets the prob token.
	SetProb(antlr.Token)

	// Getter signatures
	ADMIN() antlr.TerminalNode
	FAILPOINT() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	DISABLE() antlr.TerminalNode
	ENABLE() antlr.TerminalNode
	WITH() antlr.TerminalNode
	ON() antlr.TerminalNode
	TIMES() antlr.TerminalNode
	PROBABILITY() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	FRONTEND() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	DECIMAL_VALUE() antlr.TerminalNode

	// IsUpdateFailPointStatusStatementContext differentiates from other interfaces.
	IsUpdateFailPointStatusStatementContext()
}

type UpdateFailPointStatusStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	times  antlr.Token
	prob   antlr.Token
}

func NewEmptyUpdateFailPointStatusStatementContext() *UpdateFailPointStatusStatementContext {
	var p = new(UpdateFailPointStatusStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_updateFailPointStatusStatement
	return p
}

func InitEmptyUpdateFailPointStatusStatementContext(p *UpdateFailPointStatusStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_updateFailPointStatusStatement
}

func (*UpdateFailPointStatusStatementContext) IsUpdateFailPointStatusStatementContext() {}

func NewUpdateFailPointStatusStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateFailPointStatusStatementContext {
	var p = new(UpdateFailPointStatusStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_updateFailPointStatusStatement

	return p
}

func (s *UpdateFailPointStatusStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateFailPointStatusStatementContext) GetTimes() antlr.Token { return s.times }

func (s *UpdateFailPointStatusStatementContext) GetProb() antlr.Token { return s.prob }

func (s *UpdateFailPointStatusStatementContext) SetTimes(v antlr.Token) { s.times = v }

func (s *UpdateFailPointStatusStatementContext) SetProb(v antlr.Token) { s.prob = v }

func (s *UpdateFailPointStatusStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADMIN, 0)
}

func (s *UpdateFailPointStatusStatementContext) FAILPOINT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFAILPOINT, 0)
}

func (s *UpdateFailPointStatusStatementContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *UpdateFailPointStatusStatementContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *UpdateFailPointStatusStatementContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDISABLE, 0)
}

func (s *UpdateFailPointStatusStatementContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserENABLE, 0)
}

func (s *UpdateFailPointStatusStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *UpdateFailPointStatusStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *UpdateFailPointStatusStatementContext) TIMES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTIMES, 0)
}

func (s *UpdateFailPointStatusStatementContext) PROBABILITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROBABILITY, 0)
}

func (s *UpdateFailPointStatusStatementContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBACKEND, 0)
}

func (s *UpdateFailPointStatusStatementContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFRONTEND, 0)
}

func (s *UpdateFailPointStatusStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, 0)
}

func (s *UpdateFailPointStatusStatementContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDECIMAL_VALUE, 0)
}

func (s *UpdateFailPointStatusStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateFailPointStatusStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateFailPointStatusStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterUpdateFailPointStatusStatement(s)
	}
}

func (s *UpdateFailPointStatusStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitUpdateFailPointStatusStatement(s)
	}
}

func (s *UpdateFailPointStatusStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitUpdateFailPointStatusStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) UpdateFailPointStatusStatement() (localctx IUpdateFailPointStatusStatementContext) {
	localctx = NewUpdateFailPointStatusStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, DorisSQLParserRULE_updateFailPointStatusStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2555)
		p.Match(DorisSQLParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2556)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserDISABLE || _la == DorisSQLParserENABLE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2557)
		p.Match(DorisSQLParserFAILPOINT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2558)
		p.String_()
	}
	p.SetState(2566)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWITH {
		{
			p.SetState(2559)
			p.Match(DorisSQLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2564)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserINTEGER_VALUE:
			{
				p.SetState(2560)

				var _m = p.Match(DorisSQLParserINTEGER_VALUE)

				localctx.(*UpdateFailPointStatusStatementContext).times = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2561)
				p.Match(DorisSQLParserTIMES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisSQLParserDECIMAL_VALUE:
			{
				p.SetState(2562)

				var _m = p.Match(DorisSQLParserDECIMAL_VALUE)

				localctx.(*UpdateFailPointStatusStatementContext).prob = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2563)
				p.Match(DorisSQLParserPROBABILITY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(2574)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserON {
		{
			p.SetState(2568)
			p.Match(DorisSQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2572)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserBACKEND:
			{
				p.SetState(2569)
				p.Match(DorisSQLParserBACKEND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2570)
				p.String_()
			}

		case DorisSQLParserFRONTEND:
			{
				p.SetState(2571)
				p.Match(DorisSQLParserFRONTEND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowFailPointStatementContext is an interface to support dynamic dispatch.
type IShowFailPointStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	FAILPOINTS() antlr.TerminalNode
	ON() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	LIKE() antlr.TerminalNode

	// IsShowFailPointStatementContext differentiates from other interfaces.
	IsShowFailPointStatementContext()
}

type ShowFailPointStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowFailPointStatementContext() *ShowFailPointStatementContext {
	var p = new(ShowFailPointStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showFailPointStatement
	return p
}

func InitEmptyShowFailPointStatementContext(p *ShowFailPointStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showFailPointStatement
}

func (*ShowFailPointStatementContext) IsShowFailPointStatementContext() {}

func NewShowFailPointStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowFailPointStatementContext {
	var p = new(ShowFailPointStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showFailPointStatement

	return p
}

func (s *ShowFailPointStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowFailPointStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowFailPointStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowFailPointStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowFailPointStatementContext) FAILPOINTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFAILPOINTS, 0)
}

func (s *ShowFailPointStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *ShowFailPointStatementContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBACKEND, 0)
}

func (s *ShowFailPointStatementContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ShowFailPointStatementContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowFailPointStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *ShowFailPointStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFailPointStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowFailPointStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowFailPointStatement(s)
	}
}

func (s *ShowFailPointStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowFailPointStatement(s)
	}
}

func (s *ShowFailPointStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowFailPointStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowFailPointStatement() (localctx IShowFailPointStatementContext) {
	localctx = NewShowFailPointStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, DorisSQLParserRULE_showFailPointStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2576)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2577)
		p.Match(DorisSQLParserFAILPOINTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2580)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserLIKE {
		{
			p.SetState(2578)
			p.Match(DorisSQLParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2579)

			var _x = p.String_()

			localctx.(*ShowFailPointStatementContext).pattern = _x
		}

	}
	p.SetState(2585)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserON {
		{
			p.SetState(2582)
			p.Match(DorisSQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2583)
			p.Match(DorisSQLParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2584)
			p.String_()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDictionaryStatementContext is an interface to support dynamic dispatch.
type ICreateDictionaryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	DictionaryName() IDictionaryNameContext
	USING() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AllDictionaryColumnDesc() []IDictionaryColumnDescContext
	DictionaryColumnDesc(i int) IDictionaryColumnDescContext
	Properties() IPropertiesContext

	// IsCreateDictionaryStatementContext differentiates from other interfaces.
	IsCreateDictionaryStatementContext()
}

type CreateDictionaryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDictionaryStatementContext() *CreateDictionaryStatementContext {
	var p = new(CreateDictionaryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createDictionaryStatement
	return p
}

func InitEmptyCreateDictionaryStatementContext(p *CreateDictionaryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createDictionaryStatement
}

func (*CreateDictionaryStatementContext) IsCreateDictionaryStatementContext() {}

func NewCreateDictionaryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDictionaryStatementContext {
	var p = new(CreateDictionaryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createDictionaryStatement

	return p
}

func (s *CreateDictionaryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDictionaryStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateDictionaryStatementContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDICTIONARY, 0)
}

func (s *CreateDictionaryStatementContext) DictionaryName() IDictionaryNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDictionaryNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDictionaryNameContext)
}

func (s *CreateDictionaryStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSING, 0)
}

func (s *CreateDictionaryStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateDictionaryStatementContext) AllDictionaryColumnDesc() []IDictionaryColumnDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDictionaryColumnDescContext); ok {
			len++
		}
	}

	tst := make([]IDictionaryColumnDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDictionaryColumnDescContext); ok {
			tst[i] = t.(IDictionaryColumnDescContext)
			i++
		}
	}

	return tst
}

func (s *CreateDictionaryStatementContext) DictionaryColumnDesc(i int) IDictionaryColumnDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDictionaryColumnDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDictionaryColumnDescContext)
}

func (s *CreateDictionaryStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateDictionaryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDictionaryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDictionaryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateDictionaryStatement(s)
	}
}

func (s *CreateDictionaryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateDictionaryStatement(s)
	}
}

func (s *CreateDictionaryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateDictionaryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateDictionaryStatement() (localctx ICreateDictionaryStatementContext) {
	localctx = NewCreateDictionaryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, DorisSQLParserRULE_createDictionaryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2587)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2588)
		p.Match(DorisSQLParserDICTIONARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2589)
		p.DictionaryName()
	}
	{
		p.SetState(2590)
		p.Match(DorisSQLParserUSING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2591)
		p.QualifiedName()
	}
	{
		p.SetState(2592)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2593)
		p.DictionaryColumnDesc()
	}
	p.SetState(2598)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(2594)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2595)
			p.DictionaryColumnDesc()
		}

		p.SetState(2600)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2601)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2603)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(2602)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropDictionaryStatementContext is an interface to support dynamic dispatch.
type IDropDictionaryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	CACHE() antlr.TerminalNode

	// IsDropDictionaryStatementContext differentiates from other interfaces.
	IsDropDictionaryStatementContext()
}

type DropDictionaryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropDictionaryStatementContext() *DropDictionaryStatementContext {
	var p = new(DropDictionaryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropDictionaryStatement
	return p
}

func InitEmptyDropDictionaryStatementContext(p *DropDictionaryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropDictionaryStatement
}

func (*DropDictionaryStatementContext) IsDropDictionaryStatementContext() {}

func NewDropDictionaryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropDictionaryStatementContext {
	var p = new(DropDictionaryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropDictionaryStatement

	return p
}

func (s *DropDictionaryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropDictionaryStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropDictionaryStatementContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDICTIONARY, 0)
}

func (s *DropDictionaryStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropDictionaryStatementContext) CACHE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCACHE, 0)
}

func (s *DropDictionaryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDictionaryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropDictionaryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropDictionaryStatement(s)
	}
}

func (s *DropDictionaryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropDictionaryStatement(s)
	}
}

func (s *DropDictionaryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropDictionaryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropDictionaryStatement() (localctx IDropDictionaryStatementContext) {
	localctx = NewDropDictionaryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, DorisSQLParserRULE_dropDictionaryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2605)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2606)
		p.Match(DorisSQLParserDICTIONARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2607)
		p.QualifiedName()
	}
	p.SetState(2609)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserCACHE {
		{
			p.SetState(2608)
			p.Match(DorisSQLParserCACHE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshDictionaryStatementContext is an interface to support dynamic dispatch.
type IRefreshDictionaryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REFRESH() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsRefreshDictionaryStatementContext differentiates from other interfaces.
	IsRefreshDictionaryStatementContext()
}

type RefreshDictionaryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefreshDictionaryStatementContext() *RefreshDictionaryStatementContext {
	var p = new(RefreshDictionaryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_refreshDictionaryStatement
	return p
}

func InitEmptyRefreshDictionaryStatementContext(p *RefreshDictionaryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_refreshDictionaryStatement
}

func (*RefreshDictionaryStatementContext) IsRefreshDictionaryStatementContext() {}

func NewRefreshDictionaryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshDictionaryStatementContext {
	var p = new(RefreshDictionaryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_refreshDictionaryStatement

	return p
}

func (s *RefreshDictionaryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshDictionaryStatementContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREFRESH, 0)
}

func (s *RefreshDictionaryStatementContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDICTIONARY, 0)
}

func (s *RefreshDictionaryStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RefreshDictionaryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshDictionaryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshDictionaryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRefreshDictionaryStatement(s)
	}
}

func (s *RefreshDictionaryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRefreshDictionaryStatement(s)
	}
}

func (s *RefreshDictionaryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRefreshDictionaryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) RefreshDictionaryStatement() (localctx IRefreshDictionaryStatementContext) {
	localctx = NewRefreshDictionaryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, DorisSQLParserRULE_refreshDictionaryStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2611)
		p.Match(DorisSQLParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2612)
		p.Match(DorisSQLParserDICTIONARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2613)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDictionaryStatementContext is an interface to support dynamic dispatch.
type IShowDictionaryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowDictionaryStatementContext differentiates from other interfaces.
	IsShowDictionaryStatementContext()
}

type ShowDictionaryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowDictionaryStatementContext() *ShowDictionaryStatementContext {
	var p = new(ShowDictionaryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showDictionaryStatement
	return p
}

func InitEmptyShowDictionaryStatementContext(p *ShowDictionaryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showDictionaryStatement
}

func (*ShowDictionaryStatementContext) IsShowDictionaryStatementContext() {}

func NewShowDictionaryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDictionaryStatementContext {
	var p = new(ShowDictionaryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showDictionaryStatement

	return p
}

func (s *ShowDictionaryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDictionaryStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowDictionaryStatementContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDICTIONARY, 0)
}

func (s *ShowDictionaryStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowDictionaryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDictionaryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDictionaryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowDictionaryStatement(s)
	}
}

func (s *ShowDictionaryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowDictionaryStatement(s)
	}
}

func (s *ShowDictionaryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowDictionaryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowDictionaryStatement() (localctx IShowDictionaryStatementContext) {
	localctx = NewShowDictionaryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, DorisSQLParserRULE_showDictionaryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2615)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2616)
		p.Match(DorisSQLParserDICTIONARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2618)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262756702208) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-6664167256628462851) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-1331487429127569487) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&-7546427580836201) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-4573491655345179) != 0) || ((int64((_la-324)) & ^0x3f) == 0 && ((int64(1)<<(_la-324))&9114828243924942831) != 0) || ((int64((_la-389)) & ^0x3f) == 0 && ((int64(1)<<(_la-389))&-6956096606152176261) != 0) || ((int64((_la-453)) & ^0x3f) == 0 && ((int64(1)<<(_la-453))&70849595962729) != 0) || ((int64((_la-525)) & ^0x3f) == 0 && ((int64(1)<<(_la-525))&263) != 0) {
		{
			p.SetState(2617)
			p.QualifiedName()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelRefreshDictionaryStatementContext is an interface to support dynamic dispatch.
type ICancelRefreshDictionaryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	REFRESH() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsCancelRefreshDictionaryStatementContext differentiates from other interfaces.
	IsCancelRefreshDictionaryStatementContext()
}

type CancelRefreshDictionaryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelRefreshDictionaryStatementContext() *CancelRefreshDictionaryStatementContext {
	var p = new(CancelRefreshDictionaryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cancelRefreshDictionaryStatement
	return p
}

func InitEmptyCancelRefreshDictionaryStatementContext(p *CancelRefreshDictionaryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cancelRefreshDictionaryStatement
}

func (*CancelRefreshDictionaryStatementContext) IsCancelRefreshDictionaryStatementContext() {}

func NewCancelRefreshDictionaryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelRefreshDictionaryStatementContext {
	var p = new(CancelRefreshDictionaryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_cancelRefreshDictionaryStatement

	return p
}

func (s *CancelRefreshDictionaryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelRefreshDictionaryStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCANCEL, 0)
}

func (s *CancelRefreshDictionaryStatementContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREFRESH, 0)
}

func (s *CancelRefreshDictionaryStatementContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDICTIONARY, 0)
}

func (s *CancelRefreshDictionaryStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CancelRefreshDictionaryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelRefreshDictionaryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelRefreshDictionaryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCancelRefreshDictionaryStatement(s)
	}
}

func (s *CancelRefreshDictionaryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCancelRefreshDictionaryStatement(s)
	}
}

func (s *CancelRefreshDictionaryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCancelRefreshDictionaryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CancelRefreshDictionaryStatement() (localctx ICancelRefreshDictionaryStatementContext) {
	localctx = NewCancelRefreshDictionaryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, DorisSQLParserRULE_cancelRefreshDictionaryStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2620)
		p.Match(DorisSQLParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2621)
		p.Match(DorisSQLParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2622)
		p.Match(DorisSQLParserDICTIONARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2623)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDictionaryColumnDescContext is an interface to support dynamic dispatch.
type IDictionaryColumnDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext
	KEY() antlr.TerminalNode
	VALUE() antlr.TerminalNode

	// IsDictionaryColumnDescContext differentiates from other interfaces.
	IsDictionaryColumnDescContext()
}

type DictionaryColumnDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryColumnDescContext() *DictionaryColumnDescContext {
	var p = new(DictionaryColumnDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dictionaryColumnDesc
	return p
}

func InitEmptyDictionaryColumnDescContext(p *DictionaryColumnDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dictionaryColumnDesc
}

func (*DictionaryColumnDescContext) IsDictionaryColumnDescContext() {}

func NewDictionaryColumnDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryColumnDescContext {
	var p = new(DictionaryColumnDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dictionaryColumnDesc

	return p
}

func (s *DictionaryColumnDescContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryColumnDescContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DictionaryColumnDescContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserKEY, 0)
}

func (s *DictionaryColumnDescContext) VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVALUE, 0)
}

func (s *DictionaryColumnDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryColumnDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryColumnDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDictionaryColumnDesc(s)
	}
}

func (s *DictionaryColumnDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDictionaryColumnDesc(s)
	}
}

func (s *DictionaryColumnDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDictionaryColumnDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DictionaryColumnDesc() (localctx IDictionaryColumnDescContext) {
	localctx = NewDictionaryColumnDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, DorisSQLParserRULE_dictionaryColumnDesc)
	p.SetState(2631)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 195, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2625)
			p.QualifiedName()
		}
		{
			p.SetState(2626)
			p.Match(DorisSQLParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2628)
			p.QualifiedName()
		}
		{
			p.SetState(2629)
			p.Match(DorisSQLParserVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDictionaryNameContext is an interface to support dynamic dispatch.
type IDictionaryNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext

	// IsDictionaryNameContext differentiates from other interfaces.
	IsDictionaryNameContext()
}

type DictionaryNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryNameContext() *DictionaryNameContext {
	var p = new(DictionaryNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dictionaryName
	return p
}

func InitEmptyDictionaryNameContext(p *DictionaryNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dictionaryName
}

func (*DictionaryNameContext) IsDictionaryNameContext() {}

func NewDictionaryNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryNameContext {
	var p = new(DictionaryNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dictionaryName

	return p
}

func (s *DictionaryNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryNameContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DictionaryNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDictionaryName(s)
	}
}

func (s *DictionaryNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDictionaryName(s)
	}
}

func (s *DictionaryNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDictionaryName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DictionaryName() (localctx IDictionaryNameContext) {
	localctx = NewDictionaryNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, DorisSQLParserRULE_dictionaryName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2633)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterClauseContext is an interface to support dynamic dispatch.
type IAlterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AddFrontendClause() IAddFrontendClauseContext
	DropFrontendClause() IDropFrontendClauseContext
	ModifyFrontendHostClause() IModifyFrontendHostClauseContext
	AddBackendClause() IAddBackendClauseContext
	DropBackendClause() IDropBackendClauseContext
	DecommissionBackendClause() IDecommissionBackendClauseContext
	ModifyBackendClause() IModifyBackendClauseContext
	AddComputeNodeClause() IAddComputeNodeClauseContext
	DropComputeNodeClause() IDropComputeNodeClauseContext
	ModifyBrokerClause() IModifyBrokerClauseContext
	AlterLoadErrorUrlClause() IAlterLoadErrorUrlClauseContext
	CreateImageClause() ICreateImageClauseContext
	CleanTabletSchedQClause() ICleanTabletSchedQClauseContext
	DecommissionDiskClause() IDecommissionDiskClauseContext
	CancelDecommissionDiskClause() ICancelDecommissionDiskClauseContext
	DisableDiskClause() IDisableDiskClauseContext
	CancelDisableDiskClause() ICancelDisableDiskClauseContext
	CreateIndexClause() ICreateIndexClauseContext
	DropIndexClause() IDropIndexClauseContext
	TableRenameClause() ITableRenameClauseContext
	SwapTableClause() ISwapTableClauseContext
	ModifyPropertiesClause() IModifyPropertiesClauseContext
	AddColumnClause() IAddColumnClauseContext
	AddColumnsClause() IAddColumnsClauseContext
	DropColumnClause() IDropColumnClauseContext
	ModifyColumnCommentClause() IModifyColumnCommentClauseContext
	ModifyColumnClause() IModifyColumnClauseContext
	ColumnRenameClause() IColumnRenameClauseContext
	ReorderColumnsClause() IReorderColumnsClauseContext
	RollupRenameClause() IRollupRenameClauseContext
	CompactionClause() ICompactionClauseContext
	ModifyCommentClause() IModifyCommentClauseContext
	OptimizeClause() IOptimizeClauseContext
	AddFieldClause() IAddFieldClauseContext
	DropFieldClause() IDropFieldClauseContext
	CreateOrReplaceBranchClause() ICreateOrReplaceBranchClauseContext
	CreateOrReplaceTagClause() ICreateOrReplaceTagClauseContext
	DropBranchClause() IDropBranchClauseContext
	DropTagClause() IDropTagClauseContext
	TableOperationClause() ITableOperationClauseContext
	DropPersistentIndexClause() IDropPersistentIndexClauseContext
	AddPartitionClause() IAddPartitionClauseContext
	DropPartitionClause() IDropPartitionClauseContext
	DistributionClause() IDistributionClauseContext
	TruncatePartitionClause() ITruncatePartitionClauseContext
	ModifyPartitionClause() IModifyPartitionClauseContext
	ReplacePartitionClause() IReplacePartitionClauseContext
	PartitionRenameClause() IPartitionRenameClauseContext

	// IsAlterClauseContext differentiates from other interfaces.
	IsAlterClauseContext()
}

type AlterClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterClauseContext() *AlterClauseContext {
	var p = new(AlterClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterClause
	return p
}

func InitEmptyAlterClauseContext(p *AlterClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterClause
}

func (*AlterClauseContext) IsAlterClauseContext() {}

func NewAlterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterClauseContext {
	var p = new(AlterClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_alterClause

	return p
}

func (s *AlterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterClauseContext) AddFrontendClause() IAddFrontendClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddFrontendClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddFrontendClauseContext)
}

func (s *AlterClauseContext) DropFrontendClause() IDropFrontendClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFrontendClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFrontendClauseContext)
}

func (s *AlterClauseContext) ModifyFrontendHostClause() IModifyFrontendHostClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyFrontendHostClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyFrontendHostClauseContext)
}

func (s *AlterClauseContext) AddBackendClause() IAddBackendClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddBackendClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddBackendClauseContext)
}

func (s *AlterClauseContext) DropBackendClause() IDropBackendClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropBackendClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropBackendClauseContext)
}

func (s *AlterClauseContext) DecommissionBackendClause() IDecommissionBackendClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecommissionBackendClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecommissionBackendClauseContext)
}

func (s *AlterClauseContext) ModifyBackendClause() IModifyBackendClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyBackendClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyBackendClauseContext)
}

func (s *AlterClauseContext) AddComputeNodeClause() IAddComputeNodeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddComputeNodeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddComputeNodeClauseContext)
}

func (s *AlterClauseContext) DropComputeNodeClause() IDropComputeNodeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropComputeNodeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropComputeNodeClauseContext)
}

func (s *AlterClauseContext) ModifyBrokerClause() IModifyBrokerClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyBrokerClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyBrokerClauseContext)
}

func (s *AlterClauseContext) AlterLoadErrorUrlClause() IAlterLoadErrorUrlClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterLoadErrorUrlClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterLoadErrorUrlClauseContext)
}

func (s *AlterClauseContext) CreateImageClause() ICreateImageClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateImageClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateImageClauseContext)
}

func (s *AlterClauseContext) CleanTabletSchedQClause() ICleanTabletSchedQClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICleanTabletSchedQClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICleanTabletSchedQClauseContext)
}

func (s *AlterClauseContext) DecommissionDiskClause() IDecommissionDiskClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecommissionDiskClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecommissionDiskClauseContext)
}

func (s *AlterClauseContext) CancelDecommissionDiskClause() ICancelDecommissionDiskClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelDecommissionDiskClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelDecommissionDiskClauseContext)
}

func (s *AlterClauseContext) DisableDiskClause() IDisableDiskClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisableDiskClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisableDiskClauseContext)
}

func (s *AlterClauseContext) CancelDisableDiskClause() ICancelDisableDiskClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelDisableDiskClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelDisableDiskClauseContext)
}

func (s *AlterClauseContext) CreateIndexClause() ICreateIndexClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateIndexClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateIndexClauseContext)
}

func (s *AlterClauseContext) DropIndexClause() IDropIndexClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropIndexClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropIndexClauseContext)
}

func (s *AlterClauseContext) TableRenameClause() ITableRenameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRenameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRenameClauseContext)
}

func (s *AlterClauseContext) SwapTableClause() ISwapTableClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwapTableClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwapTableClauseContext)
}

func (s *AlterClauseContext) ModifyPropertiesClause() IModifyPropertiesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyPropertiesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyPropertiesClauseContext)
}

func (s *AlterClauseContext) AddColumnClause() IAddColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddColumnClauseContext)
}

func (s *AlterClauseContext) AddColumnsClause() IAddColumnsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddColumnsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddColumnsClauseContext)
}

func (s *AlterClauseContext) DropColumnClause() IDropColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropColumnClauseContext)
}

func (s *AlterClauseContext) ModifyColumnCommentClause() IModifyColumnCommentClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyColumnCommentClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyColumnCommentClauseContext)
}

func (s *AlterClauseContext) ModifyColumnClause() IModifyColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyColumnClauseContext)
}

func (s *AlterClauseContext) ColumnRenameClause() IColumnRenameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRenameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRenameClauseContext)
}

func (s *AlterClauseContext) ReorderColumnsClause() IReorderColumnsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReorderColumnsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReorderColumnsClauseContext)
}

func (s *AlterClauseContext) RollupRenameClause() IRollupRenameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupRenameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupRenameClauseContext)
}

func (s *AlterClauseContext) CompactionClause() ICompactionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompactionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompactionClauseContext)
}

func (s *AlterClauseContext) ModifyCommentClause() IModifyCommentClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyCommentClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyCommentClauseContext)
}

func (s *AlterClauseContext) OptimizeClause() IOptimizeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptimizeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptimizeClauseContext)
}

func (s *AlterClauseContext) AddFieldClause() IAddFieldClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddFieldClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddFieldClauseContext)
}

func (s *AlterClauseContext) DropFieldClause() IDropFieldClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFieldClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFieldClauseContext)
}

func (s *AlterClauseContext) CreateOrReplaceBranchClause() ICreateOrReplaceBranchClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateOrReplaceBranchClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateOrReplaceBranchClauseContext)
}

func (s *AlterClauseContext) CreateOrReplaceTagClause() ICreateOrReplaceTagClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateOrReplaceTagClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateOrReplaceTagClauseContext)
}

func (s *AlterClauseContext) DropBranchClause() IDropBranchClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropBranchClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropBranchClauseContext)
}

func (s *AlterClauseContext) DropTagClause() IDropTagClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTagClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTagClauseContext)
}

func (s *AlterClauseContext) TableOperationClause() ITableOperationClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOperationClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOperationClauseContext)
}

func (s *AlterClauseContext) DropPersistentIndexClause() IDropPersistentIndexClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropPersistentIndexClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropPersistentIndexClauseContext)
}

func (s *AlterClauseContext) AddPartitionClause() IAddPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddPartitionClauseContext)
}

func (s *AlterClauseContext) DropPartitionClause() IDropPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropPartitionClauseContext)
}

func (s *AlterClauseContext) DistributionClause() IDistributionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionClauseContext)
}

func (s *AlterClauseContext) TruncatePartitionClause() ITruncatePartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncatePartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncatePartitionClauseContext)
}

func (s *AlterClauseContext) ModifyPartitionClause() IModifyPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyPartitionClauseContext)
}

func (s *AlterClauseContext) ReplacePartitionClause() IReplacePartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplacePartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplacePartitionClauseContext)
}

func (s *AlterClauseContext) PartitionRenameClause() IPartitionRenameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionRenameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionRenameClauseContext)
}

func (s *AlterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAlterClause(s)
	}
}

func (s *AlterClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAlterClause(s)
	}
}

func (s *AlterClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAlterClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AlterClause() (localctx IAlterClauseContext) {
	localctx = NewAlterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, DorisSQLParserRULE_alterClause)
	p.SetState(2683)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 196, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2635)
			p.AddFrontendClause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2636)
			p.DropFrontendClause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2637)
			p.ModifyFrontendHostClause()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2638)
			p.AddBackendClause()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2639)
			p.DropBackendClause()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2640)
			p.DecommissionBackendClause()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2641)
			p.ModifyBackendClause()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2642)
			p.AddComputeNodeClause()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2643)
			p.DropComputeNodeClause()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2644)
			p.ModifyBrokerClause()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2645)
			p.AlterLoadErrorUrlClause()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2646)
			p.CreateImageClause()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2647)
			p.CleanTabletSchedQClause()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2648)
			p.DecommissionDiskClause()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(2649)
			p.CancelDecommissionDiskClause()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(2650)
			p.DisableDiskClause()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(2651)
			p.CancelDisableDiskClause()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(2652)
			p.CreateIndexClause()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(2653)
			p.DropIndexClause()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(2654)
			p.TableRenameClause()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(2655)
			p.SwapTableClause()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(2656)
			p.ModifyPropertiesClause()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(2657)
			p.AddColumnClause()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(2658)
			p.AddColumnsClause()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(2659)
			p.DropColumnClause()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(2660)
			p.ModifyColumnCommentClause()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(2661)
			p.ModifyColumnClause()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(2662)
			p.ColumnRenameClause()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(2663)
			p.ReorderColumnsClause()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(2664)
			p.RollupRenameClause()
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(2665)
			p.CompactionClause()
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(2666)
			p.ModifyCommentClause()
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(2667)
			p.OptimizeClause()
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(2668)
			p.AddFieldClause()
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(2669)
			p.DropFieldClause()
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(2670)
			p.CreateOrReplaceBranchClause()
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(2671)
			p.CreateOrReplaceTagClause()
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(2672)
			p.DropBranchClause()
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(2673)
			p.DropTagClause()
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(2674)
			p.TableOperationClause()
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(2675)
			p.DropPersistentIndexClause()
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(2676)
			p.AddPartitionClause()
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(2677)
			p.DropPartitionClause()
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(2678)
			p.DistributionClause()
		}

	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(2679)
			p.TruncatePartitionClause()
		}

	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(2680)
			p.ModifyPartitionClause()
		}

	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(2681)
			p.ReplacePartitionClause()
		}

	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(2682)
			p.PartitionRenameClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddFrontendClauseContext is an interface to support dynamic dispatch.
type IAddFrontendClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	String_() IStringContext
	FOLLOWER() antlr.TerminalNode
	OBSERVER() antlr.TerminalNode

	// IsAddFrontendClauseContext differentiates from other interfaces.
	IsAddFrontendClauseContext()
}

type AddFrontendClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddFrontendClauseContext() *AddFrontendClauseContext {
	var p = new(AddFrontendClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_addFrontendClause
	return p
}

func InitEmptyAddFrontendClauseContext(p *AddFrontendClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_addFrontendClause
}

func (*AddFrontendClauseContext) IsAddFrontendClauseContext() {}

func NewAddFrontendClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddFrontendClauseContext {
	var p = new(AddFrontendClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_addFrontendClause

	return p
}

func (s *AddFrontendClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddFrontendClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADD, 0)
}

func (s *AddFrontendClauseContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AddFrontendClauseContext) FOLLOWER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFOLLOWER, 0)
}

func (s *AddFrontendClauseContext) OBSERVER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOBSERVER, 0)
}

func (s *AddFrontendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddFrontendClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddFrontendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAddFrontendClause(s)
	}
}

func (s *AddFrontendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAddFrontendClause(s)
	}
}

func (s *AddFrontendClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAddFrontendClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AddFrontendClause() (localctx IAddFrontendClauseContext) {
	localctx = NewAddFrontendClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, DorisSQLParserRULE_addFrontendClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2685)
		p.Match(DorisSQLParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2686)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserFOLLOWER || _la == DorisSQLParserOBSERVER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2687)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropFrontendClauseContext is an interface to support dynamic dispatch.
type IDropFrontendClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	String_() IStringContext
	FOLLOWER() antlr.TerminalNode
	OBSERVER() antlr.TerminalNode

	// IsDropFrontendClauseContext differentiates from other interfaces.
	IsDropFrontendClauseContext()
}

type DropFrontendClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropFrontendClauseContext() *DropFrontendClauseContext {
	var p = new(DropFrontendClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropFrontendClause
	return p
}

func InitEmptyDropFrontendClauseContext(p *DropFrontendClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropFrontendClause
}

func (*DropFrontendClauseContext) IsDropFrontendClauseContext() {}

func NewDropFrontendClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFrontendClauseContext {
	var p = new(DropFrontendClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropFrontendClause

	return p
}

func (s *DropFrontendClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFrontendClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropFrontendClauseContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DropFrontendClauseContext) FOLLOWER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFOLLOWER, 0)
}

func (s *DropFrontendClauseContext) OBSERVER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOBSERVER, 0)
}

func (s *DropFrontendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFrontendClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropFrontendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropFrontendClause(s)
	}
}

func (s *DropFrontendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropFrontendClause(s)
	}
}

func (s *DropFrontendClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropFrontendClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropFrontendClause() (localctx IDropFrontendClauseContext) {
	localctx = NewDropFrontendClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, DorisSQLParserRULE_dropFrontendClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2689)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2690)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserFOLLOWER || _la == DorisSQLParserOBSERVER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2691)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyFrontendHostClauseContext is an interface to support dynamic dispatch.
type IModifyFrontendHostClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODIFY() antlr.TerminalNode
	FRONTEND() antlr.TerminalNode
	HOST() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	TO() antlr.TerminalNode

	// IsModifyFrontendHostClauseContext differentiates from other interfaces.
	IsModifyFrontendHostClauseContext()
}

type ModifyFrontendHostClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyFrontendHostClauseContext() *ModifyFrontendHostClauseContext {
	var p = new(ModifyFrontendHostClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_modifyFrontendHostClause
	return p
}

func InitEmptyModifyFrontendHostClauseContext(p *ModifyFrontendHostClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_modifyFrontendHostClause
}

func (*ModifyFrontendHostClauseContext) IsModifyFrontendHostClauseContext() {}

func NewModifyFrontendHostClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyFrontendHostClauseContext {
	var p = new(ModifyFrontendHostClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_modifyFrontendHostClause

	return p
}

func (s *ModifyFrontendHostClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyFrontendHostClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMODIFY, 0)
}

func (s *ModifyFrontendHostClauseContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFRONTEND, 0)
}

func (s *ModifyFrontendHostClauseContext) HOST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserHOST, 0)
}

func (s *ModifyFrontendHostClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ModifyFrontendHostClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ModifyFrontendHostClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTO, 0)
}

func (s *ModifyFrontendHostClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyFrontendHostClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyFrontendHostClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterModifyFrontendHostClause(s)
	}
}

func (s *ModifyFrontendHostClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitModifyFrontendHostClause(s)
	}
}

func (s *ModifyFrontendHostClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitModifyFrontendHostClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ModifyFrontendHostClause() (localctx IModifyFrontendHostClauseContext) {
	localctx = NewModifyFrontendHostClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, DorisSQLParserRULE_modifyFrontendHostClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2693)
		p.Match(DorisSQLParserMODIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2694)
		p.Match(DorisSQLParserFRONTEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2695)
		p.Match(DorisSQLParserHOST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2696)
		p.String_()
	}
	{
		p.SetState(2697)
		p.Match(DorisSQLParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2698)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddBackendClauseContext is an interface to support dynamic dispatch.
type IAddBackendClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	ADD() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	INTO() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext
	CNGROUP() antlr.TerminalNode

	// IsAddBackendClauseContext differentiates from other interfaces.
	IsAddBackendClauseContext()
}

type AddBackendClauseContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyAddBackendClauseContext() *AddBackendClauseContext {
	var p = new(AddBackendClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_addBackendClause
	return p
}

func InitEmptyAddBackendClauseContext(p *AddBackendClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_addBackendClause
}

func (*AddBackendClauseContext) IsAddBackendClauseContext() {}

func NewAddBackendClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddBackendClauseContext {
	var p = new(AddBackendClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_addBackendClause

	return p
}

func (s *AddBackendClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddBackendClauseContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *AddBackendClauseContext) GetCngroupName() IIdentifierOrStringContext { return s.cngroupName }

func (s *AddBackendClauseContext) SetWarehouseName(v IIdentifierOrStringContext) { s.warehouseName = v }

func (s *AddBackendClauseContext) SetCngroupName(v IIdentifierOrStringContext) { s.cngroupName = v }

func (s *AddBackendClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADD, 0)
}

func (s *AddBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBACKEND, 0)
}

func (s *AddBackendClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *AddBackendClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AddBackendClauseContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTO, 0)
}

func (s *AddBackendClauseContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWAREHOUSE, 0)
}

func (s *AddBackendClauseContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *AddBackendClauseContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AddBackendClauseContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCNGROUP, 0)
}

func (s *AddBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddBackendClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAddBackendClause(s)
	}
}

func (s *AddBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAddBackendClause(s)
	}
}

func (s *AddBackendClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAddBackendClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AddBackendClause() (localctx IAddBackendClauseContext) {
	localctx = NewAddBackendClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, DorisSQLParserRULE_addBackendClause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2700)
		p.Match(DorisSQLParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2701)
		p.Match(DorisSQLParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2702)
		p.String_()
	}
	p.SetState(2707)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 197, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2703)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2704)
				p.String_()
			}

		}
		p.SetState(2709)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 197, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2717)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserINTO {
		{
			p.SetState(2710)
			p.Match(DorisSQLParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2711)
			p.Match(DorisSQLParserWAREHOUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2712)

			var _x = p.IdentifierOrString()

			localctx.(*AddBackendClauseContext).warehouseName = _x
		}
		p.SetState(2715)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserCNGROUP {
			{
				p.SetState(2713)
				p.Match(DorisSQLParserCNGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2714)

				var _x = p.IdentifierOrString()

				localctx.(*AddBackendClauseContext).cngroupName = _x
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropBackendClauseContext is an interface to support dynamic dispatch.
type IDropBackendClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	FROM() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	FORCE() antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext
	CNGROUP() antlr.TerminalNode

	// IsDropBackendClauseContext differentiates from other interfaces.
	IsDropBackendClauseContext()
}

type DropBackendClauseContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyDropBackendClauseContext() *DropBackendClauseContext {
	var p = new(DropBackendClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropBackendClause
	return p
}

func InitEmptyDropBackendClauseContext(p *DropBackendClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropBackendClause
}

func (*DropBackendClauseContext) IsDropBackendClauseContext() {}

func NewDropBackendClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropBackendClauseContext {
	var p = new(DropBackendClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropBackendClause

	return p
}

func (s *DropBackendClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropBackendClauseContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *DropBackendClauseContext) GetCngroupName() IIdentifierOrStringContext { return s.cngroupName }

func (s *DropBackendClauseContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *DropBackendClauseContext) SetCngroupName(v IIdentifierOrStringContext) { s.cngroupName = v }

func (s *DropBackendClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBACKEND, 0)
}

func (s *DropBackendClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *DropBackendClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DropBackendClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *DropBackendClauseContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWAREHOUSE, 0)
}

func (s *DropBackendClauseContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFORCE, 0)
}

func (s *DropBackendClauseContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *DropBackendClauseContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropBackendClauseContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCNGROUP, 0)
}

func (s *DropBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropBackendClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropBackendClause(s)
	}
}

func (s *DropBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropBackendClause(s)
	}
}

func (s *DropBackendClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropBackendClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropBackendClause() (localctx IDropBackendClauseContext) {
	localctx = NewDropBackendClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, DorisSQLParserRULE_dropBackendClause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2719)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2720)
		p.Match(DorisSQLParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2721)
		p.String_()
	}
	p.SetState(2726)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 200, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2722)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2723)
				p.String_()
			}

		}
		p.SetState(2728)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 200, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2736)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM {
		{
			p.SetState(2729)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2730)
			p.Match(DorisSQLParserWAREHOUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2731)

			var _x = p.IdentifierOrString()

			localctx.(*DropBackendClauseContext).warehouseName = _x
		}
		p.SetState(2734)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserCNGROUP {
			{
				p.SetState(2732)
				p.Match(DorisSQLParserCNGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2733)

				var _x = p.IdentifierOrString()

				localctx.(*DropBackendClauseContext).cngroupName = _x
			}

		}

	}
	p.SetState(2739)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFORCE {
		{
			p.SetState(2738)
			p.Match(DorisSQLParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecommissionBackendClauseContext is an interface to support dynamic dispatch.
type IDecommissionBackendClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECOMMISSION() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsDecommissionBackendClauseContext differentiates from other interfaces.
	IsDecommissionBackendClauseContext()
}

type DecommissionBackendClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecommissionBackendClauseContext() *DecommissionBackendClauseContext {
	var p = new(DecommissionBackendClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_decommissionBackendClause
	return p
}

func InitEmptyDecommissionBackendClauseContext(p *DecommissionBackendClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_decommissionBackendClause
}

func (*DecommissionBackendClauseContext) IsDecommissionBackendClauseContext() {}

func NewDecommissionBackendClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecommissionBackendClauseContext {
	var p = new(DecommissionBackendClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_decommissionBackendClause

	return p
}

func (s *DecommissionBackendClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DecommissionBackendClauseContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDECOMMISSION, 0)
}

func (s *DecommissionBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBACKEND, 0)
}

func (s *DecommissionBackendClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *DecommissionBackendClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DecommissionBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecommissionBackendClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecommissionBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDecommissionBackendClause(s)
	}
}

func (s *DecommissionBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDecommissionBackendClause(s)
	}
}

func (s *DecommissionBackendClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDecommissionBackendClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DecommissionBackendClause() (localctx IDecommissionBackendClauseContext) {
	localctx = NewDecommissionBackendClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, DorisSQLParserRULE_decommissionBackendClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2741)
		p.Match(DorisSQLParserDECOMMISSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2742)
		p.Match(DorisSQLParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2743)
		p.String_()
	}
	p.SetState(2748)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 204, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2744)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2745)
				p.String_()
			}

		}
		p.SetState(2750)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 204, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyBackendClauseContext is an interface to support dynamic dispatch.
type IModifyBackendClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODIFY() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	HOST() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	TO() antlr.TerminalNode
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsModifyBackendClauseContext differentiates from other interfaces.
	IsModifyBackendClauseContext()
}

type ModifyBackendClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyBackendClauseContext() *ModifyBackendClauseContext {
	var p = new(ModifyBackendClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_modifyBackendClause
	return p
}

func InitEmptyModifyBackendClauseContext(p *ModifyBackendClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_modifyBackendClause
}

func (*ModifyBackendClauseContext) IsModifyBackendClauseContext() {}

func NewModifyBackendClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyBackendClauseContext {
	var p = new(ModifyBackendClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_modifyBackendClause

	return p
}

func (s *ModifyBackendClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyBackendClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMODIFY, 0)
}

func (s *ModifyBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBACKEND, 0)
}

func (s *ModifyBackendClauseContext) HOST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserHOST, 0)
}

func (s *ModifyBackendClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ModifyBackendClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ModifyBackendClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTO, 0)
}

func (s *ModifyBackendClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *ModifyBackendClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *ModifyBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyBackendClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterModifyBackendClause(s)
	}
}

func (s *ModifyBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitModifyBackendClause(s)
	}
}

func (s *ModifyBackendClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitModifyBackendClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ModifyBackendClause() (localctx IModifyBackendClauseContext) {
	localctx = NewModifyBackendClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, DorisSQLParserRULE_modifyBackendClause)
	p.SetState(2764)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 205, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2751)
			p.Match(DorisSQLParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2752)
			p.Match(DorisSQLParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2753)
			p.Match(DorisSQLParserHOST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2754)
			p.String_()
		}
		{
			p.SetState(2755)
			p.Match(DorisSQLParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2756)
			p.String_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2758)
			p.Match(DorisSQLParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2759)
			p.Match(DorisSQLParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2760)
			p.String_()
		}
		{
			p.SetState(2761)
			p.Match(DorisSQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2762)
			p.PropertyList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddComputeNodeClauseContext is an interface to support dynamic dispatch.
type IAddComputeNodeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	ADD() antlr.TerminalNode
	COMPUTE() antlr.TerminalNode
	NODE() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	INTO() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext
	CNGROUP() antlr.TerminalNode

	// IsAddComputeNodeClauseContext differentiates from other interfaces.
	IsAddComputeNodeClauseContext()
}

type AddComputeNodeClauseContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyAddComputeNodeClauseContext() *AddComputeNodeClauseContext {
	var p = new(AddComputeNodeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_addComputeNodeClause
	return p
}

func InitEmptyAddComputeNodeClauseContext(p *AddComputeNodeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_addComputeNodeClause
}

func (*AddComputeNodeClauseContext) IsAddComputeNodeClauseContext() {}

func NewAddComputeNodeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddComputeNodeClauseContext {
	var p = new(AddComputeNodeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_addComputeNodeClause

	return p
}

func (s *AddComputeNodeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddComputeNodeClauseContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *AddComputeNodeClauseContext) GetCngroupName() IIdentifierOrStringContext {
	return s.cngroupName
}

func (s *AddComputeNodeClauseContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *AddComputeNodeClauseContext) SetCngroupName(v IIdentifierOrStringContext) { s.cngroupName = v }

func (s *AddComputeNodeClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADD, 0)
}

func (s *AddComputeNodeClauseContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOMPUTE, 0)
}

func (s *AddComputeNodeClauseContext) NODE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNODE, 0)
}

func (s *AddComputeNodeClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *AddComputeNodeClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AddComputeNodeClauseContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTO, 0)
}

func (s *AddComputeNodeClauseContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWAREHOUSE, 0)
}

func (s *AddComputeNodeClauseContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *AddComputeNodeClauseContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AddComputeNodeClauseContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCNGROUP, 0)
}

func (s *AddComputeNodeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddComputeNodeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddComputeNodeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAddComputeNodeClause(s)
	}
}

func (s *AddComputeNodeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAddComputeNodeClause(s)
	}
}

func (s *AddComputeNodeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAddComputeNodeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AddComputeNodeClause() (localctx IAddComputeNodeClauseContext) {
	localctx = NewAddComputeNodeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, DorisSQLParserRULE_addComputeNodeClause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2766)
		p.Match(DorisSQLParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2767)
		p.Match(DorisSQLParserCOMPUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2768)
		p.Match(DorisSQLParserNODE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2769)
		p.String_()
	}
	p.SetState(2774)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2770)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2771)
				p.String_()
			}

		}
		p.SetState(2776)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2784)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserINTO {
		{
			p.SetState(2777)
			p.Match(DorisSQLParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2778)
			p.Match(DorisSQLParserWAREHOUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2779)

			var _x = p.IdentifierOrString()

			localctx.(*AddComputeNodeClauseContext).warehouseName = _x
		}
		p.SetState(2782)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserCNGROUP {
			{
				p.SetState(2780)
				p.Match(DorisSQLParserCNGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2781)

				var _x = p.IdentifierOrString()

				localctx.(*AddComputeNodeClauseContext).cngroupName = _x
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropComputeNodeClauseContext is an interface to support dynamic dispatch.
type IDropComputeNodeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	COMPUTE() antlr.TerminalNode
	NODE() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	FROM() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext
	CNGROUP() antlr.TerminalNode

	// IsDropComputeNodeClauseContext differentiates from other interfaces.
	IsDropComputeNodeClauseContext()
}

type DropComputeNodeClauseContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyDropComputeNodeClauseContext() *DropComputeNodeClauseContext {
	var p = new(DropComputeNodeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropComputeNodeClause
	return p
}

func InitEmptyDropComputeNodeClauseContext(p *DropComputeNodeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropComputeNodeClause
}

func (*DropComputeNodeClauseContext) IsDropComputeNodeClauseContext() {}

func NewDropComputeNodeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropComputeNodeClauseContext {
	var p = new(DropComputeNodeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropComputeNodeClause

	return p
}

func (s *DropComputeNodeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropComputeNodeClauseContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *DropComputeNodeClauseContext) GetCngroupName() IIdentifierOrStringContext {
	return s.cngroupName
}

func (s *DropComputeNodeClauseContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *DropComputeNodeClauseContext) SetCngroupName(v IIdentifierOrStringContext) {
	s.cngroupName = v
}

func (s *DropComputeNodeClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropComputeNodeClauseContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOMPUTE, 0)
}

func (s *DropComputeNodeClauseContext) NODE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNODE, 0)
}

func (s *DropComputeNodeClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *DropComputeNodeClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DropComputeNodeClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *DropComputeNodeClauseContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWAREHOUSE, 0)
}

func (s *DropComputeNodeClauseContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *DropComputeNodeClauseContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropComputeNodeClauseContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCNGROUP, 0)
}

func (s *DropComputeNodeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropComputeNodeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropComputeNodeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropComputeNodeClause(s)
	}
}

func (s *DropComputeNodeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropComputeNodeClause(s)
	}
}

func (s *DropComputeNodeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropComputeNodeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropComputeNodeClause() (localctx IDropComputeNodeClauseContext) {
	localctx = NewDropComputeNodeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, DorisSQLParserRULE_dropComputeNodeClause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2786)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2787)
		p.Match(DorisSQLParserCOMPUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2788)
		p.Match(DorisSQLParserNODE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2789)
		p.String_()
	}
	p.SetState(2794)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 209, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2790)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2791)
				p.String_()
			}

		}
		p.SetState(2796)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 209, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2804)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM {
		{
			p.SetState(2797)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2798)
			p.Match(DorisSQLParserWAREHOUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2799)

			var _x = p.IdentifierOrString()

			localctx.(*DropComputeNodeClauseContext).warehouseName = _x
		}
		p.SetState(2802)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserCNGROUP {
			{
				p.SetState(2800)
				p.Match(DorisSQLParserCNGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2801)

				var _x = p.IdentifierOrString()

				localctx.(*DropComputeNodeClauseContext).cngroupName = _x
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyBrokerClauseContext is an interface to support dynamic dispatch.
type IModifyBrokerClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	AllString_() []IStringContext
	String_(i int) IStringContext
	DROP() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsModifyBrokerClauseContext differentiates from other interfaces.
	IsModifyBrokerClauseContext()
}

type ModifyBrokerClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyBrokerClauseContext() *ModifyBrokerClauseContext {
	var p = new(ModifyBrokerClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_modifyBrokerClause
	return p
}

func InitEmptyModifyBrokerClauseContext(p *ModifyBrokerClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_modifyBrokerClause
}

func (*ModifyBrokerClauseContext) IsModifyBrokerClauseContext() {}

func NewModifyBrokerClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyBrokerClauseContext {
	var p = new(ModifyBrokerClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_modifyBrokerClause

	return p
}

func (s *ModifyBrokerClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyBrokerClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADD, 0)
}

func (s *ModifyBrokerClauseContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBROKER, 0)
}

func (s *ModifyBrokerClauseContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *ModifyBrokerClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ModifyBrokerClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ModifyBrokerClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *ModifyBrokerClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, 0)
}

func (s *ModifyBrokerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyBrokerClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyBrokerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterModifyBrokerClause(s)
	}
}

func (s *ModifyBrokerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitModifyBrokerClause(s)
	}
}

func (s *ModifyBrokerClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitModifyBrokerClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ModifyBrokerClause() (localctx IModifyBrokerClauseContext) {
	localctx = NewModifyBrokerClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, DorisSQLParserRULE_modifyBrokerClause)
	var _alt int

	p.SetState(2832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 214, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2806)
			p.Match(DorisSQLParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2807)
			p.Match(DorisSQLParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2808)
			p.IdentifierOrString()
		}
		{
			p.SetState(2809)
			p.String_()
		}
		p.SetState(2814)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2810)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2811)
					p.String_()
				}

			}
			p.SetState(2816)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2817)
			p.Match(DorisSQLParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2818)
			p.Match(DorisSQLParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2819)
			p.IdentifierOrString()
		}
		{
			p.SetState(2820)
			p.String_()
		}
		p.SetState(2825)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 213, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2821)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2822)
					p.String_()
				}

			}
			p.SetState(2827)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 213, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2828)
			p.Match(DorisSQLParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2829)
			p.Match(DorisSQLParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2830)
			p.Match(DorisSQLParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2831)
			p.IdentifierOrString()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterLoadErrorUrlClauseContext is an interface to support dynamic dispatch.
type IAlterLoadErrorUrlClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	ERRORS() antlr.TerminalNode
	HUB() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsAlterLoadErrorUrlClauseContext differentiates from other interfaces.
	IsAlterLoadErrorUrlClauseContext()
}

type AlterLoadErrorUrlClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterLoadErrorUrlClauseContext() *AlterLoadErrorUrlClauseContext {
	var p = new(AlterLoadErrorUrlClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterLoadErrorUrlClause
	return p
}

func InitEmptyAlterLoadErrorUrlClauseContext(p *AlterLoadErrorUrlClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterLoadErrorUrlClause
}

func (*AlterLoadErrorUrlClauseContext) IsAlterLoadErrorUrlClauseContext() {}

func NewAlterLoadErrorUrlClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterLoadErrorUrlClauseContext {
	var p = new(AlterLoadErrorUrlClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_alterLoadErrorUrlClause

	return p
}

func (s *AlterLoadErrorUrlClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterLoadErrorUrlClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *AlterLoadErrorUrlClauseContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOAD, 0)
}

func (s *AlterLoadErrorUrlClauseContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserERRORS, 0)
}

func (s *AlterLoadErrorUrlClauseContext) HUB() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserHUB, 0)
}

func (s *AlterLoadErrorUrlClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AlterLoadErrorUrlClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterLoadErrorUrlClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterLoadErrorUrlClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAlterLoadErrorUrlClause(s)
	}
}

func (s *AlterLoadErrorUrlClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAlterLoadErrorUrlClause(s)
	}
}

func (s *AlterLoadErrorUrlClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAlterLoadErrorUrlClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AlterLoadErrorUrlClause() (localctx IAlterLoadErrorUrlClauseContext) {
	localctx = NewAlterLoadErrorUrlClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, DorisSQLParserRULE_alterLoadErrorUrlClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2834)
		p.Match(DorisSQLParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2835)
		p.Match(DorisSQLParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2836)
		p.Match(DorisSQLParserERRORS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2837)
		p.Match(DorisSQLParserHUB)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(2838)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateImageClauseContext is an interface to support dynamic dispatch.
type ICreateImageClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	IMAGE() antlr.TerminalNode

	// IsCreateImageClauseContext differentiates from other interfaces.
	IsCreateImageClauseContext()
}

type CreateImageClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateImageClauseContext() *CreateImageClauseContext {
	var p = new(CreateImageClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createImageClause
	return p
}

func InitEmptyCreateImageClauseContext(p *CreateImageClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createImageClause
}

func (*CreateImageClauseContext) IsCreateImageClauseContext() {}

func NewCreateImageClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateImageClauseContext {
	var p = new(CreateImageClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createImageClause

	return p
}

func (s *CreateImageClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateImageClauseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateImageClauseContext) IMAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIMAGE, 0)
}

func (s *CreateImageClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateImageClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateImageClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateImageClause(s)
	}
}

func (s *CreateImageClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateImageClause(s)
	}
}

func (s *CreateImageClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateImageClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateImageClause() (localctx ICreateImageClauseContext) {
	localctx = NewCreateImageClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, DorisSQLParserRULE_createImageClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2841)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2842)
		p.Match(DorisSQLParserIMAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICleanTabletSchedQClauseContext is an interface to support dynamic dispatch.
type ICleanTabletSchedQClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLEAN() antlr.TerminalNode
	TABLET() antlr.TerminalNode
	SCHEDULER() antlr.TerminalNode
	QUEUE() antlr.TerminalNode

	// IsCleanTabletSchedQClauseContext differentiates from other interfaces.
	IsCleanTabletSchedQClauseContext()
}

type CleanTabletSchedQClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCleanTabletSchedQClauseContext() *CleanTabletSchedQClauseContext {
	var p = new(CleanTabletSchedQClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cleanTabletSchedQClause
	return p
}

func InitEmptyCleanTabletSchedQClauseContext(p *CleanTabletSchedQClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cleanTabletSchedQClause
}

func (*CleanTabletSchedQClauseContext) IsCleanTabletSchedQClauseContext() {}

func NewCleanTabletSchedQClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CleanTabletSchedQClauseContext {
	var p = new(CleanTabletSchedQClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_cleanTabletSchedQClause

	return p
}

func (s *CleanTabletSchedQClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CleanTabletSchedQClauseContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCLEAN, 0)
}

func (s *CleanTabletSchedQClauseContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLET, 0)
}

func (s *CleanTabletSchedQClauseContext) SCHEDULER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSCHEDULER, 0)
}

func (s *CleanTabletSchedQClauseContext) QUEUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserQUEUE, 0)
}

func (s *CleanTabletSchedQClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CleanTabletSchedQClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CleanTabletSchedQClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCleanTabletSchedQClause(s)
	}
}

func (s *CleanTabletSchedQClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCleanTabletSchedQClause(s)
	}
}

func (s *CleanTabletSchedQClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCleanTabletSchedQClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CleanTabletSchedQClause() (localctx ICleanTabletSchedQClauseContext) {
	localctx = NewCleanTabletSchedQClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, DorisSQLParserRULE_cleanTabletSchedQClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2844)
		p.Match(DorisSQLParserCLEAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2845)
		p.Match(DorisSQLParserTABLET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2846)
		p.Match(DorisSQLParserSCHEDULER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2847)
		p.Match(DorisSQLParserQUEUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecommissionDiskClauseContext is an interface to support dynamic dispatch.
type IDecommissionDiskClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECOMMISSION() antlr.TerminalNode
	DISK() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	ON() antlr.TerminalNode
	BACKEND() antlr.TerminalNode

	// IsDecommissionDiskClauseContext differentiates from other interfaces.
	IsDecommissionDiskClauseContext()
}

type DecommissionDiskClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecommissionDiskClauseContext() *DecommissionDiskClauseContext {
	var p = new(DecommissionDiskClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_decommissionDiskClause
	return p
}

func InitEmptyDecommissionDiskClauseContext(p *DecommissionDiskClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_decommissionDiskClause
}

func (*DecommissionDiskClauseContext) IsDecommissionDiskClauseContext() {}

func NewDecommissionDiskClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecommissionDiskClauseContext {
	var p = new(DecommissionDiskClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_decommissionDiskClause

	return p
}

func (s *DecommissionDiskClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DecommissionDiskClauseContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDECOMMISSION, 0)
}

func (s *DecommissionDiskClauseContext) DISK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDISK, 0)
}

func (s *DecommissionDiskClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *DecommissionDiskClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DecommissionDiskClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *DecommissionDiskClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBACKEND, 0)
}

func (s *DecommissionDiskClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecommissionDiskClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecommissionDiskClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDecommissionDiskClause(s)
	}
}

func (s *DecommissionDiskClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDecommissionDiskClause(s)
	}
}

func (s *DecommissionDiskClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDecommissionDiskClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DecommissionDiskClause() (localctx IDecommissionDiskClauseContext) {
	localctx = NewDecommissionDiskClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, DorisSQLParserRULE_decommissionDiskClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2849)
		p.Match(DorisSQLParserDECOMMISSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2850)
		p.Match(DorisSQLParserDISK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2851)
		p.String_()
	}
	p.SetState(2856)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(2852)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2853)
			p.String_()
		}

		p.SetState(2858)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2859)
		p.Match(DorisSQLParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2860)
		p.Match(DorisSQLParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2861)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelDecommissionDiskClauseContext is an interface to support dynamic dispatch.
type ICancelDecommissionDiskClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	DECOMMISSION() antlr.TerminalNode
	DISK() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	ON() antlr.TerminalNode
	BACKEND() antlr.TerminalNode

	// IsCancelDecommissionDiskClauseContext differentiates from other interfaces.
	IsCancelDecommissionDiskClauseContext()
}

type CancelDecommissionDiskClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelDecommissionDiskClauseContext() *CancelDecommissionDiskClauseContext {
	var p = new(CancelDecommissionDiskClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cancelDecommissionDiskClause
	return p
}

func InitEmptyCancelDecommissionDiskClauseContext(p *CancelDecommissionDiskClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cancelDecommissionDiskClause
}

func (*CancelDecommissionDiskClauseContext) IsCancelDecommissionDiskClauseContext() {}

func NewCancelDecommissionDiskClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelDecommissionDiskClauseContext {
	var p = new(CancelDecommissionDiskClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_cancelDecommissionDiskClause

	return p
}

func (s *CancelDecommissionDiskClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelDecommissionDiskClauseContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCANCEL, 0)
}

func (s *CancelDecommissionDiskClauseContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDECOMMISSION, 0)
}

func (s *CancelDecommissionDiskClauseContext) DISK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDISK, 0)
}

func (s *CancelDecommissionDiskClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *CancelDecommissionDiskClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CancelDecommissionDiskClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *CancelDecommissionDiskClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBACKEND, 0)
}

func (s *CancelDecommissionDiskClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelDecommissionDiskClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelDecommissionDiskClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCancelDecommissionDiskClause(s)
	}
}

func (s *CancelDecommissionDiskClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCancelDecommissionDiskClause(s)
	}
}

func (s *CancelDecommissionDiskClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCancelDecommissionDiskClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CancelDecommissionDiskClause() (localctx ICancelDecommissionDiskClauseContext) {
	localctx = NewCancelDecommissionDiskClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, DorisSQLParserRULE_cancelDecommissionDiskClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2863)
		p.Match(DorisSQLParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2864)
		p.Match(DorisSQLParserDECOMMISSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2865)
		p.Match(DorisSQLParserDISK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2866)
		p.String_()
	}
	p.SetState(2871)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(2867)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2868)
			p.String_()
		}

		p.SetState(2873)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2874)
		p.Match(DorisSQLParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2875)
		p.Match(DorisSQLParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2876)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDisableDiskClauseContext is an interface to support dynamic dispatch.
type IDisableDiskClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISABLE() antlr.TerminalNode
	DISK() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	ON() antlr.TerminalNode
	BACKEND() antlr.TerminalNode

	// IsDisableDiskClauseContext differentiates from other interfaces.
	IsDisableDiskClauseContext()
}

type DisableDiskClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisableDiskClauseContext() *DisableDiskClauseContext {
	var p = new(DisableDiskClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_disableDiskClause
	return p
}

func InitEmptyDisableDiskClauseContext(p *DisableDiskClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_disableDiskClause
}

func (*DisableDiskClauseContext) IsDisableDiskClauseContext() {}

func NewDisableDiskClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisableDiskClauseContext {
	var p = new(DisableDiskClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_disableDiskClause

	return p
}

func (s *DisableDiskClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DisableDiskClauseContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDISABLE, 0)
}

func (s *DisableDiskClauseContext) DISK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDISK, 0)
}

func (s *DisableDiskClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *DisableDiskClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DisableDiskClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *DisableDiskClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBACKEND, 0)
}

func (s *DisableDiskClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisableDiskClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisableDiskClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDisableDiskClause(s)
	}
}

func (s *DisableDiskClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDisableDiskClause(s)
	}
}

func (s *DisableDiskClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDisableDiskClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DisableDiskClause() (localctx IDisableDiskClauseContext) {
	localctx = NewDisableDiskClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, DorisSQLParserRULE_disableDiskClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2878)
		p.Match(DorisSQLParserDISABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2879)
		p.Match(DorisSQLParserDISK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2880)
		p.String_()
	}
	p.SetState(2885)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(2881)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2882)
			p.String_()
		}

		p.SetState(2887)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2888)
		p.Match(DorisSQLParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2889)
		p.Match(DorisSQLParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2890)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelDisableDiskClauseContext is an interface to support dynamic dispatch.
type ICancelDisableDiskClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	DISK() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	ON() antlr.TerminalNode
	BACKEND() antlr.TerminalNode

	// IsCancelDisableDiskClauseContext differentiates from other interfaces.
	IsCancelDisableDiskClauseContext()
}

type CancelDisableDiskClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelDisableDiskClauseContext() *CancelDisableDiskClauseContext {
	var p = new(CancelDisableDiskClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cancelDisableDiskClause
	return p
}

func InitEmptyCancelDisableDiskClauseContext(p *CancelDisableDiskClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cancelDisableDiskClause
}

func (*CancelDisableDiskClauseContext) IsCancelDisableDiskClauseContext() {}

func NewCancelDisableDiskClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelDisableDiskClauseContext {
	var p = new(CancelDisableDiskClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_cancelDisableDiskClause

	return p
}

func (s *CancelDisableDiskClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelDisableDiskClauseContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCANCEL, 0)
}

func (s *CancelDisableDiskClauseContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDISABLE, 0)
}

func (s *CancelDisableDiskClauseContext) DISK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDISK, 0)
}

func (s *CancelDisableDiskClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *CancelDisableDiskClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CancelDisableDiskClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *CancelDisableDiskClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBACKEND, 0)
}

func (s *CancelDisableDiskClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelDisableDiskClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelDisableDiskClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCancelDisableDiskClause(s)
	}
}

func (s *CancelDisableDiskClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCancelDisableDiskClause(s)
	}
}

func (s *CancelDisableDiskClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCancelDisableDiskClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CancelDisableDiskClause() (localctx ICancelDisableDiskClauseContext) {
	localctx = NewCancelDisableDiskClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, DorisSQLParserRULE_cancelDisableDiskClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2892)
		p.Match(DorisSQLParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2893)
		p.Match(DorisSQLParserDISABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2894)
		p.Match(DorisSQLParserDISK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2895)
		p.String_()
	}
	p.SetState(2900)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(2896)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2897)
			p.String_()
		}

		p.SetState(2902)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2903)
		p.Match(DorisSQLParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2904)
		p.Match(DorisSQLParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2905)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateIndexClauseContext is an interface to support dynamic dispatch.
type ICreateIndexClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// Getter signatures
	ADD() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	Identifier() IIdentifierContext
	IndexType() IIndexTypeContext
	Comment() ICommentContext
	PropertyList() IPropertyListContext

	// IsCreateIndexClauseContext differentiates from other interfaces.
	IsCreateIndexClauseContext()
}

type CreateIndexClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	indexName IIdentifierContext
}

func NewEmptyCreateIndexClauseContext() *CreateIndexClauseContext {
	var p = new(CreateIndexClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createIndexClause
	return p
}

func InitEmptyCreateIndexClauseContext(p *CreateIndexClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createIndexClause
}

func (*CreateIndexClauseContext) IsCreateIndexClauseContext() {}

func NewCreateIndexClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateIndexClauseContext {
	var p = new(CreateIndexClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createIndexClause

	return p
}

func (s *CreateIndexClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateIndexClauseContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *CreateIndexClauseContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *CreateIndexClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADD, 0)
}

func (s *CreateIndexClauseContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINDEX, 0)
}

func (s *CreateIndexClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateIndexClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateIndexClauseContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *CreateIndexClauseContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateIndexClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *CreateIndexClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateIndexClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateIndexClause(s)
	}
}

func (s *CreateIndexClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateIndexClause(s)
	}
}

func (s *CreateIndexClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateIndexClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateIndexClause() (localctx ICreateIndexClauseContext) {
	localctx = NewCreateIndexClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, DorisSQLParserRULE_createIndexClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2907)
		p.Match(DorisSQLParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2908)
		p.Match(DorisSQLParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2909)

		var _x = p.Identifier()

		localctx.(*CreateIndexClauseContext).indexName = _x
	}
	{
		p.SetState(2910)
		p.IdentifierList()
	}
	p.SetState(2915)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserUSING {
		{
			p.SetState(2911)
			p.IndexType()
		}
		p.SetState(2913)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__1 {
			{
				p.SetState(2912)
				p.PropertyList()
			}

		}

	}
	p.SetState(2918)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserCOMMENT {
		{
			p.SetState(2917)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropIndexClauseContext is an interface to support dynamic dispatch.
type IDropIndexClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDropIndexClauseContext differentiates from other interfaces.
	IsDropIndexClauseContext()
}

type DropIndexClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	indexName IIdentifierContext
}

func NewEmptyDropIndexClauseContext() *DropIndexClauseContext {
	var p = new(DropIndexClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropIndexClause
	return p
}

func InitEmptyDropIndexClauseContext(p *DropIndexClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropIndexClause
}

func (*DropIndexClauseContext) IsDropIndexClauseContext() {}

func NewDropIndexClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropIndexClauseContext {
	var p = new(DropIndexClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropIndexClause

	return p
}

func (s *DropIndexClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropIndexClauseContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *DropIndexClauseContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *DropIndexClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropIndexClauseContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINDEX, 0)
}

func (s *DropIndexClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropIndexClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropIndexClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropIndexClause(s)
	}
}

func (s *DropIndexClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropIndexClause(s)
	}
}

func (s *DropIndexClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropIndexClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropIndexClause() (localctx IDropIndexClauseContext) {
	localctx = NewDropIndexClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, DorisSQLParserRULE_dropIndexClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2920)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2921)
		p.Match(DorisSQLParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2922)

		var _x = p.Identifier()

		localctx.(*DropIndexClauseContext).indexName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableRenameClauseContext is an interface to support dynamic dispatch.
type ITableRenameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RENAME() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsTableRenameClauseContext differentiates from other interfaces.
	IsTableRenameClauseContext()
}

type TableRenameClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableRenameClauseContext() *TableRenameClauseContext {
	var p = new(TableRenameClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_tableRenameClause
	return p
}

func InitEmptyTableRenameClauseContext(p *TableRenameClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_tableRenameClause
}

func (*TableRenameClauseContext) IsTableRenameClauseContext() {}

func NewTableRenameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableRenameClauseContext {
	var p = new(TableRenameClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_tableRenameClause

	return p
}

func (s *TableRenameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TableRenameClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRENAME, 0)
}

func (s *TableRenameClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableRenameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableRenameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableRenameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTableRenameClause(s)
	}
}

func (s *TableRenameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTableRenameClause(s)
	}
}

func (s *TableRenameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTableRenameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) TableRenameClause() (localctx ITableRenameClauseContext) {
	localctx = NewTableRenameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, DorisSQLParserRULE_tableRenameClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2924)
		p.Match(DorisSQLParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2925)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwapTableClauseContext is an interface to support dynamic dispatch.
type ISwapTableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SWAP() antlr.TerminalNode
	WITH() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsSwapTableClauseContext differentiates from other interfaces.
	IsSwapTableClauseContext()
}

type SwapTableClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwapTableClauseContext() *SwapTableClauseContext {
	var p = new(SwapTableClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_swapTableClause
	return p
}

func InitEmptySwapTableClauseContext(p *SwapTableClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_swapTableClause
}

func (*SwapTableClauseContext) IsSwapTableClauseContext() {}

func NewSwapTableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwapTableClauseContext {
	var p = new(SwapTableClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_swapTableClause

	return p
}

func (s *SwapTableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SwapTableClauseContext) SWAP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSWAP, 0)
}

func (s *SwapTableClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *SwapTableClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SwapTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwapTableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwapTableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSwapTableClause(s)
	}
}

func (s *SwapTableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSwapTableClause(s)
	}
}

func (s *SwapTableClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSwapTableClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SwapTableClause() (localctx ISwapTableClauseContext) {
	localctx = NewSwapTableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, DorisSQLParserRULE_swapTableClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2927)
		p.Match(DorisSQLParserSWAP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2928)
		p.Match(DorisSQLParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2929)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyPropertiesClauseContext is an interface to support dynamic dispatch.
type IModifyPropertiesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsModifyPropertiesClauseContext differentiates from other interfaces.
	IsModifyPropertiesClauseContext()
}

type ModifyPropertiesClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyPropertiesClauseContext() *ModifyPropertiesClauseContext {
	var p = new(ModifyPropertiesClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_modifyPropertiesClause
	return p
}

func InitEmptyModifyPropertiesClauseContext(p *ModifyPropertiesClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_modifyPropertiesClause
}

func (*ModifyPropertiesClauseContext) IsModifyPropertiesClauseContext() {}

func NewModifyPropertiesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyPropertiesClauseContext {
	var p = new(ModifyPropertiesClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_modifyPropertiesClause

	return p
}

func (s *ModifyPropertiesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyPropertiesClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *ModifyPropertiesClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *ModifyPropertiesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyPropertiesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyPropertiesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterModifyPropertiesClause(s)
	}
}

func (s *ModifyPropertiesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitModifyPropertiesClause(s)
	}
}

func (s *ModifyPropertiesClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitModifyPropertiesClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ModifyPropertiesClause() (localctx IModifyPropertiesClauseContext) {
	localctx = NewModifyPropertiesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, DorisSQLParserRULE_modifyPropertiesClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2931)
		p.Match(DorisSQLParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2932)
		p.PropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyCommentClauseContext is an interface to support dynamic dispatch.
type IModifyCommentClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMENT() antlr.TerminalNode
	EQ() antlr.TerminalNode
	String_() IStringContext

	// IsModifyCommentClauseContext differentiates from other interfaces.
	IsModifyCommentClauseContext()
}

type ModifyCommentClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyCommentClauseContext() *ModifyCommentClauseContext {
	var p = new(ModifyCommentClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_modifyCommentClause
	return p
}

func InitEmptyModifyCommentClauseContext(p *ModifyCommentClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_modifyCommentClause
}

func (*ModifyCommentClauseContext) IsModifyCommentClauseContext() {}

func NewModifyCommentClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyCommentClauseContext {
	var p = new(ModifyCommentClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_modifyCommentClause

	return p
}

func (s *ModifyCommentClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyCommentClauseContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOMMENT, 0)
}

func (s *ModifyCommentClauseContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEQ, 0)
}

func (s *ModifyCommentClauseContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ModifyCommentClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyCommentClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyCommentClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterModifyCommentClause(s)
	}
}

func (s *ModifyCommentClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitModifyCommentClause(s)
	}
}

func (s *ModifyCommentClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitModifyCommentClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ModifyCommentClause() (localctx IModifyCommentClauseContext) {
	localctx = NewModifyCommentClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, DorisSQLParserRULE_modifyCommentClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2934)
		p.Match(DorisSQLParserCOMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2935)
		p.Match(DorisSQLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2936)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptimizeRangeContext is an interface to support dynamic dispatch.
type IOptimizeRangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStart_ returns the start_ rule contexts.
	GetStart_() IStringContext

	// GetEnd returns the end rule contexts.
	GetEnd() IStringContext

	// SetStart_ sets the start_ rule contexts.
	SetStart_(IStringContext)

	// SetEnd sets the end rule contexts.
	SetEnd(IStringContext)

	// Getter signatures
	BETWEEN() antlr.TerminalNode
	AND() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsOptimizeRangeContext differentiates from other interfaces.
	IsOptimizeRangeContext()
}

type OptimizeRangeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	start_ IStringContext
	end    IStringContext
}

func NewEmptyOptimizeRangeContext() *OptimizeRangeContext {
	var p = new(OptimizeRangeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_optimizeRange
	return p
}

func InitEmptyOptimizeRangeContext(p *OptimizeRangeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_optimizeRange
}

func (*OptimizeRangeContext) IsOptimizeRangeContext() {}

func NewOptimizeRangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptimizeRangeContext {
	var p = new(OptimizeRangeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_optimizeRange

	return p
}

func (s *OptimizeRangeContext) GetParser() antlr.Parser { return s.parser }

func (s *OptimizeRangeContext) GetStart_() IStringContext { return s.start_ }

func (s *OptimizeRangeContext) GetEnd() IStringContext { return s.end }

func (s *OptimizeRangeContext) SetStart_(v IStringContext) { s.start_ = v }

func (s *OptimizeRangeContext) SetEnd(v IStringContext) { s.end = v }

func (s *OptimizeRangeContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBETWEEN, 0)
}

func (s *OptimizeRangeContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAND, 0)
}

func (s *OptimizeRangeContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *OptimizeRangeContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *OptimizeRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptimizeRangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptimizeRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterOptimizeRange(s)
	}
}

func (s *OptimizeRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitOptimizeRange(s)
	}
}

func (s *OptimizeRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitOptimizeRange(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) OptimizeRange() (localctx IOptimizeRangeContext) {
	localctx = NewOptimizeRangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, DorisSQLParserRULE_optimizeRange)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2938)
		p.Match(DorisSQLParserBETWEEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2939)

		var _x = p.String_()

		localctx.(*OptimizeRangeContext).start_ = _x
	}
	{
		p.SetState(2940)
		p.Match(DorisSQLParserAND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2941)

		var _x = p.String_()

		localctx.(*OptimizeRangeContext).end = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptimizeClauseContext is an interface to support dynamic dispatch.
type IOptimizeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PartitionNames() IPartitionNamesContext
	KeyDesc() IKeyDescContext
	PartitionDesc() IPartitionDescContext
	OrderByDesc() IOrderByDescContext
	DistributionDesc() IDistributionDescContext
	OptimizeRange() IOptimizeRangeContext

	// IsOptimizeClauseContext differentiates from other interfaces.
	IsOptimizeClauseContext()
}

type OptimizeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptimizeClauseContext() *OptimizeClauseContext {
	var p = new(OptimizeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_optimizeClause
	return p
}

func InitEmptyOptimizeClauseContext(p *OptimizeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_optimizeClause
}

func (*OptimizeClauseContext) IsOptimizeClauseContext() {}

func NewOptimizeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptimizeClauseContext {
	var p = new(OptimizeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_optimizeClause

	return p
}

func (s *OptimizeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OptimizeClauseContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *OptimizeClauseContext) KeyDesc() IKeyDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyDescContext)
}

func (s *OptimizeClauseContext) PartitionDesc() IPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDescContext)
}

func (s *OptimizeClauseContext) OrderByDesc() IOrderByDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByDescContext)
}

func (s *OptimizeClauseContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *OptimizeClauseContext) OptimizeRange() IOptimizeRangeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptimizeRangeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptimizeRangeContext)
}

func (s *OptimizeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptimizeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptimizeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterOptimizeClause(s)
	}
}

func (s *OptimizeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitOptimizeClause(s)
	}
}

func (s *OptimizeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitOptimizeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) OptimizeClause() (localctx IOptimizeClauseContext) {
	localctx = NewOptimizeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, DorisSQLParserRULE_optimizeClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2944)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 223, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2943)
			p.PartitionNames()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2947)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserAGGREGATE || _la == DorisSQLParserDUPLICATE || _la == DorisSQLParserPRIMARY || _la == DorisSQLParserUNIQUE {
		{
			p.SetState(2946)
			p.KeyDesc()
		}

	}
	p.SetState(2950)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPARTITION {
		{
			p.SetState(2949)
			p.PartitionDesc()
		}

	}
	p.SetState(2953)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserORDER {
		{
			p.SetState(2952)
			p.OrderByDesc()
		}

	}
	p.SetState(2956)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserDISTRIBUTED {
		{
			p.SetState(2955)
			p.DistributionDesc()
		}

	}
	p.SetState(2959)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserBETWEEN {
		{
			p.SetState(2958)
			p.OptimizeRange()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddColumnClauseContext is an interface to support dynamic dispatch.
type IAddColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// Getter signatures
	ADD() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	ColumnDesc() IColumnDescContext
	FIRST() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	Properties() IPropertiesContext
	TO() antlr.TerminalNode
	IN() antlr.TerminalNode

	// IsAddColumnClauseContext differentiates from other interfaces.
	IsAddColumnClauseContext()
}

type AddColumnClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
}

func NewEmptyAddColumnClauseContext() *AddColumnClauseContext {
	var p = new(AddColumnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_addColumnClause
	return p
}

func InitEmptyAddColumnClauseContext(p *AddColumnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_addColumnClause
}

func (*AddColumnClauseContext) IsAddColumnClauseContext() {}

func NewAddColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddColumnClauseContext {
	var p = new(AddColumnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_addColumnClause

	return p
}

func (s *AddColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddColumnClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *AddColumnClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *AddColumnClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADD, 0)
}

func (s *AddColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLUMN, 0)
}

func (s *AddColumnClauseContext) ColumnDesc() IColumnDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDescContext)
}

func (s *AddColumnClauseContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFIRST, 0)
}

func (s *AddColumnClauseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAFTER, 0)
}

func (s *AddColumnClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AddColumnClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddColumnClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AddColumnClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTO, 0)
}

func (s *AddColumnClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *AddColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAddColumnClause(s)
	}
}

func (s *AddColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAddColumnClause(s)
	}
}

func (s *AddColumnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAddColumnClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AddColumnClause() (localctx IAddColumnClauseContext) {
	localctx = NewAddColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, DorisSQLParserRULE_addColumnClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2961)
		p.Match(DorisSQLParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2962)
		p.Match(DorisSQLParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2963)
		p.ColumnDesc()
	}
	p.SetState(2967)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserFIRST:
		{
			p.SetState(2964)
			p.Match(DorisSQLParserFIRST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserAFTER:
		{
			p.SetState(2965)
			p.Match(DorisSQLParserAFTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2966)
			p.Identifier()
		}

	case DorisSQLParserEOF, DorisSQLParserT__2, DorisSQLParserIN, DorisSQLParserPROPERTIES, DorisSQLParserTO, DorisSQLParserSEMICOLON:

	default:
	}
	p.SetState(2971)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIN || _la == DorisSQLParserTO {
		{
			p.SetState(2969)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserIN || _la == DorisSQLParserTO) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2970)

			var _x = p.Identifier()

			localctx.(*AddColumnClauseContext).rollupName = _x
		}

	}
	p.SetState(2974)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(2973)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddColumnsClauseContext is an interface to support dynamic dispatch.
type IAddColumnsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// Getter signatures
	ADD() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	AllColumnDesc() []IColumnDescContext
	ColumnDesc(i int) IColumnDescContext
	Properties() IPropertiesContext
	TO() antlr.TerminalNode
	IN() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsAddColumnsClauseContext differentiates from other interfaces.
	IsAddColumnsClauseContext()
}

type AddColumnsClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
}

func NewEmptyAddColumnsClauseContext() *AddColumnsClauseContext {
	var p = new(AddColumnsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_addColumnsClause
	return p
}

func InitEmptyAddColumnsClauseContext(p *AddColumnsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_addColumnsClause
}

func (*AddColumnsClauseContext) IsAddColumnsClauseContext() {}

func NewAddColumnsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddColumnsClauseContext {
	var p = new(AddColumnsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_addColumnsClause

	return p
}

func (s *AddColumnsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddColumnsClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *AddColumnsClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *AddColumnsClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADD, 0)
}

func (s *AddColumnsClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLUMN, 0)
}

func (s *AddColumnsClauseContext) AllColumnDesc() []IColumnDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnDescContext); ok {
			len++
		}
	}

	tst := make([]IColumnDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnDescContext); ok {
			tst[i] = t.(IColumnDescContext)
			i++
		}
	}

	return tst
}

func (s *AddColumnsClauseContext) ColumnDesc(i int) IColumnDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDescContext)
}

func (s *AddColumnsClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AddColumnsClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTO, 0)
}

func (s *AddColumnsClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *AddColumnsClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddColumnsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddColumnsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddColumnsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAddColumnsClause(s)
	}
}

func (s *AddColumnsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAddColumnsClause(s)
	}
}

func (s *AddColumnsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAddColumnsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AddColumnsClause() (localctx IAddColumnsClauseContext) {
	localctx = NewAddColumnsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, DorisSQLParserRULE_addColumnsClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2976)
		p.Match(DorisSQLParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2977)
		p.Match(DorisSQLParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2978)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2979)
		p.ColumnDesc()
	}
	p.SetState(2984)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(2980)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2981)
			p.ColumnDesc()
		}

		p.SetState(2986)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2987)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2990)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIN || _la == DorisSQLParserTO {
		{
			p.SetState(2988)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserIN || _la == DorisSQLParserTO) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2989)

			var _x = p.Identifier()

			localctx.(*AddColumnsClauseContext).rollupName = _x
		}

	}
	p.SetState(2993)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(2992)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropColumnClauseContext is an interface to support dynamic dispatch.
type IDropColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	FROM() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsDropColumnClauseContext differentiates from other interfaces.
	IsDropColumnClauseContext()
}

type DropColumnClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
}

func NewEmptyDropColumnClauseContext() *DropColumnClauseContext {
	var p = new(DropColumnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropColumnClause
	return p
}

func InitEmptyDropColumnClauseContext(p *DropColumnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropColumnClause
}

func (*DropColumnClauseContext) IsDropColumnClauseContext() {}

func NewDropColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropColumnClauseContext {
	var p = new(DropColumnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropColumnClause

	return p
}

func (s *DropColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropColumnClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *DropColumnClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *DropColumnClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLUMN, 0)
}

func (s *DropColumnClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DropColumnClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropColumnClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *DropColumnClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *DropColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropColumnClause(s)
	}
}

func (s *DropColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropColumnClause(s)
	}
}

func (s *DropColumnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropColumnClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropColumnClause() (localctx IDropColumnClauseContext) {
	localctx = NewDropColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, DorisSQLParserRULE_dropColumnClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2995)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2996)
		p.Match(DorisSQLParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2997)
		p.Identifier()
	}
	p.SetState(3000)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM {
		{
			p.SetState(2998)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2999)

			var _x = p.Identifier()

			localctx.(*DropColumnClauseContext).rollupName = _x
		}

	}
	p.SetState(3003)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(3002)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyColumnClauseContext is an interface to support dynamic dispatch.
type IModifyColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// Getter signatures
	MODIFY() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	ColumnDesc() IColumnDescContext
	FIRST() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	FROM() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsModifyColumnClauseContext differentiates from other interfaces.
	IsModifyColumnClauseContext()
}

type ModifyColumnClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
}

func NewEmptyModifyColumnClauseContext() *ModifyColumnClauseContext {
	var p = new(ModifyColumnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_modifyColumnClause
	return p
}

func InitEmptyModifyColumnClauseContext(p *ModifyColumnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_modifyColumnClause
}

func (*ModifyColumnClauseContext) IsModifyColumnClauseContext() {}

func NewModifyColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyColumnClauseContext {
	var p = new(ModifyColumnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_modifyColumnClause

	return p
}

func (s *ModifyColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyColumnClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *ModifyColumnClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *ModifyColumnClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMODIFY, 0)
}

func (s *ModifyColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLUMN, 0)
}

func (s *ModifyColumnClauseContext) ColumnDesc() IColumnDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDescContext)
}

func (s *ModifyColumnClauseContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFIRST, 0)
}

func (s *ModifyColumnClauseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAFTER, 0)
}

func (s *ModifyColumnClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ModifyColumnClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifyColumnClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ModifyColumnClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *ModifyColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterModifyColumnClause(s)
	}
}

func (s *ModifyColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitModifyColumnClause(s)
	}
}

func (s *ModifyColumnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitModifyColumnClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ModifyColumnClause() (localctx IModifyColumnClauseContext) {
	localctx = NewModifyColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, DorisSQLParserRULE_modifyColumnClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3005)
		p.Match(DorisSQLParserMODIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3006)
		p.Match(DorisSQLParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3007)
		p.ColumnDesc()
	}
	p.SetState(3011)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserFIRST:
		{
			p.SetState(3008)
			p.Match(DorisSQLParserFIRST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserAFTER:
		{
			p.SetState(3009)
			p.Match(DorisSQLParserAFTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3010)
			p.Identifier()
		}

	case DorisSQLParserEOF, DorisSQLParserT__2, DorisSQLParserFROM, DorisSQLParserPROPERTIES, DorisSQLParserSEMICOLON:

	default:
	}
	p.SetState(3015)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM {
		{
			p.SetState(3013)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3014)

			var _x = p.Identifier()

			localctx.(*ModifyColumnClauseContext).rollupName = _x
		}

	}
	p.SetState(3018)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(3017)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyColumnCommentClauseContext is an interface to support dynamic dispatch.
type IModifyColumnCommentClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODIFY() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	Identifier() IIdentifierContext
	Comment() ICommentContext

	// IsModifyColumnCommentClauseContext differentiates from other interfaces.
	IsModifyColumnCommentClauseContext()
}

type ModifyColumnCommentClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyColumnCommentClauseContext() *ModifyColumnCommentClauseContext {
	var p = new(ModifyColumnCommentClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_modifyColumnCommentClause
	return p
}

func InitEmptyModifyColumnCommentClauseContext(p *ModifyColumnCommentClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_modifyColumnCommentClause
}

func (*ModifyColumnCommentClauseContext) IsModifyColumnCommentClauseContext() {}

func NewModifyColumnCommentClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyColumnCommentClauseContext {
	var p = new(ModifyColumnCommentClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_modifyColumnCommentClause

	return p
}

func (s *ModifyColumnCommentClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyColumnCommentClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMODIFY, 0)
}

func (s *ModifyColumnCommentClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLUMN, 0)
}

func (s *ModifyColumnCommentClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifyColumnCommentClauseContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *ModifyColumnCommentClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyColumnCommentClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyColumnCommentClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterModifyColumnCommentClause(s)
	}
}

func (s *ModifyColumnCommentClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitModifyColumnCommentClause(s)
	}
}

func (s *ModifyColumnCommentClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitModifyColumnCommentClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ModifyColumnCommentClause() (localctx IModifyColumnCommentClauseContext) {
	localctx = NewModifyColumnCommentClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, DorisSQLParserRULE_modifyColumnCommentClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3020)
		p.Match(DorisSQLParserMODIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3021)
		p.Match(DorisSQLParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3022)
		p.Identifier()
	}
	{
		p.SetState(3023)
		p.Comment()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnRenameClauseContext is an interface to support dynamic dispatch.
type IColumnRenameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOldColumn returns the oldColumn rule contexts.
	GetOldColumn() IIdentifierContext

	// GetNewColumn returns the newColumn rule contexts.
	GetNewColumn() IIdentifierContext

	// SetOldColumn sets the oldColumn rule contexts.
	SetOldColumn(IIdentifierContext)

	// SetNewColumn sets the newColumn rule contexts.
	SetNewColumn(IIdentifierContext)

	// Getter signatures
	RENAME() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	TO() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsColumnRenameClauseContext differentiates from other interfaces.
	IsColumnRenameClauseContext()
}

type ColumnRenameClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	oldColumn IIdentifierContext
	newColumn IIdentifierContext
}

func NewEmptyColumnRenameClauseContext() *ColumnRenameClauseContext {
	var p = new(ColumnRenameClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_columnRenameClause
	return p
}

func InitEmptyColumnRenameClauseContext(p *ColumnRenameClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_columnRenameClause
}

func (*ColumnRenameClauseContext) IsColumnRenameClauseContext() {}

func NewColumnRenameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnRenameClauseContext {
	var p = new(ColumnRenameClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_columnRenameClause

	return p
}

func (s *ColumnRenameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnRenameClauseContext) GetOldColumn() IIdentifierContext { return s.oldColumn }

func (s *ColumnRenameClauseContext) GetNewColumn() IIdentifierContext { return s.newColumn }

func (s *ColumnRenameClauseContext) SetOldColumn(v IIdentifierContext) { s.oldColumn = v }

func (s *ColumnRenameClauseContext) SetNewColumn(v IIdentifierContext) { s.newColumn = v }

func (s *ColumnRenameClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRENAME, 0)
}

func (s *ColumnRenameClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLUMN, 0)
}

func (s *ColumnRenameClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTO, 0)
}

func (s *ColumnRenameClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnRenameClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnRenameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnRenameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnRenameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterColumnRenameClause(s)
	}
}

func (s *ColumnRenameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitColumnRenameClause(s)
	}
}

func (s *ColumnRenameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitColumnRenameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ColumnRenameClause() (localctx IColumnRenameClauseContext) {
	localctx = NewColumnRenameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, DorisSQLParserRULE_columnRenameClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3025)
		p.Match(DorisSQLParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3026)
		p.Match(DorisSQLParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3027)

		var _x = p.Identifier()

		localctx.(*ColumnRenameClauseContext).oldColumn = _x
	}
	{
		p.SetState(3028)
		p.Match(DorisSQLParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3029)

		var _x = p.Identifier()

		localctx.(*ColumnRenameClauseContext).newColumn = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReorderColumnsClauseContext is an interface to support dynamic dispatch.
type IReorderColumnsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	FROM() antlr.TerminalNode
	Properties() IPropertiesContext
	Identifier() IIdentifierContext

	// IsReorderColumnsClauseContext differentiates from other interfaces.
	IsReorderColumnsClauseContext()
}

type ReorderColumnsClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
}

func NewEmptyReorderColumnsClauseContext() *ReorderColumnsClauseContext {
	var p = new(ReorderColumnsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_reorderColumnsClause
	return p
}

func InitEmptyReorderColumnsClauseContext(p *ReorderColumnsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_reorderColumnsClause
}

func (*ReorderColumnsClauseContext) IsReorderColumnsClauseContext() {}

func NewReorderColumnsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReorderColumnsClauseContext {
	var p = new(ReorderColumnsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_reorderColumnsClause

	return p
}

func (s *ReorderColumnsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReorderColumnsClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *ReorderColumnsClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *ReorderColumnsClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserORDER, 0)
}

func (s *ReorderColumnsClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *ReorderColumnsClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ReorderColumnsClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ReorderColumnsClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *ReorderColumnsClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReorderColumnsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReorderColumnsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReorderColumnsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterReorderColumnsClause(s)
	}
}

func (s *ReorderColumnsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitReorderColumnsClause(s)
	}
}

func (s *ReorderColumnsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitReorderColumnsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ReorderColumnsClause() (localctx IReorderColumnsClauseContext) {
	localctx = NewReorderColumnsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, DorisSQLParserRULE_reorderColumnsClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3031)
		p.Match(DorisSQLParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3032)
		p.Match(DorisSQLParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3033)
		p.IdentifierList()
	}
	p.SetState(3036)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM {
		{
			p.SetState(3034)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3035)

			var _x = p.Identifier()

			localctx.(*ReorderColumnsClauseContext).rollupName = _x
		}

	}
	p.SetState(3039)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(3038)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollupRenameClauseContext is an interface to support dynamic dispatch.
type IRollupRenameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// GetNewRollupName returns the newRollupName rule contexts.
	GetNewRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// SetNewRollupName sets the newRollupName rule contexts.
	SetNewRollupName(IIdentifierContext)

	// Getter signatures
	RENAME() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsRollupRenameClauseContext differentiates from other interfaces.
	IsRollupRenameClauseContext()
}

type RollupRenameClauseContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	rollupName    IIdentifierContext
	newRollupName IIdentifierContext
}

func NewEmptyRollupRenameClauseContext() *RollupRenameClauseContext {
	var p = new(RollupRenameClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_rollupRenameClause
	return p
}

func InitEmptyRollupRenameClauseContext(p *RollupRenameClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_rollupRenameClause
}

func (*RollupRenameClauseContext) IsRollupRenameClauseContext() {}

func NewRollupRenameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollupRenameClauseContext {
	var p = new(RollupRenameClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_rollupRenameClause

	return p
}

func (s *RollupRenameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RollupRenameClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *RollupRenameClauseContext) GetNewRollupName() IIdentifierContext { return s.newRollupName }

func (s *RollupRenameClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *RollupRenameClauseContext) SetNewRollupName(v IIdentifierContext) { s.newRollupName = v }

func (s *RollupRenameClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRENAME, 0)
}

func (s *RollupRenameClauseContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROLLUP, 0)
}

func (s *RollupRenameClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RollupRenameClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RollupRenameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupRenameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollupRenameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRollupRenameClause(s)
	}
}

func (s *RollupRenameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRollupRenameClause(s)
	}
}

func (s *RollupRenameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRollupRenameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) RollupRenameClause() (localctx IRollupRenameClauseContext) {
	localctx = NewRollupRenameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, DorisSQLParserRULE_rollupRenameClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3041)
		p.Match(DorisSQLParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3042)
		p.Match(DorisSQLParserROLLUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3043)

		var _x = p.Identifier()

		localctx.(*RollupRenameClauseContext).rollupName = _x
	}
	{
		p.SetState(3044)

		var _x = p.Identifier()

		localctx.(*RollupRenameClauseContext).newRollupName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompactionClauseContext is an interface to support dynamic dispatch.
type ICompactionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMPACT() antlr.TerminalNode
	Identifier() IIdentifierContext
	IdentifierList() IIdentifierListContext
	BASE() antlr.TerminalNode
	CUMULATIVE() antlr.TerminalNode

	// IsCompactionClauseContext differentiates from other interfaces.
	IsCompactionClauseContext()
}

type CompactionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompactionClauseContext() *CompactionClauseContext {
	var p = new(CompactionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_compactionClause
	return p
}

func InitEmptyCompactionClauseContext(p *CompactionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_compactionClause
}

func (*CompactionClauseContext) IsCompactionClauseContext() {}

func NewCompactionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompactionClauseContext {
	var p = new(CompactionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_compactionClause

	return p
}

func (s *CompactionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CompactionClauseContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOMPACT, 0)
}

func (s *CompactionClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CompactionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CompactionClauseContext) BASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBASE, 0)
}

func (s *CompactionClauseContext) CUMULATIVE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCUMULATIVE, 0)
}

func (s *CompactionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompactionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompactionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCompactionClause(s)
	}
}

func (s *CompactionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCompactionClause(s)
	}
}

func (s *CompactionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCompactionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CompactionClause() (localctx ICompactionClauseContext) {
	localctx = NewCompactionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, DorisSQLParserRULE_compactionClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3047)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserBASE || _la == DorisSQLParserCUMULATIVE {
		{
			p.SetState(3046)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserBASE || _la == DorisSQLParserCUMULATIVE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3049)
		p.Match(DorisSQLParserCOMPACT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3052)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserACCESS, DorisSQLParserACTIVE, DorisSQLParserADMIN, DorisSQLParserADVISOR, DorisSQLParserAFTER, DorisSQLParserAGGREGATE, DorisSQLParserANTI, DorisSQLParserAPPLY, DorisSQLParserARRAY_AGG, DorisSQLParserARRAY_AGG_DISTINCT, DorisSQLParserASYNC, DorisSQLParserAUTHORS, DorisSQLParserAUTHENTICATION, DorisSQLParserAUTOMATED, DorisSQLParserAUTO_INCREMENT, DorisSQLParserAVG, DorisSQLParserBACKEND, DorisSQLParserBACKENDS, DorisSQLParserBACKUP, DorisSQLParserBASE, DorisSQLParserBASELINE, DorisSQLParserBEGIN, DorisSQLParserBINARY, DorisSQLParserBITMAP_UNION, DorisSQLParserBLACKHOLE, DorisSQLParserBLACKLIST, DorisSQLParserBODY, DorisSQLParserBOOLEAN, DorisSQLParserBRANCH, DorisSQLParserBROKER, DorisSQLParserBUCKETS, DorisSQLParserBUILTIN, DorisSQLParserCACHE, DorisSQLParserCANCEL, DorisSQLParserCAST, DorisSQLParserCATALOG, DorisSQLParserCATALOGS, DorisSQLParserCEIL, DorisSQLParserCHAIN, DorisSQLParserCHARSET, DorisSQLParserCLEAN, DorisSQLParserCLEAR, DorisSQLParserCLUSTER, DorisSQLParserCLUSTERS, DorisSQLParserCNGROUP, DorisSQLParserCNGROUPS, DorisSQLParserCOLLATION, DorisSQLParserCOLUMNS, DorisSQLParserCOMMENT, DorisSQLParserCOMMIT, DorisSQLParserCOMMITTED, DorisSQLParserCOMPACT, DorisSQLParserCOMPUTE, DorisSQLParserCONFIG, DorisSQLParserCONNECTION, DorisSQLParserCONSISTENT, DorisSQLParserCOSTS, DorisSQLParserCOUNT, DorisSQLParserCUME_DIST, DorisSQLParserCUMULATIVE, DorisSQLParserCURRENT, DorisSQLParserDATA, DorisSQLParserDATACACHE, DorisSQLParserDATE, DorisSQLParserDATETIME, DorisSQLParserDAY, DorisSQLParserDAYS, DorisSQLParserDEALLOCATE, DorisSQLParserDECOMMISSION, DorisSQLParserDIALECT, DorisSQLParserDICTIONARY, DorisSQLParserDICTIONARY_GET, DorisSQLParserDISABLE, DorisSQLParserDISTRIBUTED, DorisSQLParserDISTRIBUTION, DorisSQLParserDUPLICATE, DorisSQLParserDYNAMIC, DorisSQLParserENABLE, DorisSQLParserENCLOSE, DorisSQLParserEND, DorisSQLParserENGINE, DorisSQLParserENGINES, DorisSQLParserERRORS, DorisSQLParserESCAPE, DorisSQLParserEVENTS, DorisSQLParserEXCEPT, DorisSQLParserEXCLUDE, DorisSQLParserEXECUTE, DorisSQLParserEXPORT, DorisSQLParserEXTERNAL, DorisSQLParserEXTRACT, DorisSQLParserEVERY, DorisSQLParserFAILPOINT, DorisSQLParserFAILPOINTS, DorisSQLParserFIELDS, DorisSQLParserFILE, DorisSQLParserFILTER, DorisSQLParserFIRST, DorisSQLParserFLOOR, DorisSQLParserFN, DorisSQLParserFOLLOWING, DorisSQLParserFOLLOWER, DorisSQLParserFORMAT, DorisSQLParserFREE, DorisSQLParserFRONTEND, DorisSQLParserFRONTENDS, DorisSQLParserFUNCTIONS, DorisSQLParserGLOBAL, DorisSQLParserGRANTS, DorisSQLParserGROUP_CONCAT, DorisSQLParserHASH, DorisSQLParserHELP, DorisSQLParserHISTOGRAM, DorisSQLParserHLL_UNION, DorisSQLParserHOST, DorisSQLParserHOUR, DorisSQLParserHOURS, DorisSQLParserHUB, DorisSQLParserIDENTIFIED, DorisSQLParserIMPERSONATE, DorisSQLParserIMAGE, DorisSQLParserINACTIVE, DorisSQLParserINCREMENTAL, DorisSQLParserINDEXES, DorisSQLParserINSTALL, DorisSQLParserINTEGRATION, DorisSQLParserINTEGRATIONS, DorisSQLParserINTERMEDIATE, DorisSQLParserINTERVAL, DorisSQLParserOVERWRITE, DorisSQLParserISOLATION, DorisSQLParserJOB, DorisSQLParserLABEL, DorisSQLParserLAST, DorisSQLParserLESS, DorisSQLParserLEVEL, DorisSQLParserLIST, DorisSQLParserLOCAL, DorisSQLParserLOCATION, DorisSQLParserLOCATIONS, DorisSQLParserLOGS, DorisSQLParserLOGICAL, DorisSQLParserMANUAL, DorisSQLParserMAP, DorisSQLParserMAPPING, DorisSQLParserMAPPINGS, DorisSQLParserMASKING, DorisSQLParserMATCH, DorisSQLParserMATERIALIZED, DorisSQLParserMAX, DorisSQLParserMERGE, DorisSQLParserMIN, DorisSQLParserMINUTE, DorisSQLParserMINUTES, DorisSQLParserMINUS, DorisSQLParserMETA, DorisSQLParserMODE, DorisSQLParserMODIFY, DorisSQLParserMONTH, DorisSQLParserMULTIPLE, DorisSQLParserNAME, DorisSQLParserNAMES, DorisSQLParserNEGATIVE, DorisSQLParserNGRAMBF, DorisSQLParserNO, DorisSQLParserNODE, DorisSQLParserNODES, DorisSQLParserNONE, DorisSQLParserNULLS, DorisSQLParserNUMBER, DorisSQLParserNUMERIC, DorisSQLParserOBSERVER, DorisSQLParserOF, DorisSQLParserOFF, DorisSQLParserOFFSET, DorisSQLParserONLY, DorisSQLParserOPEN, DorisSQLParserOPERATE, DorisSQLParserOPTIMIZER, DorisSQLParserOPTION, DorisSQLParserPARTITIONS, DorisSQLParserPASSWORD, DorisSQLParserPATH, DorisSQLParserPAUSE, DorisSQLParserPENDING, DorisSQLParserPERCENT_RANK, DorisSQLParserPERCENTILE_UNION, DorisSQLParserPLAN, DorisSQLParserPLUGIN, DorisSQLParserPLUGINS, DorisSQLParserPIPE, DorisSQLParserPIPES, DorisSQLParserPIVOT, DorisSQLParserPOLICY, DorisSQLParserPOLICIES, DorisSQLParserPRECEDING, DorisSQLParserPREDICATE, DorisSQLParserPRIORITY, DorisSQLParserPRIVILEGES, DorisSQLParserPROBABILITY, DorisSQLParserPROC, DorisSQLParserPROCESSLIST, DorisSQLParserPROFILE, DorisSQLParserPROFILELIST, DorisSQLParserPROPERTIES, DorisSQLParserPROPERTY, DorisSQLParserPROVIDER, DorisSQLParserPROVIDERS, DorisSQLParserQUALIFY, DorisSQLParserQUARTER, DorisSQLParserQUERY, DorisSQLParserQUERIES, DorisSQLParserQUEUE, DorisSQLParserQUOTA, DorisSQLParserRANDOM, DorisSQLParserRANK, DorisSQLParserREASON, DorisSQLParserRECOVER, DorisSQLParserREFRESH, DorisSQLParserREWRITE, DorisSQLParserREMOVE, DorisSQLParserREPAIR, DorisSQLParserREPEATABLE, DorisSQLParserREPLACE_IF_NOT_NULL, DorisSQLParserREPLICA, DorisSQLParserREPOSITORY, DorisSQLParserREPOSITORIES, DorisSQLParserRESOURCE, DorisSQLParserRESOURCES, DorisSQLParserRESTORE, DorisSQLParserRESUME, DorisSQLParserRETAIN, DorisSQLParserRETENTION, DorisSQLParserRETURNS, DorisSQLParserRETRY, DorisSQLParserREVERT, DorisSQLParserROLE, DorisSQLParserROLES, DorisSQLParserROLLBACK, DorisSQLParserROLLUP, DorisSQLParserROUTINE, DorisSQLParserROW, DorisSQLParserRULE, DorisSQLParserRULES, DorisSQLParserRUNNING, DorisSQLParserSAMPLE, DorisSQLParserSCHEDULE, DorisSQLParserSCHEDULER, DorisSQLParserSECOND, DorisSQLParserSECURITY, DorisSQLParserSEMI, DorisSQLParserSEPARATOR, DorisSQLParserSERIALIZABLE, DorisSQLParserSESSION, DorisSQLParserSETS, DorisSQLParserSIGNED, DorisSQLParserSKIP_HEADER, DorisSQLParserSNAPSHOT, DorisSQLParserSNAPSHOTS, DorisSQLParserSQLBLACKLIST, DorisSQLParserSTART, DorisSQLParserSTATS, DorisSQLParserSTATUS, DorisSQLParserSTOP, DorisSQLParserSTORAGE, DorisSQLParserSTREAM, DorisSQLParserSTRING, DorisSQLParserSUBMIT, DorisSQLParserSUM, DorisSQLParserSUSPEND, DorisSQLParserSYNC, DorisSQLParserSYSTEM_TIME, DorisSQLParserSWAP, DorisSQLParserSTRUCT, DorisSQLParserTABLES, DorisSQLParserTABLET, DorisSQLParserTABLETS, DorisSQLParserTAG, DorisSQLParserTASK, DorisSQLParserTEMPORARY, DorisSQLParserTHAN, DorisSQLParserTIME, DorisSQLParserTIMES, DorisSQLParserTIMESTAMP, DorisSQLParserTIMESTAMPADD, DorisSQLParserTIMESTAMPDIFF, DorisSQLParserTRANSACTION, DorisSQLParserTRANSLATE, DorisSQLParserTRACE, DorisSQLParserTRIGGERS, DorisSQLParserTRIM_SPACE, DorisSQLParserTRUNCATE, DorisSQLParserTYPE, DorisSQLParserTYPES, DorisSQLParserUNBOUNDED, DorisSQLParserUNCOMMITTED, DorisSQLParserUNINSTALL, DorisSQLParserUNSET, DorisSQLParserUSAGE, DorisSQLParserUSER, DorisSQLParserUSERS, DorisSQLParserVALUE, DorisSQLParserVARBINARY, DorisSQLParserVARIABLES, DorisSQLParserVECTOR, DorisSQLParserVERBOSE, DorisSQLParserVERSION, DorisSQLParserVIEW, DorisSQLParserVIEWS, DorisSQLParserVOLUME, DorisSQLParserVOLUMES, DorisSQLParserWAREHOUSE, DorisSQLParserWAREHOUSES, DorisSQLParserWARNINGS, DorisSQLParserWEEK, DorisSQLParserWHITELIST, DorisSQLParserWORK, DorisSQLParserWRITE, DorisSQLParserYEAR, DorisSQLParserLOCK, DorisSQLParserUNLOCK, DorisSQLParserLOW_PRIORITY, DorisSQLParserDISK, DorisSQLParserBEFORE, DorisSQLParserFIELD, DorisSQLParserPERSISTENT, DorisSQLParserARRAY_ELEMENT, DorisSQLParserLETTER_IDENTIFIER, DorisSQLParserDIGIT_IDENTIFIER, DorisSQLParserBACKQUOTED_IDENTIFIER, DorisSQLParserDOTDOTDOT:
		{
			p.SetState(3050)
			p.Identifier()
		}

	case DorisSQLParserT__1:
		{
			p.SetState(3051)
			p.IdentifierList()
		}

	case DorisSQLParserEOF, DorisSQLParserT__2, DorisSQLParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubfieldNameContext is an interface to support dynamic dispatch.
type ISubfieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ARRAY_ELEMENT() antlr.TerminalNode

	// IsSubfieldNameContext differentiates from other interfaces.
	IsSubfieldNameContext()
}

type SubfieldNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubfieldNameContext() *SubfieldNameContext {
	var p = new(SubfieldNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_subfieldName
	return p
}

func InitEmptySubfieldNameContext(p *SubfieldNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_subfieldName
}

func (*SubfieldNameContext) IsSubfieldNameContext() {}

func NewSubfieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubfieldNameContext {
	var p = new(SubfieldNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_subfieldName

	return p
}

func (s *SubfieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SubfieldNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubfieldNameContext) ARRAY_ELEMENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserARRAY_ELEMENT, 0)
}

func (s *SubfieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubfieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubfieldNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSubfieldName(s)
	}
}

func (s *SubfieldNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSubfieldName(s)
	}
}

func (s *SubfieldNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSubfieldName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SubfieldName() (localctx ISubfieldNameContext) {
	localctx = NewSubfieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, DorisSQLParserRULE_subfieldName)
	p.SetState(3056)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 244, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3054)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3055)
			p.Match(DorisSQLParserARRAY_ELEMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INestedFieldNameContext is an interface to support dynamic dispatch.
type INestedFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSubfieldName() []ISubfieldNameContext
	SubfieldName(i int) ISubfieldNameContext
	AllDOT_IDENTIFIER() []antlr.TerminalNode
	DOT_IDENTIFIER(i int) antlr.TerminalNode

	// IsNestedFieldNameContext differentiates from other interfaces.
	IsNestedFieldNameContext()
}

type NestedFieldNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNestedFieldNameContext() *NestedFieldNameContext {
	var p = new(NestedFieldNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_nestedFieldName
	return p
}

func InitEmptyNestedFieldNameContext(p *NestedFieldNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_nestedFieldName
}

func (*NestedFieldNameContext) IsNestedFieldNameContext() {}

func NewNestedFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NestedFieldNameContext {
	var p = new(NestedFieldNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_nestedFieldName

	return p
}

func (s *NestedFieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *NestedFieldNameContext) AllSubfieldName() []ISubfieldNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubfieldNameContext); ok {
			len++
		}
	}

	tst := make([]ISubfieldNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubfieldNameContext); ok {
			tst[i] = t.(ISubfieldNameContext)
			i++
		}
	}

	return tst
}

func (s *NestedFieldNameContext) SubfieldName(i int) ISubfieldNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubfieldNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubfieldNameContext)
}

func (s *NestedFieldNameContext) AllDOT_IDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserDOT_IDENTIFIER)
}

func (s *NestedFieldNameContext) DOT_IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDOT_IDENTIFIER, i)
}

func (s *NestedFieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedFieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NestedFieldNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterNestedFieldName(s)
	}
}

func (s *NestedFieldNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitNestedFieldName(s)
	}
}

func (s *NestedFieldNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitNestedFieldName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) NestedFieldName() (localctx INestedFieldNameContext) {
	localctx = NewNestedFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, DorisSQLParserRULE_nestedFieldName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3058)
		p.SubfieldName()
	}
	p.SetState(3064)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__0 || _la == DorisSQLParserDOT_IDENTIFIER {
		p.SetState(3062)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserDOT_IDENTIFIER:
			{
				p.SetState(3059)
				p.Match(DorisSQLParserDOT_IDENTIFIER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisSQLParserT__0:
			{
				p.SetState(3060)
				p.Match(DorisSQLParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3061)
				p.SubfieldName()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(3066)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddFieldClauseContext is an interface to support dynamic dispatch.
type IAddFieldClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODIFY() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	ADD() antlr.TerminalNode
	FIELD() antlr.TerminalNode
	SubfieldDesc() ISubfieldDescContext
	FIRST() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsAddFieldClauseContext differentiates from other interfaces.
	IsAddFieldClauseContext()
}

type AddFieldClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddFieldClauseContext() *AddFieldClauseContext {
	var p = new(AddFieldClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_addFieldClause
	return p
}

func InitEmptyAddFieldClauseContext(p *AddFieldClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_addFieldClause
}

func (*AddFieldClauseContext) IsAddFieldClauseContext() {}

func NewAddFieldClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddFieldClauseContext {
	var p = new(AddFieldClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_addFieldClause

	return p
}

func (s *AddFieldClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddFieldClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMODIFY, 0)
}

func (s *AddFieldClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLUMN, 0)
}

func (s *AddFieldClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AddFieldClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddFieldClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADD, 0)
}

func (s *AddFieldClauseContext) FIELD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFIELD, 0)
}

func (s *AddFieldClauseContext) SubfieldDesc() ISubfieldDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubfieldDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubfieldDescContext)
}

func (s *AddFieldClauseContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFIRST, 0)
}

func (s *AddFieldClauseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAFTER, 0)
}

func (s *AddFieldClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AddFieldClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddFieldClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddFieldClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAddFieldClause(s)
	}
}

func (s *AddFieldClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAddFieldClause(s)
	}
}

func (s *AddFieldClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAddFieldClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AddFieldClause() (localctx IAddFieldClauseContext) {
	localctx = NewAddFieldClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, DorisSQLParserRULE_addFieldClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3067)
		p.Match(DorisSQLParserMODIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3068)
		p.Match(DorisSQLParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3069)
		p.Identifier()
	}
	{
		p.SetState(3070)
		p.Match(DorisSQLParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3071)
		p.Match(DorisSQLParserFIELD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3072)
		p.SubfieldDesc()
	}
	p.SetState(3076)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserFIRST:
		{
			p.SetState(3073)
			p.Match(DorisSQLParserFIRST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserAFTER:
		{
			p.SetState(3074)
			p.Match(DorisSQLParserAFTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3075)
			p.Identifier()
		}

	case DorisSQLParserEOF, DorisSQLParserT__2, DorisSQLParserPROPERTIES, DorisSQLParserSEMICOLON:

	default:
	}
	p.SetState(3079)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(3078)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropFieldClauseContext is an interface to support dynamic dispatch.
type IDropFieldClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODIFY() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	Identifier() IIdentifierContext
	DROP() antlr.TerminalNode
	FIELD() antlr.TerminalNode
	NestedFieldName() INestedFieldNameContext
	Properties() IPropertiesContext

	// IsDropFieldClauseContext differentiates from other interfaces.
	IsDropFieldClauseContext()
}

type DropFieldClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropFieldClauseContext() *DropFieldClauseContext {
	var p = new(DropFieldClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropFieldClause
	return p
}

func InitEmptyDropFieldClauseContext(p *DropFieldClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropFieldClause
}

func (*DropFieldClauseContext) IsDropFieldClauseContext() {}

func NewDropFieldClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFieldClauseContext {
	var p = new(DropFieldClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropFieldClause

	return p
}

func (s *DropFieldClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFieldClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMODIFY, 0)
}

func (s *DropFieldClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLUMN, 0)
}

func (s *DropFieldClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropFieldClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropFieldClauseContext) FIELD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFIELD, 0)
}

func (s *DropFieldClauseContext) NestedFieldName() INestedFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedFieldNameContext)
}

func (s *DropFieldClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *DropFieldClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFieldClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropFieldClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropFieldClause(s)
	}
}

func (s *DropFieldClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropFieldClause(s)
	}
}

func (s *DropFieldClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropFieldClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropFieldClause() (localctx IDropFieldClauseContext) {
	localctx = NewDropFieldClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, DorisSQLParserRULE_dropFieldClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3081)
		p.Match(DorisSQLParserMODIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3082)
		p.Match(DorisSQLParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3083)
		p.Identifier()
	}
	{
		p.SetState(3084)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3085)
		p.Match(DorisSQLParserFIELD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3086)
		p.NestedFieldName()
	}
	p.SetState(3088)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(3087)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateOrReplaceTagClauseContext is an interface to support dynamic dispatch.
type ICreateOrReplaceTagClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLACE() antlr.TerminalNode
	TAG() antlr.TerminalNode
	Identifier() IIdentifierContext
	TagOptions() ITagOptionsContext
	CREATE() antlr.TerminalNode
	OR() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsCreateOrReplaceTagClauseContext differentiates from other interfaces.
	IsCreateOrReplaceTagClauseContext()
}

type CreateOrReplaceTagClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateOrReplaceTagClauseContext() *CreateOrReplaceTagClauseContext {
	var p = new(CreateOrReplaceTagClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createOrReplaceTagClause
	return p
}

func InitEmptyCreateOrReplaceTagClauseContext(p *CreateOrReplaceTagClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createOrReplaceTagClause
}

func (*CreateOrReplaceTagClauseContext) IsCreateOrReplaceTagClauseContext() {}

func NewCreateOrReplaceTagClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateOrReplaceTagClauseContext {
	var p = new(CreateOrReplaceTagClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createOrReplaceTagClause

	return p
}

func (s *CreateOrReplaceTagClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateOrReplaceTagClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPLACE, 0)
}

func (s *CreateOrReplaceTagClauseContext) TAG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTAG, 0)
}

func (s *CreateOrReplaceTagClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateOrReplaceTagClauseContext) TagOptions() ITagOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITagOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITagOptionsContext)
}

func (s *CreateOrReplaceTagClauseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateOrReplaceTagClauseContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOR, 0)
}

func (s *CreateOrReplaceTagClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *CreateOrReplaceTagClauseContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *CreateOrReplaceTagClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *CreateOrReplaceTagClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateOrReplaceTagClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateOrReplaceTagClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateOrReplaceTagClause(s)
	}
}

func (s *CreateOrReplaceTagClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateOrReplaceTagClause(s)
	}
}

func (s *CreateOrReplaceTagClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateOrReplaceTagClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateOrReplaceTagClause() (localctx ICreateOrReplaceTagClauseContext) {
	localctx = NewCreateOrReplaceTagClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, DorisSQLParserRULE_createOrReplaceTagClause)
	var _la int

	p.SetState(3109)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 252, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3092)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserCREATE {
			{
				p.SetState(3090)
				p.Match(DorisSQLParserCREATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3091)
				p.Match(DorisSQLParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3094)
			p.Match(DorisSQLParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3095)
			p.Match(DorisSQLParserTAG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3096)
			p.Identifier()
		}
		{
			p.SetState(3097)
			p.TagOptions()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3099)
			p.Match(DorisSQLParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3100)
			p.Match(DorisSQLParserTAG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3104)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserIF {
			{
				p.SetState(3101)
				p.Match(DorisSQLParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3102)
				p.Match(DorisSQLParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3103)
				p.Match(DorisSQLParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3106)
			p.Identifier()
		}
		{
			p.SetState(3107)
			p.TagOptions()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateOrReplaceBranchClauseContext is an interface to support dynamic dispatch.
type ICreateOrReplaceBranchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLACE() antlr.TerminalNode
	BRANCH() antlr.TerminalNode
	Identifier() IIdentifierContext
	BranchOptions() IBranchOptionsContext
	CREATE() antlr.TerminalNode
	OR() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsCreateOrReplaceBranchClauseContext differentiates from other interfaces.
	IsCreateOrReplaceBranchClauseContext()
}

type CreateOrReplaceBranchClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateOrReplaceBranchClauseContext() *CreateOrReplaceBranchClauseContext {
	var p = new(CreateOrReplaceBranchClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createOrReplaceBranchClause
	return p
}

func InitEmptyCreateOrReplaceBranchClauseContext(p *CreateOrReplaceBranchClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createOrReplaceBranchClause
}

func (*CreateOrReplaceBranchClauseContext) IsCreateOrReplaceBranchClauseContext() {}

func NewCreateOrReplaceBranchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateOrReplaceBranchClauseContext {
	var p = new(CreateOrReplaceBranchClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createOrReplaceBranchClause

	return p
}

func (s *CreateOrReplaceBranchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateOrReplaceBranchClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPLACE, 0)
}

func (s *CreateOrReplaceBranchClauseContext) BRANCH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBRANCH, 0)
}

func (s *CreateOrReplaceBranchClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateOrReplaceBranchClauseContext) BranchOptions() IBranchOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBranchOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBranchOptionsContext)
}

func (s *CreateOrReplaceBranchClauseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateOrReplaceBranchClauseContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOR, 0)
}

func (s *CreateOrReplaceBranchClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *CreateOrReplaceBranchClauseContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *CreateOrReplaceBranchClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *CreateOrReplaceBranchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateOrReplaceBranchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateOrReplaceBranchClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateOrReplaceBranchClause(s)
	}
}

func (s *CreateOrReplaceBranchClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateOrReplaceBranchClause(s)
	}
}

func (s *CreateOrReplaceBranchClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateOrReplaceBranchClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateOrReplaceBranchClause() (localctx ICreateOrReplaceBranchClauseContext) {
	localctx = NewCreateOrReplaceBranchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, DorisSQLParserRULE_createOrReplaceBranchClause)
	var _la int

	p.SetState(3130)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 255, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3113)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserCREATE {
			{
				p.SetState(3111)
				p.Match(DorisSQLParserCREATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3112)
				p.Match(DorisSQLParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3115)
			p.Match(DorisSQLParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3116)
			p.Match(DorisSQLParserBRANCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3117)
			p.Identifier()
		}
		{
			p.SetState(3118)
			p.BranchOptions()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3120)
			p.Match(DorisSQLParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3121)
			p.Match(DorisSQLParserBRANCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3125)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserIF {
			{
				p.SetState(3122)
				p.Match(DorisSQLParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3123)
				p.Match(DorisSQLParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3124)
				p.Match(DorisSQLParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3127)
			p.Identifier()
		}
		{
			p.SetState(3128)
			p.BranchOptions()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropBranchClauseContext is an interface to support dynamic dispatch.
type IDropBranchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	BRANCH() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropBranchClauseContext differentiates from other interfaces.
	IsDropBranchClauseContext()
}

type DropBranchClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropBranchClauseContext() *DropBranchClauseContext {
	var p = new(DropBranchClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropBranchClause
	return p
}

func InitEmptyDropBranchClauseContext(p *DropBranchClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropBranchClause
}

func (*DropBranchClauseContext) IsDropBranchClauseContext() {}

func NewDropBranchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropBranchClauseContext {
	var p = new(DropBranchClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropBranchClause

	return p
}

func (s *DropBranchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropBranchClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropBranchClauseContext) BRANCH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBRANCH, 0)
}

func (s *DropBranchClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropBranchClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *DropBranchClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *DropBranchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropBranchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropBranchClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropBranchClause(s)
	}
}

func (s *DropBranchClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropBranchClause(s)
	}
}

func (s *DropBranchClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropBranchClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropBranchClause() (localctx IDropBranchClauseContext) {
	localctx = NewDropBranchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, DorisSQLParserRULE_dropBranchClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3132)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3133)
		p.Match(DorisSQLParserBRANCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3136)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(3134)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3135)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3138)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTagClauseContext is an interface to support dynamic dispatch.
type IDropTagClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TAG() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropTagClauseContext differentiates from other interfaces.
	IsDropTagClauseContext()
}

type DropTagClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTagClauseContext() *DropTagClauseContext {
	var p = new(DropTagClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropTagClause
	return p
}

func InitEmptyDropTagClauseContext(p *DropTagClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropTagClause
}

func (*DropTagClauseContext) IsDropTagClauseContext() {}

func NewDropTagClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTagClauseContext {
	var p = new(DropTagClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropTagClause

	return p
}

func (s *DropTagClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTagClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropTagClauseContext) TAG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTAG, 0)
}

func (s *DropTagClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropTagClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *DropTagClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *DropTagClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTagClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTagClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropTagClause(s)
	}
}

func (s *DropTagClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropTagClause(s)
	}
}

func (s *DropTagClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropTagClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropTagClause() (localctx IDropTagClauseContext) {
	localctx = NewDropTagClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, DorisSQLParserRULE_dropTagClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3140)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3141)
		p.Match(DorisSQLParserTAG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3144)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(3142)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3143)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3146)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableOperationClauseContext is an interface to support dynamic dispatch.
type ITableOperationClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXECUTE() antlr.TerminalNode
	FunctionCall() IFunctionCallContext

	// IsTableOperationClauseContext differentiates from other interfaces.
	IsTableOperationClauseContext()
}

type TableOperationClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableOperationClauseContext() *TableOperationClauseContext {
	var p = new(TableOperationClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_tableOperationClause
	return p
}

func InitEmptyTableOperationClauseContext(p *TableOperationClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_tableOperationClause
}

func (*TableOperationClauseContext) IsTableOperationClauseContext() {}

func NewTableOperationClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableOperationClauseContext {
	var p = new(TableOperationClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_tableOperationClause

	return p
}

func (s *TableOperationClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TableOperationClauseContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXECUTE, 0)
}

func (s *TableOperationClauseContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *TableOperationClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOperationClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableOperationClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTableOperationClause(s)
	}
}

func (s *TableOperationClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTableOperationClause(s)
	}
}

func (s *TableOperationClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTableOperationClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) TableOperationClause() (localctx ITableOperationClauseContext) {
	localctx = NewTableOperationClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, DorisSQLParserRULE_tableOperationClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3148)
		p.Match(DorisSQLParserEXECUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3149)
		p.FunctionCall()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITagOptionsContext is an interface to support dynamic dispatch.
type ITagOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	SnapshotId() ISnapshotIdContext
	RefRetain() IRefRetainContext

	// IsTagOptionsContext differentiates from other interfaces.
	IsTagOptionsContext()
}

type TagOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTagOptionsContext() *TagOptionsContext {
	var p = new(TagOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_tagOptions
	return p
}

func InitEmptyTagOptionsContext(p *TagOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_tagOptions
}

func (*TagOptionsContext) IsTagOptionsContext() {}

func NewTagOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TagOptionsContext {
	var p = new(TagOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_tagOptions

	return p
}

func (s *TagOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *TagOptionsContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *TagOptionsContext) OF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOF, 0)
}

func (s *TagOptionsContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVERSION, 0)
}

func (s *TagOptionsContext) SnapshotId() ISnapshotIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISnapshotIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISnapshotIdContext)
}

func (s *TagOptionsContext) RefRetain() IRefRetainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefRetainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefRetainContext)
}

func (s *TagOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TagOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TagOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTagOptions(s)
	}
}

func (s *TagOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTagOptions(s)
	}
}

func (s *TagOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTagOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) TagOptions() (localctx ITagOptionsContext) {
	localctx = NewTagOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, DorisSQLParserRULE_tagOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3155)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserAS {
		{
			p.SetState(3151)
			p.Match(DorisSQLParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3152)
			p.Match(DorisSQLParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3153)
			p.Match(DorisSQLParserVERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3154)
			p.SnapshotId()
		}

	}
	p.SetState(3158)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserRETAIN {
		{
			p.SetState(3157)
			p.RefRetain()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBranchOptionsContext is an interface to support dynamic dispatch.
type IBranchOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	SnapshotId() ISnapshotIdContext
	RefRetain() IRefRetainContext
	SnapshotRetention() ISnapshotRetentionContext

	// IsBranchOptionsContext differentiates from other interfaces.
	IsBranchOptionsContext()
}

type BranchOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBranchOptionsContext() *BranchOptionsContext {
	var p = new(BranchOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_branchOptions
	return p
}

func InitEmptyBranchOptionsContext(p *BranchOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_branchOptions
}

func (*BranchOptionsContext) IsBranchOptionsContext() {}

func NewBranchOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BranchOptionsContext {
	var p = new(BranchOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_branchOptions

	return p
}

func (s *BranchOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *BranchOptionsContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *BranchOptionsContext) OF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOF, 0)
}

func (s *BranchOptionsContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVERSION, 0)
}

func (s *BranchOptionsContext) SnapshotId() ISnapshotIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISnapshotIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISnapshotIdContext)
}

func (s *BranchOptionsContext) RefRetain() IRefRetainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefRetainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefRetainContext)
}

func (s *BranchOptionsContext) SnapshotRetention() ISnapshotRetentionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISnapshotRetentionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISnapshotRetentionContext)
}

func (s *BranchOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BranchOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BranchOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterBranchOptions(s)
	}
}

func (s *BranchOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitBranchOptions(s)
	}
}

func (s *BranchOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitBranchOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) BranchOptions() (localctx IBranchOptionsContext) {
	localctx = NewBranchOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, DorisSQLParserRULE_branchOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3164)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserAS {
		{
			p.SetState(3160)
			p.Match(DorisSQLParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3161)
			p.Match(DorisSQLParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3162)
			p.Match(DorisSQLParserVERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3163)
			p.SnapshotId()
		}

	}
	p.SetState(3167)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserRETAIN {
		{
			p.SetState(3166)
			p.RefRetain()
		}

	}
	p.SetState(3170)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWITH {
		{
			p.SetState(3169)
			p.SnapshotRetention()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISnapshotRetentionContext is an interface to support dynamic dispatch.
type ISnapshotRetentionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	RETENTION() antlr.TerminalNode
	MinSnapshotsToKeep() IMinSnapshotsToKeepContext
	MaxSnapshotAge() IMaxSnapshotAgeContext

	// IsSnapshotRetentionContext differentiates from other interfaces.
	IsSnapshotRetentionContext()
}

type SnapshotRetentionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySnapshotRetentionContext() *SnapshotRetentionContext {
	var p = new(SnapshotRetentionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_snapshotRetention
	return p
}

func InitEmptySnapshotRetentionContext(p *SnapshotRetentionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_snapshotRetention
}

func (*SnapshotRetentionContext) IsSnapshotRetentionContext() {}

func NewSnapshotRetentionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SnapshotRetentionContext {
	var p = new(SnapshotRetentionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_snapshotRetention

	return p
}

func (s *SnapshotRetentionContext) GetParser() antlr.Parser { return s.parser }

func (s *SnapshotRetentionContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *SnapshotRetentionContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSNAPSHOT, 0)
}

func (s *SnapshotRetentionContext) RETENTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRETENTION, 0)
}

func (s *SnapshotRetentionContext) MinSnapshotsToKeep() IMinSnapshotsToKeepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMinSnapshotsToKeepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMinSnapshotsToKeepContext)
}

func (s *SnapshotRetentionContext) MaxSnapshotAge() IMaxSnapshotAgeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaxSnapshotAgeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaxSnapshotAgeContext)
}

func (s *SnapshotRetentionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SnapshotRetentionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SnapshotRetentionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSnapshotRetention(s)
	}
}

func (s *SnapshotRetentionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSnapshotRetention(s)
	}
}

func (s *SnapshotRetentionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSnapshotRetention(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SnapshotRetention() (localctx ISnapshotRetentionContext) {
	localctx = NewSnapshotRetentionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, DorisSQLParserRULE_snapshotRetention)
	p.SetState(3186)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 263, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3172)
			p.Match(DorisSQLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3173)
			p.Match(DorisSQLParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3174)
			p.Match(DorisSQLParserRETENTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3175)
			p.MinSnapshotsToKeep()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3176)
			p.Match(DorisSQLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3177)
			p.Match(DorisSQLParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3178)
			p.Match(DorisSQLParserRETENTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3179)
			p.MaxSnapshotAge()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3180)
			p.Match(DorisSQLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3181)
			p.Match(DorisSQLParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3182)
			p.Match(DorisSQLParserRETENTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3183)
			p.MinSnapshotsToKeep()
		}
		{
			p.SetState(3184)
			p.MaxSnapshotAge()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefRetainContext is an interface to support dynamic dispatch.
type IRefRetainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETAIN() antlr.TerminalNode
	Number() INumberContext
	TimeUnit() ITimeUnitContext

	// IsRefRetainContext differentiates from other interfaces.
	IsRefRetainContext()
}

type RefRetainContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefRetainContext() *RefRetainContext {
	var p = new(RefRetainContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_refRetain
	return p
}

func InitEmptyRefRetainContext(p *RefRetainContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_refRetain
}

func (*RefRetainContext) IsRefRetainContext() {}

func NewRefRetainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefRetainContext {
	var p = new(RefRetainContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_refRetain

	return p
}

func (s *RefRetainContext) GetParser() antlr.Parser { return s.parser }

func (s *RefRetainContext) RETAIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRETAIN, 0)
}

func (s *RefRetainContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *RefRetainContext) TimeUnit() ITimeUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeUnitContext)
}

func (s *RefRetainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefRetainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefRetainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRefRetain(s)
	}
}

func (s *RefRetainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRefRetain(s)
	}
}

func (s *RefRetainContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRefRetain(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) RefRetain() (localctx IRefRetainContext) {
	localctx = NewRefRetainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, DorisSQLParserRULE_refRetain)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3188)
		p.Match(DorisSQLParserRETAIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3189)
		p.Number()
	}
	{
		p.SetState(3190)
		p.TimeUnit()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaxSnapshotAgeContext is an interface to support dynamic dispatch.
type IMaxSnapshotAgeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext
	TimeUnit() ITimeUnitContext

	// IsMaxSnapshotAgeContext differentiates from other interfaces.
	IsMaxSnapshotAgeContext()
}

type MaxSnapshotAgeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaxSnapshotAgeContext() *MaxSnapshotAgeContext {
	var p = new(MaxSnapshotAgeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_maxSnapshotAge
	return p
}

func InitEmptyMaxSnapshotAgeContext(p *MaxSnapshotAgeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_maxSnapshotAge
}

func (*MaxSnapshotAgeContext) IsMaxSnapshotAgeContext() {}

func NewMaxSnapshotAgeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaxSnapshotAgeContext {
	var p = new(MaxSnapshotAgeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_maxSnapshotAge

	return p
}

func (s *MaxSnapshotAgeContext) GetParser() antlr.Parser { return s.parser }

func (s *MaxSnapshotAgeContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *MaxSnapshotAgeContext) TimeUnit() ITimeUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeUnitContext)
}

func (s *MaxSnapshotAgeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaxSnapshotAgeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaxSnapshotAgeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterMaxSnapshotAge(s)
	}
}

func (s *MaxSnapshotAgeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitMaxSnapshotAge(s)
	}
}

func (s *MaxSnapshotAgeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitMaxSnapshotAge(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) MaxSnapshotAge() (localctx IMaxSnapshotAgeContext) {
	localctx = NewMaxSnapshotAgeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, DorisSQLParserRULE_maxSnapshotAge)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3192)
		p.Number()
	}
	{
		p.SetState(3193)
		p.TimeUnit()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMinSnapshotsToKeepContext is an interface to support dynamic dispatch.
type IMinSnapshotsToKeepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext
	SNAPSHOTS() antlr.TerminalNode

	// IsMinSnapshotsToKeepContext differentiates from other interfaces.
	IsMinSnapshotsToKeepContext()
}

type MinSnapshotsToKeepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMinSnapshotsToKeepContext() *MinSnapshotsToKeepContext {
	var p = new(MinSnapshotsToKeepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_minSnapshotsToKeep
	return p
}

func InitEmptyMinSnapshotsToKeepContext(p *MinSnapshotsToKeepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_minSnapshotsToKeep
}

func (*MinSnapshotsToKeepContext) IsMinSnapshotsToKeepContext() {}

func NewMinSnapshotsToKeepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MinSnapshotsToKeepContext {
	var p = new(MinSnapshotsToKeepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_minSnapshotsToKeep

	return p
}

func (s *MinSnapshotsToKeepContext) GetParser() antlr.Parser { return s.parser }

func (s *MinSnapshotsToKeepContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *MinSnapshotsToKeepContext) SNAPSHOTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSNAPSHOTS, 0)
}

func (s *MinSnapshotsToKeepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MinSnapshotsToKeepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MinSnapshotsToKeepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterMinSnapshotsToKeep(s)
	}
}

func (s *MinSnapshotsToKeepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitMinSnapshotsToKeep(s)
	}
}

func (s *MinSnapshotsToKeepContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitMinSnapshotsToKeep(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) MinSnapshotsToKeep() (localctx IMinSnapshotsToKeepContext) {
	localctx = NewMinSnapshotsToKeepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, DorisSQLParserRULE_minSnapshotsToKeep)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3195)
		p.Number()
	}
	{
		p.SetState(3196)
		p.Match(DorisSQLParserSNAPSHOTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISnapshotIdContext is an interface to support dynamic dispatch.
type ISnapshotIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext

	// IsSnapshotIdContext differentiates from other interfaces.
	IsSnapshotIdContext()
}

type SnapshotIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySnapshotIdContext() *SnapshotIdContext {
	var p = new(SnapshotIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_snapshotId
	return p
}

func InitEmptySnapshotIdContext(p *SnapshotIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_snapshotId
}

func (*SnapshotIdContext) IsSnapshotIdContext() {}

func NewSnapshotIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SnapshotIdContext {
	var p = new(SnapshotIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_snapshotId

	return p
}

func (s *SnapshotIdContext) GetParser() antlr.Parser { return s.parser }

func (s *SnapshotIdContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *SnapshotIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SnapshotIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SnapshotIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSnapshotId(s)
	}
}

func (s *SnapshotIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSnapshotId(s)
	}
}

func (s *SnapshotIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSnapshotId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SnapshotId() (localctx ISnapshotIdContext) {
	localctx = NewSnapshotIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, DorisSQLParserRULE_snapshotId)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3198)
		p.Number()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimeUnitContext is an interface to support dynamic dispatch.
type ITimeUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DAYS() antlr.TerminalNode
	HOURS() antlr.TerminalNode
	MINUTES() antlr.TerminalNode

	// IsTimeUnitContext differentiates from other interfaces.
	IsTimeUnitContext()
}

type TimeUnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeUnitContext() *TimeUnitContext {
	var p = new(TimeUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_timeUnit
	return p
}

func InitEmptyTimeUnitContext(p *TimeUnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_timeUnit
}

func (*TimeUnitContext) IsTimeUnitContext() {}

func NewTimeUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeUnitContext {
	var p = new(TimeUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_timeUnit

	return p
}

func (s *TimeUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeUnitContext) DAYS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDAYS, 0)
}

func (s *TimeUnitContext) HOURS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserHOURS, 0)
}

func (s *TimeUnitContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMINUTES, 0)
}

func (s *TimeUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimeUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTimeUnit(s)
	}
}

func (s *TimeUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTimeUnit(s)
	}
}

func (s *TimeUnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTimeUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) TimeUnit() (localctx ITimeUnitContext) {
	localctx = NewTimeUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, DorisSQLParserRULE_timeUnit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3200)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserDAYS || _la == DorisSQLParserHOURS || _la == DorisSQLParserMINUTES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInteger_listContext is an interface to support dynamic dispatch.
type IInteger_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsInteger_listContext differentiates from other interfaces.
	IsInteger_listContext()
}

type Integer_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInteger_listContext() *Integer_listContext {
	var p = new(Integer_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_integer_list
	return p
}

func InitEmptyInteger_listContext(p *Integer_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_integer_list
}

func (*Integer_listContext) IsInteger_listContext() {}

func NewInteger_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Integer_listContext {
	var p = new(Integer_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_integer_list

	return p
}

func (s *Integer_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Integer_listContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserINTEGER_VALUE)
}

func (s *Integer_listContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, i)
}

func (s *Integer_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Integer_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Integer_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterInteger_list(s)
	}
}

func (s *Integer_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitInteger_list(s)
	}
}

func (s *Integer_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitInteger_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Integer_list() (localctx IInteger_listContext) {
	localctx = NewInteger_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, DorisSQLParserRULE_integer_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3202)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3203)
		p.Match(DorisSQLParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3208)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(3204)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3205)
			p.Match(DorisSQLParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(3210)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3211)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropPersistentIndexClauseContext is an interface to support dynamic dispatch.
type IDropPersistentIndexClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	PERSISTENT() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	ON() antlr.TerminalNode
	TABLETS() antlr.TerminalNode
	Integer_list() IInteger_listContext

	// IsDropPersistentIndexClauseContext differentiates from other interfaces.
	IsDropPersistentIndexClauseContext()
}

type DropPersistentIndexClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropPersistentIndexClauseContext() *DropPersistentIndexClauseContext {
	var p = new(DropPersistentIndexClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropPersistentIndexClause
	return p
}

func InitEmptyDropPersistentIndexClauseContext(p *DropPersistentIndexClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropPersistentIndexClause
}

func (*DropPersistentIndexClauseContext) IsDropPersistentIndexClauseContext() {}

func NewDropPersistentIndexClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropPersistentIndexClauseContext {
	var p = new(DropPersistentIndexClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropPersistentIndexClause

	return p
}

func (s *DropPersistentIndexClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropPersistentIndexClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropPersistentIndexClauseContext) PERSISTENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPERSISTENT, 0)
}

func (s *DropPersistentIndexClauseContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINDEX, 0)
}

func (s *DropPersistentIndexClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *DropPersistentIndexClauseContext) TABLETS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLETS, 0)
}

func (s *DropPersistentIndexClauseContext) Integer_list() IInteger_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInteger_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInteger_listContext)
}

func (s *DropPersistentIndexClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropPersistentIndexClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropPersistentIndexClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropPersistentIndexClause(s)
	}
}

func (s *DropPersistentIndexClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropPersistentIndexClause(s)
	}
}

func (s *DropPersistentIndexClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropPersistentIndexClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropPersistentIndexClause() (localctx IDropPersistentIndexClauseContext) {
	localctx = NewDropPersistentIndexClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, DorisSQLParserRULE_dropPersistentIndexClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3213)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3214)
		p.Match(DorisSQLParserPERSISTENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3215)
		p.Match(DorisSQLParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3216)
		p.Match(DorisSQLParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3217)
		p.Match(DorisSQLParserTABLETS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3218)
		p.Integer_list()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddPartitionClauseContext is an interface to support dynamic dispatch.
type IAddPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	SingleRangePartition() ISingleRangePartitionContext
	PARTITIONS() antlr.TerminalNode
	MultiRangePartition() IMultiRangePartitionContext
	TEMPORARY() antlr.TerminalNode
	DistributionDesc() IDistributionDescContext
	Properties() IPropertiesContext
	SingleItemListPartitionDesc() ISingleItemListPartitionDescContext
	MultiItemListPartitionDesc() IMultiItemListPartitionDescContext

	// IsAddPartitionClauseContext differentiates from other interfaces.
	IsAddPartitionClauseContext()
}

type AddPartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddPartitionClauseContext() *AddPartitionClauseContext {
	var p = new(AddPartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_addPartitionClause
	return p
}

func InitEmptyAddPartitionClauseContext(p *AddPartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_addPartitionClause
}

func (*AddPartitionClauseContext) IsAddPartitionClauseContext() {}

func NewAddPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddPartitionClauseContext {
	var p = new(AddPartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_addPartitionClause

	return p
}

func (s *AddPartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddPartitionClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADD, 0)
}

func (s *AddPartitionClauseContext) SingleRangePartition() ISingleRangePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleRangePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleRangePartitionContext)
}

func (s *AddPartitionClauseContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPARTITIONS, 0)
}

func (s *AddPartitionClauseContext) MultiRangePartition() IMultiRangePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiRangePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiRangePartitionContext)
}

func (s *AddPartitionClauseContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTEMPORARY, 0)
}

func (s *AddPartitionClauseContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *AddPartitionClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AddPartitionClauseContext) SingleItemListPartitionDesc() ISingleItemListPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleItemListPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleItemListPartitionDescContext)
}

func (s *AddPartitionClauseContext) MultiItemListPartitionDesc() IMultiItemListPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiItemListPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiItemListPartitionDescContext)
}

func (s *AddPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddPartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAddPartitionClause(s)
	}
}

func (s *AddPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAddPartitionClause(s)
	}
}

func (s *AddPartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAddPartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AddPartitionClause() (localctx IAddPartitionClauseContext) {
	localctx = NewAddPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, DorisSQLParserRULE_addPartitionClause)
	var _la int

	p.SetState(3249)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 273, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3220)
			p.Match(DorisSQLParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3222)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserTEMPORARY {
			{
				p.SetState(3221)
				p.Match(DorisSQLParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3227)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserPARTITION:
			{
				p.SetState(3224)
				p.SingleRangePartition()
			}

		case DorisSQLParserPARTITIONS:
			{
				p.SetState(3225)
				p.Match(DorisSQLParserPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3226)
				p.MultiRangePartition()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(3230)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserDISTRIBUTED {
			{
				p.SetState(3229)
				p.DistributionDesc()
			}

		}
		p.SetState(3233)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserPROPERTIES {
			{
				p.SetState(3232)
				p.Properties()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3235)
			p.Match(DorisSQLParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3237)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserTEMPORARY {
			{
				p.SetState(3236)
				p.Match(DorisSQLParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3241)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 270, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3239)
				p.SingleItemListPartitionDesc()
			}

		case 2:
			{
				p.SetState(3240)
				p.MultiItemListPartitionDesc()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(3244)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserDISTRIBUTED {
			{
				p.SetState(3243)
				p.DistributionDesc()
			}

		}
		p.SetState(3247)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserPROPERTIES {
			{
				p.SetState(3246)
				p.Properties()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropPartitionClauseContext is an interface to support dynamic dispatch.
type IDropPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	PARTITIONS() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	TEMPORARY() antlr.TerminalNode
	FORCE() antlr.TerminalNode
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	MultiRangePartition() IMultiRangePartitionContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ALL() antlr.TerminalNode

	// IsDropPartitionClauseContext differentiates from other interfaces.
	IsDropPartitionClauseContext()
}

type DropPartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IExpressionContext
}

func NewEmptyDropPartitionClauseContext() *DropPartitionClauseContext {
	var p = new(DropPartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropPartitionClause
	return p
}

func InitEmptyDropPartitionClauseContext(p *DropPartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropPartitionClause
}

func (*DropPartitionClauseContext) IsDropPartitionClauseContext() {}

func NewDropPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropPartitionClauseContext {
	var p = new(DropPartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropPartitionClause

	return p
}

func (s *DropPartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropPartitionClauseContext) GetWhere() IExpressionContext { return s.where }

func (s *DropPartitionClauseContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *DropPartitionClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropPartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPARTITION, 0)
}

func (s *DropPartitionClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropPartitionClauseContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPARTITIONS, 0)
}

func (s *DropPartitionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DropPartitionClauseContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTEMPORARY, 0)
}

func (s *DropPartitionClauseContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFORCE, 0)
}

func (s *DropPartitionClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *DropPartitionClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *DropPartitionClauseContext) MultiRangePartition() IMultiRangePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiRangePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiRangePartitionContext)
}

func (s *DropPartitionClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *DropPartitionClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DropPartitionClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, 0)
}

func (s *DropPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropPartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropPartitionClause(s)
	}
}

func (s *DropPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropPartitionClause(s)
	}
}

func (s *DropPartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropPartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropPartitionClause() (localctx IDropPartitionClauseContext) {
	localctx = NewDropPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, DorisSQLParserRULE_dropPartitionClause)
	var _la int

	p.SetState(3306)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 286, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3251)
			p.Match(DorisSQLParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3253)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserTEMPORARY {
			{
				p.SetState(3252)
				p.Match(DorisSQLParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3267)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserPARTITION:
			{
				p.SetState(3255)
				p.Match(DorisSQLParserPARTITION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3258)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserIF {
				{
					p.SetState(3256)
					p.Match(DorisSQLParserIF)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3257)
					p.Match(DorisSQLParserEXISTS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(3260)
				p.Identifier()
			}

		case DorisSQLParserPARTITIONS:
			{
				p.SetState(3261)
				p.Match(DorisSQLParserPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3264)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserIF {
				{
					p.SetState(3262)
					p.Match(DorisSQLParserIF)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3263)
					p.Match(DorisSQLParserEXISTS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(3266)
				p.IdentifierList()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(3270)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserFORCE {
			{
				p.SetState(3269)
				p.Match(DorisSQLParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3272)
			p.Match(DorisSQLParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3274)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserTEMPORARY {
			{
				p.SetState(3273)
				p.Match(DorisSQLParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3276)
			p.Match(DorisSQLParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3279)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserIF {
			{
				p.SetState(3277)
				p.Match(DorisSQLParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3278)
				p.Match(DorisSQLParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3281)
			p.MultiRangePartition()
		}
		p.SetState(3283)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserFORCE {
			{
				p.SetState(3282)
				p.Match(DorisSQLParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3285)
			p.Match(DorisSQLParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3287)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserTEMPORARY {
			{
				p.SetState(3286)
				p.Match(DorisSQLParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3289)
			p.Match(DorisSQLParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3292)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserIF {
			{
				p.SetState(3290)
				p.Match(DorisSQLParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3291)
				p.Match(DorisSQLParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3294)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3295)

			var _x = p.expression(0)

			localctx.(*DropPartitionClauseContext).where = _x
		}
		p.SetState(3297)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserFORCE {
			{
				p.SetState(3296)
				p.Match(DorisSQLParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3299)
			p.Match(DorisSQLParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3300)
			p.Match(DorisSQLParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3301)
			p.Match(DorisSQLParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3302)
			p.Match(DorisSQLParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3304)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserFORCE {
			{
				p.SetState(3303)
				p.Match(DorisSQLParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITruncatePartitionClauseContext is an interface to support dynamic dispatch.
type ITruncatePartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUNCATE() antlr.TerminalNode
	PartitionNames() IPartitionNamesContext

	// IsTruncatePartitionClauseContext differentiates from other interfaces.
	IsTruncatePartitionClauseContext()
}

type TruncatePartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncatePartitionClauseContext() *TruncatePartitionClauseContext {
	var p = new(TruncatePartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_truncatePartitionClause
	return p
}

func InitEmptyTruncatePartitionClauseContext(p *TruncatePartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_truncatePartitionClause
}

func (*TruncatePartitionClauseContext) IsTruncatePartitionClauseContext() {}

func NewTruncatePartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncatePartitionClauseContext {
	var p = new(TruncatePartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_truncatePartitionClause

	return p
}

func (s *TruncatePartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncatePartitionClauseContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTRUNCATE, 0)
}

func (s *TruncatePartitionClauseContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *TruncatePartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncatePartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TruncatePartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTruncatePartitionClause(s)
	}
}

func (s *TruncatePartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTruncatePartitionClause(s)
	}
}

func (s *TruncatePartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTruncatePartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) TruncatePartitionClause() (localctx ITruncatePartitionClauseContext) {
	localctx = NewTruncatePartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, DorisSQLParserRULE_truncatePartitionClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3308)
		p.Match(DorisSQLParserTRUNCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3309)
		p.PartitionNames()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyPartitionClauseContext is an interface to support dynamic dispatch.
type IModifyPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODIFY() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext
	Identifier() IIdentifierContext
	IdentifierList() IIdentifierListContext
	ASTERISK_SYMBOL() antlr.TerminalNode
	DistributionDesc() IDistributionDescContext

	// IsModifyPartitionClauseContext differentiates from other interfaces.
	IsModifyPartitionClauseContext()
}

type ModifyPartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyPartitionClauseContext() *ModifyPartitionClauseContext {
	var p = new(ModifyPartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_modifyPartitionClause
	return p
}

func InitEmptyModifyPartitionClauseContext(p *ModifyPartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_modifyPartitionClause
}

func (*ModifyPartitionClauseContext) IsModifyPartitionClauseContext() {}

func NewModifyPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyPartitionClauseContext {
	var p = new(ModifyPartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_modifyPartitionClause

	return p
}

func (s *ModifyPartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyPartitionClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMODIFY, 0)
}

func (s *ModifyPartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPARTITION, 0)
}

func (s *ModifyPartitionClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *ModifyPartitionClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *ModifyPartitionClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifyPartitionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ModifyPartitionClauseContext) ASTERISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserASTERISK_SYMBOL, 0)
}

func (s *ModifyPartitionClauseContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *ModifyPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyPartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterModifyPartitionClause(s)
	}
}

func (s *ModifyPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitModifyPartitionClause(s)
	}
}

func (s *ModifyPartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitModifyPartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ModifyPartitionClause() (localctx IModifyPartitionClauseContext) {
	localctx = NewModifyPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, DorisSQLParserRULE_modifyPartitionClause)
	p.SetState(3325)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 288, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3311)
			p.Match(DorisSQLParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3312)
			p.Match(DorisSQLParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3318)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 287, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3313)
				p.Identifier()
			}

		case 2:
			{
				p.SetState(3314)
				p.IdentifierList()
			}

		case 3:
			{
				p.SetState(3315)
				p.Match(DorisSQLParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3316)
				p.Match(DorisSQLParserASTERISK_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3317)
				p.Match(DorisSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(3320)
			p.Match(DorisSQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3321)
			p.PropertyList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3322)
			p.Match(DorisSQLParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3323)
			p.Match(DorisSQLParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3324)
			p.DistributionDesc()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplacePartitionClauseContext is an interface to support dynamic dispatch.
type IReplacePartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetParName returns the parName rule contexts.
	GetParName() IPartitionNamesContext

	// GetTempParName returns the tempParName rule contexts.
	GetTempParName() IPartitionNamesContext

	// SetParName sets the parName rule contexts.
	SetParName(IPartitionNamesContext)

	// SetTempParName sets the tempParName rule contexts.
	SetTempParName(IPartitionNamesContext)

	// Getter signatures
	REPLACE() antlr.TerminalNode
	WITH() antlr.TerminalNode
	AllPartitionNames() []IPartitionNamesContext
	PartitionNames(i int) IPartitionNamesContext
	Properties() IPropertiesContext

	// IsReplacePartitionClauseContext differentiates from other interfaces.
	IsReplacePartitionClauseContext()
}

type ReplacePartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	parName     IPartitionNamesContext
	tempParName IPartitionNamesContext
}

func NewEmptyReplacePartitionClauseContext() *ReplacePartitionClauseContext {
	var p = new(ReplacePartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_replacePartitionClause
	return p
}

func InitEmptyReplacePartitionClauseContext(p *ReplacePartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_replacePartitionClause
}

func (*ReplacePartitionClauseContext) IsReplacePartitionClauseContext() {}

func NewReplacePartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplacePartitionClauseContext {
	var p = new(ReplacePartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_replacePartitionClause

	return p
}

func (s *ReplacePartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplacePartitionClauseContext) GetParName() IPartitionNamesContext { return s.parName }

func (s *ReplacePartitionClauseContext) GetTempParName() IPartitionNamesContext { return s.tempParName }

func (s *ReplacePartitionClauseContext) SetParName(v IPartitionNamesContext) { s.parName = v }

func (s *ReplacePartitionClauseContext) SetTempParName(v IPartitionNamesContext) { s.tempParName = v }

func (s *ReplacePartitionClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPLACE, 0)
}

func (s *ReplacePartitionClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *ReplacePartitionClauseContext) AllPartitionNames() []IPartitionNamesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			len++
		}
	}

	tst := make([]IPartitionNamesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionNamesContext); ok {
			tst[i] = t.(IPartitionNamesContext)
			i++
		}
	}

	return tst
}

func (s *ReplacePartitionClauseContext) PartitionNames(i int) IPartitionNamesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *ReplacePartitionClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *ReplacePartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplacePartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplacePartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterReplacePartitionClause(s)
	}
}

func (s *ReplacePartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitReplacePartitionClause(s)
	}
}

func (s *ReplacePartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitReplacePartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ReplacePartitionClause() (localctx IReplacePartitionClauseContext) {
	localctx = NewReplacePartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, DorisSQLParserRULE_replacePartitionClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3327)
		p.Match(DorisSQLParserREPLACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3328)

		var _x = p.PartitionNames()

		localctx.(*ReplacePartitionClauseContext).parName = _x
	}
	{
		p.SetState(3329)
		p.Match(DorisSQLParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3330)

		var _x = p.PartitionNames()

		localctx.(*ReplacePartitionClauseContext).tempParName = _x
	}
	p.SetState(3332)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(3331)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionRenameClauseContext is an interface to support dynamic dispatch.
type IPartitionRenameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetParName returns the parName rule contexts.
	GetParName() IIdentifierContext

	// GetNewParName returns the newParName rule contexts.
	GetNewParName() IIdentifierContext

	// SetParName sets the parName rule contexts.
	SetParName(IIdentifierContext)

	// SetNewParName sets the newParName rule contexts.
	SetNewParName(IIdentifierContext)

	// Getter signatures
	RENAME() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsPartitionRenameClauseContext differentiates from other interfaces.
	IsPartitionRenameClauseContext()
}

type PartitionRenameClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	parName    IIdentifierContext
	newParName IIdentifierContext
}

func NewEmptyPartitionRenameClauseContext() *PartitionRenameClauseContext {
	var p = new(PartitionRenameClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_partitionRenameClause
	return p
}

func InitEmptyPartitionRenameClauseContext(p *PartitionRenameClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_partitionRenameClause
}

func (*PartitionRenameClauseContext) IsPartitionRenameClauseContext() {}

func NewPartitionRenameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionRenameClauseContext {
	var p = new(PartitionRenameClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_partitionRenameClause

	return p
}

func (s *PartitionRenameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionRenameClauseContext) GetParName() IIdentifierContext { return s.parName }

func (s *PartitionRenameClauseContext) GetNewParName() IIdentifierContext { return s.newParName }

func (s *PartitionRenameClauseContext) SetParName(v IIdentifierContext) { s.parName = v }

func (s *PartitionRenameClauseContext) SetNewParName(v IIdentifierContext) { s.newParName = v }

func (s *PartitionRenameClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRENAME, 0)
}

func (s *PartitionRenameClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPARTITION, 0)
}

func (s *PartitionRenameClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *PartitionRenameClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PartitionRenameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionRenameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionRenameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPartitionRenameClause(s)
	}
}

func (s *PartitionRenameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPartitionRenameClause(s)
	}
}

func (s *PartitionRenameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPartitionRenameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PartitionRenameClause() (localctx IPartitionRenameClauseContext) {
	localctx = NewPartitionRenameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, DorisSQLParserRULE_partitionRenameClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3334)
		p.Match(DorisSQLParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3335)
		p.Match(DorisSQLParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3336)

		var _x = p.Identifier()

		localctx.(*PartitionRenameClauseContext).parName = _x
	}
	{
		p.SetState(3337)

		var _x = p.Identifier()

		localctx.(*PartitionRenameClauseContext).newParName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertStatementContext is an interface to support dynamic dispatch.
type IInsertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INSERT() antlr.TerminalNode
	INTO() antlr.TerminalNode
	OVERWRITE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	QueryStatement() IQueryStatementContext
	ExplainDesc() IExplainDescContext
	AllInsertLabelOrColumnAliases() []IInsertLabelOrColumnAliasesContext
	InsertLabelOrColumnAliases(i int) IInsertLabelOrColumnAliasesContext
	Properties() IPropertiesContext
	FILES() antlr.TerminalNode
	PropertyList() IPropertyListContext
	BLACKHOLE() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	AllExpressionsWithDefault() []IExpressionsWithDefaultContext
	ExpressionsWithDefault(i int) IExpressionsWithDefaultContext
	WriteBranch() IWriteBranchContext
	PartitionNames() IPartitionNamesContext

	// IsInsertStatementContext differentiates from other interfaces.
	IsInsertStatementContext()
}

type InsertStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertStatementContext() *InsertStatementContext {
	var p = new(InsertStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_insertStatement
	return p
}

func InitEmptyInsertStatementContext(p *InsertStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_insertStatement
}

func (*InsertStatementContext) IsInsertStatementContext() {}

func NewInsertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertStatementContext {
	var p = new(InsertStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_insertStatement

	return p
}

func (s *InsertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertStatementContext) INSERT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINSERT, 0)
}

func (s *InsertStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTO, 0)
}

func (s *InsertStatementContext) OVERWRITE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOVERWRITE, 0)
}

func (s *InsertStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *InsertStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *InsertStatementContext) ExplainDesc() IExplainDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainDescContext)
}

func (s *InsertStatementContext) AllInsertLabelOrColumnAliases() []IInsertLabelOrColumnAliasesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInsertLabelOrColumnAliasesContext); ok {
			len++
		}
	}

	tst := make([]IInsertLabelOrColumnAliasesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInsertLabelOrColumnAliasesContext); ok {
			tst[i] = t.(IInsertLabelOrColumnAliasesContext)
			i++
		}
	}

	return tst
}

func (s *InsertStatementContext) InsertLabelOrColumnAliases(i int) IInsertLabelOrColumnAliasesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertLabelOrColumnAliasesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertLabelOrColumnAliasesContext)
}

func (s *InsertStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *InsertStatementContext) FILES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFILES, 0)
}

func (s *InsertStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *InsertStatementContext) BLACKHOLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBLACKHOLE, 0)
}

func (s *InsertStatementContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVALUES, 0)
}

func (s *InsertStatementContext) AllExpressionsWithDefault() []IExpressionsWithDefaultContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionsWithDefaultContext); ok {
			len++
		}
	}

	tst := make([]IExpressionsWithDefaultContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionsWithDefaultContext); ok {
			tst[i] = t.(IExpressionsWithDefaultContext)
			i++
		}
	}

	return tst
}

func (s *InsertStatementContext) ExpressionsWithDefault(i int) IExpressionsWithDefaultContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsWithDefaultContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsWithDefaultContext)
}

func (s *InsertStatementContext) WriteBranch() IWriteBranchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWriteBranchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWriteBranchContext)
}

func (s *InsertStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *InsertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterInsertStatement(s)
	}
}

func (s *InsertStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitInsertStatement(s)
	}
}

func (s *InsertStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitInsertStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) InsertStatement() (localctx IInsertStatementContext) {
	localctx = NewInsertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, DorisSQLParserRULE_insertStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-125)) & ^0x3f) == 0 && ((int64(1)<<(_la-125))&16777219) != 0 {
		{
			p.SetState(3339)
			p.ExplainDesc()
		}

	}
	{
		p.SetState(3342)
		p.Match(DorisSQLParserINSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3343)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserINTO || _la == DorisSQLParserOVERWRITE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3356)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 293, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3344)
			p.QualifiedName()
		}
		p.SetState(3346)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserFOR || _la == DorisSQLParserVERSION {
			{
				p.SetState(3345)
				p.WriteBranch()
			}

		}
		p.SetState(3349)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserPARTITION || _la == DorisSQLParserPARTITIONS || _la == DorisSQLParserTEMPORARY {
			{
				p.SetState(3348)
				p.PartitionNames()
			}

		}

	case 2:
		{
			p.SetState(3351)
			p.Match(DorisSQLParserFILES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3352)
			p.PropertyList()
		}

	case 3:
		{
			p.SetState(3353)
			p.Match(DorisSQLParserBLACKHOLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3354)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3355)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(3361)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 294, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3358)
				p.InsertLabelOrColumnAliases()
			}

		}
		p.SetState(3363)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 294, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(3365)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(3364)
			p.Properties()
		}

	}
	p.SetState(3377)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserT__1, DorisSQLParserDESC, DorisSQLParserDESCRIBE, DorisSQLParserEXPLAIN, DorisSQLParserSELECT, DorisSQLParserTRACE, DorisSQLParserWITH:
		{
			p.SetState(3367)
			p.QueryStatement()
		}

	case DorisSQLParserVALUES:
		{
			p.SetState(3368)
			p.Match(DorisSQLParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3369)
			p.ExpressionsWithDefault()
		}
		p.SetState(3374)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(3370)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3371)
				p.ExpressionsWithDefault()
			}

			p.SetState(3376)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertLabelOrColumnAliasesContext is an interface to support dynamic dispatch.
type IInsertLabelOrColumnAliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLabel returns the label rule contexts.
	GetLabel() IIdentifierContext

	// SetLabel sets the label rule contexts.
	SetLabel(IIdentifierContext)

	// Getter signatures
	ColumnAliasesOrByName() IColumnAliasesOrByNameContext
	WITH() antlr.TerminalNode
	LABEL() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsInsertLabelOrColumnAliasesContext differentiates from other interfaces.
	IsInsertLabelOrColumnAliasesContext()
}

type InsertLabelOrColumnAliasesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	label  IIdentifierContext
}

func NewEmptyInsertLabelOrColumnAliasesContext() *InsertLabelOrColumnAliasesContext {
	var p = new(InsertLabelOrColumnAliasesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_insertLabelOrColumnAliases
	return p
}

func InitEmptyInsertLabelOrColumnAliasesContext(p *InsertLabelOrColumnAliasesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_insertLabelOrColumnAliases
}

func (*InsertLabelOrColumnAliasesContext) IsInsertLabelOrColumnAliasesContext() {}

func NewInsertLabelOrColumnAliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertLabelOrColumnAliasesContext {
	var p = new(InsertLabelOrColumnAliasesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_insertLabelOrColumnAliases

	return p
}

func (s *InsertLabelOrColumnAliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertLabelOrColumnAliasesContext) GetLabel() IIdentifierContext { return s.label }

func (s *InsertLabelOrColumnAliasesContext) SetLabel(v IIdentifierContext) { s.label = v }

func (s *InsertLabelOrColumnAliasesContext) ColumnAliasesOrByName() IColumnAliasesOrByNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesOrByNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesOrByNameContext)
}

func (s *InsertLabelOrColumnAliasesContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *InsertLabelOrColumnAliasesContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLABEL, 0)
}

func (s *InsertLabelOrColumnAliasesContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InsertLabelOrColumnAliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertLabelOrColumnAliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertLabelOrColumnAliasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterInsertLabelOrColumnAliases(s)
	}
}

func (s *InsertLabelOrColumnAliasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitInsertLabelOrColumnAliases(s)
	}
}

func (s *InsertLabelOrColumnAliasesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitInsertLabelOrColumnAliases(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) InsertLabelOrColumnAliases() (localctx IInsertLabelOrColumnAliasesContext) {
	localctx = NewInsertLabelOrColumnAliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, DorisSQLParserRULE_insertLabelOrColumnAliases)
	p.SetState(3383)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserT__1, DorisSQLParserBY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3379)
			p.ColumnAliasesOrByName()
		}

	case DorisSQLParserWITH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3380)
			p.Match(DorisSQLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3381)
			p.Match(DorisSQLParserLABEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3382)

			var _x = p.Identifier()

			localctx.(*InsertLabelOrColumnAliasesContext).label = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnAliasesOrByNameContext is an interface to support dynamic dispatch.
type IColumnAliasesOrByNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnAliases() IColumnAliasesContext
	BY() antlr.TerminalNode
	NAME() antlr.TerminalNode

	// IsColumnAliasesOrByNameContext differentiates from other interfaces.
	IsColumnAliasesOrByNameContext()
}

type ColumnAliasesOrByNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnAliasesOrByNameContext() *ColumnAliasesOrByNameContext {
	var p = new(ColumnAliasesOrByNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_columnAliasesOrByName
	return p
}

func InitEmptyColumnAliasesOrByNameContext(p *ColumnAliasesOrByNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_columnAliasesOrByName
}

func (*ColumnAliasesOrByNameContext) IsColumnAliasesOrByNameContext() {}

func NewColumnAliasesOrByNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnAliasesOrByNameContext {
	var p = new(ColumnAliasesOrByNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_columnAliasesOrByName

	return p
}

func (s *ColumnAliasesOrByNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnAliasesOrByNameContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *ColumnAliasesOrByNameContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *ColumnAliasesOrByNameContext) NAME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNAME, 0)
}

func (s *ColumnAliasesOrByNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnAliasesOrByNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnAliasesOrByNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterColumnAliasesOrByName(s)
	}
}

func (s *ColumnAliasesOrByNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitColumnAliasesOrByName(s)
	}
}

func (s *ColumnAliasesOrByNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitColumnAliasesOrByName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ColumnAliasesOrByName() (localctx IColumnAliasesOrByNameContext) {
	localctx = NewColumnAliasesOrByNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, DorisSQLParserRULE_columnAliasesOrByName)
	p.SetState(3388)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserT__1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3385)
			p.ColumnAliases()
		}

	case DorisSQLParserBY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3386)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3387)
			p.Match(DorisSQLParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateStatementContext is an interface to support dynamic dispatch.
type IUpdateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	UPDATE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	SET() antlr.TerminalNode
	AssignmentList() IAssignmentListContext
	FromClause() IFromClauseContext
	ExplainDesc() IExplainDescContext
	WithClause() IWithClauseContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsUpdateStatementContext differentiates from other interfaces.
	IsUpdateStatementContext()
}

type UpdateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IExpressionContext
}

func NewEmptyUpdateStatementContext() *UpdateStatementContext {
	var p = new(UpdateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_updateStatement
	return p
}

func InitEmptyUpdateStatementContext(p *UpdateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_updateStatement
}

func (*UpdateStatementContext) IsUpdateStatementContext() {}

func NewUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateStatementContext {
	var p = new(UpdateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_updateStatement

	return p
}

func (s *UpdateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateStatementContext) GetWhere() IExpressionContext { return s.where }

func (s *UpdateStatementContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *UpdateStatementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUPDATE, 0)
}

func (s *UpdateStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *UpdateStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *UpdateStatementContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *UpdateStatementContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *UpdateStatementContext) ExplainDesc() IExplainDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainDescContext)
}

func (s *UpdateStatementContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *UpdateStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *UpdateStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UpdateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitUpdateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) UpdateStatement() (localctx IUpdateStatementContext) {
	localctx = NewUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, DorisSQLParserRULE_updateStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3391)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-125)) & ^0x3f) == 0 && ((int64(1)<<(_la-125))&16777219) != 0 {
		{
			p.SetState(3390)
			p.ExplainDesc()
		}

	}
	p.SetState(3394)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWITH {
		{
			p.SetState(3393)
			p.WithClause()
		}

	}
	{
		p.SetState(3396)
		p.Match(DorisSQLParserUPDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3397)
		p.QualifiedName()
	}
	{
		p.SetState(3398)
		p.Match(DorisSQLParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3399)
		p.AssignmentList()
	}
	{
		p.SetState(3400)
		p.FromClause()
	}
	p.SetState(3403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWHERE {
		{
			p.SetState(3401)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3402)

			var _x = p.expression(0)

			localctx.(*UpdateStatementContext).where = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteStatementContext is an interface to support dynamic dispatch.
type IDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUsing returns the using rule contexts.
	GetUsing() IRelationsContext

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetUsing sets the using rule contexts.
	SetUsing(IRelationsContext)

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	DELETE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	ExplainDesc() IExplainDescContext
	WithClause() IWithClauseContext
	PartitionNames() IPartitionNamesContext
	USING() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Relations() IRelationsContext
	Expression() IExpressionContext

	// IsDeleteStatementContext differentiates from other interfaces.
	IsDeleteStatementContext()
}

type DeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	using  IRelationsContext
	where  IExpressionContext
}

func NewEmptyDeleteStatementContext() *DeleteStatementContext {
	var p = new(DeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_deleteStatement
	return p
}

func InitEmptyDeleteStatementContext(p *DeleteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_deleteStatement
}

func (*DeleteStatementContext) IsDeleteStatementContext() {}

func NewDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteStatementContext {
	var p = new(DeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_deleteStatement

	return p
}

func (s *DeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteStatementContext) GetUsing() IRelationsContext { return s.using }

func (s *DeleteStatementContext) GetWhere() IExpressionContext { return s.where }

func (s *DeleteStatementContext) SetUsing(v IRelationsContext) { s.using = v }

func (s *DeleteStatementContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *DeleteStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDELETE, 0)
}

func (s *DeleteStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *DeleteStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DeleteStatementContext) ExplainDesc() IExplainDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainDescContext)
}

func (s *DeleteStatementContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *DeleteStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *DeleteStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSING, 0)
}

func (s *DeleteStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *DeleteStatementContext) Relations() IRelationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationsContext)
}

func (s *DeleteStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDeleteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DeleteStatement() (localctx IDeleteStatementContext) {
	localctx = NewDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, DorisSQLParserRULE_deleteStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3406)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-125)) & ^0x3f) == 0 && ((int64(1)<<(_la-125))&16777219) != 0 {
		{
			p.SetState(3405)
			p.ExplainDesc()
		}

	}
	p.SetState(3409)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWITH {
		{
			p.SetState(3408)
			p.WithClause()
		}

	}
	{
		p.SetState(3411)
		p.Match(DorisSQLParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3412)
		p.Match(DorisSQLParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3413)
		p.QualifiedName()
	}
	p.SetState(3415)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPARTITION || _la == DorisSQLParserPARTITIONS || _la == DorisSQLParserTEMPORARY {
		{
			p.SetState(3414)
			p.PartitionNames()
		}

	}
	p.SetState(3419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserUSING {
		{
			p.SetState(3417)
			p.Match(DorisSQLParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3418)

			var _x = p.Relations()

			localctx.(*DeleteStatementContext).using = _x
		}

	}
	p.SetState(3423)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWHERE {
		{
			p.SetState(3421)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3422)

			var _x = p.expression(0)

			localctx.(*DeleteStatementContext).where = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateRoutineLoadStatementContext is an interface to support dynamic dispatch.
type ICreateRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// GetSource returns the source rule contexts.
	GetSource() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// SetSource sets the source rule contexts.
	SetSource(IIdentifierContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	ON() antlr.TerminalNode
	FROM() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	AllLoadProperties() []ILoadPropertiesContext
	LoadProperties(i int) ILoadPropertiesContext
	JobProperties() IJobPropertiesContext
	DataSourceProperties() IDataSourcePropertiesContext

	// IsCreateRoutineLoadStatementContext differentiates from other interfaces.
	IsCreateRoutineLoadStatementContext()
}

type CreateRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
	table  IQualifiedNameContext
	source IIdentifierContext
}

func NewEmptyCreateRoutineLoadStatementContext() *CreateRoutineLoadStatementContext {
	var p = new(CreateRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createRoutineLoadStatement
	return p
}

func InitEmptyCreateRoutineLoadStatementContext(p *CreateRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createRoutineLoadStatement
}

func (*CreateRoutineLoadStatementContext) IsCreateRoutineLoadStatementContext() {}

func NewCreateRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRoutineLoadStatementContext {
	var p = new(CreateRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createRoutineLoadStatement

	return p
}

func (s *CreateRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *CreateRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *CreateRoutineLoadStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *CreateRoutineLoadStatementContext) GetSource() IIdentifierContext { return s.source }

func (s *CreateRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *CreateRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateRoutineLoadStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *CreateRoutineLoadStatementContext) SetSource(v IIdentifierContext) { s.source = v }

func (s *CreateRoutineLoadStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROUTINE, 0)
}

func (s *CreateRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOAD, 0)
}

func (s *CreateRoutineLoadStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *CreateRoutineLoadStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *CreateRoutineLoadStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateRoutineLoadStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRoutineLoadStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *CreateRoutineLoadStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateRoutineLoadStatementContext) AllLoadProperties() []ILoadPropertiesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILoadPropertiesContext); ok {
			len++
		}
	}

	tst := make([]ILoadPropertiesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILoadPropertiesContext); ok {
			tst[i] = t.(ILoadPropertiesContext)
			i++
		}
	}

	return tst
}

func (s *CreateRoutineLoadStatementContext) LoadProperties(i int) ILoadPropertiesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadPropertiesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadPropertiesContext)
}

func (s *CreateRoutineLoadStatementContext) JobProperties() IJobPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJobPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJobPropertiesContext)
}

func (s *CreateRoutineLoadStatementContext) DataSourceProperties() IDataSourcePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataSourcePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataSourcePropertiesContext)
}

func (s *CreateRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateRoutineLoadStatement(s)
	}
}

func (s *CreateRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateRoutineLoadStatement(s)
	}
}

func (s *CreateRoutineLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateRoutineLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateRoutineLoadStatement() (localctx ICreateRoutineLoadStatementContext) {
	localctx = NewCreateRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, DorisSQLParserRULE_createRoutineLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3425)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3426)
		p.Match(DorisSQLParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3427)
		p.Match(DorisSQLParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3431)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 308, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3428)

			var _x = p.QualifiedName()

			localctx.(*CreateRoutineLoadStatementContext).db = _x
		}
		{
			p.SetState(3429)
			p.Match(DorisSQLParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3433)

		var _x = p.Identifier()

		localctx.(*CreateRoutineLoadStatementContext).name = _x
	}
	{
		p.SetState(3434)
		p.Match(DorisSQLParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3435)

		var _x = p.QualifiedName()

		localctx.(*CreateRoutineLoadStatementContext).table = _x
	}
	p.SetState(3444)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserCOLUMNS || _la == DorisSQLParserPARTITION || _la == DorisSQLParserPARTITIONS || _la == DorisSQLParserROWS || _la == DorisSQLParserTEMPORARY || _la == DorisSQLParserWHERE {
		{
			p.SetState(3436)
			p.LoadProperties()
		}
		p.SetState(3441)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(3437)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3438)
				p.LoadProperties()
			}

			p.SetState(3443)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(3446)
			p.JobProperties()
		}

	}
	{
		p.SetState(3449)
		p.Match(DorisSQLParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3450)

		var _x = p.Identifier()

		localctx.(*CreateRoutineLoadStatementContext).source = _x
	}
	p.SetState(3452)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserT__1 {
		{
			p.SetState(3451)
			p.DataSourceProperties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterRoutineLoadStatementContext is an interface to support dynamic dispatch.
type IAlterRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	AllLoadProperties() []ILoadPropertiesContext
	LoadProperties(i int) ILoadPropertiesContext
	JobProperties() IJobPropertiesContext
	DataSource() IDataSourceContext
	QualifiedName() IQualifiedNameContext

	// IsAlterRoutineLoadStatementContext differentiates from other interfaces.
	IsAlterRoutineLoadStatementContext()
}

type AlterRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyAlterRoutineLoadStatementContext() *AlterRoutineLoadStatementContext {
	var p = new(AlterRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterRoutineLoadStatement
	return p
}

func InitEmptyAlterRoutineLoadStatementContext(p *AlterRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterRoutineLoadStatement
}

func (*AlterRoutineLoadStatementContext) IsAlterRoutineLoadStatementContext() {}

func NewAlterRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterRoutineLoadStatementContext {
	var p = new(AlterRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_alterRoutineLoadStatement

	return p
}

func (s *AlterRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *AlterRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *AlterRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *AlterRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterRoutineLoadStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *AlterRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROUTINE, 0)
}

func (s *AlterRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOAD, 0)
}

func (s *AlterRoutineLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFOR, 0)
}

func (s *AlterRoutineLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterRoutineLoadStatementContext) AllLoadProperties() []ILoadPropertiesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILoadPropertiesContext); ok {
			len++
		}
	}

	tst := make([]ILoadPropertiesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILoadPropertiesContext); ok {
			tst[i] = t.(ILoadPropertiesContext)
			i++
		}
	}

	return tst
}

func (s *AlterRoutineLoadStatementContext) LoadProperties(i int) ILoadPropertiesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadPropertiesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadPropertiesContext)
}

func (s *AlterRoutineLoadStatementContext) JobProperties() IJobPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJobPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJobPropertiesContext)
}

func (s *AlterRoutineLoadStatementContext) DataSource() IDataSourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataSourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataSourceContext)
}

func (s *AlterRoutineLoadStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAlterRoutineLoadStatement(s)
	}
}

func (s *AlterRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAlterRoutineLoadStatement(s)
	}
}

func (s *AlterRoutineLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAlterRoutineLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AlterRoutineLoadStatement() (localctx IAlterRoutineLoadStatementContext) {
	localctx = NewAlterRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, DorisSQLParserRULE_alterRoutineLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3454)
		p.Match(DorisSQLParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3455)
		p.Match(DorisSQLParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3456)
		p.Match(DorisSQLParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3457)
		p.Match(DorisSQLParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3461)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 313, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3458)

			var _x = p.QualifiedName()

			localctx.(*AlterRoutineLoadStatementContext).db = _x
		}
		{
			p.SetState(3459)
			p.Match(DorisSQLParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3463)

		var _x = p.Identifier()

		localctx.(*AlterRoutineLoadStatementContext).name = _x
	}
	p.SetState(3472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserCOLUMNS || _la == DorisSQLParserPARTITION || _la == DorisSQLParserPARTITIONS || _la == DorisSQLParserROWS || _la == DorisSQLParserTEMPORARY || _la == DorisSQLParserWHERE {
		{
			p.SetState(3464)
			p.LoadProperties()
		}
		p.SetState(3469)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(3465)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3466)
				p.LoadProperties()
			}

			p.SetState(3471)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3475)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(3474)
			p.JobProperties()
		}

	}
	p.SetState(3478)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM {
		{
			p.SetState(3477)
			p.DataSource()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataSourceContext is an interface to support dynamic dispatch.
type IDataSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSource returns the source rule contexts.
	GetSource() IIdentifierContext

	// SetSource sets the source rule contexts.
	SetSource(IIdentifierContext)

	// Getter signatures
	FROM() antlr.TerminalNode
	DataSourceProperties() IDataSourcePropertiesContext
	Identifier() IIdentifierContext

	// IsDataSourceContext differentiates from other interfaces.
	IsDataSourceContext()
}

type DataSourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	source IIdentifierContext
}

func NewEmptyDataSourceContext() *DataSourceContext {
	var p = new(DataSourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dataSource
	return p
}

func InitEmptyDataSourceContext(p *DataSourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dataSource
}

func (*DataSourceContext) IsDataSourceContext() {}

func NewDataSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataSourceContext {
	var p = new(DataSourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dataSource

	return p
}

func (s *DataSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *DataSourceContext) GetSource() IIdentifierContext { return s.source }

func (s *DataSourceContext) SetSource(v IIdentifierContext) { s.source = v }

func (s *DataSourceContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *DataSourceContext) DataSourceProperties() IDataSourcePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataSourcePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataSourcePropertiesContext)
}

func (s *DataSourceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DataSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDataSource(s)
	}
}

func (s *DataSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDataSource(s)
	}
}

func (s *DataSourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDataSource(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DataSource() (localctx IDataSourceContext) {
	localctx = NewDataSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, DorisSQLParserRULE_dataSource)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3480)
		p.Match(DorisSQLParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3481)

		var _x = p.Identifier()

		localctx.(*DataSourceContext).source = _x
	}
	{
		p.SetState(3482)
		p.DataSourceProperties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoadPropertiesContext is an interface to support dynamic dispatch.
type ILoadPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColSeparatorProperty() IColSeparatorPropertyContext
	RowDelimiterProperty() IRowDelimiterPropertyContext
	ImportColumns() IImportColumnsContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	PartitionNames() IPartitionNamesContext

	// IsLoadPropertiesContext differentiates from other interfaces.
	IsLoadPropertiesContext()
}

type LoadPropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoadPropertiesContext() *LoadPropertiesContext {
	var p = new(LoadPropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_loadProperties
	return p
}

func InitEmptyLoadPropertiesContext(p *LoadPropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_loadProperties
}

func (*LoadPropertiesContext) IsLoadPropertiesContext() {}

func NewLoadPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadPropertiesContext {
	var p = new(LoadPropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_loadProperties

	return p
}

func (s *LoadPropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadPropertiesContext) ColSeparatorProperty() IColSeparatorPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColSeparatorPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColSeparatorPropertyContext)
}

func (s *LoadPropertiesContext) RowDelimiterProperty() IRowDelimiterPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowDelimiterPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowDelimiterPropertyContext)
}

func (s *LoadPropertiesContext) ImportColumns() IImportColumnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportColumnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportColumnsContext)
}

func (s *LoadPropertiesContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *LoadPropertiesContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LoadPropertiesContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *LoadPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadPropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterLoadProperties(s)
	}
}

func (s *LoadPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitLoadProperties(s)
	}
}

func (s *LoadPropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitLoadProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) LoadProperties() (localctx ILoadPropertiesContext) {
	localctx = NewLoadPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, DorisSQLParserRULE_loadProperties)
	p.SetState(3490)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 318, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3484)
			p.ColSeparatorProperty()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3485)
			p.RowDelimiterProperty()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3486)
			p.ImportColumns()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3487)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3488)
			p.expression(0)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3489)
			p.PartitionNames()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColSeparatorPropertyContext is an interface to support dynamic dispatch.
type IColSeparatorPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLUMNS() antlr.TerminalNode
	TERMINATED() antlr.TerminalNode
	BY() antlr.TerminalNode
	String_() IStringContext

	// IsColSeparatorPropertyContext differentiates from other interfaces.
	IsColSeparatorPropertyContext()
}

type ColSeparatorPropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColSeparatorPropertyContext() *ColSeparatorPropertyContext {
	var p = new(ColSeparatorPropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_colSeparatorProperty
	return p
}

func InitEmptyColSeparatorPropertyContext(p *ColSeparatorPropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_colSeparatorProperty
}

func (*ColSeparatorPropertyContext) IsColSeparatorPropertyContext() {}

func NewColSeparatorPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColSeparatorPropertyContext {
	var p = new(ColSeparatorPropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_colSeparatorProperty

	return p
}

func (s *ColSeparatorPropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *ColSeparatorPropertyContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLUMNS, 0)
}

func (s *ColSeparatorPropertyContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTERMINATED, 0)
}

func (s *ColSeparatorPropertyContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *ColSeparatorPropertyContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ColSeparatorPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColSeparatorPropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColSeparatorPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterColSeparatorProperty(s)
	}
}

func (s *ColSeparatorPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitColSeparatorProperty(s)
	}
}

func (s *ColSeparatorPropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitColSeparatorProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ColSeparatorProperty() (localctx IColSeparatorPropertyContext) {
	localctx = NewColSeparatorPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, DorisSQLParserRULE_colSeparatorProperty)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3492)
		p.Match(DorisSQLParserCOLUMNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3493)
		p.Match(DorisSQLParserTERMINATED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3494)
		p.Match(DorisSQLParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3495)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowDelimiterPropertyContext is an interface to support dynamic dispatch.
type IRowDelimiterPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROWS() antlr.TerminalNode
	TERMINATED() antlr.TerminalNode
	BY() antlr.TerminalNode
	String_() IStringContext

	// IsRowDelimiterPropertyContext differentiates from other interfaces.
	IsRowDelimiterPropertyContext()
}

type RowDelimiterPropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowDelimiterPropertyContext() *RowDelimiterPropertyContext {
	var p = new(RowDelimiterPropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_rowDelimiterProperty
	return p
}

func InitEmptyRowDelimiterPropertyContext(p *RowDelimiterPropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_rowDelimiterProperty
}

func (*RowDelimiterPropertyContext) IsRowDelimiterPropertyContext() {}

func NewRowDelimiterPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowDelimiterPropertyContext {
	var p = new(RowDelimiterPropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_rowDelimiterProperty

	return p
}

func (s *RowDelimiterPropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *RowDelimiterPropertyContext) ROWS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROWS, 0)
}

func (s *RowDelimiterPropertyContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTERMINATED, 0)
}

func (s *RowDelimiterPropertyContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *RowDelimiterPropertyContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *RowDelimiterPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowDelimiterPropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowDelimiterPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRowDelimiterProperty(s)
	}
}

func (s *RowDelimiterPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRowDelimiterProperty(s)
	}
}

func (s *RowDelimiterPropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRowDelimiterProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) RowDelimiterProperty() (localctx IRowDelimiterPropertyContext) {
	localctx = NewRowDelimiterPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, DorisSQLParserRULE_rowDelimiterProperty)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3497)
		p.Match(DorisSQLParserROWS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3498)
		p.Match(DorisSQLParserTERMINATED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3499)
		p.Match(DorisSQLParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3500)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportColumnsContext is an interface to support dynamic dispatch.
type IImportColumnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLUMNS() antlr.TerminalNode
	ColumnProperties() IColumnPropertiesContext

	// IsImportColumnsContext differentiates from other interfaces.
	IsImportColumnsContext()
}

type ImportColumnsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportColumnsContext() *ImportColumnsContext {
	var p = new(ImportColumnsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_importColumns
	return p
}

func InitEmptyImportColumnsContext(p *ImportColumnsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_importColumns
}

func (*ImportColumnsContext) IsImportColumnsContext() {}

func NewImportColumnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportColumnsContext {
	var p = new(ImportColumnsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_importColumns

	return p
}

func (s *ImportColumnsContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLUMNS, 0)
}

func (s *ImportColumnsContext) ColumnProperties() IColumnPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnPropertiesContext)
}

func (s *ImportColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportColumnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterImportColumns(s)
	}
}

func (s *ImportColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitImportColumns(s)
	}
}

func (s *ImportColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitImportColumns(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ImportColumns() (localctx IImportColumnsContext) {
	localctx = NewImportColumnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, DorisSQLParserRULE_importColumns)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3502)
		p.Match(DorisSQLParserCOLUMNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3503)
		p.ColumnProperties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnPropertiesContext is an interface to support dynamic dispatch.
type IColumnPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	AllAssignment() []IAssignmentContext
	Assignment(i int) IAssignmentContext

	// IsColumnPropertiesContext differentiates from other interfaces.
	IsColumnPropertiesContext()
}

type ColumnPropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnPropertiesContext() *ColumnPropertiesContext {
	var p = new(ColumnPropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_columnProperties
	return p
}

func InitEmptyColumnPropertiesContext(p *ColumnPropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_columnProperties
}

func (*ColumnPropertiesContext) IsColumnPropertiesContext() {}

func NewColumnPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnPropertiesContext {
	var p = new(ColumnPropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_columnProperties

	return p
}

func (s *ColumnPropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnPropertiesContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *ColumnPropertiesContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ColumnPropertiesContext) AllAssignment() []IAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentContext); ok {
			tst[i] = t.(IAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *ColumnPropertiesContext) Assignment(i int) IAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *ColumnPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnPropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterColumnProperties(s)
	}
}

func (s *ColumnPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitColumnProperties(s)
	}
}

func (s *ColumnPropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitColumnProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ColumnProperties() (localctx IColumnPropertiesContext) {
	localctx = NewColumnPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, DorisSQLParserRULE_columnProperties)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3505)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3508)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 319, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3506)
			p.QualifiedName()
		}

	case 2:
		{
			p.SetState(3507)
			p.Assignment()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(3517)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(3510)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3513)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 320, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3511)
				p.QualifiedName()
			}

		case 2:
			{
				p.SetState(3512)
				p.Assignment()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(3519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3520)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJobPropertiesContext is an interface to support dynamic dispatch.
type IJobPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Properties() IPropertiesContext

	// IsJobPropertiesContext differentiates from other interfaces.
	IsJobPropertiesContext()
}

type JobPropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJobPropertiesContext() *JobPropertiesContext {
	var p = new(JobPropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_jobProperties
	return p
}

func InitEmptyJobPropertiesContext(p *JobPropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_jobProperties
}

func (*JobPropertiesContext) IsJobPropertiesContext() {}

func NewJobPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JobPropertiesContext {
	var p = new(JobPropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_jobProperties

	return p
}

func (s *JobPropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *JobPropertiesContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *JobPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JobPropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JobPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterJobProperties(s)
	}
}

func (s *JobPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitJobProperties(s)
	}
}

func (s *JobPropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitJobProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) JobProperties() (localctx IJobPropertiesContext) {
	localctx = NewJobPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, DorisSQLParserRULE_jobProperties)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3522)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataSourcePropertiesContext is an interface to support dynamic dispatch.
type IDataSourcePropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PropertyList() IPropertyListContext

	// IsDataSourcePropertiesContext differentiates from other interfaces.
	IsDataSourcePropertiesContext()
}

type DataSourcePropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataSourcePropertiesContext() *DataSourcePropertiesContext {
	var p = new(DataSourcePropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dataSourceProperties
	return p
}

func InitEmptyDataSourcePropertiesContext(p *DataSourcePropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dataSourceProperties
}

func (*DataSourcePropertiesContext) IsDataSourcePropertiesContext() {}

func NewDataSourcePropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataSourcePropertiesContext {
	var p = new(DataSourcePropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dataSourceProperties

	return p
}

func (s *DataSourcePropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *DataSourcePropertiesContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *DataSourcePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataSourcePropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataSourcePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDataSourceProperties(s)
	}
}

func (s *DataSourcePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDataSourceProperties(s)
	}
}

func (s *DataSourcePropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDataSourceProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DataSourceProperties() (localctx IDataSourcePropertiesContext) {
	localctx = NewDataSourcePropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, DorisSQLParserRULE_dataSourceProperties)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3524)
		p.PropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStopRoutineLoadStatementContext is an interface to support dynamic dispatch.
type IStopRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	STOP() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	QualifiedName() IQualifiedNameContext

	// IsStopRoutineLoadStatementContext differentiates from other interfaces.
	IsStopRoutineLoadStatementContext()
}

type StopRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyStopRoutineLoadStatementContext() *StopRoutineLoadStatementContext {
	var p = new(StopRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_stopRoutineLoadStatement
	return p
}

func InitEmptyStopRoutineLoadStatementContext(p *StopRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_stopRoutineLoadStatement
}

func (*StopRoutineLoadStatementContext) IsStopRoutineLoadStatementContext() {}

func NewStopRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StopRoutineLoadStatementContext {
	var p = new(StopRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_stopRoutineLoadStatement

	return p
}

func (s *StopRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StopRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *StopRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *StopRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *StopRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *StopRoutineLoadStatementContext) STOP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTOP, 0)
}

func (s *StopRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROUTINE, 0)
}

func (s *StopRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOAD, 0)
}

func (s *StopRoutineLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFOR, 0)
}

func (s *StopRoutineLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StopRoutineLoadStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *StopRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StopRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StopRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterStopRoutineLoadStatement(s)
	}
}

func (s *StopRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitStopRoutineLoadStatement(s)
	}
}

func (s *StopRoutineLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitStopRoutineLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) StopRoutineLoadStatement() (localctx IStopRoutineLoadStatementContext) {
	localctx = NewStopRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, DorisSQLParserRULE_stopRoutineLoadStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3526)
		p.Match(DorisSQLParserSTOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3527)
		p.Match(DorisSQLParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3528)
		p.Match(DorisSQLParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3529)
		p.Match(DorisSQLParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3533)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 322, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3530)

			var _x = p.QualifiedName()

			localctx.(*StopRoutineLoadStatementContext).db = _x
		}
		{
			p.SetState(3531)
			p.Match(DorisSQLParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3535)

		var _x = p.Identifier()

		localctx.(*StopRoutineLoadStatementContext).name = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResumeRoutineLoadStatementContext is an interface to support dynamic dispatch.
type IResumeRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	RESUME() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	QualifiedName() IQualifiedNameContext

	// IsResumeRoutineLoadStatementContext differentiates from other interfaces.
	IsResumeRoutineLoadStatementContext()
}

type ResumeRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyResumeRoutineLoadStatementContext() *ResumeRoutineLoadStatementContext {
	var p = new(ResumeRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_resumeRoutineLoadStatement
	return p
}

func InitEmptyResumeRoutineLoadStatementContext(p *ResumeRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_resumeRoutineLoadStatement
}

func (*ResumeRoutineLoadStatementContext) IsResumeRoutineLoadStatementContext() {}

func NewResumeRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResumeRoutineLoadStatementContext {
	var p = new(ResumeRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_resumeRoutineLoadStatement

	return p
}

func (s *ResumeRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ResumeRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ResumeRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *ResumeRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ResumeRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ResumeRoutineLoadStatementContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRESUME, 0)
}

func (s *ResumeRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROUTINE, 0)
}

func (s *ResumeRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOAD, 0)
}

func (s *ResumeRoutineLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFOR, 0)
}

func (s *ResumeRoutineLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ResumeRoutineLoadStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ResumeRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumeRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResumeRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterResumeRoutineLoadStatement(s)
	}
}

func (s *ResumeRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitResumeRoutineLoadStatement(s)
	}
}

func (s *ResumeRoutineLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitResumeRoutineLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ResumeRoutineLoadStatement() (localctx IResumeRoutineLoadStatementContext) {
	localctx = NewResumeRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, DorisSQLParserRULE_resumeRoutineLoadStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3537)
		p.Match(DorisSQLParserRESUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3538)
		p.Match(DorisSQLParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3539)
		p.Match(DorisSQLParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3540)
		p.Match(DorisSQLParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3544)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 323, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3541)

			var _x = p.QualifiedName()

			localctx.(*ResumeRoutineLoadStatementContext).db = _x
		}
		{
			p.SetState(3542)
			p.Match(DorisSQLParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3546)

		var _x = p.Identifier()

		localctx.(*ResumeRoutineLoadStatementContext).name = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPauseRoutineLoadStatementContext is an interface to support dynamic dispatch.
type IPauseRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	PAUSE() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	QualifiedName() IQualifiedNameContext

	// IsPauseRoutineLoadStatementContext differentiates from other interfaces.
	IsPauseRoutineLoadStatementContext()
}

type PauseRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyPauseRoutineLoadStatementContext() *PauseRoutineLoadStatementContext {
	var p = new(PauseRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_pauseRoutineLoadStatement
	return p
}

func InitEmptyPauseRoutineLoadStatementContext(p *PauseRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_pauseRoutineLoadStatement
}

func (*PauseRoutineLoadStatementContext) IsPauseRoutineLoadStatementContext() {}

func NewPauseRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PauseRoutineLoadStatementContext {
	var p = new(PauseRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_pauseRoutineLoadStatement

	return p
}

func (s *PauseRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PauseRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *PauseRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *PauseRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *PauseRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *PauseRoutineLoadStatementContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPAUSE, 0)
}

func (s *PauseRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROUTINE, 0)
}

func (s *PauseRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOAD, 0)
}

func (s *PauseRoutineLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFOR, 0)
}

func (s *PauseRoutineLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PauseRoutineLoadStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *PauseRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PauseRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PauseRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPauseRoutineLoadStatement(s)
	}
}

func (s *PauseRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPauseRoutineLoadStatement(s)
	}
}

func (s *PauseRoutineLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPauseRoutineLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PauseRoutineLoadStatement() (localctx IPauseRoutineLoadStatementContext) {
	localctx = NewPauseRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, DorisSQLParserRULE_pauseRoutineLoadStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3548)
		p.Match(DorisSQLParserPAUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3549)
		p.Match(DorisSQLParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3550)
		p.Match(DorisSQLParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3551)
		p.Match(DorisSQLParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3555)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 324, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3552)

			var _x = p.QualifiedName()

			localctx.(*PauseRoutineLoadStatementContext).db = _x
		}
		{
			p.SetState(3553)
			p.Match(DorisSQLParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3557)

		var _x = p.Identifier()

		localctx.(*PauseRoutineLoadStatementContext).name = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowRoutineLoadStatementContext is an interface to support dynamic dispatch.
type IShowRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	ALL() antlr.TerminalNode
	FOR() antlr.TerminalNode
	FROM() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext
	Identifier() IIdentifierContext
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext

	// IsShowRoutineLoadStatementContext differentiates from other interfaces.
	IsShowRoutineLoadStatementContext()
}

type ShowRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyShowRoutineLoadStatementContext() *ShowRoutineLoadStatementContext {
	var p = new(ShowRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showRoutineLoadStatement
	return p
}

func InitEmptyShowRoutineLoadStatementContext(p *ShowRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showRoutineLoadStatement
}

func (*ShowRoutineLoadStatementContext) IsShowRoutineLoadStatementContext() {}

func NewShowRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRoutineLoadStatementContext {
	var p = new(ShowRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showRoutineLoadStatement

	return p
}

func (s *ShowRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *ShowRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ShowRoutineLoadStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROUTINE, 0)
}

func (s *ShowRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOAD, 0)
}

func (s *ShowRoutineLoadStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, 0)
}

func (s *ShowRoutineLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFOR, 0)
}

func (s *ShowRoutineLoadStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowRoutineLoadStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowRoutineLoadStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowRoutineLoadStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserORDER, 0)
}

func (s *ShowRoutineLoadStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *ShowRoutineLoadStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowRoutineLoadStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowRoutineLoadStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowRoutineLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowRoutineLoadStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *ShowRoutineLoadStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowRoutineLoadStatement(s)
	}
}

func (s *ShowRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowRoutineLoadStatement(s)
	}
}

func (s *ShowRoutineLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowRoutineLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowRoutineLoadStatement() (localctx IShowRoutineLoadStatementContext) {
	localctx = NewShowRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, DorisSQLParserRULE_showRoutineLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3559)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3561)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserALL {
		{
			p.SetState(3560)
			p.Match(DorisSQLParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3563)
		p.Match(DorisSQLParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3564)
		p.Match(DorisSQLParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3572)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFOR {
		{
			p.SetState(3565)
			p.Match(DorisSQLParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3569)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 326, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3566)

				var _x = p.QualifiedName()

				localctx.(*ShowRoutineLoadStatementContext).db = _x
			}
			{
				p.SetState(3567)
				p.Match(DorisSQLParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3571)

			var _x = p.Identifier()

			localctx.(*ShowRoutineLoadStatementContext).name = _x
		}

	}
	p.SetState(3576)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM {
		{
			p.SetState(3574)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3575)

			var _x = p.QualifiedName()

			localctx.(*ShowRoutineLoadStatementContext).db = _x
		}

	}
	p.SetState(3580)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWHERE {
		{
			p.SetState(3578)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3579)
			p.expression(0)
		}

	}
	p.SetState(3592)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserORDER {
		{
			p.SetState(3582)
			p.Match(DorisSQLParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3583)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3584)
			p.SortItem()
		}
		p.SetState(3589)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(3585)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3586)
				p.SortItem()
			}

			p.SetState(3591)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3595)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserLIMIT {
		{
			p.SetState(3594)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowRoutineLoadTaskStatementContext is an interface to support dynamic dispatch.
type IShowRoutineLoadTaskStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	TASK() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowRoutineLoadTaskStatementContext differentiates from other interfaces.
	IsShowRoutineLoadTaskStatementContext()
}

type ShowRoutineLoadTaskStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
}

func NewEmptyShowRoutineLoadTaskStatementContext() *ShowRoutineLoadTaskStatementContext {
	var p = new(ShowRoutineLoadTaskStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showRoutineLoadTaskStatement
	return p
}

func InitEmptyShowRoutineLoadTaskStatementContext(p *ShowRoutineLoadTaskStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showRoutineLoadTaskStatement
}

func (*ShowRoutineLoadTaskStatementContext) IsShowRoutineLoadTaskStatementContext() {}

func NewShowRoutineLoadTaskStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRoutineLoadTaskStatementContext {
	var p = new(ShowRoutineLoadTaskStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showRoutineLoadTaskStatement

	return p
}

func (s *ShowRoutineLoadTaskStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRoutineLoadTaskStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowRoutineLoadTaskStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowRoutineLoadTaskStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowRoutineLoadTaskStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROUTINE, 0)
}

func (s *ShowRoutineLoadTaskStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOAD, 0)
}

func (s *ShowRoutineLoadTaskStatementContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTASK, 0)
}

func (s *ShowRoutineLoadTaskStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowRoutineLoadTaskStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowRoutineLoadTaskStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowRoutineLoadTaskStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowRoutineLoadTaskStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRoutineLoadTaskStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRoutineLoadTaskStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowRoutineLoadTaskStatement(s)
	}
}

func (s *ShowRoutineLoadTaskStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowRoutineLoadTaskStatement(s)
	}
}

func (s *ShowRoutineLoadTaskStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowRoutineLoadTaskStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowRoutineLoadTaskStatement() (localctx IShowRoutineLoadTaskStatementContext) {
	localctx = NewShowRoutineLoadTaskStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, DorisSQLParserRULE_showRoutineLoadTaskStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3597)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3598)
		p.Match(DorisSQLParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3599)
		p.Match(DorisSQLParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3600)
		p.Match(DorisSQLParserTASK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3603)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM {
		{
			p.SetState(3601)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3602)

			var _x = p.QualifiedName()

			localctx.(*ShowRoutineLoadTaskStatementContext).db = _x
		}

	}
	{
		p.SetState(3605)
		p.Match(DorisSQLParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3606)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCreateRoutineLoadStatementContext is an interface to support dynamic dispatch.
type IShowCreateRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	Identifier() IIdentifierContext
	QualifiedName() IQualifiedNameContext

	// IsShowCreateRoutineLoadStatementContext differentiates from other interfaces.
	IsShowCreateRoutineLoadStatementContext()
}

type ShowCreateRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyShowCreateRoutineLoadStatementContext() *ShowCreateRoutineLoadStatementContext {
	var p = new(ShowCreateRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showCreateRoutineLoadStatement
	return p
}

func InitEmptyShowCreateRoutineLoadStatementContext(p *ShowCreateRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showCreateRoutineLoadStatement
}

func (*ShowCreateRoutineLoadStatementContext) IsShowCreateRoutineLoadStatementContext() {}

func NewShowCreateRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCreateRoutineLoadStatementContext {
	var p = new(ShowCreateRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showCreateRoutineLoadStatement

	return p
}

func (s *ShowCreateRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCreateRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowCreateRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *ShowCreateRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowCreateRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ShowCreateRoutineLoadStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowCreateRoutineLoadStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *ShowCreateRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROUTINE, 0)
}

func (s *ShowCreateRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOAD, 0)
}

func (s *ShowCreateRoutineLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateRoutineLoadStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCreateRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCreateRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowCreateRoutineLoadStatement(s)
	}
}

func (s *ShowCreateRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowCreateRoutineLoadStatement(s)
	}
}

func (s *ShowCreateRoutineLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowCreateRoutineLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowCreateRoutineLoadStatement() (localctx IShowCreateRoutineLoadStatementContext) {
	localctx = NewShowCreateRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, DorisSQLParserRULE_showCreateRoutineLoadStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3608)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3609)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3610)
		p.Match(DorisSQLParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3611)
		p.Match(DorisSQLParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3615)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 334, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3612)

			var _x = p.QualifiedName()

			localctx.(*ShowCreateRoutineLoadStatementContext).db = _x
		}
		{
			p.SetState(3613)
			p.Match(DorisSQLParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3617)

		var _x = p.Identifier()

		localctx.(*ShowCreateRoutineLoadStatementContext).name = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowStreamLoadStatementContext is an interface to support dynamic dispatch.
type IShowStreamLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	STREAM() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	ALL() antlr.TerminalNode
	FOR() antlr.TerminalNode
	FROM() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext
	Identifier() IIdentifierContext
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext

	// IsShowStreamLoadStatementContext differentiates from other interfaces.
	IsShowStreamLoadStatementContext()
}

type ShowStreamLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyShowStreamLoadStatementContext() *ShowStreamLoadStatementContext {
	var p = new(ShowStreamLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showStreamLoadStatement
	return p
}

func InitEmptyShowStreamLoadStatementContext(p *ShowStreamLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showStreamLoadStatement
}

func (*ShowStreamLoadStatementContext) IsShowStreamLoadStatementContext() {}

func NewShowStreamLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStreamLoadStatementContext {
	var p = new(ShowStreamLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showStreamLoadStatement

	return p
}

func (s *ShowStreamLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStreamLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowStreamLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *ShowStreamLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowStreamLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ShowStreamLoadStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowStreamLoadStatementContext) STREAM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTREAM, 0)
}

func (s *ShowStreamLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOAD, 0)
}

func (s *ShowStreamLoadStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, 0)
}

func (s *ShowStreamLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFOR, 0)
}

func (s *ShowStreamLoadStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowStreamLoadStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowStreamLoadStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowStreamLoadStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserORDER, 0)
}

func (s *ShowStreamLoadStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *ShowStreamLoadStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowStreamLoadStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowStreamLoadStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowStreamLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowStreamLoadStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *ShowStreamLoadStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowStreamLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStreamLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowStreamLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowStreamLoadStatement(s)
	}
}

func (s *ShowStreamLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowStreamLoadStatement(s)
	}
}

func (s *ShowStreamLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowStreamLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowStreamLoadStatement() (localctx IShowStreamLoadStatementContext) {
	localctx = NewShowStreamLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, DorisSQLParserRULE_showStreamLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3619)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3621)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserALL {
		{
			p.SetState(3620)
			p.Match(DorisSQLParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3623)
		p.Match(DorisSQLParserSTREAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3624)
		p.Match(DorisSQLParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFOR {
		{
			p.SetState(3625)
			p.Match(DorisSQLParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3629)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 336, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3626)

				var _x = p.QualifiedName()

				localctx.(*ShowStreamLoadStatementContext).db = _x
			}
			{
				p.SetState(3627)
				p.Match(DorisSQLParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3631)

			var _x = p.Identifier()

			localctx.(*ShowStreamLoadStatementContext).name = _x
		}

	}
	p.SetState(3636)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM {
		{
			p.SetState(3634)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3635)

			var _x = p.QualifiedName()

			localctx.(*ShowStreamLoadStatementContext).db = _x
		}

	}
	p.SetState(3640)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWHERE {
		{
			p.SetState(3638)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3639)
			p.expression(0)
		}

	}
	p.SetState(3652)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserORDER {
		{
			p.SetState(3642)
			p.Match(DorisSQLParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3643)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3644)
			p.SortItem()
		}
		p.SetState(3649)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(3645)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3646)
				p.SortItem()
			}

			p.SetState(3651)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3655)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserLIMIT {
		{
			p.SetState(3654)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyzeStatementContext is an interface to support dynamic dispatch.
type IAnalyzeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANALYZE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	AnalyzeColumnClause() IAnalyzeColumnClauseContext
	PartitionNames() IPartitionNamesContext
	WITH() antlr.TerminalNode
	MODE() antlr.TerminalNode
	Properties() IPropertiesContext
	FULL() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	ASYNC() antlr.TerminalNode

	// IsAnalyzeStatementContext differentiates from other interfaces.
	IsAnalyzeStatementContext()
}

type AnalyzeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalyzeStatementContext() *AnalyzeStatementContext {
	var p = new(AnalyzeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_analyzeStatement
	return p
}

func InitEmptyAnalyzeStatementContext(p *AnalyzeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_analyzeStatement
}

func (*AnalyzeStatementContext) IsAnalyzeStatementContext() {}

func NewAnalyzeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzeStatementContext {
	var p = new(AnalyzeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_analyzeStatement

	return p
}

func (s *AnalyzeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzeStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserANALYZE, 0)
}

func (s *AnalyzeStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *AnalyzeStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AnalyzeStatementContext) AnalyzeColumnClause() IAnalyzeColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeColumnClauseContext)
}

func (s *AnalyzeStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *AnalyzeStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *AnalyzeStatementContext) MODE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMODE, 0)
}

func (s *AnalyzeStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AnalyzeStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFULL, 0)
}

func (s *AnalyzeStatementContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSAMPLE, 0)
}

func (s *AnalyzeStatementContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSYNC, 0)
}

func (s *AnalyzeStatementContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserASYNC, 0)
}

func (s *AnalyzeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnalyzeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAnalyzeStatement(s)
	}
}

func (s *AnalyzeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAnalyzeStatement(s)
	}
}

func (s *AnalyzeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAnalyzeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AnalyzeStatement() (localctx IAnalyzeStatementContext) {
	localctx = NewAnalyzeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, DorisSQLParserRULE_analyzeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3657)
		p.Match(DorisSQLParserANALYZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3659)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFULL || _la == DorisSQLParserSAMPLE {
		{
			p.SetState(3658)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserFULL || _la == DorisSQLParserSAMPLE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3661)
		p.Match(DorisSQLParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3662)
		p.TableName()
	}
	p.SetState(3664)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 344, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3663)
			p.AnalyzeColumnClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3667)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPARTITION || _la == DorisSQLParserPARTITIONS || _la == DorisSQLParserTEMPORARY {
		{
			p.SetState(3666)
			p.PartitionNames()
		}

	}
	p.SetState(3672)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWITH {
		{
			p.SetState(3669)
			p.Match(DorisSQLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3670)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserASYNC || _la == DorisSQLParserSYNC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3671)
			p.Match(DorisSQLParserMODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(3674)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyzeColumnClauseContext is an interface to support dynamic dispatch.
type IAnalyzeColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAnalyzeColumnClauseContext differentiates from other interfaces.
	IsAnalyzeColumnClauseContext()
}

type AnalyzeColumnClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalyzeColumnClauseContext() *AnalyzeColumnClauseContext {
	var p = new(AnalyzeColumnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_analyzeColumnClause
	return p
}

func InitEmptyAnalyzeColumnClauseContext(p *AnalyzeColumnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_analyzeColumnClause
}

func (*AnalyzeColumnClauseContext) IsAnalyzeColumnClauseContext() {}

func NewAnalyzeColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzeColumnClauseContext {
	var p = new(AnalyzeColumnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_analyzeColumnClause

	return p
}

func (s *AnalyzeColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzeColumnClauseContext) CopyAll(ctx *AnalyzeColumnClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AnalyzeColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PredicateColumnsContext struct {
	AnalyzeColumnClauseContext
}

func NewPredicateColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicateColumnsContext {
	var p = new(PredicateColumnsContext)

	InitEmptyAnalyzeColumnClauseContext(&p.AnalyzeColumnClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AnalyzeColumnClauseContext))

	return p
}

func (s *PredicateColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateColumnsContext) PREDICATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPREDICATE, 0)
}

func (s *PredicateColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLUMNS, 0)
}

func (s *PredicateColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPredicateColumns(s)
	}
}

func (s *PredicateColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPredicateColumns(s)
	}
}

func (s *PredicateColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPredicateColumns(s)

	default:
		return t.VisitChildren(s)
	}
}

type RegularColumnsContext struct {
	AnalyzeColumnClauseContext
}

func NewRegularColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegularColumnsContext {
	var p = new(RegularColumnsContext)

	InitEmptyAnalyzeColumnClauseContext(&p.AnalyzeColumnClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AnalyzeColumnClauseContext))

	return p
}

func (s *RegularColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegularColumnsContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *RegularColumnsContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RegularColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRegularColumns(s)
	}
}

func (s *RegularColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRegularColumns(s)
	}
}

func (s *RegularColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRegularColumns(s)

	default:
		return t.VisitChildren(s)
	}
}

type AllColumnsContext struct {
	AnalyzeColumnClauseContext
}

func NewAllColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AllColumnsContext {
	var p = new(AllColumnsContext)

	InitEmptyAnalyzeColumnClauseContext(&p.AnalyzeColumnClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AnalyzeColumnClauseContext))

	return p
}

func (s *AllColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AllColumnsContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, 0)
}

func (s *AllColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLUMNS, 0)
}

func (s *AllColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAllColumns(s)
	}
}

func (s *AllColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAllColumns(s)
	}
}

func (s *AllColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAllColumns(s)

	default:
		return t.VisitChildren(s)
	}
}

type MultiColumnSetContext struct {
	AnalyzeColumnClauseContext
}

func NewMultiColumnSetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultiColumnSetContext {
	var p = new(MultiColumnSetContext)

	InitEmptyAnalyzeColumnClauseContext(&p.AnalyzeColumnClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AnalyzeColumnClauseContext))

	return p
}

func (s *MultiColumnSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiColumnSetContext) MULTIPLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMULTIPLE, 0)
}

func (s *MultiColumnSetContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLUMNS, 0)
}

func (s *MultiColumnSetContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *MultiColumnSetContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *MultiColumnSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterMultiColumnSet(s)
	}
}

func (s *MultiColumnSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitMultiColumnSet(s)
	}
}

func (s *MultiColumnSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitMultiColumnSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AnalyzeColumnClause() (localctx IAnalyzeColumnClauseContext) {
	localctx = NewAnalyzeColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, DorisSQLParserRULE_analyzeColumnClause)
	var _la int

	p.SetState(3713)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 351, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRegularColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3677)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3678)
			p.QualifiedName()
		}
		p.SetState(3683)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(3679)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3680)
				p.QualifiedName()
			}

			p.SetState(3685)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3686)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewRegularColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3688)
			p.QualifiedName()
		}
		p.SetState(3693)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(3689)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3690)
				p.QualifiedName()
			}

			p.SetState(3695)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		localctx = NewAllColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3696)
			p.Match(DorisSQLParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3697)
			p.Match(DorisSQLParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewPredicateColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3698)
			p.Match(DorisSQLParserPREDICATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3699)
			p.Match(DorisSQLParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewMultiColumnSetContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3700)
			p.Match(DorisSQLParserMULTIPLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3701)
			p.Match(DorisSQLParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3702)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3703)
			p.QualifiedName()
		}
		p.SetState(3708)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(3704)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3705)
				p.QualifiedName()
			}

			p.SetState(3710)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3711)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropStatsStatementContext is an interface to support dynamic dispatch.
type IDropStatsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	STATS() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	MULTIPLE() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode

	// IsDropStatsStatementContext differentiates from other interfaces.
	IsDropStatsStatementContext()
}

type DropStatsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropStatsStatementContext() *DropStatsStatementContext {
	var p = new(DropStatsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropStatsStatement
	return p
}

func InitEmptyDropStatsStatementContext(p *DropStatsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropStatsStatement
}

func (*DropStatsStatementContext) IsDropStatsStatementContext() {}

func NewDropStatsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropStatsStatementContext {
	var p = new(DropStatsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropStatsStatement

	return p
}

func (s *DropStatsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropStatsStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropStatsStatementContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTATS, 0)
}

func (s *DropStatsStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropStatsStatementContext) MULTIPLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMULTIPLE, 0)
}

func (s *DropStatsStatementContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLUMNS, 0)
}

func (s *DropStatsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStatsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropStatsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropStatsStatement(s)
	}
}

func (s *DropStatsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropStatsStatement(s)
	}
}

func (s *DropStatsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropStatsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropStatsStatement() (localctx IDropStatsStatementContext) {
	localctx = NewDropStatsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, DorisSQLParserRULE_dropStatsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3715)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3718)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserMULTIPLE {
		{
			p.SetState(3716)
			p.Match(DorisSQLParserMULTIPLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3717)
			p.Match(DorisSQLParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3720)
		p.Match(DorisSQLParserSTATS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3721)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHistogramStatementContext is an interface to support dynamic dispatch.
type IHistogramStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBucket returns the bucket token.
	GetBucket() antlr.Token

	// SetBucket sets the bucket token.
	SetBucket(antlr.Token)

	// Getter signatures
	ANALYZE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	UPDATE() antlr.TerminalNode
	HISTOGRAM() antlr.TerminalNode
	ON() antlr.TerminalNode
	AnalyzeColumnClause() IAnalyzeColumnClauseContext
	WITH() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	Properties() IPropertiesContext
	INTEGER_VALUE() antlr.TerminalNode

	// IsHistogramStatementContext differentiates from other interfaces.
	IsHistogramStatementContext()
}

type HistogramStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	bucket antlr.Token
}

func NewEmptyHistogramStatementContext() *HistogramStatementContext {
	var p = new(HistogramStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_histogramStatement
	return p
}

func InitEmptyHistogramStatementContext(p *HistogramStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_histogramStatement
}

func (*HistogramStatementContext) IsHistogramStatementContext() {}

func NewHistogramStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HistogramStatementContext {
	var p = new(HistogramStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_histogramStatement

	return p
}

func (s *HistogramStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HistogramStatementContext) GetBucket() antlr.Token { return s.bucket }

func (s *HistogramStatementContext) SetBucket(v antlr.Token) { s.bucket = v }

func (s *HistogramStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserANALYZE, 0)
}

func (s *HistogramStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *HistogramStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *HistogramStatementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUPDATE, 0)
}

func (s *HistogramStatementContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserHISTOGRAM, 0)
}

func (s *HistogramStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *HistogramStatementContext) AnalyzeColumnClause() IAnalyzeColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeColumnClauseContext)
}

func (s *HistogramStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *HistogramStatementContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBUCKETS, 0)
}

func (s *HistogramStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *HistogramStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, 0)
}

func (s *HistogramStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HistogramStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HistogramStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterHistogramStatement(s)
	}
}

func (s *HistogramStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitHistogramStatement(s)
	}
}

func (s *HistogramStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitHistogramStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) HistogramStatement() (localctx IHistogramStatementContext) {
	localctx = NewHistogramStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, DorisSQLParserRULE_histogramStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3723)
		p.Match(DorisSQLParserANALYZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3724)
		p.Match(DorisSQLParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3725)
		p.TableName()
	}
	{
		p.SetState(3726)
		p.Match(DorisSQLParserUPDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3727)
		p.Match(DorisSQLParserHISTOGRAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3728)
		p.Match(DorisSQLParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3729)
		p.AnalyzeColumnClause()
	}
	p.SetState(3733)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 353, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3730)
			p.Match(DorisSQLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3731)

			var _m = p.Match(DorisSQLParserINTEGER_VALUE)

			localctx.(*HistogramStatementContext).bucket = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3732)
			p.Match(DorisSQLParserBUCKETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3736)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(3735)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyzeHistogramStatementContext is an interface to support dynamic dispatch.
type IAnalyzeHistogramStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HistogramStatement() IHistogramStatementContext
	WITH() antlr.TerminalNode
	MODE() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	ASYNC() antlr.TerminalNode

	// IsAnalyzeHistogramStatementContext differentiates from other interfaces.
	IsAnalyzeHistogramStatementContext()
}

type AnalyzeHistogramStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalyzeHistogramStatementContext() *AnalyzeHistogramStatementContext {
	var p = new(AnalyzeHistogramStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_analyzeHistogramStatement
	return p
}

func InitEmptyAnalyzeHistogramStatementContext(p *AnalyzeHistogramStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_analyzeHistogramStatement
}

func (*AnalyzeHistogramStatementContext) IsAnalyzeHistogramStatementContext() {}

func NewAnalyzeHistogramStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzeHistogramStatementContext {
	var p = new(AnalyzeHistogramStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_analyzeHistogramStatement

	return p
}

func (s *AnalyzeHistogramStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzeHistogramStatementContext) HistogramStatement() IHistogramStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHistogramStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHistogramStatementContext)
}

func (s *AnalyzeHistogramStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *AnalyzeHistogramStatementContext) MODE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMODE, 0)
}

func (s *AnalyzeHistogramStatementContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSYNC, 0)
}

func (s *AnalyzeHistogramStatementContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserASYNC, 0)
}

func (s *AnalyzeHistogramStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeHistogramStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnalyzeHistogramStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAnalyzeHistogramStatement(s)
	}
}

func (s *AnalyzeHistogramStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAnalyzeHistogramStatement(s)
	}
}

func (s *AnalyzeHistogramStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAnalyzeHistogramStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AnalyzeHistogramStatement() (localctx IAnalyzeHistogramStatementContext) {
	localctx = NewAnalyzeHistogramStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, DorisSQLParserRULE_analyzeHistogramStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3738)
		p.HistogramStatement()
	}
	p.SetState(3742)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWITH {
		{
			p.SetState(3739)
			p.Match(DorisSQLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3740)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserASYNC || _la == DorisSQLParserSYNC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3741)
			p.Match(DorisSQLParserMODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropHistogramStatementContext is an interface to support dynamic dispatch.
type IDropHistogramStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANALYZE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	DROP() antlr.TerminalNode
	HISTOGRAM() antlr.TerminalNode
	ON() antlr.TerminalNode

	// IsDropHistogramStatementContext differentiates from other interfaces.
	IsDropHistogramStatementContext()
}

type DropHistogramStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropHistogramStatementContext() *DropHistogramStatementContext {
	var p = new(DropHistogramStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropHistogramStatement
	return p
}

func InitEmptyDropHistogramStatementContext(p *DropHistogramStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropHistogramStatement
}

func (*DropHistogramStatementContext) IsDropHistogramStatementContext() {}

func NewDropHistogramStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropHistogramStatementContext {
	var p = new(DropHistogramStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropHistogramStatement

	return p
}

func (s *DropHistogramStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropHistogramStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserANALYZE, 0)
}

func (s *DropHistogramStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *DropHistogramStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *DropHistogramStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropHistogramStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropHistogramStatementContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserHISTOGRAM, 0)
}

func (s *DropHistogramStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *DropHistogramStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropHistogramStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropHistogramStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropHistogramStatement(s)
	}
}

func (s *DropHistogramStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropHistogramStatement(s)
	}
}

func (s *DropHistogramStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropHistogramStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropHistogramStatement() (localctx IDropHistogramStatementContext) {
	localctx = NewDropHistogramStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, DorisSQLParserRULE_dropHistogramStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3744)
		p.Match(DorisSQLParserANALYZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3745)
		p.Match(DorisSQLParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3746)
		p.QualifiedName()
	}
	{
		p.SetState(3747)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3748)
		p.Match(DorisSQLParserHISTOGRAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3749)
		p.Match(DorisSQLParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3750)
		p.QualifiedName()
	}
	p.SetState(3755)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(3751)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3752)
			p.QualifiedName()
		}

		p.SetState(3757)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateAnalyzeStatementContext is an interface to support dynamic dispatch.
type ICreateAnalyzeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IIdentifierContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	Properties() IPropertiesContext
	FULL() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	Identifier() IIdentifierContext
	TABLE() antlr.TerminalNode
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	HistogramStatement() IHistogramStatementContext

	// IsCreateAnalyzeStatementContext differentiates from other interfaces.
	IsCreateAnalyzeStatementContext()
}

type CreateAnalyzeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IIdentifierContext
}

func NewEmptyCreateAnalyzeStatementContext() *CreateAnalyzeStatementContext {
	var p = new(CreateAnalyzeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createAnalyzeStatement
	return p
}

func InitEmptyCreateAnalyzeStatementContext(p *CreateAnalyzeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createAnalyzeStatement
}

func (*CreateAnalyzeStatementContext) IsCreateAnalyzeStatementContext() {}

func NewCreateAnalyzeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateAnalyzeStatementContext {
	var p = new(CreateAnalyzeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createAnalyzeStatement

	return p
}

func (s *CreateAnalyzeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateAnalyzeStatementContext) GetDb() IIdentifierContext { return s.db }

func (s *CreateAnalyzeStatementContext) SetDb(v IIdentifierContext) { s.db = v }

func (s *CreateAnalyzeStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateAnalyzeStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserANALYZE, 0)
}

func (s *CreateAnalyzeStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, 0)
}

func (s *CreateAnalyzeStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateAnalyzeStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFULL, 0)
}

func (s *CreateAnalyzeStatementContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSAMPLE, 0)
}

func (s *CreateAnalyzeStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATABASE, 0)
}

func (s *CreateAnalyzeStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateAnalyzeStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *CreateAnalyzeStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *CreateAnalyzeStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateAnalyzeStatementContext) HistogramStatement() IHistogramStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHistogramStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHistogramStatementContext)
}

func (s *CreateAnalyzeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateAnalyzeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateAnalyzeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateAnalyzeStatement(s)
	}
}

func (s *CreateAnalyzeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateAnalyzeStatement(s)
	}
}

func (s *CreateAnalyzeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateAnalyzeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateAnalyzeStatement() (localctx ICreateAnalyzeStatementContext) {
	localctx = NewCreateAnalyzeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, DorisSQLParserRULE_createAnalyzeStatement)
	var _la int

	p.SetState(3802)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 365, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3758)
			p.Match(DorisSQLParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3759)
			p.Match(DorisSQLParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3761)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserFULL || _la == DorisSQLParserSAMPLE {
			{
				p.SetState(3760)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserFULL || _la == DorisSQLParserSAMPLE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(3763)
			p.Match(DorisSQLParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3765)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserPROPERTIES {
			{
				p.SetState(3764)
				p.Properties()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3767)
			p.Match(DorisSQLParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3768)
			p.Match(DorisSQLParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3770)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserFULL || _la == DorisSQLParserSAMPLE {
			{
				p.SetState(3769)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserFULL || _la == DorisSQLParserSAMPLE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(3772)
			p.Match(DorisSQLParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3773)

			var _x = p.Identifier()

			localctx.(*CreateAnalyzeStatementContext).db = _x
		}
		p.SetState(3775)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserPROPERTIES {
			{
				p.SetState(3774)
				p.Properties()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3777)
			p.Match(DorisSQLParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3778)
			p.Match(DorisSQLParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3780)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserFULL || _la == DorisSQLParserSAMPLE {
			{
				p.SetState(3779)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserFULL || _la == DorisSQLParserSAMPLE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(3782)
			p.Match(DorisSQLParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3783)
			p.QualifiedName()
		}
		p.SetState(3795)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__1 {
			{
				p.SetState(3784)
				p.Match(DorisSQLParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3785)
				p.QualifiedName()
			}
			p.SetState(3790)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(3786)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3787)
					p.QualifiedName()
				}

				p.SetState(3792)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3793)
				p.Match(DorisSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3798)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserPROPERTIES {
			{
				p.SetState(3797)
				p.Properties()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3800)
			p.Match(DorisSQLParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3801)
			p.HistogramStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropAnalyzeJobStatementContext is an interface to support dynamic dispatch.
type IDropAnalyzeJobStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	JOB() antlr.TerminalNode

	// IsDropAnalyzeJobStatementContext differentiates from other interfaces.
	IsDropAnalyzeJobStatementContext()
}

type DropAnalyzeJobStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropAnalyzeJobStatementContext() *DropAnalyzeJobStatementContext {
	var p = new(DropAnalyzeJobStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropAnalyzeJobStatement
	return p
}

func InitEmptyDropAnalyzeJobStatementContext(p *DropAnalyzeJobStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropAnalyzeJobStatement
}

func (*DropAnalyzeJobStatementContext) IsDropAnalyzeJobStatementContext() {}

func NewDropAnalyzeJobStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropAnalyzeJobStatementContext {
	var p = new(DropAnalyzeJobStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropAnalyzeJobStatement

	return p
}

func (s *DropAnalyzeJobStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropAnalyzeJobStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropAnalyzeJobStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserANALYZE, 0)
}

func (s *DropAnalyzeJobStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, 0)
}

func (s *DropAnalyzeJobStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, 0)
}

func (s *DropAnalyzeJobStatementContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserJOB, 0)
}

func (s *DropAnalyzeJobStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropAnalyzeJobStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropAnalyzeJobStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropAnalyzeJobStatement(s)
	}
}

func (s *DropAnalyzeJobStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropAnalyzeJobStatement(s)
	}
}

func (s *DropAnalyzeJobStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropAnalyzeJobStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropAnalyzeJobStatement() (localctx IDropAnalyzeJobStatementContext) {
	localctx = NewDropAnalyzeJobStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, DorisSQLParserRULE_dropAnalyzeJobStatement)
	p.SetState(3811)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 366, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3804)
			p.Match(DorisSQLParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3805)
			p.Match(DorisSQLParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3806)
			p.Match(DorisSQLParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3807)
			p.Match(DorisSQLParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3808)
			p.Match(DorisSQLParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3809)
			p.Match(DorisSQLParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3810)
			p.Match(DorisSQLParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowAnalyzeStatementContext is an interface to support dynamic dispatch.
type IShowAnalyzeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext
	JOB() antlr.TerminalNode
	STATUS() antlr.TerminalNode

	// IsShowAnalyzeStatementContext differentiates from other interfaces.
	IsShowAnalyzeStatementContext()
}

type ShowAnalyzeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowAnalyzeStatementContext() *ShowAnalyzeStatementContext {
	var p = new(ShowAnalyzeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showAnalyzeStatement
	return p
}

func InitEmptyShowAnalyzeStatementContext(p *ShowAnalyzeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showAnalyzeStatement
}

func (*ShowAnalyzeStatementContext) IsShowAnalyzeStatementContext() {}

func NewShowAnalyzeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowAnalyzeStatementContext {
	var p = new(ShowAnalyzeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showAnalyzeStatement

	return p
}

func (s *ShowAnalyzeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowAnalyzeStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowAnalyzeStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserANALYZE, 0)
}

func (s *ShowAnalyzeStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowAnalyzeStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowAnalyzeStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserORDER, 0)
}

func (s *ShowAnalyzeStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *ShowAnalyzeStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowAnalyzeStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowAnalyzeStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowAnalyzeStatementContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserJOB, 0)
}

func (s *ShowAnalyzeStatementContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTATUS, 0)
}

func (s *ShowAnalyzeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAnalyzeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowAnalyzeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowAnalyzeStatement(s)
	}
}

func (s *ShowAnalyzeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowAnalyzeStatement(s)
	}
}

func (s *ShowAnalyzeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowAnalyzeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowAnalyzeStatement() (localctx IShowAnalyzeStatementContext) {
	localctx = NewShowAnalyzeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, DorisSQLParserRULE_showAnalyzeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3813)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3814)
		p.Match(DorisSQLParserANALYZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3816)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserJOB || _la == DorisSQLParserSTATUS {
		{
			p.SetState(3815)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserJOB || _la == DorisSQLParserSTATUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3820)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWHERE {
		{
			p.SetState(3818)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3819)
			p.expression(0)
		}

	}
	p.SetState(3832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserORDER {
		{
			p.SetState(3822)
			p.Match(DorisSQLParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3823)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3824)
			p.SortItem()
		}
		p.SetState(3829)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(3825)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3826)
				p.SortItem()
			}

			p.SetState(3831)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3835)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserLIMIT {
		{
			p.SetState(3834)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowStatsMetaStatementContext is an interface to support dynamic dispatch.
type IShowStatsMetaStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	STATS() antlr.TerminalNode
	META() antlr.TerminalNode
	MULTIPLE() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext

	// IsShowStatsMetaStatementContext differentiates from other interfaces.
	IsShowStatsMetaStatementContext()
}

type ShowStatsMetaStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowStatsMetaStatementContext() *ShowStatsMetaStatementContext {
	var p = new(ShowStatsMetaStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showStatsMetaStatement
	return p
}

func InitEmptyShowStatsMetaStatementContext(p *ShowStatsMetaStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showStatsMetaStatement
}

func (*ShowStatsMetaStatementContext) IsShowStatsMetaStatementContext() {}

func NewShowStatsMetaStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStatsMetaStatementContext {
	var p = new(ShowStatsMetaStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showStatsMetaStatement

	return p
}

func (s *ShowStatsMetaStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStatsMetaStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowStatsMetaStatementContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTATS, 0)
}

func (s *ShowStatsMetaStatementContext) META() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMETA, 0)
}

func (s *ShowStatsMetaStatementContext) MULTIPLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMULTIPLE, 0)
}

func (s *ShowStatsMetaStatementContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLUMNS, 0)
}

func (s *ShowStatsMetaStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowStatsMetaStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowStatsMetaStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserORDER, 0)
}

func (s *ShowStatsMetaStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *ShowStatsMetaStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowStatsMetaStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowStatsMetaStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowStatsMetaStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatsMetaStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowStatsMetaStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowStatsMetaStatement(s)
	}
}

func (s *ShowStatsMetaStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowStatsMetaStatement(s)
	}
}

func (s *ShowStatsMetaStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowStatsMetaStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowStatsMetaStatement() (localctx IShowStatsMetaStatementContext) {
	localctx = NewShowStatsMetaStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, DorisSQLParserRULE_showStatsMetaStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3837)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3840)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserMULTIPLE {
		{
			p.SetState(3838)
			p.Match(DorisSQLParserMULTIPLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3839)
			p.Match(DorisSQLParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3842)
		p.Match(DorisSQLParserSTATS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3843)
		p.Match(DorisSQLParserMETA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWHERE {
		{
			p.SetState(3844)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3845)
			p.expression(0)
		}

	}
	p.SetState(3858)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserORDER {
		{
			p.SetState(3848)
			p.Match(DorisSQLParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3849)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3850)
			p.SortItem()
		}
		p.SetState(3855)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(3851)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3852)
				p.SortItem()
			}

			p.SetState(3857)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3861)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserLIMIT {
		{
			p.SetState(3860)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowHistogramMetaStatementContext is an interface to support dynamic dispatch.
type IShowHistogramMetaStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	HISTOGRAM() antlr.TerminalNode
	META() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext

	// IsShowHistogramMetaStatementContext differentiates from other interfaces.
	IsShowHistogramMetaStatementContext()
}

type ShowHistogramMetaStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowHistogramMetaStatementContext() *ShowHistogramMetaStatementContext {
	var p = new(ShowHistogramMetaStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showHistogramMetaStatement
	return p
}

func InitEmptyShowHistogramMetaStatementContext(p *ShowHistogramMetaStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showHistogramMetaStatement
}

func (*ShowHistogramMetaStatementContext) IsShowHistogramMetaStatementContext() {}

func NewShowHistogramMetaStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowHistogramMetaStatementContext {
	var p = new(ShowHistogramMetaStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showHistogramMetaStatement

	return p
}

func (s *ShowHistogramMetaStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowHistogramMetaStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowHistogramMetaStatementContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserHISTOGRAM, 0)
}

func (s *ShowHistogramMetaStatementContext) META() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMETA, 0)
}

func (s *ShowHistogramMetaStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowHistogramMetaStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowHistogramMetaStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserORDER, 0)
}

func (s *ShowHistogramMetaStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *ShowHistogramMetaStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowHistogramMetaStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowHistogramMetaStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowHistogramMetaStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowHistogramMetaStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowHistogramMetaStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowHistogramMetaStatement(s)
	}
}

func (s *ShowHistogramMetaStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowHistogramMetaStatement(s)
	}
}

func (s *ShowHistogramMetaStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowHistogramMetaStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowHistogramMetaStatement() (localctx IShowHistogramMetaStatementContext) {
	localctx = NewShowHistogramMetaStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, DorisSQLParserRULE_showHistogramMetaStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3863)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3864)
		p.Match(DorisSQLParserHISTOGRAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3865)
		p.Match(DorisSQLParserMETA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3868)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWHERE {
		{
			p.SetState(3866)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3867)
			p.expression(0)
		}

	}
	p.SetState(3880)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserORDER {
		{
			p.SetState(3870)
			p.Match(DorisSQLParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3871)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3872)
			p.SortItem()
		}
		p.SetState(3877)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(3873)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3874)
				p.SortItem()
			}

			p.SetState(3879)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3883)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserLIMIT {
		{
			p.SetState(3882)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKillAnalyzeStatementContext is an interface to support dynamic dispatch.
type IKillAnalyzeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KILL() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsKillAnalyzeStatementContext differentiates from other interfaces.
	IsKillAnalyzeStatementContext()
}

type KillAnalyzeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKillAnalyzeStatementContext() *KillAnalyzeStatementContext {
	var p = new(KillAnalyzeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_killAnalyzeStatement
	return p
}

func InitEmptyKillAnalyzeStatementContext(p *KillAnalyzeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_killAnalyzeStatement
}

func (*KillAnalyzeStatementContext) IsKillAnalyzeStatementContext() {}

func NewKillAnalyzeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KillAnalyzeStatementContext {
	var p = new(KillAnalyzeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_killAnalyzeStatement

	return p
}

func (s *KillAnalyzeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *KillAnalyzeStatementContext) KILL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserKILL, 0)
}

func (s *KillAnalyzeStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserANALYZE, 0)
}

func (s *KillAnalyzeStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, 0)
}

func (s *KillAnalyzeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillAnalyzeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KillAnalyzeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterKillAnalyzeStatement(s)
	}
}

func (s *KillAnalyzeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitKillAnalyzeStatement(s)
	}
}

func (s *KillAnalyzeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitKillAnalyzeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) KillAnalyzeStatement() (localctx IKillAnalyzeStatementContext) {
	localctx = NewKillAnalyzeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, DorisSQLParserRULE_killAnalyzeStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3885)
		p.Match(DorisSQLParserKILL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3886)
		p.Match(DorisSQLParserANALYZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3887)
		p.Match(DorisSQLParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyzeProfileStatementContext is an interface to support dynamic dispatch.
type IAnalyzeProfileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANALYZE() antlr.TerminalNode
	PROFILE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	String_() IStringContext
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsAnalyzeProfileStatementContext differentiates from other interfaces.
	IsAnalyzeProfileStatementContext()
}

type AnalyzeProfileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalyzeProfileStatementContext() *AnalyzeProfileStatementContext {
	var p = new(AnalyzeProfileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_analyzeProfileStatement
	return p
}

func InitEmptyAnalyzeProfileStatementContext(p *AnalyzeProfileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_analyzeProfileStatement
}

func (*AnalyzeProfileStatementContext) IsAnalyzeProfileStatementContext() {}

func NewAnalyzeProfileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzeProfileStatementContext {
	var p = new(AnalyzeProfileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_analyzeProfileStatement

	return p
}

func (s *AnalyzeProfileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzeProfileStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserANALYZE, 0)
}

func (s *AnalyzeProfileStatementContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROFILE, 0)
}

func (s *AnalyzeProfileStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *AnalyzeProfileStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AnalyzeProfileStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserINTEGER_VALUE)
}

func (s *AnalyzeProfileStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, i)
}

func (s *AnalyzeProfileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeProfileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnalyzeProfileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAnalyzeProfileStatement(s)
	}
}

func (s *AnalyzeProfileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAnalyzeProfileStatement(s)
	}
}

func (s *AnalyzeProfileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAnalyzeProfileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AnalyzeProfileStatement() (localctx IAnalyzeProfileStatementContext) {
	localctx = NewAnalyzeProfileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, DorisSQLParserRULE_analyzeProfileStatement)
	var _la int

	p.SetState(3906)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 382, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3889)
			p.Match(DorisSQLParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3890)
			p.Match(DorisSQLParserPROFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3891)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3892)
			p.String_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3893)
			p.Match(DorisSQLParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3894)
			p.Match(DorisSQLParserPROFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3895)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3896)
			p.String_()
		}
		{
			p.SetState(3897)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3898)
			p.Match(DorisSQLParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3903)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(3899)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3900)
				p.Match(DorisSQLParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(3905)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateBaselinePlanStatementContext is an interface to support dynamic dispatch.
type ICreateBaselinePlanStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	BASELINE() antlr.TerminalNode
	USING() antlr.TerminalNode
	AllQueryRelation() []IQueryRelationContext
	QueryRelation(i int) IQueryRelationContext
	GLOBAL() antlr.TerminalNode
	ON() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsCreateBaselinePlanStatementContext differentiates from other interfaces.
	IsCreateBaselinePlanStatementContext()
}

type CreateBaselinePlanStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateBaselinePlanStatementContext() *CreateBaselinePlanStatementContext {
	var p = new(CreateBaselinePlanStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createBaselinePlanStatement
	return p
}

func InitEmptyCreateBaselinePlanStatementContext(p *CreateBaselinePlanStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createBaselinePlanStatement
}

func (*CreateBaselinePlanStatementContext) IsCreateBaselinePlanStatementContext() {}

func NewCreateBaselinePlanStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateBaselinePlanStatementContext {
	var p = new(CreateBaselinePlanStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createBaselinePlanStatement

	return p
}

func (s *CreateBaselinePlanStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateBaselinePlanStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateBaselinePlanStatementContext) BASELINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBASELINE, 0)
}

func (s *CreateBaselinePlanStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSING, 0)
}

func (s *CreateBaselinePlanStatementContext) AllQueryRelation() []IQueryRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQueryRelationContext); ok {
			len++
		}
	}

	tst := make([]IQueryRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQueryRelationContext); ok {
			tst[i] = t.(IQueryRelationContext)
			i++
		}
	}

	return tst
}

func (s *CreateBaselinePlanStatementContext) QueryRelation(i int) IQueryRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *CreateBaselinePlanStatementContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGLOBAL, 0)
}

func (s *CreateBaselinePlanStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *CreateBaselinePlanStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateBaselinePlanStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateBaselinePlanStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateBaselinePlanStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateBaselinePlanStatement(s)
	}
}

func (s *CreateBaselinePlanStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateBaselinePlanStatement(s)
	}
}

func (s *CreateBaselinePlanStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateBaselinePlanStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateBaselinePlanStatement() (localctx ICreateBaselinePlanStatementContext) {
	localctx = NewCreateBaselinePlanStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, DorisSQLParserRULE_createBaselinePlanStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3908)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3910)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserGLOBAL {
		{
			p.SetState(3909)
			p.Match(DorisSQLParserGLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3912)
		p.Match(DorisSQLParserBASELINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3915)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserON {
		{
			p.SetState(3913)
			p.Match(DorisSQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3914)
			p.QueryRelation()
		}

	}
	{
		p.SetState(3917)
		p.Match(DorisSQLParserUSING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3918)
		p.QueryRelation()
	}
	p.SetState(3920)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(3919)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropBaselinePlanStatementContext is an interface to support dynamic dispatch.
type IDropBaselinePlanStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	BASELINE() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsDropBaselinePlanStatementContext differentiates from other interfaces.
	IsDropBaselinePlanStatementContext()
}

type DropBaselinePlanStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropBaselinePlanStatementContext() *DropBaselinePlanStatementContext {
	var p = new(DropBaselinePlanStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropBaselinePlanStatement
	return p
}

func InitEmptyDropBaselinePlanStatementContext(p *DropBaselinePlanStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropBaselinePlanStatement
}

func (*DropBaselinePlanStatementContext) IsDropBaselinePlanStatementContext() {}

func NewDropBaselinePlanStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropBaselinePlanStatementContext {
	var p = new(DropBaselinePlanStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropBaselinePlanStatement

	return p
}

func (s *DropBaselinePlanStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropBaselinePlanStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropBaselinePlanStatementContext) BASELINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBASELINE, 0)
}

func (s *DropBaselinePlanStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserINTEGER_VALUE)
}

func (s *DropBaselinePlanStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, i)
}

func (s *DropBaselinePlanStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropBaselinePlanStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropBaselinePlanStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropBaselinePlanStatement(s)
	}
}

func (s *DropBaselinePlanStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropBaselinePlanStatement(s)
	}
}

func (s *DropBaselinePlanStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropBaselinePlanStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropBaselinePlanStatement() (localctx IDropBaselinePlanStatementContext) {
	localctx = NewDropBaselinePlanStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, DorisSQLParserRULE_dropBaselinePlanStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3922)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3923)
		p.Match(DorisSQLParserBASELINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3924)
		p.Match(DorisSQLParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3929)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(3925)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3926)
			p.Match(DorisSQLParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(3931)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowBaselinePlanStatementContext is an interface to support dynamic dispatch.
type IShowBaselinePlanStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	BASELINE() antlr.TerminalNode

	// IsShowBaselinePlanStatementContext differentiates from other interfaces.
	IsShowBaselinePlanStatementContext()
}

type ShowBaselinePlanStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowBaselinePlanStatementContext() *ShowBaselinePlanStatementContext {
	var p = new(ShowBaselinePlanStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showBaselinePlanStatement
	return p
}

func InitEmptyShowBaselinePlanStatementContext(p *ShowBaselinePlanStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showBaselinePlanStatement
}

func (*ShowBaselinePlanStatementContext) IsShowBaselinePlanStatementContext() {}

func NewShowBaselinePlanStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowBaselinePlanStatementContext {
	var p = new(ShowBaselinePlanStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showBaselinePlanStatement

	return p
}

func (s *ShowBaselinePlanStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowBaselinePlanStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowBaselinePlanStatementContext) BASELINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBASELINE, 0)
}

func (s *ShowBaselinePlanStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBaselinePlanStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowBaselinePlanStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowBaselinePlanStatement(s)
	}
}

func (s *ShowBaselinePlanStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowBaselinePlanStatement(s)
	}
}

func (s *ShowBaselinePlanStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowBaselinePlanStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowBaselinePlanStatement() (localctx IShowBaselinePlanStatementContext) {
	localctx = NewShowBaselinePlanStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, DorisSQLParserRULE_showBaselinePlanStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3932)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3933)
		p.Match(DorisSQLParserBASELINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateResourceGroupStatementContext is an interface to support dynamic dispatch.
type ICreateResourceGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Identifier() IIdentifierContext
	WITH() antlr.TerminalNode
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	TO() antlr.TerminalNode
	AllClassifier() []IClassifierContext
	Classifier(i int) IClassifierContext

	// IsCreateResourceGroupStatementContext differentiates from other interfaces.
	IsCreateResourceGroupStatementContext()
}

type CreateResourceGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateResourceGroupStatementContext() *CreateResourceGroupStatementContext {
	var p = new(CreateResourceGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createResourceGroupStatement
	return p
}

func InitEmptyCreateResourceGroupStatementContext(p *CreateResourceGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createResourceGroupStatement
}

func (*CreateResourceGroupStatementContext) IsCreateResourceGroupStatementContext() {}

func NewCreateResourceGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateResourceGroupStatementContext {
	var p = new(CreateResourceGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createResourceGroupStatement

	return p
}

func (s *CreateResourceGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateResourceGroupStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateResourceGroupStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRESOURCE, 0)
}

func (s *CreateResourceGroupStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGROUP, 0)
}

func (s *CreateResourceGroupStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateResourceGroupStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *CreateResourceGroupStatementContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *CreateResourceGroupStatementContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *CreateResourceGroupStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *CreateResourceGroupStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *CreateResourceGroupStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *CreateResourceGroupStatementContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOR, 0)
}

func (s *CreateResourceGroupStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPLACE, 0)
}

func (s *CreateResourceGroupStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTO, 0)
}

func (s *CreateResourceGroupStatementContext) AllClassifier() []IClassifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassifierContext); ok {
			len++
		}
	}

	tst := make([]IClassifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassifierContext); ok {
			tst[i] = t.(IClassifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateResourceGroupStatementContext) Classifier(i int) IClassifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassifierContext)
}

func (s *CreateResourceGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateResourceGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateResourceGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateResourceGroupStatement(s)
	}
}

func (s *CreateResourceGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateResourceGroupStatement(s)
	}
}

func (s *CreateResourceGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateResourceGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateResourceGroupStatement() (localctx ICreateResourceGroupStatementContext) {
	localctx = NewCreateResourceGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, DorisSQLParserRULE_createResourceGroupStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3935)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3936)
		p.Match(DorisSQLParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3937)
		p.Match(DorisSQLParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3941)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(3938)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3939)
			p.Match(DorisSQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3940)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3945)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserOR {
		{
			p.SetState(3943)
			p.Match(DorisSQLParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3944)
			p.Match(DorisSQLParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3947)
		p.Identifier()
	}
	p.SetState(3957)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserTO {
		{
			p.SetState(3948)
			p.Match(DorisSQLParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3949)
			p.Classifier()
		}
		p.SetState(3954)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(3950)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3951)
				p.Classifier()
			}

			p.SetState(3956)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3959)
		p.Match(DorisSQLParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3960)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3961)
		p.Property()
	}
	p.SetState(3966)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(3962)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3963)
			p.Property()
		}

		p.SetState(3968)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3969)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropResourceGroupStatementContext is an interface to support dynamic dispatch.
type IDropResourceGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDropResourceGroupStatementContext differentiates from other interfaces.
	IsDropResourceGroupStatementContext()
}

type DropResourceGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropResourceGroupStatementContext() *DropResourceGroupStatementContext {
	var p = new(DropResourceGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropResourceGroupStatement
	return p
}

func InitEmptyDropResourceGroupStatementContext(p *DropResourceGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropResourceGroupStatement
}

func (*DropResourceGroupStatementContext) IsDropResourceGroupStatementContext() {}

func NewDropResourceGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropResourceGroupStatementContext {
	var p = new(DropResourceGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropResourceGroupStatement

	return p
}

func (s *DropResourceGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropResourceGroupStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropResourceGroupStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRESOURCE, 0)
}

func (s *DropResourceGroupStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGROUP, 0)
}

func (s *DropResourceGroupStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropResourceGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropResourceGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropResourceGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropResourceGroupStatement(s)
	}
}

func (s *DropResourceGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropResourceGroupStatement(s)
	}
}

func (s *DropResourceGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropResourceGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropResourceGroupStatement() (localctx IDropResourceGroupStatementContext) {
	localctx = NewDropResourceGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, DorisSQLParserRULE_dropResourceGroupStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3971)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3972)
		p.Match(DorisSQLParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3973)
		p.Match(DorisSQLParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3974)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterResourceGroupStatementContext is an interface to support dynamic dispatch.
type IAlterResourceGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Identifier() IIdentifierContext
	ADD() antlr.TerminalNode
	AllClassifier() []IClassifierContext
	Classifier(i int) IClassifierContext
	DROP() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	ALL() antlr.TerminalNode
	WITH() antlr.TerminalNode
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext

	// IsAlterResourceGroupStatementContext differentiates from other interfaces.
	IsAlterResourceGroupStatementContext()
}

type AlterResourceGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterResourceGroupStatementContext() *AlterResourceGroupStatementContext {
	var p = new(AlterResourceGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterResourceGroupStatement
	return p
}

func InitEmptyAlterResourceGroupStatementContext(p *AlterResourceGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterResourceGroupStatement
}

func (*AlterResourceGroupStatementContext) IsAlterResourceGroupStatementContext() {}

func NewAlterResourceGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterResourceGroupStatementContext {
	var p = new(AlterResourceGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_alterResourceGroupStatement

	return p
}

func (s *AlterResourceGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterResourceGroupStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *AlterResourceGroupStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRESOURCE, 0)
}

func (s *AlterResourceGroupStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGROUP, 0)
}

func (s *AlterResourceGroupStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterResourceGroupStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADD, 0)
}

func (s *AlterResourceGroupStatementContext) AllClassifier() []IClassifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassifierContext); ok {
			len++
		}
	}

	tst := make([]IClassifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassifierContext); ok {
			tst[i] = t.(IClassifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterResourceGroupStatementContext) Classifier(i int) IClassifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassifierContext)
}

func (s *AlterResourceGroupStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *AlterResourceGroupStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserINTEGER_VALUE)
}

func (s *AlterResourceGroupStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, i)
}

func (s *AlterResourceGroupStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, 0)
}

func (s *AlterResourceGroupStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *AlterResourceGroupStatementContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *AlterResourceGroupStatementContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *AlterResourceGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterResourceGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterResourceGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAlterResourceGroupStatement(s)
	}
}

func (s *AlterResourceGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAlterResourceGroupStatement(s)
	}
}

func (s *AlterResourceGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAlterResourceGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AlterResourceGroupStatement() (localctx IAlterResourceGroupStatementContext) {
	localctx = NewAlterResourceGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, DorisSQLParserRULE_alterResourceGroupStatement)
	var _la int

	p.SetState(4028)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 395, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3976)
			p.Match(DorisSQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3977)
			p.Match(DorisSQLParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3978)
			p.Match(DorisSQLParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3979)
			p.Identifier()
		}
		{
			p.SetState(3980)
			p.Match(DorisSQLParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3981)
			p.Classifier()
		}
		p.SetState(3986)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(3982)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3983)
				p.Classifier()
			}

			p.SetState(3988)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3989)
			p.Match(DorisSQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3990)
			p.Match(DorisSQLParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3991)
			p.Match(DorisSQLParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3992)
			p.Identifier()
		}
		{
			p.SetState(3993)
			p.Match(DorisSQLParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3994)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3995)
			p.Match(DorisSQLParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4000)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(3996)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3997)
				p.Match(DorisSQLParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(4002)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4003)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4005)
			p.Match(DorisSQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4006)
			p.Match(DorisSQLParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4007)
			p.Match(DorisSQLParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4008)
			p.Identifier()
		}
		{
			p.SetState(4009)
			p.Match(DorisSQLParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4010)
			p.Match(DorisSQLParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4012)
			p.Match(DorisSQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4013)
			p.Match(DorisSQLParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4014)
			p.Match(DorisSQLParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4015)
			p.Identifier()
		}
		{
			p.SetState(4016)
			p.Match(DorisSQLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4017)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4018)
			p.Property()
		}
		p.SetState(4023)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(4019)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4020)
				p.Property()
			}

			p.SetState(4025)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4026)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowResourceGroupStatementContext is an interface to support dynamic dispatch.
type IShowResourceGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Identifier() IIdentifierContext
	VERBOSE() antlr.TerminalNode
	GROUPS() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsShowResourceGroupStatementContext differentiates from other interfaces.
	IsShowResourceGroupStatementContext()
}

type ShowResourceGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowResourceGroupStatementContext() *ShowResourceGroupStatementContext {
	var p = new(ShowResourceGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showResourceGroupStatement
	return p
}

func InitEmptyShowResourceGroupStatementContext(p *ShowResourceGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showResourceGroupStatement
}

func (*ShowResourceGroupStatementContext) IsShowResourceGroupStatementContext() {}

func NewShowResourceGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowResourceGroupStatementContext {
	var p = new(ShowResourceGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showResourceGroupStatement

	return p
}

func (s *ShowResourceGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowResourceGroupStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowResourceGroupStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRESOURCE, 0)
}

func (s *ShowResourceGroupStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGROUP, 0)
}

func (s *ShowResourceGroupStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowResourceGroupStatementContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVERBOSE, 0)
}

func (s *ShowResourceGroupStatementContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGROUPS, 0)
}

func (s *ShowResourceGroupStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, 0)
}

func (s *ShowResourceGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowResourceGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowResourceGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowResourceGroupStatement(s)
	}
}

func (s *ShowResourceGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowResourceGroupStatement(s)
	}
}

func (s *ShowResourceGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowResourceGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowResourceGroupStatement() (localctx IShowResourceGroupStatementContext) {
	localctx = NewShowResourceGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, DorisSQLParserRULE_showResourceGroupStatement)
	var _la int

	p.SetState(4046)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 399, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4030)
			p.Match(DorisSQLParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4032)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserVERBOSE {
			{
				p.SetState(4031)
				p.Match(DorisSQLParserVERBOSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4034)
			p.Match(DorisSQLParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4035)
			p.Match(DorisSQLParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4036)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4037)
			p.Match(DorisSQLParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4039)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserVERBOSE {
			{
				p.SetState(4038)
				p.Match(DorisSQLParserVERBOSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4041)
			p.Match(DorisSQLParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4042)
			p.Match(DorisSQLParserGROUPS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4044)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserALL {
			{
				p.SetState(4043)
				p.Match(DorisSQLParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowResourceGroupUsageStatementContext is an interface to support dynamic dispatch.
type IShowResourceGroupUsageStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	USAGE() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Identifier() IIdentifierContext
	GROUPS() antlr.TerminalNode

	// IsShowResourceGroupUsageStatementContext differentiates from other interfaces.
	IsShowResourceGroupUsageStatementContext()
}

type ShowResourceGroupUsageStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowResourceGroupUsageStatementContext() *ShowResourceGroupUsageStatementContext {
	var p = new(ShowResourceGroupUsageStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showResourceGroupUsageStatement
	return p
}

func InitEmptyShowResourceGroupUsageStatementContext(p *ShowResourceGroupUsageStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showResourceGroupUsageStatement
}

func (*ShowResourceGroupUsageStatementContext) IsShowResourceGroupUsageStatementContext() {}

func NewShowResourceGroupUsageStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowResourceGroupUsageStatementContext {
	var p = new(ShowResourceGroupUsageStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showResourceGroupUsageStatement

	return p
}

func (s *ShowResourceGroupUsageStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowResourceGroupUsageStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowResourceGroupUsageStatementContext) USAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSAGE, 0)
}

func (s *ShowResourceGroupUsageStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRESOURCE, 0)
}

func (s *ShowResourceGroupUsageStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGROUP, 0)
}

func (s *ShowResourceGroupUsageStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowResourceGroupUsageStatementContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGROUPS, 0)
}

func (s *ShowResourceGroupUsageStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowResourceGroupUsageStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowResourceGroupUsageStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowResourceGroupUsageStatement(s)
	}
}

func (s *ShowResourceGroupUsageStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowResourceGroupUsageStatement(s)
	}
}

func (s *ShowResourceGroupUsageStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowResourceGroupUsageStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowResourceGroupUsageStatement() (localctx IShowResourceGroupUsageStatementContext) {
	localctx = NewShowResourceGroupUsageStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, DorisSQLParserRULE_showResourceGroupUsageStatement)
	p.SetState(4057)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 400, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4048)
			p.Match(DorisSQLParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4049)
			p.Match(DorisSQLParserUSAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4050)
			p.Match(DorisSQLParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4051)
			p.Match(DorisSQLParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4052)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4053)
			p.Match(DorisSQLParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4054)
			p.Match(DorisSQLParserUSAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4055)
			p.Match(DorisSQLParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4056)
			p.Match(DorisSQLParserGROUPS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateResourceStatementContext is an interface to support dynamic dispatch.
type ICreateResourceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResourceName returns the resourceName rule contexts.
	GetResourceName() IIdentifierOrStringContext

	// SetResourceName sets the resourceName rule contexts.
	SetResourceName(IIdentifierOrStringContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	EXTERNAL() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsCreateResourceStatementContext differentiates from other interfaces.
	IsCreateResourceStatementContext()
}

type CreateResourceStatementContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	resourceName IIdentifierOrStringContext
}

func NewEmptyCreateResourceStatementContext() *CreateResourceStatementContext {
	var p = new(CreateResourceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createResourceStatement
	return p
}

func InitEmptyCreateResourceStatementContext(p *CreateResourceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createResourceStatement
}

func (*CreateResourceStatementContext) IsCreateResourceStatementContext() {}

func NewCreateResourceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateResourceStatementContext {
	var p = new(CreateResourceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createResourceStatement

	return p
}

func (s *CreateResourceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateResourceStatementContext) GetResourceName() IIdentifierOrStringContext {
	return s.resourceName
}

func (s *CreateResourceStatementContext) SetResourceName(v IIdentifierOrStringContext) {
	s.resourceName = v
}

func (s *CreateResourceStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateResourceStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRESOURCE, 0)
}

func (s *CreateResourceStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CreateResourceStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXTERNAL, 0)
}

func (s *CreateResourceStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateResourceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateResourceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateResourceStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateResourceStatement(s)
	}
}

func (s *CreateResourceStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateResourceStatement(s)
	}
}

func (s *CreateResourceStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateResourceStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateResourceStatement() (localctx ICreateResourceStatementContext) {
	localctx = NewCreateResourceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, DorisSQLParserRULE_createResourceStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4059)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4061)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserEXTERNAL {
		{
			p.SetState(4060)
			p.Match(DorisSQLParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4063)
		p.Match(DorisSQLParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4064)

		var _x = p.IdentifierOrString()

		localctx.(*CreateResourceStatementContext).resourceName = _x
	}
	p.SetState(4066)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(4065)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterResourceStatementContext is an interface to support dynamic dispatch.
type IAlterResourceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResourceName returns the resourceName rule contexts.
	GetResourceName() IIdentifierOrStringContext

	// SetResourceName sets the resourceName rule contexts.
	SetResourceName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	SET() antlr.TerminalNode
	Properties() IPropertiesContext
	IdentifierOrString() IIdentifierOrStringContext

	// IsAlterResourceStatementContext differentiates from other interfaces.
	IsAlterResourceStatementContext()
}

type AlterResourceStatementContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	resourceName IIdentifierOrStringContext
}

func NewEmptyAlterResourceStatementContext() *AlterResourceStatementContext {
	var p = new(AlterResourceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterResourceStatement
	return p
}

func InitEmptyAlterResourceStatementContext(p *AlterResourceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterResourceStatement
}

func (*AlterResourceStatementContext) IsAlterResourceStatementContext() {}

func NewAlterResourceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterResourceStatementContext {
	var p = new(AlterResourceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_alterResourceStatement

	return p
}

func (s *AlterResourceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterResourceStatementContext) GetResourceName() IIdentifierOrStringContext {
	return s.resourceName
}

func (s *AlterResourceStatementContext) SetResourceName(v IIdentifierOrStringContext) {
	s.resourceName = v
}

func (s *AlterResourceStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *AlterResourceStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRESOURCE, 0)
}

func (s *AlterResourceStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *AlterResourceStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AlterResourceStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AlterResourceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterResourceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterResourceStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAlterResourceStatement(s)
	}
}

func (s *AlterResourceStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAlterResourceStatement(s)
	}
}

func (s *AlterResourceStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAlterResourceStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AlterResourceStatement() (localctx IAlterResourceStatementContext) {
	localctx = NewAlterResourceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, DorisSQLParserRULE_alterResourceStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4068)
		p.Match(DorisSQLParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4069)
		p.Match(DorisSQLParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4070)

		var _x = p.IdentifierOrString()

		localctx.(*AlterResourceStatementContext).resourceName = _x
	}
	{
		p.SetState(4071)
		p.Match(DorisSQLParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4072)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropResourceStatementContext is an interface to support dynamic dispatch.
type IDropResourceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResourceName returns the resourceName rule contexts.
	GetResourceName() IIdentifierOrStringContext

	// SetResourceName sets the resourceName rule contexts.
	SetResourceName(IIdentifierOrStringContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsDropResourceStatementContext differentiates from other interfaces.
	IsDropResourceStatementContext()
}

type DropResourceStatementContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	resourceName IIdentifierOrStringContext
}

func NewEmptyDropResourceStatementContext() *DropResourceStatementContext {
	var p = new(DropResourceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropResourceStatement
	return p
}

func InitEmptyDropResourceStatementContext(p *DropResourceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropResourceStatement
}

func (*DropResourceStatementContext) IsDropResourceStatementContext() {}

func NewDropResourceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropResourceStatementContext {
	var p = new(DropResourceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropResourceStatement

	return p
}

func (s *DropResourceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropResourceStatementContext) GetResourceName() IIdentifierOrStringContext {
	return s.resourceName
}

func (s *DropResourceStatementContext) SetResourceName(v IIdentifierOrStringContext) {
	s.resourceName = v
}

func (s *DropResourceStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropResourceStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRESOURCE, 0)
}

func (s *DropResourceStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropResourceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropResourceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropResourceStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropResourceStatement(s)
	}
}

func (s *DropResourceStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropResourceStatement(s)
	}
}

func (s *DropResourceStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropResourceStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropResourceStatement() (localctx IDropResourceStatementContext) {
	localctx = NewDropResourceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, DorisSQLParserRULE_dropResourceStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4074)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4075)
		p.Match(DorisSQLParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4076)

		var _x = p.IdentifierOrString()

		localctx.(*DropResourceStatementContext).resourceName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowResourceStatementContext is an interface to support dynamic dispatch.
type IShowResourceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	RESOURCES() antlr.TerminalNode

	// IsShowResourceStatementContext differentiates from other interfaces.
	IsShowResourceStatementContext()
}

type ShowResourceStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowResourceStatementContext() *ShowResourceStatementContext {
	var p = new(ShowResourceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showResourceStatement
	return p
}

func InitEmptyShowResourceStatementContext(p *ShowResourceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showResourceStatement
}

func (*ShowResourceStatementContext) IsShowResourceStatementContext() {}

func NewShowResourceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowResourceStatementContext {
	var p = new(ShowResourceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showResourceStatement

	return p
}

func (s *ShowResourceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowResourceStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowResourceStatementContext) RESOURCES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRESOURCES, 0)
}

func (s *ShowResourceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowResourceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowResourceStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowResourceStatement(s)
	}
}

func (s *ShowResourceStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowResourceStatement(s)
	}
}

func (s *ShowResourceStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowResourceStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowResourceStatement() (localctx IShowResourceStatementContext) {
	localctx = NewShowResourceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, DorisSQLParserRULE_showResourceStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4078)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4079)
		p.Match(DorisSQLParserRESOURCES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassifierContext is an interface to support dynamic dispatch.
type IClassifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionList() IExpressionListContext

	// IsClassifierContext differentiates from other interfaces.
	IsClassifierContext()
}

type ClassifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassifierContext() *ClassifierContext {
	var p = new(ClassifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_classifier
	return p
}

func InitEmptyClassifierContext(p *ClassifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_classifier
}

func (*ClassifierContext) IsClassifierContext() {}

func NewClassifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassifierContext {
	var p = new(ClassifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_classifier

	return p
}

func (s *ClassifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassifierContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ClassifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterClassifier(s)
	}
}

func (s *ClassifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitClassifier(s)
	}
}

func (s *ClassifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitClassifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Classifier() (localctx IClassifierContext) {
	localctx = NewClassifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, DorisSQLParserRULE_classifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4081)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4082)
		p.ExpressionList()
	}
	{
		p.SetState(4083)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowFunctionsStatementContext is an interface to support dynamic dispatch.
type IShowFunctionsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	FUNCTIONS() antlr.TerminalNode
	FULL() antlr.TerminalNode
	BUILTIN() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowFunctionsStatementContext differentiates from other interfaces.
	IsShowFunctionsStatementContext()
}

type ShowFunctionsStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	db      IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowFunctionsStatementContext() *ShowFunctionsStatementContext {
	var p = new(ShowFunctionsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showFunctionsStatement
	return p
}

func InitEmptyShowFunctionsStatementContext(p *ShowFunctionsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showFunctionsStatement
}

func (*ShowFunctionsStatementContext) IsShowFunctionsStatementContext() {}

func NewShowFunctionsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowFunctionsStatementContext {
	var p = new(ShowFunctionsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showFunctionsStatement

	return p
}

func (s *ShowFunctionsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowFunctionsStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowFunctionsStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowFunctionsStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowFunctionsStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowFunctionsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowFunctionsStatementContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFUNCTIONS, 0)
}

func (s *ShowFunctionsStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFULL, 0)
}

func (s *ShowFunctionsStatementContext) BUILTIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBUILTIN, 0)
}

func (s *ShowFunctionsStatementContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGLOBAL, 0)
}

func (s *ShowFunctionsStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowFunctionsStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *ShowFunctionsStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowFunctionsStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *ShowFunctionsStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowFunctionsStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowFunctionsStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowFunctionsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFunctionsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowFunctionsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowFunctionsStatement(s)
	}
}

func (s *ShowFunctionsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowFunctionsStatement(s)
	}
}

func (s *ShowFunctionsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowFunctionsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowFunctionsStatement() (localctx IShowFunctionsStatementContext) {
	localctx = NewShowFunctionsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, DorisSQLParserRULE_showFunctionsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4085)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4087)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFULL {
		{
			p.SetState(4086)
			p.Match(DorisSQLParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4090)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserBUILTIN || _la == DorisSQLParserGLOBAL {
		{
			p.SetState(4089)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserBUILTIN || _la == DorisSQLParserGLOBAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(4092)
		p.Match(DorisSQLParserFUNCTIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4095)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM || _la == DorisSQLParserIN {
		{
			p.SetState(4093)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4094)

			var _x = p.QualifiedName()

			localctx.(*ShowFunctionsStatementContext).db = _x
		}

	}
	p.SetState(4101)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserLIKE:
		{
			p.SetState(4097)
			p.Match(DorisSQLParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4098)

			var _x = p.String_()

			localctx.(*ShowFunctionsStatementContext).pattern = _x
		}

	case DorisSQLParserWHERE:
		{
			p.SetState(4099)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4100)
			p.expression(0)
		}

	case DorisSQLParserEOF, DorisSQLParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropFunctionStatementContext is an interface to support dynamic dispatch.
type IDropFunctionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	TypeList() ITypeListContext
	GLOBAL() antlr.TerminalNode
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropFunctionStatementContext differentiates from other interfaces.
	IsDropFunctionStatementContext()
}

type DropFunctionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropFunctionStatementContext() *DropFunctionStatementContext {
	var p = new(DropFunctionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropFunctionStatement
	return p
}

func InitEmptyDropFunctionStatementContext(p *DropFunctionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropFunctionStatement
}

func (*DropFunctionStatementContext) IsDropFunctionStatementContext() {}

func NewDropFunctionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFunctionStatementContext {
	var p = new(DropFunctionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropFunctionStatement

	return p
}

func (s *DropFunctionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFunctionStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropFunctionStatementContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFUNCTION, 0)
}

func (s *DropFunctionStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropFunctionStatementContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *DropFunctionStatementContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGLOBAL, 0)
}

func (s *DropFunctionStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *DropFunctionStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *DropFunctionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFunctionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropFunctionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropFunctionStatement(s)
	}
}

func (s *DropFunctionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropFunctionStatement(s)
	}
}

func (s *DropFunctionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropFunctionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropFunctionStatement() (localctx IDropFunctionStatementContext) {
	localctx = NewDropFunctionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, DorisSQLParserRULE_dropFunctionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4103)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4105)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserGLOBAL {
		{
			p.SetState(4104)
			p.Match(DorisSQLParserGLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4107)
		p.Match(DorisSQLParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4110)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(4108)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4109)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4112)
		p.QualifiedName()
	}
	{
		p.SetState(4113)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4114)
		p.TypeList()
	}
	{
		p.SetState(4115)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateFunctionStatementContext is an interface to support dynamic dispatch.
type ICreateFunctionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFunctionType returns the functionType token.
	GetFunctionType() antlr.Token

	// SetFunctionType sets the functionType token.
	SetFunctionType(antlr.Token)

	// GetReturnType returns the returnType rule contexts.
	GetReturnType() ITypeContext

	// SetReturnType sets the returnType rule contexts.
	SetReturnType(ITypeContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	OrReplace() IOrReplaceContext
	FUNCTION() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	QualifiedName() IQualifiedNameContext
	TypeList() ITypeListContext
	RETURNS() antlr.TerminalNode
	Type_() ITypeContext
	GLOBAL() antlr.TerminalNode
	Properties() IPropertiesContext
	InlineProperties() IInlinePropertiesContext
	InlineFunction() IInlineFunctionContext
	TABLE() antlr.TerminalNode
	AGGREGATE() antlr.TerminalNode

	// IsCreateFunctionStatementContext differentiates from other interfaces.
	IsCreateFunctionStatementContext()
}

type CreateFunctionStatementContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	functionType antlr.Token
	returnType   ITypeContext
}

func NewEmptyCreateFunctionStatementContext() *CreateFunctionStatementContext {
	var p = new(CreateFunctionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createFunctionStatement
	return p
}

func InitEmptyCreateFunctionStatementContext(p *CreateFunctionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createFunctionStatement
}

func (*CreateFunctionStatementContext) IsCreateFunctionStatementContext() {}

func NewCreateFunctionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateFunctionStatementContext {
	var p = new(CreateFunctionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createFunctionStatement

	return p
}

func (s *CreateFunctionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateFunctionStatementContext) GetFunctionType() antlr.Token { return s.functionType }

func (s *CreateFunctionStatementContext) SetFunctionType(v antlr.Token) { s.functionType = v }

func (s *CreateFunctionStatementContext) GetReturnType() ITypeContext { return s.returnType }

func (s *CreateFunctionStatementContext) SetReturnType(v ITypeContext) { s.returnType = v }

func (s *CreateFunctionStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateFunctionStatementContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreateFunctionStatementContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFUNCTION, 0)
}

func (s *CreateFunctionStatementContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateFunctionStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateFunctionStatementContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *CreateFunctionStatementContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRETURNS, 0)
}

func (s *CreateFunctionStatementContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *CreateFunctionStatementContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGLOBAL, 0)
}

func (s *CreateFunctionStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateFunctionStatementContext) InlineProperties() IInlinePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlinePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlinePropertiesContext)
}

func (s *CreateFunctionStatementContext) InlineFunction() IInlineFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineFunctionContext)
}

func (s *CreateFunctionStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *CreateFunctionStatementContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAGGREGATE, 0)
}

func (s *CreateFunctionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFunctionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateFunctionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateFunctionStatement(s)
	}
}

func (s *CreateFunctionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateFunctionStatement(s)
	}
}

func (s *CreateFunctionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateFunctionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateFunctionStatement() (localctx ICreateFunctionStatementContext) {
	localctx = NewCreateFunctionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, DorisSQLParserRULE_createFunctionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4117)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4118)
		p.OrReplace()
	}
	p.SetState(4120)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserGLOBAL {
		{
			p.SetState(4119)
			p.Match(DorisSQLParserGLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4123)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserAGGREGATE || _la == DorisSQLParserTABLE {
		{
			p.SetState(4122)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateFunctionStatementContext).functionType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserAGGREGATE || _la == DorisSQLParserTABLE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateFunctionStatementContext).functionType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(4125)
		p.Match(DorisSQLParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4126)
		p.IfNotExists()
	}
	{
		p.SetState(4127)
		p.QualifiedName()
	}
	{
		p.SetState(4128)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4129)
		p.TypeList()
	}
	{
		p.SetState(4130)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4131)
		p.Match(DorisSQLParserRETURNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4132)

		var _x = p.Type_()

		localctx.(*CreateFunctionStatementContext).returnType = _x
	}
	p.SetState(4135)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 411, p.GetParserRuleContext()) == 1+1 {
		{
			p.SetState(4133)
			p.Properties()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 411, p.GetParserRuleContext()) == 2+1 {
		{
			p.SetState(4134)
			p.InlineProperties()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4138)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserAS {
		{
			p.SetState(4137)
			p.InlineFunction()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlineFunctionContext is an interface to support dynamic dispatch.
type IInlineFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	ATTACHMENT() antlr.TerminalNode

	// IsInlineFunctionContext differentiates from other interfaces.
	IsInlineFunctionContext()
}

type InlineFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineFunctionContext() *InlineFunctionContext {
	var p = new(InlineFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_inlineFunction
	return p
}

func InitEmptyInlineFunctionContext(p *InlineFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_inlineFunction
}

func (*InlineFunctionContext) IsInlineFunctionContext() {}

func NewInlineFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineFunctionContext {
	var p = new(InlineFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_inlineFunction

	return p
}

func (s *InlineFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *InlineFunctionContext) ATTACHMENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserATTACHMENT, 0)
}

func (s *InlineFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterInlineFunction(s)
	}
}

func (s *InlineFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitInlineFunction(s)
	}
}

func (s *InlineFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitInlineFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) InlineFunction() (localctx IInlineFunctionContext) {
	localctx = NewInlineFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, DorisSQLParserRULE_inlineFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4140)
		p.Match(DorisSQLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4141)
		p.Match(DorisSQLParserATTACHMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	DOTDOTDOT() antlr.TerminalNode

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_typeList
	return p
}

func InitEmptyTypeListContext(p *TypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_typeList
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeListContext) DOTDOTDOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDOTDOTDOT, 0)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTypeList(s)
	}
}

func (s *TypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTypeList(s)
	}
}

func (s *TypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, DorisSQLParserRULE_typeList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4144)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-24)) & ^0x3f) == 0 && ((int64(1)<<(_la-24))&1099547017217) != 0) || ((int64((_la-106)) & ^0x3f) == 0 && ((int64(1)<<(_la-106))&144115188109411299) != 0) || ((int64((_la-190)) & ^0x3f) == 0 && ((int64(1)<<(_la-190))&4611690485199667201) != 0) || ((int64((_la-284)) & ^0x3f) == 0 && ((int64(1)<<(_la-284))&67108867) != 0) || ((int64((_la-399)) & ^0x3f) == 0 && ((int64(1)<<(_la-399))&36029080491024393) != 0) || _la == DorisSQLParserVARBINARY || _la == DorisSQLParserVARCHAR {
		{
			p.SetState(4143)
			p.Type_()
		}

	}
	p.SetState(4150)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 414, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4146)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4147)
				p.Type_()
			}

		}
		p.SetState(4152)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 414, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(4155)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserT__2 {
		{
			p.SetState(4153)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4154)
			p.Match(DorisSQLParserDOTDOTDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoadStatementContext is an interface to support dynamic dispatch.
type ILoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLabel returns the label rule contexts.
	GetLabel() ILabelNameContext

	// GetData returns the data rule contexts.
	GetData() IDataDescListContext

	// GetBroker returns the broker rule contexts.
	GetBroker() IBrokerDescContext

	// GetSystem returns the system rule contexts.
	GetSystem() IIdentifierOrStringContext

	// GetProps returns the props rule contexts.
	GetProps() IPropertyListContext

	// GetResource returns the resource rule contexts.
	GetResource() IResourceDescContext

	// SetLabel sets the label rule contexts.
	SetLabel(ILabelNameContext)

	// SetData sets the data rule contexts.
	SetData(IDataDescListContext)

	// SetBroker sets the broker rule contexts.
	SetBroker(IBrokerDescContext)

	// SetSystem sets the system rule contexts.
	SetSystem(IIdentifierOrStringContext)

	// SetProps sets the props rule contexts.
	SetProps(IPropertyListContext)

	// SetResource sets the resource rule contexts.
	SetResource(IResourceDescContext)

	// Getter signatures
	LOAD() antlr.TerminalNode
	LABEL() antlr.TerminalNode
	LabelName() ILabelNameContext
	BY() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode
	DataDescList() IDataDescListContext
	BrokerDesc() IBrokerDescContext
	IdentifierOrString() IIdentifierOrStringContext
	PropertyList() IPropertyListContext
	ResourceDesc() IResourceDescContext

	// IsLoadStatementContext differentiates from other interfaces.
	IsLoadStatementContext()
}

type LoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	label    ILabelNameContext
	data     IDataDescListContext
	broker   IBrokerDescContext
	system   IIdentifierOrStringContext
	props    IPropertyListContext
	resource IResourceDescContext
}

func NewEmptyLoadStatementContext() *LoadStatementContext {
	var p = new(LoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_loadStatement
	return p
}

func InitEmptyLoadStatementContext(p *LoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_loadStatement
}

func (*LoadStatementContext) IsLoadStatementContext() {}

func NewLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadStatementContext {
	var p = new(LoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_loadStatement

	return p
}

func (s *LoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadStatementContext) GetLabel() ILabelNameContext { return s.label }

func (s *LoadStatementContext) GetData() IDataDescListContext { return s.data }

func (s *LoadStatementContext) GetBroker() IBrokerDescContext { return s.broker }

func (s *LoadStatementContext) GetSystem() IIdentifierOrStringContext { return s.system }

func (s *LoadStatementContext) GetProps() IPropertyListContext { return s.props }

func (s *LoadStatementContext) GetResource() IResourceDescContext { return s.resource }

func (s *LoadStatementContext) SetLabel(v ILabelNameContext) { s.label = v }

func (s *LoadStatementContext) SetData(v IDataDescListContext) { s.data = v }

func (s *LoadStatementContext) SetBroker(v IBrokerDescContext) { s.broker = v }

func (s *LoadStatementContext) SetSystem(v IIdentifierOrStringContext) { s.system = v }

func (s *LoadStatementContext) SetProps(v IPropertyListContext) { s.props = v }

func (s *LoadStatementContext) SetResource(v IResourceDescContext) { s.resource = v }

func (s *LoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOAD, 0)
}

func (s *LoadStatementContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLABEL, 0)
}

func (s *LoadStatementContext) LabelName() ILabelNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelNameContext)
}

func (s *LoadStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *LoadStatementContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROPERTIES, 0)
}

func (s *LoadStatementContext) DataDescList() IDataDescListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescListContext)
}

func (s *LoadStatementContext) BrokerDesc() IBrokerDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBrokerDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBrokerDescContext)
}

func (s *LoadStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *LoadStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *LoadStatementContext) ResourceDesc() IResourceDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceDescContext)
}

func (s *LoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterLoadStatement(s)
	}
}

func (s *LoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitLoadStatement(s)
	}
}

func (s *LoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) LoadStatement() (localctx ILoadStatementContext) {
	localctx = NewLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, DorisSQLParserRULE_loadStatement)
	var _la int

	p.SetState(4185)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 422, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4157)
			p.Match(DorisSQLParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4158)
			p.Match(DorisSQLParserLABEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4159)

			var _x = p.LabelName()

			localctx.(*LoadStatementContext).label = _x
		}
		p.SetState(4161)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__1 {
			{
				p.SetState(4160)

				var _x = p.DataDescList()

				localctx.(*LoadStatementContext).data = _x
			}

		}
		p.SetState(4164)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserWITH {
			{
				p.SetState(4163)

				var _x = p.BrokerDesc()

				localctx.(*LoadStatementContext).broker = _x
			}

		}
		p.SetState(4168)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserBY {
			{
				p.SetState(4166)
				p.Match(DorisSQLParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4167)

				var _x = p.IdentifierOrString()

				localctx.(*LoadStatementContext).system = _x
			}

		}
		p.SetState(4172)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserPROPERTIES {
			{
				p.SetState(4170)
				p.Match(DorisSQLParserPROPERTIES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4171)

				var _x = p.PropertyList()

				localctx.(*LoadStatementContext).props = _x
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4174)
			p.Match(DorisSQLParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4175)
			p.Match(DorisSQLParserLABEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4176)

			var _x = p.LabelName()

			localctx.(*LoadStatementContext).label = _x
		}
		p.SetState(4178)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__1 {
			{
				p.SetState(4177)

				var _x = p.DataDescList()

				localctx.(*LoadStatementContext).data = _x
			}

		}
		{
			p.SetState(4180)

			var _x = p.ResourceDesc()

			localctx.(*LoadStatementContext).resource = _x
		}
		p.SetState(4183)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserPROPERTIES {
			{
				p.SetState(4181)
				p.Match(DorisSQLParserPROPERTIES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4182)

				var _x = p.PropertyList()

				localctx.(*LoadStatementContext).props = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelNameContext is an interface to support dynamic dispatch.
type ILabelNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IIdentifierContext

	// GetLabel returns the label rule contexts.
	GetLabel() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IIdentifierContext)

	// SetLabel sets the label rule contexts.
	SetLabel(IIdentifierContext)

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsLabelNameContext differentiates from other interfaces.
	IsLabelNameContext()
}

type LabelNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IIdentifierContext
	label  IIdentifierContext
}

func NewEmptyLabelNameContext() *LabelNameContext {
	var p = new(LabelNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_labelName
	return p
}

func InitEmptyLabelNameContext(p *LabelNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_labelName
}

func (*LabelNameContext) IsLabelNameContext() {}

func NewLabelNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelNameContext {
	var p = new(LabelNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_labelName

	return p
}

func (s *LabelNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelNameContext) GetDb() IIdentifierContext { return s.db }

func (s *LabelNameContext) GetLabel() IIdentifierContext { return s.label }

func (s *LabelNameContext) SetDb(v IIdentifierContext) { s.db = v }

func (s *LabelNameContext) SetLabel(v IIdentifierContext) { s.label = v }

func (s *LabelNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *LabelNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LabelNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterLabelName(s)
	}
}

func (s *LabelNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitLabelName(s)
	}
}

func (s *LabelNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitLabelName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) LabelName() (localctx ILabelNameContext) {
	localctx = NewLabelNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, DorisSQLParserRULE_labelName)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4190)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 423, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4187)

			var _x = p.Identifier()

			localctx.(*LabelNameContext).db = _x
		}
		{
			p.SetState(4188)
			p.Match(DorisSQLParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4192)

		var _x = p.Identifier()

		localctx.(*LabelNameContext).label = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataDescListContext is an interface to support dynamic dispatch.
type IDataDescListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDataDesc() []IDataDescContext
	DataDesc(i int) IDataDescContext

	// IsDataDescListContext differentiates from other interfaces.
	IsDataDescListContext()
}

type DataDescListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDescListContext() *DataDescListContext {
	var p = new(DataDescListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dataDescList
	return p
}

func InitEmptyDataDescListContext(p *DataDescListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dataDescList
}

func (*DataDescListContext) IsDataDescListContext() {}

func NewDataDescListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescListContext {
	var p = new(DataDescListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dataDescList

	return p
}

func (s *DataDescListContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDescListContext) AllDataDesc() []IDataDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataDescContext); ok {
			len++
		}
	}

	tst := make([]IDataDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataDescContext); ok {
			tst[i] = t.(IDataDescContext)
			i++
		}
	}

	return tst
}

func (s *DataDescListContext) DataDesc(i int) IDataDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescContext)
}

func (s *DataDescListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDataDescList(s)
	}
}

func (s *DataDescListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDataDescList(s)
	}
}

func (s *DataDescListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDataDescList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DataDescList() (localctx IDataDescListContext) {
	localctx = NewDataDescListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, DorisSQLParserRULE_dataDescList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4194)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4195)
		p.DataDesc()
	}
	p.SetState(4200)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(4196)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4197)
			p.DataDesc()
		}

		p.SetState(4202)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4203)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataDescContext is an interface to support dynamic dispatch.
type IDataDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSrcFiles returns the srcFiles rule contexts.
	GetSrcFiles() IStringListContext

	// GetDstTableName returns the dstTableName rule contexts.
	GetDstTableName() IIdentifierContext

	// GetPartitions returns the partitions rule contexts.
	GetPartitions() IPartitionNamesContext

	// GetColSep returns the colSep rule contexts.
	GetColSep() IStringContext

	// GetRowSep returns the rowSep rule contexts.
	GetRowSep() IStringContext

	// GetFormat returns the format rule contexts.
	GetFormat() IFileFormatContext

	// GetFormatPropsField returns the formatPropsField rule contexts.
	GetFormatPropsField() IFormatPropsContext

	// GetColList returns the colList rule contexts.
	GetColList() IColumnAliasesContext

	// GetColFromPath returns the colFromPath rule contexts.
	GetColFromPath() IIdentifierListContext

	// GetColMappingList returns the colMappingList rule contexts.
	GetColMappingList() IClassifierContext

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// GetSrcTableName returns the srcTableName rule contexts.
	GetSrcTableName() IIdentifierContext

	// SetSrcFiles sets the srcFiles rule contexts.
	SetSrcFiles(IStringListContext)

	// SetDstTableName sets the dstTableName rule contexts.
	SetDstTableName(IIdentifierContext)

	// SetPartitions sets the partitions rule contexts.
	SetPartitions(IPartitionNamesContext)

	// SetColSep sets the colSep rule contexts.
	SetColSep(IStringContext)

	// SetRowSep sets the rowSep rule contexts.
	SetRowSep(IStringContext)

	// SetFormat sets the format rule contexts.
	SetFormat(IFileFormatContext)

	// SetFormatPropsField sets the formatPropsField rule contexts.
	SetFormatPropsField(IFormatPropsContext)

	// SetColList sets the colList rule contexts.
	SetColList(IColumnAliasesContext)

	// SetColFromPath sets the colFromPath rule contexts.
	SetColFromPath(IIdentifierListContext)

	// SetColMappingList sets the colMappingList rule contexts.
	SetColMappingList(IClassifierContext)

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// SetSrcTableName sets the srcTableName rule contexts.
	SetSrcTableName(IIdentifierContext)

	// Getter signatures
	DATA() antlr.TerminalNode
	INFILE() antlr.TerminalNode
	INTO() antlr.TerminalNode
	AllTABLE() []antlr.TerminalNode
	TABLE(i int) antlr.TerminalNode
	StringList() IStringListContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	NEGATIVE() antlr.TerminalNode
	AllCOLUMNS() []antlr.TerminalNode
	COLUMNS(i int) antlr.TerminalNode
	AllTERMINATED() []antlr.TerminalNode
	TERMINATED(i int) antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	ROWS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	PATH() antlr.TerminalNode
	AS() antlr.TerminalNode
	SET() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	PartitionNames() IPartitionNamesContext
	AllString_() []IStringContext
	String_(i int) IStringContext
	FileFormat() IFileFormatContext
	FormatProps() IFormatPropsContext
	ColumnAliases() IColumnAliasesContext
	IdentifierList() IIdentifierListContext
	Classifier() IClassifierContext
	Expression() IExpressionContext

	// IsDataDescContext differentiates from other interfaces.
	IsDataDescContext()
}

type DataDescContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	srcFiles         IStringListContext
	dstTableName     IIdentifierContext
	partitions       IPartitionNamesContext
	colSep           IStringContext
	rowSep           IStringContext
	format           IFileFormatContext
	formatPropsField IFormatPropsContext
	colList          IColumnAliasesContext
	colFromPath      IIdentifierListContext
	colMappingList   IClassifierContext
	where            IExpressionContext
	srcTableName     IIdentifierContext
}

func NewEmptyDataDescContext() *DataDescContext {
	var p = new(DataDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dataDesc
	return p
}

func InitEmptyDataDescContext(p *DataDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dataDesc
}

func (*DataDescContext) IsDataDescContext() {}

func NewDataDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescContext {
	var p = new(DataDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dataDesc

	return p
}

func (s *DataDescContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDescContext) GetSrcFiles() IStringListContext { return s.srcFiles }

func (s *DataDescContext) GetDstTableName() IIdentifierContext { return s.dstTableName }

func (s *DataDescContext) GetPartitions() IPartitionNamesContext { return s.partitions }

func (s *DataDescContext) GetColSep() IStringContext { return s.colSep }

func (s *DataDescContext) GetRowSep() IStringContext { return s.rowSep }

func (s *DataDescContext) GetFormat() IFileFormatContext { return s.format }

func (s *DataDescContext) GetFormatPropsField() IFormatPropsContext { return s.formatPropsField }

func (s *DataDescContext) GetColList() IColumnAliasesContext { return s.colList }

func (s *DataDescContext) GetColFromPath() IIdentifierListContext { return s.colFromPath }

func (s *DataDescContext) GetColMappingList() IClassifierContext { return s.colMappingList }

func (s *DataDescContext) GetWhere() IExpressionContext { return s.where }

func (s *DataDescContext) GetSrcTableName() IIdentifierContext { return s.srcTableName }

func (s *DataDescContext) SetSrcFiles(v IStringListContext) { s.srcFiles = v }

func (s *DataDescContext) SetDstTableName(v IIdentifierContext) { s.dstTableName = v }

func (s *DataDescContext) SetPartitions(v IPartitionNamesContext) { s.partitions = v }

func (s *DataDescContext) SetColSep(v IStringContext) { s.colSep = v }

func (s *DataDescContext) SetRowSep(v IStringContext) { s.rowSep = v }

func (s *DataDescContext) SetFormat(v IFileFormatContext) { s.format = v }

func (s *DataDescContext) SetFormatPropsField(v IFormatPropsContext) { s.formatPropsField = v }

func (s *DataDescContext) SetColList(v IColumnAliasesContext) { s.colList = v }

func (s *DataDescContext) SetColFromPath(v IIdentifierListContext) { s.colFromPath = v }

func (s *DataDescContext) SetColMappingList(v IClassifierContext) { s.colMappingList = v }

func (s *DataDescContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *DataDescContext) SetSrcTableName(v IIdentifierContext) { s.srcTableName = v }

func (s *DataDescContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATA, 0)
}

func (s *DataDescContext) INFILE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINFILE, 0)
}

func (s *DataDescContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTO, 0)
}

func (s *DataDescContext) AllTABLE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserTABLE)
}

func (s *DataDescContext) TABLE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, i)
}

func (s *DataDescContext) StringList() IStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringListContext)
}

func (s *DataDescContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DataDescContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DataDescContext) NEGATIVE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNEGATIVE, 0)
}

func (s *DataDescContext) AllCOLUMNS() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserCOLUMNS)
}

func (s *DataDescContext) COLUMNS(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLUMNS, i)
}

func (s *DataDescContext) AllTERMINATED() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserTERMINATED)
}

func (s *DataDescContext) TERMINATED(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTERMINATED, i)
}

func (s *DataDescContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserBY)
}

func (s *DataDescContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, i)
}

func (s *DataDescContext) ROWS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROWS, 0)
}

func (s *DataDescContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *DataDescContext) PATH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPATH, 0)
}

func (s *DataDescContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *DataDescContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *DataDescContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *DataDescContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *DataDescContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *DataDescContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DataDescContext) FileFormat() IFileFormatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileFormatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileFormatContext)
}

func (s *DataDescContext) FormatProps() IFormatPropsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormatPropsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormatPropsContext)
}

func (s *DataDescContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *DataDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DataDescContext) Classifier() IClassifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassifierContext)
}

func (s *DataDescContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DataDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDataDesc(s)
	}
}

func (s *DataDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDataDesc(s)
	}
}

func (s *DataDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDataDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DataDesc() (localctx IDataDescContext) {
	localctx = NewDataDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, DorisSQLParserRULE_dataDesc)
	var _la int

	p.SetState(4274)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 439, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4205)
			p.Match(DorisSQLParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4206)
			p.Match(DorisSQLParserINFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4207)

			var _x = p.StringList()

			localctx.(*DataDescContext).srcFiles = _x
		}
		p.SetState(4209)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserNEGATIVE {
			{
				p.SetState(4208)
				p.Match(DorisSQLParserNEGATIVE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4211)
			p.Match(DorisSQLParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4212)
			p.Match(DorisSQLParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4213)

			var _x = p.Identifier()

			localctx.(*DataDescContext).dstTableName = _x
		}
		p.SetState(4215)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserPARTITION || _la == DorisSQLParserPARTITIONS || _la == DorisSQLParserTEMPORARY {
			{
				p.SetState(4214)

				var _x = p.PartitionNames()

				localctx.(*DataDescContext).partitions = _x
			}

		}
		p.SetState(4221)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 427, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4217)
				p.Match(DorisSQLParserCOLUMNS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4218)
				p.Match(DorisSQLParserTERMINATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4219)
				p.Match(DorisSQLParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4220)

				var _x = p.String_()

				localctx.(*DataDescContext).colSep = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4227)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserROWS {
			{
				p.SetState(4223)
				p.Match(DorisSQLParserROWS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4224)
				p.Match(DorisSQLParserTERMINATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4225)
				p.Match(DorisSQLParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4226)

				var _x = p.String_()

				localctx.(*DataDescContext).rowSep = _x
			}

		}
		p.SetState(4230)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserFORMAT {
			{
				p.SetState(4229)

				var _x = p.FileFormat()

				localctx.(*DataDescContext).format = _x
			}

		}
		p.SetState(4233)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 430, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4232)

				var _x = p.FormatProps()

				localctx.(*DataDescContext).formatPropsField = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4236)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__1 {
			{
				p.SetState(4235)

				var _x = p.ColumnAliases()

				localctx.(*DataDescContext).colList = _x
			}

		}
		p.SetState(4243)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserCOLUMNS {
			{
				p.SetState(4238)
				p.Match(DorisSQLParserCOLUMNS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4239)
				p.Match(DorisSQLParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4240)
				p.Match(DorisSQLParserPATH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4241)
				p.Match(DorisSQLParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4242)

				var _x = p.IdentifierList()

				localctx.(*DataDescContext).colFromPath = _x
			}

		}
		p.SetState(4247)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserSET {
			{
				p.SetState(4245)
				p.Match(DorisSQLParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4246)

				var _x = p.Classifier()

				localctx.(*DataDescContext).colMappingList = _x
			}

		}
		p.SetState(4251)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserWHERE {
			{
				p.SetState(4249)
				p.Match(DorisSQLParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4250)

				var _x = p.expression(0)

				localctx.(*DataDescContext).where = _x
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4253)
			p.Match(DorisSQLParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4254)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4255)
			p.Match(DorisSQLParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4256)

			var _x = p.Identifier()

			localctx.(*DataDescContext).srcTableName = _x
		}
		p.SetState(4258)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserNEGATIVE {
			{
				p.SetState(4257)
				p.Match(DorisSQLParserNEGATIVE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4260)
			p.Match(DorisSQLParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4261)
			p.Match(DorisSQLParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4262)

			var _x = p.Identifier()

			localctx.(*DataDescContext).dstTableName = _x
		}
		p.SetState(4264)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserPARTITION || _la == DorisSQLParserPARTITIONS || _la == DorisSQLParserTEMPORARY {
			{
				p.SetState(4263)

				var _x = p.PartitionNames()

				localctx.(*DataDescContext).partitions = _x
			}

		}
		p.SetState(4268)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserSET {
			{
				p.SetState(4266)
				p.Match(DorisSQLParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4267)

				var _x = p.Classifier()

				localctx.(*DataDescContext).colMappingList = _x
			}

		}
		p.SetState(4272)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserWHERE {
			{
				p.SetState(4270)
				p.Match(DorisSQLParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4271)

				var _x = p.expression(0)

				localctx.(*DataDescContext).where = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormatPropsContext is an interface to support dynamic dispatch.
type IFormatPropsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetEncloseCharacter returns the encloseCharacter rule contexts.
	GetEncloseCharacter() IStringContext

	// GetEscapeCharacter returns the escapeCharacter rule contexts.
	GetEscapeCharacter() IStringContext

	// SetEncloseCharacter sets the encloseCharacter rule contexts.
	SetEncloseCharacter(IStringContext)

	// SetEscapeCharacter sets the escapeCharacter rule contexts.
	SetEscapeCharacter(IStringContext)

	// Getter signatures
	SKIP_HEADER() antlr.TerminalNode
	AllEQ() []antlr.TerminalNode
	EQ(i int) antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	TRIM_SPACE() antlr.TerminalNode
	BooleanValue() IBooleanValueContext
	ENCLOSE() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsFormatPropsContext differentiates from other interfaces.
	IsFormatPropsContext()
}

type FormatPropsContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	encloseCharacter IStringContext
	escapeCharacter  IStringContext
}

func NewEmptyFormatPropsContext() *FormatPropsContext {
	var p = new(FormatPropsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_formatProps
	return p
}

func InitEmptyFormatPropsContext(p *FormatPropsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_formatProps
}

func (*FormatPropsContext) IsFormatPropsContext() {}

func NewFormatPropsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormatPropsContext {
	var p = new(FormatPropsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_formatProps

	return p
}

func (s *FormatPropsContext) GetParser() antlr.Parser { return s.parser }

func (s *FormatPropsContext) GetEncloseCharacter() IStringContext { return s.encloseCharacter }

func (s *FormatPropsContext) GetEscapeCharacter() IStringContext { return s.escapeCharacter }

func (s *FormatPropsContext) SetEncloseCharacter(v IStringContext) { s.encloseCharacter = v }

func (s *FormatPropsContext) SetEscapeCharacter(v IStringContext) { s.escapeCharacter = v }

func (s *FormatPropsContext) SKIP_HEADER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSKIP_HEADER, 0)
}

func (s *FormatPropsContext) AllEQ() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserEQ)
}

func (s *FormatPropsContext) EQ(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEQ, i)
}

func (s *FormatPropsContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, 0)
}

func (s *FormatPropsContext) TRIM_SPACE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTRIM_SPACE, 0)
}

func (s *FormatPropsContext) BooleanValue() IBooleanValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *FormatPropsContext) ENCLOSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserENCLOSE, 0)
}

func (s *FormatPropsContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserESCAPE, 0)
}

func (s *FormatPropsContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *FormatPropsContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *FormatPropsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormatPropsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormatPropsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterFormatProps(s)
	}
}

func (s *FormatPropsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitFormatProps(s)
	}
}

func (s *FormatPropsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitFormatProps(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) FormatProps() (localctx IFormatPropsContext) {
	localctx = NewFormatPropsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, DorisSQLParserRULE_formatProps)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4276)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4280)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserSKIP_HEADER {
		{
			p.SetState(4277)
			p.Match(DorisSQLParserSKIP_HEADER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4278)
			p.Match(DorisSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4279)
			p.Match(DorisSQLParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4285)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserTRIM_SPACE {
		{
			p.SetState(4282)
			p.Match(DorisSQLParserTRIM_SPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4283)
			p.Match(DorisSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4284)
			p.BooleanValue()
		}

	}
	p.SetState(4290)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserENCLOSE {
		{
			p.SetState(4287)
			p.Match(DorisSQLParserENCLOSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4288)
			p.Match(DorisSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4289)

			var _x = p.String_()

			localctx.(*FormatPropsContext).encloseCharacter = _x
		}

	}
	p.SetState(4295)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserESCAPE {
		{
			p.SetState(4292)
			p.Match(DorisSQLParserESCAPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4293)
			p.Match(DorisSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4294)

			var _x = p.String_()

			localctx.(*FormatPropsContext).escapeCharacter = _x
		}

	}
	{
		p.SetState(4297)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBrokerDescContext is an interface to support dynamic dispatch.
type IBrokerDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetProps returns the props rule contexts.
	GetProps() IPropertyListContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierOrStringContext

	// SetProps sets the props rule contexts.
	SetProps(IPropertyListContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierOrStringContext)

	// Getter signatures
	WITH() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	PropertyList() IPropertyListContext
	IdentifierOrString() IIdentifierOrStringContext

	// IsBrokerDescContext differentiates from other interfaces.
	IsBrokerDescContext()
}

type BrokerDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	props  IPropertyListContext
	name   IIdentifierOrStringContext
}

func NewEmptyBrokerDescContext() *BrokerDescContext {
	var p = new(BrokerDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_brokerDesc
	return p
}

func InitEmptyBrokerDescContext(p *BrokerDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_brokerDesc
}

func (*BrokerDescContext) IsBrokerDescContext() {}

func NewBrokerDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BrokerDescContext {
	var p = new(BrokerDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_brokerDesc

	return p
}

func (s *BrokerDescContext) GetParser() antlr.Parser { return s.parser }

func (s *BrokerDescContext) GetProps() IPropertyListContext { return s.props }

func (s *BrokerDescContext) GetName() IIdentifierOrStringContext { return s.name }

func (s *BrokerDescContext) SetProps(v IPropertyListContext) { s.props = v }

func (s *BrokerDescContext) SetName(v IIdentifierOrStringContext) { s.name = v }

func (s *BrokerDescContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *BrokerDescContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBROKER, 0)
}

func (s *BrokerDescContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *BrokerDescContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *BrokerDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BrokerDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BrokerDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterBrokerDesc(s)
	}
}

func (s *BrokerDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitBrokerDesc(s)
	}
}

func (s *BrokerDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitBrokerDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) BrokerDesc() (localctx IBrokerDescContext) {
	localctx = NewBrokerDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, DorisSQLParserRULE_brokerDesc)
	var _la int

	p.SetState(4310)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 446, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4299)
			p.Match(DorisSQLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4300)
			p.Match(DorisSQLParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4302)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__1 {
			{
				p.SetState(4301)

				var _x = p.PropertyList()

				localctx.(*BrokerDescContext).props = _x
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4304)
			p.Match(DorisSQLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4305)
			p.Match(DorisSQLParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4306)

			var _x = p.IdentifierOrString()

			localctx.(*BrokerDescContext).name = _x
		}
		p.SetState(4308)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__1 {
			{
				p.SetState(4307)

				var _x = p.PropertyList()

				localctx.(*BrokerDescContext).props = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceDescContext is an interface to support dynamic dispatch.
type IResourceDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierOrStringContext

	// GetProps returns the props rule contexts.
	GetProps() IPropertyListContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierOrStringContext)

	// SetProps sets the props rule contexts.
	SetProps(IPropertyListContext)

	// Getter signatures
	WITH() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	PropertyList() IPropertyListContext

	// IsResourceDescContext differentiates from other interfaces.
	IsResourceDescContext()
}

type ResourceDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierOrStringContext
	props  IPropertyListContext
}

func NewEmptyResourceDescContext() *ResourceDescContext {
	var p = new(ResourceDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_resourceDesc
	return p
}

func InitEmptyResourceDescContext(p *ResourceDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_resourceDesc
}

func (*ResourceDescContext) IsResourceDescContext() {}

func NewResourceDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceDescContext {
	var p = new(ResourceDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_resourceDesc

	return p
}

func (s *ResourceDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceDescContext) GetName() IIdentifierOrStringContext { return s.name }

func (s *ResourceDescContext) GetProps() IPropertyListContext { return s.props }

func (s *ResourceDescContext) SetName(v IIdentifierOrStringContext) { s.name = v }

func (s *ResourceDescContext) SetProps(v IPropertyListContext) { s.props = v }

func (s *ResourceDescContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *ResourceDescContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRESOURCE, 0)
}

func (s *ResourceDescContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *ResourceDescContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *ResourceDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterResourceDesc(s)
	}
}

func (s *ResourceDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitResourceDesc(s)
	}
}

func (s *ResourceDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitResourceDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ResourceDesc() (localctx IResourceDescContext) {
	localctx = NewResourceDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, DorisSQLParserRULE_resourceDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4312)
		p.Match(DorisSQLParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4313)
		p.Match(DorisSQLParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4314)

		var _x = p.IdentifierOrString()

		localctx.(*ResourceDescContext).name = _x
	}
	p.SetState(4316)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserT__1 {
		{
			p.SetState(4315)

			var _x = p.PropertyList()

			localctx.(*ResourceDescContext).props = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowLoadStatementContext is an interface to support dynamic dispatch.
type IShowLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	ALL() antlr.TerminalNode
	FROM() antlr.TerminalNode
	Identifier() IIdentifierContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext

	// IsShowLoadStatementContext differentiates from other interfaces.
	IsShowLoadStatementContext()
}

type ShowLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowLoadStatementContext() *ShowLoadStatementContext {
	var p = new(ShowLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showLoadStatement
	return p
}

func InitEmptyShowLoadStatementContext(p *ShowLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showLoadStatement
}

func (*ShowLoadStatementContext) IsShowLoadStatementContext() {}

func NewShowLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowLoadStatementContext {
	var p = new(ShowLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showLoadStatement

	return p
}

func (s *ShowLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowLoadStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOAD, 0)
}

func (s *ShowLoadStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, 0)
}

func (s *ShowLoadStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowLoadStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowLoadStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowLoadStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserORDER, 0)
}

func (s *ShowLoadStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *ShowLoadStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowLoadStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowLoadStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowLoadStatement(s)
	}
}

func (s *ShowLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowLoadStatement(s)
	}
}

func (s *ShowLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowLoadStatement() (localctx IShowLoadStatementContext) {
	localctx = NewShowLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, DorisSQLParserRULE_showLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4318)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4319)
		p.Match(DorisSQLParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4321)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserALL {
		{
			p.SetState(4320)
			p.Match(DorisSQLParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4325)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM {
		{
			p.SetState(4323)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4324)
			p.Identifier()
		}

	}
	p.SetState(4329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWHERE {
		{
			p.SetState(4327)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4328)
			p.expression(0)
		}

	}
	p.SetState(4341)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserORDER {
		{
			p.SetState(4331)
			p.Match(DorisSQLParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4332)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4333)
			p.SortItem()
		}
		p.SetState(4338)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(4334)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4335)
				p.SortItem()
			}

			p.SetState(4340)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(4344)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserLIMIT {
		{
			p.SetState(4343)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowLoadWarningsStatementContext is an interface to support dynamic dispatch.
type IShowLoadWarningsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	WARNINGS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	Identifier() IIdentifierContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	LimitElement() ILimitElementContext
	ON() antlr.TerminalNode
	String_() IStringContext

	// IsShowLoadWarningsStatementContext differentiates from other interfaces.
	IsShowLoadWarningsStatementContext()
}

type ShowLoadWarningsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowLoadWarningsStatementContext() *ShowLoadWarningsStatementContext {
	var p = new(ShowLoadWarningsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showLoadWarningsStatement
	return p
}

func InitEmptyShowLoadWarningsStatementContext(p *ShowLoadWarningsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showLoadWarningsStatement
}

func (*ShowLoadWarningsStatementContext) IsShowLoadWarningsStatementContext() {}

func NewShowLoadWarningsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowLoadWarningsStatementContext {
	var p = new(ShowLoadWarningsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showLoadWarningsStatement

	return p
}

func (s *ShowLoadWarningsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowLoadWarningsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowLoadWarningsStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOAD, 0)
}

func (s *ShowLoadWarningsStatementContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWARNINGS, 0)
}

func (s *ShowLoadWarningsStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowLoadWarningsStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowLoadWarningsStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowLoadWarningsStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowLoadWarningsStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowLoadWarningsStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *ShowLoadWarningsStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowLoadWarningsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowLoadWarningsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowLoadWarningsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowLoadWarningsStatement(s)
	}
}

func (s *ShowLoadWarningsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowLoadWarningsStatement(s)
	}
}

func (s *ShowLoadWarningsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowLoadWarningsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowLoadWarningsStatement() (localctx IShowLoadWarningsStatementContext) {
	localctx = NewShowLoadWarningsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, DorisSQLParserRULE_showLoadWarningsStatement)
	var _la int

	p.SetState(4365)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 457, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4346)
			p.Match(DorisSQLParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4347)
			p.Match(DorisSQLParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4348)
			p.Match(DorisSQLParserWARNINGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4351)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserFROM {
			{
				p.SetState(4349)
				p.Match(DorisSQLParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4350)
				p.Identifier()
			}

		}
		p.SetState(4355)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserWHERE {
			{
				p.SetState(4353)
				p.Match(DorisSQLParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4354)
				p.expression(0)
			}

		}
		p.SetState(4358)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserLIMIT {
			{
				p.SetState(4357)
				p.LimitElement()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4360)
			p.Match(DorisSQLParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4361)
			p.Match(DorisSQLParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4362)
			p.Match(DorisSQLParserWARNINGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4363)
			p.Match(DorisSQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4364)
			p.String_()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelLoadStatementContext is an interface to support dynamic dispatch.
type ICancelLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FROM() antlr.TerminalNode
	Identifier() IIdentifierContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsCancelLoadStatementContext differentiates from other interfaces.
	IsCancelLoadStatementContext()
}

type CancelLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelLoadStatementContext() *CancelLoadStatementContext {
	var p = new(CancelLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cancelLoadStatement
	return p
}

func InitEmptyCancelLoadStatementContext(p *CancelLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cancelLoadStatement
}

func (*CancelLoadStatementContext) IsCancelLoadStatementContext() {}

func NewCancelLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelLoadStatementContext {
	var p = new(CancelLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_cancelLoadStatement

	return p
}

func (s *CancelLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelLoadStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCANCEL, 0)
}

func (s *CancelLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOAD, 0)
}

func (s *CancelLoadStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *CancelLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelLoadStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *CancelLoadStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CancelLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCancelLoadStatement(s)
	}
}

func (s *CancelLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCancelLoadStatement(s)
	}
}

func (s *CancelLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCancelLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CancelLoadStatement() (localctx ICancelLoadStatementContext) {
	localctx = NewCancelLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, DorisSQLParserRULE_cancelLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4367)
		p.Match(DorisSQLParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4368)
		p.Match(DorisSQLParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4371)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM {
		{
			p.SetState(4369)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4370)
			p.Identifier()
		}

	}
	p.SetState(4375)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWHERE {
		{
			p.SetState(4373)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4374)
			p.expression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterLoadStatementContext is an interface to support dynamic dispatch.
type IAlterLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	JobProperties() IJobPropertiesContext
	QualifiedName() IQualifiedNameContext

	// IsAlterLoadStatementContext differentiates from other interfaces.
	IsAlterLoadStatementContext()
}

type AlterLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyAlterLoadStatementContext() *AlterLoadStatementContext {
	var p = new(AlterLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterLoadStatement
	return p
}

func InitEmptyAlterLoadStatementContext(p *AlterLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterLoadStatement
}

func (*AlterLoadStatementContext) IsAlterLoadStatementContext() {}

func NewAlterLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterLoadStatementContext {
	var p = new(AlterLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_alterLoadStatement

	return p
}

func (s *AlterLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *AlterLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *AlterLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *AlterLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterLoadStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *AlterLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOAD, 0)
}

func (s *AlterLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFOR, 0)
}

func (s *AlterLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterLoadStatementContext) JobProperties() IJobPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJobPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJobPropertiesContext)
}

func (s *AlterLoadStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAlterLoadStatement(s)
	}
}

func (s *AlterLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAlterLoadStatement(s)
	}
}

func (s *AlterLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAlterLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AlterLoadStatement() (localctx IAlterLoadStatementContext) {
	localctx = NewAlterLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, DorisSQLParserRULE_alterLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4377)
		p.Match(DorisSQLParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4378)
		p.Match(DorisSQLParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4379)
		p.Match(DorisSQLParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4383)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 460, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4380)

			var _x = p.QualifiedName()

			localctx.(*AlterLoadStatementContext).db = _x
		}
		{
			p.SetState(4381)
			p.Match(DorisSQLParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4385)

		var _x = p.Identifier()

		localctx.(*AlterLoadStatementContext).name = _x
	}
	p.SetState(4387)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(4386)
			p.JobProperties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelCompactionStatementContext is an interface to support dynamic dispatch.
type ICancelCompactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	COMPACTION() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsCancelCompactionStatementContext differentiates from other interfaces.
	IsCancelCompactionStatementContext()
}

type CancelCompactionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelCompactionStatementContext() *CancelCompactionStatementContext {
	var p = new(CancelCompactionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cancelCompactionStatement
	return p
}

func InitEmptyCancelCompactionStatementContext(p *CancelCompactionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cancelCompactionStatement
}

func (*CancelCompactionStatementContext) IsCancelCompactionStatementContext() {}

func NewCancelCompactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelCompactionStatementContext {
	var p = new(CancelCompactionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_cancelCompactionStatement

	return p
}

func (s *CancelCompactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelCompactionStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCANCEL, 0)
}

func (s *CancelCompactionStatementContext) COMPACTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOMPACTION, 0)
}

func (s *CancelCompactionStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *CancelCompactionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CancelCompactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelCompactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelCompactionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCancelCompactionStatement(s)
	}
}

func (s *CancelCompactionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCancelCompactionStatement(s)
	}
}

func (s *CancelCompactionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCancelCompactionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CancelCompactionStatement() (localctx ICancelCompactionStatementContext) {
	localctx = NewCancelCompactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, DorisSQLParserRULE_cancelCompactionStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4389)
		p.Match(DorisSQLParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4390)
		p.Match(DorisSQLParserCOMPACTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4391)
		p.Match(DorisSQLParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4392)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowAuthorStatementContext is an interface to support dynamic dispatch.
type IShowAuthorStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	AUTHORS() antlr.TerminalNode

	// IsShowAuthorStatementContext differentiates from other interfaces.
	IsShowAuthorStatementContext()
}

type ShowAuthorStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowAuthorStatementContext() *ShowAuthorStatementContext {
	var p = new(ShowAuthorStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showAuthorStatement
	return p
}

func InitEmptyShowAuthorStatementContext(p *ShowAuthorStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showAuthorStatement
}

func (*ShowAuthorStatementContext) IsShowAuthorStatementContext() {}

func NewShowAuthorStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowAuthorStatementContext {
	var p = new(ShowAuthorStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showAuthorStatement

	return p
}

func (s *ShowAuthorStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowAuthorStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowAuthorStatementContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAUTHORS, 0)
}

func (s *ShowAuthorStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAuthorStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowAuthorStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowAuthorStatement(s)
	}
}

func (s *ShowAuthorStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowAuthorStatement(s)
	}
}

func (s *ShowAuthorStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowAuthorStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowAuthorStatement() (localctx IShowAuthorStatementContext) {
	localctx = NewShowAuthorStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, DorisSQLParserRULE_showAuthorStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4394)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4395)
		p.Match(DorisSQLParserAUTHORS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowBackendsStatementContext is an interface to support dynamic dispatch.
type IShowBackendsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	BACKENDS() antlr.TerminalNode

	// IsShowBackendsStatementContext differentiates from other interfaces.
	IsShowBackendsStatementContext()
}

type ShowBackendsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowBackendsStatementContext() *ShowBackendsStatementContext {
	var p = new(ShowBackendsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showBackendsStatement
	return p
}

func InitEmptyShowBackendsStatementContext(p *ShowBackendsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showBackendsStatement
}

func (*ShowBackendsStatementContext) IsShowBackendsStatementContext() {}

func NewShowBackendsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowBackendsStatementContext {
	var p = new(ShowBackendsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showBackendsStatement

	return p
}

func (s *ShowBackendsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowBackendsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowBackendsStatementContext) BACKENDS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBACKENDS, 0)
}

func (s *ShowBackendsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBackendsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowBackendsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowBackendsStatement(s)
	}
}

func (s *ShowBackendsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowBackendsStatement(s)
	}
}

func (s *ShowBackendsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowBackendsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowBackendsStatement() (localctx IShowBackendsStatementContext) {
	localctx = NewShowBackendsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, DorisSQLParserRULE_showBackendsStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4397)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4398)
		p.Match(DorisSQLParserBACKENDS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowBrokerStatementContext is an interface to support dynamic dispatch.
type IShowBrokerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	BROKER() antlr.TerminalNode

	// IsShowBrokerStatementContext differentiates from other interfaces.
	IsShowBrokerStatementContext()
}

type ShowBrokerStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowBrokerStatementContext() *ShowBrokerStatementContext {
	var p = new(ShowBrokerStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showBrokerStatement
	return p
}

func InitEmptyShowBrokerStatementContext(p *ShowBrokerStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showBrokerStatement
}

func (*ShowBrokerStatementContext) IsShowBrokerStatementContext() {}

func NewShowBrokerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowBrokerStatementContext {
	var p = new(ShowBrokerStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showBrokerStatement

	return p
}

func (s *ShowBrokerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowBrokerStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowBrokerStatementContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBROKER, 0)
}

func (s *ShowBrokerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBrokerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowBrokerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowBrokerStatement(s)
	}
}

func (s *ShowBrokerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowBrokerStatement(s)
	}
}

func (s *ShowBrokerStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowBrokerStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowBrokerStatement() (localctx IShowBrokerStatementContext) {
	localctx = NewShowBrokerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, DorisSQLParserRULE_showBrokerStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4400)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4401)
		p.Match(DorisSQLParserBROKER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCharsetStatementContext is an interface to support dynamic dispatch.
type IShowCharsetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	SET() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowCharsetStatementContext differentiates from other interfaces.
	IsShowCharsetStatementContext()
}

type ShowCharsetStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowCharsetStatementContext() *ShowCharsetStatementContext {
	var p = new(ShowCharsetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showCharsetStatement
	return p
}

func InitEmptyShowCharsetStatementContext(p *ShowCharsetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showCharsetStatement
}

func (*ShowCharsetStatementContext) IsShowCharsetStatementContext() {}

func NewShowCharsetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCharsetStatementContext {
	var p = new(ShowCharsetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showCharsetStatement

	return p
}

func (s *ShowCharsetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCharsetStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowCharsetStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowCharsetStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowCharsetStatementContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCHAR, 0)
}

func (s *ShowCharsetStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *ShowCharsetStatementContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCHARSET, 0)
}

func (s *ShowCharsetStatementContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCHARACTER, 0)
}

func (s *ShowCharsetStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *ShowCharsetStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowCharsetStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowCharsetStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowCharsetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCharsetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCharsetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowCharsetStatement(s)
	}
}

func (s *ShowCharsetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowCharsetStatement(s)
	}
}

func (s *ShowCharsetStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowCharsetStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowCharsetStatement() (localctx IShowCharsetStatementContext) {
	localctx = NewShowCharsetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, DorisSQLParserRULE_showCharsetStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4403)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4409)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserCHAR:
		{
			p.SetState(4404)
			p.Match(DorisSQLParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4405)
			p.Match(DorisSQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserCHARSET:
		{
			p.SetState(4406)
			p.Match(DorisSQLParserCHARSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserCHARACTER:
		{
			p.SetState(4407)
			p.Match(DorisSQLParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4408)
			p.Match(DorisSQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(4415)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserLIKE:
		{
			p.SetState(4411)
			p.Match(DorisSQLParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4412)

			var _x = p.String_()

			localctx.(*ShowCharsetStatementContext).pattern = _x
		}

	case DorisSQLParserWHERE:
		{
			p.SetState(4413)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4414)
			p.expression(0)
		}

	case DorisSQLParserEOF, DorisSQLParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCollationStatementContext is an interface to support dynamic dispatch.
type IShowCollationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowCollationStatementContext differentiates from other interfaces.
	IsShowCollationStatementContext()
}

type ShowCollationStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowCollationStatementContext() *ShowCollationStatementContext {
	var p = new(ShowCollationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showCollationStatement
	return p
}

func InitEmptyShowCollationStatementContext(p *ShowCollationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showCollationStatement
}

func (*ShowCollationStatementContext) IsShowCollationStatementContext() {}

func NewShowCollationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCollationStatementContext {
	var p = new(ShowCollationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showCollationStatement

	return p
}

func (s *ShowCollationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCollationStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowCollationStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowCollationStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowCollationStatementContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLLATION, 0)
}

func (s *ShowCollationStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *ShowCollationStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowCollationStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowCollationStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowCollationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCollationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCollationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowCollationStatement(s)
	}
}

func (s *ShowCollationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowCollationStatement(s)
	}
}

func (s *ShowCollationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowCollationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowCollationStatement() (localctx IShowCollationStatementContext) {
	localctx = NewShowCollationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, DorisSQLParserRULE_showCollationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4417)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4418)
		p.Match(DorisSQLParserCOLLATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4423)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserLIKE:
		{
			p.SetState(4419)
			p.Match(DorisSQLParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4420)

			var _x = p.String_()

			localctx.(*ShowCollationStatementContext).pattern = _x
		}

	case DorisSQLParserWHERE:
		{
			p.SetState(4421)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4422)
			p.expression(0)
		}

	case DorisSQLParserEOF, DorisSQLParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDeleteStatementContext is an interface to support dynamic dispatch.
type IShowDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowDeleteStatementContext differentiates from other interfaces.
	IsShowDeleteStatementContext()
}

type ShowDeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
}

func NewEmptyShowDeleteStatementContext() *ShowDeleteStatementContext {
	var p = new(ShowDeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showDeleteStatement
	return p
}

func InitEmptyShowDeleteStatementContext(p *ShowDeleteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showDeleteStatement
}

func (*ShowDeleteStatementContext) IsShowDeleteStatementContext() {}

func NewShowDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDeleteStatementContext {
	var p = new(ShowDeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showDeleteStatement

	return p
}

func (s *ShowDeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDeleteStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowDeleteStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowDeleteStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowDeleteStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDELETE, 0)
}

func (s *ShowDeleteStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowDeleteStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *ShowDeleteStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowDeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowDeleteStatement(s)
	}
}

func (s *ShowDeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowDeleteStatement(s)
	}
}

func (s *ShowDeleteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowDeleteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowDeleteStatement() (localctx IShowDeleteStatementContext) {
	localctx = NewShowDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, DorisSQLParserRULE_showDeleteStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4425)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4426)
		p.Match(DorisSQLParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4429)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM || _la == DorisSQLParserIN {
		{
			p.SetState(4427)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4428)

			var _x = p.QualifiedName()

			localctx.(*ShowDeleteStatementContext).db = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDynamicPartitionStatementContext is an interface to support dynamic dispatch.
type IShowDynamicPartitionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	DYNAMIC() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowDynamicPartitionStatementContext differentiates from other interfaces.
	IsShowDynamicPartitionStatementContext()
}

type ShowDynamicPartitionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
}

func NewEmptyShowDynamicPartitionStatementContext() *ShowDynamicPartitionStatementContext {
	var p = new(ShowDynamicPartitionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showDynamicPartitionStatement
	return p
}

func InitEmptyShowDynamicPartitionStatementContext(p *ShowDynamicPartitionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showDynamicPartitionStatement
}

func (*ShowDynamicPartitionStatementContext) IsShowDynamicPartitionStatementContext() {}

func NewShowDynamicPartitionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDynamicPartitionStatementContext {
	var p = new(ShowDynamicPartitionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showDynamicPartitionStatement

	return p
}

func (s *ShowDynamicPartitionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDynamicPartitionStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowDynamicPartitionStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowDynamicPartitionStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowDynamicPartitionStatementContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDYNAMIC, 0)
}

func (s *ShowDynamicPartitionStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPARTITION, 0)
}

func (s *ShowDynamicPartitionStatementContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLES, 0)
}

func (s *ShowDynamicPartitionStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowDynamicPartitionStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *ShowDynamicPartitionStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowDynamicPartitionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDynamicPartitionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDynamicPartitionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowDynamicPartitionStatement(s)
	}
}

func (s *ShowDynamicPartitionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowDynamicPartitionStatement(s)
	}
}

func (s *ShowDynamicPartitionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowDynamicPartitionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowDynamicPartitionStatement() (localctx IShowDynamicPartitionStatementContext) {
	localctx = NewShowDynamicPartitionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, DorisSQLParserRULE_showDynamicPartitionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4431)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4432)
		p.Match(DorisSQLParserDYNAMIC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4433)
		p.Match(DorisSQLParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4434)
		p.Match(DorisSQLParserTABLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4437)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM || _la == DorisSQLParserIN {
		{
			p.SetState(4435)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4436)

			var _x = p.QualifiedName()

			localctx.(*ShowDynamicPartitionStatementContext).db = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowEventsStatementContext is an interface to support dynamic dispatch.
type IShowEventsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	EVENTS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowEventsStatementContext differentiates from other interfaces.
	IsShowEventsStatementContext()
}

type ShowEventsStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowEventsStatementContext() *ShowEventsStatementContext {
	var p = new(ShowEventsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showEventsStatement
	return p
}

func InitEmptyShowEventsStatementContext(p *ShowEventsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showEventsStatement
}

func (*ShowEventsStatementContext) IsShowEventsStatementContext() {}

func NewShowEventsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowEventsStatementContext {
	var p = new(ShowEventsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showEventsStatement

	return p
}

func (s *ShowEventsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowEventsStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *ShowEventsStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowEventsStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *ShowEventsStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowEventsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowEventsStatementContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEVENTS, 0)
}

func (s *ShowEventsStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowEventsStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *ShowEventsStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowEventsStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *ShowEventsStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowEventsStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowEventsStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowEventsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowEventsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowEventsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowEventsStatement(s)
	}
}

func (s *ShowEventsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowEventsStatement(s)
	}
}

func (s *ShowEventsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowEventsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowEventsStatement() (localctx IShowEventsStatementContext) {
	localctx = NewShowEventsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, DorisSQLParserRULE_showEventsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4439)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4440)
		p.Match(DorisSQLParserEVENTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4443)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM || _la == DorisSQLParserIN {
		{
			p.SetState(4441)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4442)

			var _x = p.QualifiedName()

			localctx.(*ShowEventsStatementContext).catalog = _x
		}

	}
	p.SetState(4449)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserLIKE:
		{
			p.SetState(4445)
			p.Match(DorisSQLParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4446)

			var _x = p.String_()

			localctx.(*ShowEventsStatementContext).pattern = _x
		}

	case DorisSQLParserWHERE:
		{
			p.SetState(4447)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4448)
			p.expression(0)
		}

	case DorisSQLParserEOF, DorisSQLParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowEnginesStatementContext is an interface to support dynamic dispatch.
type IShowEnginesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	ENGINES() antlr.TerminalNode

	// IsShowEnginesStatementContext differentiates from other interfaces.
	IsShowEnginesStatementContext()
}

type ShowEnginesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowEnginesStatementContext() *ShowEnginesStatementContext {
	var p = new(ShowEnginesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showEnginesStatement
	return p
}

func InitEmptyShowEnginesStatementContext(p *ShowEnginesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showEnginesStatement
}

func (*ShowEnginesStatementContext) IsShowEnginesStatementContext() {}

func NewShowEnginesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowEnginesStatementContext {
	var p = new(ShowEnginesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showEnginesStatement

	return p
}

func (s *ShowEnginesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowEnginesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowEnginesStatementContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserENGINES, 0)
}

func (s *ShowEnginesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowEnginesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowEnginesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowEnginesStatement(s)
	}
}

func (s *ShowEnginesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowEnginesStatement(s)
	}
}

func (s *ShowEnginesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowEnginesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowEnginesStatement() (localctx IShowEnginesStatementContext) {
	localctx = NewShowEnginesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, DorisSQLParserRULE_showEnginesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4451)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4452)
		p.Match(DorisSQLParserENGINES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowFrontendsStatementContext is an interface to support dynamic dispatch.
type IShowFrontendsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	FRONTENDS() antlr.TerminalNode

	// IsShowFrontendsStatementContext differentiates from other interfaces.
	IsShowFrontendsStatementContext()
}

type ShowFrontendsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowFrontendsStatementContext() *ShowFrontendsStatementContext {
	var p = new(ShowFrontendsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showFrontendsStatement
	return p
}

func InitEmptyShowFrontendsStatementContext(p *ShowFrontendsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showFrontendsStatement
}

func (*ShowFrontendsStatementContext) IsShowFrontendsStatementContext() {}

func NewShowFrontendsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowFrontendsStatementContext {
	var p = new(ShowFrontendsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showFrontendsStatement

	return p
}

func (s *ShowFrontendsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowFrontendsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowFrontendsStatementContext) FRONTENDS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFRONTENDS, 0)
}

func (s *ShowFrontendsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFrontendsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowFrontendsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowFrontendsStatement(s)
	}
}

func (s *ShowFrontendsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowFrontendsStatement(s)
	}
}

func (s *ShowFrontendsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowFrontendsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowFrontendsStatement() (localctx IShowFrontendsStatementContext) {
	localctx = NewShowFrontendsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, DorisSQLParserRULE_showFrontendsStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4454)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4455)
		p.Match(DorisSQLParserFRONTENDS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowPluginsStatementContext is an interface to support dynamic dispatch.
type IShowPluginsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	PLUGINS() antlr.TerminalNode

	// IsShowPluginsStatementContext differentiates from other interfaces.
	IsShowPluginsStatementContext()
}

type ShowPluginsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowPluginsStatementContext() *ShowPluginsStatementContext {
	var p = new(ShowPluginsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showPluginsStatement
	return p
}

func InitEmptyShowPluginsStatementContext(p *ShowPluginsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showPluginsStatement
}

func (*ShowPluginsStatementContext) IsShowPluginsStatementContext() {}

func NewShowPluginsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowPluginsStatementContext {
	var p = new(ShowPluginsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showPluginsStatement

	return p
}

func (s *ShowPluginsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowPluginsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowPluginsStatementContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPLUGINS, 0)
}

func (s *ShowPluginsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPluginsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowPluginsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowPluginsStatement(s)
	}
}

func (s *ShowPluginsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowPluginsStatement(s)
	}
}

func (s *ShowPluginsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowPluginsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowPluginsStatement() (localctx IShowPluginsStatementContext) {
	localctx = NewShowPluginsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, DorisSQLParserRULE_showPluginsStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4457)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4458)
		p.Match(DorisSQLParserPLUGINS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowRepositoriesStatementContext is an interface to support dynamic dispatch.
type IShowRepositoriesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	REPOSITORIES() antlr.TerminalNode

	// IsShowRepositoriesStatementContext differentiates from other interfaces.
	IsShowRepositoriesStatementContext()
}

type ShowRepositoriesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowRepositoriesStatementContext() *ShowRepositoriesStatementContext {
	var p = new(ShowRepositoriesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showRepositoriesStatement
	return p
}

func InitEmptyShowRepositoriesStatementContext(p *ShowRepositoriesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showRepositoriesStatement
}

func (*ShowRepositoriesStatementContext) IsShowRepositoriesStatementContext() {}

func NewShowRepositoriesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRepositoriesStatementContext {
	var p = new(ShowRepositoriesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showRepositoriesStatement

	return p
}

func (s *ShowRepositoriesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRepositoriesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowRepositoriesStatementContext) REPOSITORIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPOSITORIES, 0)
}

func (s *ShowRepositoriesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRepositoriesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRepositoriesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowRepositoriesStatement(s)
	}
}

func (s *ShowRepositoriesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowRepositoriesStatement(s)
	}
}

func (s *ShowRepositoriesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowRepositoriesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowRepositoriesStatement() (localctx IShowRepositoriesStatementContext) {
	localctx = NewShowRepositoriesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, DorisSQLParserRULE_showRepositoriesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4460)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4461)
		p.Match(DorisSQLParserREPOSITORIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowOpenTableStatementContext is an interface to support dynamic dispatch.
type IShowOpenTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	TABLES() antlr.TerminalNode

	// IsShowOpenTableStatementContext differentiates from other interfaces.
	IsShowOpenTableStatementContext()
}

type ShowOpenTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowOpenTableStatementContext() *ShowOpenTableStatementContext {
	var p = new(ShowOpenTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showOpenTableStatement
	return p
}

func InitEmptyShowOpenTableStatementContext(p *ShowOpenTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showOpenTableStatement
}

func (*ShowOpenTableStatementContext) IsShowOpenTableStatementContext() {}

func NewShowOpenTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowOpenTableStatementContext {
	var p = new(ShowOpenTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showOpenTableStatement

	return p
}

func (s *ShowOpenTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowOpenTableStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowOpenTableStatementContext) OPEN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOPEN, 0)
}

func (s *ShowOpenTableStatementContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLES, 0)
}

func (s *ShowOpenTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowOpenTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowOpenTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowOpenTableStatement(s)
	}
}

func (s *ShowOpenTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowOpenTableStatement(s)
	}
}

func (s *ShowOpenTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowOpenTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowOpenTableStatement() (localctx IShowOpenTableStatementContext) {
	localctx = NewShowOpenTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, DorisSQLParserRULE_showOpenTableStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4463)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4464)
		p.Match(DorisSQLParserOPEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4465)
		p.Match(DorisSQLParserTABLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowPrivilegesStatementContext is an interface to support dynamic dispatch.
type IShowPrivilegesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode

	// IsShowPrivilegesStatementContext differentiates from other interfaces.
	IsShowPrivilegesStatementContext()
}

type ShowPrivilegesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowPrivilegesStatementContext() *ShowPrivilegesStatementContext {
	var p = new(ShowPrivilegesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showPrivilegesStatement
	return p
}

func InitEmptyShowPrivilegesStatementContext(p *ShowPrivilegesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showPrivilegesStatement
}

func (*ShowPrivilegesStatementContext) IsShowPrivilegesStatementContext() {}

func NewShowPrivilegesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowPrivilegesStatementContext {
	var p = new(ShowPrivilegesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showPrivilegesStatement

	return p
}

func (s *ShowPrivilegesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowPrivilegesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowPrivilegesStatementContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPRIVILEGES, 0)
}

func (s *ShowPrivilegesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPrivilegesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowPrivilegesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowPrivilegesStatement(s)
	}
}

func (s *ShowPrivilegesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowPrivilegesStatement(s)
	}
}

func (s *ShowPrivilegesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowPrivilegesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowPrivilegesStatement() (localctx IShowPrivilegesStatementContext) {
	localctx = NewShowPrivilegesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, DorisSQLParserRULE_showPrivilegesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4467)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4468)
		p.Match(DorisSQLParserPRIVILEGES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowProcedureStatementContext is an interface to support dynamic dispatch.
type IShowProcedureStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	String_() IStringContext
	Expression() IExpressionContext

	// IsShowProcedureStatementContext differentiates from other interfaces.
	IsShowProcedureStatementContext()
}

type ShowProcedureStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
	where   IExpressionContext
}

func NewEmptyShowProcedureStatementContext() *ShowProcedureStatementContext {
	var p = new(ShowProcedureStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showProcedureStatement
	return p
}

func InitEmptyShowProcedureStatementContext(p *ShowProcedureStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showProcedureStatement
}

func (*ShowProcedureStatementContext) IsShowProcedureStatementContext() {}

func NewShowProcedureStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowProcedureStatementContext {
	var p = new(ShowProcedureStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showProcedureStatement

	return p
}

func (s *ShowProcedureStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowProcedureStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowProcedureStatementContext) GetWhere() IExpressionContext { return s.where }

func (s *ShowProcedureStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowProcedureStatementContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *ShowProcedureStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowProcedureStatementContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTATUS, 0)
}

func (s *ShowProcedureStatementContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROCEDURE, 0)
}

func (s *ShowProcedureStatementContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFUNCTION, 0)
}

func (s *ShowProcedureStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *ShowProcedureStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowProcedureStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowProcedureStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowProcedureStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProcedureStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowProcedureStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowProcedureStatement(s)
	}
}

func (s *ShowProcedureStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowProcedureStatement(s)
	}
}

func (s *ShowProcedureStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowProcedureStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowProcedureStatement() (localctx IShowProcedureStatementContext) {
	localctx = NewShowProcedureStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, DorisSQLParserRULE_showProcedureStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4470)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4471)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserFUNCTION || _la == DorisSQLParserPROCEDURE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4472)
		p.Match(DorisSQLParserSTATUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4477)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserLIKE:
		{
			p.SetState(4473)
			p.Match(DorisSQLParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4474)

			var _x = p.String_()

			localctx.(*ShowProcedureStatementContext).pattern = _x
		}

	case DorisSQLParserWHERE:
		{
			p.SetState(4475)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4476)

			var _x = p.expression(0)

			localctx.(*ShowProcedureStatementContext).where = _x
		}

	case DorisSQLParserEOF, DorisSQLParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowProcStatementContext is an interface to support dynamic dispatch.
type IShowProcStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPath returns the path rule contexts.
	GetPath() IStringContext

	// SetPath sets the path rule contexts.
	SetPath(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	PROC() antlr.TerminalNode
	String_() IStringContext

	// IsShowProcStatementContext differentiates from other interfaces.
	IsShowProcStatementContext()
}

type ShowProcStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	path   IStringContext
}

func NewEmptyShowProcStatementContext() *ShowProcStatementContext {
	var p = new(ShowProcStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showProcStatement
	return p
}

func InitEmptyShowProcStatementContext(p *ShowProcStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showProcStatement
}

func (*ShowProcStatementContext) IsShowProcStatementContext() {}

func NewShowProcStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowProcStatementContext {
	var p = new(ShowProcStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showProcStatement

	return p
}

func (s *ShowProcStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowProcStatementContext) GetPath() IStringContext { return s.path }

func (s *ShowProcStatementContext) SetPath(v IStringContext) { s.path = v }

func (s *ShowProcStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowProcStatementContext) PROC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROC, 0)
}

func (s *ShowProcStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowProcStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProcStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowProcStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowProcStatement(s)
	}
}

func (s *ShowProcStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowProcStatement(s)
	}
}

func (s *ShowProcStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowProcStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowProcStatement() (localctx IShowProcStatementContext) {
	localctx = NewShowProcStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, DorisSQLParserRULE_showProcStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4479)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4480)
		p.Match(DorisSQLParserPROC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4481)

		var _x = p.String_()

		localctx.(*ShowProcStatementContext).path = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowProcesslistStatementContext is an interface to support dynamic dispatch.
type IShowProcesslistStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	PROCESSLIST() antlr.TerminalNode
	FULL() antlr.TerminalNode
	FOR() antlr.TerminalNode
	String_() IStringContext

	// IsShowProcesslistStatementContext differentiates from other interfaces.
	IsShowProcesslistStatementContext()
}

type ShowProcesslistStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowProcesslistStatementContext() *ShowProcesslistStatementContext {
	var p = new(ShowProcesslistStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showProcesslistStatement
	return p
}

func InitEmptyShowProcesslistStatementContext(p *ShowProcesslistStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showProcesslistStatement
}

func (*ShowProcesslistStatementContext) IsShowProcesslistStatementContext() {}

func NewShowProcesslistStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowProcesslistStatementContext {
	var p = new(ShowProcesslistStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showProcesslistStatement

	return p
}

func (s *ShowProcesslistStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowProcesslistStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowProcesslistStatementContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROCESSLIST, 0)
}

func (s *ShowProcesslistStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFULL, 0)
}

func (s *ShowProcesslistStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFOR, 0)
}

func (s *ShowProcesslistStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowProcesslistStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProcesslistStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowProcesslistStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowProcesslistStatement(s)
	}
}

func (s *ShowProcesslistStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowProcesslistStatement(s)
	}
}

func (s *ShowProcesslistStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowProcesslistStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowProcesslistStatement() (localctx IShowProcesslistStatementContext) {
	localctx = NewShowProcesslistStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, DorisSQLParserRULE_showProcesslistStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4483)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4485)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFULL {
		{
			p.SetState(4484)
			p.Match(DorisSQLParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4487)
		p.Match(DorisSQLParserPROCESSLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4490)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFOR {
		{
			p.SetState(4488)
			p.Match(DorisSQLParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4489)
			p.String_()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowProfilelistStatementContext is an interface to support dynamic dispatch.
type IShowProfilelistStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// Getter signatures
	SHOW() antlr.TerminalNode
	PROFILELIST() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsShowProfilelistStatementContext differentiates from other interfaces.
	IsShowProfilelistStatementContext()
}

type ShowProfilelistStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	limit  antlr.Token
}

func NewEmptyShowProfilelistStatementContext() *ShowProfilelistStatementContext {
	var p = new(ShowProfilelistStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showProfilelistStatement
	return p
}

func InitEmptyShowProfilelistStatementContext(p *ShowProfilelistStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showProfilelistStatement
}

func (*ShowProfilelistStatementContext) IsShowProfilelistStatementContext() {}

func NewShowProfilelistStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowProfilelistStatementContext {
	var p = new(ShowProfilelistStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showProfilelistStatement

	return p
}

func (s *ShowProfilelistStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowProfilelistStatementContext) GetLimit() antlr.Token { return s.limit }

func (s *ShowProfilelistStatementContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *ShowProfilelistStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowProfilelistStatementContext) PROFILELIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROFILELIST, 0)
}

func (s *ShowProfilelistStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIMIT, 0)
}

func (s *ShowProfilelistStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, 0)
}

func (s *ShowProfilelistStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProfilelistStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowProfilelistStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowProfilelistStatement(s)
	}
}

func (s *ShowProfilelistStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowProfilelistStatement(s)
	}
}

func (s *ShowProfilelistStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowProfilelistStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowProfilelistStatement() (localctx IShowProfilelistStatementContext) {
	localctx = NewShowProfilelistStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, DorisSQLParserRULE_showProfilelistStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4492)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4493)
		p.Match(DorisSQLParserPROFILELIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4496)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserLIMIT {
		{
			p.SetState(4494)
			p.Match(DorisSQLParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4495)

			var _m = p.Match(DorisSQLParserINTEGER_VALUE)

			localctx.(*ShowProfilelistStatementContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowRunningQueriesStatementContext is an interface to support dynamic dispatch.
type IShowRunningQueriesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// Getter signatures
	SHOW() antlr.TerminalNode
	RUNNING() antlr.TerminalNode
	QUERIES() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsShowRunningQueriesStatementContext differentiates from other interfaces.
	IsShowRunningQueriesStatementContext()
}

type ShowRunningQueriesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	limit  antlr.Token
}

func NewEmptyShowRunningQueriesStatementContext() *ShowRunningQueriesStatementContext {
	var p = new(ShowRunningQueriesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showRunningQueriesStatement
	return p
}

func InitEmptyShowRunningQueriesStatementContext(p *ShowRunningQueriesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showRunningQueriesStatement
}

func (*ShowRunningQueriesStatementContext) IsShowRunningQueriesStatementContext() {}

func NewShowRunningQueriesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRunningQueriesStatementContext {
	var p = new(ShowRunningQueriesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showRunningQueriesStatement

	return p
}

func (s *ShowRunningQueriesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRunningQueriesStatementContext) GetLimit() antlr.Token { return s.limit }

func (s *ShowRunningQueriesStatementContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *ShowRunningQueriesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowRunningQueriesStatementContext) RUNNING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRUNNING, 0)
}

func (s *ShowRunningQueriesStatementContext) QUERIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserQUERIES, 0)
}

func (s *ShowRunningQueriesStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIMIT, 0)
}

func (s *ShowRunningQueriesStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, 0)
}

func (s *ShowRunningQueriesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRunningQueriesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRunningQueriesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowRunningQueriesStatement(s)
	}
}

func (s *ShowRunningQueriesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowRunningQueriesStatement(s)
	}
}

func (s *ShowRunningQueriesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowRunningQueriesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowRunningQueriesStatement() (localctx IShowRunningQueriesStatementContext) {
	localctx = NewShowRunningQueriesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, DorisSQLParserRULE_showRunningQueriesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4498)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4499)
		p.Match(DorisSQLParserRUNNING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4500)
		p.Match(DorisSQLParserQUERIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4503)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserLIMIT {
		{
			p.SetState(4501)
			p.Match(DorisSQLParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4502)

			var _m = p.Match(DorisSQLParserINTEGER_VALUE)

			localctx.(*ShowRunningQueriesStatementContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowStatusStatementContext is an interface to support dynamic dispatch.
type IShowStatusStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	VarType() IVarTypeContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowStatusStatementContext differentiates from other interfaces.
	IsShowStatusStatementContext()
}

type ShowStatusStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowStatusStatementContext() *ShowStatusStatementContext {
	var p = new(ShowStatusStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showStatusStatement
	return p
}

func InitEmptyShowStatusStatementContext(p *ShowStatusStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showStatusStatement
}

func (*ShowStatusStatementContext) IsShowStatusStatementContext() {}

func NewShowStatusStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStatusStatementContext {
	var p = new(ShowStatusStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showStatusStatement

	return p
}

func (s *ShowStatusStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStatusStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowStatusStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowStatusStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowStatusStatementContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTATUS, 0)
}

func (s *ShowStatusStatementContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *ShowStatusStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *ShowStatusStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowStatusStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowStatusStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowStatusStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatusStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowStatusStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowStatusStatement(s)
	}
}

func (s *ShowStatusStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowStatusStatement(s)
	}
}

func (s *ShowStatusStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowStatusStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowStatusStatement() (localctx IShowStatusStatementContext) {
	localctx = NewShowStatusStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, DorisSQLParserRULE_showStatusStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4505)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4507)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserGLOBAL || _la == DorisSQLParserLOCAL || _la == DorisSQLParserSESSION || _la == DorisSQLParserVERBOSE {
		{
			p.SetState(4506)
			p.VarType()
		}

	}
	{
		p.SetState(4509)
		p.Match(DorisSQLParserSTATUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4514)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserLIKE:
		{
			p.SetState(4510)
			p.Match(DorisSQLParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4511)

			var _x = p.String_()

			localctx.(*ShowStatusStatementContext).pattern = _x
		}

	case DorisSQLParserWHERE:
		{
			p.SetState(4512)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4513)
			p.expression(0)
		}

	case DorisSQLParserEOF, DorisSQLParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowTabletStatementContext is an interface to support dynamic dispatch.
type IShowTabletStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	TABLET() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	TABLETS() antlr.TerminalNode
	PartitionNames() IPartitionNamesContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext

	// IsShowTabletStatementContext differentiates from other interfaces.
	IsShowTabletStatementContext()
}

type ShowTabletStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowTabletStatementContext() *ShowTabletStatementContext {
	var p = new(ShowTabletStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showTabletStatement
	return p
}

func InitEmptyShowTabletStatementContext(p *ShowTabletStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showTabletStatement
}

func (*ShowTabletStatementContext) IsShowTabletStatementContext() {}

func NewShowTabletStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTabletStatementContext {
	var p = new(ShowTabletStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showTabletStatement

	return p
}

func (s *ShowTabletStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTabletStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowTabletStatementContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLET, 0)
}

func (s *ShowTabletStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, 0)
}

func (s *ShowTabletStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowTabletStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTabletStatementContext) TABLETS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLETS, 0)
}

func (s *ShowTabletStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *ShowTabletStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowTabletStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowTabletStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserORDER, 0)
}

func (s *ShowTabletStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *ShowTabletStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowTabletStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowTabletStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowTabletStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTabletStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowTabletStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowTabletStatement(s)
	}
}

func (s *ShowTabletStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowTabletStatement(s)
	}
}

func (s *ShowTabletStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowTabletStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowTabletStatement() (localctx IShowTabletStatementContext) {
	localctx = NewShowTabletStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, DorisSQLParserRULE_showTabletStatement)
	var _la int

	p.SetState(4545)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 481, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4516)
			p.Match(DorisSQLParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4517)
			p.Match(DorisSQLParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4518)
			p.Match(DorisSQLParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4519)
			p.Match(DorisSQLParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4520)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserTABLET || _la == DorisSQLParserTABLETS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4521)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4522)
			p.QualifiedName()
		}
		p.SetState(4524)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserPARTITION || _la == DorisSQLParserPARTITIONS || _la == DorisSQLParserTEMPORARY {
			{
				p.SetState(4523)
				p.PartitionNames()
			}

		}
		p.SetState(4528)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserWHERE {
			{
				p.SetState(4526)
				p.Match(DorisSQLParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4527)
				p.expression(0)
			}

		}
		p.SetState(4540)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserORDER {
			{
				p.SetState(4530)
				p.Match(DorisSQLParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4531)
				p.Match(DorisSQLParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4532)
				p.SortItem()
			}
			p.SetState(4537)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(4533)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4534)
					p.SortItem()
				}

				p.SetState(4539)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(4543)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserLIMIT {
			{
				p.SetState(4542)
				p.LimitElement()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowTransactionStatementContext is an interface to support dynamic dispatch.
type IShowTransactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowTransactionStatementContext differentiates from other interfaces.
	IsShowTransactionStatementContext()
}

type ShowTransactionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
}

func NewEmptyShowTransactionStatementContext() *ShowTransactionStatementContext {
	var p = new(ShowTransactionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showTransactionStatement
	return p
}

func InitEmptyShowTransactionStatementContext(p *ShowTransactionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showTransactionStatement
}

func (*ShowTransactionStatementContext) IsShowTransactionStatementContext() {}

func NewShowTransactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTransactionStatementContext {
	var p = new(ShowTransactionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showTransactionStatement

	return p
}

func (s *ShowTransactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTransactionStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowTransactionStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowTransactionStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowTransactionStatementContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTRANSACTION, 0)
}

func (s *ShowTransactionStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowTransactionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowTransactionStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowTransactionStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *ShowTransactionStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTransactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTransactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowTransactionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowTransactionStatement(s)
	}
}

func (s *ShowTransactionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowTransactionStatement(s)
	}
}

func (s *ShowTransactionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowTransactionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowTransactionStatement() (localctx IShowTransactionStatementContext) {
	localctx = NewShowTransactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, DorisSQLParserRULE_showTransactionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4547)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4548)
		p.Match(DorisSQLParserTRANSACTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4551)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM || _la == DorisSQLParserIN {
		{
			p.SetState(4549)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4550)

			var _x = p.QualifiedName()

			localctx.(*ShowTransactionStatementContext).db = _x
		}

	}
	p.SetState(4555)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWHERE {
		{
			p.SetState(4553)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4554)
			p.expression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowTriggersStatementContext is an interface to support dynamic dispatch.
type IShowTriggersStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	TRIGGERS() antlr.TerminalNode
	FULL() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowTriggersStatementContext differentiates from other interfaces.
	IsShowTriggersStatementContext()
}

type ShowTriggersStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowTriggersStatementContext() *ShowTriggersStatementContext {
	var p = new(ShowTriggersStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showTriggersStatement
	return p
}

func InitEmptyShowTriggersStatementContext(p *ShowTriggersStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showTriggersStatement
}

func (*ShowTriggersStatementContext) IsShowTriggersStatementContext() {}

func NewShowTriggersStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTriggersStatementContext {
	var p = new(ShowTriggersStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showTriggersStatement

	return p
}

func (s *ShowTriggersStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTriggersStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *ShowTriggersStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowTriggersStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *ShowTriggersStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowTriggersStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowTriggersStatementContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTRIGGERS, 0)
}

func (s *ShowTriggersStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFULL, 0)
}

func (s *ShowTriggersStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowTriggersStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *ShowTriggersStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTriggersStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *ShowTriggersStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowTriggersStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowTriggersStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowTriggersStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTriggersStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowTriggersStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowTriggersStatement(s)
	}
}

func (s *ShowTriggersStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowTriggersStatement(s)
	}
}

func (s *ShowTriggersStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowTriggersStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowTriggersStatement() (localctx IShowTriggersStatementContext) {
	localctx = NewShowTriggersStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, DorisSQLParserRULE_showTriggersStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4557)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4559)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFULL {
		{
			p.SetState(4558)
			p.Match(DorisSQLParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4561)
		p.Match(DorisSQLParserTRIGGERS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4564)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM || _la == DorisSQLParserIN {
		{
			p.SetState(4562)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4563)

			var _x = p.QualifiedName()

			localctx.(*ShowTriggersStatementContext).catalog = _x
		}

	}
	p.SetState(4570)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserLIKE:
		{
			p.SetState(4566)
			p.Match(DorisSQLParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4567)

			var _x = p.String_()

			localctx.(*ShowTriggersStatementContext).pattern = _x
		}

	case DorisSQLParserWHERE:
		{
			p.SetState(4568)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4569)
			p.expression(0)
		}

	case DorisSQLParserEOF, DorisSQLParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowUserPropertyStatementContext is an interface to support dynamic dispatch.
type IShowUserPropertyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode
	FOR() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	LIKE() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode

	// IsShowUserPropertyStatementContext differentiates from other interfaces.
	IsShowUserPropertyStatementContext()
}

type ShowUserPropertyStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowUserPropertyStatementContext() *ShowUserPropertyStatementContext {
	var p = new(ShowUserPropertyStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showUserPropertyStatement
	return p
}

func InitEmptyShowUserPropertyStatementContext(p *ShowUserPropertyStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showUserPropertyStatement
}

func (*ShowUserPropertyStatementContext) IsShowUserPropertyStatementContext() {}

func NewShowUserPropertyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowUserPropertyStatementContext {
	var p = new(ShowUserPropertyStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showUserPropertyStatement

	return p
}

func (s *ShowUserPropertyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowUserPropertyStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowUserPropertyStatementContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROPERTY, 0)
}

func (s *ShowUserPropertyStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFOR, 0)
}

func (s *ShowUserPropertyStatementContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ShowUserPropertyStatementContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowUserPropertyStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *ShowUserPropertyStatementContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROPERTIES, 0)
}

func (s *ShowUserPropertyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowUserPropertyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowUserPropertyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowUserPropertyStatement(s)
	}
}

func (s *ShowUserPropertyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowUserPropertyStatement(s)
	}
}

func (s *ShowUserPropertyStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowUserPropertyStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowUserPropertyStatement() (localctx IShowUserPropertyStatementContext) {
	localctx = NewShowUserPropertyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, DorisSQLParserRULE_showUserPropertyStatement)
	var _la int

	p.SetState(4592)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 491, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4572)
			p.Match(DorisSQLParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4573)
			p.Match(DorisSQLParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4576)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserFOR {
			{
				p.SetState(4574)
				p.Match(DorisSQLParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4575)
				p.String_()
			}

		}
		p.SetState(4580)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserLIKE {
			{
				p.SetState(4578)
				p.Match(DorisSQLParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4579)
				p.String_()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4582)
			p.Match(DorisSQLParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4583)
			p.Match(DorisSQLParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4586)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserFOR {
			{
				p.SetState(4584)
				p.Match(DorisSQLParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4585)
				p.String_()
			}

		}
		p.SetState(4590)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserLIKE {
			{
				p.SetState(4588)
				p.Match(DorisSQLParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4589)
				p.String_()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowVariablesStatementContext is an interface to support dynamic dispatch.
type IShowVariablesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	VARIABLES() antlr.TerminalNode
	VarType() IVarTypeContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowVariablesStatementContext differentiates from other interfaces.
	IsShowVariablesStatementContext()
}

type ShowVariablesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowVariablesStatementContext() *ShowVariablesStatementContext {
	var p = new(ShowVariablesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showVariablesStatement
	return p
}

func InitEmptyShowVariablesStatementContext(p *ShowVariablesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showVariablesStatement
}

func (*ShowVariablesStatementContext) IsShowVariablesStatementContext() {}

func NewShowVariablesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowVariablesStatementContext {
	var p = new(ShowVariablesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showVariablesStatement

	return p
}

func (s *ShowVariablesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowVariablesStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowVariablesStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowVariablesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowVariablesStatementContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVARIABLES, 0)
}

func (s *ShowVariablesStatementContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *ShowVariablesStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *ShowVariablesStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowVariablesStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowVariablesStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowVariablesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowVariablesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowVariablesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowVariablesStatement(s)
	}
}

func (s *ShowVariablesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowVariablesStatement(s)
	}
}

func (s *ShowVariablesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowVariablesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowVariablesStatement() (localctx IShowVariablesStatementContext) {
	localctx = NewShowVariablesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, DorisSQLParserRULE_showVariablesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4594)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4596)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserGLOBAL || _la == DorisSQLParserLOCAL || _la == DorisSQLParserSESSION || _la == DorisSQLParserVERBOSE {
		{
			p.SetState(4595)
			p.VarType()
		}

	}
	{
		p.SetState(4598)
		p.Match(DorisSQLParserVARIABLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4603)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserLIKE:
		{
			p.SetState(4599)
			p.Match(DorisSQLParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4600)

			var _x = p.String_()

			localctx.(*ShowVariablesStatementContext).pattern = _x
		}

	case DorisSQLParserWHERE:
		{
			p.SetState(4601)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4602)
			p.expression(0)
		}

	case DorisSQLParserEOF, DorisSQLParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowWarningStatementContext is an interface to support dynamic dispatch.
type IShowWarningStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	WARNINGS() antlr.TerminalNode
	ERRORS() antlr.TerminalNode
	LimitElement() ILimitElementContext

	// IsShowWarningStatementContext differentiates from other interfaces.
	IsShowWarningStatementContext()
}

type ShowWarningStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowWarningStatementContext() *ShowWarningStatementContext {
	var p = new(ShowWarningStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showWarningStatement
	return p
}

func InitEmptyShowWarningStatementContext(p *ShowWarningStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showWarningStatement
}

func (*ShowWarningStatementContext) IsShowWarningStatementContext() {}

func NewShowWarningStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowWarningStatementContext {
	var p = new(ShowWarningStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showWarningStatement

	return p
}

func (s *ShowWarningStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowWarningStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowWarningStatementContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWARNINGS, 0)
}

func (s *ShowWarningStatementContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserERRORS, 0)
}

func (s *ShowWarningStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowWarningStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWarningStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowWarningStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowWarningStatement(s)
	}
}

func (s *ShowWarningStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowWarningStatement(s)
	}
}

func (s *ShowWarningStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowWarningStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowWarningStatement() (localctx IShowWarningStatementContext) {
	localctx = NewShowWarningStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, DorisSQLParserRULE_showWarningStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4605)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4606)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserERRORS || _la == DorisSQLParserWARNINGS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(4608)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserLIMIT {
		{
			p.SetState(4607)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHelpStatementContext is an interface to support dynamic dispatch.
type IHelpStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HELP() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsHelpStatementContext differentiates from other interfaces.
	IsHelpStatementContext()
}

type HelpStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelpStatementContext() *HelpStatementContext {
	var p = new(HelpStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_helpStatement
	return p
}

func InitEmptyHelpStatementContext(p *HelpStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_helpStatement
}

func (*HelpStatementContext) IsHelpStatementContext() {}

func NewHelpStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelpStatementContext {
	var p = new(HelpStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_helpStatement

	return p
}

func (s *HelpStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HelpStatementContext) HELP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserHELP, 0)
}

func (s *HelpStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *HelpStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelpStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelpStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterHelpStatement(s)
	}
}

func (s *HelpStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitHelpStatement(s)
	}
}

func (s *HelpStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitHelpStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) HelpStatement() (localctx IHelpStatementContext) {
	localctx = NewHelpStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, DorisSQLParserRULE_helpStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4610)
		p.Match(DorisSQLParserHELP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4611)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateUserStatementContext is an interface to support dynamic dispatch.
type ICreateUserStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	USER() antlr.TerminalNode
	User() IUserContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AuthOption() IAuthOptionContext
	DEFAULT() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	RoleList() IRoleListContext
	Properties() IPropertiesContext

	// IsCreateUserStatementContext differentiates from other interfaces.
	IsCreateUserStatementContext()
}

type CreateUserStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateUserStatementContext() *CreateUserStatementContext {
	var p = new(CreateUserStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createUserStatement
	return p
}

func InitEmptyCreateUserStatementContext(p *CreateUserStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createUserStatement
}

func (*CreateUserStatementContext) IsCreateUserStatementContext() {}

func NewCreateUserStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUserStatementContext {
	var p = new(CreateUserStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createUserStatement

	return p
}

func (s *CreateUserStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUserStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateUserStatementContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSER, 0)
}

func (s *CreateUserStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *CreateUserStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *CreateUserStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *CreateUserStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *CreateUserStatementContext) AuthOption() IAuthOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthOptionContext)
}

func (s *CreateUserStatementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDEFAULT, 0)
}

func (s *CreateUserStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROLE, 0)
}

func (s *CreateUserStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *CreateUserStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateUserStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateUserStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateUserStatement(s)
	}
}

func (s *CreateUserStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateUserStatement(s)
	}
}

func (s *CreateUserStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateUserStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateUserStatement() (localctx ICreateUserStatementContext) {
	localctx = NewCreateUserStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, DorisSQLParserRULE_createUserStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4613)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4614)
		p.Match(DorisSQLParserUSER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4618)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(4615)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4616)
			p.Match(DorisSQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4617)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4620)
		p.User()
	}
	p.SetState(4622)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIDENTIFIED {
		{
			p.SetState(4621)
			p.AuthOption()
		}

	}
	p.SetState(4627)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserDEFAULT {
		{
			p.SetState(4624)
			p.Match(DorisSQLParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4625)
			p.Match(DorisSQLParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4626)
			p.RoleList()
		}

	}
	p.SetState(4630)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(4629)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropUserStatementContext is an interface to support dynamic dispatch.
type IDropUserStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	USER() antlr.TerminalNode
	User() IUserContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropUserStatementContext differentiates from other interfaces.
	IsDropUserStatementContext()
}

type DropUserStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropUserStatementContext() *DropUserStatementContext {
	var p = new(DropUserStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropUserStatement
	return p
}

func InitEmptyDropUserStatementContext(p *DropUserStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropUserStatement
}

func (*DropUserStatementContext) IsDropUserStatementContext() {}

func NewDropUserStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropUserStatementContext {
	var p = new(DropUserStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropUserStatement

	return p
}

func (s *DropUserStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropUserStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropUserStatementContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSER, 0)
}

func (s *DropUserStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *DropUserStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *DropUserStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *DropUserStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropUserStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropUserStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropUserStatement(s)
	}
}

func (s *DropUserStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropUserStatement(s)
	}
}

func (s *DropUserStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropUserStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropUserStatement() (localctx IDropUserStatementContext) {
	localctx = NewDropUserStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, DorisSQLParserRULE_dropUserStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4632)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4633)
		p.Match(DorisSQLParserUSER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4636)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(4634)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4635)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4638)
		p.User()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterUserStatementContext is an interface to support dynamic dispatch.
type IAlterUserStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	USER() antlr.TerminalNode
	User() IUserContext
	AuthOption() IAuthOptionContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	NONE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	RoleList() IRoleListContext
	SET() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsAlterUserStatementContext differentiates from other interfaces.
	IsAlterUserStatementContext()
}

type AlterUserStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterUserStatementContext() *AlterUserStatementContext {
	var p = new(AlterUserStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterUserStatement
	return p
}

func InitEmptyAlterUserStatementContext(p *AlterUserStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterUserStatement
}

func (*AlterUserStatementContext) IsAlterUserStatementContext() {}

func NewAlterUserStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterUserStatementContext {
	var p = new(AlterUserStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_alterUserStatement

	return p
}

func (s *AlterUserStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterUserStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *AlterUserStatementContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSER, 0)
}

func (s *AlterUserStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *AlterUserStatementContext) AuthOption() IAuthOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthOptionContext)
}

func (s *AlterUserStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *AlterUserStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *AlterUserStatementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDEFAULT, 0)
}

func (s *AlterUserStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROLE, 0)
}

func (s *AlterUserStatementContext) NONE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNONE, 0)
}

func (s *AlterUserStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, 0)
}

func (s *AlterUserStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *AlterUserStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *AlterUserStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AlterUserStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterUserStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAlterUserStatement(s)
	}
}

func (s *AlterUserStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAlterUserStatement(s)
	}
}

func (s *AlterUserStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAlterUserStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AlterUserStatement() (localctx IAlterUserStatementContext) {
	localctx = NewAlterUserStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, DorisSQLParserRULE_alterUserStatement)
	var _la int

	p.SetState(4673)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 504, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4640)
			p.Match(DorisSQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4641)
			p.Match(DorisSQLParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4644)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserIF {
			{
				p.SetState(4642)
				p.Match(DorisSQLParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4643)
				p.Match(DorisSQLParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4646)
			p.User()
		}
		{
			p.SetState(4647)
			p.AuthOption()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4649)
			p.Match(DorisSQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4650)
			p.Match(DorisSQLParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4653)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserIF {
			{
				p.SetState(4651)
				p.Match(DorisSQLParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4652)
				p.Match(DorisSQLParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4655)
			p.User()
		}
		{
			p.SetState(4656)
			p.Match(DorisSQLParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4657)
			p.Match(DorisSQLParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4661)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 502, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4658)
				p.Match(DorisSQLParserNONE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(4659)
				p.Match(DorisSQLParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(4660)
				p.RoleList()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4663)
			p.Match(DorisSQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4664)
			p.Match(DorisSQLParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4667)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserIF {
			{
				p.SetState(4665)
				p.Match(DorisSQLParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4666)
				p.Match(DorisSQLParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4669)
			p.User()
		}
		{
			p.SetState(4670)
			p.Match(DorisSQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4671)
			p.Properties()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowUserStatementContext is an interface to support dynamic dispatch.
type IShowUserStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	USER() antlr.TerminalNode
	USERS() antlr.TerminalNode

	// IsShowUserStatementContext differentiates from other interfaces.
	IsShowUserStatementContext()
}

type ShowUserStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowUserStatementContext() *ShowUserStatementContext {
	var p = new(ShowUserStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showUserStatement
	return p
}

func InitEmptyShowUserStatementContext(p *ShowUserStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showUserStatement
}

func (*ShowUserStatementContext) IsShowUserStatementContext() {}

func NewShowUserStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowUserStatementContext {
	var p = new(ShowUserStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showUserStatement

	return p
}

func (s *ShowUserStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowUserStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowUserStatementContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSER, 0)
}

func (s *ShowUserStatementContext) USERS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSERS, 0)
}

func (s *ShowUserStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowUserStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowUserStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowUserStatement(s)
	}
}

func (s *ShowUserStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowUserStatement(s)
	}
}

func (s *ShowUserStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowUserStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowUserStatement() (localctx IShowUserStatementContext) {
	localctx = NewShowUserStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, DorisSQLParserRULE_showUserStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4675)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4676)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserUSER || _la == DorisSQLParserUSERS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowAuthenticationStatementContext is an interface to support dynamic dispatch.
type IShowAuthenticationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsShowAuthenticationStatementContext differentiates from other interfaces.
	IsShowAuthenticationStatementContext()
}

type ShowAuthenticationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowAuthenticationStatementContext() *ShowAuthenticationStatementContext {
	var p = new(ShowAuthenticationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showAuthenticationStatement
	return p
}

func InitEmptyShowAuthenticationStatementContext(p *ShowAuthenticationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showAuthenticationStatement
}

func (*ShowAuthenticationStatementContext) IsShowAuthenticationStatementContext() {}

func NewShowAuthenticationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowAuthenticationStatementContext {
	var p = new(ShowAuthenticationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showAuthenticationStatement

	return p
}

func (s *ShowAuthenticationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowAuthenticationStatementContext) CopyAll(ctx *ShowAuthenticationStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ShowAuthenticationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAuthenticationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowAllAuthenticationContext struct {
	ShowAuthenticationStatementContext
}

func NewShowAllAuthenticationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAllAuthenticationContext {
	var p = new(ShowAllAuthenticationContext)

	InitEmptyShowAuthenticationStatementContext(&p.ShowAuthenticationStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowAuthenticationStatementContext))

	return p
}

func (s *ShowAllAuthenticationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAllAuthenticationContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowAllAuthenticationContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, 0)
}

func (s *ShowAllAuthenticationContext) AUTHENTICATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAUTHENTICATION, 0)
}

func (s *ShowAllAuthenticationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowAllAuthentication(s)
	}
}

func (s *ShowAllAuthenticationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowAllAuthentication(s)
	}
}

func (s *ShowAllAuthenticationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowAllAuthentication(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowAuthenticationForUserContext struct {
	ShowAuthenticationStatementContext
}

func NewShowAuthenticationForUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAuthenticationForUserContext {
	var p = new(ShowAuthenticationForUserContext)

	InitEmptyShowAuthenticationStatementContext(&p.ShowAuthenticationStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowAuthenticationStatementContext))

	return p
}

func (s *ShowAuthenticationForUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAuthenticationForUserContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowAuthenticationForUserContext) AUTHENTICATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAUTHENTICATION, 0)
}

func (s *ShowAuthenticationForUserContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFOR, 0)
}

func (s *ShowAuthenticationForUserContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *ShowAuthenticationForUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowAuthenticationForUser(s)
	}
}

func (s *ShowAuthenticationForUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowAuthenticationForUser(s)
	}
}

func (s *ShowAuthenticationForUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowAuthenticationForUser(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowAuthenticationStatement() (localctx IShowAuthenticationStatementContext) {
	localctx = NewShowAuthenticationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, DorisSQLParserRULE_showAuthenticationStatement)
	var _la int

	p.SetState(4687)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 506, p.GetParserRuleContext()) {
	case 1:
		localctx = NewShowAllAuthenticationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4678)
			p.Match(DorisSQLParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4679)
			p.Match(DorisSQLParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4680)
			p.Match(DorisSQLParserAUTHENTICATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewShowAuthenticationForUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4681)
			p.Match(DorisSQLParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4682)
			p.Match(DorisSQLParserAUTHENTICATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4685)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserFOR {
			{
				p.SetState(4683)
				p.Match(DorisSQLParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4684)
				p.User()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExecuteAsStatementContext is an interface to support dynamic dispatch.
type IExecuteAsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXECUTE() antlr.TerminalNode
	AS() antlr.TerminalNode
	User() IUserContext
	WITH() antlr.TerminalNode
	NO() antlr.TerminalNode
	REVERT() antlr.TerminalNode

	// IsExecuteAsStatementContext differentiates from other interfaces.
	IsExecuteAsStatementContext()
}

type ExecuteAsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteAsStatementContext() *ExecuteAsStatementContext {
	var p = new(ExecuteAsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_executeAsStatement
	return p
}

func InitEmptyExecuteAsStatementContext(p *ExecuteAsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_executeAsStatement
}

func (*ExecuteAsStatementContext) IsExecuteAsStatementContext() {}

func NewExecuteAsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteAsStatementContext {
	var p = new(ExecuteAsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_executeAsStatement

	return p
}

func (s *ExecuteAsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteAsStatementContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXECUTE, 0)
}

func (s *ExecuteAsStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *ExecuteAsStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *ExecuteAsStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *ExecuteAsStatementContext) NO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNO, 0)
}

func (s *ExecuteAsStatementContext) REVERT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREVERT, 0)
}

func (s *ExecuteAsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteAsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteAsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterExecuteAsStatement(s)
	}
}

func (s *ExecuteAsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitExecuteAsStatement(s)
	}
}

func (s *ExecuteAsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitExecuteAsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ExecuteAsStatement() (localctx IExecuteAsStatementContext) {
	localctx = NewExecuteAsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, DorisSQLParserRULE_executeAsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4689)
		p.Match(DorisSQLParserEXECUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4690)
		p.Match(DorisSQLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4691)
		p.User()
	}
	p.SetState(4695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWITH {
		{
			p.SetState(4692)
			p.Match(DorisSQLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4693)
			p.Match(DorisSQLParserNO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4694)
			p.Match(DorisSQLParserREVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateRoleStatementContext is an interface to support dynamic dispatch.
type ICreateRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	RoleList() IRoleListContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Comment() ICommentContext

	// IsCreateRoleStatementContext differentiates from other interfaces.
	IsCreateRoleStatementContext()
}

type CreateRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateRoleStatementContext() *CreateRoleStatementContext {
	var p = new(CreateRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createRoleStatement
	return p
}

func InitEmptyCreateRoleStatementContext(p *CreateRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createRoleStatement
}

func (*CreateRoleStatementContext) IsCreateRoleStatementContext() {}

func NewCreateRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRoleStatementContext {
	var p = new(CreateRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createRoleStatement

	return p
}

func (s *CreateRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRoleStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateRoleStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROLE, 0)
}

func (s *CreateRoleStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *CreateRoleStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *CreateRoleStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *CreateRoleStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *CreateRoleStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRoleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateRoleStatement(s)
	}
}

func (s *CreateRoleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateRoleStatement(s)
	}
}

func (s *CreateRoleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateRoleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateRoleStatement() (localctx ICreateRoleStatementContext) {
	localctx = NewCreateRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, DorisSQLParserRULE_createRoleStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4697)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4698)
		p.Match(DorisSQLParserROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4702)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(4699)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4700)
			p.Match(DorisSQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4701)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4704)
		p.RoleList()
	}
	p.SetState(4706)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserCOMMENT {
		{
			p.SetState(4705)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterRoleStatementContext is an interface to support dynamic dispatch.
type IAlterRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	RoleList() IRoleListContext
	SET() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	EQ() antlr.TerminalNode
	String_() IStringContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsAlterRoleStatementContext differentiates from other interfaces.
	IsAlterRoleStatementContext()
}

type AlterRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterRoleStatementContext() *AlterRoleStatementContext {
	var p = new(AlterRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterRoleStatement
	return p
}

func InitEmptyAlterRoleStatementContext(p *AlterRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterRoleStatement
}

func (*AlterRoleStatementContext) IsAlterRoleStatementContext() {}

func NewAlterRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterRoleStatementContext {
	var p = new(AlterRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_alterRoleStatement

	return p
}

func (s *AlterRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterRoleStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *AlterRoleStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROLE, 0)
}

func (s *AlterRoleStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *AlterRoleStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *AlterRoleStatementContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOMMENT, 0)
}

func (s *AlterRoleStatementContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEQ, 0)
}

func (s *AlterRoleStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AlterRoleStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *AlterRoleStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *AlterRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterRoleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAlterRoleStatement(s)
	}
}

func (s *AlterRoleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAlterRoleStatement(s)
	}
}

func (s *AlterRoleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAlterRoleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AlterRoleStatement() (localctx IAlterRoleStatementContext) {
	localctx = NewAlterRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, DorisSQLParserRULE_alterRoleStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4708)
		p.Match(DorisSQLParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4709)
		p.Match(DorisSQLParserROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4712)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(4710)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4711)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4714)
		p.RoleList()
	}
	{
		p.SetState(4715)
		p.Match(DorisSQLParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4716)
		p.Match(DorisSQLParserCOMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4717)
		p.Match(DorisSQLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4718)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropRoleStatementContext is an interface to support dynamic dispatch.
type IDropRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	RoleList() IRoleListContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropRoleStatementContext differentiates from other interfaces.
	IsDropRoleStatementContext()
}

type DropRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropRoleStatementContext() *DropRoleStatementContext {
	var p = new(DropRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropRoleStatement
	return p
}

func InitEmptyDropRoleStatementContext(p *DropRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropRoleStatement
}

func (*DropRoleStatementContext) IsDropRoleStatementContext() {}

func NewDropRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropRoleStatementContext {
	var p = new(DropRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropRoleStatement

	return p
}

func (s *DropRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropRoleStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropRoleStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROLE, 0)
}

func (s *DropRoleStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *DropRoleStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *DropRoleStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *DropRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropRoleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropRoleStatement(s)
	}
}

func (s *DropRoleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropRoleStatement(s)
	}
}

func (s *DropRoleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropRoleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropRoleStatement() (localctx IDropRoleStatementContext) {
	localctx = NewDropRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, DorisSQLParserRULE_dropRoleStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4720)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4721)
		p.Match(DorisSQLParserROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4724)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(4722)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4723)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4726)
		p.RoleList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowRolesStatementContext is an interface to support dynamic dispatch.
type IShowRolesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	ROLES() antlr.TerminalNode

	// IsShowRolesStatementContext differentiates from other interfaces.
	IsShowRolesStatementContext()
}

type ShowRolesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowRolesStatementContext() *ShowRolesStatementContext {
	var p = new(ShowRolesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showRolesStatement
	return p
}

func InitEmptyShowRolesStatementContext(p *ShowRolesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showRolesStatement
}

func (*ShowRolesStatementContext) IsShowRolesStatementContext() {}

func NewShowRolesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRolesStatementContext {
	var p = new(ShowRolesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showRolesStatement

	return p
}

func (s *ShowRolesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRolesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowRolesStatementContext) ROLES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROLES, 0)
}

func (s *ShowRolesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRolesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRolesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowRolesStatement(s)
	}
}

func (s *ShowRolesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowRolesStatement(s)
	}
}

func (s *ShowRolesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowRolesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowRolesStatement() (localctx IShowRolesStatementContext) {
	localctx = NewShowRolesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, DorisSQLParserRULE_showRolesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4728)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4729)
		p.Match(DorisSQLParserROLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantRoleStatementContext is an interface to support dynamic dispatch.
type IGrantRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsGrantRoleStatementContext differentiates from other interfaces.
	IsGrantRoleStatementContext()
}

type GrantRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantRoleStatementContext() *GrantRoleStatementContext {
	var p = new(GrantRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_grantRoleStatement
	return p
}

func InitEmptyGrantRoleStatementContext(p *GrantRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_grantRoleStatement
}

func (*GrantRoleStatementContext) IsGrantRoleStatementContext() {}

func NewGrantRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantRoleStatementContext {
	var p = new(GrantRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_grantRoleStatement

	return p
}

func (s *GrantRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantRoleStatementContext) CopyAll(ctx *GrantRoleStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *GrantRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type GrantRoleToUserContext struct {
	GrantRoleStatementContext
}

func NewGrantRoleToUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantRoleToUserContext {
	var p = new(GrantRoleToUserContext)

	InitEmptyGrantRoleStatementContext(&p.GrantRoleStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantRoleStatementContext))

	return p
}

func (s *GrantRoleToUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRoleToUserContext) GRANT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGRANT, 0)
}

func (s *GrantRoleToUserContext) IdentifierOrStringList() IIdentifierOrStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringListContext)
}

func (s *GrantRoleToUserContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTO, 0)
}

func (s *GrantRoleToUserContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *GrantRoleToUserContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSER, 0)
}

func (s *GrantRoleToUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterGrantRoleToUser(s)
	}
}

func (s *GrantRoleToUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitGrantRoleToUser(s)
	}
}

func (s *GrantRoleToUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitGrantRoleToUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type GrantRoleToRoleContext struct {
	GrantRoleStatementContext
}

func NewGrantRoleToRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantRoleToRoleContext {
	var p = new(GrantRoleToRoleContext)

	InitEmptyGrantRoleStatementContext(&p.GrantRoleStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantRoleStatementContext))

	return p
}

func (s *GrantRoleToRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRoleToRoleContext) GRANT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGRANT, 0)
}

func (s *GrantRoleToRoleContext) IdentifierOrStringList() IIdentifierOrStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringListContext)
}

func (s *GrantRoleToRoleContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTO, 0)
}

func (s *GrantRoleToRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROLE, 0)
}

func (s *GrantRoleToRoleContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *GrantRoleToRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterGrantRoleToRole(s)
	}
}

func (s *GrantRoleToRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitGrantRoleToRole(s)
	}
}

func (s *GrantRoleToRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitGrantRoleToRole(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) GrantRoleStatement() (localctx IGrantRoleStatementContext) {
	localctx = NewGrantRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, DorisSQLParserRULE_grantRoleStatement)
	p.SetState(4745)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 513, p.GetParserRuleContext()) {
	case 1:
		localctx = NewGrantRoleToUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4731)
			p.Match(DorisSQLParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4732)
			p.IdentifierOrStringList()
		}
		{
			p.SetState(4733)
			p.Match(DorisSQLParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4735)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 512, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4734)
				p.Match(DorisSQLParserUSER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4737)
			p.User()
		}

	case 2:
		localctx = NewGrantRoleToRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4739)
			p.Match(DorisSQLParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4740)
			p.IdentifierOrStringList()
		}
		{
			p.SetState(4741)
			p.Match(DorisSQLParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4742)
			p.Match(DorisSQLParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4743)
			p.IdentifierOrString()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRevokeRoleStatementContext is an interface to support dynamic dispatch.
type IRevokeRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRevokeRoleStatementContext differentiates from other interfaces.
	IsRevokeRoleStatementContext()
}

type RevokeRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevokeRoleStatementContext() *RevokeRoleStatementContext {
	var p = new(RevokeRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_revokeRoleStatement
	return p
}

func InitEmptyRevokeRoleStatementContext(p *RevokeRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_revokeRoleStatement
}

func (*RevokeRoleStatementContext) IsRevokeRoleStatementContext() {}

func NewRevokeRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokeRoleStatementContext {
	var p = new(RevokeRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_revokeRoleStatement

	return p
}

func (s *RevokeRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokeRoleStatementContext) CopyAll(ctx *RevokeRoleStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RevokeRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RevokeRoleFromUserContext struct {
	RevokeRoleStatementContext
}

func NewRevokeRoleFromUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeRoleFromUserContext {
	var p = new(RevokeRoleFromUserContext)

	InitEmptyRevokeRoleStatementContext(&p.RevokeRoleStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokeRoleStatementContext))

	return p
}

func (s *RevokeRoleFromUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeRoleFromUserContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREVOKE, 0)
}

func (s *RevokeRoleFromUserContext) IdentifierOrStringList() IIdentifierOrStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringListContext)
}

func (s *RevokeRoleFromUserContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *RevokeRoleFromUserContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *RevokeRoleFromUserContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSER, 0)
}

func (s *RevokeRoleFromUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRevokeRoleFromUser(s)
	}
}

func (s *RevokeRoleFromUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRevokeRoleFromUser(s)
	}
}

func (s *RevokeRoleFromUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRevokeRoleFromUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeRoleFromRoleContext struct {
	RevokeRoleStatementContext
}

func NewRevokeRoleFromRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeRoleFromRoleContext {
	var p = new(RevokeRoleFromRoleContext)

	InitEmptyRevokeRoleStatementContext(&p.RevokeRoleStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokeRoleStatementContext))

	return p
}

func (s *RevokeRoleFromRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeRoleFromRoleContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREVOKE, 0)
}

func (s *RevokeRoleFromRoleContext) IdentifierOrStringList() IIdentifierOrStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringListContext)
}

func (s *RevokeRoleFromRoleContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *RevokeRoleFromRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROLE, 0)
}

func (s *RevokeRoleFromRoleContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *RevokeRoleFromRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRevokeRoleFromRole(s)
	}
}

func (s *RevokeRoleFromRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRevokeRoleFromRole(s)
	}
}

func (s *RevokeRoleFromRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRevokeRoleFromRole(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) RevokeRoleStatement() (localctx IRevokeRoleStatementContext) {
	localctx = NewRevokeRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, DorisSQLParserRULE_revokeRoleStatement)
	p.SetState(4761)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 515, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRevokeRoleFromUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4747)
			p.Match(DorisSQLParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4748)
			p.IdentifierOrStringList()
		}
		{
			p.SetState(4749)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4751)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 514, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4750)
				p.Match(DorisSQLParserUSER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4753)
			p.User()
		}

	case 2:
		localctx = NewRevokeRoleFromRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4755)
			p.Match(DorisSQLParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4756)
			p.IdentifierOrStringList()
		}
		{
			p.SetState(4757)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4758)
			p.Match(DorisSQLParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4759)
			p.IdentifierOrString()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetRoleStatementContext is an interface to support dynamic dispatch.
type ISetRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	NONE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode
	RoleList() IRoleListContext

	// IsSetRoleStatementContext differentiates from other interfaces.
	IsSetRoleStatementContext()
}

type SetRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetRoleStatementContext() *SetRoleStatementContext {
	var p = new(SetRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_setRoleStatement
	return p
}

func InitEmptySetRoleStatementContext(p *SetRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_setRoleStatement
}

func (*SetRoleStatementContext) IsSetRoleStatementContext() {}

func NewSetRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetRoleStatementContext {
	var p = new(SetRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_setRoleStatement

	return p
}

func (s *SetRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetRoleStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *SetRoleStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROLE, 0)
}

func (s *SetRoleStatementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDEFAULT, 0)
}

func (s *SetRoleStatementContext) NONE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNONE, 0)
}

func (s *SetRoleStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, 0)
}

func (s *SetRoleStatementContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXCEPT, 0)
}

func (s *SetRoleStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *SetRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetRoleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSetRoleStatement(s)
	}
}

func (s *SetRoleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSetRoleStatement(s)
	}
}

func (s *SetRoleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSetRoleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SetRoleStatement() (localctx ISetRoleStatementContext) {
	localctx = NewSetRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, DorisSQLParserRULE_setRoleStatement)
	var _la int

	p.SetState(4779)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 517, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4763)
			p.Match(DorisSQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4764)
			p.Match(DorisSQLParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4765)
			p.Match(DorisSQLParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4766)
			p.Match(DorisSQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4767)
			p.Match(DorisSQLParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4768)
			p.Match(DorisSQLParserNONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4769)
			p.Match(DorisSQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4770)
			p.Match(DorisSQLParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4771)
			p.Match(DorisSQLParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4774)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserEXCEPT {
			{
				p.SetState(4772)
				p.Match(DorisSQLParserEXCEPT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4773)
				p.RoleList()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4776)
			p.Match(DorisSQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4777)
			p.Match(DorisSQLParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4778)
			p.RoleList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetDefaultRoleStatementContext is an interface to support dynamic dispatch.
type ISetDefaultRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	TO() antlr.TerminalNode
	User() IUserContext
	NONE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	RoleList() IRoleListContext

	// IsSetDefaultRoleStatementContext differentiates from other interfaces.
	IsSetDefaultRoleStatementContext()
}

type SetDefaultRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetDefaultRoleStatementContext() *SetDefaultRoleStatementContext {
	var p = new(SetDefaultRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_setDefaultRoleStatement
	return p
}

func InitEmptySetDefaultRoleStatementContext(p *SetDefaultRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_setDefaultRoleStatement
}

func (*SetDefaultRoleStatementContext) IsSetDefaultRoleStatementContext() {}

func NewSetDefaultRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetDefaultRoleStatementContext {
	var p = new(SetDefaultRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_setDefaultRoleStatement

	return p
}

func (s *SetDefaultRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetDefaultRoleStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *SetDefaultRoleStatementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDEFAULT, 0)
}

func (s *SetDefaultRoleStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROLE, 0)
}

func (s *SetDefaultRoleStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTO, 0)
}

func (s *SetDefaultRoleStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *SetDefaultRoleStatementContext) NONE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNONE, 0)
}

func (s *SetDefaultRoleStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, 0)
}

func (s *SetDefaultRoleStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *SetDefaultRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetDefaultRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetDefaultRoleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSetDefaultRoleStatement(s)
	}
}

func (s *SetDefaultRoleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSetDefaultRoleStatement(s)
	}
}

func (s *SetDefaultRoleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSetDefaultRoleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SetDefaultRoleStatement() (localctx ISetDefaultRoleStatementContext) {
	localctx = NewSetDefaultRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, DorisSQLParserRULE_setDefaultRoleStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4781)
		p.Match(DorisSQLParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4782)
		p.Match(DorisSQLParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4783)
		p.Match(DorisSQLParserROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4787)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 518, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4784)
			p.Match(DorisSQLParserNONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(4785)
			p.Match(DorisSQLParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(4786)
			p.RoleList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(4789)
		p.Match(DorisSQLParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4790)
		p.User()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantRevokeClauseContext is an interface to support dynamic dispatch.
type IGrantRevokeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	User() IUserContext
	ROLE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	USER() antlr.TerminalNode

	// IsGrantRevokeClauseContext differentiates from other interfaces.
	IsGrantRevokeClauseContext()
}

type GrantRevokeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantRevokeClauseContext() *GrantRevokeClauseContext {
	var p = new(GrantRevokeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_grantRevokeClause
	return p
}

func InitEmptyGrantRevokeClauseContext(p *GrantRevokeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_grantRevokeClause
}

func (*GrantRevokeClauseContext) IsGrantRevokeClauseContext() {}

func NewGrantRevokeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantRevokeClauseContext {
	var p = new(GrantRevokeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_grantRevokeClause

	return p
}

func (s *GrantRevokeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantRevokeClauseContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *GrantRevokeClauseContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROLE, 0)
}

func (s *GrantRevokeClauseContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *GrantRevokeClauseContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSER, 0)
}

func (s *GrantRevokeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRevokeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantRevokeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterGrantRevokeClause(s)
	}
}

func (s *GrantRevokeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitGrantRevokeClause(s)
	}
}

func (s *GrantRevokeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitGrantRevokeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) GrantRevokeClause() (localctx IGrantRevokeClauseContext) {
	localctx = NewGrantRevokeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, DorisSQLParserRULE_grantRevokeClause)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4798)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 520, p.GetParserRuleContext()) {
	case 1:
		p.SetState(4793)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 519, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4792)
				p.Match(DorisSQLParserUSER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4795)
			p.User()
		}

	case 2:
		{
			p.SetState(4796)
			p.Match(DorisSQLParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4797)
			p.IdentifierOrString()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantPrivilegeStatementContext is an interface to support dynamic dispatch.
type IGrantPrivilegeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsGrantPrivilegeStatementContext differentiates from other interfaces.
	IsGrantPrivilegeStatementContext()
}

type GrantPrivilegeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantPrivilegeStatementContext() *GrantPrivilegeStatementContext {
	var p = new(GrantPrivilegeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_grantPrivilegeStatement
	return p
}

func InitEmptyGrantPrivilegeStatementContext(p *GrantPrivilegeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_grantPrivilegeStatement
}

func (*GrantPrivilegeStatementContext) IsGrantPrivilegeStatementContext() {}

func NewGrantPrivilegeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantPrivilegeStatementContext {
	var p = new(GrantPrivilegeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_grantPrivilegeStatement

	return p
}

func (s *GrantPrivilegeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantPrivilegeStatementContext) CopyAll(ctx *GrantPrivilegeStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *GrantPrivilegeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantPrivilegeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type GrantOnAllContext struct {
	GrantPrivilegeStatementContext
	isAll antlr.Token
}

func NewGrantOnAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantOnAllContext {
	var p = new(GrantOnAllContext)

	InitEmptyGrantPrivilegeStatementContext(&p.GrantPrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantPrivilegeStatementContext))

	return p
}

func (s *GrantOnAllContext) GetIsAll() antlr.Token { return s.isAll }

func (s *GrantOnAllContext) SetIsAll(v antlr.Token) { s.isAll = v }

func (s *GrantOnAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOnAllContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserGRANT)
}

func (s *GrantOnAllContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGRANT, i)
}

func (s *GrantOnAllContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *GrantOnAllContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *GrantOnAllContext) AllALL() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserALL)
}

func (s *GrantOnAllContext) ALL(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, i)
}

func (s *GrantOnAllContext) PrivObjectTypePlural() IPrivObjectTypePluralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectTypePluralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectTypePluralContext)
}

func (s *GrantOnAllContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTO, 0)
}

func (s *GrantOnAllContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *GrantOnAllContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *GrantOnAllContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATABASES, 0)
}

func (s *GrantOnAllContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATABASE, 0)
}

func (s *GrantOnAllContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *GrantOnAllContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *GrantOnAllContext) OPTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOPTION, 0)
}

func (s *GrantOnAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterGrantOnAll(s)
	}
}

func (s *GrantOnAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitGrantOnAll(s)
	}
}

func (s *GrantOnAllContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitGrantOnAll(s)

	default:
		return t.VisitChildren(s)
	}
}

type GrantOnFuncContext struct {
	GrantPrivilegeStatementContext
}

func NewGrantOnFuncContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantOnFuncContext {
	var p = new(GrantOnFuncContext)

	InitEmptyGrantPrivilegeStatementContext(&p.GrantPrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantPrivilegeStatementContext))

	return p
}

func (s *GrantOnFuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOnFuncContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserGRANT)
}

func (s *GrantOnFuncContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGRANT, i)
}

func (s *GrantOnFuncContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *GrantOnFuncContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *GrantOnFuncContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFUNCTION, 0)
}

func (s *GrantOnFuncContext) PrivFunctionObjectNameList() IPrivFunctionObjectNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivFunctionObjectNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivFunctionObjectNameListContext)
}

func (s *GrantOnFuncContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTO, 0)
}

func (s *GrantOnFuncContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *GrantOnFuncContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGLOBAL, 0)
}

func (s *GrantOnFuncContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *GrantOnFuncContext) OPTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOPTION, 0)
}

func (s *GrantOnFuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterGrantOnFunc(s)
	}
}

func (s *GrantOnFuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitGrantOnFunc(s)
	}
}

func (s *GrantOnFuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitGrantOnFunc(s)

	default:
		return t.VisitChildren(s)
	}
}

type GrantOnPrimaryObjContext struct {
	GrantPrivilegeStatementContext
}

func NewGrantOnPrimaryObjContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantOnPrimaryObjContext {
	var p = new(GrantOnPrimaryObjContext)

	InitEmptyGrantPrivilegeStatementContext(&p.GrantPrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantPrivilegeStatementContext))

	return p
}

func (s *GrantOnPrimaryObjContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOnPrimaryObjContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserGRANT)
}

func (s *GrantOnPrimaryObjContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGRANT, i)
}

func (s *GrantOnPrimaryObjContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *GrantOnPrimaryObjContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *GrantOnPrimaryObjContext) PrivObjectType() IPrivObjectTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectTypeContext)
}

func (s *GrantOnPrimaryObjContext) PrivObjectNameList() IPrivObjectNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectNameListContext)
}

func (s *GrantOnPrimaryObjContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTO, 0)
}

func (s *GrantOnPrimaryObjContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *GrantOnPrimaryObjContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *GrantOnPrimaryObjContext) OPTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOPTION, 0)
}

func (s *GrantOnPrimaryObjContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterGrantOnPrimaryObj(s)
	}
}

func (s *GrantOnPrimaryObjContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitGrantOnPrimaryObj(s)
	}
}

func (s *GrantOnPrimaryObjContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitGrantOnPrimaryObj(s)

	default:
		return t.VisitChildren(s)
	}
}

type GrantOnTableBriefContext struct {
	GrantPrivilegeStatementContext
}

func NewGrantOnTableBriefContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantOnTableBriefContext {
	var p = new(GrantOnTableBriefContext)

	InitEmptyGrantPrivilegeStatementContext(&p.GrantPrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantPrivilegeStatementContext))

	return p
}

func (s *GrantOnTableBriefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOnTableBriefContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserGRANT)
}

func (s *GrantOnTableBriefContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGRANT, i)
}

func (s *GrantOnTableBriefContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *GrantOnTableBriefContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *GrantOnTableBriefContext) PrivObjectNameList() IPrivObjectNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectNameListContext)
}

func (s *GrantOnTableBriefContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTO, 0)
}

func (s *GrantOnTableBriefContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *GrantOnTableBriefContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *GrantOnTableBriefContext) OPTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOPTION, 0)
}

func (s *GrantOnTableBriefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterGrantOnTableBrief(s)
	}
}

func (s *GrantOnTableBriefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitGrantOnTableBrief(s)
	}
}

func (s *GrantOnTableBriefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitGrantOnTableBrief(s)

	default:
		return t.VisitChildren(s)
	}
}

type GrantOnUserContext struct {
	GrantPrivilegeStatementContext
}

func NewGrantOnUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantOnUserContext {
	var p = new(GrantOnUserContext)

	InitEmptyGrantPrivilegeStatementContext(&p.GrantPrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantPrivilegeStatementContext))

	return p
}

func (s *GrantOnUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOnUserContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserGRANT)
}

func (s *GrantOnUserContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGRANT, i)
}

func (s *GrantOnUserContext) IMPERSONATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIMPERSONATE, 0)
}

func (s *GrantOnUserContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *GrantOnUserContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSER, 0)
}

func (s *GrantOnUserContext) AllUser() []IUserContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserContext); ok {
			len++
		}
	}

	tst := make([]IUserContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserContext); ok {
			tst[i] = t.(IUserContext)
			i++
		}
	}

	return tst
}

func (s *GrantOnUserContext) User(i int) IUserContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *GrantOnUserContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTO, 0)
}

func (s *GrantOnUserContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *GrantOnUserContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *GrantOnUserContext) OPTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOPTION, 0)
}

func (s *GrantOnUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterGrantOnUser(s)
	}
}

func (s *GrantOnUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitGrantOnUser(s)
	}
}

func (s *GrantOnUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitGrantOnUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type GrantOnSystemContext struct {
	GrantPrivilegeStatementContext
}

func NewGrantOnSystemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantOnSystemContext {
	var p = new(GrantOnSystemContext)

	InitEmptyGrantPrivilegeStatementContext(&p.GrantPrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantPrivilegeStatementContext))

	return p
}

func (s *GrantOnSystemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOnSystemContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserGRANT)
}

func (s *GrantOnSystemContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGRANT, i)
}

func (s *GrantOnSystemContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *GrantOnSystemContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *GrantOnSystemContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSYSTEM, 0)
}

func (s *GrantOnSystemContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTO, 0)
}

func (s *GrantOnSystemContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *GrantOnSystemContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *GrantOnSystemContext) OPTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOPTION, 0)
}

func (s *GrantOnSystemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterGrantOnSystem(s)
	}
}

func (s *GrantOnSystemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitGrantOnSystem(s)
	}
}

func (s *GrantOnSystemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitGrantOnSystem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) GrantPrivilegeStatement() (localctx IGrantPrivilegeStatementContext) {
	localctx = NewGrantPrivilegeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, DorisSQLParserRULE_grantPrivilegeStatement)
	var _la int

	p.SetState(4888)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 530, p.GetParserRuleContext()) {
	case 1:
		localctx = NewGrantOnUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4800)
			p.Match(DorisSQLParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4801)
			p.Match(DorisSQLParserIMPERSONATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4802)
			p.Match(DorisSQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4803)
			p.Match(DorisSQLParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4804)
			p.User()
		}
		p.SetState(4809)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(4805)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4806)
				p.User()
			}

			p.SetState(4811)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4812)
			p.Match(DorisSQLParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4813)
			p.GrantRevokeClause()
		}
		p.SetState(4817)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserWITH {
			{
				p.SetState(4814)
				p.Match(DorisSQLParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4815)
				p.Match(DorisSQLParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4816)
				p.Match(DorisSQLParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		localctx = NewGrantOnTableBriefContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4819)
			p.Match(DorisSQLParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4820)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4821)
			p.Match(DorisSQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4822)
			p.PrivObjectNameList()
		}
		{
			p.SetState(4823)
			p.Match(DorisSQLParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4824)
			p.GrantRevokeClause()
		}
		p.SetState(4828)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserWITH {
			{
				p.SetState(4825)
				p.Match(DorisSQLParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4826)
				p.Match(DorisSQLParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4827)
				p.Match(DorisSQLParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		localctx = NewGrantOnFuncContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4830)
			p.Match(DorisSQLParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4831)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4832)
			p.Match(DorisSQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4834)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserGLOBAL {
			{
				p.SetState(4833)
				p.Match(DorisSQLParserGLOBAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4836)
			p.Match(DorisSQLParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4837)
			p.PrivFunctionObjectNameList()
		}
		{
			p.SetState(4838)
			p.Match(DorisSQLParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4839)
			p.GrantRevokeClause()
		}
		p.SetState(4843)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserWITH {
			{
				p.SetState(4840)
				p.Match(DorisSQLParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4841)
				p.Match(DorisSQLParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4842)
				p.Match(DorisSQLParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		localctx = NewGrantOnSystemContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4845)
			p.Match(DorisSQLParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4846)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4847)
			p.Match(DorisSQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4848)
			p.Match(DorisSQLParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4849)
			p.Match(DorisSQLParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4850)
			p.GrantRevokeClause()
		}
		p.SetState(4854)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserWITH {
			{
				p.SetState(4851)
				p.Match(DorisSQLParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4852)
				p.Match(DorisSQLParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4853)
				p.Match(DorisSQLParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		localctx = NewGrantOnPrimaryObjContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4856)
			p.Match(DorisSQLParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4857)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4858)
			p.Match(DorisSQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4859)
			p.PrivObjectType()
		}
		{
			p.SetState(4860)
			p.PrivObjectNameList()
		}
		{
			p.SetState(4861)
			p.Match(DorisSQLParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4862)
			p.GrantRevokeClause()
		}
		p.SetState(4866)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserWITH {
			{
				p.SetState(4863)
				p.Match(DorisSQLParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4864)
				p.Match(DorisSQLParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4865)
				p.Match(DorisSQLParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		localctx = NewGrantOnAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4868)
			p.Match(DorisSQLParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4869)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4870)
			p.Match(DorisSQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4871)
			p.Match(DorisSQLParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4872)
			p.PrivObjectTypePlural()
		}
		p.SetState(4879)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 528, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4873)
				p.Match(DorisSQLParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4874)

				var _m = p.Match(DorisSQLParserALL)

				localctx.(*GrantOnAllContext).isAll = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4875)
				p.Match(DorisSQLParserDATABASES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 528, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(4876)
				p.Match(DorisSQLParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4877)
				p.Match(DorisSQLParserDATABASE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4878)
				p.IdentifierOrString()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4881)
			p.Match(DorisSQLParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4882)
			p.GrantRevokeClause()
		}
		p.SetState(4886)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserWITH {
			{
				p.SetState(4883)
				p.Match(DorisSQLParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4884)
				p.Match(DorisSQLParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4885)
				p.Match(DorisSQLParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRevokePrivilegeStatementContext is an interface to support dynamic dispatch.
type IRevokePrivilegeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRevokePrivilegeStatementContext differentiates from other interfaces.
	IsRevokePrivilegeStatementContext()
}

type RevokePrivilegeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevokePrivilegeStatementContext() *RevokePrivilegeStatementContext {
	var p = new(RevokePrivilegeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_revokePrivilegeStatement
	return p
}

func InitEmptyRevokePrivilegeStatementContext(p *RevokePrivilegeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_revokePrivilegeStatement
}

func (*RevokePrivilegeStatementContext) IsRevokePrivilegeStatementContext() {}

func NewRevokePrivilegeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokePrivilegeStatementContext {
	var p = new(RevokePrivilegeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_revokePrivilegeStatement

	return p
}

func (s *RevokePrivilegeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokePrivilegeStatementContext) CopyAll(ctx *RevokePrivilegeStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RevokePrivilegeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokePrivilegeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RevokeOnPrimaryObjContext struct {
	RevokePrivilegeStatementContext
}

func NewRevokeOnPrimaryObjContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeOnPrimaryObjContext {
	var p = new(RevokeOnPrimaryObjContext)

	InitEmptyRevokePrivilegeStatementContext(&p.RevokePrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokePrivilegeStatementContext))

	return p
}

func (s *RevokeOnPrimaryObjContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeOnPrimaryObjContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREVOKE, 0)
}

func (s *RevokeOnPrimaryObjContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *RevokeOnPrimaryObjContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *RevokeOnPrimaryObjContext) PrivObjectType() IPrivObjectTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectTypeContext)
}

func (s *RevokeOnPrimaryObjContext) PrivObjectNameList() IPrivObjectNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectNameListContext)
}

func (s *RevokeOnPrimaryObjContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *RevokeOnPrimaryObjContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *RevokeOnPrimaryObjContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRevokeOnPrimaryObj(s)
	}
}

func (s *RevokeOnPrimaryObjContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRevokeOnPrimaryObj(s)
	}
}

func (s *RevokeOnPrimaryObjContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRevokeOnPrimaryObj(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeOnTableBriefContext struct {
	RevokePrivilegeStatementContext
}

func NewRevokeOnTableBriefContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeOnTableBriefContext {
	var p = new(RevokeOnTableBriefContext)

	InitEmptyRevokePrivilegeStatementContext(&p.RevokePrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokePrivilegeStatementContext))

	return p
}

func (s *RevokeOnTableBriefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeOnTableBriefContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREVOKE, 0)
}

func (s *RevokeOnTableBriefContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *RevokeOnTableBriefContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *RevokeOnTableBriefContext) PrivObjectNameList() IPrivObjectNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectNameListContext)
}

func (s *RevokeOnTableBriefContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *RevokeOnTableBriefContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *RevokeOnTableBriefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRevokeOnTableBrief(s)
	}
}

func (s *RevokeOnTableBriefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRevokeOnTableBrief(s)
	}
}

func (s *RevokeOnTableBriefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRevokeOnTableBrief(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeOnAllContext struct {
	RevokePrivilegeStatementContext
	isAll antlr.Token
}

func NewRevokeOnAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeOnAllContext {
	var p = new(RevokeOnAllContext)

	InitEmptyRevokePrivilegeStatementContext(&p.RevokePrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokePrivilegeStatementContext))

	return p
}

func (s *RevokeOnAllContext) GetIsAll() antlr.Token { return s.isAll }

func (s *RevokeOnAllContext) SetIsAll(v antlr.Token) { s.isAll = v }

func (s *RevokeOnAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeOnAllContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREVOKE, 0)
}

func (s *RevokeOnAllContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *RevokeOnAllContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *RevokeOnAllContext) AllALL() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserALL)
}

func (s *RevokeOnAllContext) ALL(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, i)
}

func (s *RevokeOnAllContext) PrivObjectTypePlural() IPrivObjectTypePluralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectTypePluralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectTypePluralContext)
}

func (s *RevokeOnAllContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *RevokeOnAllContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *RevokeOnAllContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *RevokeOnAllContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATABASES, 0)
}

func (s *RevokeOnAllContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATABASE, 0)
}

func (s *RevokeOnAllContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *RevokeOnAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRevokeOnAll(s)
	}
}

func (s *RevokeOnAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRevokeOnAll(s)
	}
}

func (s *RevokeOnAllContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRevokeOnAll(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeOnUserContext struct {
	RevokePrivilegeStatementContext
}

func NewRevokeOnUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeOnUserContext {
	var p = new(RevokeOnUserContext)

	InitEmptyRevokePrivilegeStatementContext(&p.RevokePrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokePrivilegeStatementContext))

	return p
}

func (s *RevokeOnUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeOnUserContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREVOKE, 0)
}

func (s *RevokeOnUserContext) IMPERSONATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIMPERSONATE, 0)
}

func (s *RevokeOnUserContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *RevokeOnUserContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSER, 0)
}

func (s *RevokeOnUserContext) AllUser() []IUserContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserContext); ok {
			len++
		}
	}

	tst := make([]IUserContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserContext); ok {
			tst[i] = t.(IUserContext)
			i++
		}
	}

	return tst
}

func (s *RevokeOnUserContext) User(i int) IUserContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *RevokeOnUserContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *RevokeOnUserContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *RevokeOnUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRevokeOnUser(s)
	}
}

func (s *RevokeOnUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRevokeOnUser(s)
	}
}

func (s *RevokeOnUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRevokeOnUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeOnFuncContext struct {
	RevokePrivilegeStatementContext
}

func NewRevokeOnFuncContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeOnFuncContext {
	var p = new(RevokeOnFuncContext)

	InitEmptyRevokePrivilegeStatementContext(&p.RevokePrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokePrivilegeStatementContext))

	return p
}

func (s *RevokeOnFuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeOnFuncContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREVOKE, 0)
}

func (s *RevokeOnFuncContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *RevokeOnFuncContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *RevokeOnFuncContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFUNCTION, 0)
}

func (s *RevokeOnFuncContext) PrivFunctionObjectNameList() IPrivFunctionObjectNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivFunctionObjectNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivFunctionObjectNameListContext)
}

func (s *RevokeOnFuncContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *RevokeOnFuncContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *RevokeOnFuncContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGLOBAL, 0)
}

func (s *RevokeOnFuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRevokeOnFunc(s)
	}
}

func (s *RevokeOnFuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRevokeOnFunc(s)
	}
}

func (s *RevokeOnFuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRevokeOnFunc(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeOnSystemContext struct {
	RevokePrivilegeStatementContext
}

func NewRevokeOnSystemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeOnSystemContext {
	var p = new(RevokeOnSystemContext)

	InitEmptyRevokePrivilegeStatementContext(&p.RevokePrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokePrivilegeStatementContext))

	return p
}

func (s *RevokeOnSystemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeOnSystemContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREVOKE, 0)
}

func (s *RevokeOnSystemContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *RevokeOnSystemContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *RevokeOnSystemContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSYSTEM, 0)
}

func (s *RevokeOnSystemContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *RevokeOnSystemContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *RevokeOnSystemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRevokeOnSystem(s)
	}
}

func (s *RevokeOnSystemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRevokeOnSystem(s)
	}
}

func (s *RevokeOnSystemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRevokeOnSystem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) RevokePrivilegeStatement() (localctx IRevokePrivilegeStatementContext) {
	localctx = NewRevokePrivilegeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, DorisSQLParserRULE_revokePrivilegeStatement)
	var _la int

	p.SetState(4954)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 534, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRevokeOnUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4890)
			p.Match(DorisSQLParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4891)
			p.Match(DorisSQLParserIMPERSONATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4892)
			p.Match(DorisSQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4893)
			p.Match(DorisSQLParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4894)
			p.User()
		}
		p.SetState(4899)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(4895)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4896)
				p.User()
			}

			p.SetState(4901)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4902)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4903)
			p.GrantRevokeClause()
		}

	case 2:
		localctx = NewRevokeOnTableBriefContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4905)
			p.Match(DorisSQLParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4906)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4907)
			p.Match(DorisSQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4908)
			p.PrivObjectNameList()
		}
		{
			p.SetState(4909)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4910)
			p.GrantRevokeClause()
		}

	case 3:
		localctx = NewRevokeOnFuncContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4912)
			p.Match(DorisSQLParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4913)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4914)
			p.Match(DorisSQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4916)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserGLOBAL {
			{
				p.SetState(4915)
				p.Match(DorisSQLParserGLOBAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4918)
			p.Match(DorisSQLParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4919)
			p.PrivFunctionObjectNameList()
		}
		{
			p.SetState(4920)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4921)
			p.GrantRevokeClause()
		}

	case 4:
		localctx = NewRevokeOnSystemContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4923)
			p.Match(DorisSQLParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4924)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4925)
			p.Match(DorisSQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4926)
			p.Match(DorisSQLParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4927)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4928)
			p.GrantRevokeClause()
		}

	case 5:
		localctx = NewRevokeOnPrimaryObjContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4930)
			p.Match(DorisSQLParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4931)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4932)
			p.Match(DorisSQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4933)
			p.PrivObjectType()
		}
		{
			p.SetState(4934)
			p.PrivObjectNameList()
		}
		{
			p.SetState(4935)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4936)
			p.GrantRevokeClause()
		}

	case 6:
		localctx = NewRevokeOnAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4938)
			p.Match(DorisSQLParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4939)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4940)
			p.Match(DorisSQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4941)
			p.Match(DorisSQLParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4942)
			p.PrivObjectTypePlural()
		}
		p.SetState(4949)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 533, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4943)
				p.Match(DorisSQLParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4944)

				var _m = p.Match(DorisSQLParserALL)

				localctx.(*RevokeOnAllContext).isAll = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4945)
				p.Match(DorisSQLParserDATABASES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 533, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(4946)
				p.Match(DorisSQLParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4947)
				p.Match(DorisSQLParserDATABASE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4948)
				p.IdentifierOrString()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4951)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4952)
			p.GrantRevokeClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowGrantsStatementContext is an interface to support dynamic dispatch.
type IShowGrantsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	GRANTS() antlr.TerminalNode
	FOR() antlr.TerminalNode
	User() IUserContext
	USER() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsShowGrantsStatementContext differentiates from other interfaces.
	IsShowGrantsStatementContext()
}

type ShowGrantsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowGrantsStatementContext() *ShowGrantsStatementContext {
	var p = new(ShowGrantsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showGrantsStatement
	return p
}

func InitEmptyShowGrantsStatementContext(p *ShowGrantsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showGrantsStatement
}

func (*ShowGrantsStatementContext) IsShowGrantsStatementContext() {}

func NewShowGrantsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowGrantsStatementContext {
	var p = new(ShowGrantsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showGrantsStatement

	return p
}

func (s *ShowGrantsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowGrantsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowGrantsStatementContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGRANTS, 0)
}

func (s *ShowGrantsStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFOR, 0)
}

func (s *ShowGrantsStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *ShowGrantsStatementContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSER, 0)
}

func (s *ShowGrantsStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROLE, 0)
}

func (s *ShowGrantsStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *ShowGrantsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGrantsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowGrantsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowGrantsStatement(s)
	}
}

func (s *ShowGrantsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowGrantsStatement(s)
	}
}

func (s *ShowGrantsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowGrantsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowGrantsStatement() (localctx IShowGrantsStatementContext) {
	localctx = NewShowGrantsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, DorisSQLParserRULE_showGrantsStatement)
	p.SetState(4970)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 536, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4956)
			p.Match(DorisSQLParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4957)
			p.Match(DorisSQLParserGRANTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4958)
			p.Match(DorisSQLParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4959)
			p.Match(DorisSQLParserGRANTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4960)
			p.Match(DorisSQLParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4962)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 535, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4961)
				p.Match(DorisSQLParserUSER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4964)
			p.User()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4965)
			p.Match(DorisSQLParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4966)
			p.Match(DorisSQLParserGRANTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4967)
			p.Match(DorisSQLParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4968)
			p.Match(DorisSQLParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4969)
			p.IdentifierOrString()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAuthOptionContext is an interface to support dynamic dispatch.
type IAuthOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAuthOptionContext differentiates from other interfaces.
	IsAuthOptionContext()
}

type AuthOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAuthOptionContext() *AuthOptionContext {
	var p = new(AuthOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_authOption
	return p
}

func InitEmptyAuthOptionContext(p *AuthOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_authOption
}

func (*AuthOptionContext) IsAuthOptionContext() {}

func NewAuthOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AuthOptionContext {
	var p = new(AuthOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_authOption

	return p
}

func (s *AuthOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *AuthOptionContext) CopyAll(ctx *AuthOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AuthWithPluginContext struct {
	AuthOptionContext
}

func NewAuthWithPluginContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AuthWithPluginContext {
	var p = new(AuthWithPluginContext)

	InitEmptyAuthOptionContext(&p.AuthOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*AuthOptionContext))

	return p
}

func (s *AuthWithPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthWithPluginContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIDENTIFIED, 0)
}

func (s *AuthWithPluginContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *AuthWithPluginContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AuthWithPluginContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AuthWithPluginContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *AuthWithPluginContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *AuthWithPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAuthWithPlugin(s)
	}
}

func (s *AuthWithPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAuthWithPlugin(s)
	}
}

func (s *AuthWithPluginContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAuthWithPlugin(s)

	default:
		return t.VisitChildren(s)
	}
}

type AuthWithoutPluginContext struct {
	AuthOptionContext
}

func NewAuthWithoutPluginContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AuthWithoutPluginContext {
	var p = new(AuthWithoutPluginContext)

	InitEmptyAuthOptionContext(&p.AuthOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*AuthOptionContext))

	return p
}

func (s *AuthWithoutPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthWithoutPluginContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIDENTIFIED, 0)
}

func (s *AuthWithoutPluginContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *AuthWithoutPluginContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AuthWithoutPluginContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPASSWORD, 0)
}

func (s *AuthWithoutPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAuthWithoutPlugin(s)
	}
}

func (s *AuthWithoutPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAuthWithoutPlugin(s)
	}
}

func (s *AuthWithoutPluginContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAuthWithoutPlugin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AuthOption() (localctx IAuthOptionContext) {
	localctx = NewAuthOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, DorisSQLParserRULE_authOption)
	var _la int

	p.SetState(4985)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 539, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAuthWithoutPluginContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4972)
			p.Match(DorisSQLParserIDENTIFIED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4973)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4975)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserPASSWORD {
			{
				p.SetState(4974)
				p.Match(DorisSQLParserPASSWORD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4977)
			p.String_()
		}

	case 2:
		localctx = NewAuthWithPluginContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4978)
			p.Match(DorisSQLParserIDENTIFIED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4979)
			p.Match(DorisSQLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4980)
			p.IdentifierOrString()
		}
		p.SetState(4983)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserAS || _la == DorisSQLParserBY {
			{
				p.SetState(4981)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserAS || _la == DorisSQLParserBY) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(4982)
				p.String_()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivObjectNameContext is an interface to support dynamic dispatch.
type IPrivObjectNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierOrStringOrStar() []IIdentifierOrStringOrStarContext
	IdentifierOrStringOrStar(i int) IIdentifierOrStringOrStarContext

	// IsPrivObjectNameContext differentiates from other interfaces.
	IsPrivObjectNameContext()
}

type PrivObjectNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivObjectNameContext() *PrivObjectNameContext {
	var p = new(PrivObjectNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_privObjectName
	return p
}

func InitEmptyPrivObjectNameContext(p *PrivObjectNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_privObjectName
}

func (*PrivObjectNameContext) IsPrivObjectNameContext() {}

func NewPrivObjectNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivObjectNameContext {
	var p = new(PrivObjectNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_privObjectName

	return p
}

func (s *PrivObjectNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivObjectNameContext) AllIdentifierOrStringOrStar() []IIdentifierOrStringOrStarContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringOrStarContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringOrStarContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringOrStarContext); ok {
			tst[i] = t.(IIdentifierOrStringOrStarContext)
			i++
		}
	}

	return tst
}

func (s *PrivObjectNameContext) IdentifierOrStringOrStar(i int) IIdentifierOrStringOrStarContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringOrStarContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringOrStarContext)
}

func (s *PrivObjectNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivObjectNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivObjectNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPrivObjectName(s)
	}
}

func (s *PrivObjectNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPrivObjectName(s)
	}
}

func (s *PrivObjectNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPrivObjectName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PrivObjectName() (localctx IPrivObjectNameContext) {
	localctx = NewPrivObjectNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, DorisSQLParserRULE_privObjectName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4987)
		p.IdentifierOrStringOrStar()
	}
	p.SetState(4990)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserT__0 {
		{
			p.SetState(4988)
			p.Match(DorisSQLParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4989)
			p.IdentifierOrStringOrStar()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivObjectNameListContext is an interface to support dynamic dispatch.
type IPrivObjectNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrivObjectName() []IPrivObjectNameContext
	PrivObjectName(i int) IPrivObjectNameContext

	// IsPrivObjectNameListContext differentiates from other interfaces.
	IsPrivObjectNameListContext()
}

type PrivObjectNameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivObjectNameListContext() *PrivObjectNameListContext {
	var p = new(PrivObjectNameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_privObjectNameList
	return p
}

func InitEmptyPrivObjectNameListContext(p *PrivObjectNameListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_privObjectNameList
}

func (*PrivObjectNameListContext) IsPrivObjectNameListContext() {}

func NewPrivObjectNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivObjectNameListContext {
	var p = new(PrivObjectNameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_privObjectNameList

	return p
}

func (s *PrivObjectNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivObjectNameListContext) AllPrivObjectName() []IPrivObjectNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivObjectNameContext); ok {
			len++
		}
	}

	tst := make([]IPrivObjectNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivObjectNameContext); ok {
			tst[i] = t.(IPrivObjectNameContext)
			i++
		}
	}

	return tst
}

func (s *PrivObjectNameListContext) PrivObjectName(i int) IPrivObjectNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectNameContext)
}

func (s *PrivObjectNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivObjectNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivObjectNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPrivObjectNameList(s)
	}
}

func (s *PrivObjectNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPrivObjectNameList(s)
	}
}

func (s *PrivObjectNameListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPrivObjectNameList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PrivObjectNameList() (localctx IPrivObjectNameListContext) {
	localctx = NewPrivObjectNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, DorisSQLParserRULE_privObjectNameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4992)
		p.PrivObjectName()
	}
	p.SetState(4997)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(4993)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4994)
			p.PrivObjectName()
		}

		p.SetState(4999)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivFunctionObjectNameListContext is an interface to support dynamic dispatch.
type IPrivFunctionObjectNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	AllTypeList() []ITypeListContext
	TypeList(i int) ITypeListContext

	// IsPrivFunctionObjectNameListContext differentiates from other interfaces.
	IsPrivFunctionObjectNameListContext()
}

type PrivFunctionObjectNameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivFunctionObjectNameListContext() *PrivFunctionObjectNameListContext {
	var p = new(PrivFunctionObjectNameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_privFunctionObjectNameList
	return p
}

func InitEmptyPrivFunctionObjectNameListContext(p *PrivFunctionObjectNameListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_privFunctionObjectNameList
}

func (*PrivFunctionObjectNameListContext) IsPrivFunctionObjectNameListContext() {}

func NewPrivFunctionObjectNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivFunctionObjectNameListContext {
	var p = new(PrivFunctionObjectNameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_privFunctionObjectNameList

	return p
}

func (s *PrivFunctionObjectNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivFunctionObjectNameListContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *PrivFunctionObjectNameListContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *PrivFunctionObjectNameListContext) AllTypeList() []ITypeListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeListContext); ok {
			len++
		}
	}

	tst := make([]ITypeListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeListContext); ok {
			tst[i] = t.(ITypeListContext)
			i++
		}
	}

	return tst
}

func (s *PrivFunctionObjectNameListContext) TypeList(i int) ITypeListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *PrivFunctionObjectNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivFunctionObjectNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivFunctionObjectNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPrivFunctionObjectNameList(s)
	}
}

func (s *PrivFunctionObjectNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPrivFunctionObjectNameList(s)
	}
}

func (s *PrivFunctionObjectNameListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPrivFunctionObjectNameList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PrivFunctionObjectNameList() (localctx IPrivFunctionObjectNameListContext) {
	localctx = NewPrivFunctionObjectNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, DorisSQLParserRULE_privFunctionObjectNameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5000)
		p.QualifiedName()
	}
	{
		p.SetState(5001)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5002)
		p.TypeList()
	}
	{
		p.SetState(5003)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5012)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(5004)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5005)
			p.QualifiedName()
		}
		{
			p.SetState(5006)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5007)
			p.TypeList()
		}
		{
			p.SetState(5008)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(5014)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeTypeListContext is an interface to support dynamic dispatch.
type IPrivilegeTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrivilegeType() []IPrivilegeTypeContext
	PrivilegeType(i int) IPrivilegeTypeContext

	// IsPrivilegeTypeListContext differentiates from other interfaces.
	IsPrivilegeTypeListContext()
}

type PrivilegeTypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeTypeListContext() *PrivilegeTypeListContext {
	var p = new(PrivilegeTypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_privilegeTypeList
	return p
}

func InitEmptyPrivilegeTypeListContext(p *PrivilegeTypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_privilegeTypeList
}

func (*PrivilegeTypeListContext) IsPrivilegeTypeListContext() {}

func NewPrivilegeTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeTypeListContext {
	var p = new(PrivilegeTypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_privilegeTypeList

	return p
}

func (s *PrivilegeTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeTypeListContext) AllPrivilegeType() []IPrivilegeTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivilegeTypeContext); ok {
			len++
		}
	}

	tst := make([]IPrivilegeTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivilegeTypeContext); ok {
			tst[i] = t.(IPrivilegeTypeContext)
			i++
		}
	}

	return tst
}

func (s *PrivilegeTypeListContext) PrivilegeType(i int) IPrivilegeTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeContext)
}

func (s *PrivilegeTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPrivilegeTypeList(s)
	}
}

func (s *PrivilegeTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPrivilegeTypeList(s)
	}
}

func (s *PrivilegeTypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPrivilegeTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PrivilegeTypeList() (localctx IPrivilegeTypeListContext) {
	localctx = NewPrivilegeTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, DorisSQLParserRULE_privilegeTypeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5015)
		p.PrivilegeType()
	}
	p.SetState(5020)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(5016)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5017)
			p.PrivilegeType()
		}

		p.SetState(5022)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeTypeContext is an interface to support dynamic dispatch.
type IPrivilegeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	APPLY() antlr.TerminalNode
	BLACKLIST() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	CNGROUP() antlr.TerminalNode
	PIPE() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	DROP() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	FILE() antlr.TerminalNode
	IMPERSONATE() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	GRANT() antlr.TerminalNode
	NODE() antlr.TerminalNode
	OPERATE() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	REPOSITORY() antlr.TerminalNode
	REFRESH() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	USAGE() antlr.TerminalNode

	// IsPrivilegeTypeContext differentiates from other interfaces.
	IsPrivilegeTypeContext()
}

type PrivilegeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeTypeContext() *PrivilegeTypeContext {
	var p = new(PrivilegeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_privilegeType
	return p
}

func InitEmptyPrivilegeTypeContext(p *PrivilegeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_privilegeType
}

func (*PrivilegeTypeContext) IsPrivilegeTypeContext() {}

func NewPrivilegeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeTypeContext {
	var p = new(PrivilegeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_privilegeType

	return p
}

func (s *PrivilegeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeTypeContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, 0)
}

func (s *PrivilegeTypeContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPRIVILEGES, 0)
}

func (s *PrivilegeTypeContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *PrivilegeTypeContext) APPLY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAPPLY, 0)
}

func (s *PrivilegeTypeContext) BLACKLIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBLACKLIST, 0)
}

func (s *PrivilegeTypeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *PrivilegeTypeContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATABASE, 0)
}

func (s *PrivilegeTypeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *PrivilegeTypeContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVIEW, 0)
}

func (s *PrivilegeTypeContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFUNCTION, 0)
}

func (s *PrivilegeTypeContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGLOBAL, 0)
}

func (s *PrivilegeTypeContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMATERIALIZED, 0)
}

func (s *PrivilegeTypeContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRESOURCE, 0)
}

func (s *PrivilegeTypeContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGROUP, 0)
}

func (s *PrivilegeTypeContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXTERNAL, 0)
}

func (s *PrivilegeTypeContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCATALOG, 0)
}

func (s *PrivilegeTypeContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTORAGE, 0)
}

func (s *PrivilegeTypeContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVOLUME, 0)
}

func (s *PrivilegeTypeContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWAREHOUSE, 0)
}

func (s *PrivilegeTypeContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCNGROUP, 0)
}

func (s *PrivilegeTypeContext) PIPE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPIPE, 0)
}

func (s *PrivilegeTypeContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDELETE, 0)
}

func (s *PrivilegeTypeContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *PrivilegeTypeContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXPORT, 0)
}

func (s *PrivilegeTypeContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFILE, 0)
}

func (s *PrivilegeTypeContext) IMPERSONATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIMPERSONATE, 0)
}

func (s *PrivilegeTypeContext) INSERT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINSERT, 0)
}

func (s *PrivilegeTypeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGRANT, 0)
}

func (s *PrivilegeTypeContext) NODE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNODE, 0)
}

func (s *PrivilegeTypeContext) OPERATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOPERATE, 0)
}

func (s *PrivilegeTypeContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPLUGIN, 0)
}

func (s *PrivilegeTypeContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPOSITORY, 0)
}

func (s *PrivilegeTypeContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREFRESH, 0)
}

func (s *PrivilegeTypeContext) SELECT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSELECT, 0)
}

func (s *PrivilegeTypeContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUPDATE, 0)
}

func (s *PrivilegeTypeContext) USAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSAGE, 0)
}

func (s *PrivilegeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPrivilegeType(s)
	}
}

func (s *PrivilegeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPrivilegeType(s)
	}
}

func (s *PrivilegeTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPrivilegeType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PrivilegeType() (localctx IPrivilegeTypeContext) {
	localctx = NewPrivilegeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, DorisSQLParserRULE_privilegeType)
	var _la int

	p.SetState(5066)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserALL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5023)
			p.Match(DorisSQLParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5025)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserPRIVILEGES {
			{
				p.SetState(5024)
				p.Match(DorisSQLParserPRIVILEGES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DorisSQLParserALTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5027)
			p.Match(DorisSQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserAPPLY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5028)
			p.Match(DorisSQLParserAPPLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserBLACKLIST:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5029)
			p.Match(DorisSQLParserBLACKLIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserCREATE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5030)
			p.Match(DorisSQLParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5049)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 545, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5031)
				p.Match(DorisSQLParserDATABASE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(5032)
				p.Match(DorisSQLParserTABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(5033)
				p.Match(DorisSQLParserVIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 4:
			{
				p.SetState(5034)
				p.Match(DorisSQLParserFUNCTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 5:
			{
				p.SetState(5035)
				p.Match(DorisSQLParserGLOBAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5036)
				p.Match(DorisSQLParserFUNCTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 6:
			{
				p.SetState(5037)
				p.Match(DorisSQLParserMATERIALIZED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5038)
				p.Match(DorisSQLParserVIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 7:
			{
				p.SetState(5039)
				p.Match(DorisSQLParserRESOURCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 8:
			{
				p.SetState(5040)
				p.Match(DorisSQLParserRESOURCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5041)
				p.Match(DorisSQLParserGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 9:
			{
				p.SetState(5042)
				p.Match(DorisSQLParserEXTERNAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5043)
				p.Match(DorisSQLParserCATALOG)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 10:
			{
				p.SetState(5044)
				p.Match(DorisSQLParserSTORAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5045)
				p.Match(DorisSQLParserVOLUME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 11:
			{
				p.SetState(5046)
				p.Match(DorisSQLParserWAREHOUSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 12:
			{
				p.SetState(5047)
				p.Match(DorisSQLParserCNGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 13:
			{
				p.SetState(5048)
				p.Match(DorisSQLParserPIPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case DorisSQLParserDELETE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5051)
			p.Match(DorisSQLParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserDROP:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5052)
			p.Match(DorisSQLParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserEXPORT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5053)
			p.Match(DorisSQLParserEXPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserFILE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5054)
			p.Match(DorisSQLParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserIMPERSONATE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5055)
			p.Match(DorisSQLParserIMPERSONATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserINSERT:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5056)
			p.Match(DorisSQLParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserGRANT:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5057)
			p.Match(DorisSQLParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserNODE:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5058)
			p.Match(DorisSQLParserNODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserOPERATE:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5059)
			p.Match(DorisSQLParserOPERATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserPLUGIN:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(5060)
			p.Match(DorisSQLParserPLUGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserREPOSITORY:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(5061)
			p.Match(DorisSQLParserREPOSITORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserREFRESH:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(5062)
			p.Match(DorisSQLParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserSELECT:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(5063)
			p.Match(DorisSQLParserSELECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserUPDATE:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(5064)
			p.Match(DorisSQLParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserUSAGE:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(5065)
			p.Match(DorisSQLParserUSAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivObjectTypeContext is an interface to support dynamic dispatch.
type IPrivObjectTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CATALOG() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	PIPE() antlr.TerminalNode

	// IsPrivObjectTypeContext differentiates from other interfaces.
	IsPrivObjectTypeContext()
}

type PrivObjectTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivObjectTypeContext() *PrivObjectTypeContext {
	var p = new(PrivObjectTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_privObjectType
	return p
}

func InitEmptyPrivObjectTypeContext(p *PrivObjectTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_privObjectType
}

func (*PrivObjectTypeContext) IsPrivObjectTypeContext() {}

func NewPrivObjectTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivObjectTypeContext {
	var p = new(PrivObjectTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_privObjectType

	return p
}

func (s *PrivObjectTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivObjectTypeContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCATALOG, 0)
}

func (s *PrivObjectTypeContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATABASE, 0)
}

func (s *PrivObjectTypeContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMATERIALIZED, 0)
}

func (s *PrivObjectTypeContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVIEW, 0)
}

func (s *PrivObjectTypeContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRESOURCE, 0)
}

func (s *PrivObjectTypeContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGROUP, 0)
}

func (s *PrivObjectTypeContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTORAGE, 0)
}

func (s *PrivObjectTypeContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVOLUME, 0)
}

func (s *PrivObjectTypeContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSYSTEM, 0)
}

func (s *PrivObjectTypeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *PrivObjectTypeContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWAREHOUSE, 0)
}

func (s *PrivObjectTypeContext) PIPE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPIPE, 0)
}

func (s *PrivObjectTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivObjectTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivObjectTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPrivObjectType(s)
	}
}

func (s *PrivObjectTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPrivObjectType(s)
	}
}

func (s *PrivObjectTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPrivObjectType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PrivObjectType() (localctx IPrivObjectTypeContext) {
	localctx = NewPrivObjectTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, DorisSQLParserRULE_privObjectType)
	p.SetState(5082)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 547, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5068)
			p.Match(DorisSQLParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5069)
			p.Match(DorisSQLParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5070)
			p.Match(DorisSQLParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5071)
			p.Match(DorisSQLParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5072)
			p.Match(DorisSQLParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5073)
			p.Match(DorisSQLParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5074)
			p.Match(DorisSQLParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5075)
			p.Match(DorisSQLParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5076)
			p.Match(DorisSQLParserVOLUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5077)
			p.Match(DorisSQLParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5078)
			p.Match(DorisSQLParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5079)
			p.Match(DorisSQLParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5080)
			p.Match(DorisSQLParserWAREHOUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5081)
			p.Match(DorisSQLParserPIPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivObjectTypePluralContext is an interface to support dynamic dispatch.
type IPrivObjectTypePluralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CATALOGS() antlr.TerminalNode
	DATABASES() antlr.TerminalNode
	FUNCTIONS() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEWS() antlr.TerminalNode
	POLICIES() antlr.TerminalNode
	RESOURCES() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUPS() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUMES() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	USERS() antlr.TerminalNode
	WAREHOUSES() antlr.TerminalNode
	PIPES() antlr.TerminalNode

	// IsPrivObjectTypePluralContext differentiates from other interfaces.
	IsPrivObjectTypePluralContext()
}

type PrivObjectTypePluralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivObjectTypePluralContext() *PrivObjectTypePluralContext {
	var p = new(PrivObjectTypePluralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_privObjectTypePlural
	return p
}

func InitEmptyPrivObjectTypePluralContext(p *PrivObjectTypePluralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_privObjectTypePlural
}

func (*PrivObjectTypePluralContext) IsPrivObjectTypePluralContext() {}

func NewPrivObjectTypePluralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivObjectTypePluralContext {
	var p = new(PrivObjectTypePluralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_privObjectTypePlural

	return p
}

func (s *PrivObjectTypePluralContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivObjectTypePluralContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCATALOGS, 0)
}

func (s *PrivObjectTypePluralContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATABASES, 0)
}

func (s *PrivObjectTypePluralContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFUNCTIONS, 0)
}

func (s *PrivObjectTypePluralContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGLOBAL, 0)
}

func (s *PrivObjectTypePluralContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMATERIALIZED, 0)
}

func (s *PrivObjectTypePluralContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVIEWS, 0)
}

func (s *PrivObjectTypePluralContext) POLICIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPOLICIES, 0)
}

func (s *PrivObjectTypePluralContext) RESOURCES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRESOURCES, 0)
}

func (s *PrivObjectTypePluralContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRESOURCE, 0)
}

func (s *PrivObjectTypePluralContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGROUPS, 0)
}

func (s *PrivObjectTypePluralContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTORAGE, 0)
}

func (s *PrivObjectTypePluralContext) VOLUMES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVOLUMES, 0)
}

func (s *PrivObjectTypePluralContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLES, 0)
}

func (s *PrivObjectTypePluralContext) USERS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSERS, 0)
}

func (s *PrivObjectTypePluralContext) WAREHOUSES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWAREHOUSES, 0)
}

func (s *PrivObjectTypePluralContext) PIPES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPIPES, 0)
}

func (s *PrivObjectTypePluralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivObjectTypePluralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivObjectTypePluralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPrivObjectTypePlural(s)
	}
}

func (s *PrivObjectTypePluralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPrivObjectTypePlural(s)
	}
}

func (s *PrivObjectTypePluralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPrivObjectTypePlural(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PrivObjectTypePlural() (localctx IPrivObjectTypePluralContext) {
	localctx = NewPrivObjectTypePluralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, DorisSQLParserRULE_privObjectTypePlural)
	p.SetState(5102)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserCATALOGS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5084)
			p.Match(DorisSQLParserCATALOGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserDATABASES:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5085)
			p.Match(DorisSQLParserDATABASES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserFUNCTIONS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5086)
			p.Match(DorisSQLParserFUNCTIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserGLOBAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5087)
			p.Match(DorisSQLParserGLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5088)
			p.Match(DorisSQLParserFUNCTIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserMATERIALIZED:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5089)
			p.Match(DorisSQLParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5090)
			p.Match(DorisSQLParserVIEWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserPOLICIES:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5091)
			p.Match(DorisSQLParserPOLICIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserRESOURCES:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5092)
			p.Match(DorisSQLParserRESOURCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserRESOURCE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5093)
			p.Match(DorisSQLParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5094)
			p.Match(DorisSQLParserGROUPS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserSTORAGE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5095)
			p.Match(DorisSQLParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5096)
			p.Match(DorisSQLParserVOLUMES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserTABLES:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5097)
			p.Match(DorisSQLParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserUSERS:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5098)
			p.Match(DorisSQLParserUSERS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserVIEWS:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5099)
			p.Match(DorisSQLParserVIEWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserWAREHOUSES:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5100)
			p.Match(DorisSQLParserWAREHOUSES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserPIPES:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5101)
			p.Match(DorisSQLParserPIPES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateSecurityIntegrationStatementContext is an interface to support dynamic dispatch.
type ICreateSecurityIntegrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	INTEGRATION() antlr.TerminalNode
	Identifier() IIdentifierContext
	Properties() IPropertiesContext

	// IsCreateSecurityIntegrationStatementContext differentiates from other interfaces.
	IsCreateSecurityIntegrationStatementContext()
}

type CreateSecurityIntegrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateSecurityIntegrationStatementContext() *CreateSecurityIntegrationStatementContext {
	var p = new(CreateSecurityIntegrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createSecurityIntegrationStatement
	return p
}

func InitEmptyCreateSecurityIntegrationStatementContext(p *CreateSecurityIntegrationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createSecurityIntegrationStatement
}

func (*CreateSecurityIntegrationStatementContext) IsCreateSecurityIntegrationStatementContext() {}

func NewCreateSecurityIntegrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateSecurityIntegrationStatementContext {
	var p = new(CreateSecurityIntegrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createSecurityIntegrationStatement

	return p
}

func (s *CreateSecurityIntegrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateSecurityIntegrationStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateSecurityIntegrationStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSECURITY, 0)
}

func (s *CreateSecurityIntegrationStatementContext) INTEGRATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGRATION, 0)
}

func (s *CreateSecurityIntegrationStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateSecurityIntegrationStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateSecurityIntegrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateSecurityIntegrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateSecurityIntegrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateSecurityIntegrationStatement(s)
	}
}

func (s *CreateSecurityIntegrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateSecurityIntegrationStatement(s)
	}
}

func (s *CreateSecurityIntegrationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateSecurityIntegrationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateSecurityIntegrationStatement() (localctx ICreateSecurityIntegrationStatementContext) {
	localctx = NewCreateSecurityIntegrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, DorisSQLParserRULE_createSecurityIntegrationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5104)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5105)
		p.Match(DorisSQLParserSECURITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5106)
		p.Match(DorisSQLParserINTEGRATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5107)
		p.Identifier()
	}
	{
		p.SetState(5108)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterSecurityIntegrationStatementContext is an interface to support dynamic dispatch.
type IAlterSecurityIntegrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	INTEGRATION() antlr.TerminalNode
	Identifier() IIdentifierContext
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsAlterSecurityIntegrationStatementContext differentiates from other interfaces.
	IsAlterSecurityIntegrationStatementContext()
}

type AlterSecurityIntegrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterSecurityIntegrationStatementContext() *AlterSecurityIntegrationStatementContext {
	var p = new(AlterSecurityIntegrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterSecurityIntegrationStatement
	return p
}

func InitEmptyAlterSecurityIntegrationStatementContext(p *AlterSecurityIntegrationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterSecurityIntegrationStatement
}

func (*AlterSecurityIntegrationStatementContext) IsAlterSecurityIntegrationStatementContext() {}

func NewAlterSecurityIntegrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterSecurityIntegrationStatementContext {
	var p = new(AlterSecurityIntegrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_alterSecurityIntegrationStatement

	return p
}

func (s *AlterSecurityIntegrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterSecurityIntegrationStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *AlterSecurityIntegrationStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSECURITY, 0)
}

func (s *AlterSecurityIntegrationStatementContext) INTEGRATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGRATION, 0)
}

func (s *AlterSecurityIntegrationStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterSecurityIntegrationStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *AlterSecurityIntegrationStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *AlterSecurityIntegrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSecurityIntegrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterSecurityIntegrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAlterSecurityIntegrationStatement(s)
	}
}

func (s *AlterSecurityIntegrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAlterSecurityIntegrationStatement(s)
	}
}

func (s *AlterSecurityIntegrationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAlterSecurityIntegrationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AlterSecurityIntegrationStatement() (localctx IAlterSecurityIntegrationStatementContext) {
	localctx = NewAlterSecurityIntegrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, DorisSQLParserRULE_alterSecurityIntegrationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5110)
		p.Match(DorisSQLParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5111)
		p.Match(DorisSQLParserSECURITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5112)
		p.Match(DorisSQLParserINTEGRATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5113)
		p.Identifier()
	}
	{
		p.SetState(5114)
		p.Match(DorisSQLParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5115)
		p.PropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropSecurityIntegrationStatementContext is an interface to support dynamic dispatch.
type IDropSecurityIntegrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	INTEGRATION() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDropSecurityIntegrationStatementContext differentiates from other interfaces.
	IsDropSecurityIntegrationStatementContext()
}

type DropSecurityIntegrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropSecurityIntegrationStatementContext() *DropSecurityIntegrationStatementContext {
	var p = new(DropSecurityIntegrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropSecurityIntegrationStatement
	return p
}

func InitEmptyDropSecurityIntegrationStatementContext(p *DropSecurityIntegrationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropSecurityIntegrationStatement
}

func (*DropSecurityIntegrationStatementContext) IsDropSecurityIntegrationStatementContext() {}

func NewDropSecurityIntegrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropSecurityIntegrationStatementContext {
	var p = new(DropSecurityIntegrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropSecurityIntegrationStatement

	return p
}

func (s *DropSecurityIntegrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropSecurityIntegrationStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropSecurityIntegrationStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSECURITY, 0)
}

func (s *DropSecurityIntegrationStatementContext) INTEGRATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGRATION, 0)
}

func (s *DropSecurityIntegrationStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropSecurityIntegrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropSecurityIntegrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropSecurityIntegrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropSecurityIntegrationStatement(s)
	}
}

func (s *DropSecurityIntegrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropSecurityIntegrationStatement(s)
	}
}

func (s *DropSecurityIntegrationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropSecurityIntegrationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropSecurityIntegrationStatement() (localctx IDropSecurityIntegrationStatementContext) {
	localctx = NewDropSecurityIntegrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, DorisSQLParserRULE_dropSecurityIntegrationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5117)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5118)
		p.Match(DorisSQLParserSECURITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5119)
		p.Match(DorisSQLParserINTEGRATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5120)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowSecurityIntegrationStatementContext is an interface to support dynamic dispatch.
type IShowSecurityIntegrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	INTEGRATIONS() antlr.TerminalNode

	// IsShowSecurityIntegrationStatementContext differentiates from other interfaces.
	IsShowSecurityIntegrationStatementContext()
}

type ShowSecurityIntegrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowSecurityIntegrationStatementContext() *ShowSecurityIntegrationStatementContext {
	var p = new(ShowSecurityIntegrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showSecurityIntegrationStatement
	return p
}

func InitEmptyShowSecurityIntegrationStatementContext(p *ShowSecurityIntegrationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showSecurityIntegrationStatement
}

func (*ShowSecurityIntegrationStatementContext) IsShowSecurityIntegrationStatementContext() {}

func NewShowSecurityIntegrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowSecurityIntegrationStatementContext {
	var p = new(ShowSecurityIntegrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showSecurityIntegrationStatement

	return p
}

func (s *ShowSecurityIntegrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowSecurityIntegrationStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowSecurityIntegrationStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSECURITY, 0)
}

func (s *ShowSecurityIntegrationStatementContext) INTEGRATIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGRATIONS, 0)
}

func (s *ShowSecurityIntegrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSecurityIntegrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowSecurityIntegrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowSecurityIntegrationStatement(s)
	}
}

func (s *ShowSecurityIntegrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowSecurityIntegrationStatement(s)
	}
}

func (s *ShowSecurityIntegrationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowSecurityIntegrationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowSecurityIntegrationStatement() (localctx IShowSecurityIntegrationStatementContext) {
	localctx = NewShowSecurityIntegrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, DorisSQLParserRULE_showSecurityIntegrationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5122)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5123)
		p.Match(DorisSQLParserSECURITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5124)
		p.Match(DorisSQLParserINTEGRATIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCreateSecurityIntegrationStatementContext is an interface to support dynamic dispatch.
type IShowCreateSecurityIntegrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	INTEGRATION() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsShowCreateSecurityIntegrationStatementContext differentiates from other interfaces.
	IsShowCreateSecurityIntegrationStatementContext()
}

type ShowCreateSecurityIntegrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowCreateSecurityIntegrationStatementContext() *ShowCreateSecurityIntegrationStatementContext {
	var p = new(ShowCreateSecurityIntegrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showCreateSecurityIntegrationStatement
	return p
}

func InitEmptyShowCreateSecurityIntegrationStatementContext(p *ShowCreateSecurityIntegrationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showCreateSecurityIntegrationStatement
}

func (*ShowCreateSecurityIntegrationStatementContext) IsShowCreateSecurityIntegrationStatementContext() {
}

func NewShowCreateSecurityIntegrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCreateSecurityIntegrationStatementContext {
	var p = new(ShowCreateSecurityIntegrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showCreateSecurityIntegrationStatement

	return p
}

func (s *ShowCreateSecurityIntegrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCreateSecurityIntegrationStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowCreateSecurityIntegrationStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *ShowCreateSecurityIntegrationStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSECURITY, 0)
}

func (s *ShowCreateSecurityIntegrationStatementContext) INTEGRATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGRATION, 0)
}

func (s *ShowCreateSecurityIntegrationStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateSecurityIntegrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateSecurityIntegrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCreateSecurityIntegrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowCreateSecurityIntegrationStatement(s)
	}
}

func (s *ShowCreateSecurityIntegrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowCreateSecurityIntegrationStatement(s)
	}
}

func (s *ShowCreateSecurityIntegrationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowCreateSecurityIntegrationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowCreateSecurityIntegrationStatement() (localctx IShowCreateSecurityIntegrationStatementContext) {
	localctx = NewShowCreateSecurityIntegrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, DorisSQLParserRULE_showCreateSecurityIntegrationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5126)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5127)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5128)
		p.Match(DorisSQLParserSECURITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5129)
		p.Match(DorisSQLParserINTEGRATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5130)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateGroupProviderStatementContext is an interface to support dynamic dispatch.
type ICreateGroupProviderStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	PROVIDER() antlr.TerminalNode
	Identifier() IIdentifierContext
	Properties() IPropertiesContext

	// IsCreateGroupProviderStatementContext differentiates from other interfaces.
	IsCreateGroupProviderStatementContext()
}

type CreateGroupProviderStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateGroupProviderStatementContext() *CreateGroupProviderStatementContext {
	var p = new(CreateGroupProviderStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createGroupProviderStatement
	return p
}

func InitEmptyCreateGroupProviderStatementContext(p *CreateGroupProviderStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createGroupProviderStatement
}

func (*CreateGroupProviderStatementContext) IsCreateGroupProviderStatementContext() {}

func NewCreateGroupProviderStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateGroupProviderStatementContext {
	var p = new(CreateGroupProviderStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createGroupProviderStatement

	return p
}

func (s *CreateGroupProviderStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateGroupProviderStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateGroupProviderStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGROUP, 0)
}

func (s *CreateGroupProviderStatementContext) PROVIDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROVIDER, 0)
}

func (s *CreateGroupProviderStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateGroupProviderStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateGroupProviderStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateGroupProviderStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateGroupProviderStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateGroupProviderStatement(s)
	}
}

func (s *CreateGroupProviderStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateGroupProviderStatement(s)
	}
}

func (s *CreateGroupProviderStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateGroupProviderStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateGroupProviderStatement() (localctx ICreateGroupProviderStatementContext) {
	localctx = NewCreateGroupProviderStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, DorisSQLParserRULE_createGroupProviderStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5132)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5133)
		p.Match(DorisSQLParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5134)
		p.Match(DorisSQLParserPROVIDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5135)
		p.Identifier()
	}
	{
		p.SetState(5136)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropGroupProviderStatementContext is an interface to support dynamic dispatch.
type IDropGroupProviderStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	PROVIDER() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDropGroupProviderStatementContext differentiates from other interfaces.
	IsDropGroupProviderStatementContext()
}

type DropGroupProviderStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropGroupProviderStatementContext() *DropGroupProviderStatementContext {
	var p = new(DropGroupProviderStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropGroupProviderStatement
	return p
}

func InitEmptyDropGroupProviderStatementContext(p *DropGroupProviderStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropGroupProviderStatement
}

func (*DropGroupProviderStatementContext) IsDropGroupProviderStatementContext() {}

func NewDropGroupProviderStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropGroupProviderStatementContext {
	var p = new(DropGroupProviderStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropGroupProviderStatement

	return p
}

func (s *DropGroupProviderStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropGroupProviderStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropGroupProviderStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGROUP, 0)
}

func (s *DropGroupProviderStatementContext) PROVIDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROVIDER, 0)
}

func (s *DropGroupProviderStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropGroupProviderStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropGroupProviderStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropGroupProviderStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropGroupProviderStatement(s)
	}
}

func (s *DropGroupProviderStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropGroupProviderStatement(s)
	}
}

func (s *DropGroupProviderStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropGroupProviderStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropGroupProviderStatement() (localctx IDropGroupProviderStatementContext) {
	localctx = NewDropGroupProviderStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, DorisSQLParserRULE_dropGroupProviderStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5138)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5139)
		p.Match(DorisSQLParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5140)
		p.Match(DorisSQLParserPROVIDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5141)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowGroupProvidersStatementContext is an interface to support dynamic dispatch.
type IShowGroupProvidersStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	PROVIDERS() antlr.TerminalNode

	// IsShowGroupProvidersStatementContext differentiates from other interfaces.
	IsShowGroupProvidersStatementContext()
}

type ShowGroupProvidersStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowGroupProvidersStatementContext() *ShowGroupProvidersStatementContext {
	var p = new(ShowGroupProvidersStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showGroupProvidersStatement
	return p
}

func InitEmptyShowGroupProvidersStatementContext(p *ShowGroupProvidersStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showGroupProvidersStatement
}

func (*ShowGroupProvidersStatementContext) IsShowGroupProvidersStatementContext() {}

func NewShowGroupProvidersStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowGroupProvidersStatementContext {
	var p = new(ShowGroupProvidersStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showGroupProvidersStatement

	return p
}

func (s *ShowGroupProvidersStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowGroupProvidersStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowGroupProvidersStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGROUP, 0)
}

func (s *ShowGroupProvidersStatementContext) PROVIDERS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROVIDERS, 0)
}

func (s *ShowGroupProvidersStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGroupProvidersStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowGroupProvidersStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowGroupProvidersStatement(s)
	}
}

func (s *ShowGroupProvidersStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowGroupProvidersStatement(s)
	}
}

func (s *ShowGroupProvidersStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowGroupProvidersStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowGroupProvidersStatement() (localctx IShowGroupProvidersStatementContext) {
	localctx = NewShowGroupProvidersStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, DorisSQLParserRULE_showGroupProvidersStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5143)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5144)
		p.Match(DorisSQLParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5145)
		p.Match(DorisSQLParserPROVIDERS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCreateGroupProviderStatementContext is an interface to support dynamic dispatch.
type IShowCreateGroupProviderStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	PROVIDER() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsShowCreateGroupProviderStatementContext differentiates from other interfaces.
	IsShowCreateGroupProviderStatementContext()
}

type ShowCreateGroupProviderStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowCreateGroupProviderStatementContext() *ShowCreateGroupProviderStatementContext {
	var p = new(ShowCreateGroupProviderStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showCreateGroupProviderStatement
	return p
}

func InitEmptyShowCreateGroupProviderStatementContext(p *ShowCreateGroupProviderStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showCreateGroupProviderStatement
}

func (*ShowCreateGroupProviderStatementContext) IsShowCreateGroupProviderStatementContext() {}

func NewShowCreateGroupProviderStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCreateGroupProviderStatementContext {
	var p = new(ShowCreateGroupProviderStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showCreateGroupProviderStatement

	return p
}

func (s *ShowCreateGroupProviderStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCreateGroupProviderStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowCreateGroupProviderStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *ShowCreateGroupProviderStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGROUP, 0)
}

func (s *ShowCreateGroupProviderStatementContext) PROVIDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROVIDER, 0)
}

func (s *ShowCreateGroupProviderStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateGroupProviderStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateGroupProviderStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCreateGroupProviderStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowCreateGroupProviderStatement(s)
	}
}

func (s *ShowCreateGroupProviderStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowCreateGroupProviderStatement(s)
	}
}

func (s *ShowCreateGroupProviderStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowCreateGroupProviderStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowCreateGroupProviderStatement() (localctx IShowCreateGroupProviderStatementContext) {
	localctx = NewShowCreateGroupProviderStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, DorisSQLParserRULE_showCreateGroupProviderStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5147)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5148)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5149)
		p.Match(DorisSQLParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5150)
		p.Match(DorisSQLParserPROVIDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5151)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBackupStatementContext is an interface to support dynamic dispatch.
type IBackupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDbName returns the dbName rule contexts.
	GetDbName() IIdentifierContext

	// GetRepoName returns the repoName rule contexts.
	GetRepoName() IIdentifierContext

	// SetDbName sets the dbName rule contexts.
	SetDbName(IIdentifierContext)

	// SetRepoName sets the repoName rule contexts.
	SetRepoName(IIdentifierContext)

	// Getter signatures
	BACKUP() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	TO() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	ALL() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	CATALOGS() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	DATABASE() antlr.TerminalNode
	ON() antlr.TerminalNode
	AllBackupRestoreObjectDesc() []IBackupRestoreObjectDescContext
	BackupRestoreObjectDesc(i int) IBackupRestoreObjectDescContext
	PROPERTIES() antlr.TerminalNode
	PropertyList() IPropertyListContext
	CATALOG() antlr.TerminalNode

	// IsBackupStatementContext differentiates from other interfaces.
	IsBackupStatementContext()
}

type BackupStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	dbName   IIdentifierContext
	repoName IIdentifierContext
}

func NewEmptyBackupStatementContext() *BackupStatementContext {
	var p = new(BackupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_backupStatement
	return p
}

func InitEmptyBackupStatementContext(p *BackupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_backupStatement
}

func (*BackupStatementContext) IsBackupStatementContext() {}

func NewBackupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BackupStatementContext {
	var p = new(BackupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_backupStatement

	return p
}

func (s *BackupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BackupStatementContext) GetDbName() IIdentifierContext { return s.dbName }

func (s *BackupStatementContext) GetRepoName() IIdentifierContext { return s.repoName }

func (s *BackupStatementContext) SetDbName(v IIdentifierContext) { s.dbName = v }

func (s *BackupStatementContext) SetRepoName(v IIdentifierContext) { s.repoName = v }

func (s *BackupStatementContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBACKUP, 0)
}

func (s *BackupStatementContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSNAPSHOT, 0)
}

func (s *BackupStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *BackupStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTO, 0)
}

func (s *BackupStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *BackupStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BackupStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, 0)
}

func (s *BackupStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXTERNAL, 0)
}

func (s *BackupStatementContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCATALOGS, 0)
}

func (s *BackupStatementContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *BackupStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATABASE, 0)
}

func (s *BackupStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *BackupStatementContext) AllBackupRestoreObjectDesc() []IBackupRestoreObjectDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBackupRestoreObjectDescContext); ok {
			len++
		}
	}

	tst := make([]IBackupRestoreObjectDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBackupRestoreObjectDescContext); ok {
			tst[i] = t.(IBackupRestoreObjectDescContext)
			i++
		}
	}

	return tst
}

func (s *BackupStatementContext) BackupRestoreObjectDesc(i int) IBackupRestoreObjectDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackupRestoreObjectDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackupRestoreObjectDescContext)
}

func (s *BackupStatementContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROPERTIES, 0)
}

func (s *BackupStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *BackupStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCATALOG, 0)
}

func (s *BackupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BackupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterBackupStatement(s)
	}
}

func (s *BackupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitBackupStatement(s)
	}
}

func (s *BackupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitBackupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) BackupStatement() (localctx IBackupStatementContext) {
	localctx = NewBackupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, DorisSQLParserRULE_backupStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5153)
		p.Match(DorisSQLParserBACKUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5160)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserALL:
		{
			p.SetState(5154)
			p.Match(DorisSQLParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5155)
			p.Match(DorisSQLParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5156)
			p.Match(DorisSQLParserCATALOGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserEXTERNAL:
		{
			p.SetState(5157)
			p.Match(DorisSQLParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5158)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserCATALOG || _la == DorisSQLParserCATALOGS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5159)
			p.IdentifierList()
		}

	case DorisSQLParserDATABASE, DorisSQLParserSNAPSHOT:

	default:
	}
	p.SetState(5164)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserDATABASE {
		{
			p.SetState(5162)
			p.Match(DorisSQLParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5163)

			var _x = p.Identifier()

			localctx.(*BackupStatementContext).dbName = _x
		}

	}
	{
		p.SetState(5166)
		p.Match(DorisSQLParserSNAPSHOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5167)
		p.QualifiedName()
	}
	{
		p.SetState(5168)
		p.Match(DorisSQLParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5169)

		var _x = p.Identifier()

		localctx.(*BackupStatementContext).repoName = _x
	}
	p.SetState(5182)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserON {
		{
			p.SetState(5170)
			p.Match(DorisSQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5171)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5172)
			p.BackupRestoreObjectDesc()
		}
		p.SetState(5177)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(5173)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5174)
				p.BackupRestoreObjectDesc()
			}

			p.SetState(5179)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5180)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5186)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(5184)
			p.Match(DorisSQLParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5185)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelBackupStatementContext is an interface to support dynamic dispatch.
type ICancelBackupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	BACKUP() antlr.TerminalNode
	Identifier() IIdentifierContext
	FOR() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode

	// IsCancelBackupStatementContext differentiates from other interfaces.
	IsCancelBackupStatementContext()
}

type CancelBackupStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelBackupStatementContext() *CancelBackupStatementContext {
	var p = new(CancelBackupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cancelBackupStatement
	return p
}

func InitEmptyCancelBackupStatementContext(p *CancelBackupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cancelBackupStatement
}

func (*CancelBackupStatementContext) IsCancelBackupStatementContext() {}

func NewCancelBackupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelBackupStatementContext {
	var p = new(CancelBackupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_cancelBackupStatement

	return p
}

func (s *CancelBackupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelBackupStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCANCEL, 0)
}

func (s *CancelBackupStatementContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBACKUP, 0)
}

func (s *CancelBackupStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelBackupStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFOR, 0)
}

func (s *CancelBackupStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXTERNAL, 0)
}

func (s *CancelBackupStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCATALOG, 0)
}

func (s *CancelBackupStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *CancelBackupStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *CancelBackupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelBackupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelBackupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCancelBackupStatement(s)
	}
}

func (s *CancelBackupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCancelBackupStatement(s)
	}
}

func (s *CancelBackupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCancelBackupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CancelBackupStatement() (localctx ICancelBackupStatementContext) {
	localctx = NewCancelBackupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, DorisSQLParserRULE_cancelBackupStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5188)
		p.Match(DorisSQLParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5189)
		p.Match(DorisSQLParserBACKUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5195)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserFROM, DorisSQLParserIN:
		{
			p.SetState(5190)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5191)
			p.Identifier()
		}

	case DorisSQLParserFOR:
		{
			p.SetState(5192)
			p.Match(DorisSQLParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5193)
			p.Match(DorisSQLParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5194)
			p.Match(DorisSQLParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserEOF, DorisSQLParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowBackupStatementContext is an interface to support dynamic dispatch.
type IShowBackupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	BACKUP() antlr.TerminalNode
	Identifier() IIdentifierContext
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode

	// IsShowBackupStatementContext differentiates from other interfaces.
	IsShowBackupStatementContext()
}

type ShowBackupStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowBackupStatementContext() *ShowBackupStatementContext {
	var p = new(ShowBackupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showBackupStatement
	return p
}

func InitEmptyShowBackupStatementContext(p *ShowBackupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showBackupStatement
}

func (*ShowBackupStatementContext) IsShowBackupStatementContext() {}

func NewShowBackupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowBackupStatementContext {
	var p = new(ShowBackupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showBackupStatement

	return p
}

func (s *ShowBackupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowBackupStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowBackupStatementContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBACKUP, 0)
}

func (s *ShowBackupStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowBackupStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowBackupStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *ShowBackupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBackupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowBackupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowBackupStatement(s)
	}
}

func (s *ShowBackupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowBackupStatement(s)
	}
}

func (s *ShowBackupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowBackupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowBackupStatement() (localctx IShowBackupStatementContext) {
	localctx = NewShowBackupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, DorisSQLParserRULE_showBackupStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5197)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5198)
		p.Match(DorisSQLParserBACKUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5201)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM || _la == DorisSQLParserIN {
		{
			p.SetState(5199)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5200)
			p.Identifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRestoreStatementContext is an interface to support dynamic dispatch.
type IRestoreStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRepoName returns the repoName rule contexts.
	GetRepoName() IIdentifierContext

	// GetDbName returns the dbName rule contexts.
	GetDbName() IIdentifierContext

	// GetDbAlias returns the dbAlias rule contexts.
	GetDbAlias() IIdentifierContext

	// SetRepoName sets the repoName rule contexts.
	SetRepoName(IIdentifierContext)

	// SetDbName sets the dbName rule contexts.
	SetDbName(IIdentifierContext)

	// SetDbAlias sets the dbAlias rule contexts.
	SetDbAlias(IIdentifierContext)

	// Getter signatures
	RESTORE() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	FROM() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	ALL() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	CATALOGS() antlr.TerminalNode
	IdentifierWithAliasList() IIdentifierWithAliasListContext
	DATABASE() antlr.TerminalNode
	ON() antlr.TerminalNode
	AllBackupRestoreObjectDesc() []IBackupRestoreObjectDescContext
	BackupRestoreObjectDesc(i int) IBackupRestoreObjectDescContext
	PROPERTIES() antlr.TerminalNode
	PropertyList() IPropertyListContext
	CATALOG() antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsRestoreStatementContext differentiates from other interfaces.
	IsRestoreStatementContext()
}

type RestoreStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	repoName IIdentifierContext
	dbName   IIdentifierContext
	dbAlias  IIdentifierContext
}

func NewEmptyRestoreStatementContext() *RestoreStatementContext {
	var p = new(RestoreStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_restoreStatement
	return p
}

func InitEmptyRestoreStatementContext(p *RestoreStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_restoreStatement
}

func (*RestoreStatementContext) IsRestoreStatementContext() {}

func NewRestoreStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RestoreStatementContext {
	var p = new(RestoreStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_restoreStatement

	return p
}

func (s *RestoreStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RestoreStatementContext) GetRepoName() IIdentifierContext { return s.repoName }

func (s *RestoreStatementContext) GetDbName() IIdentifierContext { return s.dbName }

func (s *RestoreStatementContext) GetDbAlias() IIdentifierContext { return s.dbAlias }

func (s *RestoreStatementContext) SetRepoName(v IIdentifierContext) { s.repoName = v }

func (s *RestoreStatementContext) SetDbName(v IIdentifierContext) { s.dbName = v }

func (s *RestoreStatementContext) SetDbAlias(v IIdentifierContext) { s.dbAlias = v }

func (s *RestoreStatementContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRESTORE, 0)
}

func (s *RestoreStatementContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSNAPSHOT, 0)
}

func (s *RestoreStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RestoreStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *RestoreStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RestoreStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RestoreStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, 0)
}

func (s *RestoreStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXTERNAL, 0)
}

func (s *RestoreStatementContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCATALOGS, 0)
}

func (s *RestoreStatementContext) IdentifierWithAliasList() IIdentifierWithAliasListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierWithAliasListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierWithAliasListContext)
}

func (s *RestoreStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATABASE, 0)
}

func (s *RestoreStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *RestoreStatementContext) AllBackupRestoreObjectDesc() []IBackupRestoreObjectDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBackupRestoreObjectDescContext); ok {
			len++
		}
	}

	tst := make([]IBackupRestoreObjectDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBackupRestoreObjectDescContext); ok {
			tst[i] = t.(IBackupRestoreObjectDescContext)
			i++
		}
	}

	return tst
}

func (s *RestoreStatementContext) BackupRestoreObjectDesc(i int) IBackupRestoreObjectDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackupRestoreObjectDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackupRestoreObjectDescContext)
}

func (s *RestoreStatementContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROPERTIES, 0)
}

func (s *RestoreStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *RestoreStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCATALOG, 0)
}

func (s *RestoreStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *RestoreStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RestoreStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RestoreStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRestoreStatement(s)
	}
}

func (s *RestoreStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRestoreStatement(s)
	}
}

func (s *RestoreStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRestoreStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) RestoreStatement() (localctx IRestoreStatementContext) {
	localctx = NewRestoreStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, DorisSQLParserRULE_restoreStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5203)
		p.Match(DorisSQLParserRESTORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5204)
		p.Match(DorisSQLParserSNAPSHOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5205)
		p.QualifiedName()
	}
	{
		p.SetState(5206)
		p.Match(DorisSQLParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5207)

		var _x = p.Identifier()

		localctx.(*RestoreStatementContext).repoName = _x
	}
	p.SetState(5214)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserALL:
		{
			p.SetState(5208)
			p.Match(DorisSQLParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5209)
			p.Match(DorisSQLParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5210)
			p.Match(DorisSQLParserCATALOGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserEXTERNAL:
		{
			p.SetState(5211)
			p.Match(DorisSQLParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5212)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserCATALOG || _la == DorisSQLParserCATALOGS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5213)
			p.IdentifierWithAliasList()
		}

	case DorisSQLParserEOF, DorisSQLParserDATABASE, DorisSQLParserON, DorisSQLParserPROPERTIES, DorisSQLParserSEMICOLON:

	default:
	}
	p.SetState(5222)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserDATABASE {
		{
			p.SetState(5216)
			p.Match(DorisSQLParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5217)

			var _x = p.Identifier()

			localctx.(*RestoreStatementContext).dbName = _x
		}
		p.SetState(5220)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserAS {
			{
				p.SetState(5218)
				p.Match(DorisSQLParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5219)

				var _x = p.Identifier()

				localctx.(*RestoreStatementContext).dbAlias = _x
			}

		}

	}
	p.SetState(5236)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserON {
		{
			p.SetState(5224)
			p.Match(DorisSQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5225)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5226)
			p.BackupRestoreObjectDesc()
		}
		p.SetState(5231)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(5227)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5228)
				p.BackupRestoreObjectDesc()
			}

			p.SetState(5233)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5234)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5240)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(5238)
			p.Match(DorisSQLParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5239)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelRestoreStatementContext is an interface to support dynamic dispatch.
type ICancelRestoreStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	RESTORE() antlr.TerminalNode
	Identifier() IIdentifierContext
	FOR() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode

	// IsCancelRestoreStatementContext differentiates from other interfaces.
	IsCancelRestoreStatementContext()
}

type CancelRestoreStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelRestoreStatementContext() *CancelRestoreStatementContext {
	var p = new(CancelRestoreStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cancelRestoreStatement
	return p
}

func InitEmptyCancelRestoreStatementContext(p *CancelRestoreStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cancelRestoreStatement
}

func (*CancelRestoreStatementContext) IsCancelRestoreStatementContext() {}

func NewCancelRestoreStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelRestoreStatementContext {
	var p = new(CancelRestoreStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_cancelRestoreStatement

	return p
}

func (s *CancelRestoreStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelRestoreStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCANCEL, 0)
}

func (s *CancelRestoreStatementContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRESTORE, 0)
}

func (s *CancelRestoreStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelRestoreStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFOR, 0)
}

func (s *CancelRestoreStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXTERNAL, 0)
}

func (s *CancelRestoreStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCATALOG, 0)
}

func (s *CancelRestoreStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *CancelRestoreStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *CancelRestoreStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelRestoreStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelRestoreStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCancelRestoreStatement(s)
	}
}

func (s *CancelRestoreStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCancelRestoreStatement(s)
	}
}

func (s *CancelRestoreStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCancelRestoreStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CancelRestoreStatement() (localctx ICancelRestoreStatementContext) {
	localctx = NewCancelRestoreStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, DorisSQLParserRULE_cancelRestoreStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5242)
		p.Match(DorisSQLParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5243)
		p.Match(DorisSQLParserRESTORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5249)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserFROM, DorisSQLParserIN:
		{
			p.SetState(5244)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5245)
			p.Identifier()
		}

	case DorisSQLParserFOR:
		{
			p.SetState(5246)
			p.Match(DorisSQLParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5247)
			p.Match(DorisSQLParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5248)
			p.Match(DorisSQLParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserEOF, DorisSQLParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowRestoreStatementContext is an interface to support dynamic dispatch.
type IShowRestoreStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	RESTORE() antlr.TerminalNode
	Identifier() IIdentifierContext
	WHERE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsShowRestoreStatementContext differentiates from other interfaces.
	IsShowRestoreStatementContext()
}

type ShowRestoreStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IExpressionContext
}

func NewEmptyShowRestoreStatementContext() *ShowRestoreStatementContext {
	var p = new(ShowRestoreStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showRestoreStatement
	return p
}

func InitEmptyShowRestoreStatementContext(p *ShowRestoreStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showRestoreStatement
}

func (*ShowRestoreStatementContext) IsShowRestoreStatementContext() {}

func NewShowRestoreStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRestoreStatementContext {
	var p = new(ShowRestoreStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showRestoreStatement

	return p
}

func (s *ShowRestoreStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRestoreStatementContext) GetWhere() IExpressionContext { return s.where }

func (s *ShowRestoreStatementContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *ShowRestoreStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowRestoreStatementContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRESTORE, 0)
}

func (s *ShowRestoreStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowRestoreStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowRestoreStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowRestoreStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *ShowRestoreStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowRestoreStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRestoreStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRestoreStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowRestoreStatement(s)
	}
}

func (s *ShowRestoreStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowRestoreStatement(s)
	}
}

func (s *ShowRestoreStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowRestoreStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowRestoreStatement() (localctx IShowRestoreStatementContext) {
	localctx = NewShowRestoreStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, DorisSQLParserRULE_showRestoreStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5251)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5252)
		p.Match(DorisSQLParserRESTORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5255)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM || _la == DorisSQLParserIN {
		{
			p.SetState(5253)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5254)
			p.Identifier()
		}

	}
	p.SetState(5259)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWHERE {
		{
			p.SetState(5257)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5258)

			var _x = p.expression(0)

			localctx.(*ShowRestoreStatementContext).where = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowSnapshotStatementContext is an interface to support dynamic dispatch.
type IShowSnapshotStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	ON() antlr.TerminalNode
	Identifier() IIdentifierContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsShowSnapshotStatementContext differentiates from other interfaces.
	IsShowSnapshotStatementContext()
}

type ShowSnapshotStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowSnapshotStatementContext() *ShowSnapshotStatementContext {
	var p = new(ShowSnapshotStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showSnapshotStatement
	return p
}

func InitEmptyShowSnapshotStatementContext(p *ShowSnapshotStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showSnapshotStatement
}

func (*ShowSnapshotStatementContext) IsShowSnapshotStatementContext() {}

func NewShowSnapshotStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowSnapshotStatementContext {
	var p = new(ShowSnapshotStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showSnapshotStatement

	return p
}

func (s *ShowSnapshotStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowSnapshotStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowSnapshotStatementContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSNAPSHOT, 0)
}

func (s *ShowSnapshotStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *ShowSnapshotStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowSnapshotStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowSnapshotStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowSnapshotStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSnapshotStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowSnapshotStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowSnapshotStatement(s)
	}
}

func (s *ShowSnapshotStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowSnapshotStatement(s)
	}
}

func (s *ShowSnapshotStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowSnapshotStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowSnapshotStatement() (localctx IShowSnapshotStatementContext) {
	localctx = NewShowSnapshotStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, DorisSQLParserRULE_showSnapshotStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5261)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5262)
		p.Match(DorisSQLParserSNAPSHOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5263)
		p.Match(DorisSQLParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5264)
		p.Identifier()
	}
	p.SetState(5267)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWHERE {
		{
			p.SetState(5265)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5266)
			p.expression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateRepositoryStatementContext is an interface to support dynamic dispatch.
type ICreateRepositoryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRepoName returns the repoName rule contexts.
	GetRepoName() IIdentifierContext

	// GetBrokerName returns the brokerName rule contexts.
	GetBrokerName() IIdentifierOrStringContext

	// GetLocation returns the location rule contexts.
	GetLocation() IStringContext

	// SetRepoName sets the repoName rule contexts.
	SetRepoName(IIdentifierContext)

	// SetBrokerName sets the brokerName rule contexts.
	SetBrokerName(IIdentifierOrStringContext)

	// SetLocation sets the location rule contexts.
	SetLocation(IStringContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	REPOSITORY() antlr.TerminalNode
	WITH() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	ON() antlr.TerminalNode
	LOCATION() antlr.TerminalNode
	Identifier() IIdentifierContext
	String_() IStringContext
	READ() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode
	PropertyList() IPropertyListContext
	IdentifierOrString() IIdentifierOrStringContext

	// IsCreateRepositoryStatementContext differentiates from other interfaces.
	IsCreateRepositoryStatementContext()
}

type CreateRepositoryStatementContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	repoName   IIdentifierContext
	brokerName IIdentifierOrStringContext
	location   IStringContext
}

func NewEmptyCreateRepositoryStatementContext() *CreateRepositoryStatementContext {
	var p = new(CreateRepositoryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createRepositoryStatement
	return p
}

func InitEmptyCreateRepositoryStatementContext(p *CreateRepositoryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createRepositoryStatement
}

func (*CreateRepositoryStatementContext) IsCreateRepositoryStatementContext() {}

func NewCreateRepositoryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRepositoryStatementContext {
	var p = new(CreateRepositoryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createRepositoryStatement

	return p
}

func (s *CreateRepositoryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRepositoryStatementContext) GetRepoName() IIdentifierContext { return s.repoName }

func (s *CreateRepositoryStatementContext) GetBrokerName() IIdentifierOrStringContext {
	return s.brokerName
}

func (s *CreateRepositoryStatementContext) GetLocation() IStringContext { return s.location }

func (s *CreateRepositoryStatementContext) SetRepoName(v IIdentifierContext) { s.repoName = v }

func (s *CreateRepositoryStatementContext) SetBrokerName(v IIdentifierOrStringContext) {
	s.brokerName = v
}

func (s *CreateRepositoryStatementContext) SetLocation(v IStringContext) { s.location = v }

func (s *CreateRepositoryStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateRepositoryStatementContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPOSITORY, 0)
}

func (s *CreateRepositoryStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *CreateRepositoryStatementContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBROKER, 0)
}

func (s *CreateRepositoryStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *CreateRepositoryStatementContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOCATION, 0)
}

func (s *CreateRepositoryStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRepositoryStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CreateRepositoryStatementContext) READ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREAD, 0)
}

func (s *CreateRepositoryStatementContext) ONLY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserONLY, 0)
}

func (s *CreateRepositoryStatementContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROPERTIES, 0)
}

func (s *CreateRepositoryStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *CreateRepositoryStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CreateRepositoryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRepositoryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRepositoryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateRepositoryStatement(s)
	}
}

func (s *CreateRepositoryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateRepositoryStatement(s)
	}
}

func (s *CreateRepositoryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateRepositoryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateRepositoryStatement() (localctx ICreateRepositoryStatementContext) {
	localctx = NewCreateRepositoryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, DorisSQLParserRULE_createRepositoryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5269)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserREAD {
		{
			p.SetState(5270)
			p.Match(DorisSQLParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5271)
			p.Match(DorisSQLParserONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5274)
		p.Match(DorisSQLParserREPOSITORY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5275)

		var _x = p.Identifier()

		localctx.(*CreateRepositoryStatementContext).repoName = _x
	}
	{
		p.SetState(5276)
		p.Match(DorisSQLParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5277)
		p.Match(DorisSQLParserBROKER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5279)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262756702208) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-6664167256628462851) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-1331487429127569487) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&-7546427580836201) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-4573491655345179) != 0) || ((int64((_la-324)) & ^0x3f) == 0 && ((int64(1)<<(_la-324))&9114828243924942831) != 0) || ((int64((_la-389)) & ^0x3f) == 0 && ((int64(1)<<(_la-389))&-6956096606152176261) != 0) || ((int64((_la-453)) & ^0x3f) == 0 && ((int64(1)<<(_la-453))&70849595962729) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&4211) != 0) {
		{
			p.SetState(5278)

			var _x = p.IdentifierOrString()

			localctx.(*CreateRepositoryStatementContext).brokerName = _x
		}

	}
	{
		p.SetState(5281)
		p.Match(DorisSQLParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5282)
		p.Match(DorisSQLParserLOCATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5283)

		var _x = p.String_()

		localctx.(*CreateRepositoryStatementContext).location = _x
	}
	p.SetState(5286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(5284)
			p.Match(DorisSQLParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5285)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropRepositoryStatementContext is an interface to support dynamic dispatch.
type IDropRepositoryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	REPOSITORY() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDropRepositoryStatementContext differentiates from other interfaces.
	IsDropRepositoryStatementContext()
}

type DropRepositoryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropRepositoryStatementContext() *DropRepositoryStatementContext {
	var p = new(DropRepositoryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropRepositoryStatement
	return p
}

func InitEmptyDropRepositoryStatementContext(p *DropRepositoryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropRepositoryStatement
}

func (*DropRepositoryStatementContext) IsDropRepositoryStatementContext() {}

func NewDropRepositoryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropRepositoryStatementContext {
	var p = new(DropRepositoryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropRepositoryStatement

	return p
}

func (s *DropRepositoryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropRepositoryStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropRepositoryStatementContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPOSITORY, 0)
}

func (s *DropRepositoryStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropRepositoryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRepositoryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropRepositoryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropRepositoryStatement(s)
	}
}

func (s *DropRepositoryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropRepositoryStatement(s)
	}
}

func (s *DropRepositoryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropRepositoryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropRepositoryStatement() (localctx IDropRepositoryStatementContext) {
	localctx = NewDropRepositoryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, DorisSQLParserRULE_dropRepositoryStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5288)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5289)
		p.Match(DorisSQLParserREPOSITORY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5290)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddSqlBlackListStatementContext is an interface to support dynamic dispatch.
type IAddSqlBlackListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	SQLBLACKLIST() antlr.TerminalNode
	String_() IStringContext

	// IsAddSqlBlackListStatementContext differentiates from other interfaces.
	IsAddSqlBlackListStatementContext()
}

type AddSqlBlackListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddSqlBlackListStatementContext() *AddSqlBlackListStatementContext {
	var p = new(AddSqlBlackListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_addSqlBlackListStatement
	return p
}

func InitEmptyAddSqlBlackListStatementContext(p *AddSqlBlackListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_addSqlBlackListStatement
}

func (*AddSqlBlackListStatementContext) IsAddSqlBlackListStatementContext() {}

func NewAddSqlBlackListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddSqlBlackListStatementContext {
	var p = new(AddSqlBlackListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_addSqlBlackListStatement

	return p
}

func (s *AddSqlBlackListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AddSqlBlackListStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADD, 0)
}

func (s *AddSqlBlackListStatementContext) SQLBLACKLIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSQLBLACKLIST, 0)
}

func (s *AddSqlBlackListStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AddSqlBlackListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddSqlBlackListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddSqlBlackListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAddSqlBlackListStatement(s)
	}
}

func (s *AddSqlBlackListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAddSqlBlackListStatement(s)
	}
}

func (s *AddSqlBlackListStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAddSqlBlackListStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AddSqlBlackListStatement() (localctx IAddSqlBlackListStatementContext) {
	localctx = NewAddSqlBlackListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, DorisSQLParserRULE_addSqlBlackListStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5292)
		p.Match(DorisSQLParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5293)
		p.Match(DorisSQLParserSQLBLACKLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5294)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelSqlBlackListStatementContext is an interface to support dynamic dispatch.
type IDelSqlBlackListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	SQLBLACKLIST() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsDelSqlBlackListStatementContext differentiates from other interfaces.
	IsDelSqlBlackListStatementContext()
}

type DelSqlBlackListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelSqlBlackListStatementContext() *DelSqlBlackListStatementContext {
	var p = new(DelSqlBlackListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_delSqlBlackListStatement
	return p
}

func InitEmptyDelSqlBlackListStatementContext(p *DelSqlBlackListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_delSqlBlackListStatement
}

func (*DelSqlBlackListStatementContext) IsDelSqlBlackListStatementContext() {}

func NewDelSqlBlackListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelSqlBlackListStatementContext {
	var p = new(DelSqlBlackListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_delSqlBlackListStatement

	return p
}

func (s *DelSqlBlackListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DelSqlBlackListStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDELETE, 0)
}

func (s *DelSqlBlackListStatementContext) SQLBLACKLIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSQLBLACKLIST, 0)
}

func (s *DelSqlBlackListStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserINTEGER_VALUE)
}

func (s *DelSqlBlackListStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, i)
}

func (s *DelSqlBlackListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelSqlBlackListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelSqlBlackListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDelSqlBlackListStatement(s)
	}
}

func (s *DelSqlBlackListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDelSqlBlackListStatement(s)
	}
}

func (s *DelSqlBlackListStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDelSqlBlackListStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DelSqlBlackListStatement() (localctx IDelSqlBlackListStatementContext) {
	localctx = NewDelSqlBlackListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, DorisSQLParserRULE_delSqlBlackListStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5296)
		p.Match(DorisSQLParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5297)
		p.Match(DorisSQLParserSQLBLACKLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5298)
		p.Match(DorisSQLParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5303)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(5299)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5300)
			p.Match(DorisSQLParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(5305)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowSqlBlackListStatementContext is an interface to support dynamic dispatch.
type IShowSqlBlackListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	SQLBLACKLIST() antlr.TerminalNode

	// IsShowSqlBlackListStatementContext differentiates from other interfaces.
	IsShowSqlBlackListStatementContext()
}

type ShowSqlBlackListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowSqlBlackListStatementContext() *ShowSqlBlackListStatementContext {
	var p = new(ShowSqlBlackListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showSqlBlackListStatement
	return p
}

func InitEmptyShowSqlBlackListStatementContext(p *ShowSqlBlackListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showSqlBlackListStatement
}

func (*ShowSqlBlackListStatementContext) IsShowSqlBlackListStatementContext() {}

func NewShowSqlBlackListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowSqlBlackListStatementContext {
	var p = new(ShowSqlBlackListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showSqlBlackListStatement

	return p
}

func (s *ShowSqlBlackListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowSqlBlackListStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowSqlBlackListStatementContext) SQLBLACKLIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSQLBLACKLIST, 0)
}

func (s *ShowSqlBlackListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSqlBlackListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowSqlBlackListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowSqlBlackListStatement(s)
	}
}

func (s *ShowSqlBlackListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowSqlBlackListStatement(s)
	}
}

func (s *ShowSqlBlackListStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowSqlBlackListStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowSqlBlackListStatement() (localctx IShowSqlBlackListStatementContext) {
	localctx = NewShowSqlBlackListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, DorisSQLParserRULE_showSqlBlackListStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5306)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5307)
		p.Match(DorisSQLParserSQLBLACKLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowWhiteListStatementContext is an interface to support dynamic dispatch.
type IShowWhiteListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	WHITELIST() antlr.TerminalNode

	// IsShowWhiteListStatementContext differentiates from other interfaces.
	IsShowWhiteListStatementContext()
}

type ShowWhiteListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowWhiteListStatementContext() *ShowWhiteListStatementContext {
	var p = new(ShowWhiteListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showWhiteListStatement
	return p
}

func InitEmptyShowWhiteListStatementContext(p *ShowWhiteListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showWhiteListStatement
}

func (*ShowWhiteListStatementContext) IsShowWhiteListStatementContext() {}

func NewShowWhiteListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowWhiteListStatementContext {
	var p = new(ShowWhiteListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showWhiteListStatement

	return p
}

func (s *ShowWhiteListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowWhiteListStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowWhiteListStatementContext) WHITELIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHITELIST, 0)
}

func (s *ShowWhiteListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWhiteListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowWhiteListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowWhiteListStatement(s)
	}
}

func (s *ShowWhiteListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowWhiteListStatement(s)
	}
}

func (s *ShowWhiteListStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowWhiteListStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowWhiteListStatement() (localctx IShowWhiteListStatementContext) {
	localctx = NewShowWhiteListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, DorisSQLParserRULE_showWhiteListStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5309)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5310)
		p.Match(DorisSQLParserWHITELIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddBackendBlackListStatementContext is an interface to support dynamic dispatch.
type IAddBackendBlackListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	BLACKLIST() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsAddBackendBlackListStatementContext differentiates from other interfaces.
	IsAddBackendBlackListStatementContext()
}

type AddBackendBlackListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddBackendBlackListStatementContext() *AddBackendBlackListStatementContext {
	var p = new(AddBackendBlackListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_addBackendBlackListStatement
	return p
}

func InitEmptyAddBackendBlackListStatementContext(p *AddBackendBlackListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_addBackendBlackListStatement
}

func (*AddBackendBlackListStatementContext) IsAddBackendBlackListStatementContext() {}

func NewAddBackendBlackListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddBackendBlackListStatementContext {
	var p = new(AddBackendBlackListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_addBackendBlackListStatement

	return p
}

func (s *AddBackendBlackListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AddBackendBlackListStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADD, 0)
}

func (s *AddBackendBlackListStatementContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBACKEND, 0)
}

func (s *AddBackendBlackListStatementContext) BLACKLIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBLACKLIST, 0)
}

func (s *AddBackendBlackListStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserINTEGER_VALUE)
}

func (s *AddBackendBlackListStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, i)
}

func (s *AddBackendBlackListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddBackendBlackListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddBackendBlackListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAddBackendBlackListStatement(s)
	}
}

func (s *AddBackendBlackListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAddBackendBlackListStatement(s)
	}
}

func (s *AddBackendBlackListStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAddBackendBlackListStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AddBackendBlackListStatement() (localctx IAddBackendBlackListStatementContext) {
	localctx = NewAddBackendBlackListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, DorisSQLParserRULE_addBackendBlackListStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5312)
		p.Match(DorisSQLParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5313)
		p.Match(DorisSQLParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5314)
		p.Match(DorisSQLParserBLACKLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5315)
		p.Match(DorisSQLParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5320)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(5316)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5317)
			p.Match(DorisSQLParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(5322)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelBackendBlackListStatementContext is an interface to support dynamic dispatch.
type IDelBackendBlackListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	BLACKLIST() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsDelBackendBlackListStatementContext differentiates from other interfaces.
	IsDelBackendBlackListStatementContext()
}

type DelBackendBlackListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelBackendBlackListStatementContext() *DelBackendBlackListStatementContext {
	var p = new(DelBackendBlackListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_delBackendBlackListStatement
	return p
}

func InitEmptyDelBackendBlackListStatementContext(p *DelBackendBlackListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_delBackendBlackListStatement
}

func (*DelBackendBlackListStatementContext) IsDelBackendBlackListStatementContext() {}

func NewDelBackendBlackListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelBackendBlackListStatementContext {
	var p = new(DelBackendBlackListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_delBackendBlackListStatement

	return p
}

func (s *DelBackendBlackListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DelBackendBlackListStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDELETE, 0)
}

func (s *DelBackendBlackListStatementContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBACKEND, 0)
}

func (s *DelBackendBlackListStatementContext) BLACKLIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBLACKLIST, 0)
}

func (s *DelBackendBlackListStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserINTEGER_VALUE)
}

func (s *DelBackendBlackListStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, i)
}

func (s *DelBackendBlackListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelBackendBlackListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelBackendBlackListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDelBackendBlackListStatement(s)
	}
}

func (s *DelBackendBlackListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDelBackendBlackListStatement(s)
	}
}

func (s *DelBackendBlackListStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDelBackendBlackListStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DelBackendBlackListStatement() (localctx IDelBackendBlackListStatementContext) {
	localctx = NewDelBackendBlackListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, DorisSQLParserRULE_delBackendBlackListStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5323)
		p.Match(DorisSQLParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5324)
		p.Match(DorisSQLParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5325)
		p.Match(DorisSQLParserBLACKLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5326)
		p.Match(DorisSQLParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5331)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(5327)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5328)
			p.Match(DorisSQLParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(5333)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowBackendBlackListStatementContext is an interface to support dynamic dispatch.
type IShowBackendBlackListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	BLACKLIST() antlr.TerminalNode

	// IsShowBackendBlackListStatementContext differentiates from other interfaces.
	IsShowBackendBlackListStatementContext()
}

type ShowBackendBlackListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowBackendBlackListStatementContext() *ShowBackendBlackListStatementContext {
	var p = new(ShowBackendBlackListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showBackendBlackListStatement
	return p
}

func InitEmptyShowBackendBlackListStatementContext(p *ShowBackendBlackListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showBackendBlackListStatement
}

func (*ShowBackendBlackListStatementContext) IsShowBackendBlackListStatementContext() {}

func NewShowBackendBlackListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowBackendBlackListStatementContext {
	var p = new(ShowBackendBlackListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showBackendBlackListStatement

	return p
}

func (s *ShowBackendBlackListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowBackendBlackListStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowBackendBlackListStatementContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBACKEND, 0)
}

func (s *ShowBackendBlackListStatementContext) BLACKLIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBLACKLIST, 0)
}

func (s *ShowBackendBlackListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBackendBlackListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowBackendBlackListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowBackendBlackListStatement(s)
	}
}

func (s *ShowBackendBlackListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowBackendBlackListStatement(s)
	}
}

func (s *ShowBackendBlackListStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowBackendBlackListStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowBackendBlackListStatement() (localctx IShowBackendBlackListStatementContext) {
	localctx = NewShowBackendBlackListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, DorisSQLParserRULE_showBackendBlackListStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5334)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5335)
		p.Match(DorisSQLParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5336)
		p.Match(DorisSQLParserBLACKLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataCacheTargetContext is an interface to support dynamic dispatch.
type IDataCacheTargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierOrStringOrStar() []IIdentifierOrStringOrStarContext
	IdentifierOrStringOrStar(i int) IIdentifierOrStringOrStarContext

	// IsDataCacheTargetContext differentiates from other interfaces.
	IsDataCacheTargetContext()
}

type DataCacheTargetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataCacheTargetContext() *DataCacheTargetContext {
	var p = new(DataCacheTargetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dataCacheTarget
	return p
}

func InitEmptyDataCacheTargetContext(p *DataCacheTargetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dataCacheTarget
}

func (*DataCacheTargetContext) IsDataCacheTargetContext() {}

func NewDataCacheTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataCacheTargetContext {
	var p = new(DataCacheTargetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dataCacheTarget

	return p
}

func (s *DataCacheTargetContext) GetParser() antlr.Parser { return s.parser }

func (s *DataCacheTargetContext) AllIdentifierOrStringOrStar() []IIdentifierOrStringOrStarContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringOrStarContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringOrStarContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringOrStarContext); ok {
			tst[i] = t.(IIdentifierOrStringOrStarContext)
			i++
		}
	}

	return tst
}

func (s *DataCacheTargetContext) IdentifierOrStringOrStar(i int) IIdentifierOrStringOrStarContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringOrStarContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringOrStarContext)
}

func (s *DataCacheTargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataCacheTargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataCacheTargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDataCacheTarget(s)
	}
}

func (s *DataCacheTargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDataCacheTarget(s)
	}
}

func (s *DataCacheTargetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDataCacheTarget(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DataCacheTarget() (localctx IDataCacheTargetContext) {
	localctx = NewDataCacheTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, DorisSQLParserRULE_dataCacheTarget)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5338)
		p.IdentifierOrStringOrStar()
	}
	{
		p.SetState(5339)
		p.Match(DorisSQLParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5340)
		p.IdentifierOrStringOrStar()
	}
	{
		p.SetState(5341)
		p.Match(DorisSQLParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5342)
		p.IdentifierOrStringOrStar()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDataCacheRuleStatementContext is an interface to support dynamic dispatch.
type ICreateDataCacheRuleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	DATACACHE() antlr.TerminalNode
	RULE() antlr.TerminalNode
	DataCacheTarget() IDataCacheTargetContext
	PRIORITY() antlr.TerminalNode
	EQ() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	MINUS_SYMBOL() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsCreateDataCacheRuleStatementContext differentiates from other interfaces.
	IsCreateDataCacheRuleStatementContext()
}

type CreateDataCacheRuleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDataCacheRuleStatementContext() *CreateDataCacheRuleStatementContext {
	var p = new(CreateDataCacheRuleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createDataCacheRuleStatement
	return p
}

func InitEmptyCreateDataCacheRuleStatementContext(p *CreateDataCacheRuleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createDataCacheRuleStatement
}

func (*CreateDataCacheRuleStatementContext) IsCreateDataCacheRuleStatementContext() {}

func NewCreateDataCacheRuleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDataCacheRuleStatementContext {
	var p = new(CreateDataCacheRuleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createDataCacheRuleStatement

	return p
}

func (s *CreateDataCacheRuleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDataCacheRuleStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateDataCacheRuleStatementContext) DATACACHE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATACACHE, 0)
}

func (s *CreateDataCacheRuleStatementContext) RULE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRULE, 0)
}

func (s *CreateDataCacheRuleStatementContext) DataCacheTarget() IDataCacheTargetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataCacheTargetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataCacheTargetContext)
}

func (s *CreateDataCacheRuleStatementContext) PRIORITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPRIORITY, 0)
}

func (s *CreateDataCacheRuleStatementContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEQ, 0)
}

func (s *CreateDataCacheRuleStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, 0)
}

func (s *CreateDataCacheRuleStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *CreateDataCacheRuleStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CreateDataCacheRuleStatementContext) MINUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMINUS_SYMBOL, 0)
}

func (s *CreateDataCacheRuleStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateDataCacheRuleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDataCacheRuleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDataCacheRuleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateDataCacheRuleStatement(s)
	}
}

func (s *CreateDataCacheRuleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateDataCacheRuleStatement(s)
	}
}

func (s *CreateDataCacheRuleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateDataCacheRuleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateDataCacheRuleStatement() (localctx ICreateDataCacheRuleStatementContext) {
	localctx = NewCreateDataCacheRuleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, DorisSQLParserRULE_createDataCacheRuleStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5344)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5345)
		p.Match(DorisSQLParserDATACACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5346)
		p.Match(DorisSQLParserRULE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5347)
		p.DataCacheTarget()
	}
	p.SetState(5350)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWHERE {
		{
			p.SetState(5348)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5349)
			p.expression(0)
		}

	}
	{
		p.SetState(5352)
		p.Match(DorisSQLParserPRIORITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5353)
		p.Match(DorisSQLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5355)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserMINUS_SYMBOL {
		{
			p.SetState(5354)
			p.Match(DorisSQLParserMINUS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5357)
		p.Match(DorisSQLParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5359)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(5358)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDataCacheRulesStatementContext is an interface to support dynamic dispatch.
type IShowDataCacheRulesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	DATACACHE() antlr.TerminalNode
	RULES() antlr.TerminalNode

	// IsShowDataCacheRulesStatementContext differentiates from other interfaces.
	IsShowDataCacheRulesStatementContext()
}

type ShowDataCacheRulesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowDataCacheRulesStatementContext() *ShowDataCacheRulesStatementContext {
	var p = new(ShowDataCacheRulesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showDataCacheRulesStatement
	return p
}

func InitEmptyShowDataCacheRulesStatementContext(p *ShowDataCacheRulesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showDataCacheRulesStatement
}

func (*ShowDataCacheRulesStatementContext) IsShowDataCacheRulesStatementContext() {}

func NewShowDataCacheRulesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDataCacheRulesStatementContext {
	var p = new(ShowDataCacheRulesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showDataCacheRulesStatement

	return p
}

func (s *ShowDataCacheRulesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDataCacheRulesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowDataCacheRulesStatementContext) DATACACHE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATACACHE, 0)
}

func (s *ShowDataCacheRulesStatementContext) RULES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRULES, 0)
}

func (s *ShowDataCacheRulesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDataCacheRulesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDataCacheRulesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowDataCacheRulesStatement(s)
	}
}

func (s *ShowDataCacheRulesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowDataCacheRulesStatement(s)
	}
}

func (s *ShowDataCacheRulesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowDataCacheRulesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowDataCacheRulesStatement() (localctx IShowDataCacheRulesStatementContext) {
	localctx = NewShowDataCacheRulesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, DorisSQLParserRULE_showDataCacheRulesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5361)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5362)
		p.Match(DorisSQLParserDATACACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5363)
		p.Match(DorisSQLParserRULES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropDataCacheRuleStatementContext is an interface to support dynamic dispatch.
type IDropDataCacheRuleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	DATACACHE() antlr.TerminalNode
	RULE() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsDropDataCacheRuleStatementContext differentiates from other interfaces.
	IsDropDataCacheRuleStatementContext()
}

type DropDataCacheRuleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropDataCacheRuleStatementContext() *DropDataCacheRuleStatementContext {
	var p = new(DropDataCacheRuleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropDataCacheRuleStatement
	return p
}

func InitEmptyDropDataCacheRuleStatementContext(p *DropDataCacheRuleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropDataCacheRuleStatement
}

func (*DropDataCacheRuleStatementContext) IsDropDataCacheRuleStatementContext() {}

func NewDropDataCacheRuleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropDataCacheRuleStatementContext {
	var p = new(DropDataCacheRuleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropDataCacheRuleStatement

	return p
}

func (s *DropDataCacheRuleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropDataCacheRuleStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropDataCacheRuleStatementContext) DATACACHE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATACACHE, 0)
}

func (s *DropDataCacheRuleStatementContext) RULE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRULE, 0)
}

func (s *DropDataCacheRuleStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, 0)
}

func (s *DropDataCacheRuleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDataCacheRuleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropDataCacheRuleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropDataCacheRuleStatement(s)
	}
}

func (s *DropDataCacheRuleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropDataCacheRuleStatement(s)
	}
}

func (s *DropDataCacheRuleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropDataCacheRuleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropDataCacheRuleStatement() (localctx IDropDataCacheRuleStatementContext) {
	localctx = NewDropDataCacheRuleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, DorisSQLParserRULE_dropDataCacheRuleStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5365)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5366)
		p.Match(DorisSQLParserDATACACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5367)
		p.Match(DorisSQLParserRULE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5368)
		p.Match(DorisSQLParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClearDataCacheRulesStatementContext is an interface to support dynamic dispatch.
type IClearDataCacheRulesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLEAR() antlr.TerminalNode
	DATACACHE() antlr.TerminalNode
	RULES() antlr.TerminalNode

	// IsClearDataCacheRulesStatementContext differentiates from other interfaces.
	IsClearDataCacheRulesStatementContext()
}

type ClearDataCacheRulesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClearDataCacheRulesStatementContext() *ClearDataCacheRulesStatementContext {
	var p = new(ClearDataCacheRulesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_clearDataCacheRulesStatement
	return p
}

func InitEmptyClearDataCacheRulesStatementContext(p *ClearDataCacheRulesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_clearDataCacheRulesStatement
}

func (*ClearDataCacheRulesStatementContext) IsClearDataCacheRulesStatementContext() {}

func NewClearDataCacheRulesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClearDataCacheRulesStatementContext {
	var p = new(ClearDataCacheRulesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_clearDataCacheRulesStatement

	return p
}

func (s *ClearDataCacheRulesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ClearDataCacheRulesStatementContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCLEAR, 0)
}

func (s *ClearDataCacheRulesStatementContext) DATACACHE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATACACHE, 0)
}

func (s *ClearDataCacheRulesStatementContext) RULES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRULES, 0)
}

func (s *ClearDataCacheRulesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClearDataCacheRulesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClearDataCacheRulesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterClearDataCacheRulesStatement(s)
	}
}

func (s *ClearDataCacheRulesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitClearDataCacheRulesStatement(s)
	}
}

func (s *ClearDataCacheRulesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitClearDataCacheRulesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ClearDataCacheRulesStatement() (localctx IClearDataCacheRulesStatementContext) {
	localctx = NewClearDataCacheRulesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, DorisSQLParserRULE_clearDataCacheRulesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5370)
		p.Match(DorisSQLParserCLEAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5371)
		p.Match(DorisSQLParserDATACACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5372)
		p.Match(DorisSQLParserRULES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataCacheSelectStatementContext is an interface to support dynamic dispatch.
type IDataCacheSelectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	CACHE() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	AllSelectItem() []ISelectItemContext
	SelectItem(i int) ISelectItemContext
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	WHERE() antlr.TerminalNode
	Properties() IPropertiesContext
	Expression() IExpressionContext

	// IsDataCacheSelectStatementContext differentiates from other interfaces.
	IsDataCacheSelectStatementContext()
}

type DataCacheSelectStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IExpressionContext
}

func NewEmptyDataCacheSelectStatementContext() *DataCacheSelectStatementContext {
	var p = new(DataCacheSelectStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dataCacheSelectStatement
	return p
}

func InitEmptyDataCacheSelectStatementContext(p *DataCacheSelectStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dataCacheSelectStatement
}

func (*DataCacheSelectStatementContext) IsDataCacheSelectStatementContext() {}

func NewDataCacheSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataCacheSelectStatementContext {
	var p = new(DataCacheSelectStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dataCacheSelectStatement

	return p
}

func (s *DataCacheSelectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DataCacheSelectStatementContext) GetWhere() IExpressionContext { return s.where }

func (s *DataCacheSelectStatementContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *DataCacheSelectStatementContext) CACHE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCACHE, 0)
}

func (s *DataCacheSelectStatementContext) SELECT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSELECT, 0)
}

func (s *DataCacheSelectStatementContext) AllSelectItem() []ISelectItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectItemContext); ok {
			len++
		}
	}

	tst := make([]ISelectItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectItemContext); ok {
			tst[i] = t.(ISelectItemContext)
			i++
		}
	}

	return tst
}

func (s *DataCacheSelectStatementContext) SelectItem(i int) ISelectItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectItemContext)
}

func (s *DataCacheSelectStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *DataCacheSelectStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DataCacheSelectStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *DataCacheSelectStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *DataCacheSelectStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DataCacheSelectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataCacheSelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataCacheSelectStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDataCacheSelectStatement(s)
	}
}

func (s *DataCacheSelectStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDataCacheSelectStatement(s)
	}
}

func (s *DataCacheSelectStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDataCacheSelectStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DataCacheSelectStatement() (localctx IDataCacheSelectStatementContext) {
	localctx = NewDataCacheSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, DorisSQLParserRULE_dataCacheSelectStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5374)
		p.Match(DorisSQLParserCACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5375)
		p.Match(DorisSQLParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5376)
		p.SelectItem()
	}
	p.SetState(5381)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(5377)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5378)
			p.SelectItem()
		}

		p.SetState(5383)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5384)
		p.Match(DorisSQLParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5385)
		p.QualifiedName()
	}
	p.SetState(5388)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWHERE {
		{
			p.SetState(5386)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5387)

			var _x = p.expression(0)

			localctx.(*DataCacheSelectStatementContext).where = _x
		}

	}
	p.SetState(5391)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(5390)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportStatementContext is an interface to support dynamic dispatch.
type IExportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXPORT() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableDesc() ITableDescContext
	TO() antlr.TerminalNode
	String_() IStringContext
	ColumnAliases() IColumnAliasesContext
	WITH() antlr.TerminalNode
	MODE() antlr.TerminalNode
	Properties() IPropertiesContext
	BrokerDesc() IBrokerDescContext
	SYNC() antlr.TerminalNode
	ASYNC() antlr.TerminalNode

	// IsExportStatementContext differentiates from other interfaces.
	IsExportStatementContext()
}

type ExportStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportStatementContext() *ExportStatementContext {
	var p = new(ExportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_exportStatement
	return p
}

func InitEmptyExportStatementContext(p *ExportStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_exportStatement
}

func (*ExportStatementContext) IsExportStatementContext() {}

func NewExportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportStatementContext {
	var p = new(ExportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_exportStatement

	return p
}

func (s *ExportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportStatementContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXPORT, 0)
}

func (s *ExportStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *ExportStatementContext) TableDesc() ITableDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableDescContext)
}

func (s *ExportStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTO, 0)
}

func (s *ExportStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ExportStatementContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *ExportStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *ExportStatementContext) MODE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMODE, 0)
}

func (s *ExportStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *ExportStatementContext) BrokerDesc() IBrokerDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBrokerDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBrokerDescContext)
}

func (s *ExportStatementContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSYNC, 0)
}

func (s *ExportStatementContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserASYNC, 0)
}

func (s *ExportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterExportStatement(s)
	}
}

func (s *ExportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitExportStatement(s)
	}
}

func (s *ExportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitExportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ExportStatement() (localctx IExportStatementContext) {
	localctx = NewExportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, DorisSQLParserRULE_exportStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5393)
		p.Match(DorisSQLParserEXPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5394)
		p.Match(DorisSQLParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5395)
		p.TableDesc()
	}
	p.SetState(5397)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserT__1 {
		{
			p.SetState(5396)
			p.ColumnAliases()
		}

	}
	{
		p.SetState(5399)
		p.Match(DorisSQLParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5400)
		p.String_()
	}
	p.SetState(5404)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 579, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5401)
			p.Match(DorisSQLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5402)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserASYNC || _la == DorisSQLParserSYNC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5403)
			p.Match(DorisSQLParserMODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(5407)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(5406)
			p.Properties()
		}

	}
	p.SetState(5410)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWITH {
		{
			p.SetState(5409)
			p.BrokerDesc()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelExportStatementContext is an interface to support dynamic dispatch.
type ICancelExportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	CANCEL() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsCancelExportStatementContext differentiates from other interfaces.
	IsCancelExportStatementContext()
}

type CancelExportStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyCancelExportStatementContext() *CancelExportStatementContext {
	var p = new(CancelExportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cancelExportStatement
	return p
}

func InitEmptyCancelExportStatementContext(p *CancelExportStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_cancelExportStatement
}

func (*CancelExportStatementContext) IsCancelExportStatementContext() {}

func NewCancelExportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelExportStatementContext {
	var p = new(CancelExportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_cancelExportStatement

	return p
}

func (s *CancelExportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelExportStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *CancelExportStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *CancelExportStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *CancelExportStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *CancelExportStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCANCEL, 0)
}

func (s *CancelExportStatementContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXPORT, 0)
}

func (s *CancelExportStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *CancelExportStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *CancelExportStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CancelExportStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *CancelExportStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *CancelExportStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CancelExportStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CancelExportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelExportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelExportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCancelExportStatement(s)
	}
}

func (s *CancelExportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCancelExportStatement(s)
	}
}

func (s *CancelExportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCancelExportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CancelExportStatement() (localctx ICancelExportStatementContext) {
	localctx = NewCancelExportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, DorisSQLParserRULE_cancelExportStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5412)
		p.Match(DorisSQLParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5413)
		p.Match(DorisSQLParserEXPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5416)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM || _la == DorisSQLParserIN {
		{
			p.SetState(5414)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5415)

			var _x = p.QualifiedName()

			localctx.(*CancelExportStatementContext).catalog = _x
		}

	}
	p.SetState(5422)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserLIKE:
		{
			p.SetState(5418)
			p.Match(DorisSQLParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5419)

			var _x = p.String_()

			localctx.(*CancelExportStatementContext).pattern = _x
		}

	case DorisSQLParserWHERE:
		{
			p.SetState(5420)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5421)
			p.expression(0)
		}

	case DorisSQLParserEOF, DorisSQLParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowExportStatementContext is an interface to support dynamic dispatch.
type IShowExportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowExportStatementContext differentiates from other interfaces.
	IsShowExportStatementContext()
}

type ShowExportStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowExportStatementContext() *ShowExportStatementContext {
	var p = new(ShowExportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showExportStatement
	return p
}

func InitEmptyShowExportStatementContext(p *ShowExportStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showExportStatement
}

func (*ShowExportStatementContext) IsShowExportStatementContext() {}

func NewShowExportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowExportStatementContext {
	var p = new(ShowExportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showExportStatement

	return p
}

func (s *ShowExportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowExportStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *ShowExportStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowExportStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *ShowExportStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowExportStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowExportStatementContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXPORT, 0)
}

func (s *ShowExportStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserORDER, 0)
}

func (s *ShowExportStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *ShowExportStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowExportStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowExportStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowExportStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowExportStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *ShowExportStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowExportStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *ShowExportStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowExportStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowExportStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowExportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowExportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowExportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowExportStatement(s)
	}
}

func (s *ShowExportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowExportStatement(s)
	}
}

func (s *ShowExportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowExportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowExportStatement() (localctx IShowExportStatementContext) {
	localctx = NewShowExportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, DorisSQLParserRULE_showExportStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5424)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5425)
		p.Match(DorisSQLParserEXPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5428)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM || _la == DorisSQLParserIN {
		{
			p.SetState(5426)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5427)

			var _x = p.QualifiedName()

			localctx.(*ShowExportStatementContext).catalog = _x
		}

	}
	p.SetState(5434)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserLIKE:
		{
			p.SetState(5430)
			p.Match(DorisSQLParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5431)

			var _x = p.String_()

			localctx.(*ShowExportStatementContext).pattern = _x
		}

	case DorisSQLParserWHERE:
		{
			p.SetState(5432)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5433)
			p.expression(0)
		}

	case DorisSQLParserEOF, DorisSQLParserLIMIT, DorisSQLParserORDER, DorisSQLParserSEMICOLON:

	default:
	}
	p.SetState(5446)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserORDER {
		{
			p.SetState(5436)
			p.Match(DorisSQLParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5437)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5438)
			p.SortItem()
		}
		p.SetState(5443)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(5439)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5440)
				p.SortItem()
			}

			p.SetState(5445)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(5449)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserLIMIT {
		{
			p.SetState(5448)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstallPluginStatementContext is an interface to support dynamic dispatch.
type IInstallPluginStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INSTALL() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	Properties() IPropertiesContext

	// IsInstallPluginStatementContext differentiates from other interfaces.
	IsInstallPluginStatementContext()
}

type InstallPluginStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstallPluginStatementContext() *InstallPluginStatementContext {
	var p = new(InstallPluginStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_installPluginStatement
	return p
}

func InitEmptyInstallPluginStatementContext(p *InstallPluginStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_installPluginStatement
}

func (*InstallPluginStatementContext) IsInstallPluginStatementContext() {}

func NewInstallPluginStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstallPluginStatementContext {
	var p = new(InstallPluginStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_installPluginStatement

	return p
}

func (s *InstallPluginStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InstallPluginStatementContext) INSTALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINSTALL, 0)
}

func (s *InstallPluginStatementContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPLUGIN, 0)
}

func (s *InstallPluginStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *InstallPluginStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *InstallPluginStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *InstallPluginStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstallPluginStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstallPluginStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterInstallPluginStatement(s)
	}
}

func (s *InstallPluginStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitInstallPluginStatement(s)
	}
}

func (s *InstallPluginStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitInstallPluginStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) InstallPluginStatement() (localctx IInstallPluginStatementContext) {
	localctx = NewInstallPluginStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, DorisSQLParserRULE_installPluginStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5451)
		p.Match(DorisSQLParserINSTALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5452)
		p.Match(DorisSQLParserPLUGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5453)
		p.Match(DorisSQLParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5454)
		p.IdentifierOrString()
	}
	p.SetState(5456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(5455)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUninstallPluginStatementContext is an interface to support dynamic dispatch.
type IUninstallPluginStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNINSTALL() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsUninstallPluginStatementContext differentiates from other interfaces.
	IsUninstallPluginStatementContext()
}

type UninstallPluginStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUninstallPluginStatementContext() *UninstallPluginStatementContext {
	var p = new(UninstallPluginStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_uninstallPluginStatement
	return p
}

func InitEmptyUninstallPluginStatementContext(p *UninstallPluginStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_uninstallPluginStatement
}

func (*UninstallPluginStatementContext) IsUninstallPluginStatementContext() {}

func NewUninstallPluginStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UninstallPluginStatementContext {
	var p = new(UninstallPluginStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_uninstallPluginStatement

	return p
}

func (s *UninstallPluginStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UninstallPluginStatementContext) UNINSTALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUNINSTALL, 0)
}

func (s *UninstallPluginStatementContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPLUGIN, 0)
}

func (s *UninstallPluginStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *UninstallPluginStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UninstallPluginStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UninstallPluginStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterUninstallPluginStatement(s)
	}
}

func (s *UninstallPluginStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitUninstallPluginStatement(s)
	}
}

func (s *UninstallPluginStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitUninstallPluginStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) UninstallPluginStatement() (localctx IUninstallPluginStatementContext) {
	localctx = NewUninstallPluginStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, DorisSQLParserRULE_uninstallPluginStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5458)
		p.Match(DorisSQLParserUNINSTALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5459)
		p.Match(DorisSQLParserPLUGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5460)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateFileStatementContext is an interface to support dynamic dispatch.
type ICreateFileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	FILE() antlr.TerminalNode
	String_() IStringContext
	Properties() IPropertiesContext
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsCreateFileStatementContext differentiates from other interfaces.
	IsCreateFileStatementContext()
}

type CreateFileStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
}

func NewEmptyCreateFileStatementContext() *CreateFileStatementContext {
	var p = new(CreateFileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createFileStatement
	return p
}

func InitEmptyCreateFileStatementContext(p *CreateFileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createFileStatement
}

func (*CreateFileStatementContext) IsCreateFileStatementContext() {}

func NewCreateFileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateFileStatementContext {
	var p = new(CreateFileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createFileStatement

	return p
}

func (s *CreateFileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateFileStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *CreateFileStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *CreateFileStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateFileStatementContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFILE, 0)
}

func (s *CreateFileStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CreateFileStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateFileStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *CreateFileStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *CreateFileStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateFileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateFileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateFileStatement(s)
	}
}

func (s *CreateFileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateFileStatement(s)
	}
}

func (s *CreateFileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateFileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateFileStatement() (localctx ICreateFileStatementContext) {
	localctx = NewCreateFileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, DorisSQLParserRULE_createFileStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5462)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5463)
		p.Match(DorisSQLParserFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5464)
		p.String_()
	}
	p.SetState(5467)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM || _la == DorisSQLParserIN {
		{
			p.SetState(5465)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5466)

			var _x = p.QualifiedName()

			localctx.(*CreateFileStatementContext).catalog = _x
		}

	}
	{
		p.SetState(5469)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropFileStatementContext is an interface to support dynamic dispatch.
type IDropFileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	FILE() antlr.TerminalNode
	String_() IStringContext
	Properties() IPropertiesContext
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsDropFileStatementContext differentiates from other interfaces.
	IsDropFileStatementContext()
}

type DropFileStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
}

func NewEmptyDropFileStatementContext() *DropFileStatementContext {
	var p = new(DropFileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropFileStatement
	return p
}

func InitEmptyDropFileStatementContext(p *DropFileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropFileStatement
}

func (*DropFileStatementContext) IsDropFileStatementContext() {}

func NewDropFileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFileStatementContext {
	var p = new(DropFileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropFileStatement

	return p
}

func (s *DropFileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFileStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *DropFileStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *DropFileStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropFileStatementContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFILE, 0)
}

func (s *DropFileStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DropFileStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *DropFileStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *DropFileStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *DropFileStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropFileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropFileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropFileStatement(s)
	}
}

func (s *DropFileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropFileStatement(s)
	}
}

func (s *DropFileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropFileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropFileStatement() (localctx IDropFileStatementContext) {
	localctx = NewDropFileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, DorisSQLParserRULE_dropFileStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5471)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5472)
		p.Match(DorisSQLParserFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5473)
		p.String_()
	}
	p.SetState(5476)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM || _la == DorisSQLParserIN {
		{
			p.SetState(5474)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5475)

			var _x = p.QualifiedName()

			localctx.(*DropFileStatementContext).catalog = _x
		}

	}
	{
		p.SetState(5478)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowSmallFilesStatementContext is an interface to support dynamic dispatch.
type IShowSmallFilesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	FILE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowSmallFilesStatementContext differentiates from other interfaces.
	IsShowSmallFilesStatementContext()
}

type ShowSmallFilesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
}

func NewEmptyShowSmallFilesStatementContext() *ShowSmallFilesStatementContext {
	var p = new(ShowSmallFilesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showSmallFilesStatement
	return p
}

func InitEmptyShowSmallFilesStatementContext(p *ShowSmallFilesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showSmallFilesStatement
}

func (*ShowSmallFilesStatementContext) IsShowSmallFilesStatementContext() {}

func NewShowSmallFilesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowSmallFilesStatementContext {
	var p = new(ShowSmallFilesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showSmallFilesStatement

	return p
}

func (s *ShowSmallFilesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowSmallFilesStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *ShowSmallFilesStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *ShowSmallFilesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowSmallFilesStatementContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFILE, 0)
}

func (s *ShowSmallFilesStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowSmallFilesStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *ShowSmallFilesStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowSmallFilesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSmallFilesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowSmallFilesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowSmallFilesStatement(s)
	}
}

func (s *ShowSmallFilesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowSmallFilesStatement(s)
	}
}

func (s *ShowSmallFilesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowSmallFilesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowSmallFilesStatement() (localctx IShowSmallFilesStatementContext) {
	localctx = NewShowSmallFilesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, DorisSQLParserRULE_showSmallFilesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5480)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5481)
		p.Match(DorisSQLParserFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5484)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFROM || _la == DorisSQLParserIN {
		{
			p.SetState(5482)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserFROM || _la == DorisSQLParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5483)

			var _x = p.QualifiedName()

			localctx.(*ShowSmallFilesStatementContext).catalog = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreatePipeStatementContext is an interface to support dynamic dispatch.
type ICreatePipeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	OrReplace() IOrReplaceContext
	PIPE() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	QualifiedName() IQualifiedNameContext
	AS() antlr.TerminalNode
	InsertStatement() IInsertStatementContext
	Properties() IPropertiesContext

	// IsCreatePipeStatementContext differentiates from other interfaces.
	IsCreatePipeStatementContext()
}

type CreatePipeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreatePipeStatementContext() *CreatePipeStatementContext {
	var p = new(CreatePipeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createPipeStatement
	return p
}

func InitEmptyCreatePipeStatementContext(p *CreatePipeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createPipeStatement
}

func (*CreatePipeStatementContext) IsCreatePipeStatementContext() {}

func NewCreatePipeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreatePipeStatementContext {
	var p = new(CreatePipeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createPipeStatement

	return p
}

func (s *CreatePipeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreatePipeStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreatePipeStatementContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreatePipeStatementContext) PIPE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPIPE, 0)
}

func (s *CreatePipeStatementContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreatePipeStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreatePipeStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *CreatePipeStatementContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *CreatePipeStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreatePipeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatePipeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreatePipeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreatePipeStatement(s)
	}
}

func (s *CreatePipeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreatePipeStatement(s)
	}
}

func (s *CreatePipeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreatePipeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreatePipeStatement() (localctx ICreatePipeStatementContext) {
	localctx = NewCreatePipeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 666, DorisSQLParserRULE_createPipeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5486)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5487)
		p.OrReplace()
	}
	{
		p.SetState(5488)
		p.Match(DorisSQLParserPIPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5489)
		p.IfNotExists()
	}
	{
		p.SetState(5490)
		p.QualifiedName()
	}
	p.SetState(5492)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(5491)
			p.Properties()
		}

	}
	{
		p.SetState(5494)
		p.Match(DorisSQLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5495)
		p.InsertStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropPipeStatementContext is an interface to support dynamic dispatch.
type IDropPipeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	PIPE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropPipeStatementContext differentiates from other interfaces.
	IsDropPipeStatementContext()
}

type DropPipeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropPipeStatementContext() *DropPipeStatementContext {
	var p = new(DropPipeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropPipeStatement
	return p
}

func InitEmptyDropPipeStatementContext(p *DropPipeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropPipeStatement
}

func (*DropPipeStatementContext) IsDropPipeStatementContext() {}

func NewDropPipeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropPipeStatementContext {
	var p = new(DropPipeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropPipeStatement

	return p
}

func (s *DropPipeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropPipeStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropPipeStatementContext) PIPE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPIPE, 0)
}

func (s *DropPipeStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropPipeStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *DropPipeStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *DropPipeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropPipeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropPipeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropPipeStatement(s)
	}
}

func (s *DropPipeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropPipeStatement(s)
	}
}

func (s *DropPipeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropPipeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropPipeStatement() (localctx IDropPipeStatementContext) {
	localctx = NewDropPipeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 668, DorisSQLParserRULE_dropPipeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5497)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5498)
		p.Match(DorisSQLParserPIPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5501)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(5499)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5500)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5503)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterPipeClauseContext is an interface to support dynamic dispatch.
type IAlterPipeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFileName returns the fileName rule contexts.
	GetFileName() IStringContext

	// SetFileName sets the fileName rule contexts.
	SetFileName(IStringContext)

	// Getter signatures
	SUSPEND() antlr.TerminalNode
	RESUME() antlr.TerminalNode
	RETRY() antlr.TerminalNode
	ALL() antlr.TerminalNode
	FILE() antlr.TerminalNode
	String_() IStringContext
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsAlterPipeClauseContext differentiates from other interfaces.
	IsAlterPipeClauseContext()
}

type AlterPipeClauseContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	fileName IStringContext
}

func NewEmptyAlterPipeClauseContext() *AlterPipeClauseContext {
	var p = new(AlterPipeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterPipeClause
	return p
}

func InitEmptyAlterPipeClauseContext(p *AlterPipeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterPipeClause
}

func (*AlterPipeClauseContext) IsAlterPipeClauseContext() {}

func NewAlterPipeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterPipeClauseContext {
	var p = new(AlterPipeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_alterPipeClause

	return p
}

func (s *AlterPipeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterPipeClauseContext) GetFileName() IStringContext { return s.fileName }

func (s *AlterPipeClauseContext) SetFileName(v IStringContext) { s.fileName = v }

func (s *AlterPipeClauseContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSUSPEND, 0)
}

func (s *AlterPipeClauseContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRESUME, 0)
}

func (s *AlterPipeClauseContext) RETRY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRETRY, 0)
}

func (s *AlterPipeClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, 0)
}

func (s *AlterPipeClauseContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFILE, 0)
}

func (s *AlterPipeClauseContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AlterPipeClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *AlterPipeClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *AlterPipeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterPipeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterPipeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAlterPipeClause(s)
	}
}

func (s *AlterPipeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAlterPipeClause(s)
	}
}

func (s *AlterPipeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAlterPipeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AlterPipeClause() (localctx IAlterPipeClauseContext) {
	localctx = NewAlterPipeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 670, DorisSQLParserRULE_alterPipeClause)
	p.SetState(5514)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 595, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5505)
			p.Match(DorisSQLParserSUSPEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5506)
			p.Match(DorisSQLParserRESUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5507)
			p.Match(DorisSQLParserRETRY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5508)
			p.Match(DorisSQLParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5509)
			p.Match(DorisSQLParserRETRY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5510)
			p.Match(DorisSQLParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5511)

			var _x = p.String_()

			localctx.(*AlterPipeClauseContext).fileName = _x
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5512)
			p.Match(DorisSQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5513)
			p.PropertyList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterPipeStatementContext is an interface to support dynamic dispatch.
type IAlterPipeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	PIPE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AlterPipeClause() IAlterPipeClauseContext

	// IsAlterPipeStatementContext differentiates from other interfaces.
	IsAlterPipeStatementContext()
}

type AlterPipeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterPipeStatementContext() *AlterPipeStatementContext {
	var p = new(AlterPipeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterPipeStatement
	return p
}

func InitEmptyAlterPipeStatementContext(p *AlterPipeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterPipeStatement
}

func (*AlterPipeStatementContext) IsAlterPipeStatementContext() {}

func NewAlterPipeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterPipeStatementContext {
	var p = new(AlterPipeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_alterPipeStatement

	return p
}

func (s *AlterPipeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterPipeStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *AlterPipeStatementContext) PIPE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPIPE, 0)
}

func (s *AlterPipeStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterPipeStatementContext) AlterPipeClause() IAlterPipeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterPipeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterPipeClauseContext)
}

func (s *AlterPipeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterPipeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterPipeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAlterPipeStatement(s)
	}
}

func (s *AlterPipeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAlterPipeStatement(s)
	}
}

func (s *AlterPipeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAlterPipeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AlterPipeStatement() (localctx IAlterPipeStatementContext) {
	localctx = NewAlterPipeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 672, DorisSQLParserRULE_alterPipeStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5516)
		p.Match(DorisSQLParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5517)
		p.Match(DorisSQLParserPIPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5518)
		p.QualifiedName()
	}
	{
		p.SetState(5519)
		p.AlterPipeClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescPipeStatementContext is an interface to support dynamic dispatch.
type IDescPipeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PIPE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode

	// IsDescPipeStatementContext differentiates from other interfaces.
	IsDescPipeStatementContext()
}

type DescPipeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescPipeStatementContext() *DescPipeStatementContext {
	var p = new(DescPipeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_descPipeStatement
	return p
}

func InitEmptyDescPipeStatementContext(p *DescPipeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_descPipeStatement
}

func (*DescPipeStatementContext) IsDescPipeStatementContext() {}

func NewDescPipeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescPipeStatementContext {
	var p = new(DescPipeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_descPipeStatement

	return p
}

func (s *DescPipeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DescPipeStatementContext) PIPE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPIPE, 0)
}

func (s *DescPipeStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DescPipeStatementContext) DESC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDESC, 0)
}

func (s *DescPipeStatementContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDESCRIBE, 0)
}

func (s *DescPipeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescPipeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescPipeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDescPipeStatement(s)
	}
}

func (s *DescPipeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDescPipeStatement(s)
	}
}

func (s *DescPipeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDescPipeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DescPipeStatement() (localctx IDescPipeStatementContext) {
	localctx = NewDescPipeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 674, DorisSQLParserRULE_descPipeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5521)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserDESC || _la == DorisSQLParserDESCRIBE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5522)
		p.Match(DorisSQLParserPIPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5523)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowPipeStatementContext is an interface to support dynamic dispatch.
type IShowPipeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	PIPES() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	String_() IStringContext

	// IsShowPipeStatementContext differentiates from other interfaces.
	IsShowPipeStatementContext()
}

type ShowPipeStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowPipeStatementContext() *ShowPipeStatementContext {
	var p = new(ShowPipeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showPipeStatement
	return p
}

func InitEmptyShowPipeStatementContext(p *ShowPipeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showPipeStatement
}

func (*ShowPipeStatementContext) IsShowPipeStatementContext() {}

func NewShowPipeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowPipeStatementContext {
	var p = new(ShowPipeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showPipeStatement

	return p
}

func (s *ShowPipeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowPipeStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowPipeStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowPipeStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowPipeStatementContext) PIPES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPIPES, 0)
}

func (s *ShowPipeStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserORDER, 0)
}

func (s *ShowPipeStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *ShowPipeStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowPipeStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowPipeStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowPipeStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *ShowPipeStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *ShowPipeStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowPipeStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowPipeStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowPipeStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowPipeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPipeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowPipeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowPipeStatement(s)
	}
}

func (s *ShowPipeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowPipeStatement(s)
	}
}

func (s *ShowPipeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowPipeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowPipeStatement() (localctx IShowPipeStatementContext) {
	localctx = NewShowPipeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 676, DorisSQLParserRULE_showPipeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5525)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5526)
		p.Match(DorisSQLParserPIPES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5533)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserLIKE:
		{
			p.SetState(5527)
			p.Match(DorisSQLParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5528)

			var _x = p.String_()

			localctx.(*ShowPipeStatementContext).pattern = _x
		}

	case DorisSQLParserWHERE:
		{
			p.SetState(5529)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5530)
			p.expression(0)
		}

	case DorisSQLParserFROM:
		{
			p.SetState(5531)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5532)
			p.QualifiedName()
		}

	case DorisSQLParserEOF, DorisSQLParserLIMIT, DorisSQLParserORDER, DorisSQLParserSEMICOLON:

	default:
	}
	p.SetState(5545)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserORDER {
		{
			p.SetState(5535)
			p.Match(DorisSQLParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5536)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5537)
			p.SortItem()
		}
		p.SetState(5542)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(5538)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5539)
				p.SortItem()
			}

			p.SetState(5544)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(5548)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserLIMIT {
		{
			p.SetState(5547)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetStatementContext is an interface to support dynamic dispatch.
type ISetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	AllSetVar() []ISetVarContext
	SetVar(i int) ISetVarContext

	// IsSetStatementContext differentiates from other interfaces.
	IsSetStatementContext()
}

type SetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetStatementContext() *SetStatementContext {
	var p = new(SetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_setStatement
	return p
}

func InitEmptySetStatementContext(p *SetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_setStatement
}

func (*SetStatementContext) IsSetStatementContext() {}

func NewSetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetStatementContext {
	var p = new(SetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_setStatement

	return p
}

func (s *SetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *SetStatementContext) AllSetVar() []ISetVarContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISetVarContext); ok {
			len++
		}
	}

	tst := make([]ISetVarContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISetVarContext); ok {
			tst[i] = t.(ISetVarContext)
			i++
		}
	}

	return tst
}

func (s *SetStatementContext) SetVar(i int) ISetVarContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetVarContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetVarContext)
}

func (s *SetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSetStatement(s)
	}
}

func (s *SetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSetStatement(s)
	}
}

func (s *SetStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSetStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SetStatement() (localctx ISetStatementContext) {
	localctx = NewSetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 678, DorisSQLParserRULE_setStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5550)
		p.Match(DorisSQLParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5551)
		p.SetVar()
	}
	p.SetState(5556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(5552)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5553)
			p.SetVar()
		}

		p.SetState(5558)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetVarContext is an interface to support dynamic dispatch.
type ISetVarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSetVarContext differentiates from other interfaces.
	IsSetVarContext()
}

type SetVarContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetVarContext() *SetVarContext {
	var p = new(SetVarContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_setVar
	return p
}

func InitEmptySetVarContext(p *SetVarContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_setVar
}

func (*SetVarContext) IsSetVarContext() {}

func NewSetVarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetVarContext {
	var p = new(SetVarContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_setVar

	return p
}

func (s *SetVarContext) GetParser() antlr.Parser { return s.parser }

func (s *SetVarContext) CopyAll(ctx *SetVarContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SetVarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetVarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SetTransactionContext struct {
	SetVarContext
}

func NewSetTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetTransactionContext {
	var p = new(SetTransactionContext)

	InitEmptySetVarContext(&p.SetVarContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetVarContext))

	return p
}

func (s *SetTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTRANSACTION, 0)
}

func (s *SetTransactionContext) Transaction_characteristics() ITransaction_characteristicsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransaction_characteristicsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransaction_characteristicsContext)
}

func (s *SetTransactionContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *SetTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSetTransaction(s)
	}
}

func (s *SetTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSetTransaction(s)
	}
}

func (s *SetTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSetTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetNamesContext struct {
	SetVarContext
	charset IIdentifierOrStringContext
	collate IIdentifierOrStringContext
}

func NewSetNamesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetNamesContext {
	var p = new(SetNamesContext)

	InitEmptySetVarContext(&p.SetVarContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetVarContext))

	return p
}

func (s *SetNamesContext) GetCharset() IIdentifierOrStringContext { return s.charset }

func (s *SetNamesContext) GetCollate() IIdentifierOrStringContext { return s.collate }

func (s *SetNamesContext) SetCharset(v IIdentifierOrStringContext) { s.charset = v }

func (s *SetNamesContext) SetCollate(v IIdentifierOrStringContext) { s.collate = v }

func (s *SetNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetNamesContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCHAR, 0)
}

func (s *SetNamesContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *SetNamesContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCHARSET, 0)
}

func (s *SetNamesContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCHARACTER, 0)
}

func (s *SetNamesContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *SetNamesContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *SetNamesContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserDEFAULT)
}

func (s *SetNamesContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDEFAULT, i)
}

func (s *SetNamesContext) NAMES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNAMES, 0)
}

func (s *SetNamesContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLLATE, 0)
}

func (s *SetNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSetNames(s)
	}
}

func (s *SetNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSetNames(s)
	}
}

func (s *SetNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSetNames(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetPasswordContext struct {
	SetVarContext
}

func NewSetPasswordContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetPasswordContext {
	var p = new(SetPasswordContext)

	InitEmptySetVarContext(&p.SetVarContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetVarContext))

	return p
}

func (s *SetPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetPasswordContext) AllPASSWORD() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserPASSWORD)
}

func (s *SetPasswordContext) PASSWORD(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPASSWORD, i)
}

func (s *SetPasswordContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEQ, 0)
}

func (s *SetPasswordContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *SetPasswordContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFOR, 0)
}

func (s *SetPasswordContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *SetPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSetPassword(s)
	}
}

func (s *SetPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSetPassword(s)
	}
}

func (s *SetPasswordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSetPassword(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetUserVarContext struct {
	SetVarContext
}

func NewSetUserVarContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetUserVarContext {
	var p = new(SetUserVarContext)

	InitEmptySetVarContext(&p.SetVarContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetVarContext))

	return p
}

func (s *SetUserVarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetUserVarContext) UserVariable() IUserVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariableContext)
}

func (s *SetUserVarContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEQ, 0)
}

func (s *SetUserVarContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetUserVarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSetUserVar(s)
	}
}

func (s *SetUserVarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSetUserVar(s)
	}
}

func (s *SetUserVarContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSetUserVar(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetSystemVarContext struct {
	SetVarContext
}

func NewSetSystemVarContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetSystemVarContext {
	var p = new(SetSystemVarContext)

	InitEmptySetVarContext(&p.SetVarContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetVarContext))

	return p
}

func (s *SetSystemVarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetSystemVarContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetSystemVarContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEQ, 0)
}

func (s *SetSystemVarContext) SetExprOrDefault() ISetExprOrDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetExprOrDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetExprOrDefaultContext)
}

func (s *SetSystemVarContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *SetSystemVarContext) SystemVariable() ISystemVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISystemVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISystemVariableContext)
}

func (s *SetSystemVarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSetSystemVar(s)
	}
}

func (s *SetSystemVarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSetSystemVar(s)
	}
}

func (s *SetSystemVarContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSetSystemVar(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SetVar() (localctx ISetVarContext) {
	localctx = NewSetVarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 680, DorisSQLParserRULE_setVar)
	var _la int

	p.SetState(5624)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 610, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSetNamesContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5564)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserCHAR:
			{
				p.SetState(5559)
				p.Match(DorisSQLParserCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5560)
				p.Match(DorisSQLParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisSQLParserCHARSET:
			{
				p.SetState(5561)
				p.Match(DorisSQLParserCHARSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisSQLParserCHARACTER:
			{
				p.SetState(5562)
				p.Match(DorisSQLParserCHARACTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5563)
				p.Match(DorisSQLParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(5568)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserACCESS, DorisSQLParserACTIVE, DorisSQLParserADMIN, DorisSQLParserADVISOR, DorisSQLParserAFTER, DorisSQLParserAGGREGATE, DorisSQLParserANTI, DorisSQLParserAPPLY, DorisSQLParserARRAY_AGG, DorisSQLParserARRAY_AGG_DISTINCT, DorisSQLParserASYNC, DorisSQLParserAUTHORS, DorisSQLParserAUTHENTICATION, DorisSQLParserAUTOMATED, DorisSQLParserAUTO_INCREMENT, DorisSQLParserAVG, DorisSQLParserBACKEND, DorisSQLParserBACKENDS, DorisSQLParserBACKUP, DorisSQLParserBASE, DorisSQLParserBASELINE, DorisSQLParserBEGIN, DorisSQLParserBINARY, DorisSQLParserBITMAP_UNION, DorisSQLParserBLACKHOLE, DorisSQLParserBLACKLIST, DorisSQLParserBODY, DorisSQLParserBOOLEAN, DorisSQLParserBRANCH, DorisSQLParserBROKER, DorisSQLParserBUCKETS, DorisSQLParserBUILTIN, DorisSQLParserCACHE, DorisSQLParserCANCEL, DorisSQLParserCAST, DorisSQLParserCATALOG, DorisSQLParserCATALOGS, DorisSQLParserCEIL, DorisSQLParserCHAIN, DorisSQLParserCHARSET, DorisSQLParserCLEAN, DorisSQLParserCLEAR, DorisSQLParserCLUSTER, DorisSQLParserCLUSTERS, DorisSQLParserCNGROUP, DorisSQLParserCNGROUPS, DorisSQLParserCOLLATION, DorisSQLParserCOLUMNS, DorisSQLParserCOMMENT, DorisSQLParserCOMMIT, DorisSQLParserCOMMITTED, DorisSQLParserCOMPACT, DorisSQLParserCOMPUTE, DorisSQLParserCONFIG, DorisSQLParserCONNECTION, DorisSQLParserCONSISTENT, DorisSQLParserCOSTS, DorisSQLParserCOUNT, DorisSQLParserCUME_DIST, DorisSQLParserCUMULATIVE, DorisSQLParserCURRENT, DorisSQLParserDATA, DorisSQLParserDATACACHE, DorisSQLParserDATE, DorisSQLParserDATETIME, DorisSQLParserDAY, DorisSQLParserDAYS, DorisSQLParserDEALLOCATE, DorisSQLParserDECOMMISSION, DorisSQLParserDIALECT, DorisSQLParserDICTIONARY, DorisSQLParserDICTIONARY_GET, DorisSQLParserDISABLE, DorisSQLParserDISTRIBUTED, DorisSQLParserDISTRIBUTION, DorisSQLParserDUPLICATE, DorisSQLParserDYNAMIC, DorisSQLParserENABLE, DorisSQLParserENCLOSE, DorisSQLParserEND, DorisSQLParserENGINE, DorisSQLParserENGINES, DorisSQLParserERRORS, DorisSQLParserESCAPE, DorisSQLParserEVENTS, DorisSQLParserEXCEPT, DorisSQLParserEXCLUDE, DorisSQLParserEXECUTE, DorisSQLParserEXPORT, DorisSQLParserEXTERNAL, DorisSQLParserEXTRACT, DorisSQLParserEVERY, DorisSQLParserFAILPOINT, DorisSQLParserFAILPOINTS, DorisSQLParserFIELDS, DorisSQLParserFILE, DorisSQLParserFILTER, DorisSQLParserFIRST, DorisSQLParserFLOOR, DorisSQLParserFN, DorisSQLParserFOLLOWING, DorisSQLParserFOLLOWER, DorisSQLParserFORMAT, DorisSQLParserFREE, DorisSQLParserFRONTEND, DorisSQLParserFRONTENDS, DorisSQLParserFUNCTIONS, DorisSQLParserGLOBAL, DorisSQLParserGRANTS, DorisSQLParserGROUP_CONCAT, DorisSQLParserHASH, DorisSQLParserHELP, DorisSQLParserHISTOGRAM, DorisSQLParserHLL_UNION, DorisSQLParserHOST, DorisSQLParserHOUR, DorisSQLParserHOURS, DorisSQLParserHUB, DorisSQLParserIDENTIFIED, DorisSQLParserIMPERSONATE, DorisSQLParserIMAGE, DorisSQLParserINACTIVE, DorisSQLParserINCREMENTAL, DorisSQLParserINDEXES, DorisSQLParserINSTALL, DorisSQLParserINTEGRATION, DorisSQLParserINTEGRATIONS, DorisSQLParserINTERMEDIATE, DorisSQLParserINTERVAL, DorisSQLParserOVERWRITE, DorisSQLParserISOLATION, DorisSQLParserJOB, DorisSQLParserLABEL, DorisSQLParserLAST, DorisSQLParserLESS, DorisSQLParserLEVEL, DorisSQLParserLIST, DorisSQLParserLOCAL, DorisSQLParserLOCATION, DorisSQLParserLOCATIONS, DorisSQLParserLOGS, DorisSQLParserLOGICAL, DorisSQLParserMANUAL, DorisSQLParserMAP, DorisSQLParserMAPPING, DorisSQLParserMAPPINGS, DorisSQLParserMASKING, DorisSQLParserMATCH, DorisSQLParserMATERIALIZED, DorisSQLParserMAX, DorisSQLParserMERGE, DorisSQLParserMIN, DorisSQLParserMINUTE, DorisSQLParserMINUTES, DorisSQLParserMINUS, DorisSQLParserMETA, DorisSQLParserMODE, DorisSQLParserMODIFY, DorisSQLParserMONTH, DorisSQLParserMULTIPLE, DorisSQLParserNAME, DorisSQLParserNAMES, DorisSQLParserNEGATIVE, DorisSQLParserNGRAMBF, DorisSQLParserNO, DorisSQLParserNODE, DorisSQLParserNODES, DorisSQLParserNONE, DorisSQLParserNULLS, DorisSQLParserNUMBER, DorisSQLParserNUMERIC, DorisSQLParserOBSERVER, DorisSQLParserOF, DorisSQLParserOFF, DorisSQLParserOFFSET, DorisSQLParserONLY, DorisSQLParserOPEN, DorisSQLParserOPERATE, DorisSQLParserOPTIMIZER, DorisSQLParserOPTION, DorisSQLParserPARTITIONS, DorisSQLParserPASSWORD, DorisSQLParserPATH, DorisSQLParserPAUSE, DorisSQLParserPENDING, DorisSQLParserPERCENT_RANK, DorisSQLParserPERCENTILE_UNION, DorisSQLParserPLAN, DorisSQLParserPLUGIN, DorisSQLParserPLUGINS, DorisSQLParserPIPE, DorisSQLParserPIPES, DorisSQLParserPIVOT, DorisSQLParserPOLICY, DorisSQLParserPOLICIES, DorisSQLParserPRECEDING, DorisSQLParserPREDICATE, DorisSQLParserPRIORITY, DorisSQLParserPRIVILEGES, DorisSQLParserPROBABILITY, DorisSQLParserPROC, DorisSQLParserPROCESSLIST, DorisSQLParserPROFILE, DorisSQLParserPROFILELIST, DorisSQLParserPROPERTIES, DorisSQLParserPROPERTY, DorisSQLParserPROVIDER, DorisSQLParserPROVIDERS, DorisSQLParserQUALIFY, DorisSQLParserQUARTER, DorisSQLParserQUERY, DorisSQLParserQUERIES, DorisSQLParserQUEUE, DorisSQLParserQUOTA, DorisSQLParserRANDOM, DorisSQLParserRANK, DorisSQLParserREASON, DorisSQLParserRECOVER, DorisSQLParserREFRESH, DorisSQLParserREWRITE, DorisSQLParserREMOVE, DorisSQLParserREPAIR, DorisSQLParserREPEATABLE, DorisSQLParserREPLACE_IF_NOT_NULL, DorisSQLParserREPLICA, DorisSQLParserREPOSITORY, DorisSQLParserREPOSITORIES, DorisSQLParserRESOURCE, DorisSQLParserRESOURCES, DorisSQLParserRESTORE, DorisSQLParserRESUME, DorisSQLParserRETAIN, DorisSQLParserRETENTION, DorisSQLParserRETURNS, DorisSQLParserRETRY, DorisSQLParserREVERT, DorisSQLParserROLE, DorisSQLParserROLES, DorisSQLParserROLLBACK, DorisSQLParserROLLUP, DorisSQLParserROUTINE, DorisSQLParserROW, DorisSQLParserRULE, DorisSQLParserRULES, DorisSQLParserRUNNING, DorisSQLParserSAMPLE, DorisSQLParserSCHEDULE, DorisSQLParserSCHEDULER, DorisSQLParserSECOND, DorisSQLParserSECURITY, DorisSQLParserSEMI, DorisSQLParserSEPARATOR, DorisSQLParserSERIALIZABLE, DorisSQLParserSESSION, DorisSQLParserSETS, DorisSQLParserSIGNED, DorisSQLParserSKIP_HEADER, DorisSQLParserSNAPSHOT, DorisSQLParserSNAPSHOTS, DorisSQLParserSQLBLACKLIST, DorisSQLParserSTART, DorisSQLParserSTATS, DorisSQLParserSTATUS, DorisSQLParserSTOP, DorisSQLParserSTORAGE, DorisSQLParserSTREAM, DorisSQLParserSTRING, DorisSQLParserSUBMIT, DorisSQLParserSUM, DorisSQLParserSUSPEND, DorisSQLParserSYNC, DorisSQLParserSYSTEM_TIME, DorisSQLParserSWAP, DorisSQLParserSTRUCT, DorisSQLParserTABLES, DorisSQLParserTABLET, DorisSQLParserTABLETS, DorisSQLParserTAG, DorisSQLParserTASK, DorisSQLParserTEMPORARY, DorisSQLParserTHAN, DorisSQLParserTIME, DorisSQLParserTIMES, DorisSQLParserTIMESTAMP, DorisSQLParserTIMESTAMPADD, DorisSQLParserTIMESTAMPDIFF, DorisSQLParserTRANSACTION, DorisSQLParserTRANSLATE, DorisSQLParserTRACE, DorisSQLParserTRIGGERS, DorisSQLParserTRIM_SPACE, DorisSQLParserTRUNCATE, DorisSQLParserTYPE, DorisSQLParserTYPES, DorisSQLParserUNBOUNDED, DorisSQLParserUNCOMMITTED, DorisSQLParserUNINSTALL, DorisSQLParserUNSET, DorisSQLParserUSAGE, DorisSQLParserUSER, DorisSQLParserUSERS, DorisSQLParserVALUE, DorisSQLParserVARBINARY, DorisSQLParserVARIABLES, DorisSQLParserVECTOR, DorisSQLParserVERBOSE, DorisSQLParserVERSION, DorisSQLParserVIEW, DorisSQLParserVIEWS, DorisSQLParserVOLUME, DorisSQLParserVOLUMES, DorisSQLParserWAREHOUSE, DorisSQLParserWAREHOUSES, DorisSQLParserWARNINGS, DorisSQLParserWEEK, DorisSQLParserWHITELIST, DorisSQLParserWORK, DorisSQLParserWRITE, DorisSQLParserYEAR, DorisSQLParserLOCK, DorisSQLParserUNLOCK, DorisSQLParserLOW_PRIORITY, DorisSQLParserDISK, DorisSQLParserBEFORE, DorisSQLParserFIELD, DorisSQLParserPERSISTENT, DorisSQLParserARRAY_ELEMENT, DorisSQLParserSINGLE_QUOTED_TEXT, DorisSQLParserDOUBLE_QUOTED_TEXT, DorisSQLParserLETTER_IDENTIFIER, DorisSQLParserDIGIT_IDENTIFIER, DorisSQLParserBACKQUOTED_IDENTIFIER, DorisSQLParserDOTDOTDOT:
			{
				p.SetState(5566)
				p.IdentifierOrString()
			}

		case DorisSQLParserDEFAULT:
			{
				p.SetState(5567)
				p.Match(DorisSQLParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		localctx = NewSetNamesContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5570)
			p.Match(DorisSQLParserNAMES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5573)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserACCESS, DorisSQLParserACTIVE, DorisSQLParserADMIN, DorisSQLParserADVISOR, DorisSQLParserAFTER, DorisSQLParserAGGREGATE, DorisSQLParserANTI, DorisSQLParserAPPLY, DorisSQLParserARRAY_AGG, DorisSQLParserARRAY_AGG_DISTINCT, DorisSQLParserASYNC, DorisSQLParserAUTHORS, DorisSQLParserAUTHENTICATION, DorisSQLParserAUTOMATED, DorisSQLParserAUTO_INCREMENT, DorisSQLParserAVG, DorisSQLParserBACKEND, DorisSQLParserBACKENDS, DorisSQLParserBACKUP, DorisSQLParserBASE, DorisSQLParserBASELINE, DorisSQLParserBEGIN, DorisSQLParserBINARY, DorisSQLParserBITMAP_UNION, DorisSQLParserBLACKHOLE, DorisSQLParserBLACKLIST, DorisSQLParserBODY, DorisSQLParserBOOLEAN, DorisSQLParserBRANCH, DorisSQLParserBROKER, DorisSQLParserBUCKETS, DorisSQLParserBUILTIN, DorisSQLParserCACHE, DorisSQLParserCANCEL, DorisSQLParserCAST, DorisSQLParserCATALOG, DorisSQLParserCATALOGS, DorisSQLParserCEIL, DorisSQLParserCHAIN, DorisSQLParserCHARSET, DorisSQLParserCLEAN, DorisSQLParserCLEAR, DorisSQLParserCLUSTER, DorisSQLParserCLUSTERS, DorisSQLParserCNGROUP, DorisSQLParserCNGROUPS, DorisSQLParserCOLLATION, DorisSQLParserCOLUMNS, DorisSQLParserCOMMENT, DorisSQLParserCOMMIT, DorisSQLParserCOMMITTED, DorisSQLParserCOMPACT, DorisSQLParserCOMPUTE, DorisSQLParserCONFIG, DorisSQLParserCONNECTION, DorisSQLParserCONSISTENT, DorisSQLParserCOSTS, DorisSQLParserCOUNT, DorisSQLParserCUME_DIST, DorisSQLParserCUMULATIVE, DorisSQLParserCURRENT, DorisSQLParserDATA, DorisSQLParserDATACACHE, DorisSQLParserDATE, DorisSQLParserDATETIME, DorisSQLParserDAY, DorisSQLParserDAYS, DorisSQLParserDEALLOCATE, DorisSQLParserDECOMMISSION, DorisSQLParserDIALECT, DorisSQLParserDICTIONARY, DorisSQLParserDICTIONARY_GET, DorisSQLParserDISABLE, DorisSQLParserDISTRIBUTED, DorisSQLParserDISTRIBUTION, DorisSQLParserDUPLICATE, DorisSQLParserDYNAMIC, DorisSQLParserENABLE, DorisSQLParserENCLOSE, DorisSQLParserEND, DorisSQLParserENGINE, DorisSQLParserENGINES, DorisSQLParserERRORS, DorisSQLParserESCAPE, DorisSQLParserEVENTS, DorisSQLParserEXCEPT, DorisSQLParserEXCLUDE, DorisSQLParserEXECUTE, DorisSQLParserEXPORT, DorisSQLParserEXTERNAL, DorisSQLParserEXTRACT, DorisSQLParserEVERY, DorisSQLParserFAILPOINT, DorisSQLParserFAILPOINTS, DorisSQLParserFIELDS, DorisSQLParserFILE, DorisSQLParserFILTER, DorisSQLParserFIRST, DorisSQLParserFLOOR, DorisSQLParserFN, DorisSQLParserFOLLOWING, DorisSQLParserFOLLOWER, DorisSQLParserFORMAT, DorisSQLParserFREE, DorisSQLParserFRONTEND, DorisSQLParserFRONTENDS, DorisSQLParserFUNCTIONS, DorisSQLParserGLOBAL, DorisSQLParserGRANTS, DorisSQLParserGROUP_CONCAT, DorisSQLParserHASH, DorisSQLParserHELP, DorisSQLParserHISTOGRAM, DorisSQLParserHLL_UNION, DorisSQLParserHOST, DorisSQLParserHOUR, DorisSQLParserHOURS, DorisSQLParserHUB, DorisSQLParserIDENTIFIED, DorisSQLParserIMPERSONATE, DorisSQLParserIMAGE, DorisSQLParserINACTIVE, DorisSQLParserINCREMENTAL, DorisSQLParserINDEXES, DorisSQLParserINSTALL, DorisSQLParserINTEGRATION, DorisSQLParserINTEGRATIONS, DorisSQLParserINTERMEDIATE, DorisSQLParserINTERVAL, DorisSQLParserOVERWRITE, DorisSQLParserISOLATION, DorisSQLParserJOB, DorisSQLParserLABEL, DorisSQLParserLAST, DorisSQLParserLESS, DorisSQLParserLEVEL, DorisSQLParserLIST, DorisSQLParserLOCAL, DorisSQLParserLOCATION, DorisSQLParserLOCATIONS, DorisSQLParserLOGS, DorisSQLParserLOGICAL, DorisSQLParserMANUAL, DorisSQLParserMAP, DorisSQLParserMAPPING, DorisSQLParserMAPPINGS, DorisSQLParserMASKING, DorisSQLParserMATCH, DorisSQLParserMATERIALIZED, DorisSQLParserMAX, DorisSQLParserMERGE, DorisSQLParserMIN, DorisSQLParserMINUTE, DorisSQLParserMINUTES, DorisSQLParserMINUS, DorisSQLParserMETA, DorisSQLParserMODE, DorisSQLParserMODIFY, DorisSQLParserMONTH, DorisSQLParserMULTIPLE, DorisSQLParserNAME, DorisSQLParserNAMES, DorisSQLParserNEGATIVE, DorisSQLParserNGRAMBF, DorisSQLParserNO, DorisSQLParserNODE, DorisSQLParserNODES, DorisSQLParserNONE, DorisSQLParserNULLS, DorisSQLParserNUMBER, DorisSQLParserNUMERIC, DorisSQLParserOBSERVER, DorisSQLParserOF, DorisSQLParserOFF, DorisSQLParserOFFSET, DorisSQLParserONLY, DorisSQLParserOPEN, DorisSQLParserOPERATE, DorisSQLParserOPTIMIZER, DorisSQLParserOPTION, DorisSQLParserPARTITIONS, DorisSQLParserPASSWORD, DorisSQLParserPATH, DorisSQLParserPAUSE, DorisSQLParserPENDING, DorisSQLParserPERCENT_RANK, DorisSQLParserPERCENTILE_UNION, DorisSQLParserPLAN, DorisSQLParserPLUGIN, DorisSQLParserPLUGINS, DorisSQLParserPIPE, DorisSQLParserPIPES, DorisSQLParserPIVOT, DorisSQLParserPOLICY, DorisSQLParserPOLICIES, DorisSQLParserPRECEDING, DorisSQLParserPREDICATE, DorisSQLParserPRIORITY, DorisSQLParserPRIVILEGES, DorisSQLParserPROBABILITY, DorisSQLParserPROC, DorisSQLParserPROCESSLIST, DorisSQLParserPROFILE, DorisSQLParserPROFILELIST, DorisSQLParserPROPERTIES, DorisSQLParserPROPERTY, DorisSQLParserPROVIDER, DorisSQLParserPROVIDERS, DorisSQLParserQUALIFY, DorisSQLParserQUARTER, DorisSQLParserQUERY, DorisSQLParserQUERIES, DorisSQLParserQUEUE, DorisSQLParserQUOTA, DorisSQLParserRANDOM, DorisSQLParserRANK, DorisSQLParserREASON, DorisSQLParserRECOVER, DorisSQLParserREFRESH, DorisSQLParserREWRITE, DorisSQLParserREMOVE, DorisSQLParserREPAIR, DorisSQLParserREPEATABLE, DorisSQLParserREPLACE_IF_NOT_NULL, DorisSQLParserREPLICA, DorisSQLParserREPOSITORY, DorisSQLParserREPOSITORIES, DorisSQLParserRESOURCE, DorisSQLParserRESOURCES, DorisSQLParserRESTORE, DorisSQLParserRESUME, DorisSQLParserRETAIN, DorisSQLParserRETENTION, DorisSQLParserRETURNS, DorisSQLParserRETRY, DorisSQLParserREVERT, DorisSQLParserROLE, DorisSQLParserROLES, DorisSQLParserROLLBACK, DorisSQLParserROLLUP, DorisSQLParserROUTINE, DorisSQLParserROW, DorisSQLParserRULE, DorisSQLParserRULES, DorisSQLParserRUNNING, DorisSQLParserSAMPLE, DorisSQLParserSCHEDULE, DorisSQLParserSCHEDULER, DorisSQLParserSECOND, DorisSQLParserSECURITY, DorisSQLParserSEMI, DorisSQLParserSEPARATOR, DorisSQLParserSERIALIZABLE, DorisSQLParserSESSION, DorisSQLParserSETS, DorisSQLParserSIGNED, DorisSQLParserSKIP_HEADER, DorisSQLParserSNAPSHOT, DorisSQLParserSNAPSHOTS, DorisSQLParserSQLBLACKLIST, DorisSQLParserSTART, DorisSQLParserSTATS, DorisSQLParserSTATUS, DorisSQLParserSTOP, DorisSQLParserSTORAGE, DorisSQLParserSTREAM, DorisSQLParserSTRING, DorisSQLParserSUBMIT, DorisSQLParserSUM, DorisSQLParserSUSPEND, DorisSQLParserSYNC, DorisSQLParserSYSTEM_TIME, DorisSQLParserSWAP, DorisSQLParserSTRUCT, DorisSQLParserTABLES, DorisSQLParserTABLET, DorisSQLParserTABLETS, DorisSQLParserTAG, DorisSQLParserTASK, DorisSQLParserTEMPORARY, DorisSQLParserTHAN, DorisSQLParserTIME, DorisSQLParserTIMES, DorisSQLParserTIMESTAMP, DorisSQLParserTIMESTAMPADD, DorisSQLParserTIMESTAMPDIFF, DorisSQLParserTRANSACTION, DorisSQLParserTRANSLATE, DorisSQLParserTRACE, DorisSQLParserTRIGGERS, DorisSQLParserTRIM_SPACE, DorisSQLParserTRUNCATE, DorisSQLParserTYPE, DorisSQLParserTYPES, DorisSQLParserUNBOUNDED, DorisSQLParserUNCOMMITTED, DorisSQLParserUNINSTALL, DorisSQLParserUNSET, DorisSQLParserUSAGE, DorisSQLParserUSER, DorisSQLParserUSERS, DorisSQLParserVALUE, DorisSQLParserVARBINARY, DorisSQLParserVARIABLES, DorisSQLParserVECTOR, DorisSQLParserVERBOSE, DorisSQLParserVERSION, DorisSQLParserVIEW, DorisSQLParserVIEWS, DorisSQLParserVOLUME, DorisSQLParserVOLUMES, DorisSQLParserWAREHOUSE, DorisSQLParserWAREHOUSES, DorisSQLParserWARNINGS, DorisSQLParserWEEK, DorisSQLParserWHITELIST, DorisSQLParserWORK, DorisSQLParserWRITE, DorisSQLParserYEAR, DorisSQLParserLOCK, DorisSQLParserUNLOCK, DorisSQLParserLOW_PRIORITY, DorisSQLParserDISK, DorisSQLParserBEFORE, DorisSQLParserFIELD, DorisSQLParserPERSISTENT, DorisSQLParserARRAY_ELEMENT, DorisSQLParserSINGLE_QUOTED_TEXT, DorisSQLParserDOUBLE_QUOTED_TEXT, DorisSQLParserLETTER_IDENTIFIER, DorisSQLParserDIGIT_IDENTIFIER, DorisSQLParserBACKQUOTED_IDENTIFIER, DorisSQLParserDOTDOTDOT:
			{
				p.SetState(5571)

				var _x = p.IdentifierOrString()

				localctx.(*SetNamesContext).charset = _x
			}

		case DorisSQLParserDEFAULT:
			{
				p.SetState(5572)
				p.Match(DorisSQLParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(5580)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserCOLLATE {
			{
				p.SetState(5575)
				p.Match(DorisSQLParserCOLLATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5578)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisSQLParserACCESS, DorisSQLParserACTIVE, DorisSQLParserADMIN, DorisSQLParserADVISOR, DorisSQLParserAFTER, DorisSQLParserAGGREGATE, DorisSQLParserANTI, DorisSQLParserAPPLY, DorisSQLParserARRAY_AGG, DorisSQLParserARRAY_AGG_DISTINCT, DorisSQLParserASYNC, DorisSQLParserAUTHORS, DorisSQLParserAUTHENTICATION, DorisSQLParserAUTOMATED, DorisSQLParserAUTO_INCREMENT, DorisSQLParserAVG, DorisSQLParserBACKEND, DorisSQLParserBACKENDS, DorisSQLParserBACKUP, DorisSQLParserBASE, DorisSQLParserBASELINE, DorisSQLParserBEGIN, DorisSQLParserBINARY, DorisSQLParserBITMAP_UNION, DorisSQLParserBLACKHOLE, DorisSQLParserBLACKLIST, DorisSQLParserBODY, DorisSQLParserBOOLEAN, DorisSQLParserBRANCH, DorisSQLParserBROKER, DorisSQLParserBUCKETS, DorisSQLParserBUILTIN, DorisSQLParserCACHE, DorisSQLParserCANCEL, DorisSQLParserCAST, DorisSQLParserCATALOG, DorisSQLParserCATALOGS, DorisSQLParserCEIL, DorisSQLParserCHAIN, DorisSQLParserCHARSET, DorisSQLParserCLEAN, DorisSQLParserCLEAR, DorisSQLParserCLUSTER, DorisSQLParserCLUSTERS, DorisSQLParserCNGROUP, DorisSQLParserCNGROUPS, DorisSQLParserCOLLATION, DorisSQLParserCOLUMNS, DorisSQLParserCOMMENT, DorisSQLParserCOMMIT, DorisSQLParserCOMMITTED, DorisSQLParserCOMPACT, DorisSQLParserCOMPUTE, DorisSQLParserCONFIG, DorisSQLParserCONNECTION, DorisSQLParserCONSISTENT, DorisSQLParserCOSTS, DorisSQLParserCOUNT, DorisSQLParserCUME_DIST, DorisSQLParserCUMULATIVE, DorisSQLParserCURRENT, DorisSQLParserDATA, DorisSQLParserDATACACHE, DorisSQLParserDATE, DorisSQLParserDATETIME, DorisSQLParserDAY, DorisSQLParserDAYS, DorisSQLParserDEALLOCATE, DorisSQLParserDECOMMISSION, DorisSQLParserDIALECT, DorisSQLParserDICTIONARY, DorisSQLParserDICTIONARY_GET, DorisSQLParserDISABLE, DorisSQLParserDISTRIBUTED, DorisSQLParserDISTRIBUTION, DorisSQLParserDUPLICATE, DorisSQLParserDYNAMIC, DorisSQLParserENABLE, DorisSQLParserENCLOSE, DorisSQLParserEND, DorisSQLParserENGINE, DorisSQLParserENGINES, DorisSQLParserERRORS, DorisSQLParserESCAPE, DorisSQLParserEVENTS, DorisSQLParserEXCEPT, DorisSQLParserEXCLUDE, DorisSQLParserEXECUTE, DorisSQLParserEXPORT, DorisSQLParserEXTERNAL, DorisSQLParserEXTRACT, DorisSQLParserEVERY, DorisSQLParserFAILPOINT, DorisSQLParserFAILPOINTS, DorisSQLParserFIELDS, DorisSQLParserFILE, DorisSQLParserFILTER, DorisSQLParserFIRST, DorisSQLParserFLOOR, DorisSQLParserFN, DorisSQLParserFOLLOWING, DorisSQLParserFOLLOWER, DorisSQLParserFORMAT, DorisSQLParserFREE, DorisSQLParserFRONTEND, DorisSQLParserFRONTENDS, DorisSQLParserFUNCTIONS, DorisSQLParserGLOBAL, DorisSQLParserGRANTS, DorisSQLParserGROUP_CONCAT, DorisSQLParserHASH, DorisSQLParserHELP, DorisSQLParserHISTOGRAM, DorisSQLParserHLL_UNION, DorisSQLParserHOST, DorisSQLParserHOUR, DorisSQLParserHOURS, DorisSQLParserHUB, DorisSQLParserIDENTIFIED, DorisSQLParserIMPERSONATE, DorisSQLParserIMAGE, DorisSQLParserINACTIVE, DorisSQLParserINCREMENTAL, DorisSQLParserINDEXES, DorisSQLParserINSTALL, DorisSQLParserINTEGRATION, DorisSQLParserINTEGRATIONS, DorisSQLParserINTERMEDIATE, DorisSQLParserINTERVAL, DorisSQLParserOVERWRITE, DorisSQLParserISOLATION, DorisSQLParserJOB, DorisSQLParserLABEL, DorisSQLParserLAST, DorisSQLParserLESS, DorisSQLParserLEVEL, DorisSQLParserLIST, DorisSQLParserLOCAL, DorisSQLParserLOCATION, DorisSQLParserLOCATIONS, DorisSQLParserLOGS, DorisSQLParserLOGICAL, DorisSQLParserMANUAL, DorisSQLParserMAP, DorisSQLParserMAPPING, DorisSQLParserMAPPINGS, DorisSQLParserMASKING, DorisSQLParserMATCH, DorisSQLParserMATERIALIZED, DorisSQLParserMAX, DorisSQLParserMERGE, DorisSQLParserMIN, DorisSQLParserMINUTE, DorisSQLParserMINUTES, DorisSQLParserMINUS, DorisSQLParserMETA, DorisSQLParserMODE, DorisSQLParserMODIFY, DorisSQLParserMONTH, DorisSQLParserMULTIPLE, DorisSQLParserNAME, DorisSQLParserNAMES, DorisSQLParserNEGATIVE, DorisSQLParserNGRAMBF, DorisSQLParserNO, DorisSQLParserNODE, DorisSQLParserNODES, DorisSQLParserNONE, DorisSQLParserNULLS, DorisSQLParserNUMBER, DorisSQLParserNUMERIC, DorisSQLParserOBSERVER, DorisSQLParserOF, DorisSQLParserOFF, DorisSQLParserOFFSET, DorisSQLParserONLY, DorisSQLParserOPEN, DorisSQLParserOPERATE, DorisSQLParserOPTIMIZER, DorisSQLParserOPTION, DorisSQLParserPARTITIONS, DorisSQLParserPASSWORD, DorisSQLParserPATH, DorisSQLParserPAUSE, DorisSQLParserPENDING, DorisSQLParserPERCENT_RANK, DorisSQLParserPERCENTILE_UNION, DorisSQLParserPLAN, DorisSQLParserPLUGIN, DorisSQLParserPLUGINS, DorisSQLParserPIPE, DorisSQLParserPIPES, DorisSQLParserPIVOT, DorisSQLParserPOLICY, DorisSQLParserPOLICIES, DorisSQLParserPRECEDING, DorisSQLParserPREDICATE, DorisSQLParserPRIORITY, DorisSQLParserPRIVILEGES, DorisSQLParserPROBABILITY, DorisSQLParserPROC, DorisSQLParserPROCESSLIST, DorisSQLParserPROFILE, DorisSQLParserPROFILELIST, DorisSQLParserPROPERTIES, DorisSQLParserPROPERTY, DorisSQLParserPROVIDER, DorisSQLParserPROVIDERS, DorisSQLParserQUALIFY, DorisSQLParserQUARTER, DorisSQLParserQUERY, DorisSQLParserQUERIES, DorisSQLParserQUEUE, DorisSQLParserQUOTA, DorisSQLParserRANDOM, DorisSQLParserRANK, DorisSQLParserREASON, DorisSQLParserRECOVER, DorisSQLParserREFRESH, DorisSQLParserREWRITE, DorisSQLParserREMOVE, DorisSQLParserREPAIR, DorisSQLParserREPEATABLE, DorisSQLParserREPLACE_IF_NOT_NULL, DorisSQLParserREPLICA, DorisSQLParserREPOSITORY, DorisSQLParserREPOSITORIES, DorisSQLParserRESOURCE, DorisSQLParserRESOURCES, DorisSQLParserRESTORE, DorisSQLParserRESUME, DorisSQLParserRETAIN, DorisSQLParserRETENTION, DorisSQLParserRETURNS, DorisSQLParserRETRY, DorisSQLParserREVERT, DorisSQLParserROLE, DorisSQLParserROLES, DorisSQLParserROLLBACK, DorisSQLParserROLLUP, DorisSQLParserROUTINE, DorisSQLParserROW, DorisSQLParserRULE, DorisSQLParserRULES, DorisSQLParserRUNNING, DorisSQLParserSAMPLE, DorisSQLParserSCHEDULE, DorisSQLParserSCHEDULER, DorisSQLParserSECOND, DorisSQLParserSECURITY, DorisSQLParserSEMI, DorisSQLParserSEPARATOR, DorisSQLParserSERIALIZABLE, DorisSQLParserSESSION, DorisSQLParserSETS, DorisSQLParserSIGNED, DorisSQLParserSKIP_HEADER, DorisSQLParserSNAPSHOT, DorisSQLParserSNAPSHOTS, DorisSQLParserSQLBLACKLIST, DorisSQLParserSTART, DorisSQLParserSTATS, DorisSQLParserSTATUS, DorisSQLParserSTOP, DorisSQLParserSTORAGE, DorisSQLParserSTREAM, DorisSQLParserSTRING, DorisSQLParserSUBMIT, DorisSQLParserSUM, DorisSQLParserSUSPEND, DorisSQLParserSYNC, DorisSQLParserSYSTEM_TIME, DorisSQLParserSWAP, DorisSQLParserSTRUCT, DorisSQLParserTABLES, DorisSQLParserTABLET, DorisSQLParserTABLETS, DorisSQLParserTAG, DorisSQLParserTASK, DorisSQLParserTEMPORARY, DorisSQLParserTHAN, DorisSQLParserTIME, DorisSQLParserTIMES, DorisSQLParserTIMESTAMP, DorisSQLParserTIMESTAMPADD, DorisSQLParserTIMESTAMPDIFF, DorisSQLParserTRANSACTION, DorisSQLParserTRANSLATE, DorisSQLParserTRACE, DorisSQLParserTRIGGERS, DorisSQLParserTRIM_SPACE, DorisSQLParserTRUNCATE, DorisSQLParserTYPE, DorisSQLParserTYPES, DorisSQLParserUNBOUNDED, DorisSQLParserUNCOMMITTED, DorisSQLParserUNINSTALL, DorisSQLParserUNSET, DorisSQLParserUSAGE, DorisSQLParserUSER, DorisSQLParserUSERS, DorisSQLParserVALUE, DorisSQLParserVARBINARY, DorisSQLParserVARIABLES, DorisSQLParserVECTOR, DorisSQLParserVERBOSE, DorisSQLParserVERSION, DorisSQLParserVIEW, DorisSQLParserVIEWS, DorisSQLParserVOLUME, DorisSQLParserVOLUMES, DorisSQLParserWAREHOUSE, DorisSQLParserWAREHOUSES, DorisSQLParserWARNINGS, DorisSQLParserWEEK, DorisSQLParserWHITELIST, DorisSQLParserWORK, DorisSQLParserWRITE, DorisSQLParserYEAR, DorisSQLParserLOCK, DorisSQLParserUNLOCK, DorisSQLParserLOW_PRIORITY, DorisSQLParserDISK, DorisSQLParserBEFORE, DorisSQLParserFIELD, DorisSQLParserPERSISTENT, DorisSQLParserARRAY_ELEMENT, DorisSQLParserSINGLE_QUOTED_TEXT, DorisSQLParserDOUBLE_QUOTED_TEXT, DorisSQLParserLETTER_IDENTIFIER, DorisSQLParserDIGIT_IDENTIFIER, DorisSQLParserBACKQUOTED_IDENTIFIER, DorisSQLParserDOTDOTDOT:
				{
					p.SetState(5576)

					var _x = p.IdentifierOrString()

					localctx.(*SetNamesContext).collate = _x
				}

			case DorisSQLParserDEFAULT:
				{
					p.SetState(5577)
					p.Match(DorisSQLParserDEFAULT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}

	case 3:
		localctx = NewSetPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5582)
			p.Match(DorisSQLParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5583)
			p.Match(DorisSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5590)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserSINGLE_QUOTED_TEXT, DorisSQLParserDOUBLE_QUOTED_TEXT:
			{
				p.SetState(5584)
				p.String_()
			}

		case DorisSQLParserPASSWORD:
			{
				p.SetState(5585)
				p.Match(DorisSQLParserPASSWORD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5586)
				p.Match(DorisSQLParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5587)
				p.String_()
			}
			{
				p.SetState(5588)
				p.Match(DorisSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 4:
		localctx = NewSetPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5592)
			p.Match(DorisSQLParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5593)
			p.Match(DorisSQLParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5594)
			p.User()
		}
		{
			p.SetState(5595)
			p.Match(DorisSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5602)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserSINGLE_QUOTED_TEXT, DorisSQLParserDOUBLE_QUOTED_TEXT:
			{
				p.SetState(5596)
				p.String_()
			}

		case DorisSQLParserPASSWORD:
			{
				p.SetState(5597)
				p.Match(DorisSQLParserPASSWORD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5598)
				p.Match(DorisSQLParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5599)
				p.String_()
			}
			{
				p.SetState(5600)
				p.Match(DorisSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 5:
		localctx = NewSetUserVarContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5604)
			p.UserVariable()
		}
		{
			p.SetState(5605)
			p.Match(DorisSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5606)
			p.expression(0)
		}

	case 6:
		localctx = NewSetSystemVarContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(5609)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 608, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5608)
				p.VarType()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5611)
			p.Identifier()
		}
		{
			p.SetState(5612)
			p.Match(DorisSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5613)
			p.SetExprOrDefault()
		}

	case 7:
		localctx = NewSetSystemVarContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5615)
			p.SystemVariable()
		}
		{
			p.SetState(5616)
			p.Match(DorisSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5617)
			p.SetExprOrDefault()
		}

	case 8:
		localctx = NewSetTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		p.SetState(5620)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserGLOBAL || _la == DorisSQLParserLOCAL || _la == DorisSQLParserSESSION || _la == DorisSQLParserVERBOSE {
			{
				p.SetState(5619)
				p.VarType()
			}

		}
		{
			p.SetState(5622)
			p.Match(DorisSQLParserTRANSACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5623)
			p.Transaction_characteristics()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransaction_characteristicsContext is an interface to support dynamic dispatch.
type ITransaction_characteristicsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Transaction_access_mode() ITransaction_access_modeContext
	Isolation_level() IIsolation_levelContext

	// IsTransaction_characteristicsContext differentiates from other interfaces.
	IsTransaction_characteristicsContext()
}

type Transaction_characteristicsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransaction_characteristicsContext() *Transaction_characteristicsContext {
	var p = new(Transaction_characteristicsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_transaction_characteristics
	return p
}

func InitEmptyTransaction_characteristicsContext(p *Transaction_characteristicsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_transaction_characteristics
}

func (*Transaction_characteristicsContext) IsTransaction_characteristicsContext() {}

func NewTransaction_characteristicsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transaction_characteristicsContext {
	var p = new(Transaction_characteristicsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_transaction_characteristics

	return p
}

func (s *Transaction_characteristicsContext) GetParser() antlr.Parser { return s.parser }

func (s *Transaction_characteristicsContext) Transaction_access_mode() ITransaction_access_modeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransaction_access_modeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransaction_access_modeContext)
}

func (s *Transaction_characteristicsContext) Isolation_level() IIsolation_levelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsolation_levelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsolation_levelContext)
}

func (s *Transaction_characteristicsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transaction_characteristicsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transaction_characteristicsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTransaction_characteristics(s)
	}
}

func (s *Transaction_characteristicsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTransaction_characteristics(s)
	}
}

func (s *Transaction_characteristicsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTransaction_characteristics(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Transaction_characteristics() (localctx ITransaction_characteristicsContext) {
	localctx = NewTransaction_characteristicsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 682, DorisSQLParserRULE_transaction_characteristics)
	p.SetState(5636)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 611, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5626)
			p.Transaction_access_mode()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5627)
			p.Isolation_level()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5628)
			p.Transaction_access_mode()
		}
		{
			p.SetState(5629)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5630)
			p.Isolation_level()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5632)
			p.Isolation_level()
		}
		{
			p.SetState(5633)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5634)
			p.Transaction_access_mode()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransaction_access_modeContext is an interface to support dynamic dispatch.
type ITransaction_access_modeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	WRITE() antlr.TerminalNode

	// IsTransaction_access_modeContext differentiates from other interfaces.
	IsTransaction_access_modeContext()
}

type Transaction_access_modeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransaction_access_modeContext() *Transaction_access_modeContext {
	var p = new(Transaction_access_modeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_transaction_access_mode
	return p
}

func InitEmptyTransaction_access_modeContext(p *Transaction_access_modeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_transaction_access_mode
}

func (*Transaction_access_modeContext) IsTransaction_access_modeContext() {}

func NewTransaction_access_modeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transaction_access_modeContext {
	var p = new(Transaction_access_modeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_transaction_access_mode

	return p
}

func (s *Transaction_access_modeContext) GetParser() antlr.Parser { return s.parser }

func (s *Transaction_access_modeContext) READ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREAD, 0)
}

func (s *Transaction_access_modeContext) ONLY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserONLY, 0)
}

func (s *Transaction_access_modeContext) WRITE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWRITE, 0)
}

func (s *Transaction_access_modeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transaction_access_modeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transaction_access_modeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTransaction_access_mode(s)
	}
}

func (s *Transaction_access_modeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTransaction_access_mode(s)
	}
}

func (s *Transaction_access_modeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTransaction_access_mode(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Transaction_access_mode() (localctx ITransaction_access_modeContext) {
	localctx = NewTransaction_access_modeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 684, DorisSQLParserRULE_transaction_access_mode)
	p.SetState(5642)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 612, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5638)
			p.Match(DorisSQLParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5639)
			p.Match(DorisSQLParserONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5640)
			p.Match(DorisSQLParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5641)
			p.Match(DorisSQLParserWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIsolation_levelContext is an interface to support dynamic dispatch.
type IIsolation_levelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ISOLATION() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	Isolation_types() IIsolation_typesContext

	// IsIsolation_levelContext differentiates from other interfaces.
	IsIsolation_levelContext()
}

type Isolation_levelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsolation_levelContext() *Isolation_levelContext {
	var p = new(Isolation_levelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_isolation_level
	return p
}

func InitEmptyIsolation_levelContext(p *Isolation_levelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_isolation_level
}

func (*Isolation_levelContext) IsIsolation_levelContext() {}

func NewIsolation_levelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Isolation_levelContext {
	var p = new(Isolation_levelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_isolation_level

	return p
}

func (s *Isolation_levelContext) GetParser() antlr.Parser { return s.parser }

func (s *Isolation_levelContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserISOLATION, 0)
}

func (s *Isolation_levelContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLEVEL, 0)
}

func (s *Isolation_levelContext) Isolation_types() IIsolation_typesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsolation_typesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsolation_typesContext)
}

func (s *Isolation_levelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Isolation_levelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Isolation_levelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterIsolation_level(s)
	}
}

func (s *Isolation_levelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitIsolation_level(s)
	}
}

func (s *Isolation_levelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitIsolation_level(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Isolation_level() (localctx IIsolation_levelContext) {
	localctx = NewIsolation_levelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 686, DorisSQLParserRULE_isolation_level)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5644)
		p.Match(DorisSQLParserISOLATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5645)
		p.Match(DorisSQLParserLEVEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5646)
		p.Isolation_types()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIsolation_typesContext is an interface to support dynamic dispatch.
type IIsolation_typesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	REPEATABLE() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode

	// IsIsolation_typesContext differentiates from other interfaces.
	IsIsolation_typesContext()
}

type Isolation_typesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsolation_typesContext() *Isolation_typesContext {
	var p = new(Isolation_typesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_isolation_types
	return p
}

func InitEmptyIsolation_typesContext(p *Isolation_typesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_isolation_types
}

func (*Isolation_typesContext) IsIsolation_typesContext() {}

func NewIsolation_typesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Isolation_typesContext {
	var p = new(Isolation_typesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_isolation_types

	return p
}

func (s *Isolation_typesContext) GetParser() antlr.Parser { return s.parser }

func (s *Isolation_typesContext) READ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREAD, 0)
}

func (s *Isolation_typesContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUNCOMMITTED, 0)
}

func (s *Isolation_typesContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOMMITTED, 0)
}

func (s *Isolation_typesContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPEATABLE, 0)
}

func (s *Isolation_typesContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSERIALIZABLE, 0)
}

func (s *Isolation_typesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Isolation_typesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Isolation_typesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterIsolation_types(s)
	}
}

func (s *Isolation_typesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitIsolation_types(s)
	}
}

func (s *Isolation_typesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitIsolation_types(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Isolation_types() (localctx IIsolation_typesContext) {
	localctx = NewIsolation_typesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 688, DorisSQLParserRULE_isolation_types)
	p.SetState(5655)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 613, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5648)
			p.Match(DorisSQLParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5649)
			p.Match(DorisSQLParserUNCOMMITTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5650)
			p.Match(DorisSQLParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5651)
			p.Match(DorisSQLParserCOMMITTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5652)
			p.Match(DorisSQLParserREPEATABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5653)
			p.Match(DorisSQLParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5654)
			p.Match(DorisSQLParserSERIALIZABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetExprOrDefaultContext is an interface to support dynamic dispatch.
type ISetExprOrDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	ON() antlr.TerminalNode
	ALL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsSetExprOrDefaultContext differentiates from other interfaces.
	IsSetExprOrDefaultContext()
}

type SetExprOrDefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetExprOrDefaultContext() *SetExprOrDefaultContext {
	var p = new(SetExprOrDefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_setExprOrDefault
	return p
}

func InitEmptySetExprOrDefaultContext(p *SetExprOrDefaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_setExprOrDefault
}

func (*SetExprOrDefaultContext) IsSetExprOrDefaultContext() {}

func NewSetExprOrDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetExprOrDefaultContext {
	var p = new(SetExprOrDefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_setExprOrDefault

	return p
}

func (s *SetExprOrDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *SetExprOrDefaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDEFAULT, 0)
}

func (s *SetExprOrDefaultContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *SetExprOrDefaultContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, 0)
}

func (s *SetExprOrDefaultContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetExprOrDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetExprOrDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetExprOrDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSetExprOrDefault(s)
	}
}

func (s *SetExprOrDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSetExprOrDefault(s)
	}
}

func (s *SetExprOrDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSetExprOrDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SetExprOrDefault() (localctx ISetExprOrDefaultContext) {
	localctx = NewSetExprOrDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 690, DorisSQLParserRULE_setExprOrDefault)
	p.SetState(5661)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserDEFAULT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5657)
			p.Match(DorisSQLParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5658)
			p.Match(DorisSQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserALL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5659)
			p.Match(DorisSQLParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserT__1, DorisSQLParserT__5, DorisSQLParserT__8, DorisSQLParserACCESS, DorisSQLParserACTIVE, DorisSQLParserADMIN, DorisSQLParserADVISOR, DorisSQLParserAFTER, DorisSQLParserAGGREGATE, DorisSQLParserANTI, DorisSQLParserAPPLY, DorisSQLParserARRAY, DorisSQLParserARRAY_AGG, DorisSQLParserARRAY_AGG_DISTINCT, DorisSQLParserASYNC, DorisSQLParserAUTHORS, DorisSQLParserAUTHENTICATION, DorisSQLParserAUTOMATED, DorisSQLParserAUTO_INCREMENT, DorisSQLParserAVG, DorisSQLParserBACKEND, DorisSQLParserBACKENDS, DorisSQLParserBACKUP, DorisSQLParserBASE, DorisSQLParserBASELINE, DorisSQLParserBEGIN, DorisSQLParserBINARY, DorisSQLParserBITMAP_UNION, DorisSQLParserBLACKHOLE, DorisSQLParserBLACKLIST, DorisSQLParserBODY, DorisSQLParserBOOLEAN, DorisSQLParserBRANCH, DorisSQLParserBROKER, DorisSQLParserBUCKETS, DorisSQLParserBUILTIN, DorisSQLParserCACHE, DorisSQLParserCANCEL, DorisSQLParserCASE, DorisSQLParserCAST, DorisSQLParserCATALOG, DorisSQLParserCATALOGS, DorisSQLParserCEIL, DorisSQLParserCHAIN, DorisSQLParserCHAR, DorisSQLParserCHARSET, DorisSQLParserCLEAN, DorisSQLParserCLEAR, DorisSQLParserCLUSTER, DorisSQLParserCLUSTERS, DorisSQLParserCNGROUP, DorisSQLParserCNGROUPS, DorisSQLParserCOLLATION, DorisSQLParserCOLUMNS, DorisSQLParserCOMMENT, DorisSQLParserCOMMIT, DorisSQLParserCOMMITTED, DorisSQLParserCOMPACT, DorisSQLParserCOMPUTE, DorisSQLParserCONFIG, DorisSQLParserCONNECTION, DorisSQLParserCONSISTENT, DorisSQLParserCONVERT, DorisSQLParserCOSTS, DorisSQLParserCOUNT, DorisSQLParserCUME_DIST, DorisSQLParserCUMULATIVE, DorisSQLParserCURRENT, DorisSQLParserCURRENT_DATE, DorisSQLParserCURRENT_GROUP, DorisSQLParserCURRENT_ROLE, DorisSQLParserCURRENT_TIME, DorisSQLParserCURRENT_TIMESTAMP, DorisSQLParserCURRENT_USER, DorisSQLParserDATA, DorisSQLParserDATACACHE, DorisSQLParserDATABASE, DorisSQLParserDATE, DorisSQLParserDATETIME, DorisSQLParserDAY, DorisSQLParserDAYS, DorisSQLParserDEALLOCATE, DorisSQLParserDECOMMISSION, DorisSQLParserDENSE_RANK, DorisSQLParserDIALECT, DorisSQLParserDICTIONARY, DorisSQLParserDICTIONARY_GET, DorisSQLParserNTILE, DorisSQLParserDISABLE, DorisSQLParserDISTRIBUTED, DorisSQLParserDISTRIBUTION, DorisSQLParserDUPLICATE, DorisSQLParserDYNAMIC, DorisSQLParserENABLE, DorisSQLParserENCLOSE, DorisSQLParserEND, DorisSQLParserENGINE, DorisSQLParserENGINES, DorisSQLParserERRORS, DorisSQLParserESCAPE, DorisSQLParserEVENTS, DorisSQLParserEXCEPT, DorisSQLParserEXCLUDE, DorisSQLParserEXECUTE, DorisSQLParserEXISTS, DorisSQLParserEXPORT, DorisSQLParserEXTERNAL, DorisSQLParserEXTRACT, DorisSQLParserEVERY, DorisSQLParserFAILPOINT, DorisSQLParserFAILPOINTS, DorisSQLParserFALSE, DorisSQLParserFIELDS, DorisSQLParserFILE, DorisSQLParserFILTER, DorisSQLParserFIRST, DorisSQLParserFIRST_VALUE, DorisSQLParserFLOOR, DorisSQLParserFN, DorisSQLParserFOLLOWING, DorisSQLParserFOLLOWER, DorisSQLParserFORMAT, DorisSQLParserFREE, DorisSQLParserFRONTEND, DorisSQLParserFRONTENDS, DorisSQLParserFUNCTIONS, DorisSQLParserGLOBAL, DorisSQLParserGRANTS, DorisSQLParserGROUPING, DorisSQLParserGROUPING_ID, DorisSQLParserGROUP_CONCAT, DorisSQLParserHASH, DorisSQLParserHELP, DorisSQLParserHISTOGRAM, DorisSQLParserHLL_UNION, DorisSQLParserHOST, DorisSQLParserHOUR, DorisSQLParserHOURS, DorisSQLParserHUB, DorisSQLParserIDENTIFIED, DorisSQLParserIF, DorisSQLParserIMPERSONATE, DorisSQLParserIMAGE, DorisSQLParserINACTIVE, DorisSQLParserINCREMENTAL, DorisSQLParserINDEXES, DorisSQLParserINSTALL, DorisSQLParserINTEGRATION, DorisSQLParserINTEGRATIONS, DorisSQLParserINTERMEDIATE, DorisSQLParserINTERVAL, DorisSQLParserOVERWRITE, DorisSQLParserISOLATION, DorisSQLParserJOB, DorisSQLParserLABEL, DorisSQLParserLAG, DorisSQLParserLAST, DorisSQLParserLAST_VALUE, DorisSQLParserLEAD, DorisSQLParserLEFT, DorisSQLParserLESS, DorisSQLParserLEVEL, DorisSQLParserLIKE, DorisSQLParserLIST, DorisSQLParserLOCAL, DorisSQLParserLOCALTIME, DorisSQLParserLOCALTIMESTAMP, DorisSQLParserLOCATION, DorisSQLParserLOCATIONS, DorisSQLParserLOGS, DorisSQLParserLOGICAL, DorisSQLParserMANUAL, DorisSQLParserMAP, DorisSQLParserMAPPING, DorisSQLParserMAPPINGS, DorisSQLParserMASKING, DorisSQLParserMATCH, DorisSQLParserMATERIALIZED, DorisSQLParserMAX, DorisSQLParserMERGE, DorisSQLParserMIN, DorisSQLParserMINUTE, DorisSQLParserMINUTES, DorisSQLParserMINUS, DorisSQLParserMETA, DorisSQLParserMOD, DorisSQLParserMODE, DorisSQLParserMODIFY, DorisSQLParserMONTH, DorisSQLParserMULTIPLE, DorisSQLParserNAME, DorisSQLParserNAMES, DorisSQLParserNEGATIVE, DorisSQLParserNGRAMBF, DorisSQLParserNO, DorisSQLParserNODE, DorisSQLParserNODES, DorisSQLParserNONE, DorisSQLParserNOT, DorisSQLParserNULL, DorisSQLParserNULLS, DorisSQLParserNUMBER, DorisSQLParserNUMERIC, DorisSQLParserOBSERVER, DorisSQLParserOF, DorisSQLParserOFF, DorisSQLParserOFFSET, DorisSQLParserONLY, DorisSQLParserOPEN, DorisSQLParserOPERATE, DorisSQLParserOPTIMIZER, DorisSQLParserOPTION, DorisSQLParserPARAMETER, DorisSQLParserPARTITIONS, DorisSQLParserPASSWORD, DorisSQLParserPATH, DorisSQLParserPAUSE, DorisSQLParserPENDING, DorisSQLParserPERCENT_RANK, DorisSQLParserPERCENTILE_UNION, DorisSQLParserPLAN, DorisSQLParserPLUGIN, DorisSQLParserPLUGINS, DorisSQLParserPIPE, DorisSQLParserPIPES, DorisSQLParserPIVOT, DorisSQLParserPOLICY, DorisSQLParserPOLICIES, DorisSQLParserPRECEDING, DorisSQLParserPREDICATE, DorisSQLParserPRIORITY, DorisSQLParserPRIVILEGES, DorisSQLParserPROBABILITY, DorisSQLParserPROC, DorisSQLParserPROCESSLIST, DorisSQLParserPROFILE, DorisSQLParserPROFILELIST, DorisSQLParserPROPERTIES, DorisSQLParserPROPERTY, DorisSQLParserPROVIDER, DorisSQLParserPROVIDERS, DorisSQLParserQUALIFY, DorisSQLParserQUARTER, DorisSQLParserQUERY, DorisSQLParserQUERIES, DorisSQLParserQUEUE, DorisSQLParserQUOTA, DorisSQLParserRANDOM, DorisSQLParserRANK, DorisSQLParserREASON, DorisSQLParserRECOVER, DorisSQLParserREFRESH, DorisSQLParserREWRITE, DorisSQLParserREGEXP, DorisSQLParserREMOVE, DorisSQLParserREPAIR, DorisSQLParserREPEATABLE, DorisSQLParserREPLACE, DorisSQLParserREPLACE_IF_NOT_NULL, DorisSQLParserREPLICA, DorisSQLParserREPOSITORY, DorisSQLParserREPOSITORIES, DorisSQLParserRESOURCE, DorisSQLParserRESOURCES, DorisSQLParserRESTORE, DorisSQLParserRESUME, DorisSQLParserRETAIN, DorisSQLParserRETENTION, DorisSQLParserRETURNS, DorisSQLParserRETRY, DorisSQLParserREVERT, DorisSQLParserRIGHT, DorisSQLParserRLIKE, DorisSQLParserROLE, DorisSQLParserROLES, DorisSQLParserROLLBACK, DorisSQLParserROLLUP, DorisSQLParserROUTINE, DorisSQLParserROW, DorisSQLParserROW_NUMBER, DorisSQLParserRULE, DorisSQLParserRULES, DorisSQLParserRUNNING, DorisSQLParserSAMPLE, DorisSQLParserSCHEDULE, DorisSQLParserSCHEDULER, DorisSQLParserSCHEMA, DorisSQLParserSECOND, DorisSQLParserSECURITY, DorisSQLParserSEMI, DorisSQLParserSEPARATOR, DorisSQLParserSERIALIZABLE, DorisSQLParserSESSION, DorisSQLParserSETS, DorisSQLParserSIGNED, DorisSQLParserSKIP_HEADER, DorisSQLParserSNAPSHOT, DorisSQLParserSNAPSHOTS, DorisSQLParserSQLBLACKLIST, DorisSQLParserSTART, DorisSQLParserSTATS, DorisSQLParserSTATUS, DorisSQLParserSTOP, DorisSQLParserSTORAGE, DorisSQLParserSTREAM, DorisSQLParserSTRING, DorisSQLParserSUBMIT, DorisSQLParserSUM, DorisSQLParserSUSPEND, DorisSQLParserSYNC, DorisSQLParserSYSTEM_TIME, DorisSQLParserSWAP, DorisSQLParserSTRUCT, DorisSQLParserTABLES, DorisSQLParserTABLET, DorisSQLParserTABLETS, DorisSQLParserTAG, DorisSQLParserTASK, DorisSQLParserTEMPORARY, DorisSQLParserTHAN, DorisSQLParserTIME, DorisSQLParserTIMES, DorisSQLParserTIMESTAMP, DorisSQLParserTIMESTAMPADD, DorisSQLParserTIMESTAMPDIFF, DorisSQLParserTRANSACTION, DorisSQLParserTRANSLATE, DorisSQLParserTRACE, DorisSQLParserTRIGGERS, DorisSQLParserTRIM_SPACE, DorisSQLParserTRUE, DorisSQLParserTRUNCATE, DorisSQLParserTYPE, DorisSQLParserTYPES, DorisSQLParserUNBOUNDED, DorisSQLParserUNCOMMITTED, DorisSQLParserUNINSTALL, DorisSQLParserUNSET, DorisSQLParserUSAGE, DorisSQLParserUSER, DorisSQLParserUSERS, DorisSQLParserVALUE, DorisSQLParserVARBINARY, DorisSQLParserVARIABLES, DorisSQLParserVECTOR, DorisSQLParserVERBOSE, DorisSQLParserVERSION, DorisSQLParserVIEW, DorisSQLParserVIEWS, DorisSQLParserVOLUME, DorisSQLParserVOLUMES, DorisSQLParserWAREHOUSE, DorisSQLParserWAREHOUSES, DorisSQLParserWARNINGS, DorisSQLParserWEEK, DorisSQLParserWHITELIST, DorisSQLParserWORK, DorisSQLParserWRITE, DorisSQLParserYEAR, DorisSQLParserLOCK, DorisSQLParserUNLOCK, DorisSQLParserLOW_PRIORITY, DorisSQLParserDISK, DorisSQLParserBEFORE, DorisSQLParserFIELD, DorisSQLParserPERSISTENT, DorisSQLParserARRAY_ELEMENT, DorisSQLParserPLUS_SYMBOL, DorisSQLParserMINUS_SYMBOL, DorisSQLParserLOGICAL_NOT, DorisSQLParserBITNOT, DorisSQLParserAT, DorisSQLParserINTEGER_VALUE, DorisSQLParserDECIMAL_VALUE, DorisSQLParserDOUBLE_VALUE, DorisSQLParserSINGLE_QUOTED_TEXT, DorisSQLParserDOUBLE_QUOTED_TEXT, DorisSQLParserBINARY_SINGLE_QUOTED_TEXT, DorisSQLParserBINARY_DOUBLE_QUOTED_TEXT, DorisSQLParserLETTER_IDENTIFIER, DorisSQLParserDIGIT_IDENTIFIER, DorisSQLParserBACKQUOTED_IDENTIFIER, DorisSQLParserDOTDOTDOT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5660)
			p.expression(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetUserPropertyStatementContext is an interface to support dynamic dispatch.
type ISetUserPropertyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode
	UserPropertyList() IUserPropertyListContext
	FOR() antlr.TerminalNode
	String_() IStringContext

	// IsSetUserPropertyStatementContext differentiates from other interfaces.
	IsSetUserPropertyStatementContext()
}

type SetUserPropertyStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetUserPropertyStatementContext() *SetUserPropertyStatementContext {
	var p = new(SetUserPropertyStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_setUserPropertyStatement
	return p
}

func InitEmptySetUserPropertyStatementContext(p *SetUserPropertyStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_setUserPropertyStatement
}

func (*SetUserPropertyStatementContext) IsSetUserPropertyStatementContext() {}

func NewSetUserPropertyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetUserPropertyStatementContext {
	var p = new(SetUserPropertyStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_setUserPropertyStatement

	return p
}

func (s *SetUserPropertyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetUserPropertyStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *SetUserPropertyStatementContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROPERTY, 0)
}

func (s *SetUserPropertyStatementContext) UserPropertyList() IUserPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserPropertyListContext)
}

func (s *SetUserPropertyStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFOR, 0)
}

func (s *SetUserPropertyStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *SetUserPropertyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetUserPropertyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetUserPropertyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSetUserPropertyStatement(s)
	}
}

func (s *SetUserPropertyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSetUserPropertyStatement(s)
	}
}

func (s *SetUserPropertyStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSetUserPropertyStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SetUserPropertyStatement() (localctx ISetUserPropertyStatementContext) {
	localctx = NewSetUserPropertyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 692, DorisSQLParserRULE_setUserPropertyStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5663)
		p.Match(DorisSQLParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5664)
		p.Match(DorisSQLParserPROPERTY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5667)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFOR {
		{
			p.SetState(5665)
			p.Match(DorisSQLParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5666)
			p.String_()
		}

	}
	{
		p.SetState(5669)
		p.UserPropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleListContext is an interface to support dynamic dispatch.
type IRoleListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext

	// IsRoleListContext differentiates from other interfaces.
	IsRoleListContext()
}

type RoleListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleListContext() *RoleListContext {
	var p = new(RoleListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_roleList
	return p
}

func InitEmptyRoleListContext(p *RoleListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_roleList
}

func (*RoleListContext) IsRoleListContext() {}

func NewRoleListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleListContext {
	var p = new(RoleListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_roleList

	return p
}

func (s *RoleListContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleListContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *RoleListContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *RoleListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRoleList(s)
	}
}

func (s *RoleListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRoleList(s)
	}
}

func (s *RoleListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRoleList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) RoleList() (localctx IRoleListContext) {
	localctx = NewRoleListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 694, DorisSQLParserRULE_roleList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5671)
		p.IdentifierOrString()
	}
	p.SetState(5676)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(5672)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5673)
			p.IdentifierOrString()
		}

		p.SetState(5678)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExecuteScriptStatementContext is an interface to support dynamic dispatch.
type IExecuteScriptStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	EXECUTE() antlr.TerminalNode
	ON() antlr.TerminalNode
	String_() IStringContext
	FRONTEND() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsExecuteScriptStatementContext differentiates from other interfaces.
	IsExecuteScriptStatementContext()
}

type ExecuteScriptStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteScriptStatementContext() *ExecuteScriptStatementContext {
	var p = new(ExecuteScriptStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_executeScriptStatement
	return p
}

func InitEmptyExecuteScriptStatementContext(p *ExecuteScriptStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_executeScriptStatement
}

func (*ExecuteScriptStatementContext) IsExecuteScriptStatementContext() {}

func NewExecuteScriptStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteScriptStatementContext {
	var p = new(ExecuteScriptStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_executeScriptStatement

	return p
}

func (s *ExecuteScriptStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteScriptStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADMIN, 0)
}

func (s *ExecuteScriptStatementContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXECUTE, 0)
}

func (s *ExecuteScriptStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *ExecuteScriptStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ExecuteScriptStatementContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFRONTEND, 0)
}

func (s *ExecuteScriptStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, 0)
}

func (s *ExecuteScriptStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteScriptStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteScriptStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterExecuteScriptStatement(s)
	}
}

func (s *ExecuteScriptStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitExecuteScriptStatement(s)
	}
}

func (s *ExecuteScriptStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitExecuteScriptStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ExecuteScriptStatement() (localctx IExecuteScriptStatementContext) {
	localctx = NewExecuteScriptStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 696, DorisSQLParserRULE_executeScriptStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5679)
		p.Match(DorisSQLParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5680)
		p.Match(DorisSQLParserEXECUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5681)
		p.Match(DorisSQLParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5682)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserFRONTEND || _la == DorisSQLParserINTEGER_VALUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5683)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedStatementContext is an interface to support dynamic dispatch.
type IUnsupportedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCK() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	AllLock_item() []ILock_itemContext
	Lock_item(i int) ILock_itemContext
	UNLOCK() antlr.TerminalNode

	// IsUnsupportedStatementContext differentiates from other interfaces.
	IsUnsupportedStatementContext()
}

type UnsupportedStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedStatementContext() *UnsupportedStatementContext {
	var p = new(UnsupportedStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_unsupportedStatement
	return p
}

func InitEmptyUnsupportedStatementContext(p *UnsupportedStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_unsupportedStatement
}

func (*UnsupportedStatementContext) IsUnsupportedStatementContext() {}

func NewUnsupportedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedStatementContext {
	var p = new(UnsupportedStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_unsupportedStatement

	return p
}

func (s *UnsupportedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedStatementContext) LOCK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOCK, 0)
}

func (s *UnsupportedStatementContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLES, 0)
}

func (s *UnsupportedStatementContext) AllLock_item() []ILock_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILock_itemContext); ok {
			len++
		}
	}

	tst := make([]ILock_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILock_itemContext); ok {
			tst[i] = t.(ILock_itemContext)
			i++
		}
	}

	return tst
}

func (s *UnsupportedStatementContext) Lock_item(i int) ILock_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILock_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILock_itemContext)
}

func (s *UnsupportedStatementContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUNLOCK, 0)
}

func (s *UnsupportedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsupportedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterUnsupportedStatement(s)
	}
}

func (s *UnsupportedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitUnsupportedStatement(s)
	}
}

func (s *UnsupportedStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitUnsupportedStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) UnsupportedStatement() (localctx IUnsupportedStatementContext) {
	localctx = NewUnsupportedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 698, DorisSQLParserRULE_unsupportedStatement)
	var _la int

	p.SetState(5697)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserLOCK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5685)
			p.Match(DorisSQLParserLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5686)
			p.Match(DorisSQLParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5687)
			p.Lock_item()
		}
		p.SetState(5692)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(5688)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5689)
				p.Lock_item()
			}

			p.SetState(5694)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case DorisSQLParserUNLOCK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5695)
			p.Match(DorisSQLParserUNLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5696)
			p.Match(DorisSQLParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILock_itemContext is an interface to support dynamic dispatch.
type ILock_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlias returns the alias rule contexts.
	GetAlias() IIdentifierContext

	// SetAlias sets the alias rule contexts.
	SetAlias(IIdentifierContext)

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	Lock_type() ILock_typeContext
	AS() antlr.TerminalNode

	// IsLock_itemContext differentiates from other interfaces.
	IsLock_itemContext()
}

type Lock_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	alias  IIdentifierContext
}

func NewEmptyLock_itemContext() *Lock_itemContext {
	var p = new(Lock_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_lock_item
	return p
}

func InitEmptyLock_itemContext(p *Lock_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_lock_item
}

func (*Lock_itemContext) IsLock_itemContext() {}

func NewLock_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lock_itemContext {
	var p = new(Lock_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_lock_item

	return p
}

func (s *Lock_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Lock_itemContext) GetAlias() IIdentifierContext { return s.alias }

func (s *Lock_itemContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *Lock_itemContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Lock_itemContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Lock_itemContext) Lock_type() ILock_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILock_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILock_typeContext)
}

func (s *Lock_itemContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *Lock_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lock_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lock_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterLock_item(s)
	}
}

func (s *Lock_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitLock_item(s)
	}
}

func (s *Lock_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitLock_item(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Lock_item() (localctx ILock_itemContext) {
	localctx = NewLock_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 700, DorisSQLParserRULE_lock_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5699)
		p.Identifier()
	}
	p.SetState(5704)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 620, p.GetParserRuleContext()) == 1 {
		p.SetState(5701)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserAS {
			{
				p.SetState(5700)
				p.Match(DorisSQLParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5703)

			var _x = p.Identifier()

			localctx.(*Lock_itemContext).alias = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(5706)
		p.Lock_type()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILock_typeContext is an interface to support dynamic dispatch.
type ILock_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	LOW_PRIORITY() antlr.TerminalNode

	// IsLock_typeContext differentiates from other interfaces.
	IsLock_typeContext()
}

type Lock_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLock_typeContext() *Lock_typeContext {
	var p = new(Lock_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_lock_type
	return p
}

func InitEmptyLock_typeContext(p *Lock_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_lock_type
}

func (*Lock_typeContext) IsLock_typeContext() {}

func NewLock_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lock_typeContext {
	var p = new(Lock_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_lock_type

	return p
}

func (s *Lock_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Lock_typeContext) READ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREAD, 0)
}

func (s *Lock_typeContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOCAL, 0)
}

func (s *Lock_typeContext) WRITE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWRITE, 0)
}

func (s *Lock_typeContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOW_PRIORITY, 0)
}

func (s *Lock_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lock_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lock_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterLock_type(s)
	}
}

func (s *Lock_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitLock_type(s)
	}
}

func (s *Lock_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitLock_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Lock_type() (localctx ILock_typeContext) {
	localctx = NewLock_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 702, DorisSQLParserRULE_lock_type)
	var _la int

	p.SetState(5716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserREAD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5708)
			p.Match(DorisSQLParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5710)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserLOCAL {
			{
				p.SetState(5709)
				p.Match(DorisSQLParserLOCAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DorisSQLParserWRITE, DorisSQLParserLOW_PRIORITY:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5713)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserLOW_PRIORITY {
			{
				p.SetState(5712)
				p.Match(DorisSQLParserLOW_PRIORITY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5715)
			p.Match(DorisSQLParserWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterPlanAdvisorAddStatementContext is an interface to support dynamic dispatch.
type IAlterPlanAdvisorAddStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	ADVISOR() antlr.TerminalNode
	ADD() antlr.TerminalNode
	QueryStatement() IQueryStatementContext

	// IsAlterPlanAdvisorAddStatementContext differentiates from other interfaces.
	IsAlterPlanAdvisorAddStatementContext()
}

type AlterPlanAdvisorAddStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterPlanAdvisorAddStatementContext() *AlterPlanAdvisorAddStatementContext {
	var p = new(AlterPlanAdvisorAddStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterPlanAdvisorAddStatement
	return p
}

func InitEmptyAlterPlanAdvisorAddStatementContext(p *AlterPlanAdvisorAddStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterPlanAdvisorAddStatement
}

func (*AlterPlanAdvisorAddStatementContext) IsAlterPlanAdvisorAddStatementContext() {}

func NewAlterPlanAdvisorAddStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterPlanAdvisorAddStatementContext {
	var p = new(AlterPlanAdvisorAddStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_alterPlanAdvisorAddStatement

	return p
}

func (s *AlterPlanAdvisorAddStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterPlanAdvisorAddStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *AlterPlanAdvisorAddStatementContext) PLAN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPLAN, 0)
}

func (s *AlterPlanAdvisorAddStatementContext) ADVISOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADVISOR, 0)
}

func (s *AlterPlanAdvisorAddStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADD, 0)
}

func (s *AlterPlanAdvisorAddStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *AlterPlanAdvisorAddStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterPlanAdvisorAddStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterPlanAdvisorAddStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAlterPlanAdvisorAddStatement(s)
	}
}

func (s *AlterPlanAdvisorAddStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAlterPlanAdvisorAddStatement(s)
	}
}

func (s *AlterPlanAdvisorAddStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAlterPlanAdvisorAddStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AlterPlanAdvisorAddStatement() (localctx IAlterPlanAdvisorAddStatementContext) {
	localctx = NewAlterPlanAdvisorAddStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 704, DorisSQLParserRULE_alterPlanAdvisorAddStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5718)
		p.Match(DorisSQLParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5719)
		p.Match(DorisSQLParserPLAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5720)
		p.Match(DorisSQLParserADVISOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5721)
		p.Match(DorisSQLParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5722)
		p.QueryStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITruncatePlanAdvisorStatementContext is an interface to support dynamic dispatch.
type ITruncatePlanAdvisorStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUNCATE() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	ADVISOR() antlr.TerminalNode

	// IsTruncatePlanAdvisorStatementContext differentiates from other interfaces.
	IsTruncatePlanAdvisorStatementContext()
}

type TruncatePlanAdvisorStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncatePlanAdvisorStatementContext() *TruncatePlanAdvisorStatementContext {
	var p = new(TruncatePlanAdvisorStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_truncatePlanAdvisorStatement
	return p
}

func InitEmptyTruncatePlanAdvisorStatementContext(p *TruncatePlanAdvisorStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_truncatePlanAdvisorStatement
}

func (*TruncatePlanAdvisorStatementContext) IsTruncatePlanAdvisorStatementContext() {}

func NewTruncatePlanAdvisorStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncatePlanAdvisorStatementContext {
	var p = new(TruncatePlanAdvisorStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_truncatePlanAdvisorStatement

	return p
}

func (s *TruncatePlanAdvisorStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncatePlanAdvisorStatementContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTRUNCATE, 0)
}

func (s *TruncatePlanAdvisorStatementContext) PLAN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPLAN, 0)
}

func (s *TruncatePlanAdvisorStatementContext) ADVISOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADVISOR, 0)
}

func (s *TruncatePlanAdvisorStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncatePlanAdvisorStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TruncatePlanAdvisorStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTruncatePlanAdvisorStatement(s)
	}
}

func (s *TruncatePlanAdvisorStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTruncatePlanAdvisorStatement(s)
	}
}

func (s *TruncatePlanAdvisorStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTruncatePlanAdvisorStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) TruncatePlanAdvisorStatement() (localctx ITruncatePlanAdvisorStatementContext) {
	localctx = NewTruncatePlanAdvisorStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 706, DorisSQLParserRULE_truncatePlanAdvisorStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5724)
		p.Match(DorisSQLParserTRUNCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5725)
		p.Match(DorisSQLParserPLAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5726)
		p.Match(DorisSQLParserADVISOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterPlanAdvisorDropStatementContext is an interface to support dynamic dispatch.
type IAlterPlanAdvisorDropStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	ADVISOR() antlr.TerminalNode
	DROP() antlr.TerminalNode
	String_() IStringContext

	// IsAlterPlanAdvisorDropStatementContext differentiates from other interfaces.
	IsAlterPlanAdvisorDropStatementContext()
}

type AlterPlanAdvisorDropStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterPlanAdvisorDropStatementContext() *AlterPlanAdvisorDropStatementContext {
	var p = new(AlterPlanAdvisorDropStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterPlanAdvisorDropStatement
	return p
}

func InitEmptyAlterPlanAdvisorDropStatementContext(p *AlterPlanAdvisorDropStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterPlanAdvisorDropStatement
}

func (*AlterPlanAdvisorDropStatementContext) IsAlterPlanAdvisorDropStatementContext() {}

func NewAlterPlanAdvisorDropStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterPlanAdvisorDropStatementContext {
	var p = new(AlterPlanAdvisorDropStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_alterPlanAdvisorDropStatement

	return p
}

func (s *AlterPlanAdvisorDropStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterPlanAdvisorDropStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *AlterPlanAdvisorDropStatementContext) PLAN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPLAN, 0)
}

func (s *AlterPlanAdvisorDropStatementContext) ADVISOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADVISOR, 0)
}

func (s *AlterPlanAdvisorDropStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *AlterPlanAdvisorDropStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AlterPlanAdvisorDropStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterPlanAdvisorDropStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterPlanAdvisorDropStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAlterPlanAdvisorDropStatement(s)
	}
}

func (s *AlterPlanAdvisorDropStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAlterPlanAdvisorDropStatement(s)
	}
}

func (s *AlterPlanAdvisorDropStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAlterPlanAdvisorDropStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AlterPlanAdvisorDropStatement() (localctx IAlterPlanAdvisorDropStatementContext) {
	localctx = NewAlterPlanAdvisorDropStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 708, DorisSQLParserRULE_alterPlanAdvisorDropStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5728)
		p.Match(DorisSQLParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5729)
		p.Match(DorisSQLParserPLAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5730)
		p.Match(DorisSQLParserADVISOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5731)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5732)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowPlanAdvisorStatementContext is an interface to support dynamic dispatch.
type IShowPlanAdvisorStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	ADVISOR() antlr.TerminalNode

	// IsShowPlanAdvisorStatementContext differentiates from other interfaces.
	IsShowPlanAdvisorStatementContext()
}

type ShowPlanAdvisorStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowPlanAdvisorStatementContext() *ShowPlanAdvisorStatementContext {
	var p = new(ShowPlanAdvisorStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showPlanAdvisorStatement
	return p
}

func InitEmptyShowPlanAdvisorStatementContext(p *ShowPlanAdvisorStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showPlanAdvisorStatement
}

func (*ShowPlanAdvisorStatementContext) IsShowPlanAdvisorStatementContext() {}

func NewShowPlanAdvisorStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowPlanAdvisorStatementContext {
	var p = new(ShowPlanAdvisorStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showPlanAdvisorStatement

	return p
}

func (s *ShowPlanAdvisorStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowPlanAdvisorStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowPlanAdvisorStatementContext) PLAN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPLAN, 0)
}

func (s *ShowPlanAdvisorStatementContext) ADVISOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADVISOR, 0)
}

func (s *ShowPlanAdvisorStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPlanAdvisorStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowPlanAdvisorStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowPlanAdvisorStatement(s)
	}
}

func (s *ShowPlanAdvisorStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowPlanAdvisorStatement(s)
	}
}

func (s *ShowPlanAdvisorStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowPlanAdvisorStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowPlanAdvisorStatement() (localctx IShowPlanAdvisorStatementContext) {
	localctx = NewShowPlanAdvisorStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 710, DorisSQLParserRULE_showPlanAdvisorStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5734)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5735)
		p.Match(DorisSQLParserPLAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5736)
		p.Match(DorisSQLParserADVISOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateWarehouseStatementContext is an interface to support dynamic dispatch.
type ICreateWarehouseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	WAREHOUSE() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Comment() ICommentContext
	Properties() IPropertiesContext

	// IsCreateWarehouseStatementContext differentiates from other interfaces.
	IsCreateWarehouseStatementContext()
}

type CreateWarehouseStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
}

func NewEmptyCreateWarehouseStatementContext() *CreateWarehouseStatementContext {
	var p = new(CreateWarehouseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createWarehouseStatement
	return p
}

func InitEmptyCreateWarehouseStatementContext(p *CreateWarehouseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createWarehouseStatement
}

func (*CreateWarehouseStatementContext) IsCreateWarehouseStatementContext() {}

func NewCreateWarehouseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateWarehouseStatementContext {
	var p = new(CreateWarehouseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createWarehouseStatement

	return p
}

func (s *CreateWarehouseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateWarehouseStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *CreateWarehouseStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *CreateWarehouseStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCREATE, 0)
}

func (s *CreateWarehouseStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CreateWarehouseStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWAREHOUSE, 0)
}

func (s *CreateWarehouseStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *CreateWarehouseStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *CreateWarehouseStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *CreateWarehouseStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateWarehouseStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateWarehouseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateWarehouseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateWarehouseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateWarehouseStatement(s)
	}
}

func (s *CreateWarehouseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateWarehouseStatement(s)
	}
}

func (s *CreateWarehouseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateWarehouseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateWarehouseStatement() (localctx ICreateWarehouseStatementContext) {
	localctx = NewCreateWarehouseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 712, DorisSQLParserRULE_createWarehouseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5738)
		p.Match(DorisSQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	{
		p.SetState(5739)
		p.Match(DorisSQLParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	p.SetState(5743)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(5740)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5741)
			p.Match(DorisSQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5742)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5745)

		var _x = p.IdentifierOrString()

		localctx.(*CreateWarehouseStatementContext).warehouseName = _x
	}
	p.SetState(5747)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserCOMMENT {
		{
			p.SetState(5746)
			p.Comment()
		}

	}
	p.SetState(5750)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(5749)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropWarehouseStatementContext is an interface to support dynamic dispatch.
type IDropWarehouseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropWarehouseStatementContext differentiates from other interfaces.
	IsDropWarehouseStatementContext()
}

type DropWarehouseStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
}

func NewEmptyDropWarehouseStatementContext() *DropWarehouseStatementContext {
	var p = new(DropWarehouseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropWarehouseStatement
	return p
}

func InitEmptyDropWarehouseStatementContext(p *DropWarehouseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropWarehouseStatement
}

func (*DropWarehouseStatementContext) IsDropWarehouseStatementContext() {}

func NewDropWarehouseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropWarehouseStatementContext {
	var p = new(DropWarehouseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropWarehouseStatement

	return p
}

func (s *DropWarehouseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropWarehouseStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *DropWarehouseStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *DropWarehouseStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropWarehouseStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWAREHOUSE, 0)
}

func (s *DropWarehouseStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropWarehouseStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *DropWarehouseStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *DropWarehouseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropWarehouseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropWarehouseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropWarehouseStatement(s)
	}
}

func (s *DropWarehouseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropWarehouseStatement(s)
	}
}

func (s *DropWarehouseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropWarehouseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropWarehouseStatement() (localctx IDropWarehouseStatementContext) {
	localctx = NewDropWarehouseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 714, DorisSQLParserRULE_dropWarehouseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5752)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5753)
		p.Match(DorisSQLParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5756)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(5754)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5755)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5758)

		var _x = p.IdentifierOrString()

		localctx.(*DropWarehouseStatementContext).warehouseName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISuspendWarehouseStatementContext is an interface to support dynamic dispatch.
type ISuspendWarehouseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUSPEND() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsSuspendWarehouseStatementContext differentiates from other interfaces.
	IsSuspendWarehouseStatementContext()
}

type SuspendWarehouseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuspendWarehouseStatementContext() *SuspendWarehouseStatementContext {
	var p = new(SuspendWarehouseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_suspendWarehouseStatement
	return p
}

func InitEmptySuspendWarehouseStatementContext(p *SuspendWarehouseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_suspendWarehouseStatement
}

func (*SuspendWarehouseStatementContext) IsSuspendWarehouseStatementContext() {}

func NewSuspendWarehouseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuspendWarehouseStatementContext {
	var p = new(SuspendWarehouseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_suspendWarehouseStatement

	return p
}

func (s *SuspendWarehouseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SuspendWarehouseStatementContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSUSPEND, 0)
}

func (s *SuspendWarehouseStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWAREHOUSE, 0)
}

func (s *SuspendWarehouseStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SuspendWarehouseStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *SuspendWarehouseStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *SuspendWarehouseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuspendWarehouseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SuspendWarehouseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSuspendWarehouseStatement(s)
	}
}

func (s *SuspendWarehouseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSuspendWarehouseStatement(s)
	}
}

func (s *SuspendWarehouseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSuspendWarehouseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SuspendWarehouseStatement() (localctx ISuspendWarehouseStatementContext) {
	localctx = NewSuspendWarehouseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 716, DorisSQLParserRULE_suspendWarehouseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5760)
		p.Match(DorisSQLParserSUSPEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5761)
		p.Match(DorisSQLParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5764)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(5762)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5763)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5766)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResumeWarehouseStatementContext is an interface to support dynamic dispatch.
type IResumeWarehouseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESUME() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsResumeWarehouseStatementContext differentiates from other interfaces.
	IsResumeWarehouseStatementContext()
}

type ResumeWarehouseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResumeWarehouseStatementContext() *ResumeWarehouseStatementContext {
	var p = new(ResumeWarehouseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_resumeWarehouseStatement
	return p
}

func InitEmptyResumeWarehouseStatementContext(p *ResumeWarehouseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_resumeWarehouseStatement
}

func (*ResumeWarehouseStatementContext) IsResumeWarehouseStatementContext() {}

func NewResumeWarehouseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResumeWarehouseStatementContext {
	var p = new(ResumeWarehouseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_resumeWarehouseStatement

	return p
}

func (s *ResumeWarehouseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ResumeWarehouseStatementContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRESUME, 0)
}

func (s *ResumeWarehouseStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWAREHOUSE, 0)
}

func (s *ResumeWarehouseStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ResumeWarehouseStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *ResumeWarehouseStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *ResumeWarehouseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumeWarehouseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResumeWarehouseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterResumeWarehouseStatement(s)
	}
}

func (s *ResumeWarehouseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitResumeWarehouseStatement(s)
	}
}

func (s *ResumeWarehouseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitResumeWarehouseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ResumeWarehouseStatement() (localctx IResumeWarehouseStatementContext) {
	localctx = NewResumeWarehouseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 718, DorisSQLParserRULE_resumeWarehouseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5768)
		p.Match(DorisSQLParserRESUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5769)
		p.Match(DorisSQLParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5772)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(5770)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5771)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5774)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetWarehouseStatementContext is an interface to support dynamic dispatch.
type ISetWarehouseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	SESSION() antlr.TerminalNode
	EQ() antlr.TerminalNode

	// IsSetWarehouseStatementContext differentiates from other interfaces.
	IsSetWarehouseStatementContext()
}

type SetWarehouseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetWarehouseStatementContext() *SetWarehouseStatementContext {
	var p = new(SetWarehouseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_setWarehouseStatement
	return p
}

func InitEmptySetWarehouseStatementContext(p *SetWarehouseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_setWarehouseStatement
}

func (*SetWarehouseStatementContext) IsSetWarehouseStatementContext() {}

func NewSetWarehouseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetWarehouseStatementContext {
	var p = new(SetWarehouseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_setWarehouseStatement

	return p
}

func (s *SetWarehouseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetWarehouseStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSET, 0)
}

func (s *SetWarehouseStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWAREHOUSE, 0)
}

func (s *SetWarehouseStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *SetWarehouseStatementContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSESSION, 0)
}

func (s *SetWarehouseStatementContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEQ, 0)
}

func (s *SetWarehouseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetWarehouseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetWarehouseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSetWarehouseStatement(s)
	}
}

func (s *SetWarehouseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSetWarehouseStatement(s)
	}
}

func (s *SetWarehouseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSetWarehouseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SetWarehouseStatement() (localctx ISetWarehouseStatementContext) {
	localctx = NewSetWarehouseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 720, DorisSQLParserRULE_setWarehouseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5776)
		p.Match(DorisSQLParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5778)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserSESSION {
		{
			p.SetState(5777)
			p.Match(DorisSQLParserSESSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5780)
		p.Match(DorisSQLParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5782)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserEQ {
		{
			p.SetState(5781)
			p.Match(DorisSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5784)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowWarehousesStatementContext is an interface to support dynamic dispatch.
type IShowWarehousesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	WAREHOUSES() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	String_() IStringContext

	// IsShowWarehousesStatementContext differentiates from other interfaces.
	IsShowWarehousesStatementContext()
}

type ShowWarehousesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowWarehousesStatementContext() *ShowWarehousesStatementContext {
	var p = new(ShowWarehousesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showWarehousesStatement
	return p
}

func InitEmptyShowWarehousesStatementContext(p *ShowWarehousesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showWarehousesStatement
}

func (*ShowWarehousesStatementContext) IsShowWarehousesStatementContext() {}

func NewShowWarehousesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowWarehousesStatementContext {
	var p = new(ShowWarehousesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showWarehousesStatement

	return p
}

func (s *ShowWarehousesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowWarehousesStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowWarehousesStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowWarehousesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowWarehousesStatementContext) WAREHOUSES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWAREHOUSES, 0)
}

func (s *ShowWarehousesStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *ShowWarehousesStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowWarehousesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWarehousesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowWarehousesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowWarehousesStatement(s)
	}
}

func (s *ShowWarehousesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowWarehousesStatement(s)
	}
}

func (s *ShowWarehousesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowWarehousesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowWarehousesStatement() (localctx IShowWarehousesStatementContext) {
	localctx = NewShowWarehousesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 722, DorisSQLParserRULE_showWarehousesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5786)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5787)
		p.Match(DorisSQLParserWAREHOUSES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5790)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserLIKE {
		{
			p.SetState(5788)
			p.Match(DorisSQLParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5789)

			var _x = p.String_()

			localctx.(*ShowWarehousesStatementContext).pattern = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowClustersStatementContext is an interface to support dynamic dispatch.
type IShowClustersStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	FROM() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	Identifier() IIdentifierContext
	CLUSTERS() antlr.TerminalNode
	CNGROUPS() antlr.TerminalNode

	// IsShowClustersStatementContext differentiates from other interfaces.
	IsShowClustersStatementContext()
}

type ShowClustersStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowClustersStatementContext() *ShowClustersStatementContext {
	var p = new(ShowClustersStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showClustersStatement
	return p
}

func InitEmptyShowClustersStatementContext(p *ShowClustersStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showClustersStatement
}

func (*ShowClustersStatementContext) IsShowClustersStatementContext() {}

func NewShowClustersStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowClustersStatementContext {
	var p = new(ShowClustersStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showClustersStatement

	return p
}

func (s *ShowClustersStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowClustersStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowClustersStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowClustersStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWAREHOUSE, 0)
}

func (s *ShowClustersStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowClustersStatementContext) CLUSTERS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCLUSTERS, 0)
}

func (s *ShowClustersStatementContext) CNGROUPS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCNGROUPS, 0)
}

func (s *ShowClustersStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowClustersStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowClustersStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowClustersStatement(s)
	}
}

func (s *ShowClustersStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowClustersStatement(s)
	}
}

func (s *ShowClustersStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowClustersStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowClustersStatement() (localctx IShowClustersStatementContext) {
	localctx = NewShowClustersStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 724, DorisSQLParserRULE_showClustersStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5792)
		p.Match(DorisSQLParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5793)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserCLUSTERS || _la == DorisSQLParserCNGROUPS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5794)
		p.Match(DorisSQLParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5795)
		p.Match(DorisSQLParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5796)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowNodesStatementContext is an interface to support dynamic dispatch.
type IShowNodesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	NODES() antlr.TerminalNode
	FROM() antlr.TerminalNode
	WAREHOUSES() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	String_() IStringContext
	WAREHOUSE() antlr.TerminalNode
	Identifier() IIdentifierContext
	CNGROUP() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsShowNodesStatementContext differentiates from other interfaces.
	IsShowNodesStatementContext()
}

type ShowNodesStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	pattern     IStringContext
	cngroupName IIdentifierOrStringContext
}

func NewEmptyShowNodesStatementContext() *ShowNodesStatementContext {
	var p = new(ShowNodesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showNodesStatement
	return p
}

func InitEmptyShowNodesStatementContext(p *ShowNodesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_showNodesStatement
}

func (*ShowNodesStatementContext) IsShowNodesStatementContext() {}

func NewShowNodesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowNodesStatementContext {
	var p = new(ShowNodesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_showNodesStatement

	return p
}

func (s *ShowNodesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowNodesStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowNodesStatementContext) GetCngroupName() IIdentifierOrStringContext { return s.cngroupName }

func (s *ShowNodesStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowNodesStatementContext) SetCngroupName(v IIdentifierOrStringContext) { s.cngroupName = v }

func (s *ShowNodesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSHOW, 0)
}

func (s *ShowNodesStatementContext) NODES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNODES, 0)
}

func (s *ShowNodesStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ShowNodesStatementContext) WAREHOUSES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWAREHOUSES, 0)
}

func (s *ShowNodesStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *ShowNodesStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowNodesStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWAREHOUSE, 0)
}

func (s *ShowNodesStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowNodesStatementContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCNGROUP, 0)
}

func (s *ShowNodesStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *ShowNodesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowNodesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowNodesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterShowNodesStatement(s)
	}
}

func (s *ShowNodesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitShowNodesStatement(s)
	}
}

func (s *ShowNodesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitShowNodesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ShowNodesStatement() (localctx IShowNodesStatementContext) {
	localctx = NewShowNodesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 726, DorisSQLParserRULE_showNodesStatement)
	var _la int

	p.SetState(5815)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 635, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5798)
			p.Match(DorisSQLParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5799)
			p.Match(DorisSQLParserNODES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5800)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5801)
			p.Match(DorisSQLParserWAREHOUSES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5804)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserLIKE {
			{
				p.SetState(5802)
				p.Match(DorisSQLParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5803)

				var _x = p.String_()

				localctx.(*ShowNodesStatementContext).pattern = _x
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5806)
			p.Match(DorisSQLParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5807)
			p.Match(DorisSQLParserNODES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5808)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5809)
			p.Match(DorisSQLParserWAREHOUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5810)
			p.Identifier()
		}
		p.SetState(5813)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserCNGROUP {
			{
				p.SetState(5811)
				p.Match(DorisSQLParserCNGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5812)

				var _x = p.IdentifierOrString()

				localctx.(*ShowNodesStatementContext).cngroupName = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterWarehouseStatementContext is an interface to support dynamic dispatch.
type IAlterWarehouseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	ModifyPropertiesClause() IModifyPropertiesClauseContext
	IdentifierOrString() IIdentifierOrStringContext

	// IsAlterWarehouseStatementContext differentiates from other interfaces.
	IsAlterWarehouseStatementContext()
}

type AlterWarehouseStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
}

func NewEmptyAlterWarehouseStatementContext() *AlterWarehouseStatementContext {
	var p = new(AlterWarehouseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterWarehouseStatement
	return p
}

func InitEmptyAlterWarehouseStatementContext(p *AlterWarehouseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterWarehouseStatement
}

func (*AlterWarehouseStatementContext) IsAlterWarehouseStatementContext() {}

func NewAlterWarehouseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterWarehouseStatementContext {
	var p = new(AlterWarehouseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_alterWarehouseStatement

	return p
}

func (s *AlterWarehouseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterWarehouseStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *AlterWarehouseStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *AlterWarehouseStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *AlterWarehouseStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWAREHOUSE, 0)
}

func (s *AlterWarehouseStatementContext) ModifyPropertiesClause() IModifyPropertiesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyPropertiesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyPropertiesClauseContext)
}

func (s *AlterWarehouseStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AlterWarehouseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterWarehouseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterWarehouseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAlterWarehouseStatement(s)
	}
}

func (s *AlterWarehouseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAlterWarehouseStatement(s)
	}
}

func (s *AlterWarehouseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAlterWarehouseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AlterWarehouseStatement() (localctx IAlterWarehouseStatementContext) {
	localctx = NewAlterWarehouseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 728, DorisSQLParserRULE_alterWarehouseStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5817)
		p.Match(DorisSQLParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5818)
		p.Match(DorisSQLParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5819)

		var _x = p.IdentifierOrString()

		localctx.(*AlterWarehouseStatementContext).warehouseName = _x
	}
	{
		p.SetState(5820)
		p.ModifyPropertiesClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateCNGroupStatementContext is an interface to support dynamic dispatch.
type ICreateCNGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	ADD() antlr.TerminalNode
	CNGROUP() antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Comment() ICommentContext
	Properties() IPropertiesContext

	// IsCreateCNGroupStatementContext differentiates from other interfaces.
	IsCreateCNGroupStatementContext()
}

type CreateCNGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyCreateCNGroupStatementContext() *CreateCNGroupStatementContext {
	var p = new(CreateCNGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createCNGroupStatement
	return p
}

func InitEmptyCreateCNGroupStatementContext(p *CreateCNGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_createCNGroupStatement
}

func (*CreateCNGroupStatementContext) IsCreateCNGroupStatementContext() {}

func NewCreateCNGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateCNGroupStatementContext {
	var p = new(CreateCNGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_createCNGroupStatement

	return p
}

func (s *CreateCNGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateCNGroupStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *CreateCNGroupStatementContext) GetCngroupName() IIdentifierOrStringContext {
	return s.cngroupName
}

func (s *CreateCNGroupStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *CreateCNGroupStatementContext) SetCngroupName(v IIdentifierOrStringContext) {
	s.cngroupName = v
}

func (s *CreateCNGroupStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *CreateCNGroupStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWAREHOUSE, 0)
}

func (s *CreateCNGroupStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADD, 0)
}

func (s *CreateCNGroupStatementContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCNGROUP, 0)
}

func (s *CreateCNGroupStatementContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *CreateCNGroupStatementContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CreateCNGroupStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *CreateCNGroupStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *CreateCNGroupStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *CreateCNGroupStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateCNGroupStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateCNGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateCNGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateCNGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCreateCNGroupStatement(s)
	}
}

func (s *CreateCNGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCreateCNGroupStatement(s)
	}
}

func (s *CreateCNGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCreateCNGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CreateCNGroupStatement() (localctx ICreateCNGroupStatementContext) {
	localctx = NewCreateCNGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 730, DorisSQLParserRULE_createCNGroupStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5822)
		p.Match(DorisSQLParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5823)
		p.Match(DorisSQLParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5824)

		var _x = p.IdentifierOrString()

		localctx.(*CreateCNGroupStatementContext).warehouseName = _x
	}
	{
		p.SetState(5825)
		p.Match(DorisSQLParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5826)
		p.Match(DorisSQLParserCNGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5830)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(5827)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5828)
			p.Match(DorisSQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5829)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5832)

		var _x = p.IdentifierOrString()

		localctx.(*CreateCNGroupStatementContext).cngroupName = _x
	}
	p.SetState(5834)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserCOMMENT {
		{
			p.SetState(5833)
			p.Comment()
		}

	}
	p.SetState(5837)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(5836)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropCNGroupStatementContext is an interface to support dynamic dispatch.
type IDropCNGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	DROP() antlr.TerminalNode
	CNGROUP() antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	FORCE() antlr.TerminalNode

	// IsDropCNGroupStatementContext differentiates from other interfaces.
	IsDropCNGroupStatementContext()
}

type DropCNGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyDropCNGroupStatementContext() *DropCNGroupStatementContext {
	var p = new(DropCNGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropCNGroupStatement
	return p
}

func InitEmptyDropCNGroupStatementContext(p *DropCNGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dropCNGroupStatement
}

func (*DropCNGroupStatementContext) IsDropCNGroupStatementContext() {}

func NewDropCNGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropCNGroupStatementContext {
	var p = new(DropCNGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dropCNGroupStatement

	return p
}

func (s *DropCNGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropCNGroupStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *DropCNGroupStatementContext) GetCngroupName() IIdentifierOrStringContext {
	return s.cngroupName
}

func (s *DropCNGroupStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *DropCNGroupStatementContext) SetCngroupName(v IIdentifierOrStringContext) { s.cngroupName = v }

func (s *DropCNGroupStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *DropCNGroupStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWAREHOUSE, 0)
}

func (s *DropCNGroupStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DropCNGroupStatementContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCNGROUP, 0)
}

func (s *DropCNGroupStatementContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *DropCNGroupStatementContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropCNGroupStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *DropCNGroupStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *DropCNGroupStatementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFORCE, 0)
}

func (s *DropCNGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropCNGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropCNGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDropCNGroupStatement(s)
	}
}

func (s *DropCNGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDropCNGroupStatement(s)
	}
}

func (s *DropCNGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDropCNGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DropCNGroupStatement() (localctx IDropCNGroupStatementContext) {
	localctx = NewDropCNGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 732, DorisSQLParserRULE_dropCNGroupStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5839)
		p.Match(DorisSQLParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5840)
		p.Match(DorisSQLParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5841)

		var _x = p.IdentifierOrString()

		localctx.(*DropCNGroupStatementContext).warehouseName = _x
	}
	{
		p.SetState(5842)
		p.Match(DorisSQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5843)
		p.Match(DorisSQLParserCNGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(5844)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5845)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5848)

		var _x = p.IdentifierOrString()

		localctx.(*DropCNGroupStatementContext).cngroupName = _x
	}
	p.SetState(5850)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFORCE {
		{
			p.SetState(5849)
			p.Match(DorisSQLParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnableCNGroupStatementContext is an interface to support dynamic dispatch.
type IEnableCNGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	ENABLE() antlr.TerminalNode
	CNGROUP() antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext

	// IsEnableCNGroupStatementContext differentiates from other interfaces.
	IsEnableCNGroupStatementContext()
}

type EnableCNGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyEnableCNGroupStatementContext() *EnableCNGroupStatementContext {
	var p = new(EnableCNGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_enableCNGroupStatement
	return p
}

func InitEmptyEnableCNGroupStatementContext(p *EnableCNGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_enableCNGroupStatement
}

func (*EnableCNGroupStatementContext) IsEnableCNGroupStatementContext() {}

func NewEnableCNGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnableCNGroupStatementContext {
	var p = new(EnableCNGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_enableCNGroupStatement

	return p
}

func (s *EnableCNGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EnableCNGroupStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *EnableCNGroupStatementContext) GetCngroupName() IIdentifierOrStringContext {
	return s.cngroupName
}

func (s *EnableCNGroupStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *EnableCNGroupStatementContext) SetCngroupName(v IIdentifierOrStringContext) {
	s.cngroupName = v
}

func (s *EnableCNGroupStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *EnableCNGroupStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWAREHOUSE, 0)
}

func (s *EnableCNGroupStatementContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserENABLE, 0)
}

func (s *EnableCNGroupStatementContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCNGROUP, 0)
}

func (s *EnableCNGroupStatementContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *EnableCNGroupStatementContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *EnableCNGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnableCNGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnableCNGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterEnableCNGroupStatement(s)
	}
}

func (s *EnableCNGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitEnableCNGroupStatement(s)
	}
}

func (s *EnableCNGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitEnableCNGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) EnableCNGroupStatement() (localctx IEnableCNGroupStatementContext) {
	localctx = NewEnableCNGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 734, DorisSQLParserRULE_enableCNGroupStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5852)
		p.Match(DorisSQLParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5853)
		p.Match(DorisSQLParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5854)

		var _x = p.IdentifierOrString()

		localctx.(*EnableCNGroupStatementContext).warehouseName = _x
	}
	{
		p.SetState(5855)
		p.Match(DorisSQLParserENABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5856)
		p.Match(DorisSQLParserCNGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5857)

		var _x = p.IdentifierOrString()

		localctx.(*EnableCNGroupStatementContext).cngroupName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDisableCNGroupStatementContext is an interface to support dynamic dispatch.
type IDisableCNGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	CNGROUP() antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext

	// IsDisableCNGroupStatementContext differentiates from other interfaces.
	IsDisableCNGroupStatementContext()
}

type DisableCNGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyDisableCNGroupStatementContext() *DisableCNGroupStatementContext {
	var p = new(DisableCNGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_disableCNGroupStatement
	return p
}

func InitEmptyDisableCNGroupStatementContext(p *DisableCNGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_disableCNGroupStatement
}

func (*DisableCNGroupStatementContext) IsDisableCNGroupStatementContext() {}

func NewDisableCNGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisableCNGroupStatementContext {
	var p = new(DisableCNGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_disableCNGroupStatement

	return p
}

func (s *DisableCNGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DisableCNGroupStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *DisableCNGroupStatementContext) GetCngroupName() IIdentifierOrStringContext {
	return s.cngroupName
}

func (s *DisableCNGroupStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *DisableCNGroupStatementContext) SetCngroupName(v IIdentifierOrStringContext) {
	s.cngroupName = v
}

func (s *DisableCNGroupStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *DisableCNGroupStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWAREHOUSE, 0)
}

func (s *DisableCNGroupStatementContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDISABLE, 0)
}

func (s *DisableCNGroupStatementContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCNGROUP, 0)
}

func (s *DisableCNGroupStatementContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *DisableCNGroupStatementContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DisableCNGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisableCNGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisableCNGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDisableCNGroupStatement(s)
	}
}

func (s *DisableCNGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDisableCNGroupStatement(s)
	}
}

func (s *DisableCNGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDisableCNGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DisableCNGroupStatement() (localctx IDisableCNGroupStatementContext) {
	localctx = NewDisableCNGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 736, DorisSQLParserRULE_disableCNGroupStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5859)
		p.Match(DorisSQLParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5860)
		p.Match(DorisSQLParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5861)

		var _x = p.IdentifierOrString()

		localctx.(*DisableCNGroupStatementContext).warehouseName = _x
	}
	{
		p.SetState(5862)
		p.Match(DorisSQLParserDISABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5863)
		p.Match(DorisSQLParserCNGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5864)

		var _x = p.IdentifierOrString()

		localctx.(*DisableCNGroupStatementContext).cngroupName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterCNGroupStatementContext is an interface to support dynamic dispatch.
type IAlterCNGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	CNGROUP() antlr.TerminalNode
	ModifyPropertiesClause() IModifyPropertiesClauseContext
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext

	// IsAlterCNGroupStatementContext differentiates from other interfaces.
	IsAlterCNGroupStatementContext()
}

type AlterCNGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyAlterCNGroupStatementContext() *AlterCNGroupStatementContext {
	var p = new(AlterCNGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterCNGroupStatement
	return p
}

func InitEmptyAlterCNGroupStatementContext(p *AlterCNGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_alterCNGroupStatement
}

func (*AlterCNGroupStatementContext) IsAlterCNGroupStatementContext() {}

func NewAlterCNGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterCNGroupStatementContext {
	var p = new(AlterCNGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_alterCNGroupStatement

	return p
}

func (s *AlterCNGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterCNGroupStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *AlterCNGroupStatementContext) GetCngroupName() IIdentifierOrStringContext {
	return s.cngroupName
}

func (s *AlterCNGroupStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *AlterCNGroupStatementContext) SetCngroupName(v IIdentifierOrStringContext) {
	s.cngroupName = v
}

func (s *AlterCNGroupStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALTER, 0)
}

func (s *AlterCNGroupStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWAREHOUSE, 0)
}

func (s *AlterCNGroupStatementContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMODIFY, 0)
}

func (s *AlterCNGroupStatementContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCNGROUP, 0)
}

func (s *AlterCNGroupStatementContext) ModifyPropertiesClause() IModifyPropertiesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyPropertiesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyPropertiesClauseContext)
}

func (s *AlterCNGroupStatementContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *AlterCNGroupStatementContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AlterCNGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterCNGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterCNGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAlterCNGroupStatement(s)
	}
}

func (s *AlterCNGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAlterCNGroupStatement(s)
	}
}

func (s *AlterCNGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAlterCNGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AlterCNGroupStatement() (localctx IAlterCNGroupStatementContext) {
	localctx = NewAlterCNGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 738, DorisSQLParserRULE_alterCNGroupStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5866)
		p.Match(DorisSQLParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5867)
		p.Match(DorisSQLParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5868)

		var _x = p.IdentifierOrString()

		localctx.(*AlterCNGroupStatementContext).warehouseName = _x
	}
	{
		p.SetState(5869)
		p.Match(DorisSQLParserMODIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5870)
		p.Match(DorisSQLParserCNGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5871)

		var _x = p.IdentifierOrString()

		localctx.(*AlterCNGroupStatementContext).cngroupName = _x
	}
	{
		p.SetState(5872)
		p.ModifyPropertiesClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBeginStatementContext is an interface to support dynamic dispatch.
type IBeginStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	WITH() antlr.TerminalNode
	CONSISTENT() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	WORK() antlr.TerminalNode

	// IsBeginStatementContext differentiates from other interfaces.
	IsBeginStatementContext()
}

type BeginStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBeginStatementContext() *BeginStatementContext {
	var p = new(BeginStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_beginStatement
	return p
}

func InitEmptyBeginStatementContext(p *BeginStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_beginStatement
}

func (*BeginStatementContext) IsBeginStatementContext() {}

func NewBeginStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BeginStatementContext {
	var p = new(BeginStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_beginStatement

	return p
}

func (s *BeginStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BeginStatementContext) START() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTART, 0)
}

func (s *BeginStatementContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTRANSACTION, 0)
}

func (s *BeginStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *BeginStatementContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCONSISTENT, 0)
}

func (s *BeginStatementContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSNAPSHOT, 0)
}

func (s *BeginStatementContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBEGIN, 0)
}

func (s *BeginStatementContext) WORK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWORK, 0)
}

func (s *BeginStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BeginStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BeginStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterBeginStatement(s)
	}
}

func (s *BeginStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitBeginStatement(s)
	}
}

func (s *BeginStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitBeginStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) BeginStatement() (localctx IBeginStatementContext) {
	localctx = NewBeginStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 740, DorisSQLParserRULE_beginStatement)
	var _la int

	p.SetState(5885)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserSTART:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5874)
			p.Match(DorisSQLParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5875)
			p.Match(DorisSQLParserTRANSACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5879)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserWITH {
			{
				p.SetState(5876)
				p.Match(DorisSQLParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5877)
				p.Match(DorisSQLParserCONSISTENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5878)
				p.Match(DorisSQLParserSNAPSHOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DorisSQLParserBEGIN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5881)
			p.Match(DorisSQLParserBEGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5883)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserWORK {
			{
				p.SetState(5882)
				p.Match(DorisSQLParserWORK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommitStatementContext is an interface to support dynamic dispatch.
type ICommitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMIT() antlr.TerminalNode
	WORK() antlr.TerminalNode
	AND() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	RELEASE() antlr.TerminalNode
	AllNO() []antlr.TerminalNode
	NO(i int) antlr.TerminalNode

	// IsCommitStatementContext differentiates from other interfaces.
	IsCommitStatementContext()
}

type CommitStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommitStatementContext() *CommitStatementContext {
	var p = new(CommitStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_commitStatement
	return p
}

func InitEmptyCommitStatementContext(p *CommitStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_commitStatement
}

func (*CommitStatementContext) IsCommitStatementContext() {}

func NewCommitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommitStatementContext {
	var p = new(CommitStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_commitStatement

	return p
}

func (s *CommitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CommitStatementContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOMMIT, 0)
}

func (s *CommitStatementContext) WORK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWORK, 0)
}

func (s *CommitStatementContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAND, 0)
}

func (s *CommitStatementContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCHAIN, 0)
}

func (s *CommitStatementContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRELEASE, 0)
}

func (s *CommitStatementContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserNO)
}

func (s *CommitStatementContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNO, i)
}

func (s *CommitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCommitStatement(s)
	}
}

func (s *CommitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCommitStatement(s)
	}
}

func (s *CommitStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCommitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CommitStatement() (localctx ICommitStatementContext) {
	localctx = NewCommitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 742, DorisSQLParserRULE_commitStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5887)
		p.Match(DorisSQLParserCOMMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5889)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWORK {
		{
			p.SetState(5888)
			p.Match(DorisSQLParserWORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5896)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserAND {
		{
			p.SetState(5891)
			p.Match(DorisSQLParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5893)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserNO {
			{
				p.SetState(5892)
				p.Match(DorisSQLParserNO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5895)
			p.Match(DorisSQLParserCHAIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5902)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserNO || _la == DorisSQLParserRELEASE {
		p.SetState(5899)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserNO {
			{
				p.SetState(5898)
				p.Match(DorisSQLParserNO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5901)
			p.Match(DorisSQLParserRELEASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollbackStatementContext is an interface to support dynamic dispatch.
type IRollbackStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLLBACK() antlr.TerminalNode
	WORK() antlr.TerminalNode
	AND() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	RELEASE() antlr.TerminalNode
	AllNO() []antlr.TerminalNode
	NO(i int) antlr.TerminalNode

	// IsRollbackStatementContext differentiates from other interfaces.
	IsRollbackStatementContext()
}

type RollbackStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollbackStatementContext() *RollbackStatementContext {
	var p = new(RollbackStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_rollbackStatement
	return p
}

func InitEmptyRollbackStatementContext(p *RollbackStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_rollbackStatement
}

func (*RollbackStatementContext) IsRollbackStatementContext() {}

func NewRollbackStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollbackStatementContext {
	var p = new(RollbackStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_rollbackStatement

	return p
}

func (s *RollbackStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RollbackStatementContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROLLBACK, 0)
}

func (s *RollbackStatementContext) WORK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWORK, 0)
}

func (s *RollbackStatementContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAND, 0)
}

func (s *RollbackStatementContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCHAIN, 0)
}

func (s *RollbackStatementContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRELEASE, 0)
}

func (s *RollbackStatementContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserNO)
}

func (s *RollbackStatementContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNO, i)
}

func (s *RollbackStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollbackStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollbackStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRollbackStatement(s)
	}
}

func (s *RollbackStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRollbackStatement(s)
	}
}

func (s *RollbackStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRollbackStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) RollbackStatement() (localctx IRollbackStatementContext) {
	localctx = NewRollbackStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 744, DorisSQLParserRULE_rollbackStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5904)
		p.Match(DorisSQLParserROLLBACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5906)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWORK {
		{
			p.SetState(5905)
			p.Match(DorisSQLParserWORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5913)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserAND {
		{
			p.SetState(5908)
			p.Match(DorisSQLParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5910)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserNO {
			{
				p.SetState(5909)
				p.Match(DorisSQLParserNO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5912)
			p.Match(DorisSQLParserCHAIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5919)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserNO || _la == DorisSQLParserRELEASE {
		p.SetState(5916)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserNO {
			{
				p.SetState(5915)
				p.Match(DorisSQLParserNO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5918)
			p.Match(DorisSQLParserRELEASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITranslateStatementContext is an interface to support dynamic dispatch.
type ITranslateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRANSLATE() antlr.TerminalNode
	Dialect() IDialectContext
	TranslateSQL() ITranslateSQLContext

	// IsTranslateStatementContext differentiates from other interfaces.
	IsTranslateStatementContext()
}

type TranslateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTranslateStatementContext() *TranslateStatementContext {
	var p = new(TranslateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_translateStatement
	return p
}

func InitEmptyTranslateStatementContext(p *TranslateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_translateStatement
}

func (*TranslateStatementContext) IsTranslateStatementContext() {}

func NewTranslateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TranslateStatementContext {
	var p = new(TranslateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_translateStatement

	return p
}

func (s *TranslateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TranslateStatementContext) TRANSLATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTRANSLATE, 0)
}

func (s *TranslateStatementContext) Dialect() IDialectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDialectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDialectContext)
}

func (s *TranslateStatementContext) TranslateSQL() ITranslateSQLContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITranslateSQLContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITranslateSQLContext)
}

func (s *TranslateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TranslateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TranslateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTranslateStatement(s)
	}
}

func (s *TranslateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTranslateStatement(s)
	}
}

func (s *TranslateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTranslateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) TranslateStatement() (localctx ITranslateStatementContext) {
	localctx = NewTranslateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 746, DorisSQLParserRULE_translateStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5921)
		p.Match(DorisSQLParserTRANSLATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5922)
		p.Dialect()
	}
	{
		p.SetState(5923)
		p.TranslateSQL()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDialectContext is an interface to support dynamic dispatch.
type IDialectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsDialectContext differentiates from other interfaces.
	IsDialectContext()
}

type DialectContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDialectContext() *DialectContext {
	var p = new(DialectContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dialect
	return p
}

func InitEmptyDialectContext(p *DialectContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_dialect
}

func (*DialectContext) IsDialectContext() {}

func NewDialectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DialectContext {
	var p = new(DialectContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_dialect

	return p
}

func (s *DialectContext) GetParser() antlr.Parser { return s.parser }

func (s *DialectContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DialectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DialectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DialectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDialect(s)
	}
}

func (s *DialectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDialect(s)
	}
}

func (s *DialectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDialect(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Dialect() (localctx IDialectContext) {
	localctx = NewDialectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 748, DorisSQLParserRULE_dialect)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5925)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITranslateSQLContext is an interface to support dynamic dispatch.
type ITranslateSQLContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTranslateSQLContext differentiates from other interfaces.
	IsTranslateSQLContext()
}

type TranslateSQLContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTranslateSQLContext() *TranslateSQLContext {
	var p = new(TranslateSQLContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_translateSQL
	return p
}

func InitEmptyTranslateSQLContext(p *TranslateSQLContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_translateSQL
}

func (*TranslateSQLContext) IsTranslateSQLContext() {}

func NewTranslateSQLContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TranslateSQLContext {
	var p = new(TranslateSQLContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_translateSQL

	return p
}

func (s *TranslateSQLContext) GetParser() antlr.Parser { return s.parser }
func (s *TranslateSQLContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TranslateSQLContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TranslateSQLContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTranslateSQL(s)
	}
}

func (s *TranslateSQLContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTranslateSQL(s)
	}
}

func (s *TranslateSQLContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTranslateSQL(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) TranslateSQL() (localctx ITranslateSQLContext) {
	localctx = NewTranslateSQLContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 750, DorisSQLParserRULE_translateSQL)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5928)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(5927)
			p.MatchWildcard()

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(5930)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 654, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryStatementContext is an interface to support dynamic dispatch.
type IQueryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryRelation() IQueryRelationContext
	ExplainDesc() IExplainDescContext
	OptimizerTrace() IOptimizerTraceContext
	Outfile() IOutfileContext

	// IsQueryStatementContext differentiates from other interfaces.
	IsQueryStatementContext()
}

type QueryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryStatementContext() *QueryStatementContext {
	var p = new(QueryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_queryStatement
	return p
}

func InitEmptyQueryStatementContext(p *QueryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_queryStatement
}

func (*QueryStatementContext) IsQueryStatementContext() {}

func NewQueryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryStatementContext {
	var p = new(QueryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_queryStatement

	return p
}

func (s *QueryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryStatementContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *QueryStatementContext) ExplainDesc() IExplainDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainDescContext)
}

func (s *QueryStatementContext) OptimizerTrace() IOptimizerTraceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptimizerTraceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptimizerTraceContext)
}

func (s *QueryStatementContext) Outfile() IOutfileContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOutfileContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOutfileContext)
}

func (s *QueryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterQueryStatement(s)
	}
}

func (s *QueryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitQueryStatement(s)
	}
}

func (s *QueryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitQueryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) QueryStatement() (localctx IQueryStatementContext) {
	localctx = NewQueryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 752, DorisSQLParserRULE_queryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5934)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserDESC, DorisSQLParserDESCRIBE, DorisSQLParserEXPLAIN:
		{
			p.SetState(5932)
			p.ExplainDesc()
		}

	case DorisSQLParserTRACE:
		{
			p.SetState(5933)
			p.OptimizerTrace()
		}

	case DorisSQLParserT__1, DorisSQLParserSELECT, DorisSQLParserWITH:

	default:
	}
	{
		p.SetState(5936)
		p.QueryRelation()
	}
	p.SetState(5938)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserINTO {
		{
			p.SetState(5937)
			p.Outfile()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryRelationContext is an interface to support dynamic dispatch.
type IQueryRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryNoWith() IQueryNoWithContext
	WithClause() IWithClauseContext

	// IsQueryRelationContext differentiates from other interfaces.
	IsQueryRelationContext()
}

type QueryRelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryRelationContext() *QueryRelationContext {
	var p = new(QueryRelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_queryRelation
	return p
}

func InitEmptyQueryRelationContext(p *QueryRelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_queryRelation
}

func (*QueryRelationContext) IsQueryRelationContext() {}

func NewQueryRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryRelationContext {
	var p = new(QueryRelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_queryRelation

	return p
}

func (s *QueryRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryRelationContext) QueryNoWith() IQueryNoWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryNoWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryNoWithContext)
}

func (s *QueryRelationContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *QueryRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterQueryRelation(s)
	}
}

func (s *QueryRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitQueryRelation(s)
	}
}

func (s *QueryRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitQueryRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) QueryRelation() (localctx IQueryRelationContext) {
	localctx = NewQueryRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 754, DorisSQLParserRULE_queryRelation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5941)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserWITH {
		{
			p.SetState(5940)
			p.WithClause()
		}

	}
	{
		p.SetState(5943)
		p.QueryNoWith()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithClauseContext is an interface to support dynamic dispatch.
type IWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	AllCommonTableExpression() []ICommonTableExpressionContext
	CommonTableExpression(i int) ICommonTableExpressionContext

	// IsWithClauseContext differentiates from other interfaces.
	IsWithClauseContext()
}

type WithClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithClauseContext() *WithClauseContext {
	var p = new(WithClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_withClause
	return p
}

func InitEmptyWithClauseContext(p *WithClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_withClause
}

func (*WithClauseContext) IsWithClauseContext() {}

func NewWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithClauseContext {
	var p = new(WithClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_withClause

	return p
}

func (s *WithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWITH, 0)
}

func (s *WithClauseContext) AllCommonTableExpression() []ICommonTableExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommonTableExpressionContext); ok {
			len++
		}
	}

	tst := make([]ICommonTableExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommonTableExpressionContext); ok {
			tst[i] = t.(ICommonTableExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WithClauseContext) CommonTableExpression(i int) ICommonTableExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommonTableExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommonTableExpressionContext)
}

func (s *WithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterWithClause(s)
	}
}

func (s *WithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitWithClause(s)
	}
}

func (s *WithClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitWithClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) WithClause() (localctx IWithClauseContext) {
	localctx = NewWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 756, DorisSQLParserRULE_withClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5945)
		p.Match(DorisSQLParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5946)
		p.CommonTableExpression()
	}
	p.SetState(5951)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(5947)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5948)
			p.CommonTableExpression()
		}

		p.SetState(5953)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryNoWithContext is an interface to support dynamic dispatch.
type IQueryNoWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryPrimary() IQueryPrimaryContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext

	// IsQueryNoWithContext differentiates from other interfaces.
	IsQueryNoWithContext()
}

type QueryNoWithContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryNoWithContext() *QueryNoWithContext {
	var p = new(QueryNoWithContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_queryNoWith
	return p
}

func InitEmptyQueryNoWithContext(p *QueryNoWithContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_queryNoWith
}

func (*QueryNoWithContext) IsQueryNoWithContext() {}

func NewQueryNoWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryNoWithContext {
	var p = new(QueryNoWithContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_queryNoWith

	return p
}

func (s *QueryNoWithContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryNoWithContext) QueryPrimary() IQueryPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryPrimaryContext)
}

func (s *QueryNoWithContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserORDER, 0)
}

func (s *QueryNoWithContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *QueryNoWithContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *QueryNoWithContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *QueryNoWithContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *QueryNoWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryNoWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryNoWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterQueryNoWith(s)
	}
}

func (s *QueryNoWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitQueryNoWith(s)
	}
}

func (s *QueryNoWithContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitQueryNoWith(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) QueryNoWith() (localctx IQueryNoWithContext) {
	localctx = NewQueryNoWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 758, DorisSQLParserRULE_queryNoWith)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5954)
		p.queryPrimary(0)
	}
	p.SetState(5965)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserORDER {
		{
			p.SetState(5955)
			p.Match(DorisSQLParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5956)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5957)
			p.SortItem()
		}
		p.SetState(5962)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(5958)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5959)
				p.SortItem()
			}

			p.SetState(5964)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(5968)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserLIMIT {
		{
			p.SetState(5967)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryPeriodContext is an interface to support dynamic dispatch.
type IQueryPeriodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetEnd returns the end rule contexts.
	GetEnd() IExpressionContext

	// SetEnd sets the end rule contexts.
	SetEnd(IExpressionContext)

	// Getter signatures
	PeriodType() IPeriodTypeContext
	BETWEEN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AND() antlr.TerminalNode
	FOR() antlr.TerminalNode
	FROM() antlr.TerminalNode
	TO() antlr.TerminalNode
	ALL() antlr.TerminalNode
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode

	// IsQueryPeriodContext differentiates from other interfaces.
	IsQueryPeriodContext()
}

type QueryPeriodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	end    IExpressionContext
}

func NewEmptyQueryPeriodContext() *QueryPeriodContext {
	var p = new(QueryPeriodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_queryPeriod
	return p
}

func InitEmptyQueryPeriodContext(p *QueryPeriodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_queryPeriod
}

func (*QueryPeriodContext) IsQueryPeriodContext() {}

func NewQueryPeriodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryPeriodContext {
	var p = new(QueryPeriodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_queryPeriod

	return p
}

func (s *QueryPeriodContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryPeriodContext) GetEnd() IExpressionContext { return s.end }

func (s *QueryPeriodContext) SetEnd(v IExpressionContext) { s.end = v }

func (s *QueryPeriodContext) PeriodType() IPeriodTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPeriodTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPeriodTypeContext)
}

func (s *QueryPeriodContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBETWEEN, 0)
}

func (s *QueryPeriodContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *QueryPeriodContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *QueryPeriodContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAND, 0)
}

func (s *QueryPeriodContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFOR, 0)
}

func (s *QueryPeriodContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *QueryPeriodContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTO, 0)
}

func (s *QueryPeriodContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, 0)
}

func (s *QueryPeriodContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *QueryPeriodContext) OF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOF, 0)
}

func (s *QueryPeriodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPeriodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryPeriodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterQueryPeriod(s)
	}
}

func (s *QueryPeriodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitQueryPeriod(s)
	}
}

func (s *QueryPeriodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitQueryPeriod(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) QueryPeriod() (localctx IQueryPeriodContext) {
	localctx = NewQueryPeriodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 760, DorisSQLParserRULE_queryPeriod)
	var _la int

	p.SetState(6002)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 666, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5971)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserFOR {
			{
				p.SetState(5970)
				p.Match(DorisSQLParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5973)
			p.PeriodType()
		}
		{
			p.SetState(5974)
			p.Match(DorisSQLParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5975)
			p.expression(0)
		}
		{
			p.SetState(5976)
			p.Match(DorisSQLParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5977)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5980)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserFOR {
			{
				p.SetState(5979)
				p.Match(DorisSQLParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5982)
			p.PeriodType()
		}
		{
			p.SetState(5983)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5984)
			p.expression(0)
		}
		{
			p.SetState(5985)
			p.Match(DorisSQLParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5986)
			p.expression(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(5989)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserFOR {
			{
				p.SetState(5988)
				p.Match(DorisSQLParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5991)
			p.PeriodType()
		}
		{
			p.SetState(5992)
			p.Match(DorisSQLParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(5995)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserFOR {
			{
				p.SetState(5994)
				p.Match(DorisSQLParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5997)
			p.PeriodType()
		}
		{
			p.SetState(5998)
			p.Match(DorisSQLParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5999)
			p.Match(DorisSQLParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6000)

			var _x = p.expression(0)

			localctx.(*QueryPeriodContext).end = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPeriodTypeContext is an interface to support dynamic dispatch.
type IPeriodTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SYSTEM_TIME() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	VERSION() antlr.TerminalNode

	// IsPeriodTypeContext differentiates from other interfaces.
	IsPeriodTypeContext()
}

type PeriodTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPeriodTypeContext() *PeriodTypeContext {
	var p = new(PeriodTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_periodType
	return p
}

func InitEmptyPeriodTypeContext(p *PeriodTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_periodType
}

func (*PeriodTypeContext) IsPeriodTypeContext() {}

func NewPeriodTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PeriodTypeContext {
	var p = new(PeriodTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_periodType

	return p
}

func (s *PeriodTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PeriodTypeContext) SYSTEM_TIME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSYSTEM_TIME, 0)
}

func (s *PeriodTypeContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTIMESTAMP, 0)
}

func (s *PeriodTypeContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVERSION, 0)
}

func (s *PeriodTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PeriodTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PeriodTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPeriodType(s)
	}
}

func (s *PeriodTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPeriodType(s)
	}
}

func (s *PeriodTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPeriodType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PeriodType() (localctx IPeriodTypeContext) {
	localctx = NewPeriodTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 762, DorisSQLParserRULE_periodType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6004)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-419)) & ^0x3f) == 0 && ((int64(1)<<(_la-419))&562949953454081) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryPrimaryContext is an interface to support dynamic dispatch.
type IQueryPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQueryPrimaryContext differentiates from other interfaces.
	IsQueryPrimaryContext()
}

type QueryPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryPrimaryContext() *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_queryPrimary
	return p
}

func InitEmptyQueryPrimaryContext(p *QueryPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_queryPrimary
}

func (*QueryPrimaryContext) IsQueryPrimaryContext() {}

func NewQueryPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_queryPrimary

	return p
}

func (s *QueryPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryPrimaryContext) CopyAll(ctx *QueryPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QueryPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QueryWithParenthesesContext struct {
	QueryPrimaryContext
}

func NewQueryWithParenthesesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryWithParenthesesContext {
	var p = new(QueryWithParenthesesContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *QueryWithParenthesesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryWithParenthesesContext) Subquery() ISubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *QueryWithParenthesesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterQueryWithParentheses(s)
	}
}

func (s *QueryWithParenthesesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitQueryWithParentheses(s)
	}
}

func (s *QueryWithParenthesesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitQueryWithParentheses(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetOperationContext struct {
	QueryPrimaryContext
	left     IQueryPrimaryContext
	operator antlr.Token
	right    IQueryPrimaryContext
}

func NewSetOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetOperationContext {
	var p = new(SetOperationContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *SetOperationContext) GetOperator() antlr.Token { return s.operator }

func (s *SetOperationContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *SetOperationContext) GetLeft() IQueryPrimaryContext { return s.left }

func (s *SetOperationContext) GetRight() IQueryPrimaryContext { return s.right }

func (s *SetOperationContext) SetLeft(v IQueryPrimaryContext) { s.left = v }

func (s *SetOperationContext) SetRight(v IQueryPrimaryContext) { s.right = v }

func (s *SetOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOperationContext) AllQueryPrimary() []IQueryPrimaryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			len++
		}
	}

	tst := make([]IQueryPrimaryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQueryPrimaryContext); ok {
			tst[i] = t.(IQueryPrimaryContext)
			i++
		}
	}

	return tst
}

func (s *SetOperationContext) QueryPrimary(i int) IQueryPrimaryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryPrimaryContext)
}

func (s *SetOperationContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTERSECT, 0)
}

func (s *SetOperationContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *SetOperationContext) UNION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUNION, 0)
}

func (s *SetOperationContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXCEPT, 0)
}

func (s *SetOperationContext) MINUS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMINUS, 0)
}

func (s *SetOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSetOperation(s)
	}
}

func (s *SetOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSetOperation(s)
	}
}

func (s *SetOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSetOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

type QueryPrimaryDefaultContext struct {
	QueryPrimaryContext
}

func NewQueryPrimaryDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryPrimaryDefaultContext {
	var p = new(QueryPrimaryDefaultContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *QueryPrimaryDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryDefaultContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *QueryPrimaryDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterQueryPrimaryDefault(s)
	}
}

func (s *QueryPrimaryDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitQueryPrimaryDefault(s)
	}
}

func (s *QueryPrimaryDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitQueryPrimaryDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) QueryPrimary() (localctx IQueryPrimaryContext) {
	return p.queryPrimary(0)
}

func (p *DorisSQLParser) queryPrimary(_p int) (localctx IQueryPrimaryContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewQueryPrimaryContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IQueryPrimaryContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 764
	p.EnterRecursionRule(localctx, 764, DorisSQLParserRULE_queryPrimary, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6009)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserSELECT:
		localctx = NewQueryPrimaryDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(6007)
			p.QuerySpecification()
		}

	case DorisSQLParserT__1:
		localctx = NewQueryWithParenthesesContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6008)
			p.Subquery()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(6025)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 671, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(6023)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 670, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSetOperationContext(p, NewQueryPrimaryContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserRULE_queryPrimary)
				p.SetState(6011)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(6012)

					var _m = p.Match(DorisSQLParserINTERSECT)

					localctx.(*SetOperationContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(6014)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisSQLParserALL || _la == DorisSQLParserDISTINCT {
					{
						p.SetState(6013)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(6016)

					var _x = p.queryPrimary(3)

					localctx.(*SetOperationContext).right = _x
				}

			case 2:
				localctx = NewSetOperationContext(p, NewQueryPrimaryContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserRULE_queryPrimary)
				p.SetState(6017)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(6018)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*SetOperationContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisSQLParserEXCEPT || _la == DorisSQLParserMINUS || _la == DorisSQLParserUNION) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*SetOperationContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(6020)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisSQLParserALL || _la == DorisSQLParserDISTINCT {
					{
						p.SetState(6019)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(6022)

					var _x = p.queryPrimary(2)

					localctx.(*SetOperationContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(6027)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 671, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubqueryContext is an interface to support dynamic dispatch.
type ISubqueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryRelation() IQueryRelationContext

	// IsSubqueryContext differentiates from other interfaces.
	IsSubqueryContext()
}

type SubqueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubqueryContext() *SubqueryContext {
	var p = new(SubqueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_subquery
	return p
}

func InitEmptySubqueryContext(p *SubqueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_subquery
}

func (*SubqueryContext) IsSubqueryContext() {}

func NewSubqueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubqueryContext {
	var p = new(SubqueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_subquery

	return p
}

func (s *SubqueryContext) GetParser() antlr.Parser { return s.parser }

func (s *SubqueryContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSubquery(s)
	}
}

func (s *SubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSubquery(s)
	}
}

func (s *SubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Subquery() (localctx ISubqueryContext) {
	localctx = NewSubqueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 766, DorisSQLParserRULE_subquery)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6028)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6029)
		p.QueryRelation()
	}
	{
		p.SetState(6030)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowConstructorContext is an interface to support dynamic dispatch.
type IRowConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionList() IExpressionListContext

	// IsRowConstructorContext differentiates from other interfaces.
	IsRowConstructorContext()
}

type RowConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowConstructorContext() *RowConstructorContext {
	var p = new(RowConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_rowConstructor
	return p
}

func InitEmptyRowConstructorContext(p *RowConstructorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_rowConstructor
}

func (*RowConstructorContext) IsRowConstructorContext() {}

func NewRowConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowConstructorContext {
	var p = new(RowConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_rowConstructor

	return p
}

func (s *RowConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *RowConstructorContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *RowConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRowConstructor(s)
	}
}

func (s *RowConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRowConstructor(s)
	}
}

func (s *RowConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRowConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) RowConstructor() (localctx IRowConstructorContext) {
	localctx = NewRowConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 768, DorisSQLParserRULE_rowConstructor)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6032)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6033)
		p.ExpressionList()
	}
	{
		p.SetState(6034)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortItemContext is an interface to support dynamic dispatch.
type ISortItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrdering returns the ordering token.
	GetOrdering() antlr.Token

	// GetNullOrdering returns the nullOrdering token.
	GetNullOrdering() antlr.Token

	// SetOrdering sets the ordering token.
	SetOrdering(antlr.Token)

	// SetNullOrdering sets the nullOrdering token.
	SetNullOrdering(antlr.Token)

	// Getter signatures
	Expression() IExpressionContext
	NULLS() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode

	// IsSortItemContext differentiates from other interfaces.
	IsSortItemContext()
}

type SortItemContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	ordering     antlr.Token
	nullOrdering antlr.Token
}

func NewEmptySortItemContext() *SortItemContext {
	var p = new(SortItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_sortItem
	return p
}

func InitEmptySortItemContext(p *SortItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_sortItem
}

func (*SortItemContext) IsSortItemContext() {}

func NewSortItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortItemContext {
	var p = new(SortItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_sortItem

	return p
}

func (s *SortItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SortItemContext) GetOrdering() antlr.Token { return s.ordering }

func (s *SortItemContext) GetNullOrdering() antlr.Token { return s.nullOrdering }

func (s *SortItemContext) SetOrdering(v antlr.Token) { s.ordering = v }

func (s *SortItemContext) SetNullOrdering(v antlr.Token) { s.nullOrdering = v }

func (s *SortItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SortItemContext) NULLS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNULLS, 0)
}

func (s *SortItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserASC, 0)
}

func (s *SortItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDESC, 0)
}

func (s *SortItemContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFIRST, 0)
}

func (s *SortItemContext) LAST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLAST, 0)
}

func (s *SortItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSortItem(s)
	}
}

func (s *SortItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSortItem(s)
	}
}

func (s *SortItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSortItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SortItem() (localctx ISortItemContext) {
	localctx = NewSortItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 770, DorisSQLParserRULE_sortItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6036)
		p.expression(0)
	}
	p.SetState(6038)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserASC || _la == DorisSQLParserDESC {
		{
			p.SetState(6037)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).ordering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserASC || _la == DorisSQLParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).ordering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(6042)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserNULLS {
		{
			p.SetState(6040)
			p.Match(DorisSQLParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6041)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).nullOrdering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserFIRST || _la == DorisSQLParserLAST) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).nullOrdering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitConstExprContext is an interface to support dynamic dispatch.
type ILimitConstExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER_VALUE() antlr.TerminalNode
	PARAMETER() antlr.TerminalNode
	UserVariable() IUserVariableContext

	// IsLimitConstExprContext differentiates from other interfaces.
	IsLimitConstExprContext()
}

type LimitConstExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitConstExprContext() *LimitConstExprContext {
	var p = new(LimitConstExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_limitConstExpr
	return p
}

func InitEmptyLimitConstExprContext(p *LimitConstExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_limitConstExpr
}

func (*LimitConstExprContext) IsLimitConstExprContext() {}

func NewLimitConstExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitConstExprContext {
	var p = new(LimitConstExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_limitConstExpr

	return p
}

func (s *LimitConstExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitConstExprContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, 0)
}

func (s *LimitConstExprContext) PARAMETER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPARAMETER, 0)
}

func (s *LimitConstExprContext) UserVariable() IUserVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariableContext)
}

func (s *LimitConstExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitConstExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitConstExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterLimitConstExpr(s)
	}
}

func (s *LimitConstExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitLimitConstExpr(s)
	}
}

func (s *LimitConstExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitLimitConstExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) LimitConstExpr() (localctx ILimitConstExprContext) {
	localctx = NewLimitConstExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 772, DorisSQLParserRULE_limitConstExpr)
	p.SetState(6047)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserINTEGER_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6044)
			p.Match(DorisSQLParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserPARAMETER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6045)
			p.Match(DorisSQLParserPARAMETER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserAT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6046)
			p.UserVariable()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitElementContext is an interface to support dynamic dispatch.
type ILimitElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit rule contexts.
	GetLimit() ILimitConstExprContext

	// GetOffset returns the offset rule contexts.
	GetOffset() ILimitConstExprContext

	// SetLimit sets the limit rule contexts.
	SetLimit(ILimitConstExprContext)

	// SetOffset sets the offset rule contexts.
	SetOffset(ILimitConstExprContext)

	// Getter signatures
	LIMIT() antlr.TerminalNode
	AllLimitConstExpr() []ILimitConstExprContext
	LimitConstExpr(i int) ILimitConstExprContext
	OFFSET() antlr.TerminalNode

	// IsLimitElementContext differentiates from other interfaces.
	IsLimitElementContext()
}

type LimitElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	limit  ILimitConstExprContext
	offset ILimitConstExprContext
}

func NewEmptyLimitElementContext() *LimitElementContext {
	var p = new(LimitElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_limitElement
	return p
}

func InitEmptyLimitElementContext(p *LimitElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_limitElement
}

func (*LimitElementContext) IsLimitElementContext() {}

func NewLimitElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitElementContext {
	var p = new(LimitElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_limitElement

	return p
}

func (s *LimitElementContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitElementContext) GetLimit() ILimitConstExprContext { return s.limit }

func (s *LimitElementContext) GetOffset() ILimitConstExprContext { return s.offset }

func (s *LimitElementContext) SetLimit(v ILimitConstExprContext) { s.limit = v }

func (s *LimitElementContext) SetOffset(v ILimitConstExprContext) { s.offset = v }

func (s *LimitElementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIMIT, 0)
}

func (s *LimitElementContext) AllLimitConstExpr() []ILimitConstExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILimitConstExprContext); ok {
			len++
		}
	}

	tst := make([]ILimitConstExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILimitConstExprContext); ok {
			tst[i] = t.(ILimitConstExprContext)
			i++
		}
	}

	return tst
}

func (s *LimitElementContext) LimitConstExpr(i int) ILimitConstExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitConstExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitConstExprContext)
}

func (s *LimitElementContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOFFSET, 0)
}

func (s *LimitElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterLimitElement(s)
	}
}

func (s *LimitElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitLimitElement(s)
	}
}

func (s *LimitElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitLimitElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) LimitElement() (localctx ILimitElementContext) {
	localctx = NewLimitElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 774, DorisSQLParserRULE_limitElement)
	var _la int

	p.SetState(6060)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 676, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6049)
			p.Match(DorisSQLParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6050)

			var _x = p.LimitConstExpr()

			localctx.(*LimitElementContext).limit = _x
		}
		p.SetState(6053)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserOFFSET {
			{
				p.SetState(6051)
				p.Match(DorisSQLParserOFFSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6052)

				var _x = p.LimitConstExpr()

				localctx.(*LimitElementContext).offset = _x
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6055)
			p.Match(DorisSQLParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6056)

			var _x = p.LimitConstExpr()

			localctx.(*LimitElementContext).offset = _x
		}
		{
			p.SetState(6057)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6058)

			var _x = p.LimitConstExpr()

			localctx.(*LimitElementContext).limit = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// GetHaving returns the having rule contexts.
	GetHaving() IExpressionContext

	// GetQualifyFunction returns the qualifyFunction rule contexts.
	GetQualifyFunction() ISelectItemContext

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// SetHaving sets the having rule contexts.
	SetHaving(IExpressionContext)

	// SetQualifyFunction sets the qualifyFunction rule contexts.
	SetQualifyFunction(ISelectItemContext)

	// Getter signatures
	SELECT() antlr.TerminalNode
	AllSelectItem() []ISelectItemContext
	SelectItem(i int) ISelectItemContext
	FromClause() IFromClauseContext
	SetQuantifier() ISetQuantifierContext
	WHERE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	GroupingElement() IGroupingElementContext
	HAVING() antlr.TerminalNode
	QUALIFY() antlr.TerminalNode
	ComparisonOperator() IComparisonOperatorContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	INTEGER_VALUE() antlr.TerminalNode

	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	where           IExpressionContext
	having          IExpressionContext
	qualifyFunction ISelectItemContext
	limit           antlr.Token
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_querySpecification
	return p
}

func InitEmptyQuerySpecificationContext(p *QuerySpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_querySpecification
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) GetLimit() antlr.Token { return s.limit }

func (s *QuerySpecificationContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *QuerySpecificationContext) GetWhere() IExpressionContext { return s.where }

func (s *QuerySpecificationContext) GetHaving() IExpressionContext { return s.having }

func (s *QuerySpecificationContext) GetQualifyFunction() ISelectItemContext { return s.qualifyFunction }

func (s *QuerySpecificationContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *QuerySpecificationContext) SetHaving(v IExpressionContext) { s.having = v }

func (s *QuerySpecificationContext) SetQualifyFunction(v ISelectItemContext) { s.qualifyFunction = v }

func (s *QuerySpecificationContext) SELECT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSELECT, 0)
}

func (s *QuerySpecificationContext) AllSelectItem() []ISelectItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectItemContext); ok {
			len++
		}
	}

	tst := make([]ISelectItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectItemContext); ok {
			tst[i] = t.(ISelectItemContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationContext) SelectItem(i int) ISelectItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectItemContext)
}

func (s *QuerySpecificationContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *QuerySpecificationContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *QuerySpecificationContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHERE, 0)
}

func (s *QuerySpecificationContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGROUP, 0)
}

func (s *QuerySpecificationContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *QuerySpecificationContext) GroupingElement() IGroupingElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingElementContext)
}

func (s *QuerySpecificationContext) HAVING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserHAVING, 0)
}

func (s *QuerySpecificationContext) QUALIFY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserQUALIFY, 0)
}

func (s *QuerySpecificationContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *QuerySpecificationContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *QuerySpecificationContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, 0)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitQuerySpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 776, DorisSQLParserRULE_querySpecification)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6062)
		p.Match(DorisSQLParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6064)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserALL || _la == DorisSQLParserDISTINCT {
		{
			p.SetState(6063)
			p.SetQuantifier()
		}

	}
	{
		p.SetState(6066)
		p.SelectItem()
	}
	p.SetState(6071)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 678, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6067)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6068)
				p.SelectItem()
			}

		}
		p.SetState(6073)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 678, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(6074)
		p.FromClause()
	}

	p.SetState(6077)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 679, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6075)
			p.Match(DorisSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6076)

			var _x = p.expression(0)

			localctx.(*QuerySpecificationContext).where = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(6082)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 680, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6079)
			p.Match(DorisSQLParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6080)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6081)
			p.GroupingElement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(6086)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 681, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6084)
			p.Match(DorisSQLParserHAVING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6085)

			var _x = p.expression(0)

			localctx.(*QuerySpecificationContext).having = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(6093)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 682, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6088)
			p.Match(DorisSQLParserQUALIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6089)

			var _x = p.SelectItem()

			localctx.(*QuerySpecificationContext).qualifyFunction = _x
		}
		{
			p.SetState(6090)
			p.ComparisonOperator()
		}
		{
			p.SetState(6091)

			var _m = p.Match(DorisSQLParserINTEGER_VALUE)

			localctx.(*QuerySpecificationContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_fromClause
	return p
}

func InitEmptyFromClauseContext(p *FromClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_fromClause
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) CopyAll(ctx *FromClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DualContext struct {
	FromClauseContext
}

func NewDualContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DualContext {
	var p = new(DualContext)

	InitEmptyFromClauseContext(&p.FromClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*FromClauseContext))

	return p
}

func (s *DualContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DualContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *DualContext) DUAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDUAL, 0)
}

func (s *DualContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDual(s)
	}
}

func (s *DualContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDual(s)
	}
}

func (s *DualContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDual(s)

	default:
		return t.VisitChildren(s)
	}
}

type FromContext struct {
	FromClauseContext
}

func NewFromContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FromContext {
	var p = new(FromContext)

	InitEmptyFromClauseContext(&p.FromClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*FromClauseContext))

	return p
}

func (s *FromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *FromContext) Relations() IRelationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationsContext)
}

func (s *FromContext) PivotClause() IPivotClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivotClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivotClauseContext)
}

func (s *FromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterFrom(s)
	}
}

func (s *FromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitFrom(s)
	}
}

func (s *FromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitFrom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) FromClause() (localctx IFromClauseContext) {
	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 778, DorisSQLParserRULE_fromClause)
	p.SetState(6104)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 685, p.GetParserRuleContext()) {
	case 1:
		localctx = NewFromContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6100)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 684, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6095)
				p.Match(DorisSQLParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6096)
				p.Relations()
			}
			p.SetState(6098)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 683, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6097)
					p.PivotClause()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewDualContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6102)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6103)
			p.Match(DorisSQLParserDUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingElementContext is an interface to support dynamic dispatch.
type IGroupingElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsGroupingElementContext differentiates from other interfaces.
	IsGroupingElementContext()
}

type GroupingElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingElementContext() *GroupingElementContext {
	var p = new(GroupingElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_groupingElement
	return p
}

func InitEmptyGroupingElementContext(p *GroupingElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_groupingElement
}

func (*GroupingElementContext) IsGroupingElementContext() {}

func NewGroupingElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingElementContext {
	var p = new(GroupingElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_groupingElement

	return p
}

func (s *GroupingElementContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingElementContext) CopyAll(ctx *GroupingElementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *GroupingElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type MultipleGroupingSetsContext struct {
	GroupingElementContext
}

func NewMultipleGroupingSetsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultipleGroupingSetsContext {
	var p = new(MultipleGroupingSetsContext)

	InitEmptyGroupingElementContext(&p.GroupingElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingElementContext))

	return p
}

func (s *MultipleGroupingSetsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleGroupingSetsContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGROUPING, 0)
}

func (s *MultipleGroupingSetsContext) SETS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSETS, 0)
}

func (s *MultipleGroupingSetsContext) AllGroupingSet() []IGroupingSetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupingSetContext); ok {
			len++
		}
	}

	tst := make([]IGroupingSetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupingSetContext); ok {
			tst[i] = t.(IGroupingSetContext)
			i++
		}
	}

	return tst
}

func (s *MultipleGroupingSetsContext) GroupingSet(i int) IGroupingSetContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingSetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *MultipleGroupingSetsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterMultipleGroupingSets(s)
	}
}

func (s *MultipleGroupingSetsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitMultipleGroupingSets(s)
	}
}

func (s *MultipleGroupingSetsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitMultipleGroupingSets(s)

	default:
		return t.VisitChildren(s)
	}
}

type SingleGroupingSetContext struct {
	GroupingElementContext
}

func NewSingleGroupingSetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SingleGroupingSetContext {
	var p = new(SingleGroupingSetContext)

	InitEmptyGroupingElementContext(&p.GroupingElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingElementContext))

	return p
}

func (s *SingleGroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleGroupingSetContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *SingleGroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSingleGroupingSet(s)
	}
}

func (s *SingleGroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSingleGroupingSet(s)
	}
}

func (s *SingleGroupingSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSingleGroupingSet(s)

	default:
		return t.VisitChildren(s)
	}
}

type CubeContext struct {
	GroupingElementContext
}

func NewCubeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CubeContext {
	var p = new(CubeContext)

	InitEmptyGroupingElementContext(&p.GroupingElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingElementContext))

	return p
}

func (s *CubeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CubeContext) CUBE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCUBE, 0)
}

func (s *CubeContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *CubeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCube(s)
	}
}

func (s *CubeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCube(s)
	}
}

func (s *CubeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCube(s)

	default:
		return t.VisitChildren(s)
	}
}

type RollupContext struct {
	GroupingElementContext
}

func NewRollupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RollupContext {
	var p = new(RollupContext)

	InitEmptyGroupingElementContext(&p.GroupingElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingElementContext))

	return p
}

func (s *RollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROLLUP, 0)
}

func (s *RollupContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *RollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRollup(s)
	}
}

func (s *RollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRollup(s)
	}
}

func (s *RollupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRollup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) GroupingElement() (localctx IGroupingElementContext) {
	localctx = NewGroupingElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 780, DorisSQLParserRULE_groupingElement)
	var _la int

	p.SetState(6132)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 689, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRollupContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6106)
			p.Match(DorisSQLParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6107)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6109)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(6108)
				p.ExpressionList()
			}

		}
		{
			p.SetState(6111)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewCubeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6112)
			p.Match(DorisSQLParserCUBE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6113)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6115)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(6114)
				p.ExpressionList()
			}

		}
		{
			p.SetState(6117)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewMultipleGroupingSetsContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6118)
			p.Match(DorisSQLParserGROUPING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6119)
			p.Match(DorisSQLParserSETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6120)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6121)
			p.GroupingSet()
		}
		p.SetState(6126)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(6122)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6123)
				p.GroupingSet()
			}

			p.SetState(6128)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6129)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewSingleGroupingSetContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6131)
			p.ExpressionList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingSetContext is an interface to support dynamic dispatch.
type IGroupingSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsGroupingSetContext differentiates from other interfaces.
	IsGroupingSetContext()
}

type GroupingSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingSetContext() *GroupingSetContext {
	var p = new(GroupingSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_groupingSet
	return p
}

func InitEmptyGroupingSetContext(p *GroupingSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_groupingSet
}

func (*GroupingSetContext) IsGroupingSetContext() {}

func NewGroupingSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingSetContext {
	var p = new(GroupingSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_groupingSet

	return p
}

func (s *GroupingSetContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingSetContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupingSetContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterGroupingSet(s)
	}
}

func (s *GroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitGroupingSet(s)
	}
}

func (s *GroupingSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitGroupingSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) GroupingSet() (localctx IGroupingSetContext) {
	localctx = NewGroupingSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 782, DorisSQLParserRULE_groupingSet)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6134)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6136)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
		{
			p.SetState(6135)
			p.expression(0)
		}

	}
	p.SetState(6142)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(6138)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6139)
			p.expression(0)
		}

		p.SetState(6144)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6145)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommonTableExpressionContext is an interface to support dynamic dispatch.
type ICommonTableExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	AS() antlr.TerminalNode
	QueryRelation() IQueryRelationContext
	Identifier() IIdentifierContext
	ColumnAliases() IColumnAliasesContext

	// IsCommonTableExpressionContext differentiates from other interfaces.
	IsCommonTableExpressionContext()
}

type CommonTableExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyCommonTableExpressionContext() *CommonTableExpressionContext {
	var p = new(CommonTableExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_commonTableExpression
	return p
}

func InitEmptyCommonTableExpressionContext(p *CommonTableExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_commonTableExpression
}

func (*CommonTableExpressionContext) IsCommonTableExpressionContext() {}

func NewCommonTableExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommonTableExpressionContext {
	var p = new(CommonTableExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_commonTableExpression

	return p
}

func (s *CommonTableExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CommonTableExpressionContext) GetName() IIdentifierContext { return s.name }

func (s *CommonTableExpressionContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CommonTableExpressionContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *CommonTableExpressionContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *CommonTableExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CommonTableExpressionContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *CommonTableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommonTableExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommonTableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCommonTableExpression(s)
	}
}

func (s *CommonTableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCommonTableExpression(s)
	}
}

func (s *CommonTableExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCommonTableExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CommonTableExpression() (localctx ICommonTableExpressionContext) {
	localctx = NewCommonTableExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 784, DorisSQLParserRULE_commonTableExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6147)

		var _x = p.Identifier()

		localctx.(*CommonTableExpressionContext).name = _x
	}
	p.SetState(6149)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserT__1 {
		{
			p.SetState(6148)
			p.ColumnAliases()
		}

	}
	{
		p.SetState(6151)
		p.Match(DorisSQLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6152)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6153)
		p.QueryRelation()
	}
	{
		p.SetState(6154)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetQuantifierContext is an interface to support dynamic dispatch.
type ISetQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTINCT() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsSetQuantifierContext differentiates from other interfaces.
	IsSetQuantifierContext()
}

type SetQuantifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetQuantifierContext() *SetQuantifierContext {
	var p = new(SetQuantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_setQuantifier
	return p
}

func InitEmptySetQuantifierContext(p *SetQuantifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_setQuantifier
}

func (*SetQuantifierContext) IsSetQuantifierContext() {}

func NewSetQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetQuantifierContext {
	var p = new(SetQuantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_setQuantifier

	return p
}

func (s *SetQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SetQuantifierContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDISTINCT, 0)
}

func (s *SetQuantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, 0)
}

func (s *SetQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSetQuantifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SetQuantifier() (localctx ISetQuantifierContext) {
	localctx = NewSetQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 786, DorisSQLParserRULE_setQuantifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6156)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserALL || _la == DorisSQLParserDISTINCT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectItemContext is an interface to support dynamic dispatch.
type ISelectItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSelectItemContext differentiates from other interfaces.
	IsSelectItemContext()
}

type SelectItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectItemContext() *SelectItemContext {
	var p = new(SelectItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_selectItem
	return p
}

func InitEmptySelectItemContext(p *SelectItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_selectItem
}

func (*SelectItemContext) IsSelectItemContext() {}

func NewSelectItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectItemContext {
	var p = new(SelectItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_selectItem

	return p
}

func (s *SelectItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectItemContext) CopyAll(ctx *SelectItemContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SelectItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectAllContext struct {
	SelectItemContext
}

func NewSelectAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectAllContext {
	var p = new(SelectAllContext)

	InitEmptySelectItemContext(&p.SelectItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectItemContext))

	return p
}

func (s *SelectAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectAllContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SelectAllContext) ASTERISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserASTERISK_SYMBOL, 0)
}

func (s *SelectAllContext) ExcludeClause() IExcludeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExcludeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExcludeClauseContext)
}

func (s *SelectAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSelectAll(s)
	}
}

func (s *SelectAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSelectAll(s)
	}
}

func (s *SelectAllContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSelectAll(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectSingleContext struct {
	SelectItemContext
}

func NewSelectSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectSingleContext {
	var p = new(SelectSingleContext)

	InitEmptySelectItemContext(&p.SelectItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectItemContext))

	return p
}

func (s *SelectSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectSingleContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectSingleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SelectSingleContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *SelectSingleContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *SelectSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSelectSingle(s)
	}
}

func (s *SelectSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSelectSingle(s)
	}
}

func (s *SelectSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSelectSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SelectItem() (localctx ISelectItemContext) {
	localctx = NewSelectItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 788, DorisSQLParserRULE_selectItem)
	var _la int

	p.SetState(6178)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 698, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6158)
			p.expression(0)
		}
		p.SetState(6166)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 695, p.GetParserRuleContext()) == 1 {
			p.SetState(6160)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserAS {
				{
					p.SetState(6159)
					p.Match(DorisSQLParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(6164)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisSQLParserACCESS, DorisSQLParserACTIVE, DorisSQLParserADMIN, DorisSQLParserADVISOR, DorisSQLParserAFTER, DorisSQLParserAGGREGATE, DorisSQLParserANTI, DorisSQLParserAPPLY, DorisSQLParserARRAY_AGG, DorisSQLParserARRAY_AGG_DISTINCT, DorisSQLParserASYNC, DorisSQLParserAUTHORS, DorisSQLParserAUTHENTICATION, DorisSQLParserAUTOMATED, DorisSQLParserAUTO_INCREMENT, DorisSQLParserAVG, DorisSQLParserBACKEND, DorisSQLParserBACKENDS, DorisSQLParserBACKUP, DorisSQLParserBASE, DorisSQLParserBASELINE, DorisSQLParserBEGIN, DorisSQLParserBINARY, DorisSQLParserBITMAP_UNION, DorisSQLParserBLACKHOLE, DorisSQLParserBLACKLIST, DorisSQLParserBODY, DorisSQLParserBOOLEAN, DorisSQLParserBRANCH, DorisSQLParserBROKER, DorisSQLParserBUCKETS, DorisSQLParserBUILTIN, DorisSQLParserCACHE, DorisSQLParserCANCEL, DorisSQLParserCAST, DorisSQLParserCATALOG, DorisSQLParserCATALOGS, DorisSQLParserCEIL, DorisSQLParserCHAIN, DorisSQLParserCHARSET, DorisSQLParserCLEAN, DorisSQLParserCLEAR, DorisSQLParserCLUSTER, DorisSQLParserCLUSTERS, DorisSQLParserCNGROUP, DorisSQLParserCNGROUPS, DorisSQLParserCOLLATION, DorisSQLParserCOLUMNS, DorisSQLParserCOMMENT, DorisSQLParserCOMMIT, DorisSQLParserCOMMITTED, DorisSQLParserCOMPACT, DorisSQLParserCOMPUTE, DorisSQLParserCONFIG, DorisSQLParserCONNECTION, DorisSQLParserCONSISTENT, DorisSQLParserCOSTS, DorisSQLParserCOUNT, DorisSQLParserCUME_DIST, DorisSQLParserCUMULATIVE, DorisSQLParserCURRENT, DorisSQLParserDATA, DorisSQLParserDATACACHE, DorisSQLParserDATE, DorisSQLParserDATETIME, DorisSQLParserDAY, DorisSQLParserDAYS, DorisSQLParserDEALLOCATE, DorisSQLParserDECOMMISSION, DorisSQLParserDIALECT, DorisSQLParserDICTIONARY, DorisSQLParserDICTIONARY_GET, DorisSQLParserDISABLE, DorisSQLParserDISTRIBUTED, DorisSQLParserDISTRIBUTION, DorisSQLParserDUPLICATE, DorisSQLParserDYNAMIC, DorisSQLParserENABLE, DorisSQLParserENCLOSE, DorisSQLParserEND, DorisSQLParserENGINE, DorisSQLParserENGINES, DorisSQLParserERRORS, DorisSQLParserESCAPE, DorisSQLParserEVENTS, DorisSQLParserEXCEPT, DorisSQLParserEXCLUDE, DorisSQLParserEXECUTE, DorisSQLParserEXPORT, DorisSQLParserEXTERNAL, DorisSQLParserEXTRACT, DorisSQLParserEVERY, DorisSQLParserFAILPOINT, DorisSQLParserFAILPOINTS, DorisSQLParserFIELDS, DorisSQLParserFILE, DorisSQLParserFILTER, DorisSQLParserFIRST, DorisSQLParserFLOOR, DorisSQLParserFN, DorisSQLParserFOLLOWING, DorisSQLParserFOLLOWER, DorisSQLParserFORMAT, DorisSQLParserFREE, DorisSQLParserFRONTEND, DorisSQLParserFRONTENDS, DorisSQLParserFUNCTIONS, DorisSQLParserGLOBAL, DorisSQLParserGRANTS, DorisSQLParserGROUP_CONCAT, DorisSQLParserHASH, DorisSQLParserHELP, DorisSQLParserHISTOGRAM, DorisSQLParserHLL_UNION, DorisSQLParserHOST, DorisSQLParserHOUR, DorisSQLParserHOURS, DorisSQLParserHUB, DorisSQLParserIDENTIFIED, DorisSQLParserIMPERSONATE, DorisSQLParserIMAGE, DorisSQLParserINACTIVE, DorisSQLParserINCREMENTAL, DorisSQLParserINDEXES, DorisSQLParserINSTALL, DorisSQLParserINTEGRATION, DorisSQLParserINTEGRATIONS, DorisSQLParserINTERMEDIATE, DorisSQLParserINTERVAL, DorisSQLParserOVERWRITE, DorisSQLParserISOLATION, DorisSQLParserJOB, DorisSQLParserLABEL, DorisSQLParserLAST, DorisSQLParserLESS, DorisSQLParserLEVEL, DorisSQLParserLIST, DorisSQLParserLOCAL, DorisSQLParserLOCATION, DorisSQLParserLOCATIONS, DorisSQLParserLOGS, DorisSQLParserLOGICAL, DorisSQLParserMANUAL, DorisSQLParserMAP, DorisSQLParserMAPPING, DorisSQLParserMAPPINGS, DorisSQLParserMASKING, DorisSQLParserMATCH, DorisSQLParserMATERIALIZED, DorisSQLParserMAX, DorisSQLParserMERGE, DorisSQLParserMIN, DorisSQLParserMINUTE, DorisSQLParserMINUTES, DorisSQLParserMINUS, DorisSQLParserMETA, DorisSQLParserMODE, DorisSQLParserMODIFY, DorisSQLParserMONTH, DorisSQLParserMULTIPLE, DorisSQLParserNAME, DorisSQLParserNAMES, DorisSQLParserNEGATIVE, DorisSQLParserNGRAMBF, DorisSQLParserNO, DorisSQLParserNODE, DorisSQLParserNODES, DorisSQLParserNONE, DorisSQLParserNULLS, DorisSQLParserNUMBER, DorisSQLParserNUMERIC, DorisSQLParserOBSERVER, DorisSQLParserOF, DorisSQLParserOFF, DorisSQLParserOFFSET, DorisSQLParserONLY, DorisSQLParserOPEN, DorisSQLParserOPERATE, DorisSQLParserOPTIMIZER, DorisSQLParserOPTION, DorisSQLParserPARTITIONS, DorisSQLParserPASSWORD, DorisSQLParserPATH, DorisSQLParserPAUSE, DorisSQLParserPENDING, DorisSQLParserPERCENT_RANK, DorisSQLParserPERCENTILE_UNION, DorisSQLParserPLAN, DorisSQLParserPLUGIN, DorisSQLParserPLUGINS, DorisSQLParserPIPE, DorisSQLParserPIPES, DorisSQLParserPIVOT, DorisSQLParserPOLICY, DorisSQLParserPOLICIES, DorisSQLParserPRECEDING, DorisSQLParserPREDICATE, DorisSQLParserPRIORITY, DorisSQLParserPRIVILEGES, DorisSQLParserPROBABILITY, DorisSQLParserPROC, DorisSQLParserPROCESSLIST, DorisSQLParserPROFILE, DorisSQLParserPROFILELIST, DorisSQLParserPROPERTIES, DorisSQLParserPROPERTY, DorisSQLParserPROVIDER, DorisSQLParserPROVIDERS, DorisSQLParserQUALIFY, DorisSQLParserQUARTER, DorisSQLParserQUERY, DorisSQLParserQUERIES, DorisSQLParserQUEUE, DorisSQLParserQUOTA, DorisSQLParserRANDOM, DorisSQLParserRANK, DorisSQLParserREASON, DorisSQLParserRECOVER, DorisSQLParserREFRESH, DorisSQLParserREWRITE, DorisSQLParserREMOVE, DorisSQLParserREPAIR, DorisSQLParserREPEATABLE, DorisSQLParserREPLACE_IF_NOT_NULL, DorisSQLParserREPLICA, DorisSQLParserREPOSITORY, DorisSQLParserREPOSITORIES, DorisSQLParserRESOURCE, DorisSQLParserRESOURCES, DorisSQLParserRESTORE, DorisSQLParserRESUME, DorisSQLParserRETAIN, DorisSQLParserRETENTION, DorisSQLParserRETURNS, DorisSQLParserRETRY, DorisSQLParserREVERT, DorisSQLParserROLE, DorisSQLParserROLES, DorisSQLParserROLLBACK, DorisSQLParserROLLUP, DorisSQLParserROUTINE, DorisSQLParserROW, DorisSQLParserRULE, DorisSQLParserRULES, DorisSQLParserRUNNING, DorisSQLParserSAMPLE, DorisSQLParserSCHEDULE, DorisSQLParserSCHEDULER, DorisSQLParserSECOND, DorisSQLParserSECURITY, DorisSQLParserSEMI, DorisSQLParserSEPARATOR, DorisSQLParserSERIALIZABLE, DorisSQLParserSESSION, DorisSQLParserSETS, DorisSQLParserSIGNED, DorisSQLParserSKIP_HEADER, DorisSQLParserSNAPSHOT, DorisSQLParserSNAPSHOTS, DorisSQLParserSQLBLACKLIST, DorisSQLParserSTART, DorisSQLParserSTATS, DorisSQLParserSTATUS, DorisSQLParserSTOP, DorisSQLParserSTORAGE, DorisSQLParserSTREAM, DorisSQLParserSTRING, DorisSQLParserSUBMIT, DorisSQLParserSUM, DorisSQLParserSUSPEND, DorisSQLParserSYNC, DorisSQLParserSYSTEM_TIME, DorisSQLParserSWAP, DorisSQLParserSTRUCT, DorisSQLParserTABLES, DorisSQLParserTABLET, DorisSQLParserTABLETS, DorisSQLParserTAG, DorisSQLParserTASK, DorisSQLParserTEMPORARY, DorisSQLParserTHAN, DorisSQLParserTIME, DorisSQLParserTIMES, DorisSQLParserTIMESTAMP, DorisSQLParserTIMESTAMPADD, DorisSQLParserTIMESTAMPDIFF, DorisSQLParserTRANSACTION, DorisSQLParserTRANSLATE, DorisSQLParserTRACE, DorisSQLParserTRIGGERS, DorisSQLParserTRIM_SPACE, DorisSQLParserTRUNCATE, DorisSQLParserTYPE, DorisSQLParserTYPES, DorisSQLParserUNBOUNDED, DorisSQLParserUNCOMMITTED, DorisSQLParserUNINSTALL, DorisSQLParserUNSET, DorisSQLParserUSAGE, DorisSQLParserUSER, DorisSQLParserUSERS, DorisSQLParserVALUE, DorisSQLParserVARBINARY, DorisSQLParserVARIABLES, DorisSQLParserVECTOR, DorisSQLParserVERBOSE, DorisSQLParserVERSION, DorisSQLParserVIEW, DorisSQLParserVIEWS, DorisSQLParserVOLUME, DorisSQLParserVOLUMES, DorisSQLParserWAREHOUSE, DorisSQLParserWAREHOUSES, DorisSQLParserWARNINGS, DorisSQLParserWEEK, DorisSQLParserWHITELIST, DorisSQLParserWORK, DorisSQLParserWRITE, DorisSQLParserYEAR, DorisSQLParserLOCK, DorisSQLParserUNLOCK, DorisSQLParserLOW_PRIORITY, DorisSQLParserDISK, DorisSQLParserBEFORE, DorisSQLParserFIELD, DorisSQLParserPERSISTENT, DorisSQLParserARRAY_ELEMENT, DorisSQLParserLETTER_IDENTIFIER, DorisSQLParserDIGIT_IDENTIFIER, DorisSQLParserBACKQUOTED_IDENTIFIER, DorisSQLParserDOTDOTDOT:
				{
					p.SetState(6162)
					p.Identifier()
				}

			case DorisSQLParserSINGLE_QUOTED_TEXT, DorisSQLParserDOUBLE_QUOTED_TEXT:
				{
					p.SetState(6163)
					p.String_()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6168)
			p.QualifiedName()
		}
		{
			p.SetState(6169)
			p.Match(DorisSQLParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6170)
			p.Match(DorisSQLParserASTERISK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6172)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 696, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6171)
				p.ExcludeClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6174)
			p.Match(DorisSQLParserASTERISK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6176)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 697, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6175)
				p.ExcludeClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExcludeClauseContext is an interface to support dynamic dispatch.
type IExcludeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	EXCEPT() antlr.TerminalNode
	EXCLUDE() antlr.TerminalNode

	// IsExcludeClauseContext differentiates from other interfaces.
	IsExcludeClauseContext()
}

type ExcludeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExcludeClauseContext() *ExcludeClauseContext {
	var p = new(ExcludeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_excludeClause
	return p
}

func InitEmptyExcludeClauseContext(p *ExcludeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_excludeClause
}

func (*ExcludeClauseContext) IsExcludeClauseContext() {}

func NewExcludeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExcludeClauseContext {
	var p = new(ExcludeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_excludeClause

	return p
}

func (s *ExcludeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ExcludeClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ExcludeClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExcludeClauseContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXCEPT, 0)
}

func (s *ExcludeClauseContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXCLUDE, 0)
}

func (s *ExcludeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExcludeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExcludeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterExcludeClause(s)
	}
}

func (s *ExcludeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitExcludeClause(s)
	}
}

func (s *ExcludeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitExcludeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ExcludeClause() (localctx IExcludeClauseContext) {
	localctx = NewExcludeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 790, DorisSQLParserRULE_excludeClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6180)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserEXCEPT || _la == DorisSQLParserEXCLUDE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6181)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6182)
		p.Identifier()
	}
	p.SetState(6187)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(6183)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6184)
			p.Identifier()
		}

		p.SetState(6189)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6190)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationsContext is an interface to support dynamic dispatch.
type IRelationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRelation() []IRelationContext
	Relation(i int) IRelationContext
	AllLATERAL() []antlr.TerminalNode
	LATERAL(i int) antlr.TerminalNode

	// IsRelationsContext differentiates from other interfaces.
	IsRelationsContext()
}

type RelationsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationsContext() *RelationsContext {
	var p = new(RelationsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_relations
	return p
}

func InitEmptyRelationsContext(p *RelationsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_relations
}

func (*RelationsContext) IsRelationsContext() {}

func NewRelationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationsContext {
	var p = new(RelationsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_relations

	return p
}

func (s *RelationsContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationsContext) AllRelation() []IRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelationContext); ok {
			len++
		}
	}

	tst := make([]IRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelationContext); ok {
			tst[i] = t.(IRelationContext)
			i++
		}
	}

	return tst
}

func (s *RelationsContext) Relation(i int) IRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *RelationsContext) AllLATERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserLATERAL)
}

func (s *RelationsContext) LATERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLATERAL, i)
}

func (s *RelationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRelations(s)
	}
}

func (s *RelationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRelations(s)
	}
}

func (s *RelationsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRelations(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Relations() (localctx IRelationsContext) {
	localctx = NewRelationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 792, DorisSQLParserRULE_relations)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6192)
		p.Relation()
	}
	p.SetState(6200)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 701, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6193)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(6195)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserLATERAL {
				{
					p.SetState(6194)
					p.Match(DorisSQLParserLATERAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6197)
				p.Relation()
			}

		}
		p.SetState(6202)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 701, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RelationPrimary() IRelationPrimaryContext
	AllJoinRelation() []IJoinRelationContext
	JoinRelation(i int) IJoinRelationContext

	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_relation
	return p
}

func InitEmptyRelationContext(p *RelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_relation
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) RelationPrimary() IRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *RelationContext) AllJoinRelation() []IJoinRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinRelationContext); ok {
			len++
		}
	}

	tst := make([]IJoinRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinRelationContext); ok {
			tst[i] = t.(IJoinRelationContext)
			i++
		}
	}

	return tst
}

func (s *RelationContext) JoinRelation(i int) IJoinRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinRelationContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRelation(s)
	}
}

func (s *RelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRelation(s)
	}
}

func (s *RelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Relation() (localctx IRelationContext) {
	localctx = NewRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 794, DorisSQLParserRULE_relation)
	var _la int

	var _alt int

	p.SetState(6220)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 704, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6203)
			p.RelationPrimary()
		}
		p.SetState(6207)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 702, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(6204)
					p.JoinRelation()
				}

			}
			p.SetState(6209)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 702, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6210)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6211)
			p.RelationPrimary()
		}
		p.SetState(6215)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserCROSS || ((int64((_la-175)) & ^0x3f) == 0 && ((int64(1)<<(_la-175))&4612811926924165121) != 0) || _la == DorisSQLParserRIGHT {
			{
				p.SetState(6212)
				p.JoinRelation()
			}

			p.SetState(6217)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6218)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationPrimaryContext is an interface to support dynamic dispatch.
type IRelationPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationPrimaryContext differentiates from other interfaces.
	IsRelationPrimaryContext()
}

type RelationPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationPrimaryContext() *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_relationPrimary
	return p
}

func InitEmptyRelationPrimaryContext(p *RelationPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_relationPrimary
}

func (*RelationPrimaryContext) IsRelationPrimaryContext() {}

func NewRelationPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_relationPrimary

	return p
}

func (s *RelationPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationPrimaryContext) CopyAll(ctx *RelationPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RelationPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryWithAliasContext struct {
	RelationPrimaryContext
	alias IIdentifierContext
}

func NewSubqueryWithAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryWithAliasContext {
	var p = new(SubqueryWithAliasContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *SubqueryWithAliasContext) GetAlias() IIdentifierContext { return s.alias }

func (s *SubqueryWithAliasContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *SubqueryWithAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryWithAliasContext) Subquery() ISubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *SubqueryWithAliasContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubqueryWithAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *SubqueryWithAliasContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *SubqueryWithAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSubqueryWithAlias(s)
	}
}

func (s *SubqueryWithAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSubqueryWithAlias(s)
	}
}

func (s *SubqueryWithAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSubqueryWithAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type NormalizedTableFunctionContext struct {
	RelationPrimaryContext
	alias IIdentifierContext
}

func NewNormalizedTableFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NormalizedTableFunctionContext {
	var p = new(NormalizedTableFunctionContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *NormalizedTableFunctionContext) GetAlias() IIdentifierContext { return s.alias }

func (s *NormalizedTableFunctionContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *NormalizedTableFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalizedTableFunctionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *NormalizedTableFunctionContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *NormalizedTableFunctionContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *NormalizedTableFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NormalizedTableFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *NormalizedTableFunctionContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *NormalizedTableFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterNormalizedTableFunction(s)
	}
}

func (s *NormalizedTableFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitNormalizedTableFunction(s)
	}
}

func (s *NormalizedTableFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitNormalizedTableFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableFunctionContext struct {
	RelationPrimaryContext
	alias IIdentifierContext
}

func NewTableFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableFunctionContext {
	var p = new(TableFunctionContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableFunctionContext) GetAlias() IIdentifierContext { return s.alias }

func (s *TableFunctionContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *TableFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableFunctionContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableFunctionContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *TableFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *TableFunctionContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *TableFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTableFunction(s)
	}
}

func (s *TableFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTableFunction(s)
	}
}

func (s *TableFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTableFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesizedRelationContext struct {
	RelationPrimaryContext
}

func NewParenthesizedRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedRelationContext {
	var p = new(ParenthesizedRelationContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *ParenthesizedRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedRelationContext) Relations() IRelationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationsContext)
}

func (s *ParenthesizedRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterParenthesizedRelation(s)
	}
}

func (s *ParenthesizedRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitParenthesizedRelation(s)
	}
}

func (s *ParenthesizedRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitParenthesizedRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

type FileTableFunctionContext struct {
	RelationPrimaryContext
	alias IIdentifierContext
}

func NewFileTableFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FileTableFunctionContext {
	var p = new(FileTableFunctionContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *FileTableFunctionContext) GetAlias() IIdentifierContext { return s.alias }

func (s *FileTableFunctionContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *FileTableFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileTableFunctionContext) FILES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFILES, 0)
}

func (s *FileTableFunctionContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *FileTableFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FileTableFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *FileTableFunctionContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *FileTableFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterFileTableFunction(s)
	}
}

func (s *FileTableFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitFileTableFunction(s)
	}
}

func (s *FileTableFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitFileTableFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableAtomContext struct {
	RelationPrimaryContext
	alias IIdentifierContext
	ts    IStringContext
}

func NewTableAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableAtomContext {
	var p = new(TableAtomContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableAtomContext) GetAlias() IIdentifierContext { return s.alias }

func (s *TableAtomContext) GetTs() IStringContext { return s.ts }

func (s *TableAtomContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *TableAtomContext) SetTs(v IStringContext) { s.ts = v }

func (s *TableAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableAtomContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableAtomContext) QueryPeriod() IQueryPeriodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryPeriodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryPeriodContext)
}

func (s *TableAtomContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *TableAtomContext) TabletList() ITabletListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabletListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabletListContext)
}

func (s *TableAtomContext) ReplicaList() IReplicaListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplicaListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplicaListContext)
}

func (s *TableAtomContext) SampleClause() ISampleClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleClauseContext)
}

func (s *TableAtomContext) BracketHint() IBracketHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBracketHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBracketHintContext)
}

func (s *TableAtomContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBEFORE, 0)
}

func (s *TableAtomContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableAtomContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *TableAtomContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *TableAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTableAtom(s)
	}
}

func (s *TableAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTableAtom(s)
	}
}

func (s *TableAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTableAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type InlineTableContext struct {
	RelationPrimaryContext
	alias IIdentifierContext
}

func NewInlineTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InlineTableContext {
	var p = new(InlineTableContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *InlineTableContext) GetAlias() IIdentifierContext { return s.alias }

func (s *InlineTableContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *InlineTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineTableContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVALUES, 0)
}

func (s *InlineTableContext) AllRowConstructor() []IRowConstructorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRowConstructorContext); ok {
			len++
		}
	}

	tst := make([]IRowConstructorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRowConstructorContext); ok {
			tst[i] = t.(IRowConstructorContext)
			i++
		}
	}

	return tst
}

func (s *InlineTableContext) RowConstructor(i int) IRowConstructorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowConstructorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowConstructorContext)
}

func (s *InlineTableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InlineTableContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *InlineTableContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *InlineTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterInlineTable(s)
	}
}

func (s *InlineTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitInlineTable(s)
	}
}

func (s *InlineTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitInlineTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) RelationPrimary() (localctx IRelationPrimaryContext) {
	localctx = NewRelationPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 796, DorisSQLParserRULE_relationPrimary)
	var _la int

	p.SetState(6325)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 730, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableAtomContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6222)
			p.QualifiedName()
		}
		p.SetState(6224)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 705, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6223)
				p.QueryPeriod()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6227)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 706, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6226)
				p.PartitionNames()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6230)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 707, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6229)
				p.TabletList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6233)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 708, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6232)
				p.ReplicaList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6236)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 709, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6235)
				p.SampleClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6242)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 711, p.GetParserRuleContext()) == 1 {
			p.SetState(6239)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserAS {
				{
					p.SetState(6238)
					p.Match(DorisSQLParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6241)

				var _x = p.Identifier()

				localctx.(*TableAtomContext).alias = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6245)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 712, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6244)
				p.BracketHint()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6249)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 713, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6247)
				p.Match(DorisSQLParserBEFORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6248)

				var _x = p.String_()

				localctx.(*TableAtomContext).ts = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewInlineTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6251)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6252)
			p.Match(DorisSQLParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6253)
			p.RowConstructor()
		}
		p.SetState(6258)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(6254)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6255)
				p.RowConstructor()
			}

			p.SetState(6260)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6261)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6269)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 717, p.GetParserRuleContext()) == 1 {
			p.SetState(6263)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserAS {
				{
					p.SetState(6262)
					p.Match(DorisSQLParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6265)

				var _x = p.Identifier()

				localctx.(*InlineTableContext).alias = _x
			}
			p.SetState(6267)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 716, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6266)
					p.ColumnAliases()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewSubqueryWithAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6271)
			p.Subquery()
		}
		p.SetState(6279)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 720, p.GetParserRuleContext()) == 1 {
			p.SetState(6273)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserAS {
				{
					p.SetState(6272)
					p.Match(DorisSQLParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6275)

				var _x = p.Identifier()

				localctx.(*SubqueryWithAliasContext).alias = _x
			}
			p.SetState(6277)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 719, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6276)
					p.ColumnAliases()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		localctx = NewTableFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6281)
			p.QualifiedName()
		}
		{
			p.SetState(6282)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6283)
			p.ExpressionList()
		}
		{
			p.SetState(6284)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6292)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 723, p.GetParserRuleContext()) == 1 {
			p.SetState(6286)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserAS {
				{
					p.SetState(6285)
					p.Match(DorisSQLParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6288)

				var _x = p.Identifier()

				localctx.(*TableFunctionContext).alias = _x
			}
			p.SetState(6290)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 722, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6289)
					p.ColumnAliases()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		localctx = NewNormalizedTableFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6294)
			p.Match(DorisSQLParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6295)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6296)
			p.QualifiedName()
		}
		{
			p.SetState(6297)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6298)
			p.ArgumentList()
		}
		{
			p.SetState(6299)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6300)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6308)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 726, p.GetParserRuleContext()) == 1 {
			p.SetState(6302)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserAS {
				{
					p.SetState(6301)
					p.Match(DorisSQLParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6304)

				var _x = p.Identifier()

				localctx.(*NormalizedTableFunctionContext).alias = _x
			}
			p.SetState(6306)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 725, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6305)
					p.ColumnAliases()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		localctx = NewFileTableFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6310)
			p.Match(DorisSQLParserFILES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6311)
			p.PropertyList()
		}
		p.SetState(6319)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 729, p.GetParserRuleContext()) == 1 {
			p.SetState(6313)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserAS {
				{
					p.SetState(6312)
					p.Match(DorisSQLParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6315)

				var _x = p.Identifier()

				localctx.(*FileTableFunctionContext).alias = _x
			}
			p.SetState(6317)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 728, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6316)
					p.ColumnAliases()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		localctx = NewParenthesizedRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6321)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6322)
			p.Relations()
		}
		{
			p.SetState(6323)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPivotClauseContext is an interface to support dynamic dispatch.
type IPivotClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PIVOT() antlr.TerminalNode
	AllPivotAggregationExpression() []IPivotAggregationExpressionContext
	PivotAggregationExpression(i int) IPivotAggregationExpressionContext
	FOR() antlr.TerminalNode
	IN() antlr.TerminalNode
	AllPivotValue() []IPivotValueContext
	PivotValue(i int) IPivotValueContext
	Identifier() IIdentifierContext
	IdentifierList() IIdentifierListContext

	// IsPivotClauseContext differentiates from other interfaces.
	IsPivotClauseContext()
}

type PivotClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivotClauseContext() *PivotClauseContext {
	var p = new(PivotClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_pivotClause
	return p
}

func InitEmptyPivotClauseContext(p *PivotClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_pivotClause
}

func (*PivotClauseContext) IsPivotClauseContext() {}

func NewPivotClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PivotClauseContext {
	var p = new(PivotClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_pivotClause

	return p
}

func (s *PivotClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PivotClauseContext) PIVOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPIVOT, 0)
}

func (s *PivotClauseContext) AllPivotAggregationExpression() []IPivotAggregationExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPivotAggregationExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPivotAggregationExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPivotAggregationExpressionContext); ok {
			tst[i] = t.(IPivotAggregationExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PivotClauseContext) PivotAggregationExpression(i int) IPivotAggregationExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivotAggregationExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivotAggregationExpressionContext)
}

func (s *PivotClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFOR, 0)
}

func (s *PivotClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *PivotClauseContext) AllPivotValue() []IPivotValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPivotValueContext); ok {
			len++
		}
	}

	tst := make([]IPivotValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPivotValueContext); ok {
			tst[i] = t.(IPivotValueContext)
			i++
		}
	}

	return tst
}

func (s *PivotClauseContext) PivotValue(i int) IPivotValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivotValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivotValueContext)
}

func (s *PivotClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PivotClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PivotClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PivotClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PivotClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPivotClause(s)
	}
}

func (s *PivotClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPivotClause(s)
	}
}

func (s *PivotClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPivotClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PivotClause() (localctx IPivotClauseContext) {
	localctx = NewPivotClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 798, DorisSQLParserRULE_pivotClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6327)
		p.Match(DorisSQLParserPIVOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6328)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6329)
		p.PivotAggregationExpression()
	}
	p.SetState(6334)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(6330)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6331)
			p.PivotAggregationExpression()
		}

		p.SetState(6336)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6337)
		p.Match(DorisSQLParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserACCESS, DorisSQLParserACTIVE, DorisSQLParserADMIN, DorisSQLParserADVISOR, DorisSQLParserAFTER, DorisSQLParserAGGREGATE, DorisSQLParserANTI, DorisSQLParserAPPLY, DorisSQLParserARRAY_AGG, DorisSQLParserARRAY_AGG_DISTINCT, DorisSQLParserASYNC, DorisSQLParserAUTHORS, DorisSQLParserAUTHENTICATION, DorisSQLParserAUTOMATED, DorisSQLParserAUTO_INCREMENT, DorisSQLParserAVG, DorisSQLParserBACKEND, DorisSQLParserBACKENDS, DorisSQLParserBACKUP, DorisSQLParserBASE, DorisSQLParserBASELINE, DorisSQLParserBEGIN, DorisSQLParserBINARY, DorisSQLParserBITMAP_UNION, DorisSQLParserBLACKHOLE, DorisSQLParserBLACKLIST, DorisSQLParserBODY, DorisSQLParserBOOLEAN, DorisSQLParserBRANCH, DorisSQLParserBROKER, DorisSQLParserBUCKETS, DorisSQLParserBUILTIN, DorisSQLParserCACHE, DorisSQLParserCANCEL, DorisSQLParserCAST, DorisSQLParserCATALOG, DorisSQLParserCATALOGS, DorisSQLParserCEIL, DorisSQLParserCHAIN, DorisSQLParserCHARSET, DorisSQLParserCLEAN, DorisSQLParserCLEAR, DorisSQLParserCLUSTER, DorisSQLParserCLUSTERS, DorisSQLParserCNGROUP, DorisSQLParserCNGROUPS, DorisSQLParserCOLLATION, DorisSQLParserCOLUMNS, DorisSQLParserCOMMENT, DorisSQLParserCOMMIT, DorisSQLParserCOMMITTED, DorisSQLParserCOMPACT, DorisSQLParserCOMPUTE, DorisSQLParserCONFIG, DorisSQLParserCONNECTION, DorisSQLParserCONSISTENT, DorisSQLParserCOSTS, DorisSQLParserCOUNT, DorisSQLParserCUME_DIST, DorisSQLParserCUMULATIVE, DorisSQLParserCURRENT, DorisSQLParserDATA, DorisSQLParserDATACACHE, DorisSQLParserDATE, DorisSQLParserDATETIME, DorisSQLParserDAY, DorisSQLParserDAYS, DorisSQLParserDEALLOCATE, DorisSQLParserDECOMMISSION, DorisSQLParserDIALECT, DorisSQLParserDICTIONARY, DorisSQLParserDICTIONARY_GET, DorisSQLParserDISABLE, DorisSQLParserDISTRIBUTED, DorisSQLParserDISTRIBUTION, DorisSQLParserDUPLICATE, DorisSQLParserDYNAMIC, DorisSQLParserENABLE, DorisSQLParserENCLOSE, DorisSQLParserEND, DorisSQLParserENGINE, DorisSQLParserENGINES, DorisSQLParserERRORS, DorisSQLParserESCAPE, DorisSQLParserEVENTS, DorisSQLParserEXCEPT, DorisSQLParserEXCLUDE, DorisSQLParserEXECUTE, DorisSQLParserEXPORT, DorisSQLParserEXTERNAL, DorisSQLParserEXTRACT, DorisSQLParserEVERY, DorisSQLParserFAILPOINT, DorisSQLParserFAILPOINTS, DorisSQLParserFIELDS, DorisSQLParserFILE, DorisSQLParserFILTER, DorisSQLParserFIRST, DorisSQLParserFLOOR, DorisSQLParserFN, DorisSQLParserFOLLOWING, DorisSQLParserFOLLOWER, DorisSQLParserFORMAT, DorisSQLParserFREE, DorisSQLParserFRONTEND, DorisSQLParserFRONTENDS, DorisSQLParserFUNCTIONS, DorisSQLParserGLOBAL, DorisSQLParserGRANTS, DorisSQLParserGROUP_CONCAT, DorisSQLParserHASH, DorisSQLParserHELP, DorisSQLParserHISTOGRAM, DorisSQLParserHLL_UNION, DorisSQLParserHOST, DorisSQLParserHOUR, DorisSQLParserHOURS, DorisSQLParserHUB, DorisSQLParserIDENTIFIED, DorisSQLParserIMPERSONATE, DorisSQLParserIMAGE, DorisSQLParserINACTIVE, DorisSQLParserINCREMENTAL, DorisSQLParserINDEXES, DorisSQLParserINSTALL, DorisSQLParserINTEGRATION, DorisSQLParserINTEGRATIONS, DorisSQLParserINTERMEDIATE, DorisSQLParserINTERVAL, DorisSQLParserOVERWRITE, DorisSQLParserISOLATION, DorisSQLParserJOB, DorisSQLParserLABEL, DorisSQLParserLAST, DorisSQLParserLESS, DorisSQLParserLEVEL, DorisSQLParserLIST, DorisSQLParserLOCAL, DorisSQLParserLOCATION, DorisSQLParserLOCATIONS, DorisSQLParserLOGS, DorisSQLParserLOGICAL, DorisSQLParserMANUAL, DorisSQLParserMAP, DorisSQLParserMAPPING, DorisSQLParserMAPPINGS, DorisSQLParserMASKING, DorisSQLParserMATCH, DorisSQLParserMATERIALIZED, DorisSQLParserMAX, DorisSQLParserMERGE, DorisSQLParserMIN, DorisSQLParserMINUTE, DorisSQLParserMINUTES, DorisSQLParserMINUS, DorisSQLParserMETA, DorisSQLParserMODE, DorisSQLParserMODIFY, DorisSQLParserMONTH, DorisSQLParserMULTIPLE, DorisSQLParserNAME, DorisSQLParserNAMES, DorisSQLParserNEGATIVE, DorisSQLParserNGRAMBF, DorisSQLParserNO, DorisSQLParserNODE, DorisSQLParserNODES, DorisSQLParserNONE, DorisSQLParserNULLS, DorisSQLParserNUMBER, DorisSQLParserNUMERIC, DorisSQLParserOBSERVER, DorisSQLParserOF, DorisSQLParserOFF, DorisSQLParserOFFSET, DorisSQLParserONLY, DorisSQLParserOPEN, DorisSQLParserOPERATE, DorisSQLParserOPTIMIZER, DorisSQLParserOPTION, DorisSQLParserPARTITIONS, DorisSQLParserPASSWORD, DorisSQLParserPATH, DorisSQLParserPAUSE, DorisSQLParserPENDING, DorisSQLParserPERCENT_RANK, DorisSQLParserPERCENTILE_UNION, DorisSQLParserPLAN, DorisSQLParserPLUGIN, DorisSQLParserPLUGINS, DorisSQLParserPIPE, DorisSQLParserPIPES, DorisSQLParserPIVOT, DorisSQLParserPOLICY, DorisSQLParserPOLICIES, DorisSQLParserPRECEDING, DorisSQLParserPREDICATE, DorisSQLParserPRIORITY, DorisSQLParserPRIVILEGES, DorisSQLParserPROBABILITY, DorisSQLParserPROC, DorisSQLParserPROCESSLIST, DorisSQLParserPROFILE, DorisSQLParserPROFILELIST, DorisSQLParserPROPERTIES, DorisSQLParserPROPERTY, DorisSQLParserPROVIDER, DorisSQLParserPROVIDERS, DorisSQLParserQUALIFY, DorisSQLParserQUARTER, DorisSQLParserQUERY, DorisSQLParserQUERIES, DorisSQLParserQUEUE, DorisSQLParserQUOTA, DorisSQLParserRANDOM, DorisSQLParserRANK, DorisSQLParserREASON, DorisSQLParserRECOVER, DorisSQLParserREFRESH, DorisSQLParserREWRITE, DorisSQLParserREMOVE, DorisSQLParserREPAIR, DorisSQLParserREPEATABLE, DorisSQLParserREPLACE_IF_NOT_NULL, DorisSQLParserREPLICA, DorisSQLParserREPOSITORY, DorisSQLParserREPOSITORIES, DorisSQLParserRESOURCE, DorisSQLParserRESOURCES, DorisSQLParserRESTORE, DorisSQLParserRESUME, DorisSQLParserRETAIN, DorisSQLParserRETENTION, DorisSQLParserRETURNS, DorisSQLParserRETRY, DorisSQLParserREVERT, DorisSQLParserROLE, DorisSQLParserROLES, DorisSQLParserROLLBACK, DorisSQLParserROLLUP, DorisSQLParserROUTINE, DorisSQLParserROW, DorisSQLParserRULE, DorisSQLParserRULES, DorisSQLParserRUNNING, DorisSQLParserSAMPLE, DorisSQLParserSCHEDULE, DorisSQLParserSCHEDULER, DorisSQLParserSECOND, DorisSQLParserSECURITY, DorisSQLParserSEMI, DorisSQLParserSEPARATOR, DorisSQLParserSERIALIZABLE, DorisSQLParserSESSION, DorisSQLParserSETS, DorisSQLParserSIGNED, DorisSQLParserSKIP_HEADER, DorisSQLParserSNAPSHOT, DorisSQLParserSNAPSHOTS, DorisSQLParserSQLBLACKLIST, DorisSQLParserSTART, DorisSQLParserSTATS, DorisSQLParserSTATUS, DorisSQLParserSTOP, DorisSQLParserSTORAGE, DorisSQLParserSTREAM, DorisSQLParserSTRING, DorisSQLParserSUBMIT, DorisSQLParserSUM, DorisSQLParserSUSPEND, DorisSQLParserSYNC, DorisSQLParserSYSTEM_TIME, DorisSQLParserSWAP, DorisSQLParserSTRUCT, DorisSQLParserTABLES, DorisSQLParserTABLET, DorisSQLParserTABLETS, DorisSQLParserTAG, DorisSQLParserTASK, DorisSQLParserTEMPORARY, DorisSQLParserTHAN, DorisSQLParserTIME, DorisSQLParserTIMES, DorisSQLParserTIMESTAMP, DorisSQLParserTIMESTAMPADD, DorisSQLParserTIMESTAMPDIFF, DorisSQLParserTRANSACTION, DorisSQLParserTRANSLATE, DorisSQLParserTRACE, DorisSQLParserTRIGGERS, DorisSQLParserTRIM_SPACE, DorisSQLParserTRUNCATE, DorisSQLParserTYPE, DorisSQLParserTYPES, DorisSQLParserUNBOUNDED, DorisSQLParserUNCOMMITTED, DorisSQLParserUNINSTALL, DorisSQLParserUNSET, DorisSQLParserUSAGE, DorisSQLParserUSER, DorisSQLParserUSERS, DorisSQLParserVALUE, DorisSQLParserVARBINARY, DorisSQLParserVARIABLES, DorisSQLParserVECTOR, DorisSQLParserVERBOSE, DorisSQLParserVERSION, DorisSQLParserVIEW, DorisSQLParserVIEWS, DorisSQLParserVOLUME, DorisSQLParserVOLUMES, DorisSQLParserWAREHOUSE, DorisSQLParserWAREHOUSES, DorisSQLParserWARNINGS, DorisSQLParserWEEK, DorisSQLParserWHITELIST, DorisSQLParserWORK, DorisSQLParserWRITE, DorisSQLParserYEAR, DorisSQLParserLOCK, DorisSQLParserUNLOCK, DorisSQLParserLOW_PRIORITY, DorisSQLParserDISK, DorisSQLParserBEFORE, DorisSQLParserFIELD, DorisSQLParserPERSISTENT, DorisSQLParserARRAY_ELEMENT, DorisSQLParserLETTER_IDENTIFIER, DorisSQLParserDIGIT_IDENTIFIER, DorisSQLParserBACKQUOTED_IDENTIFIER, DorisSQLParserDOTDOTDOT:
		{
			p.SetState(6338)
			p.Identifier()
		}

	case DorisSQLParserT__1:
		{
			p.SetState(6339)
			p.IdentifierList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(6342)
		p.Match(DorisSQLParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6343)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6344)
		p.PivotValue()
	}
	p.SetState(6349)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(6345)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6346)
			p.PivotValue()
		}

		p.SetState(6351)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6352)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6353)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPivotAggregationExpressionContext is an interface to support dynamic dispatch.
type IPivotAggregationExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionCall() IFunctionCallContext
	Identifier() IIdentifierContext
	String_() IStringContext
	AS() antlr.TerminalNode

	// IsPivotAggregationExpressionContext differentiates from other interfaces.
	IsPivotAggregationExpressionContext()
}

type PivotAggregationExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivotAggregationExpressionContext() *PivotAggregationExpressionContext {
	var p = new(PivotAggregationExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_pivotAggregationExpression
	return p
}

func InitEmptyPivotAggregationExpressionContext(p *PivotAggregationExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_pivotAggregationExpression
}

func (*PivotAggregationExpressionContext) IsPivotAggregationExpressionContext() {}

func NewPivotAggregationExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PivotAggregationExpressionContext {
	var p = new(PivotAggregationExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_pivotAggregationExpression

	return p
}

func (s *PivotAggregationExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PivotAggregationExpressionContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *PivotAggregationExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PivotAggregationExpressionContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *PivotAggregationExpressionContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *PivotAggregationExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PivotAggregationExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PivotAggregationExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPivotAggregationExpression(s)
	}
}

func (s *PivotAggregationExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPivotAggregationExpression(s)
	}
}

func (s *PivotAggregationExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPivotAggregationExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PivotAggregationExpression() (localctx IPivotAggregationExpressionContext) {
	localctx = NewPivotAggregationExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 800, DorisSQLParserRULE_pivotAggregationExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6355)
		p.FunctionCall()
	}
	p.SetState(6363)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262622484480) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-6664167256628462851) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-1331487429127569487) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&-7546427580836201) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-4573491655345179) != 0) || ((int64((_la-324)) & ^0x3f) == 0 && ((int64(1)<<(_la-324))&9114828243924942831) != 0) || ((int64((_la-389)) & ^0x3f) == 0 && ((int64(1)<<(_la-389))&-6956096606152176261) != 0) || ((int64((_la-453)) & ^0x3f) == 0 && ((int64(1)<<(_la-453))&70849595962729) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&4211) != 0) {
		p.SetState(6357)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserAS {
			{
				p.SetState(6356)
				p.Match(DorisSQLParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(6361)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserACCESS, DorisSQLParserACTIVE, DorisSQLParserADMIN, DorisSQLParserADVISOR, DorisSQLParserAFTER, DorisSQLParserAGGREGATE, DorisSQLParserANTI, DorisSQLParserAPPLY, DorisSQLParserARRAY_AGG, DorisSQLParserARRAY_AGG_DISTINCT, DorisSQLParserASYNC, DorisSQLParserAUTHORS, DorisSQLParserAUTHENTICATION, DorisSQLParserAUTOMATED, DorisSQLParserAUTO_INCREMENT, DorisSQLParserAVG, DorisSQLParserBACKEND, DorisSQLParserBACKENDS, DorisSQLParserBACKUP, DorisSQLParserBASE, DorisSQLParserBASELINE, DorisSQLParserBEGIN, DorisSQLParserBINARY, DorisSQLParserBITMAP_UNION, DorisSQLParserBLACKHOLE, DorisSQLParserBLACKLIST, DorisSQLParserBODY, DorisSQLParserBOOLEAN, DorisSQLParserBRANCH, DorisSQLParserBROKER, DorisSQLParserBUCKETS, DorisSQLParserBUILTIN, DorisSQLParserCACHE, DorisSQLParserCANCEL, DorisSQLParserCAST, DorisSQLParserCATALOG, DorisSQLParserCATALOGS, DorisSQLParserCEIL, DorisSQLParserCHAIN, DorisSQLParserCHARSET, DorisSQLParserCLEAN, DorisSQLParserCLEAR, DorisSQLParserCLUSTER, DorisSQLParserCLUSTERS, DorisSQLParserCNGROUP, DorisSQLParserCNGROUPS, DorisSQLParserCOLLATION, DorisSQLParserCOLUMNS, DorisSQLParserCOMMENT, DorisSQLParserCOMMIT, DorisSQLParserCOMMITTED, DorisSQLParserCOMPACT, DorisSQLParserCOMPUTE, DorisSQLParserCONFIG, DorisSQLParserCONNECTION, DorisSQLParserCONSISTENT, DorisSQLParserCOSTS, DorisSQLParserCOUNT, DorisSQLParserCUME_DIST, DorisSQLParserCUMULATIVE, DorisSQLParserCURRENT, DorisSQLParserDATA, DorisSQLParserDATACACHE, DorisSQLParserDATE, DorisSQLParserDATETIME, DorisSQLParserDAY, DorisSQLParserDAYS, DorisSQLParserDEALLOCATE, DorisSQLParserDECOMMISSION, DorisSQLParserDIALECT, DorisSQLParserDICTIONARY, DorisSQLParserDICTIONARY_GET, DorisSQLParserDISABLE, DorisSQLParserDISTRIBUTED, DorisSQLParserDISTRIBUTION, DorisSQLParserDUPLICATE, DorisSQLParserDYNAMIC, DorisSQLParserENABLE, DorisSQLParserENCLOSE, DorisSQLParserEND, DorisSQLParserENGINE, DorisSQLParserENGINES, DorisSQLParserERRORS, DorisSQLParserESCAPE, DorisSQLParserEVENTS, DorisSQLParserEXCEPT, DorisSQLParserEXCLUDE, DorisSQLParserEXECUTE, DorisSQLParserEXPORT, DorisSQLParserEXTERNAL, DorisSQLParserEXTRACT, DorisSQLParserEVERY, DorisSQLParserFAILPOINT, DorisSQLParserFAILPOINTS, DorisSQLParserFIELDS, DorisSQLParserFILE, DorisSQLParserFILTER, DorisSQLParserFIRST, DorisSQLParserFLOOR, DorisSQLParserFN, DorisSQLParserFOLLOWING, DorisSQLParserFOLLOWER, DorisSQLParserFORMAT, DorisSQLParserFREE, DorisSQLParserFRONTEND, DorisSQLParserFRONTENDS, DorisSQLParserFUNCTIONS, DorisSQLParserGLOBAL, DorisSQLParserGRANTS, DorisSQLParserGROUP_CONCAT, DorisSQLParserHASH, DorisSQLParserHELP, DorisSQLParserHISTOGRAM, DorisSQLParserHLL_UNION, DorisSQLParserHOST, DorisSQLParserHOUR, DorisSQLParserHOURS, DorisSQLParserHUB, DorisSQLParserIDENTIFIED, DorisSQLParserIMPERSONATE, DorisSQLParserIMAGE, DorisSQLParserINACTIVE, DorisSQLParserINCREMENTAL, DorisSQLParserINDEXES, DorisSQLParserINSTALL, DorisSQLParserINTEGRATION, DorisSQLParserINTEGRATIONS, DorisSQLParserINTERMEDIATE, DorisSQLParserINTERVAL, DorisSQLParserOVERWRITE, DorisSQLParserISOLATION, DorisSQLParserJOB, DorisSQLParserLABEL, DorisSQLParserLAST, DorisSQLParserLESS, DorisSQLParserLEVEL, DorisSQLParserLIST, DorisSQLParserLOCAL, DorisSQLParserLOCATION, DorisSQLParserLOCATIONS, DorisSQLParserLOGS, DorisSQLParserLOGICAL, DorisSQLParserMANUAL, DorisSQLParserMAP, DorisSQLParserMAPPING, DorisSQLParserMAPPINGS, DorisSQLParserMASKING, DorisSQLParserMATCH, DorisSQLParserMATERIALIZED, DorisSQLParserMAX, DorisSQLParserMERGE, DorisSQLParserMIN, DorisSQLParserMINUTE, DorisSQLParserMINUTES, DorisSQLParserMINUS, DorisSQLParserMETA, DorisSQLParserMODE, DorisSQLParserMODIFY, DorisSQLParserMONTH, DorisSQLParserMULTIPLE, DorisSQLParserNAME, DorisSQLParserNAMES, DorisSQLParserNEGATIVE, DorisSQLParserNGRAMBF, DorisSQLParserNO, DorisSQLParserNODE, DorisSQLParserNODES, DorisSQLParserNONE, DorisSQLParserNULLS, DorisSQLParserNUMBER, DorisSQLParserNUMERIC, DorisSQLParserOBSERVER, DorisSQLParserOF, DorisSQLParserOFF, DorisSQLParserOFFSET, DorisSQLParserONLY, DorisSQLParserOPEN, DorisSQLParserOPERATE, DorisSQLParserOPTIMIZER, DorisSQLParserOPTION, DorisSQLParserPARTITIONS, DorisSQLParserPASSWORD, DorisSQLParserPATH, DorisSQLParserPAUSE, DorisSQLParserPENDING, DorisSQLParserPERCENT_RANK, DorisSQLParserPERCENTILE_UNION, DorisSQLParserPLAN, DorisSQLParserPLUGIN, DorisSQLParserPLUGINS, DorisSQLParserPIPE, DorisSQLParserPIPES, DorisSQLParserPIVOT, DorisSQLParserPOLICY, DorisSQLParserPOLICIES, DorisSQLParserPRECEDING, DorisSQLParserPREDICATE, DorisSQLParserPRIORITY, DorisSQLParserPRIVILEGES, DorisSQLParserPROBABILITY, DorisSQLParserPROC, DorisSQLParserPROCESSLIST, DorisSQLParserPROFILE, DorisSQLParserPROFILELIST, DorisSQLParserPROPERTIES, DorisSQLParserPROPERTY, DorisSQLParserPROVIDER, DorisSQLParserPROVIDERS, DorisSQLParserQUALIFY, DorisSQLParserQUARTER, DorisSQLParserQUERY, DorisSQLParserQUERIES, DorisSQLParserQUEUE, DorisSQLParserQUOTA, DorisSQLParserRANDOM, DorisSQLParserRANK, DorisSQLParserREASON, DorisSQLParserRECOVER, DorisSQLParserREFRESH, DorisSQLParserREWRITE, DorisSQLParserREMOVE, DorisSQLParserREPAIR, DorisSQLParserREPEATABLE, DorisSQLParserREPLACE_IF_NOT_NULL, DorisSQLParserREPLICA, DorisSQLParserREPOSITORY, DorisSQLParserREPOSITORIES, DorisSQLParserRESOURCE, DorisSQLParserRESOURCES, DorisSQLParserRESTORE, DorisSQLParserRESUME, DorisSQLParserRETAIN, DorisSQLParserRETENTION, DorisSQLParserRETURNS, DorisSQLParserRETRY, DorisSQLParserREVERT, DorisSQLParserROLE, DorisSQLParserROLES, DorisSQLParserROLLBACK, DorisSQLParserROLLUP, DorisSQLParserROUTINE, DorisSQLParserROW, DorisSQLParserRULE, DorisSQLParserRULES, DorisSQLParserRUNNING, DorisSQLParserSAMPLE, DorisSQLParserSCHEDULE, DorisSQLParserSCHEDULER, DorisSQLParserSECOND, DorisSQLParserSECURITY, DorisSQLParserSEMI, DorisSQLParserSEPARATOR, DorisSQLParserSERIALIZABLE, DorisSQLParserSESSION, DorisSQLParserSETS, DorisSQLParserSIGNED, DorisSQLParserSKIP_HEADER, DorisSQLParserSNAPSHOT, DorisSQLParserSNAPSHOTS, DorisSQLParserSQLBLACKLIST, DorisSQLParserSTART, DorisSQLParserSTATS, DorisSQLParserSTATUS, DorisSQLParserSTOP, DorisSQLParserSTORAGE, DorisSQLParserSTREAM, DorisSQLParserSTRING, DorisSQLParserSUBMIT, DorisSQLParserSUM, DorisSQLParserSUSPEND, DorisSQLParserSYNC, DorisSQLParserSYSTEM_TIME, DorisSQLParserSWAP, DorisSQLParserSTRUCT, DorisSQLParserTABLES, DorisSQLParserTABLET, DorisSQLParserTABLETS, DorisSQLParserTAG, DorisSQLParserTASK, DorisSQLParserTEMPORARY, DorisSQLParserTHAN, DorisSQLParserTIME, DorisSQLParserTIMES, DorisSQLParserTIMESTAMP, DorisSQLParserTIMESTAMPADD, DorisSQLParserTIMESTAMPDIFF, DorisSQLParserTRANSACTION, DorisSQLParserTRANSLATE, DorisSQLParserTRACE, DorisSQLParserTRIGGERS, DorisSQLParserTRIM_SPACE, DorisSQLParserTRUNCATE, DorisSQLParserTYPE, DorisSQLParserTYPES, DorisSQLParserUNBOUNDED, DorisSQLParserUNCOMMITTED, DorisSQLParserUNINSTALL, DorisSQLParserUNSET, DorisSQLParserUSAGE, DorisSQLParserUSER, DorisSQLParserUSERS, DorisSQLParserVALUE, DorisSQLParserVARBINARY, DorisSQLParserVARIABLES, DorisSQLParserVECTOR, DorisSQLParserVERBOSE, DorisSQLParserVERSION, DorisSQLParserVIEW, DorisSQLParserVIEWS, DorisSQLParserVOLUME, DorisSQLParserVOLUMES, DorisSQLParserWAREHOUSE, DorisSQLParserWAREHOUSES, DorisSQLParserWARNINGS, DorisSQLParserWEEK, DorisSQLParserWHITELIST, DorisSQLParserWORK, DorisSQLParserWRITE, DorisSQLParserYEAR, DorisSQLParserLOCK, DorisSQLParserUNLOCK, DorisSQLParserLOW_PRIORITY, DorisSQLParserDISK, DorisSQLParserBEFORE, DorisSQLParserFIELD, DorisSQLParserPERSISTENT, DorisSQLParserARRAY_ELEMENT, DorisSQLParserLETTER_IDENTIFIER, DorisSQLParserDIGIT_IDENTIFIER, DorisSQLParserBACKQUOTED_IDENTIFIER, DorisSQLParserDOTDOTDOT:
			{
				p.SetState(6359)
				p.Identifier()
			}

		case DorisSQLParserSINGLE_QUOTED_TEXT, DorisSQLParserDOUBLE_QUOTED_TEXT:
			{
				p.SetState(6360)
				p.String_()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPivotValueContext is an interface to support dynamic dispatch.
type IPivotValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LiteralExpression() ILiteralExpressionContext
	LiteralExpressionList() ILiteralExpressionListContext
	Identifier() IIdentifierContext
	String_() IStringContext
	AS() antlr.TerminalNode

	// IsPivotValueContext differentiates from other interfaces.
	IsPivotValueContext()
}

type PivotValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivotValueContext() *PivotValueContext {
	var p = new(PivotValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_pivotValue
	return p
}

func InitEmptyPivotValueContext(p *PivotValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_pivotValue
}

func (*PivotValueContext) IsPivotValueContext() {}

func NewPivotValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PivotValueContext {
	var p = new(PivotValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_pivotValue

	return p
}

func (s *PivotValueContext) GetParser() antlr.Parser { return s.parser }

func (s *PivotValueContext) LiteralExpression() ILiteralExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionContext)
}

func (s *PivotValueContext) LiteralExpressionList() ILiteralExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionListContext)
}

func (s *PivotValueContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PivotValueContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *PivotValueContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *PivotValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PivotValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PivotValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPivotValue(s)
	}
}

func (s *PivotValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPivotValue(s)
	}
}

func (s *PivotValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPivotValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PivotValue() (localctx IPivotValueContext) {
	localctx = NewPivotValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 802, DorisSQLParserRULE_pivotValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6367)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserCEIL, DorisSQLParserDATE, DorisSQLParserDATETIME, DorisSQLParserFALSE, DorisSQLParserFLOOR, DorisSQLParserINTERVAL, DorisSQLParserNULL, DorisSQLParserPARAMETER, DorisSQLParserTRUE, DorisSQLParserINTEGER_VALUE, DorisSQLParserDECIMAL_VALUE, DorisSQLParserDOUBLE_VALUE, DorisSQLParserSINGLE_QUOTED_TEXT, DorisSQLParserDOUBLE_QUOTED_TEXT, DorisSQLParserBINARY_SINGLE_QUOTED_TEXT, DorisSQLParserBINARY_DOUBLE_QUOTED_TEXT:
		{
			p.SetState(6365)
			p.LiteralExpression()
		}

	case DorisSQLParserT__1:
		{
			p.SetState(6366)
			p.LiteralExpressionList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(6376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262622484480) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-6664167256628462851) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-1331487429127569487) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&-7546427580836201) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-4573491655345179) != 0) || ((int64((_la-324)) & ^0x3f) == 0 && ((int64(1)<<(_la-324))&9114828243924942831) != 0) || ((int64((_la-389)) & ^0x3f) == 0 && ((int64(1)<<(_la-389))&-6956096606152176261) != 0) || ((int64((_la-453)) & ^0x3f) == 0 && ((int64(1)<<(_la-453))&70849595962729) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&4211) != 0) {
		p.SetState(6370)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserAS {
			{
				p.SetState(6369)
				p.Match(DorisSQLParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(6374)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserACCESS, DorisSQLParserACTIVE, DorisSQLParserADMIN, DorisSQLParserADVISOR, DorisSQLParserAFTER, DorisSQLParserAGGREGATE, DorisSQLParserANTI, DorisSQLParserAPPLY, DorisSQLParserARRAY_AGG, DorisSQLParserARRAY_AGG_DISTINCT, DorisSQLParserASYNC, DorisSQLParserAUTHORS, DorisSQLParserAUTHENTICATION, DorisSQLParserAUTOMATED, DorisSQLParserAUTO_INCREMENT, DorisSQLParserAVG, DorisSQLParserBACKEND, DorisSQLParserBACKENDS, DorisSQLParserBACKUP, DorisSQLParserBASE, DorisSQLParserBASELINE, DorisSQLParserBEGIN, DorisSQLParserBINARY, DorisSQLParserBITMAP_UNION, DorisSQLParserBLACKHOLE, DorisSQLParserBLACKLIST, DorisSQLParserBODY, DorisSQLParserBOOLEAN, DorisSQLParserBRANCH, DorisSQLParserBROKER, DorisSQLParserBUCKETS, DorisSQLParserBUILTIN, DorisSQLParserCACHE, DorisSQLParserCANCEL, DorisSQLParserCAST, DorisSQLParserCATALOG, DorisSQLParserCATALOGS, DorisSQLParserCEIL, DorisSQLParserCHAIN, DorisSQLParserCHARSET, DorisSQLParserCLEAN, DorisSQLParserCLEAR, DorisSQLParserCLUSTER, DorisSQLParserCLUSTERS, DorisSQLParserCNGROUP, DorisSQLParserCNGROUPS, DorisSQLParserCOLLATION, DorisSQLParserCOLUMNS, DorisSQLParserCOMMENT, DorisSQLParserCOMMIT, DorisSQLParserCOMMITTED, DorisSQLParserCOMPACT, DorisSQLParserCOMPUTE, DorisSQLParserCONFIG, DorisSQLParserCONNECTION, DorisSQLParserCONSISTENT, DorisSQLParserCOSTS, DorisSQLParserCOUNT, DorisSQLParserCUME_DIST, DorisSQLParserCUMULATIVE, DorisSQLParserCURRENT, DorisSQLParserDATA, DorisSQLParserDATACACHE, DorisSQLParserDATE, DorisSQLParserDATETIME, DorisSQLParserDAY, DorisSQLParserDAYS, DorisSQLParserDEALLOCATE, DorisSQLParserDECOMMISSION, DorisSQLParserDIALECT, DorisSQLParserDICTIONARY, DorisSQLParserDICTIONARY_GET, DorisSQLParserDISABLE, DorisSQLParserDISTRIBUTED, DorisSQLParserDISTRIBUTION, DorisSQLParserDUPLICATE, DorisSQLParserDYNAMIC, DorisSQLParserENABLE, DorisSQLParserENCLOSE, DorisSQLParserEND, DorisSQLParserENGINE, DorisSQLParserENGINES, DorisSQLParserERRORS, DorisSQLParserESCAPE, DorisSQLParserEVENTS, DorisSQLParserEXCEPT, DorisSQLParserEXCLUDE, DorisSQLParserEXECUTE, DorisSQLParserEXPORT, DorisSQLParserEXTERNAL, DorisSQLParserEXTRACT, DorisSQLParserEVERY, DorisSQLParserFAILPOINT, DorisSQLParserFAILPOINTS, DorisSQLParserFIELDS, DorisSQLParserFILE, DorisSQLParserFILTER, DorisSQLParserFIRST, DorisSQLParserFLOOR, DorisSQLParserFN, DorisSQLParserFOLLOWING, DorisSQLParserFOLLOWER, DorisSQLParserFORMAT, DorisSQLParserFREE, DorisSQLParserFRONTEND, DorisSQLParserFRONTENDS, DorisSQLParserFUNCTIONS, DorisSQLParserGLOBAL, DorisSQLParserGRANTS, DorisSQLParserGROUP_CONCAT, DorisSQLParserHASH, DorisSQLParserHELP, DorisSQLParserHISTOGRAM, DorisSQLParserHLL_UNION, DorisSQLParserHOST, DorisSQLParserHOUR, DorisSQLParserHOURS, DorisSQLParserHUB, DorisSQLParserIDENTIFIED, DorisSQLParserIMPERSONATE, DorisSQLParserIMAGE, DorisSQLParserINACTIVE, DorisSQLParserINCREMENTAL, DorisSQLParserINDEXES, DorisSQLParserINSTALL, DorisSQLParserINTEGRATION, DorisSQLParserINTEGRATIONS, DorisSQLParserINTERMEDIATE, DorisSQLParserINTERVAL, DorisSQLParserOVERWRITE, DorisSQLParserISOLATION, DorisSQLParserJOB, DorisSQLParserLABEL, DorisSQLParserLAST, DorisSQLParserLESS, DorisSQLParserLEVEL, DorisSQLParserLIST, DorisSQLParserLOCAL, DorisSQLParserLOCATION, DorisSQLParserLOCATIONS, DorisSQLParserLOGS, DorisSQLParserLOGICAL, DorisSQLParserMANUAL, DorisSQLParserMAP, DorisSQLParserMAPPING, DorisSQLParserMAPPINGS, DorisSQLParserMASKING, DorisSQLParserMATCH, DorisSQLParserMATERIALIZED, DorisSQLParserMAX, DorisSQLParserMERGE, DorisSQLParserMIN, DorisSQLParserMINUTE, DorisSQLParserMINUTES, DorisSQLParserMINUS, DorisSQLParserMETA, DorisSQLParserMODE, DorisSQLParserMODIFY, DorisSQLParserMONTH, DorisSQLParserMULTIPLE, DorisSQLParserNAME, DorisSQLParserNAMES, DorisSQLParserNEGATIVE, DorisSQLParserNGRAMBF, DorisSQLParserNO, DorisSQLParserNODE, DorisSQLParserNODES, DorisSQLParserNONE, DorisSQLParserNULLS, DorisSQLParserNUMBER, DorisSQLParserNUMERIC, DorisSQLParserOBSERVER, DorisSQLParserOF, DorisSQLParserOFF, DorisSQLParserOFFSET, DorisSQLParserONLY, DorisSQLParserOPEN, DorisSQLParserOPERATE, DorisSQLParserOPTIMIZER, DorisSQLParserOPTION, DorisSQLParserPARTITIONS, DorisSQLParserPASSWORD, DorisSQLParserPATH, DorisSQLParserPAUSE, DorisSQLParserPENDING, DorisSQLParserPERCENT_RANK, DorisSQLParserPERCENTILE_UNION, DorisSQLParserPLAN, DorisSQLParserPLUGIN, DorisSQLParserPLUGINS, DorisSQLParserPIPE, DorisSQLParserPIPES, DorisSQLParserPIVOT, DorisSQLParserPOLICY, DorisSQLParserPOLICIES, DorisSQLParserPRECEDING, DorisSQLParserPREDICATE, DorisSQLParserPRIORITY, DorisSQLParserPRIVILEGES, DorisSQLParserPROBABILITY, DorisSQLParserPROC, DorisSQLParserPROCESSLIST, DorisSQLParserPROFILE, DorisSQLParserPROFILELIST, DorisSQLParserPROPERTIES, DorisSQLParserPROPERTY, DorisSQLParserPROVIDER, DorisSQLParserPROVIDERS, DorisSQLParserQUALIFY, DorisSQLParserQUARTER, DorisSQLParserQUERY, DorisSQLParserQUERIES, DorisSQLParserQUEUE, DorisSQLParserQUOTA, DorisSQLParserRANDOM, DorisSQLParserRANK, DorisSQLParserREASON, DorisSQLParserRECOVER, DorisSQLParserREFRESH, DorisSQLParserREWRITE, DorisSQLParserREMOVE, DorisSQLParserREPAIR, DorisSQLParserREPEATABLE, DorisSQLParserREPLACE_IF_NOT_NULL, DorisSQLParserREPLICA, DorisSQLParserREPOSITORY, DorisSQLParserREPOSITORIES, DorisSQLParserRESOURCE, DorisSQLParserRESOURCES, DorisSQLParserRESTORE, DorisSQLParserRESUME, DorisSQLParserRETAIN, DorisSQLParserRETENTION, DorisSQLParserRETURNS, DorisSQLParserRETRY, DorisSQLParserREVERT, DorisSQLParserROLE, DorisSQLParserROLES, DorisSQLParserROLLBACK, DorisSQLParserROLLUP, DorisSQLParserROUTINE, DorisSQLParserROW, DorisSQLParserRULE, DorisSQLParserRULES, DorisSQLParserRUNNING, DorisSQLParserSAMPLE, DorisSQLParserSCHEDULE, DorisSQLParserSCHEDULER, DorisSQLParserSECOND, DorisSQLParserSECURITY, DorisSQLParserSEMI, DorisSQLParserSEPARATOR, DorisSQLParserSERIALIZABLE, DorisSQLParserSESSION, DorisSQLParserSETS, DorisSQLParserSIGNED, DorisSQLParserSKIP_HEADER, DorisSQLParserSNAPSHOT, DorisSQLParserSNAPSHOTS, DorisSQLParserSQLBLACKLIST, DorisSQLParserSTART, DorisSQLParserSTATS, DorisSQLParserSTATUS, DorisSQLParserSTOP, DorisSQLParserSTORAGE, DorisSQLParserSTREAM, DorisSQLParserSTRING, DorisSQLParserSUBMIT, DorisSQLParserSUM, DorisSQLParserSUSPEND, DorisSQLParserSYNC, DorisSQLParserSYSTEM_TIME, DorisSQLParserSWAP, DorisSQLParserSTRUCT, DorisSQLParserTABLES, DorisSQLParserTABLET, DorisSQLParserTABLETS, DorisSQLParserTAG, DorisSQLParserTASK, DorisSQLParserTEMPORARY, DorisSQLParserTHAN, DorisSQLParserTIME, DorisSQLParserTIMES, DorisSQLParserTIMESTAMP, DorisSQLParserTIMESTAMPADD, DorisSQLParserTIMESTAMPDIFF, DorisSQLParserTRANSACTION, DorisSQLParserTRANSLATE, DorisSQLParserTRACE, DorisSQLParserTRIGGERS, DorisSQLParserTRIM_SPACE, DorisSQLParserTRUNCATE, DorisSQLParserTYPE, DorisSQLParserTYPES, DorisSQLParserUNBOUNDED, DorisSQLParserUNCOMMITTED, DorisSQLParserUNINSTALL, DorisSQLParserUNSET, DorisSQLParserUSAGE, DorisSQLParserUSER, DorisSQLParserUSERS, DorisSQLParserVALUE, DorisSQLParserVARBINARY, DorisSQLParserVARIABLES, DorisSQLParserVECTOR, DorisSQLParserVERBOSE, DorisSQLParserVERSION, DorisSQLParserVIEW, DorisSQLParserVIEWS, DorisSQLParserVOLUME, DorisSQLParserVOLUMES, DorisSQLParserWAREHOUSE, DorisSQLParserWAREHOUSES, DorisSQLParserWARNINGS, DorisSQLParserWEEK, DorisSQLParserWHITELIST, DorisSQLParserWORK, DorisSQLParserWRITE, DorisSQLParserYEAR, DorisSQLParserLOCK, DorisSQLParserUNLOCK, DorisSQLParserLOW_PRIORITY, DorisSQLParserDISK, DorisSQLParserBEFORE, DorisSQLParserFIELD, DorisSQLParserPERSISTENT, DorisSQLParserARRAY_ELEMENT, DorisSQLParserLETTER_IDENTIFIER, DorisSQLParserDIGIT_IDENTIFIER, DorisSQLParserBACKQUOTED_IDENTIFIER, DorisSQLParserDOTDOTDOT:
			{
				p.SetState(6372)
				p.Identifier()
			}

		case DorisSQLParserSINGLE_QUOTED_TEXT, DorisSQLParserDOUBLE_QUOTED_TEXT:
			{
				p.SetState(6373)
				p.String_()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampleClauseContext is an interface to support dynamic dispatch.
type ISampleClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SAMPLE() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsSampleClauseContext differentiates from other interfaces.
	IsSampleClauseContext()
}

type SampleClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampleClauseContext() *SampleClauseContext {
	var p = new(SampleClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_sampleClause
	return p
}

func InitEmptySampleClauseContext(p *SampleClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_sampleClause
}

func (*SampleClauseContext) IsSampleClauseContext() {}

func NewSampleClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleClauseContext {
	var p = new(SampleClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_sampleClause

	return p
}

func (s *SampleClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleClauseContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSAMPLE, 0)
}

func (s *SampleClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *SampleClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampleClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSampleClause(s)
	}
}

func (s *SampleClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSampleClause(s)
	}
}

func (s *SampleClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSampleClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SampleClause() (localctx ISampleClauseContext) {
	localctx = NewSampleClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 804, DorisSQLParserRULE_sampleClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6378)
		p.Match(DorisSQLParserSAMPLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6380)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 741, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6379)
			p.PropertyList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionList() IExpressionListContext
	NamedArgumentList() INamedArgumentListContext

	// IsArgumentListContext differentiates from other interfaces.
	IsArgumentListContext()
}

type ArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext {
	var p = new(ArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_argumentList
	return p
}

func InitEmptyArgumentListContext(p *ArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_argumentList
}

func (*ArgumentListContext) IsArgumentListContext() {}

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext {
	var p = new(ArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_argumentList

	return p
}

func (s *ArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArgumentListContext) NamedArgumentList() INamedArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedArgumentListContext)
}

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterArgumentList(s)
	}
}

func (s *ArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitArgumentList(s)
	}
}

func (s *ArgumentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitArgumentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ArgumentList() (localctx IArgumentListContext) {
	localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 806, DorisSQLParserRULE_argumentList)
	p.SetState(6384)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 742, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6382)
			p.ExpressionList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6383)
			p.NamedArgumentList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedArgumentListContext is an interface to support dynamic dispatch.
type INamedArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNamedArgument() []INamedArgumentContext
	NamedArgument(i int) INamedArgumentContext

	// IsNamedArgumentListContext differentiates from other interfaces.
	IsNamedArgumentListContext()
}

type NamedArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedArgumentListContext() *NamedArgumentListContext {
	var p = new(NamedArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_namedArgumentList
	return p
}

func InitEmptyNamedArgumentListContext(p *NamedArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_namedArgumentList
}

func (*NamedArgumentListContext) IsNamedArgumentListContext() {}

func NewNamedArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedArgumentListContext {
	var p = new(NamedArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_namedArgumentList

	return p
}

func (s *NamedArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedArgumentListContext) AllNamedArgument() []INamedArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedArgumentContext); ok {
			len++
		}
	}

	tst := make([]INamedArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedArgumentContext); ok {
			tst[i] = t.(INamedArgumentContext)
			i++
		}
	}

	return tst
}

func (s *NamedArgumentListContext) NamedArgument(i int) INamedArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedArgumentContext)
}

func (s *NamedArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterNamedArgumentList(s)
	}
}

func (s *NamedArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitNamedArgumentList(s)
	}
}

func (s *NamedArgumentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitNamedArgumentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) NamedArgumentList() (localctx INamedArgumentListContext) {
	localctx = NewNamedArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 808, DorisSQLParserRULE_namedArgumentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6386)
		p.NamedArgument()
	}
	p.SetState(6391)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(6387)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6388)
			p.NamedArgument()
		}

		p.SetState(6393)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedArgumentContext is an interface to support dynamic dispatch.
type INamedArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNamedArgumentContext differentiates from other interfaces.
	IsNamedArgumentContext()
}

type NamedArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedArgumentContext() *NamedArgumentContext {
	var p = new(NamedArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_namedArgument
	return p
}

func InitEmptyNamedArgumentContext(p *NamedArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_namedArgument
}

func (*NamedArgumentContext) IsNamedArgumentContext() {}

func NewNamedArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedArgumentContext {
	var p = new(NamedArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_namedArgument

	return p
}

func (s *NamedArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedArgumentContext) CopyAll(ctx *NamedArgumentContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NamedArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type NamedArgumentsContext struct {
	NamedArgumentContext
}

func NewNamedArgumentsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NamedArgumentsContext {
	var p = new(NamedArgumentsContext)

	InitEmptyNamedArgumentContext(&p.NamedArgumentContext)
	p.parser = parser
	p.CopyAll(ctx.(*NamedArgumentContext))

	return p
}

func (s *NamedArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgumentsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamedArgumentsContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NamedArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterNamedArguments(s)
	}
}

func (s *NamedArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitNamedArguments(s)
	}
}

func (s *NamedArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitNamedArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) NamedArgument() (localctx INamedArgumentContext) {
	localctx = NewNamedArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 810, DorisSQLParserRULE_namedArgument)
	localctx = NewNamedArgumentsContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6394)
		p.Identifier()
	}
	{
		p.SetState(6395)
		p.Match(DorisSQLParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6396)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinRelationContext is an interface to support dynamic dispatch.
type IJoinRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRightRelation returns the rightRelation rule contexts.
	GetRightRelation() IRelationPrimaryContext

	// SetRightRelation sets the rightRelation rule contexts.
	SetRightRelation(IRelationPrimaryContext)

	// Getter signatures
	CrossOrInnerJoinType() ICrossOrInnerJoinTypeContext
	RelationPrimary() IRelationPrimaryContext
	BracketHint() IBracketHintContext
	LATERAL() antlr.TerminalNode
	JoinCriteria() IJoinCriteriaContext
	OuterAndSemiJoinType() IOuterAndSemiJoinTypeContext

	// IsJoinRelationContext differentiates from other interfaces.
	IsJoinRelationContext()
}

type JoinRelationContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	rightRelation IRelationPrimaryContext
}

func NewEmptyJoinRelationContext() *JoinRelationContext {
	var p = new(JoinRelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_joinRelation
	return p
}

func InitEmptyJoinRelationContext(p *JoinRelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_joinRelation
}

func (*JoinRelationContext) IsJoinRelationContext() {}

func NewJoinRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinRelationContext {
	var p = new(JoinRelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_joinRelation

	return p
}

func (s *JoinRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinRelationContext) GetRightRelation() IRelationPrimaryContext { return s.rightRelation }

func (s *JoinRelationContext) SetRightRelation(v IRelationPrimaryContext) { s.rightRelation = v }

func (s *JoinRelationContext) CrossOrInnerJoinType() ICrossOrInnerJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICrossOrInnerJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICrossOrInnerJoinTypeContext)
}

func (s *JoinRelationContext) RelationPrimary() IRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *JoinRelationContext) BracketHint() IBracketHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBracketHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBracketHintContext)
}

func (s *JoinRelationContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLATERAL, 0)
}

func (s *JoinRelationContext) JoinCriteria() IJoinCriteriaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinCriteriaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinCriteriaContext)
}

func (s *JoinRelationContext) OuterAndSemiJoinType() IOuterAndSemiJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOuterAndSemiJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOuterAndSemiJoinTypeContext)
}

func (s *JoinRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterJoinRelation(s)
	}
}

func (s *JoinRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitJoinRelation(s)
	}
}

func (s *JoinRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitJoinRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) JoinRelation() (localctx IJoinRelationContext) {
	localctx = NewJoinRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 812, DorisSQLParserRULE_joinRelation)
	var _la int

	p.SetState(6419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserCROSS, DorisSQLParserINNER, DorisSQLParserJOIN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6398)
			p.CrossOrInnerJoinType()
		}
		p.SetState(6400)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__5 {
			{
				p.SetState(6399)
				p.BracketHint()
			}

		}
		p.SetState(6403)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserLATERAL {
			{
				p.SetState(6402)
				p.Match(DorisSQLParserLATERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6405)

			var _x = p.RelationPrimary()

			localctx.(*JoinRelationContext).rightRelation = _x
		}
		p.SetState(6407)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 746, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6406)
				p.JoinCriteria()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case DorisSQLParserFULL, DorisSQLParserLEFT, DorisSQLParserRIGHT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6409)
			p.OuterAndSemiJoinType()
		}
		p.SetState(6411)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__5 {
			{
				p.SetState(6410)
				p.BracketHint()
			}

		}
		p.SetState(6414)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserLATERAL {
			{
				p.SetState(6413)
				p.Match(DorisSQLParserLATERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6416)

			var _x = p.RelationPrimary()

			localctx.(*JoinRelationContext).rightRelation = _x
		}
		{
			p.SetState(6417)
			p.JoinCriteria()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICrossOrInnerJoinTypeContext is an interface to support dynamic dispatch.
type ICrossOrInnerJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JOIN() antlr.TerminalNode
	INNER() antlr.TerminalNode
	CROSS() antlr.TerminalNode

	// IsCrossOrInnerJoinTypeContext differentiates from other interfaces.
	IsCrossOrInnerJoinTypeContext()
}

type CrossOrInnerJoinTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCrossOrInnerJoinTypeContext() *CrossOrInnerJoinTypeContext {
	var p = new(CrossOrInnerJoinTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_crossOrInnerJoinType
	return p
}

func InitEmptyCrossOrInnerJoinTypeContext(p *CrossOrInnerJoinTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_crossOrInnerJoinType
}

func (*CrossOrInnerJoinTypeContext) IsCrossOrInnerJoinTypeContext() {}

func NewCrossOrInnerJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CrossOrInnerJoinTypeContext {
	var p = new(CrossOrInnerJoinTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_crossOrInnerJoinType

	return p
}

func (s *CrossOrInnerJoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CrossOrInnerJoinTypeContext) JOIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserJOIN, 0)
}

func (s *CrossOrInnerJoinTypeContext) INNER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINNER, 0)
}

func (s *CrossOrInnerJoinTypeContext) CROSS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCROSS, 0)
}

func (s *CrossOrInnerJoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CrossOrInnerJoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CrossOrInnerJoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCrossOrInnerJoinType(s)
	}
}

func (s *CrossOrInnerJoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCrossOrInnerJoinType(s)
	}
}

func (s *CrossOrInnerJoinTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCrossOrInnerJoinType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) CrossOrInnerJoinType() (localctx ICrossOrInnerJoinTypeContext) {
	localctx = NewCrossOrInnerJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 814, DorisSQLParserRULE_crossOrInnerJoinType)
	p.SetState(6427)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 750, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6421)
			p.Match(DorisSQLParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6422)
			p.Match(DorisSQLParserINNER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6423)
			p.Match(DorisSQLParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6424)
			p.Match(DorisSQLParserCROSS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6425)
			p.Match(DorisSQLParserCROSS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6426)
			p.Match(DorisSQLParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOuterAndSemiJoinTypeContext is an interface to support dynamic dispatch.
type IOuterAndSemiJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	FULL() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	ANTI() antlr.TerminalNode

	// IsOuterAndSemiJoinTypeContext differentiates from other interfaces.
	IsOuterAndSemiJoinTypeContext()
}

type OuterAndSemiJoinTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOuterAndSemiJoinTypeContext() *OuterAndSemiJoinTypeContext {
	var p = new(OuterAndSemiJoinTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_outerAndSemiJoinType
	return p
}

func InitEmptyOuterAndSemiJoinTypeContext(p *OuterAndSemiJoinTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_outerAndSemiJoinType
}

func (*OuterAndSemiJoinTypeContext) IsOuterAndSemiJoinTypeContext() {}

func NewOuterAndSemiJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OuterAndSemiJoinTypeContext {
	var p = new(OuterAndSemiJoinTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_outerAndSemiJoinType

	return p
}

func (s *OuterAndSemiJoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OuterAndSemiJoinTypeContext) LEFT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLEFT, 0)
}

func (s *OuterAndSemiJoinTypeContext) JOIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserJOIN, 0)
}

func (s *OuterAndSemiJoinTypeContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRIGHT, 0)
}

func (s *OuterAndSemiJoinTypeContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFULL, 0)
}

func (s *OuterAndSemiJoinTypeContext) OUTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOUTER, 0)
}

func (s *OuterAndSemiJoinTypeContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSEMI, 0)
}

func (s *OuterAndSemiJoinTypeContext) ANTI() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserANTI, 0)
}

func (s *OuterAndSemiJoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OuterAndSemiJoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OuterAndSemiJoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterOuterAndSemiJoinType(s)
	}
}

func (s *OuterAndSemiJoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitOuterAndSemiJoinType(s)
	}
}

func (s *OuterAndSemiJoinTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitOuterAndSemiJoinType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) OuterAndSemiJoinType() (localctx IOuterAndSemiJoinTypeContext) {
	localctx = NewOuterAndSemiJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 816, DorisSQLParserRULE_outerAndSemiJoinType)
	p.SetState(6456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 751, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6429)
			p.Match(DorisSQLParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6430)
			p.Match(DorisSQLParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6431)
			p.Match(DorisSQLParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6432)
			p.Match(DorisSQLParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6433)
			p.Match(DorisSQLParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6434)
			p.Match(DorisSQLParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6435)
			p.Match(DorisSQLParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6436)
			p.Match(DorisSQLParserOUTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6437)
			p.Match(DorisSQLParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6438)
			p.Match(DorisSQLParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6439)
			p.Match(DorisSQLParserOUTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6440)
			p.Match(DorisSQLParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6441)
			p.Match(DorisSQLParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6442)
			p.Match(DorisSQLParserOUTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6443)
			p.Match(DorisSQLParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6444)
			p.Match(DorisSQLParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6445)
			p.Match(DorisSQLParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6446)
			p.Match(DorisSQLParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6447)
			p.Match(DorisSQLParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6448)
			p.Match(DorisSQLParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6449)
			p.Match(DorisSQLParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6450)
			p.Match(DorisSQLParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6451)
			p.Match(DorisSQLParserANTI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6452)
			p.Match(DorisSQLParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6453)
			p.Match(DorisSQLParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6454)
			p.Match(DorisSQLParserANTI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6455)
			p.Match(DorisSQLParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBracketHintContext is an interface to support dynamic dispatch.
type IBracketHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	BITOR() antlr.TerminalNode
	PrimaryExpression() IPrimaryExpressionContext
	LiteralExpressionList() ILiteralExpressionListContext

	// IsBracketHintContext differentiates from other interfaces.
	IsBracketHintContext()
}

type BracketHintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBracketHintContext() *BracketHintContext {
	var p = new(BracketHintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_bracketHint
	return p
}

func InitEmptyBracketHintContext(p *BracketHintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_bracketHint
}

func (*BracketHintContext) IsBracketHintContext() {}

func NewBracketHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BracketHintContext {
	var p = new(BracketHintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_bracketHint

	return p
}

func (s *BracketHintContext) GetParser() antlr.Parser { return s.parser }

func (s *BracketHintContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *BracketHintContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BracketHintContext) BITOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBITOR, 0)
}

func (s *BracketHintContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *BracketHintContext) LiteralExpressionList() ILiteralExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionListContext)
}

func (s *BracketHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BracketHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BracketHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterBracketHint(s)
	}
}

func (s *BracketHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitBracketHint(s)
	}
}

func (s *BracketHintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitBracketHint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) BracketHint() (localctx IBracketHintContext) {
	localctx = NewBracketHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 818, DorisSQLParserRULE_bracketHint)
	var _la int

	p.SetState(6476)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 753, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6458)
			p.Match(DorisSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6459)
			p.Identifier()
		}
		p.SetState(6464)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(6460)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6461)
				p.Identifier()
			}

			p.SetState(6466)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6467)
			p.Match(DorisSQLParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6469)
			p.Match(DorisSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6470)
			p.Identifier()
		}
		{
			p.SetState(6471)
			p.Match(DorisSQLParserBITOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6472)
			p.primaryExpression(0)
		}
		{
			p.SetState(6473)
			p.LiteralExpressionList()
		}
		{
			p.SetState(6474)
			p.Match(DorisSQLParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHintMapContext is an interface to support dynamic dispatch.
type IHintMapContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetK returns the k rule contexts.
	GetK() IIdentifierOrStringContext

	// GetV returns the v rule contexts.
	GetV() ILiteralExpressionContext

	// SetK sets the k rule contexts.
	SetK(IIdentifierOrStringContext)

	// SetV sets the v rule contexts.
	SetV(ILiteralExpressionContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	LiteralExpression() ILiteralExpressionContext

	// IsHintMapContext differentiates from other interfaces.
	IsHintMapContext()
}

type HintMapContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	k      IIdentifierOrStringContext
	v      ILiteralExpressionContext
}

func NewEmptyHintMapContext() *HintMapContext {
	var p = new(HintMapContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_hintMap
	return p
}

func InitEmptyHintMapContext(p *HintMapContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_hintMap
}

func (*HintMapContext) IsHintMapContext() {}

func NewHintMapContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintMapContext {
	var p = new(HintMapContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_hintMap

	return p
}

func (s *HintMapContext) GetParser() antlr.Parser { return s.parser }

func (s *HintMapContext) GetK() IIdentifierOrStringContext { return s.k }

func (s *HintMapContext) GetV() ILiteralExpressionContext { return s.v }

func (s *HintMapContext) SetK(v IIdentifierOrStringContext) { s.k = v }

func (s *HintMapContext) SetV(v ILiteralExpressionContext) { s.v = v }

func (s *HintMapContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEQ, 0)
}

func (s *HintMapContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *HintMapContext) LiteralExpression() ILiteralExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionContext)
}

func (s *HintMapContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintMapContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HintMapContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterHintMap(s)
	}
}

func (s *HintMapContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitHintMap(s)
	}
}

func (s *HintMapContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitHintMap(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) HintMap() (localctx IHintMapContext) {
	localctx = NewHintMapContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 820, DorisSQLParserRULE_hintMap)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6478)

		var _x = p.IdentifierOrString()

		localctx.(*HintMapContext).k = _x
	}
	{
		p.SetState(6479)
		p.Match(DorisSQLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6480)

		var _x = p.LiteralExpression()

		localctx.(*HintMapContext).v = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinCriteriaContext is an interface to support dynamic dispatch.
type IJoinCriteriaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	Expression() IExpressionContext
	USING() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsJoinCriteriaContext differentiates from other interfaces.
	IsJoinCriteriaContext()
}

type JoinCriteriaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinCriteriaContext() *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_joinCriteria
	return p
}

func InitEmptyJoinCriteriaContext(p *JoinCriteriaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_joinCriteria
}

func (*JoinCriteriaContext) IsJoinCriteriaContext() {}

func NewJoinCriteriaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_joinCriteria

	return p
}

func (s *JoinCriteriaContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinCriteriaContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserON, 0)
}

func (s *JoinCriteriaContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JoinCriteriaContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSING, 0)
}

func (s *JoinCriteriaContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *JoinCriteriaContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *JoinCriteriaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinCriteriaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinCriteriaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitJoinCriteria(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) JoinCriteria() (localctx IJoinCriteriaContext) {
	localctx = NewJoinCriteriaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 822, DorisSQLParserRULE_joinCriteria)
	var _la int

	p.SetState(6496)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6482)
			p.Match(DorisSQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6483)
			p.expression(0)
		}

	case DorisSQLParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6484)
			p.Match(DorisSQLParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6485)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6486)
			p.Identifier()
		}
		p.SetState(6491)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(6487)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6488)
				p.Identifier()
			}

			p.SetState(6493)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6494)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnAliasesContext is an interface to support dynamic dispatch.
type IColumnAliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsColumnAliasesContext differentiates from other interfaces.
	IsColumnAliasesContext()
}

type ColumnAliasesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnAliasesContext() *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_columnAliases
	return p
}

func InitEmptyColumnAliasesContext(p *ColumnAliasesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_columnAliases
}

func (*ColumnAliasesContext) IsColumnAliasesContext() {}

func NewColumnAliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_columnAliases

	return p
}

func (s *ColumnAliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnAliasesContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnAliasesContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnAliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnAliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnAliasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterColumnAliases(s)
	}
}

func (s *ColumnAliasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitColumnAliases(s)
	}
}

func (s *ColumnAliasesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitColumnAliases(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ColumnAliases() (localctx IColumnAliasesContext) {
	localctx = NewColumnAliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 824, DorisSQLParserRULE_columnAliases)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6498)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6499)
		p.Identifier()
	}
	p.SetState(6504)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(6500)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6501)
			p.Identifier()
		}

		p.SetState(6506)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6507)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionNamesContext is an interface to support dynamic dispatch.
type IPartitionNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext
	PARTITION() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	KeyPartitions() IKeyPartitionsContext

	// IsPartitionNamesContext differentiates from other interfaces.
	IsPartitionNamesContext()
}

type PartitionNamesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionNamesContext() *PartitionNamesContext {
	var p = new(PartitionNamesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_partitionNames
	return p
}

func InitEmptyPartitionNamesContext(p *PartitionNamesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_partitionNames
}

func (*PartitionNamesContext) IsPartitionNamesContext() {}

func NewPartitionNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionNamesContext {
	var p = new(PartitionNamesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_partitionNames

	return p
}

func (s *PartitionNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionNamesContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *PartitionNamesContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *PartitionNamesContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPARTITION, 0)
}

func (s *PartitionNamesContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPARTITIONS, 0)
}

func (s *PartitionNamesContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTEMPORARY, 0)
}

func (s *PartitionNamesContext) KeyPartitions() IKeyPartitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyPartitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyPartitionsContext)
}

func (s *PartitionNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPartitionNames(s)
	}
}

func (s *PartitionNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPartitionNames(s)
	}
}

func (s *PartitionNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPartitionNames(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PartitionNames() (localctx IPartitionNamesContext) {
	localctx = NewPartitionNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 826, DorisSQLParserRULE_partitionNames)
	var _la int

	p.SetState(6530)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 760, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6510)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserTEMPORARY {
			{
				p.SetState(6509)
				p.Match(DorisSQLParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6512)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserPARTITION || _la == DorisSQLParserPARTITIONS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6513)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6514)
			p.IdentifierOrString()
		}
		p.SetState(6519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(6515)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6516)
				p.IdentifierOrString()
			}

			p.SetState(6521)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6522)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(6525)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserTEMPORARY {
			{
				p.SetState(6524)
				p.Match(DorisSQLParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6527)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserPARTITION || _la == DorisSQLParserPARTITIONS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6528)
			p.IdentifierOrString()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6529)
			p.KeyPartitions()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyPartitionsContext is an interface to support dynamic dispatch.
type IKeyPartitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsKeyPartitionsContext differentiates from other interfaces.
	IsKeyPartitionsContext()
}

type KeyPartitionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyPartitionsContext() *KeyPartitionsContext {
	var p = new(KeyPartitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_keyPartitions
	return p
}

func InitEmptyKeyPartitionsContext(p *KeyPartitionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_keyPartitions
}

func (*KeyPartitionsContext) IsKeyPartitionsContext() {}

func NewKeyPartitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyPartitionsContext {
	var p = new(KeyPartitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_keyPartitions

	return p
}

func (s *KeyPartitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyPartitionsContext) CopyAll(ctx *KeyPartitionsContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *KeyPartitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyPartitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type KeyPartitionListContext struct {
	KeyPartitionsContext
}

func NewKeyPartitionListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KeyPartitionListContext {
	var p = new(KeyPartitionListContext)

	InitEmptyKeyPartitionsContext(&p.KeyPartitionsContext)
	p.parser = parser
	p.CopyAll(ctx.(*KeyPartitionsContext))

	return p
}

func (s *KeyPartitionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyPartitionListContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPARTITION, 0)
}

func (s *KeyPartitionListContext) AllKeyPartition() []IKeyPartitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyPartitionContext); ok {
			len++
		}
	}

	tst := make([]IKeyPartitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyPartitionContext); ok {
			tst[i] = t.(IKeyPartitionContext)
			i++
		}
	}

	return tst
}

func (s *KeyPartitionListContext) KeyPartition(i int) IKeyPartitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyPartitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyPartitionContext)
}

func (s *KeyPartitionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterKeyPartitionList(s)
	}
}

func (s *KeyPartitionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitKeyPartitionList(s)
	}
}

func (s *KeyPartitionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitKeyPartitionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) KeyPartitions() (localctx IKeyPartitionsContext) {
	localctx = NewKeyPartitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 828, DorisSQLParserRULE_keyPartitions)
	var _la int

	localctx = NewKeyPartitionListContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6532)
		p.Match(DorisSQLParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6533)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6534)
		p.KeyPartition()
	}
	p.SetState(6539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(6535)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6536)
			p.KeyPartition()
		}

		p.SetState(6541)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6542)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITabletListContext is an interface to support dynamic dispatch.
type ITabletListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLET() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsTabletListContext differentiates from other interfaces.
	IsTabletListContext()
}

type TabletListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTabletListContext() *TabletListContext {
	var p = new(TabletListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_tabletList
	return p
}

func InitEmptyTabletListContext(p *TabletListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_tabletList
}

func (*TabletListContext) IsTabletListContext() {}

func NewTabletListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TabletListContext {
	var p = new(TabletListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_tabletList

	return p
}

func (s *TabletListContext) GetParser() antlr.Parser { return s.parser }

func (s *TabletListContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLET, 0)
}

func (s *TabletListContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserINTEGER_VALUE)
}

func (s *TabletListContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, i)
}

func (s *TabletListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TabletListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TabletListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTabletList(s)
	}
}

func (s *TabletListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTabletList(s)
	}
}

func (s *TabletListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTabletList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) TabletList() (localctx ITabletListContext) {
	localctx = NewTabletListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 830, DorisSQLParserRULE_tabletList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6544)
		p.Match(DorisSQLParserTABLET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6545)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6546)
		p.Match(DorisSQLParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6551)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(6547)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6548)
			p.Match(DorisSQLParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(6553)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6554)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrepareStatementContext is an interface to support dynamic dispatch.
type IPrepareStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PREPARE() antlr.TerminalNode
	Identifier() IIdentifierContext
	FROM() antlr.TerminalNode
	PrepareSql() IPrepareSqlContext

	// IsPrepareStatementContext differentiates from other interfaces.
	IsPrepareStatementContext()
}

type PrepareStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrepareStatementContext() *PrepareStatementContext {
	var p = new(PrepareStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_prepareStatement
	return p
}

func InitEmptyPrepareStatementContext(p *PrepareStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_prepareStatement
}

func (*PrepareStatementContext) IsPrepareStatementContext() {}

func NewPrepareStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrepareStatementContext {
	var p = new(PrepareStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_prepareStatement

	return p
}

func (s *PrepareStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PrepareStatementContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPREPARE, 0)
}

func (s *PrepareStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrepareStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *PrepareStatementContext) PrepareSql() IPrepareSqlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrepareSqlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrepareSqlContext)
}

func (s *PrepareStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrepareStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrepareStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPrepareStatement(s)
	}
}

func (s *PrepareStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPrepareStatement(s)
	}
}

func (s *PrepareStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPrepareStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PrepareStatement() (localctx IPrepareStatementContext) {
	localctx = NewPrepareStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 832, DorisSQLParserRULE_prepareStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6556)
		p.Match(DorisSQLParserPREPARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6557)
		p.Identifier()
	}
	{
		p.SetState(6558)
		p.Match(DorisSQLParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6559)
		p.PrepareSql()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrepareSqlContext is an interface to support dynamic dispatch.
type IPrepareSqlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Statement() IStatementContext
	SINGLE_QUOTED_TEXT() antlr.TerminalNode

	// IsPrepareSqlContext differentiates from other interfaces.
	IsPrepareSqlContext()
}

type PrepareSqlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrepareSqlContext() *PrepareSqlContext {
	var p = new(PrepareSqlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_prepareSql
	return p
}

func InitEmptyPrepareSqlContext(p *PrepareSqlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_prepareSql
}

func (*PrepareSqlContext) IsPrepareSqlContext() {}

func NewPrepareSqlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrepareSqlContext {
	var p = new(PrepareSqlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_prepareSql

	return p
}

func (s *PrepareSqlContext) GetParser() antlr.Parser { return s.parser }

func (s *PrepareSqlContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *PrepareSqlContext) SINGLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSINGLE_QUOTED_TEXT, 0)
}

func (s *PrepareSqlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrepareSqlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrepareSqlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPrepareSql(s)
	}
}

func (s *PrepareSqlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPrepareSql(s)
	}
}

func (s *PrepareSqlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPrepareSql(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PrepareSql() (localctx IPrepareSqlContext) {
	localctx = NewPrepareSqlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 834, DorisSQLParserRULE_prepareSql)
	p.SetState(6563)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserT__1, DorisSQLParserADD, DorisSQLParserADMIN, DorisSQLParserALTER, DorisSQLParserANALYZE, DorisSQLParserBACKUP, DorisSQLParserBEGIN, DorisSQLParserCACHE, DorisSQLParserCANCEL, DorisSQLParserCLEAN, DorisSQLParserCLEAR, DorisSQLParserCOMMIT, DorisSQLParserCREATE, DorisSQLParserDEALLOCATE, DorisSQLParserDELETE, DorisSQLParserDESC, DorisSQLParserDESCRIBE, DorisSQLParserDROP, DorisSQLParserEXECUTE, DorisSQLParserEXPLAIN, DorisSQLParserEXPORT, DorisSQLParserGRANT, DorisSQLParserHELP, DorisSQLParserINSTALL, DorisSQLParserINSERT, DorisSQLParserKILL, DorisSQLParserLOAD, DorisSQLParserPAUSE, DorisSQLParserPREPARE, DorisSQLParserRECOVER, DorisSQLParserREFRESH, DorisSQLParserRESTORE, DorisSQLParserRESUME, DorisSQLParserREVOKE, DorisSQLParserROLLBACK, DorisSQLParserSELECT, DorisSQLParserSET, DorisSQLParserSHOW, DorisSQLParserSTART, DorisSQLParserSTOP, DorisSQLParserSUBMIT, DorisSQLParserSUSPEND, DorisSQLParserSYNC, DorisSQLParserTRANSLATE, DorisSQLParserTRACE, DorisSQLParserTRUNCATE, DorisSQLParserUNINSTALL, DorisSQLParserUPDATE, DorisSQLParserUSE, DorisSQLParserWITH, DorisSQLParserLOCK, DorisSQLParserUNLOCK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6561)
			p.Statement()
		}

	case DorisSQLParserSINGLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6562)
			p.Match(DorisSQLParserSINGLE_QUOTED_TEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExecuteStatementContext is an interface to support dynamic dispatch.
type IExecuteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXECUTE() antlr.TerminalNode
	Identifier() IIdentifierContext
	USING() antlr.TerminalNode
	AllAT() []antlr.TerminalNode
	AT(i int) antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext

	// IsExecuteStatementContext differentiates from other interfaces.
	IsExecuteStatementContext()
}

type ExecuteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteStatementContext() *ExecuteStatementContext {
	var p = new(ExecuteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_executeStatement
	return p
}

func InitEmptyExecuteStatementContext(p *ExecuteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_executeStatement
}

func (*ExecuteStatementContext) IsExecuteStatementContext() {}

func NewExecuteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteStatementContext {
	var p = new(ExecuteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_executeStatement

	return p
}

func (s *ExecuteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteStatementContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXECUTE, 0)
}

func (s *ExecuteStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExecuteStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSING, 0)
}

func (s *ExecuteStatementContext) AllAT() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserAT)
}

func (s *ExecuteStatementContext) AT(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAT, i)
}

func (s *ExecuteStatementContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *ExecuteStatementContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *ExecuteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterExecuteStatement(s)
	}
}

func (s *ExecuteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitExecuteStatement(s)
	}
}

func (s *ExecuteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitExecuteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ExecuteStatement() (localctx IExecuteStatementContext) {
	localctx = NewExecuteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 836, DorisSQLParserRULE_executeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6565)
		p.Match(DorisSQLParserEXECUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6566)
		p.Identifier()
	}
	p.SetState(6578)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserUSING {
		{
			p.SetState(6567)
			p.Match(DorisSQLParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6568)
			p.Match(DorisSQLParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6569)
			p.IdentifierOrString()
		}
		p.SetState(6575)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(6570)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6571)
				p.Match(DorisSQLParserAT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6572)
				p.IdentifierOrString()
			}

			p.SetState(6577)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeallocateStatementContext is an interface to support dynamic dispatch.
type IDeallocateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PREPARE() antlr.TerminalNode
	Identifier() IIdentifierContext
	DEALLOCATE() antlr.TerminalNode
	DROP() antlr.TerminalNode

	// IsDeallocateStatementContext differentiates from other interfaces.
	IsDeallocateStatementContext()
}

type DeallocateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeallocateStatementContext() *DeallocateStatementContext {
	var p = new(DeallocateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_deallocateStatement
	return p
}

func InitEmptyDeallocateStatementContext(p *DeallocateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_deallocateStatement
}

func (*DeallocateStatementContext) IsDeallocateStatementContext() {}

func NewDeallocateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeallocateStatementContext {
	var p = new(DeallocateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_deallocateStatement

	return p
}

func (s *DeallocateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeallocateStatementContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPREPARE, 0)
}

func (s *DeallocateStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DeallocateStatementContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDEALLOCATE, 0)
}

func (s *DeallocateStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDROP, 0)
}

func (s *DeallocateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeallocateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeallocateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDeallocateStatement(s)
	}
}

func (s *DeallocateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDeallocateStatement(s)
	}
}

func (s *DeallocateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDeallocateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DeallocateStatement() (localctx IDeallocateStatementContext) {
	localctx = NewDeallocateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 838, DorisSQLParserRULE_deallocateStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6580)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserDEALLOCATE || _la == DorisSQLParserDROP) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6581)
		p.Match(DorisSQLParserPREPARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6582)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplicaListContext is an interface to support dynamic dispatch.
type IReplicaListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLICA() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsReplicaListContext differentiates from other interfaces.
	IsReplicaListContext()
}

type ReplicaListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplicaListContext() *ReplicaListContext {
	var p = new(ReplicaListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_replicaList
	return p
}

func InitEmptyReplicaListContext(p *ReplicaListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_replicaList
}

func (*ReplicaListContext) IsReplicaListContext() {}

func NewReplicaListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplicaListContext {
	var p = new(ReplicaListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_replicaList

	return p
}

func (s *ReplicaListContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplicaListContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPLICA, 0)
}

func (s *ReplicaListContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserINTEGER_VALUE)
}

func (s *ReplicaListContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, i)
}

func (s *ReplicaListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplicaListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplicaListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterReplicaList(s)
	}
}

func (s *ReplicaListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitReplicaList(s)
	}
}

func (s *ReplicaListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitReplicaList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ReplicaList() (localctx IReplicaListContext) {
	localctx = NewReplicaListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 840, DorisSQLParserRULE_replicaList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6584)
		p.Match(DorisSQLParserREPLICA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6585)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6586)
		p.Match(DorisSQLParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6591)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(6587)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6588)
			p.Match(DorisSQLParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(6593)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6594)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionsWithDefaultContext is an interface to support dynamic dispatch.
type IExpressionsWithDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpressionOrDefault() []IExpressionOrDefaultContext
	ExpressionOrDefault(i int) IExpressionOrDefaultContext

	// IsExpressionsWithDefaultContext differentiates from other interfaces.
	IsExpressionsWithDefaultContext()
}

type ExpressionsWithDefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionsWithDefaultContext() *ExpressionsWithDefaultContext {
	var p = new(ExpressionsWithDefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_expressionsWithDefault
	return p
}

func InitEmptyExpressionsWithDefaultContext(p *ExpressionsWithDefaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_expressionsWithDefault
}

func (*ExpressionsWithDefaultContext) IsExpressionsWithDefaultContext() {}

func NewExpressionsWithDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionsWithDefaultContext {
	var p = new(ExpressionsWithDefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_expressionsWithDefault

	return p
}

func (s *ExpressionsWithDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionsWithDefaultContext) AllExpressionOrDefault() []IExpressionOrDefaultContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionOrDefaultContext); ok {
			len++
		}
	}

	tst := make([]IExpressionOrDefaultContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionOrDefaultContext); ok {
			tst[i] = t.(IExpressionOrDefaultContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionsWithDefaultContext) ExpressionOrDefault(i int) IExpressionOrDefaultContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionOrDefaultContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionOrDefaultContext)
}

func (s *ExpressionsWithDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionsWithDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionsWithDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterExpressionsWithDefault(s)
	}
}

func (s *ExpressionsWithDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitExpressionsWithDefault(s)
	}
}

func (s *ExpressionsWithDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitExpressionsWithDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ExpressionsWithDefault() (localctx IExpressionsWithDefaultContext) {
	localctx = NewExpressionsWithDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 842, DorisSQLParserRULE_expressionsWithDefault)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6596)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6597)
		p.ExpressionOrDefault()
	}
	p.SetState(6602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(6598)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6599)
			p.ExpressionOrDefault()
		}

		p.SetState(6604)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6605)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionOrDefaultContext is an interface to support dynamic dispatch.
type IExpressionOrDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	DEFAULT() antlr.TerminalNode

	// IsExpressionOrDefaultContext differentiates from other interfaces.
	IsExpressionOrDefaultContext()
}

type ExpressionOrDefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionOrDefaultContext() *ExpressionOrDefaultContext {
	var p = new(ExpressionOrDefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_expressionOrDefault
	return p
}

func InitEmptyExpressionOrDefaultContext(p *ExpressionOrDefaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_expressionOrDefault
}

func (*ExpressionOrDefaultContext) IsExpressionOrDefaultContext() {}

func NewExpressionOrDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionOrDefaultContext {
	var p = new(ExpressionOrDefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_expressionOrDefault

	return p
}

func (s *ExpressionOrDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionOrDefaultContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionOrDefaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDEFAULT, 0)
}

func (s *ExpressionOrDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionOrDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionOrDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterExpressionOrDefault(s)
	}
}

func (s *ExpressionOrDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitExpressionOrDefault(s)
	}
}

func (s *ExpressionOrDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitExpressionOrDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ExpressionOrDefault() (localctx IExpressionOrDefaultContext) {
	localctx = NewExpressionOrDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 844, DorisSQLParserRULE_expressionOrDefault)
	p.SetState(6609)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserT__1, DorisSQLParserT__5, DorisSQLParserT__8, DorisSQLParserACCESS, DorisSQLParserACTIVE, DorisSQLParserADMIN, DorisSQLParserADVISOR, DorisSQLParserAFTER, DorisSQLParserAGGREGATE, DorisSQLParserANTI, DorisSQLParserAPPLY, DorisSQLParserARRAY, DorisSQLParserARRAY_AGG, DorisSQLParserARRAY_AGG_DISTINCT, DorisSQLParserASYNC, DorisSQLParserAUTHORS, DorisSQLParserAUTHENTICATION, DorisSQLParserAUTOMATED, DorisSQLParserAUTO_INCREMENT, DorisSQLParserAVG, DorisSQLParserBACKEND, DorisSQLParserBACKENDS, DorisSQLParserBACKUP, DorisSQLParserBASE, DorisSQLParserBASELINE, DorisSQLParserBEGIN, DorisSQLParserBINARY, DorisSQLParserBITMAP_UNION, DorisSQLParserBLACKHOLE, DorisSQLParserBLACKLIST, DorisSQLParserBODY, DorisSQLParserBOOLEAN, DorisSQLParserBRANCH, DorisSQLParserBROKER, DorisSQLParserBUCKETS, DorisSQLParserBUILTIN, DorisSQLParserCACHE, DorisSQLParserCANCEL, DorisSQLParserCASE, DorisSQLParserCAST, DorisSQLParserCATALOG, DorisSQLParserCATALOGS, DorisSQLParserCEIL, DorisSQLParserCHAIN, DorisSQLParserCHAR, DorisSQLParserCHARSET, DorisSQLParserCLEAN, DorisSQLParserCLEAR, DorisSQLParserCLUSTER, DorisSQLParserCLUSTERS, DorisSQLParserCNGROUP, DorisSQLParserCNGROUPS, DorisSQLParserCOLLATION, DorisSQLParserCOLUMNS, DorisSQLParserCOMMENT, DorisSQLParserCOMMIT, DorisSQLParserCOMMITTED, DorisSQLParserCOMPACT, DorisSQLParserCOMPUTE, DorisSQLParserCONFIG, DorisSQLParserCONNECTION, DorisSQLParserCONSISTENT, DorisSQLParserCONVERT, DorisSQLParserCOSTS, DorisSQLParserCOUNT, DorisSQLParserCUME_DIST, DorisSQLParserCUMULATIVE, DorisSQLParserCURRENT, DorisSQLParserCURRENT_DATE, DorisSQLParserCURRENT_GROUP, DorisSQLParserCURRENT_ROLE, DorisSQLParserCURRENT_TIME, DorisSQLParserCURRENT_TIMESTAMP, DorisSQLParserCURRENT_USER, DorisSQLParserDATA, DorisSQLParserDATACACHE, DorisSQLParserDATABASE, DorisSQLParserDATE, DorisSQLParserDATETIME, DorisSQLParserDAY, DorisSQLParserDAYS, DorisSQLParserDEALLOCATE, DorisSQLParserDECOMMISSION, DorisSQLParserDENSE_RANK, DorisSQLParserDIALECT, DorisSQLParserDICTIONARY, DorisSQLParserDICTIONARY_GET, DorisSQLParserNTILE, DorisSQLParserDISABLE, DorisSQLParserDISTRIBUTED, DorisSQLParserDISTRIBUTION, DorisSQLParserDUPLICATE, DorisSQLParserDYNAMIC, DorisSQLParserENABLE, DorisSQLParserENCLOSE, DorisSQLParserEND, DorisSQLParserENGINE, DorisSQLParserENGINES, DorisSQLParserERRORS, DorisSQLParserESCAPE, DorisSQLParserEVENTS, DorisSQLParserEXCEPT, DorisSQLParserEXCLUDE, DorisSQLParserEXECUTE, DorisSQLParserEXISTS, DorisSQLParserEXPORT, DorisSQLParserEXTERNAL, DorisSQLParserEXTRACT, DorisSQLParserEVERY, DorisSQLParserFAILPOINT, DorisSQLParserFAILPOINTS, DorisSQLParserFALSE, DorisSQLParserFIELDS, DorisSQLParserFILE, DorisSQLParserFILTER, DorisSQLParserFIRST, DorisSQLParserFIRST_VALUE, DorisSQLParserFLOOR, DorisSQLParserFN, DorisSQLParserFOLLOWING, DorisSQLParserFOLLOWER, DorisSQLParserFORMAT, DorisSQLParserFREE, DorisSQLParserFRONTEND, DorisSQLParserFRONTENDS, DorisSQLParserFUNCTIONS, DorisSQLParserGLOBAL, DorisSQLParserGRANTS, DorisSQLParserGROUPING, DorisSQLParserGROUPING_ID, DorisSQLParserGROUP_CONCAT, DorisSQLParserHASH, DorisSQLParserHELP, DorisSQLParserHISTOGRAM, DorisSQLParserHLL_UNION, DorisSQLParserHOST, DorisSQLParserHOUR, DorisSQLParserHOURS, DorisSQLParserHUB, DorisSQLParserIDENTIFIED, DorisSQLParserIF, DorisSQLParserIMPERSONATE, DorisSQLParserIMAGE, DorisSQLParserINACTIVE, DorisSQLParserINCREMENTAL, DorisSQLParserINDEXES, DorisSQLParserINSTALL, DorisSQLParserINTEGRATION, DorisSQLParserINTEGRATIONS, DorisSQLParserINTERMEDIATE, DorisSQLParserINTERVAL, DorisSQLParserOVERWRITE, DorisSQLParserISOLATION, DorisSQLParserJOB, DorisSQLParserLABEL, DorisSQLParserLAG, DorisSQLParserLAST, DorisSQLParserLAST_VALUE, DorisSQLParserLEAD, DorisSQLParserLEFT, DorisSQLParserLESS, DorisSQLParserLEVEL, DorisSQLParserLIKE, DorisSQLParserLIST, DorisSQLParserLOCAL, DorisSQLParserLOCALTIME, DorisSQLParserLOCALTIMESTAMP, DorisSQLParserLOCATION, DorisSQLParserLOCATIONS, DorisSQLParserLOGS, DorisSQLParserLOGICAL, DorisSQLParserMANUAL, DorisSQLParserMAP, DorisSQLParserMAPPING, DorisSQLParserMAPPINGS, DorisSQLParserMASKING, DorisSQLParserMATCH, DorisSQLParserMATERIALIZED, DorisSQLParserMAX, DorisSQLParserMERGE, DorisSQLParserMIN, DorisSQLParserMINUTE, DorisSQLParserMINUTES, DorisSQLParserMINUS, DorisSQLParserMETA, DorisSQLParserMOD, DorisSQLParserMODE, DorisSQLParserMODIFY, DorisSQLParserMONTH, DorisSQLParserMULTIPLE, DorisSQLParserNAME, DorisSQLParserNAMES, DorisSQLParserNEGATIVE, DorisSQLParserNGRAMBF, DorisSQLParserNO, DorisSQLParserNODE, DorisSQLParserNODES, DorisSQLParserNONE, DorisSQLParserNOT, DorisSQLParserNULL, DorisSQLParserNULLS, DorisSQLParserNUMBER, DorisSQLParserNUMERIC, DorisSQLParserOBSERVER, DorisSQLParserOF, DorisSQLParserOFF, DorisSQLParserOFFSET, DorisSQLParserONLY, DorisSQLParserOPEN, DorisSQLParserOPERATE, DorisSQLParserOPTIMIZER, DorisSQLParserOPTION, DorisSQLParserPARAMETER, DorisSQLParserPARTITIONS, DorisSQLParserPASSWORD, DorisSQLParserPATH, DorisSQLParserPAUSE, DorisSQLParserPENDING, DorisSQLParserPERCENT_RANK, DorisSQLParserPERCENTILE_UNION, DorisSQLParserPLAN, DorisSQLParserPLUGIN, DorisSQLParserPLUGINS, DorisSQLParserPIPE, DorisSQLParserPIPES, DorisSQLParserPIVOT, DorisSQLParserPOLICY, DorisSQLParserPOLICIES, DorisSQLParserPRECEDING, DorisSQLParserPREDICATE, DorisSQLParserPRIORITY, DorisSQLParserPRIVILEGES, DorisSQLParserPROBABILITY, DorisSQLParserPROC, DorisSQLParserPROCESSLIST, DorisSQLParserPROFILE, DorisSQLParserPROFILELIST, DorisSQLParserPROPERTIES, DorisSQLParserPROPERTY, DorisSQLParserPROVIDER, DorisSQLParserPROVIDERS, DorisSQLParserQUALIFY, DorisSQLParserQUARTER, DorisSQLParserQUERY, DorisSQLParserQUERIES, DorisSQLParserQUEUE, DorisSQLParserQUOTA, DorisSQLParserRANDOM, DorisSQLParserRANK, DorisSQLParserREASON, DorisSQLParserRECOVER, DorisSQLParserREFRESH, DorisSQLParserREWRITE, DorisSQLParserREGEXP, DorisSQLParserREMOVE, DorisSQLParserREPAIR, DorisSQLParserREPEATABLE, DorisSQLParserREPLACE, DorisSQLParserREPLACE_IF_NOT_NULL, DorisSQLParserREPLICA, DorisSQLParserREPOSITORY, DorisSQLParserREPOSITORIES, DorisSQLParserRESOURCE, DorisSQLParserRESOURCES, DorisSQLParserRESTORE, DorisSQLParserRESUME, DorisSQLParserRETAIN, DorisSQLParserRETENTION, DorisSQLParserRETURNS, DorisSQLParserRETRY, DorisSQLParserREVERT, DorisSQLParserRIGHT, DorisSQLParserRLIKE, DorisSQLParserROLE, DorisSQLParserROLES, DorisSQLParserROLLBACK, DorisSQLParserROLLUP, DorisSQLParserROUTINE, DorisSQLParserROW, DorisSQLParserROW_NUMBER, DorisSQLParserRULE, DorisSQLParserRULES, DorisSQLParserRUNNING, DorisSQLParserSAMPLE, DorisSQLParserSCHEDULE, DorisSQLParserSCHEDULER, DorisSQLParserSCHEMA, DorisSQLParserSECOND, DorisSQLParserSECURITY, DorisSQLParserSEMI, DorisSQLParserSEPARATOR, DorisSQLParserSERIALIZABLE, DorisSQLParserSESSION, DorisSQLParserSETS, DorisSQLParserSIGNED, DorisSQLParserSKIP_HEADER, DorisSQLParserSNAPSHOT, DorisSQLParserSNAPSHOTS, DorisSQLParserSQLBLACKLIST, DorisSQLParserSTART, DorisSQLParserSTATS, DorisSQLParserSTATUS, DorisSQLParserSTOP, DorisSQLParserSTORAGE, DorisSQLParserSTREAM, DorisSQLParserSTRING, DorisSQLParserSUBMIT, DorisSQLParserSUM, DorisSQLParserSUSPEND, DorisSQLParserSYNC, DorisSQLParserSYSTEM_TIME, DorisSQLParserSWAP, DorisSQLParserSTRUCT, DorisSQLParserTABLES, DorisSQLParserTABLET, DorisSQLParserTABLETS, DorisSQLParserTAG, DorisSQLParserTASK, DorisSQLParserTEMPORARY, DorisSQLParserTHAN, DorisSQLParserTIME, DorisSQLParserTIMES, DorisSQLParserTIMESTAMP, DorisSQLParserTIMESTAMPADD, DorisSQLParserTIMESTAMPDIFF, DorisSQLParserTRANSACTION, DorisSQLParserTRANSLATE, DorisSQLParserTRACE, DorisSQLParserTRIGGERS, DorisSQLParserTRIM_SPACE, DorisSQLParserTRUE, DorisSQLParserTRUNCATE, DorisSQLParserTYPE, DorisSQLParserTYPES, DorisSQLParserUNBOUNDED, DorisSQLParserUNCOMMITTED, DorisSQLParserUNINSTALL, DorisSQLParserUNSET, DorisSQLParserUSAGE, DorisSQLParserUSER, DorisSQLParserUSERS, DorisSQLParserVALUE, DorisSQLParserVARBINARY, DorisSQLParserVARIABLES, DorisSQLParserVECTOR, DorisSQLParserVERBOSE, DorisSQLParserVERSION, DorisSQLParserVIEW, DorisSQLParserVIEWS, DorisSQLParserVOLUME, DorisSQLParserVOLUMES, DorisSQLParserWAREHOUSE, DorisSQLParserWAREHOUSES, DorisSQLParserWARNINGS, DorisSQLParserWEEK, DorisSQLParserWHITELIST, DorisSQLParserWORK, DorisSQLParserWRITE, DorisSQLParserYEAR, DorisSQLParserLOCK, DorisSQLParserUNLOCK, DorisSQLParserLOW_PRIORITY, DorisSQLParserDISK, DorisSQLParserBEFORE, DorisSQLParserFIELD, DorisSQLParserPERSISTENT, DorisSQLParserARRAY_ELEMENT, DorisSQLParserPLUS_SYMBOL, DorisSQLParserMINUS_SYMBOL, DorisSQLParserLOGICAL_NOT, DorisSQLParserBITNOT, DorisSQLParserAT, DorisSQLParserINTEGER_VALUE, DorisSQLParserDECIMAL_VALUE, DorisSQLParserDOUBLE_VALUE, DorisSQLParserSINGLE_QUOTED_TEXT, DorisSQLParserDOUBLE_QUOTED_TEXT, DorisSQLParserBINARY_SINGLE_QUOTED_TEXT, DorisSQLParserBINARY_DOUBLE_QUOTED_TEXT, DorisSQLParserLETTER_IDENTIFIER, DorisSQLParserDIGIT_IDENTIFIER, DorisSQLParserBACKQUOTED_IDENTIFIER, DorisSQLParserDOTDOTDOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6607)
			p.expression(0)
		}

	case DorisSQLParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6608)
			p.Match(DorisSQLParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapExpressionListContext is an interface to support dynamic dispatch.
type IMapExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMapExpression() []IMapExpressionContext
	MapExpression(i int) IMapExpressionContext

	// IsMapExpressionListContext differentiates from other interfaces.
	IsMapExpressionListContext()
}

type MapExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapExpressionListContext() *MapExpressionListContext {
	var p = new(MapExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_mapExpressionList
	return p
}

func InitEmptyMapExpressionListContext(p *MapExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_mapExpressionList
}

func (*MapExpressionListContext) IsMapExpressionListContext() {}

func NewMapExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapExpressionListContext {
	var p = new(MapExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_mapExpressionList

	return p
}

func (s *MapExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *MapExpressionListContext) AllMapExpression() []IMapExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMapExpressionContext); ok {
			len++
		}
	}

	tst := make([]IMapExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMapExpressionContext); ok {
			tst[i] = t.(IMapExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MapExpressionListContext) MapExpression(i int) IMapExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapExpressionContext)
}

func (s *MapExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterMapExpressionList(s)
	}
}

func (s *MapExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitMapExpressionList(s)
	}
}

func (s *MapExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitMapExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) MapExpressionList() (localctx IMapExpressionListContext) {
	localctx = NewMapExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 846, DorisSQLParserRULE_mapExpressionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6611)
		p.MapExpression()
	}
	p.SetState(6616)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(6612)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6613)
			p.MapExpression()
		}

		p.SetState(6618)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapExpressionContext is an interface to support dynamic dispatch.
type IMapExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IExpressionContext

	// GetValue returns the value rule contexts.
	GetValue() IExpressionContext

	// SetKey sets the key rule contexts.
	SetKey(IExpressionContext)

	// SetValue sets the value rule contexts.
	SetValue(IExpressionContext)

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsMapExpressionContext differentiates from other interfaces.
	IsMapExpressionContext()
}

type MapExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IExpressionContext
	value  IExpressionContext
}

func NewEmptyMapExpressionContext() *MapExpressionContext {
	var p = new(MapExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_mapExpression
	return p
}

func InitEmptyMapExpressionContext(p *MapExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_mapExpression
}

func (*MapExpressionContext) IsMapExpressionContext() {}

func NewMapExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapExpressionContext {
	var p = new(MapExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_mapExpression

	return p
}

func (s *MapExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MapExpressionContext) GetKey() IExpressionContext { return s.key }

func (s *MapExpressionContext) GetValue() IExpressionContext { return s.value }

func (s *MapExpressionContext) SetKey(v IExpressionContext) { s.key = v }

func (s *MapExpressionContext) SetValue(v IExpressionContext) { s.value = v }

func (s *MapExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MapExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MapExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterMapExpression(s)
	}
}

func (s *MapExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitMapExpression(s)
	}
}

func (s *MapExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitMapExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) MapExpression() (localctx IMapExpressionContext) {
	localctx = NewMapExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 848, DorisSQLParserRULE_mapExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6619)

		var _x = p.expression(0)

		localctx.(*MapExpressionContext).key = _x
	}
	{
		p.SetState(6620)
		p.Match(DorisSQLParserT__7)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6621)

		var _x = p.expression(0)

		localctx.(*MapExpressionContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionSingletonContext is an interface to support dynamic dispatch.
type IExpressionSingletonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	EOF() antlr.TerminalNode

	// IsExpressionSingletonContext differentiates from other interfaces.
	IsExpressionSingletonContext()
}

type ExpressionSingletonContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionSingletonContext() *ExpressionSingletonContext {
	var p = new(ExpressionSingletonContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_expressionSingleton
	return p
}

func InitEmptyExpressionSingletonContext(p *ExpressionSingletonContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_expressionSingleton
}

func (*ExpressionSingletonContext) IsExpressionSingletonContext() {}

func NewExpressionSingletonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionSingletonContext {
	var p = new(ExpressionSingletonContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_expressionSingleton

	return p
}

func (s *ExpressionSingletonContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionSingletonContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionSingletonContext) EOF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEOF, 0)
}

func (s *ExpressionSingletonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionSingletonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionSingletonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterExpressionSingleton(s)
	}
}

func (s *ExpressionSingletonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitExpressionSingleton(s)
	}
}

func (s *ExpressionSingletonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitExpressionSingleton(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ExpressionSingleton() (localctx IExpressionSingletonContext) {
	localctx = NewExpressionSingletonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 850, DorisSQLParserRULE_expressionSingleton)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6623)
		p.expression(0)
	}
	{
		p.SetState(6624)
		p.Match(DorisSQLParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyAll(ctx *ExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExpressionDefaultContext struct {
	ExpressionContext
}

func NewExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExpressionDefaultContext {
	var p = new(ExpressionDefaultContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionDefaultContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ExpressionDefaultContext) BINARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBINARY, 0)
}

func (s *ExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterExpressionDefault(s)
	}
}

func (s *ExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitExpressionDefault(s)
	}
}

func (s *ExpressionDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitExpressionDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalNotContext struct {
	ExpressionContext
}

func NewLogicalNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalNotContext {
	var p = new(LogicalNotContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *LogicalNotContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterLogicalNot(s)
	}
}

func (s *LogicalNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitLogicalNot(s)
	}
}

func (s *LogicalNotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitLogicalNot(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalBinaryContext struct {
	ExpressionContext
	left     IExpressionContext
	operator antlr.Token
	right    IExpressionContext
}

func NewLogicalBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalBinaryContext {
	var p = new(LogicalBinaryContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *LogicalBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *LogicalBinaryContext) GetLeft() IExpressionContext { return s.left }

func (s *LogicalBinaryContext) GetRight() IExpressionContext { return s.right }

func (s *LogicalBinaryContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *LogicalBinaryContext) SetRight(v IExpressionContext) { s.right = v }

func (s *LogicalBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalBinaryContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalBinaryContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalBinaryContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAND, 0)
}

func (s *LogicalBinaryContext) LOGICAL_AND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOGICAL_AND, 0)
}

func (s *LogicalBinaryContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOR, 0)
}

func (s *LogicalBinaryContext) LOGICAL_OR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOGICAL_OR, 0)
}

func (s *LogicalBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitLogicalBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *DorisSQLParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 852
	p.EnterRecursionRule(localctx, 852, DorisSQLParserRULE_expression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6633)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserT__1, DorisSQLParserT__5, DorisSQLParserT__8, DorisSQLParserACCESS, DorisSQLParserACTIVE, DorisSQLParserADMIN, DorisSQLParserADVISOR, DorisSQLParserAFTER, DorisSQLParserAGGREGATE, DorisSQLParserANTI, DorisSQLParserAPPLY, DorisSQLParserARRAY, DorisSQLParserARRAY_AGG, DorisSQLParserARRAY_AGG_DISTINCT, DorisSQLParserASYNC, DorisSQLParserAUTHORS, DorisSQLParserAUTHENTICATION, DorisSQLParserAUTOMATED, DorisSQLParserAUTO_INCREMENT, DorisSQLParserAVG, DorisSQLParserBACKEND, DorisSQLParserBACKENDS, DorisSQLParserBACKUP, DorisSQLParserBASE, DorisSQLParserBASELINE, DorisSQLParserBEGIN, DorisSQLParserBINARY, DorisSQLParserBITMAP_UNION, DorisSQLParserBLACKHOLE, DorisSQLParserBLACKLIST, DorisSQLParserBODY, DorisSQLParserBOOLEAN, DorisSQLParserBRANCH, DorisSQLParserBROKER, DorisSQLParserBUCKETS, DorisSQLParserBUILTIN, DorisSQLParserCACHE, DorisSQLParserCANCEL, DorisSQLParserCASE, DorisSQLParserCAST, DorisSQLParserCATALOG, DorisSQLParserCATALOGS, DorisSQLParserCEIL, DorisSQLParserCHAIN, DorisSQLParserCHAR, DorisSQLParserCHARSET, DorisSQLParserCLEAN, DorisSQLParserCLEAR, DorisSQLParserCLUSTER, DorisSQLParserCLUSTERS, DorisSQLParserCNGROUP, DorisSQLParserCNGROUPS, DorisSQLParserCOLLATION, DorisSQLParserCOLUMNS, DorisSQLParserCOMMENT, DorisSQLParserCOMMIT, DorisSQLParserCOMMITTED, DorisSQLParserCOMPACT, DorisSQLParserCOMPUTE, DorisSQLParserCONFIG, DorisSQLParserCONNECTION, DorisSQLParserCONSISTENT, DorisSQLParserCONVERT, DorisSQLParserCOSTS, DorisSQLParserCOUNT, DorisSQLParserCUME_DIST, DorisSQLParserCUMULATIVE, DorisSQLParserCURRENT, DorisSQLParserCURRENT_DATE, DorisSQLParserCURRENT_GROUP, DorisSQLParserCURRENT_ROLE, DorisSQLParserCURRENT_TIME, DorisSQLParserCURRENT_TIMESTAMP, DorisSQLParserCURRENT_USER, DorisSQLParserDATA, DorisSQLParserDATACACHE, DorisSQLParserDATABASE, DorisSQLParserDATE, DorisSQLParserDATETIME, DorisSQLParserDAY, DorisSQLParserDAYS, DorisSQLParserDEALLOCATE, DorisSQLParserDECOMMISSION, DorisSQLParserDENSE_RANK, DorisSQLParserDIALECT, DorisSQLParserDICTIONARY, DorisSQLParserDICTIONARY_GET, DorisSQLParserNTILE, DorisSQLParserDISABLE, DorisSQLParserDISTRIBUTED, DorisSQLParserDISTRIBUTION, DorisSQLParserDUPLICATE, DorisSQLParserDYNAMIC, DorisSQLParserENABLE, DorisSQLParserENCLOSE, DorisSQLParserEND, DorisSQLParserENGINE, DorisSQLParserENGINES, DorisSQLParserERRORS, DorisSQLParserESCAPE, DorisSQLParserEVENTS, DorisSQLParserEXCEPT, DorisSQLParserEXCLUDE, DorisSQLParserEXECUTE, DorisSQLParserEXISTS, DorisSQLParserEXPORT, DorisSQLParserEXTERNAL, DorisSQLParserEXTRACT, DorisSQLParserEVERY, DorisSQLParserFAILPOINT, DorisSQLParserFAILPOINTS, DorisSQLParserFALSE, DorisSQLParserFIELDS, DorisSQLParserFILE, DorisSQLParserFILTER, DorisSQLParserFIRST, DorisSQLParserFIRST_VALUE, DorisSQLParserFLOOR, DorisSQLParserFN, DorisSQLParserFOLLOWING, DorisSQLParserFOLLOWER, DorisSQLParserFORMAT, DorisSQLParserFREE, DorisSQLParserFRONTEND, DorisSQLParserFRONTENDS, DorisSQLParserFUNCTIONS, DorisSQLParserGLOBAL, DorisSQLParserGRANTS, DorisSQLParserGROUPING, DorisSQLParserGROUPING_ID, DorisSQLParserGROUP_CONCAT, DorisSQLParserHASH, DorisSQLParserHELP, DorisSQLParserHISTOGRAM, DorisSQLParserHLL_UNION, DorisSQLParserHOST, DorisSQLParserHOUR, DorisSQLParserHOURS, DorisSQLParserHUB, DorisSQLParserIDENTIFIED, DorisSQLParserIF, DorisSQLParserIMPERSONATE, DorisSQLParserIMAGE, DorisSQLParserINACTIVE, DorisSQLParserINCREMENTAL, DorisSQLParserINDEXES, DorisSQLParserINSTALL, DorisSQLParserINTEGRATION, DorisSQLParserINTEGRATIONS, DorisSQLParserINTERMEDIATE, DorisSQLParserINTERVAL, DorisSQLParserOVERWRITE, DorisSQLParserISOLATION, DorisSQLParserJOB, DorisSQLParserLABEL, DorisSQLParserLAG, DorisSQLParserLAST, DorisSQLParserLAST_VALUE, DorisSQLParserLEAD, DorisSQLParserLEFT, DorisSQLParserLESS, DorisSQLParserLEVEL, DorisSQLParserLIKE, DorisSQLParserLIST, DorisSQLParserLOCAL, DorisSQLParserLOCALTIME, DorisSQLParserLOCALTIMESTAMP, DorisSQLParserLOCATION, DorisSQLParserLOCATIONS, DorisSQLParserLOGS, DorisSQLParserLOGICAL, DorisSQLParserMANUAL, DorisSQLParserMAP, DorisSQLParserMAPPING, DorisSQLParserMAPPINGS, DorisSQLParserMASKING, DorisSQLParserMATCH, DorisSQLParserMATERIALIZED, DorisSQLParserMAX, DorisSQLParserMERGE, DorisSQLParserMIN, DorisSQLParserMINUTE, DorisSQLParserMINUTES, DorisSQLParserMINUS, DorisSQLParserMETA, DorisSQLParserMOD, DorisSQLParserMODE, DorisSQLParserMODIFY, DorisSQLParserMONTH, DorisSQLParserMULTIPLE, DorisSQLParserNAME, DorisSQLParserNAMES, DorisSQLParserNEGATIVE, DorisSQLParserNGRAMBF, DorisSQLParserNO, DorisSQLParserNODE, DorisSQLParserNODES, DorisSQLParserNONE, DorisSQLParserNULL, DorisSQLParserNULLS, DorisSQLParserNUMBER, DorisSQLParserNUMERIC, DorisSQLParserOBSERVER, DorisSQLParserOF, DorisSQLParserOFF, DorisSQLParserOFFSET, DorisSQLParserONLY, DorisSQLParserOPEN, DorisSQLParserOPERATE, DorisSQLParserOPTIMIZER, DorisSQLParserOPTION, DorisSQLParserPARAMETER, DorisSQLParserPARTITIONS, DorisSQLParserPASSWORD, DorisSQLParserPATH, DorisSQLParserPAUSE, DorisSQLParserPENDING, DorisSQLParserPERCENT_RANK, DorisSQLParserPERCENTILE_UNION, DorisSQLParserPLAN, DorisSQLParserPLUGIN, DorisSQLParserPLUGINS, DorisSQLParserPIPE, DorisSQLParserPIPES, DorisSQLParserPIVOT, DorisSQLParserPOLICY, DorisSQLParserPOLICIES, DorisSQLParserPRECEDING, DorisSQLParserPREDICATE, DorisSQLParserPRIORITY, DorisSQLParserPRIVILEGES, DorisSQLParserPROBABILITY, DorisSQLParserPROC, DorisSQLParserPROCESSLIST, DorisSQLParserPROFILE, DorisSQLParserPROFILELIST, DorisSQLParserPROPERTIES, DorisSQLParserPROPERTY, DorisSQLParserPROVIDER, DorisSQLParserPROVIDERS, DorisSQLParserQUALIFY, DorisSQLParserQUARTER, DorisSQLParserQUERY, DorisSQLParserQUERIES, DorisSQLParserQUEUE, DorisSQLParserQUOTA, DorisSQLParserRANDOM, DorisSQLParserRANK, DorisSQLParserREASON, DorisSQLParserRECOVER, DorisSQLParserREFRESH, DorisSQLParserREWRITE, DorisSQLParserREGEXP, DorisSQLParserREMOVE, DorisSQLParserREPAIR, DorisSQLParserREPEATABLE, DorisSQLParserREPLACE, DorisSQLParserREPLACE_IF_NOT_NULL, DorisSQLParserREPLICA, DorisSQLParserREPOSITORY, DorisSQLParserREPOSITORIES, DorisSQLParserRESOURCE, DorisSQLParserRESOURCES, DorisSQLParserRESTORE, DorisSQLParserRESUME, DorisSQLParserRETAIN, DorisSQLParserRETENTION, DorisSQLParserRETURNS, DorisSQLParserRETRY, DorisSQLParserREVERT, DorisSQLParserRIGHT, DorisSQLParserRLIKE, DorisSQLParserROLE, DorisSQLParserROLES, DorisSQLParserROLLBACK, DorisSQLParserROLLUP, DorisSQLParserROUTINE, DorisSQLParserROW, DorisSQLParserROW_NUMBER, DorisSQLParserRULE, DorisSQLParserRULES, DorisSQLParserRUNNING, DorisSQLParserSAMPLE, DorisSQLParserSCHEDULE, DorisSQLParserSCHEDULER, DorisSQLParserSCHEMA, DorisSQLParserSECOND, DorisSQLParserSECURITY, DorisSQLParserSEMI, DorisSQLParserSEPARATOR, DorisSQLParserSERIALIZABLE, DorisSQLParserSESSION, DorisSQLParserSETS, DorisSQLParserSIGNED, DorisSQLParserSKIP_HEADER, DorisSQLParserSNAPSHOT, DorisSQLParserSNAPSHOTS, DorisSQLParserSQLBLACKLIST, DorisSQLParserSTART, DorisSQLParserSTATS, DorisSQLParserSTATUS, DorisSQLParserSTOP, DorisSQLParserSTORAGE, DorisSQLParserSTREAM, DorisSQLParserSTRING, DorisSQLParserSUBMIT, DorisSQLParserSUM, DorisSQLParserSUSPEND, DorisSQLParserSYNC, DorisSQLParserSYSTEM_TIME, DorisSQLParserSWAP, DorisSQLParserSTRUCT, DorisSQLParserTABLES, DorisSQLParserTABLET, DorisSQLParserTABLETS, DorisSQLParserTAG, DorisSQLParserTASK, DorisSQLParserTEMPORARY, DorisSQLParserTHAN, DorisSQLParserTIME, DorisSQLParserTIMES, DorisSQLParserTIMESTAMP, DorisSQLParserTIMESTAMPADD, DorisSQLParserTIMESTAMPDIFF, DorisSQLParserTRANSACTION, DorisSQLParserTRANSLATE, DorisSQLParserTRACE, DorisSQLParserTRIGGERS, DorisSQLParserTRIM_SPACE, DorisSQLParserTRUE, DorisSQLParserTRUNCATE, DorisSQLParserTYPE, DorisSQLParserTYPES, DorisSQLParserUNBOUNDED, DorisSQLParserUNCOMMITTED, DorisSQLParserUNINSTALL, DorisSQLParserUNSET, DorisSQLParserUSAGE, DorisSQLParserUSER, DorisSQLParserUSERS, DorisSQLParserVALUE, DorisSQLParserVARBINARY, DorisSQLParserVARIABLES, DorisSQLParserVECTOR, DorisSQLParserVERBOSE, DorisSQLParserVERSION, DorisSQLParserVIEW, DorisSQLParserVIEWS, DorisSQLParserVOLUME, DorisSQLParserVOLUMES, DorisSQLParserWAREHOUSE, DorisSQLParserWAREHOUSES, DorisSQLParserWARNINGS, DorisSQLParserWEEK, DorisSQLParserWHITELIST, DorisSQLParserWORK, DorisSQLParserWRITE, DorisSQLParserYEAR, DorisSQLParserLOCK, DorisSQLParserUNLOCK, DorisSQLParserLOW_PRIORITY, DorisSQLParserDISK, DorisSQLParserBEFORE, DorisSQLParserFIELD, DorisSQLParserPERSISTENT, DorisSQLParserARRAY_ELEMENT, DorisSQLParserPLUS_SYMBOL, DorisSQLParserMINUS_SYMBOL, DorisSQLParserLOGICAL_NOT, DorisSQLParserBITNOT, DorisSQLParserAT, DorisSQLParserINTEGER_VALUE, DorisSQLParserDECIMAL_VALUE, DorisSQLParserDOUBLE_VALUE, DorisSQLParserSINGLE_QUOTED_TEXT, DorisSQLParserDOUBLE_QUOTED_TEXT, DorisSQLParserBINARY_SINGLE_QUOTED_TEXT, DorisSQLParserBINARY_DOUBLE_QUOTED_TEXT, DorisSQLParserLETTER_IDENTIFIER, DorisSQLParserDIGIT_IDENTIFIER, DorisSQLParserBACKQUOTED_IDENTIFIER, DorisSQLParserDOTDOTDOT:
		localctx = NewExpressionDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		p.SetState(6628)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 770, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6627)
				p.Match(DorisSQLParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(6630)
			p.booleanExpression(0)
		}

	case DorisSQLParserNOT:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6631)
			p.Match(DorisSQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6632)
			p.expression(3)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(6643)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 773, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(6641)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 772, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLogicalBinaryContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserRULE_expression)
				p.SetState(6635)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(6636)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*LogicalBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisSQLParserAND || _la == DorisSQLParserLOGICAL_AND) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*LogicalBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(6637)

					var _x = p.expression(3)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 2:
				localctx = NewLogicalBinaryContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserRULE_expression)
				p.SetState(6638)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(6639)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*LogicalBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisSQLParserOR || _la == DorisSQLParserLOGICAL_OR) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*LogicalBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(6640)

					var _x = p.expression(2)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(6645)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 773, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_expressionList
	return p
}

func InitEmptyExpressionListContext(p *ExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_expressionList
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (s *ExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ExpressionList() (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 854, DorisSQLParserRULE_expressionList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6646)
		p.expression(0)
	}
	p.SetState(6651)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 774, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6647)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6648)
				p.expression(0)
			}

		}
		p.SetState(6653)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 774, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanExpressionContext is an interface to support dynamic dispatch.
type IBooleanExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBooleanExpressionContext differentiates from other interfaces.
	IsBooleanExpressionContext()
}

type BooleanExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanExpressionContext() *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_booleanExpression
	return p
}

func InitEmptyBooleanExpressionContext(p *BooleanExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_booleanExpression
}

func (*BooleanExpressionContext) IsBooleanExpressionContext() {}

func NewBooleanExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_booleanExpression

	return p
}

func (s *BooleanExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanExpressionContext) CopyAll(ctx *BooleanExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BooleanExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ComparisonContext struct {
	BooleanExpressionContext
	left  IBooleanExpressionContext
	right IPredicateContext
}

func NewComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonContext {
	var p = new(ComparisonContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *ComparisonContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *ComparisonContext) GetRight() IPredicateContext { return s.right }

func (s *ComparisonContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *ComparisonContext) SetRight(v IPredicateContext) { s.right = v }

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ComparisonContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitComparison(s)
	}
}

func (s *ComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitComparison(s)

	default:
		return t.VisitChildren(s)
	}
}

type BooleanExpressionDefaultContext struct {
	BooleanExpressionContext
}

func NewBooleanExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanExpressionDefaultContext {
	var p = new(BooleanExpressionDefaultContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *BooleanExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionDefaultContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BooleanExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterBooleanExpressionDefault(s)
	}
}

func (s *BooleanExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitBooleanExpressionDefault(s)
	}
}

func (s *BooleanExpressionDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitBooleanExpressionDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type IsNullContext struct {
	BooleanExpressionContext
}

func NewIsNullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsNullContext {
	var p = new(IsNullContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *IsNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsNullContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *IsNullContext) IS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIS, 0)
}

func (s *IsNullContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNULL, 0)
}

func (s *IsNullContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *IsNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterIsNull(s)
	}
}

func (s *IsNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitIsNull(s)
	}
}

func (s *IsNullContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitIsNull(s)

	default:
		return t.VisitChildren(s)
	}
}

type ScalarSubqueryContext struct {
	BooleanExpressionContext
}

func NewScalarSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ScalarSubqueryContext {
	var p = new(ScalarSubqueryContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *ScalarSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarSubqueryContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ScalarSubqueryContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ScalarSubqueryContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *ScalarSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterScalarSubquery(s)
	}
}

func (s *ScalarSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitScalarSubquery(s)
	}
}

func (s *ScalarSubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitScalarSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) BooleanExpression() (localctx IBooleanExpressionContext) {
	return p.booleanExpression(0)
}

func (p *DorisSQLParser) booleanExpression(_p int) (localctx IBooleanExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBooleanExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBooleanExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 856
	p.EnterRecursionRule(localctx, 856, DorisSQLParserRULE_booleanExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewBooleanExpressionDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(6655)
		p.Predicate()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(6675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 777, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(6673)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 776, p.GetParserRuleContext()) {
			case 1:
				localctx = NewIsNullContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserRULE_booleanExpression)
				p.SetState(6657)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(6658)
					p.Match(DorisSQLParserIS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(6660)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisSQLParserNOT {
					{
						p.SetState(6659)
						p.Match(DorisSQLParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(6662)
					p.Match(DorisSQLParserNULL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				localctx = NewComparisonContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*ComparisonContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserRULE_booleanExpression)
				p.SetState(6663)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(6664)
					p.ComparisonOperator()
				}
				{
					p.SetState(6665)

					var _x = p.Predicate()

					localctx.(*ComparisonContext).right = _x
				}

			case 3:
				localctx = NewScalarSubqueryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserRULE_booleanExpression)
				p.SetState(6667)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(6668)
					p.ComparisonOperator()
				}
				{
					p.SetState(6669)
					p.Match(DorisSQLParserT__1)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6670)
					p.QueryRelation()
				}
				{
					p.SetState(6671)
					p.Match(DorisSQLParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(6677)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 777, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_valueExpression returns the _valueExpression rule contexts.
	Get_valueExpression() IValueExpressionContext

	// Set_valueExpression sets the _valueExpression rule contexts.
	Set_valueExpression(IValueExpressionContext)

	// Getter signatures
	ValueExpression() IValueExpressionContext
	PredicateOperations() IPredicateOperationsContext
	TupleInSubquery() ITupleInSubqueryContext

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	_valueExpression IValueExpressionContext
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_predicate
	return p
}

func InitEmptyPredicateContext(p *PredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_predicate
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) Get_valueExpression() IValueExpressionContext { return s._valueExpression }

func (s *PredicateContext) Set_valueExpression(v IValueExpressionContext) { s._valueExpression = v }

func (s *PredicateContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicateContext) PredicateOperations() IPredicateOperationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateOperationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateOperationsContext)
}

func (s *PredicateContext) TupleInSubquery() ITupleInSubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleInSubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleInSubqueryContext)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPredicate(s)
	}
}

func (s *PredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPredicate(s)
	}
}

func (s *PredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Predicate() (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 858, DorisSQLParserRULE_predicate)
	p.SetState(6683)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 779, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6678)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext)._valueExpression = _x
		}
		p.SetState(6680)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 778, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6679)
				p.PredicateOperations(localctx.(*PredicateContext).Get_valueExpression())
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6682)
			p.TupleInSubquery()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleInSubqueryContext is an interface to support dynamic dispatch.
type ITupleInSubqueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	IN() antlr.TerminalNode
	QueryRelation() IQueryRelationContext
	NOT() antlr.TerminalNode

	// IsTupleInSubqueryContext differentiates from other interfaces.
	IsTupleInSubqueryContext()
}

type TupleInSubqueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleInSubqueryContext() *TupleInSubqueryContext {
	var p = new(TupleInSubqueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_tupleInSubquery
	return p
}

func InitEmptyTupleInSubqueryContext(p *TupleInSubqueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_tupleInSubquery
}

func (*TupleInSubqueryContext) IsTupleInSubqueryContext() {}

func NewTupleInSubqueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleInSubqueryContext {
	var p = new(TupleInSubqueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_tupleInSubquery

	return p
}

func (s *TupleInSubqueryContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleInSubqueryContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TupleInSubqueryContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TupleInSubqueryContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *TupleInSubqueryContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *TupleInSubqueryContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *TupleInSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleInSubqueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleInSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTupleInSubquery(s)
	}
}

func (s *TupleInSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTupleInSubquery(s)
	}
}

func (s *TupleInSubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTupleInSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) TupleInSubquery() (localctx ITupleInSubqueryContext) {
	localctx = NewTupleInSubqueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 860, DorisSQLParserRULE_tupleInSubquery)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6685)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6686)
		p.expression(0)
	}
	p.SetState(6689)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == DorisSQLParserT__2 {
		{
			p.SetState(6687)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6688)
			p.expression(0)
		}

		p.SetState(6691)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6693)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserNOT {
		{
			p.SetState(6694)
			p.Match(DorisSQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(6697)
		p.Match(DorisSQLParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6698)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6699)
		p.QueryRelation()
	}
	{
		p.SetState(6700)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateOperationsContext is an interface to support dynamic dispatch.
type IPredicateOperationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value attribute.
	GetValue() ParserRuleContext

	// SetValue sets the value attribute.
	SetValue(ParserRuleContext)

	// IsPredicateOperationsContext differentiates from other interfaces.
	IsPredicateOperationsContext()
}

type PredicateOperationsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  ParserRuleContext
}

func NewEmptyPredicateOperationsContext() *PredicateOperationsContext {
	var p = new(PredicateOperationsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_predicateOperations
	return p
}

func InitEmptyPredicateOperationsContext(p *PredicateOperationsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_predicateOperations
}

func (*PredicateOperationsContext) IsPredicateOperationsContext() {}

func NewPredicateOperationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, value ParserRuleContext) *PredicateOperationsContext {
	var p = new(PredicateOperationsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_predicateOperations

	p.value = value

	return p
}

func (s *PredicateOperationsContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateOperationsContext) GetValue() ParserRuleContext { return s.value }

func (s *PredicateOperationsContext) SetValue(v ParserRuleContext) { s.value = v }

func (s *PredicateOperationsContext) CopyAll(ctx *PredicateOperationsContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
	s.value = ctx.value
}

func (s *PredicateOperationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateOperationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LikeContext struct {
	PredicateOperationsContext
	pattern IValueExpressionContext
}

func NewLikeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikeContext {
	var p = new(LikeContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *LikeContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *LikeContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *LikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *LikeContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRLIKE, 0)
}

func (s *LikeContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREGEXP, 0)
}

func (s *LikeContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *LikeContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *LikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterLike(s)
	}
}

func (s *LikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitLike(s)
	}
}

func (s *LikeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitLike(s)

	default:
		return t.VisitChildren(s)
	}
}

type InSubqueryContext struct {
	PredicateOperationsContext
}

func NewInSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InSubqueryContext {
	var p = new(InSubqueryContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *InSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InSubqueryContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *InSubqueryContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *InSubqueryContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *InSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterInSubquery(s)
	}
}

func (s *InSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitInSubquery(s)
	}
}

func (s *InSubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitInSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

type InListContext struct {
	PredicateOperationsContext
}

func NewInListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InListContext {
	var p = new(InListContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *InListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InListContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *InListContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *InListContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *InListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterInList(s)
	}
}

func (s *InListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitInList(s)
	}
}

func (s *InListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitInList(s)

	default:
		return t.VisitChildren(s)
	}
}

type BetweenContext struct {
	PredicateOperationsContext
	lower IValueExpressionContext
	upper IPredicateContext
}

func NewBetweenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenContext {
	var p = new(BetweenContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *BetweenContext) GetLower() IValueExpressionContext { return s.lower }

func (s *BetweenContext) GetUpper() IPredicateContext { return s.upper }

func (s *BetweenContext) SetLower(v IValueExpressionContext) { s.lower = v }

func (s *BetweenContext) SetUpper(v IPredicateContext) { s.upper = v }

func (s *BetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBETWEEN, 0)
}

func (s *BetweenContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAND, 0)
}

func (s *BetweenContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *BetweenContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BetweenContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *BetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterBetween(s)
	}
}

func (s *BetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitBetween(s)
	}
}

func (s *BetweenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitBetween(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PredicateOperations(value ParserRuleContext) (localctx IPredicateOperationsContext) {
	localctx = NewPredicateOperationsContext(p, p.GetParserRuleContext(), p.GetState(), value)
	p.EnterRule(localctx, 862, DorisSQLParserRULE_predicateOperations)
	var _la int

	p.SetState(6731)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 786, p.GetParserRuleContext()) {
	case 1:
		localctx = NewInSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6703)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserNOT {
			{
				p.SetState(6702)
				p.Match(DorisSQLParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6705)
			p.Match(DorisSQLParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6706)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6707)
			p.QueryRelation()
		}
		{
			p.SetState(6708)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewInListContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(6711)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserNOT {
			{
				p.SetState(6710)
				p.Match(DorisSQLParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6713)
			p.Match(DorisSQLParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6714)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6715)
			p.ExpressionList()
		}
		{
			p.SetState(6716)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewBetweenContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(6719)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserNOT {
			{
				p.SetState(6718)
				p.Match(DorisSQLParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6721)
			p.Match(DorisSQLParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6722)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).lower = _x
		}
		{
			p.SetState(6723)
			p.Match(DorisSQLParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6724)

			var _x = p.Predicate()

			localctx.(*BetweenContext).upper = _x
		}

	case 4:
		localctx = NewLikeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(6727)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserNOT {
			{
				p.SetState(6726)
				p.Match(DorisSQLParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6729)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserLIKE || _la == DorisSQLParserREGEXP || _la == DorisSQLParserRLIKE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6730)

			var _x = p.valueExpression(0)

			localctx.(*LikeContext).pattern = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueExpressionContext is an interface to support dynamic dispatch.
type IValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsValueExpressionContext differentiates from other interfaces.
	IsValueExpressionContext()
}

type ValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExpressionContext() *ValueExpressionContext {
	var p = new(ValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_valueExpression
	return p
}

func InitEmptyValueExpressionContext(p *ValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_valueExpression
}

func (*ValueExpressionContext) IsValueExpressionContext() {}

func NewValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExpressionContext {
	var p = new(ValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_valueExpression

	return p
}

func (s *ValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExpressionContext) CopyAll(ctx *ValueExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ValueExpressionDefaultContext struct {
	ValueExpressionContext
}

func NewValueExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValueExpressionDefaultContext {
	var p = new(ValueExpressionDefaultContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ValueExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionDefaultContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ValueExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitValueExpressionDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArithmeticBinaryContext struct {
	ValueExpressionContext
	left     IValueExpressionContext
	operator antlr.Token
	right    IValueExpressionContext
}

func NewArithmeticBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticBinaryContext {
	var p = new(ArithmeticBinaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticBinaryContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ArithmeticBinaryContext) GetRight() IValueExpressionContext { return s.right }

func (s *ArithmeticBinaryContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ArithmeticBinaryContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ArithmeticBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticBinaryContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArithmeticBinaryContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticBinaryContext) BITXOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBITXOR, 0)
}

func (s *ArithmeticBinaryContext) ASTERISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserASTERISK_SYMBOL, 0)
}

func (s *ArithmeticBinaryContext) SLASH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSLASH_SYMBOL, 0)
}

func (s *ArithmeticBinaryContext) PERCENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPERCENT_SYMBOL, 0)
}

func (s *ArithmeticBinaryContext) INT_DIV() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINT_DIV, 0)
}

func (s *ArithmeticBinaryContext) MOD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMOD, 0)
}

func (s *ArithmeticBinaryContext) PLUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPLUS_SYMBOL, 0)
}

func (s *ArithmeticBinaryContext) MINUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMINUS_SYMBOL, 0)
}

func (s *ArithmeticBinaryContext) BITAND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBITAND, 0)
}

func (s *ArithmeticBinaryContext) BITOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBITOR, 0)
}

func (s *ArithmeticBinaryContext) BIT_SHIFT_LEFT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBIT_SHIFT_LEFT, 0)
}

func (s *ArithmeticBinaryContext) BIT_SHIFT_RIGHT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBIT_SHIFT_RIGHT, 0)
}

func (s *ArithmeticBinaryContext) BIT_SHIFT_RIGHT_LOGICAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBIT_SHIFT_RIGHT_LOGICAL, 0)
}

func (s *ArithmeticBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitArithmeticBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ValueExpression() (localctx IValueExpressionContext) {
	return p.valueExpression(0)
}

func (p *DorisSQLParser) valueExpression(_p int) (localctx IValueExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewValueExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 864
	p.EnterRecursionRule(localctx, 864, DorisSQLParserRULE_valueExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewValueExpressionDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(6734)
		p.primaryExpression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(6762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 788, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(6760)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 787, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserRULE_valueExpression)
				p.SetState(6736)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(6737)

					var _m = p.Match(DorisSQLParserBITXOR)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6738)

					var _x = p.valueExpression(9)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 2:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserRULE_valueExpression)
				p.SetState(6739)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(6740)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisSQLParserMOD || ((int64((_la-502)) & ^0x3f) == 0 && ((int64(1)<<(_la-502))&71) != 0)) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(6741)

					var _x = p.valueExpression(8)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 3:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserRULE_valueExpression)
				p.SetState(6742)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(6743)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisSQLParserPLUS_SYMBOL || _la == DorisSQLParserMINUS_SYMBOL) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(6744)

					var _x = p.valueExpression(7)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 4:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserRULE_valueExpression)
				p.SetState(6745)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(6746)

					var _m = p.Match(DorisSQLParserBITAND)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6747)

					var _x = p.valueExpression(6)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 5:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserRULE_valueExpression)
				p.SetState(6748)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(6749)

					var _m = p.Match(DorisSQLParserBITOR)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6750)

					var _x = p.valueExpression(5)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 6:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserRULE_valueExpression)
				p.SetState(6751)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(6752)

					var _m = p.Match(DorisSQLParserBIT_SHIFT_LEFT)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6753)

					var _x = p.valueExpression(4)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 7:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserRULE_valueExpression)
				p.SetState(6754)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(6755)

					var _m = p.Match(DorisSQLParserBIT_SHIFT_RIGHT)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6756)

					var _x = p.valueExpression(3)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 8:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserRULE_valueExpression)
				p.SetState(6757)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(6758)

					var _m = p.Match(DorisSQLParserBIT_SHIFT_RIGHT_LOGICAL)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6759)

					var _x = p.valueExpression(2)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(6764)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 788, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_primaryExpression
	return p
}

func InitEmptyPrimaryExpressionContext(p *PrimaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_primaryExpression
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) CopyAll(ctx *PrimaryExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DereferenceContext struct {
	PrimaryExpressionContext
	base      IPrimaryExpressionContext
	fieldName IIdentifierContext
}

func NewDereferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DereferenceContext {
	var p = new(DereferenceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DereferenceContext) GetBase() IPrimaryExpressionContext { return s.base }

func (s *DereferenceContext) GetFieldName() IIdentifierContext { return s.fieldName }

func (s *DereferenceContext) SetBase(v IPrimaryExpressionContext) { s.base = v }

func (s *DereferenceContext) SetFieldName(v IIdentifierContext) { s.fieldName = v }

func (s *DereferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DereferenceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *DereferenceContext) DOT_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDOT_IDENTIFIER, 0)
}

func (s *DereferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DereferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDereference(s)
	}
}

func (s *DereferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDereference(s)
	}
}

func (s *DereferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDereference(s)

	default:
		return t.VisitChildren(s)
	}
}

type OdbcFunctionCallExpressionContext struct {
	PrimaryExpressionContext
}

func NewOdbcFunctionCallExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OdbcFunctionCallExpressionContext {
	var p = new(OdbcFunctionCallExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *OdbcFunctionCallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OdbcFunctionCallExpressionContext) FN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFN, 0)
}

func (s *OdbcFunctionCallExpressionContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *OdbcFunctionCallExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterOdbcFunctionCallExpression(s)
	}
}

func (s *OdbcFunctionCallExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitOdbcFunctionCallExpression(s)
	}
}

func (s *OdbcFunctionCallExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitOdbcFunctionCallExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MatchExprContext struct {
	PrimaryExpressionContext
	left  IPrimaryExpressionContext
	right IPrimaryExpressionContext
}

func NewMatchExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MatchExprContext {
	var p = new(MatchExprContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *MatchExprContext) GetLeft() IPrimaryExpressionContext { return s.left }

func (s *MatchExprContext) GetRight() IPrimaryExpressionContext { return s.right }

func (s *MatchExprContext) SetLeft(v IPrimaryExpressionContext) { s.left = v }

func (s *MatchExprContext) SetRight(v IPrimaryExpressionContext) { s.right = v }

func (s *MatchExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchExprContext) MATCH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMATCH, 0)
}

func (s *MatchExprContext) AllPrimaryExpression() []IPrimaryExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrimaryExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrimaryExpressionContext); ok {
			tst[i] = t.(IPrimaryExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MatchExprContext) PrimaryExpression(i int) IPrimaryExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *MatchExprContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *MatchExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterMatchExpr(s)
	}
}

func (s *MatchExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitMatchExpr(s)
	}
}

func (s *MatchExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitMatchExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnRefContext struct {
	PrimaryExpressionContext
}

func NewColumnRefContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnRefContext {
	var p = new(ColumnRefContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ColumnRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnRefContext) ColumnReference() IColumnReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnReferenceContext)
}

func (s *ColumnRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterColumnRef(s)
	}
}

func (s *ColumnRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitColumnRef(s)
	}
}

func (s *ColumnRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitColumnRef(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConvertContext struct {
	PrimaryExpressionContext
}

func NewConvertContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConvertContext {
	var p = new(ConvertContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ConvertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCONVERT, 0)
}

func (s *ConvertContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConvertContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ConvertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterConvert(s)
	}
}

func (s *ConvertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitConvert(s)
	}
}

func (s *ConvertContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitConvert(s)

	default:
		return t.VisitChildren(s)
	}
}

type CollectionSubscriptContext struct {
	PrimaryExpressionContext
	value IPrimaryExpressionContext
	index IValueExpressionContext
}

func NewCollectionSubscriptContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollectionSubscriptContext {
	var p = new(CollectionSubscriptContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CollectionSubscriptContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *CollectionSubscriptContext) GetIndex() IValueExpressionContext { return s.index }

func (s *CollectionSubscriptContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *CollectionSubscriptContext) SetIndex(v IValueExpressionContext) { s.index = v }

func (s *CollectionSubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionSubscriptContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *CollectionSubscriptContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *CollectionSubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCollectionSubscript(s)
	}
}

func (s *CollectionSubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCollectionSubscript(s)
	}
}

func (s *CollectionSubscriptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCollectionSubscript(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralContext struct {
	PrimaryExpressionContext
}

func NewLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralContext {
	var p = new(LiteralContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) LiteralExpression() ILiteralExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionContext)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type CastContext struct {
	PrimaryExpressionContext
}

func NewCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastContext {
	var p = new(CastContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastContext) CAST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCAST, 0)
}

func (s *CastContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *CastContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *CastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCast(s)
	}
}

func (s *CastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCast(s)
	}
}

func (s *CastContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCast(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesizedExpressionContext struct {
	PrimaryExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitParenthesizedExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type UserVariableExpressionContext struct {
	PrimaryExpressionContext
}

func NewUserVariableExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserVariableExpressionContext {
	var p = new(UserVariableExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *UserVariableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserVariableExpressionContext) UserVariable() IUserVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariableContext)
}

func (s *UserVariableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterUserVariableExpression(s)
	}
}

func (s *UserVariableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitUserVariableExpression(s)
	}
}

func (s *UserVariableExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitUserVariableExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type FunctionCallExpressionContext struct {
	PrimaryExpressionContext
}

func NewFunctionCallExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallExpressionContext {
	var p = new(FunctionCallExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *FunctionCallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallExpressionContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *FunctionCallExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterFunctionCallExpression(s)
	}
}

func (s *FunctionCallExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitFunctionCallExpression(s)
	}
}

func (s *FunctionCallExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitFunctionCallExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleCaseContext struct {
	PrimaryExpressionContext
	caseExpr       IExpressionContext
	elseExpression IExpressionContext
}

func NewSimpleCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleCaseContext {
	var p = new(SimpleCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SimpleCaseContext) GetCaseExpr() IExpressionContext { return s.caseExpr }

func (s *SimpleCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SimpleCaseContext) SetCaseExpr(v IExpressionContext) { s.caseExpr = v }

func (s *SimpleCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SimpleCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCASE, 0)
}

func (s *SimpleCaseContext) END() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEND, 0)
}

func (s *SimpleCaseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SimpleCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserELSE, 0)
}

func (s *SimpleCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSimpleCase(s)
	}
}

func (s *SimpleCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSimpleCase(s)
	}
}

func (s *SimpleCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSimpleCase(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrowExpressionContext struct {
	PrimaryExpressionContext
}

func NewArrowExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrowExpressionContext {
	var p = new(ArrowExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArrowExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowExpressionContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ArrowExpressionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserARROW, 0)
}

func (s *ArrowExpressionContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ArrowExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterArrowExpression(s)
	}
}

func (s *ArrowExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitArrowExpression(s)
	}
}

func (s *ArrowExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitArrowExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type SystemVariableExpressionContext struct {
	PrimaryExpressionContext
}

func NewSystemVariableExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SystemVariableExpressionContext {
	var p = new(SystemVariableExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SystemVariableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SystemVariableExpressionContext) SystemVariable() ISystemVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISystemVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISystemVariableContext)
}

func (s *SystemVariableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSystemVariableExpression(s)
	}
}

func (s *SystemVariableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSystemVariableExpression(s)
	}
}

func (s *SystemVariableExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSystemVariableExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConcatContext struct {
	PrimaryExpressionContext
	left  IPrimaryExpressionContext
	right IPrimaryExpressionContext
}

func NewConcatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConcatContext {
	var p = new(ConcatContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ConcatContext) GetLeft() IPrimaryExpressionContext { return s.left }

func (s *ConcatContext) GetRight() IPrimaryExpressionContext { return s.right }

func (s *ConcatContext) SetLeft(v IPrimaryExpressionContext) { s.left = v }

func (s *ConcatContext) SetRight(v IPrimaryExpressionContext) { s.right = v }

func (s *ConcatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCONCAT, 0)
}

func (s *ConcatContext) AllPrimaryExpression() []IPrimaryExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrimaryExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrimaryExpressionContext); ok {
			tst[i] = t.(IPrimaryExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ConcatContext) PrimaryExpression(i int) IPrimaryExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ConcatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterConcat(s)
	}
}

func (s *ConcatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitConcat(s)
	}
}

func (s *ConcatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitConcat(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubqueryExpressionContext struct {
	PrimaryExpressionContext
}

func NewSubqueryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryExpressionContext {
	var p = new(SubqueryExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubqueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryExpressionContext) Subquery() ISubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *SubqueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSubqueryExpression(s)
	}
}

func (s *SubqueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSubqueryExpression(s)
	}
}

func (s *SubqueryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSubqueryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LambdaFunctionExprContext struct {
	PrimaryExpressionContext
}

func NewLambdaFunctionExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LambdaFunctionExprContext {
	var p = new(LambdaFunctionExprContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LambdaFunctionExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaFunctionExprContext) ARROW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserARROW, 0)
}

func (s *LambdaFunctionExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaFunctionExprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LambdaFunctionExprContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *LambdaFunctionExprContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *LambdaFunctionExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterLambdaFunctionExpr(s)
	}
}

func (s *LambdaFunctionExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitLambdaFunctionExpr(s)
	}
}

func (s *LambdaFunctionExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitLambdaFunctionExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type DictionaryGetExprContext struct {
	PrimaryExpressionContext
}

func NewDictionaryGetExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DictionaryGetExprContext {
	var p = new(DictionaryGetExprContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DictionaryGetExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryGetExprContext) DICTIONARY_GET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDICTIONARY_GET, 0)
}

func (s *DictionaryGetExprContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *DictionaryGetExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDictionaryGetExpr(s)
	}
}

func (s *DictionaryGetExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDictionaryGetExpr(s)
	}
}

func (s *DictionaryGetExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDictionaryGetExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type CollateContext struct {
	PrimaryExpressionContext
}

func NewCollateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollateContext {
	var p = new(CollateContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *CollateContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLLATE, 0)
}

func (s *CollateContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CollateContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CollateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCollate(s)
	}
}

func (s *CollateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCollate(s)
	}
}

func (s *CollateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCollate(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayConstructorContext struct {
	PrimaryExpressionContext
}

func NewArrayConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayConstructorContext {
	var p = new(ArrayConstructorContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArrayConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayConstructorContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *ArrayConstructorContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArrayConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitArrayConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

type MapConstructorContext struct {
	PrimaryExpressionContext
}

func NewMapConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MapConstructorContext {
	var p = new(MapConstructorContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *MapConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapConstructorContext) MapType() IMapTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapTypeContext)
}

func (s *MapConstructorContext) MapExpressionList() IMapExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapExpressionListContext)
}

func (s *MapConstructorContext) MAP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMAP, 0)
}

func (s *MapConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterMapConstructor(s)
	}
}

func (s *MapConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitMapConstructor(s)
	}
}

func (s *MapConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitMapConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArraySliceContext struct {
	PrimaryExpressionContext
	start_ antlr.Token
	end    antlr.Token
}

func NewArraySliceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArraySliceContext {
	var p = new(ArraySliceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArraySliceContext) GetStart_() antlr.Token { return s.start_ }

func (s *ArraySliceContext) GetEnd() antlr.Token { return s.end }

func (s *ArraySliceContext) SetStart_(v antlr.Token) { s.start_ = v }

func (s *ArraySliceContext) SetEnd(v antlr.Token) { s.end = v }

func (s *ArraySliceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArraySliceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ArraySliceContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserINTEGER_VALUE)
}

func (s *ArraySliceContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, i)
}

func (s *ArraySliceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterArraySlice(s)
	}
}

func (s *ArraySliceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitArraySlice(s)
	}
}

func (s *ArraySliceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitArraySlice(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExistsContext struct {
	PrimaryExpressionContext
}

func NewExistsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsContext {
	var p = new(ExistsContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *ExistsContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *ExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterExists(s)
	}
}

func (s *ExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitExists(s)
	}
}

func (s *ExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitExists(s)

	default:
		return t.VisitChildren(s)
	}
}

type SearchedCaseContext struct {
	PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSearchedCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SearchedCaseContext {
	var p = new(SearchedCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SearchedCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SearchedCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SearchedCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCASE, 0)
}

func (s *SearchedCaseContext) END() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEND, 0)
}

func (s *SearchedCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SearchedCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SearchedCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserELSE, 0)
}

func (s *SearchedCaseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SearchedCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSearchedCase(s)
	}
}

func (s *SearchedCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSearchedCase(s)
	}
}

func (s *SearchedCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSearchedCase(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArithmeticUnaryContext struct {
	PrimaryExpressionContext
	operator antlr.Token
}

func NewArithmeticUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticUnaryContext {
	var p = new(ArithmeticUnaryContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArithmeticUnaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticUnaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticUnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticUnaryContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ArithmeticUnaryContext) MINUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMINUS_SYMBOL, 0)
}

func (s *ArithmeticUnaryContext) PLUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPLUS_SYMBOL, 0)
}

func (s *ArithmeticUnaryContext) BITNOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBITNOT, 0)
}

func (s *ArithmeticUnaryContext) LOGICAL_NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOGICAL_NOT, 0)
}

func (s *ArithmeticUnaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitArithmeticUnary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	return p.primaryExpression(0)
}

func (p *DorisSQLParser) primaryExpression(_p int) (localctx IPrimaryExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 866
	p.EnterRecursionRule(localctx, 866, DorisSQLParserRULE_primaryExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6870)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 799, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUserVariableExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(6766)
			p.UserVariable()
		}

	case 2:
		localctx = NewSystemVariableExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6767)
			p.SystemVariable()
		}

	case 3:
		localctx = NewDictionaryGetExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6768)
			p.Match(DorisSQLParserDICTIONARY_GET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6769)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6770)
			p.ExpressionList()
		}
		{
			p.SetState(6771)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewFunctionCallExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6773)
			p.FunctionCall()
		}

	case 5:
		localctx = NewOdbcFunctionCallExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6774)
			p.Match(DorisSQLParserT__8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6775)
			p.Match(DorisSQLParserFN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6776)
			p.FunctionCall()
		}
		{
			p.SetState(6777)
			p.Match(DorisSQLParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6779)
			p.LiteralExpression()
		}

	case 7:
		localctx = NewColumnRefContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6780)
			p.ColumnReference()
		}

	case 8:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6781)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ArithmeticUnaryContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-500)) & ^0x3f) == 0 && ((int64(1)<<(_la-500))&4099) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ArithmeticUnaryContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6782)
			p.primaryExpression(18)
		}

	case 9:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6783)

			var _m = p.Match(DorisSQLParserLOGICAL_NOT)

			localctx.(*ArithmeticUnaryContext).operator = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6784)
			p.primaryExpression(17)
		}

	case 10:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6785)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6786)
			p.expression(0)
		}
		{
			p.SetState(6787)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewExistsContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6789)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6790)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6791)
			p.QueryRelation()
		}
		{
			p.SetState(6792)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewSubqueryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6794)
			p.Subquery()
		}

	case 13:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6795)
			p.Match(DorisSQLParserCAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6796)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6797)
			p.expression(0)
		}
		{
			p.SetState(6798)
			p.Match(DorisSQLParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6799)
			p.Type_()
		}
		{
			p.SetState(6800)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		localctx = NewConvertContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6802)
			p.Match(DorisSQLParserCONVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6803)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6804)
			p.expression(0)
		}
		{
			p.SetState(6805)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6806)
			p.Type_()
		}
		{
			p.SetState(6807)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		localctx = NewSimpleCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6809)
			p.Match(DorisSQLParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6810)

			var _x = p.expression(0)

			localctx.(*SimpleCaseContext).caseExpr = _x
		}
		p.SetState(6812)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == DorisSQLParserWHEN {
			{
				p.SetState(6811)
				p.WhenClause()
			}

			p.SetState(6814)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(6818)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserELSE {
			{
				p.SetState(6816)
				p.Match(DorisSQLParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6817)

				var _x = p.expression(0)

				localctx.(*SimpleCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(6820)
			p.Match(DorisSQLParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		localctx = NewSearchedCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6822)
			p.Match(DorisSQLParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6824)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == DorisSQLParserWHEN {
			{
				p.SetState(6823)
				p.WhenClause()
			}

			p.SetState(6826)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(6830)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserELSE {
			{
				p.SetState(6828)
				p.Match(DorisSQLParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6829)

				var _x = p.expression(0)

				localctx.(*SearchedCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(6832)
			p.Match(DorisSQLParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		localctx = NewArrayConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(6835)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserARRAY {
			{
				p.SetState(6834)
				p.ArrayType()
			}

		}
		{
			p.SetState(6837)
			p.Match(DorisSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6839)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(6838)
				p.ExpressionList()
			}

		}
		{
			p.SetState(6841)
			p.Match(DorisSQLParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		localctx = NewMapConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6842)
			p.MapType()
		}
		{
			p.SetState(6843)
			p.Match(DorisSQLParserT__8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6845)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(6844)
				p.MapExpressionList()
			}

		}
		{
			p.SetState(6847)
			p.Match(DorisSQLParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		localctx = NewMapConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6849)
			p.Match(DorisSQLParserMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6850)
			p.Match(DorisSQLParserT__8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6852)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(6851)
				p.MapExpressionList()
			}

		}
		{
			p.SetState(6854)
			p.Match(DorisSQLParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		localctx = NewLambdaFunctionExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(6857)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserACCESS, DorisSQLParserACTIVE, DorisSQLParserADMIN, DorisSQLParserADVISOR, DorisSQLParserAFTER, DorisSQLParserAGGREGATE, DorisSQLParserANTI, DorisSQLParserAPPLY, DorisSQLParserARRAY_AGG, DorisSQLParserARRAY_AGG_DISTINCT, DorisSQLParserASYNC, DorisSQLParserAUTHORS, DorisSQLParserAUTHENTICATION, DorisSQLParserAUTOMATED, DorisSQLParserAUTO_INCREMENT, DorisSQLParserAVG, DorisSQLParserBACKEND, DorisSQLParserBACKENDS, DorisSQLParserBACKUP, DorisSQLParserBASE, DorisSQLParserBASELINE, DorisSQLParserBEGIN, DorisSQLParserBINARY, DorisSQLParserBITMAP_UNION, DorisSQLParserBLACKHOLE, DorisSQLParserBLACKLIST, DorisSQLParserBODY, DorisSQLParserBOOLEAN, DorisSQLParserBRANCH, DorisSQLParserBROKER, DorisSQLParserBUCKETS, DorisSQLParserBUILTIN, DorisSQLParserCACHE, DorisSQLParserCANCEL, DorisSQLParserCAST, DorisSQLParserCATALOG, DorisSQLParserCATALOGS, DorisSQLParserCEIL, DorisSQLParserCHAIN, DorisSQLParserCHARSET, DorisSQLParserCLEAN, DorisSQLParserCLEAR, DorisSQLParserCLUSTER, DorisSQLParserCLUSTERS, DorisSQLParserCNGROUP, DorisSQLParserCNGROUPS, DorisSQLParserCOLLATION, DorisSQLParserCOLUMNS, DorisSQLParserCOMMENT, DorisSQLParserCOMMIT, DorisSQLParserCOMMITTED, DorisSQLParserCOMPACT, DorisSQLParserCOMPUTE, DorisSQLParserCONFIG, DorisSQLParserCONNECTION, DorisSQLParserCONSISTENT, DorisSQLParserCOSTS, DorisSQLParserCOUNT, DorisSQLParserCUME_DIST, DorisSQLParserCUMULATIVE, DorisSQLParserCURRENT, DorisSQLParserDATA, DorisSQLParserDATACACHE, DorisSQLParserDATE, DorisSQLParserDATETIME, DorisSQLParserDAY, DorisSQLParserDAYS, DorisSQLParserDEALLOCATE, DorisSQLParserDECOMMISSION, DorisSQLParserDIALECT, DorisSQLParserDICTIONARY, DorisSQLParserDICTIONARY_GET, DorisSQLParserDISABLE, DorisSQLParserDISTRIBUTED, DorisSQLParserDISTRIBUTION, DorisSQLParserDUPLICATE, DorisSQLParserDYNAMIC, DorisSQLParserENABLE, DorisSQLParserENCLOSE, DorisSQLParserEND, DorisSQLParserENGINE, DorisSQLParserENGINES, DorisSQLParserERRORS, DorisSQLParserESCAPE, DorisSQLParserEVENTS, DorisSQLParserEXCEPT, DorisSQLParserEXCLUDE, DorisSQLParserEXECUTE, DorisSQLParserEXPORT, DorisSQLParserEXTERNAL, DorisSQLParserEXTRACT, DorisSQLParserEVERY, DorisSQLParserFAILPOINT, DorisSQLParserFAILPOINTS, DorisSQLParserFIELDS, DorisSQLParserFILE, DorisSQLParserFILTER, DorisSQLParserFIRST, DorisSQLParserFLOOR, DorisSQLParserFN, DorisSQLParserFOLLOWING, DorisSQLParserFOLLOWER, DorisSQLParserFORMAT, DorisSQLParserFREE, DorisSQLParserFRONTEND, DorisSQLParserFRONTENDS, DorisSQLParserFUNCTIONS, DorisSQLParserGLOBAL, DorisSQLParserGRANTS, DorisSQLParserGROUP_CONCAT, DorisSQLParserHASH, DorisSQLParserHELP, DorisSQLParserHISTOGRAM, DorisSQLParserHLL_UNION, DorisSQLParserHOST, DorisSQLParserHOUR, DorisSQLParserHOURS, DorisSQLParserHUB, DorisSQLParserIDENTIFIED, DorisSQLParserIMPERSONATE, DorisSQLParserIMAGE, DorisSQLParserINACTIVE, DorisSQLParserINCREMENTAL, DorisSQLParserINDEXES, DorisSQLParserINSTALL, DorisSQLParserINTEGRATION, DorisSQLParserINTEGRATIONS, DorisSQLParserINTERMEDIATE, DorisSQLParserINTERVAL, DorisSQLParserOVERWRITE, DorisSQLParserISOLATION, DorisSQLParserJOB, DorisSQLParserLABEL, DorisSQLParserLAST, DorisSQLParserLESS, DorisSQLParserLEVEL, DorisSQLParserLIST, DorisSQLParserLOCAL, DorisSQLParserLOCATION, DorisSQLParserLOCATIONS, DorisSQLParserLOGS, DorisSQLParserLOGICAL, DorisSQLParserMANUAL, DorisSQLParserMAP, DorisSQLParserMAPPING, DorisSQLParserMAPPINGS, DorisSQLParserMASKING, DorisSQLParserMATCH, DorisSQLParserMATERIALIZED, DorisSQLParserMAX, DorisSQLParserMERGE, DorisSQLParserMIN, DorisSQLParserMINUTE, DorisSQLParserMINUTES, DorisSQLParserMINUS, DorisSQLParserMETA, DorisSQLParserMODE, DorisSQLParserMODIFY, DorisSQLParserMONTH, DorisSQLParserMULTIPLE, DorisSQLParserNAME, DorisSQLParserNAMES, DorisSQLParserNEGATIVE, DorisSQLParserNGRAMBF, DorisSQLParserNO, DorisSQLParserNODE, DorisSQLParserNODES, DorisSQLParserNONE, DorisSQLParserNULLS, DorisSQLParserNUMBER, DorisSQLParserNUMERIC, DorisSQLParserOBSERVER, DorisSQLParserOF, DorisSQLParserOFF, DorisSQLParserOFFSET, DorisSQLParserONLY, DorisSQLParserOPEN, DorisSQLParserOPERATE, DorisSQLParserOPTIMIZER, DorisSQLParserOPTION, DorisSQLParserPARTITIONS, DorisSQLParserPASSWORD, DorisSQLParserPATH, DorisSQLParserPAUSE, DorisSQLParserPENDING, DorisSQLParserPERCENT_RANK, DorisSQLParserPERCENTILE_UNION, DorisSQLParserPLAN, DorisSQLParserPLUGIN, DorisSQLParserPLUGINS, DorisSQLParserPIPE, DorisSQLParserPIPES, DorisSQLParserPIVOT, DorisSQLParserPOLICY, DorisSQLParserPOLICIES, DorisSQLParserPRECEDING, DorisSQLParserPREDICATE, DorisSQLParserPRIORITY, DorisSQLParserPRIVILEGES, DorisSQLParserPROBABILITY, DorisSQLParserPROC, DorisSQLParserPROCESSLIST, DorisSQLParserPROFILE, DorisSQLParserPROFILELIST, DorisSQLParserPROPERTIES, DorisSQLParserPROPERTY, DorisSQLParserPROVIDER, DorisSQLParserPROVIDERS, DorisSQLParserQUALIFY, DorisSQLParserQUARTER, DorisSQLParserQUERY, DorisSQLParserQUERIES, DorisSQLParserQUEUE, DorisSQLParserQUOTA, DorisSQLParserRANDOM, DorisSQLParserRANK, DorisSQLParserREASON, DorisSQLParserRECOVER, DorisSQLParserREFRESH, DorisSQLParserREWRITE, DorisSQLParserREMOVE, DorisSQLParserREPAIR, DorisSQLParserREPEATABLE, DorisSQLParserREPLACE_IF_NOT_NULL, DorisSQLParserREPLICA, DorisSQLParserREPOSITORY, DorisSQLParserREPOSITORIES, DorisSQLParserRESOURCE, DorisSQLParserRESOURCES, DorisSQLParserRESTORE, DorisSQLParserRESUME, DorisSQLParserRETAIN, DorisSQLParserRETENTION, DorisSQLParserRETURNS, DorisSQLParserRETRY, DorisSQLParserREVERT, DorisSQLParserROLE, DorisSQLParserROLES, DorisSQLParserROLLBACK, DorisSQLParserROLLUP, DorisSQLParserROUTINE, DorisSQLParserROW, DorisSQLParserRULE, DorisSQLParserRULES, DorisSQLParserRUNNING, DorisSQLParserSAMPLE, DorisSQLParserSCHEDULE, DorisSQLParserSCHEDULER, DorisSQLParserSECOND, DorisSQLParserSECURITY, DorisSQLParserSEMI, DorisSQLParserSEPARATOR, DorisSQLParserSERIALIZABLE, DorisSQLParserSESSION, DorisSQLParserSETS, DorisSQLParserSIGNED, DorisSQLParserSKIP_HEADER, DorisSQLParserSNAPSHOT, DorisSQLParserSNAPSHOTS, DorisSQLParserSQLBLACKLIST, DorisSQLParserSTART, DorisSQLParserSTATS, DorisSQLParserSTATUS, DorisSQLParserSTOP, DorisSQLParserSTORAGE, DorisSQLParserSTREAM, DorisSQLParserSTRING, DorisSQLParserSUBMIT, DorisSQLParserSUM, DorisSQLParserSUSPEND, DorisSQLParserSYNC, DorisSQLParserSYSTEM_TIME, DorisSQLParserSWAP, DorisSQLParserSTRUCT, DorisSQLParserTABLES, DorisSQLParserTABLET, DorisSQLParserTABLETS, DorisSQLParserTAG, DorisSQLParserTASK, DorisSQLParserTEMPORARY, DorisSQLParserTHAN, DorisSQLParserTIME, DorisSQLParserTIMES, DorisSQLParserTIMESTAMP, DorisSQLParserTIMESTAMPADD, DorisSQLParserTIMESTAMPDIFF, DorisSQLParserTRANSACTION, DorisSQLParserTRANSLATE, DorisSQLParserTRACE, DorisSQLParserTRIGGERS, DorisSQLParserTRIM_SPACE, DorisSQLParserTRUNCATE, DorisSQLParserTYPE, DorisSQLParserTYPES, DorisSQLParserUNBOUNDED, DorisSQLParserUNCOMMITTED, DorisSQLParserUNINSTALL, DorisSQLParserUNSET, DorisSQLParserUSAGE, DorisSQLParserUSER, DorisSQLParserUSERS, DorisSQLParserVALUE, DorisSQLParserVARBINARY, DorisSQLParserVARIABLES, DorisSQLParserVECTOR, DorisSQLParserVERBOSE, DorisSQLParserVERSION, DorisSQLParserVIEW, DorisSQLParserVIEWS, DorisSQLParserVOLUME, DorisSQLParserVOLUMES, DorisSQLParserWAREHOUSE, DorisSQLParserWAREHOUSES, DorisSQLParserWARNINGS, DorisSQLParserWEEK, DorisSQLParserWHITELIST, DorisSQLParserWORK, DorisSQLParserWRITE, DorisSQLParserYEAR, DorisSQLParserLOCK, DorisSQLParserUNLOCK, DorisSQLParserLOW_PRIORITY, DorisSQLParserDISK, DorisSQLParserBEFORE, DorisSQLParserFIELD, DorisSQLParserPERSISTENT, DorisSQLParserARRAY_ELEMENT, DorisSQLParserLETTER_IDENTIFIER, DorisSQLParserDIGIT_IDENTIFIER, DorisSQLParserBACKQUOTED_IDENTIFIER, DorisSQLParserDOTDOTDOT:
			{
				p.SetState(6855)
				p.Identifier()
			}

		case DorisSQLParserT__1:
			{
				p.SetState(6856)
				p.IdentifierList()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(6859)
			p.Match(DorisSQLParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6860)
			p.expression(0)
		}

	case 21:
		localctx = NewLambdaFunctionExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6862)
			p.IdentifierList()
		}
		{
			p.SetState(6863)
			p.Match(DorisSQLParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6864)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6866)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(6865)
				p.ExpressionList()
			}

		}
		{
			p.SetState(6868)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(6913)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 806, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(6911)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 805, p.GetParserRuleContext()) {
			case 1:
				localctx = NewConcatContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*ConcatContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserRULE_primaryExpression)
				p.SetState(6872)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
					goto errorExit
				}
				{
					p.SetState(6873)
					p.Match(DorisSQLParserCONCAT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6874)

					var _x = p.primaryExpression(20)

					localctx.(*ConcatContext).right = _x
				}

			case 2:
				localctx = NewMatchExprContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*MatchExprContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserRULE_primaryExpression)
				p.SetState(6875)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				p.SetState(6877)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisSQLParserNOT {
					{
						p.SetState(6876)
						p.Match(DorisSQLParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(6879)
					p.Match(DorisSQLParserMATCH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6880)

					var _x = p.primaryExpression(2)

					localctx.(*MatchExprContext).right = _x
				}

			case 3:
				localctx = NewCollateContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserRULE_primaryExpression)
				p.SetState(6881)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
					goto errorExit
				}
				{
					p.SetState(6882)
					p.Match(DorisSQLParserCOLLATE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(6885)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DorisSQLParserACCESS, DorisSQLParserACTIVE, DorisSQLParserADMIN, DorisSQLParserADVISOR, DorisSQLParserAFTER, DorisSQLParserAGGREGATE, DorisSQLParserANTI, DorisSQLParserAPPLY, DorisSQLParserARRAY_AGG, DorisSQLParserARRAY_AGG_DISTINCT, DorisSQLParserASYNC, DorisSQLParserAUTHORS, DorisSQLParserAUTHENTICATION, DorisSQLParserAUTOMATED, DorisSQLParserAUTO_INCREMENT, DorisSQLParserAVG, DorisSQLParserBACKEND, DorisSQLParserBACKENDS, DorisSQLParserBACKUP, DorisSQLParserBASE, DorisSQLParserBASELINE, DorisSQLParserBEGIN, DorisSQLParserBINARY, DorisSQLParserBITMAP_UNION, DorisSQLParserBLACKHOLE, DorisSQLParserBLACKLIST, DorisSQLParserBODY, DorisSQLParserBOOLEAN, DorisSQLParserBRANCH, DorisSQLParserBROKER, DorisSQLParserBUCKETS, DorisSQLParserBUILTIN, DorisSQLParserCACHE, DorisSQLParserCANCEL, DorisSQLParserCAST, DorisSQLParserCATALOG, DorisSQLParserCATALOGS, DorisSQLParserCEIL, DorisSQLParserCHAIN, DorisSQLParserCHARSET, DorisSQLParserCLEAN, DorisSQLParserCLEAR, DorisSQLParserCLUSTER, DorisSQLParserCLUSTERS, DorisSQLParserCNGROUP, DorisSQLParserCNGROUPS, DorisSQLParserCOLLATION, DorisSQLParserCOLUMNS, DorisSQLParserCOMMENT, DorisSQLParserCOMMIT, DorisSQLParserCOMMITTED, DorisSQLParserCOMPACT, DorisSQLParserCOMPUTE, DorisSQLParserCONFIG, DorisSQLParserCONNECTION, DorisSQLParserCONSISTENT, DorisSQLParserCOSTS, DorisSQLParserCOUNT, DorisSQLParserCUME_DIST, DorisSQLParserCUMULATIVE, DorisSQLParserCURRENT, DorisSQLParserDATA, DorisSQLParserDATACACHE, DorisSQLParserDATE, DorisSQLParserDATETIME, DorisSQLParserDAY, DorisSQLParserDAYS, DorisSQLParserDEALLOCATE, DorisSQLParserDECOMMISSION, DorisSQLParserDIALECT, DorisSQLParserDICTIONARY, DorisSQLParserDICTIONARY_GET, DorisSQLParserDISABLE, DorisSQLParserDISTRIBUTED, DorisSQLParserDISTRIBUTION, DorisSQLParserDUPLICATE, DorisSQLParserDYNAMIC, DorisSQLParserENABLE, DorisSQLParserENCLOSE, DorisSQLParserEND, DorisSQLParserENGINE, DorisSQLParserENGINES, DorisSQLParserERRORS, DorisSQLParserESCAPE, DorisSQLParserEVENTS, DorisSQLParserEXCEPT, DorisSQLParserEXCLUDE, DorisSQLParserEXECUTE, DorisSQLParserEXPORT, DorisSQLParserEXTERNAL, DorisSQLParserEXTRACT, DorisSQLParserEVERY, DorisSQLParserFAILPOINT, DorisSQLParserFAILPOINTS, DorisSQLParserFIELDS, DorisSQLParserFILE, DorisSQLParserFILTER, DorisSQLParserFIRST, DorisSQLParserFLOOR, DorisSQLParserFN, DorisSQLParserFOLLOWING, DorisSQLParserFOLLOWER, DorisSQLParserFORMAT, DorisSQLParserFREE, DorisSQLParserFRONTEND, DorisSQLParserFRONTENDS, DorisSQLParserFUNCTIONS, DorisSQLParserGLOBAL, DorisSQLParserGRANTS, DorisSQLParserGROUP_CONCAT, DorisSQLParserHASH, DorisSQLParserHELP, DorisSQLParserHISTOGRAM, DorisSQLParserHLL_UNION, DorisSQLParserHOST, DorisSQLParserHOUR, DorisSQLParserHOURS, DorisSQLParserHUB, DorisSQLParserIDENTIFIED, DorisSQLParserIMPERSONATE, DorisSQLParserIMAGE, DorisSQLParserINACTIVE, DorisSQLParserINCREMENTAL, DorisSQLParserINDEXES, DorisSQLParserINSTALL, DorisSQLParserINTEGRATION, DorisSQLParserINTEGRATIONS, DorisSQLParserINTERMEDIATE, DorisSQLParserINTERVAL, DorisSQLParserOVERWRITE, DorisSQLParserISOLATION, DorisSQLParserJOB, DorisSQLParserLABEL, DorisSQLParserLAST, DorisSQLParserLESS, DorisSQLParserLEVEL, DorisSQLParserLIST, DorisSQLParserLOCAL, DorisSQLParserLOCATION, DorisSQLParserLOCATIONS, DorisSQLParserLOGS, DorisSQLParserLOGICAL, DorisSQLParserMANUAL, DorisSQLParserMAP, DorisSQLParserMAPPING, DorisSQLParserMAPPINGS, DorisSQLParserMASKING, DorisSQLParserMATCH, DorisSQLParserMATERIALIZED, DorisSQLParserMAX, DorisSQLParserMERGE, DorisSQLParserMIN, DorisSQLParserMINUTE, DorisSQLParserMINUTES, DorisSQLParserMINUS, DorisSQLParserMETA, DorisSQLParserMODE, DorisSQLParserMODIFY, DorisSQLParserMONTH, DorisSQLParserMULTIPLE, DorisSQLParserNAME, DorisSQLParserNAMES, DorisSQLParserNEGATIVE, DorisSQLParserNGRAMBF, DorisSQLParserNO, DorisSQLParserNODE, DorisSQLParserNODES, DorisSQLParserNONE, DorisSQLParserNULLS, DorisSQLParserNUMBER, DorisSQLParserNUMERIC, DorisSQLParserOBSERVER, DorisSQLParserOF, DorisSQLParserOFF, DorisSQLParserOFFSET, DorisSQLParserONLY, DorisSQLParserOPEN, DorisSQLParserOPERATE, DorisSQLParserOPTIMIZER, DorisSQLParserOPTION, DorisSQLParserPARTITIONS, DorisSQLParserPASSWORD, DorisSQLParserPATH, DorisSQLParserPAUSE, DorisSQLParserPENDING, DorisSQLParserPERCENT_RANK, DorisSQLParserPERCENTILE_UNION, DorisSQLParserPLAN, DorisSQLParserPLUGIN, DorisSQLParserPLUGINS, DorisSQLParserPIPE, DorisSQLParserPIPES, DorisSQLParserPIVOT, DorisSQLParserPOLICY, DorisSQLParserPOLICIES, DorisSQLParserPRECEDING, DorisSQLParserPREDICATE, DorisSQLParserPRIORITY, DorisSQLParserPRIVILEGES, DorisSQLParserPROBABILITY, DorisSQLParserPROC, DorisSQLParserPROCESSLIST, DorisSQLParserPROFILE, DorisSQLParserPROFILELIST, DorisSQLParserPROPERTIES, DorisSQLParserPROPERTY, DorisSQLParserPROVIDER, DorisSQLParserPROVIDERS, DorisSQLParserQUALIFY, DorisSQLParserQUARTER, DorisSQLParserQUERY, DorisSQLParserQUERIES, DorisSQLParserQUEUE, DorisSQLParserQUOTA, DorisSQLParserRANDOM, DorisSQLParserRANK, DorisSQLParserREASON, DorisSQLParserRECOVER, DorisSQLParserREFRESH, DorisSQLParserREWRITE, DorisSQLParserREMOVE, DorisSQLParserREPAIR, DorisSQLParserREPEATABLE, DorisSQLParserREPLACE_IF_NOT_NULL, DorisSQLParserREPLICA, DorisSQLParserREPOSITORY, DorisSQLParserREPOSITORIES, DorisSQLParserRESOURCE, DorisSQLParserRESOURCES, DorisSQLParserRESTORE, DorisSQLParserRESUME, DorisSQLParserRETAIN, DorisSQLParserRETENTION, DorisSQLParserRETURNS, DorisSQLParserRETRY, DorisSQLParserREVERT, DorisSQLParserROLE, DorisSQLParserROLES, DorisSQLParserROLLBACK, DorisSQLParserROLLUP, DorisSQLParserROUTINE, DorisSQLParserROW, DorisSQLParserRULE, DorisSQLParserRULES, DorisSQLParserRUNNING, DorisSQLParserSAMPLE, DorisSQLParserSCHEDULE, DorisSQLParserSCHEDULER, DorisSQLParserSECOND, DorisSQLParserSECURITY, DorisSQLParserSEMI, DorisSQLParserSEPARATOR, DorisSQLParserSERIALIZABLE, DorisSQLParserSESSION, DorisSQLParserSETS, DorisSQLParserSIGNED, DorisSQLParserSKIP_HEADER, DorisSQLParserSNAPSHOT, DorisSQLParserSNAPSHOTS, DorisSQLParserSQLBLACKLIST, DorisSQLParserSTART, DorisSQLParserSTATS, DorisSQLParserSTATUS, DorisSQLParserSTOP, DorisSQLParserSTORAGE, DorisSQLParserSTREAM, DorisSQLParserSTRING, DorisSQLParserSUBMIT, DorisSQLParserSUM, DorisSQLParserSUSPEND, DorisSQLParserSYNC, DorisSQLParserSYSTEM_TIME, DorisSQLParserSWAP, DorisSQLParserSTRUCT, DorisSQLParserTABLES, DorisSQLParserTABLET, DorisSQLParserTABLETS, DorisSQLParserTAG, DorisSQLParserTASK, DorisSQLParserTEMPORARY, DorisSQLParserTHAN, DorisSQLParserTIME, DorisSQLParserTIMES, DorisSQLParserTIMESTAMP, DorisSQLParserTIMESTAMPADD, DorisSQLParserTIMESTAMPDIFF, DorisSQLParserTRANSACTION, DorisSQLParserTRANSLATE, DorisSQLParserTRACE, DorisSQLParserTRIGGERS, DorisSQLParserTRIM_SPACE, DorisSQLParserTRUNCATE, DorisSQLParserTYPE, DorisSQLParserTYPES, DorisSQLParserUNBOUNDED, DorisSQLParserUNCOMMITTED, DorisSQLParserUNINSTALL, DorisSQLParserUNSET, DorisSQLParserUSAGE, DorisSQLParserUSER, DorisSQLParserUSERS, DorisSQLParserVALUE, DorisSQLParserVARBINARY, DorisSQLParserVARIABLES, DorisSQLParserVECTOR, DorisSQLParserVERBOSE, DorisSQLParserVERSION, DorisSQLParserVIEW, DorisSQLParserVIEWS, DorisSQLParserVOLUME, DorisSQLParserVOLUMES, DorisSQLParserWAREHOUSE, DorisSQLParserWAREHOUSES, DorisSQLParserWARNINGS, DorisSQLParserWEEK, DorisSQLParserWHITELIST, DorisSQLParserWORK, DorisSQLParserWRITE, DorisSQLParserYEAR, DorisSQLParserLOCK, DorisSQLParserUNLOCK, DorisSQLParserLOW_PRIORITY, DorisSQLParserDISK, DorisSQLParserBEFORE, DorisSQLParserFIELD, DorisSQLParserPERSISTENT, DorisSQLParserARRAY_ELEMENT, DorisSQLParserLETTER_IDENTIFIER, DorisSQLParserDIGIT_IDENTIFIER, DorisSQLParserBACKQUOTED_IDENTIFIER, DorisSQLParserDOTDOTDOT:
					{
						p.SetState(6883)
						p.Identifier()
					}

				case DorisSQLParserSINGLE_QUOTED_TEXT, DorisSQLParserDOUBLE_QUOTED_TEXT:
					{
						p.SetState(6884)
						p.String_()
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			case 4:
				localctx = NewDereferenceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*DereferenceContext).base = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserRULE_primaryExpression)
				p.SetState(6887)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
					goto errorExit
				}
				p.SetState(6891)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DorisSQLParserDOT_IDENTIFIER:
					{
						p.SetState(6888)
						p.Match(DorisSQLParserDOT_IDENTIFIER)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case DorisSQLParserT__0:
					{
						p.SetState(6889)
						p.Match(DorisSQLParserT__0)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(6890)

						var _x = p.Identifier()

						localctx.(*DereferenceContext).fieldName = _x
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			case 5:
				localctx = NewCollectionSubscriptContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*CollectionSubscriptContext).value = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserRULE_primaryExpression)
				p.SetState(6893)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(6894)
					p.Match(DorisSQLParserT__5)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6895)

					var _x = p.valueExpression(0)

					localctx.(*CollectionSubscriptContext).index = _x
				}
				{
					p.SetState(6896)
					p.Match(DorisSQLParserT__6)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 6:
				localctx = NewArraySliceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserRULE_primaryExpression)
				p.SetState(6898)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(6899)
					p.Match(DorisSQLParserT__5)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(6901)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisSQLParserINTEGER_VALUE {
					{
						p.SetState(6900)

						var _m = p.Match(DorisSQLParserINTEGER_VALUE)

						localctx.(*ArraySliceContext).start_ = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(6903)
					p.Match(DorisSQLParserT__7)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(6905)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisSQLParserINTEGER_VALUE {
					{
						p.SetState(6904)

						var _m = p.Match(DorisSQLParserINTEGER_VALUE)

						localctx.(*ArraySliceContext).end = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(6907)
					p.Match(DorisSQLParserT__6)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 7:
				localctx = NewArrowExpressionContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserRULE_primaryExpression)
				p.SetState(6908)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(6909)
					p.Match(DorisSQLParserARROW)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6910)
					p.String_()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(6915)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 806, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralExpressionContext is an interface to support dynamic dispatch.
type ILiteralExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLiteralExpressionContext differentiates from other interfaces.
	IsLiteralExpressionContext()
}

type LiteralExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralExpressionContext() *LiteralExpressionContext {
	var p = new(LiteralExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_literalExpression
	return p
}

func InitEmptyLiteralExpressionContext(p *LiteralExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_literalExpression
}

func (*LiteralExpressionContext) IsLiteralExpressionContext() {}

func NewLiteralExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralExpressionContext {
	var p = new(LiteralExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_literalExpression

	return p
}

func (s *LiteralExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralExpressionContext) CopyAll(ctx *LiteralExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BinaryLiteralContext struct {
	LiteralExpressionContext
}

func NewBinaryLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryLiteralContext {
	var p = new(BinaryLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *BinaryLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryLiteralContext) Binary() IBinaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBinaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBinaryContext)
}

func (s *BinaryLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterBinaryLiteral(s)
	}
}

func (s *BinaryLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitBinaryLiteral(s)
	}
}

func (s *BinaryLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitBinaryLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type NullLiteralContext struct {
	LiteralExpressionContext
}

func NewNullLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralContext {
	var p = new(NullLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNULL, 0)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

func (s *NullLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitNullLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type StringLiteralContext struct {
	LiteralExpressionContext
}

func NewStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralContext {
	var p = new(StringLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (s *StringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParameterContext struct {
	LiteralExpressionContext
}

func NewParameterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParameterContext {
	var p = new(ParameterContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) PARAMETER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPARAMETER, 0)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (s *ParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

type DateLiteralContext struct {
	LiteralExpressionContext
}

func NewDateLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DateLiteralContext {
	var p = new(DateLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *DateLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateLiteralContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DateLiteralContext) DATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATE, 0)
}

func (s *DateLiteralContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATETIME, 0)
}

func (s *DateLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDateLiteral(s)
	}
}

func (s *DateLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDateLiteral(s)
	}
}

func (s *DateLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDateLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type BooleanLiteralContext struct {
	LiteralExpressionContext
}

func NewBooleanLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) BooleanValue() IBooleanValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitBooleanLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type NumericLiteralContext struct {
	LiteralExpressionContext
}

func NewNumericLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitNumericLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntervalLiteralContext struct {
	LiteralExpressionContext
}

func NewIntervalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalLiteralContext {
	var p = new(IntervalLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *IntervalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalLiteralContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *IntervalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterIntervalLiteral(s)
	}
}

func (s *IntervalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitIntervalLiteral(s)
	}
}

func (s *IntervalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitIntervalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnitBoundaryLiteralContext struct {
	LiteralExpressionContext
}

func NewUnitBoundaryLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnitBoundaryLiteralContext {
	var p = new(UnitBoundaryLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *UnitBoundaryLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitBoundaryLiteralContext) UnitBoundary() IUnitBoundaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitBoundaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitBoundaryContext)
}

func (s *UnitBoundaryLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterUnitBoundaryLiteral(s)
	}
}

func (s *UnitBoundaryLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitUnitBoundaryLiteral(s)
	}
}

func (s *UnitBoundaryLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitUnitBoundaryLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) LiteralExpression() (localctx ILiteralExpressionContext) {
	localctx = NewLiteralExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 868, DorisSQLParserRULE_literalExpression)
	var _la int

	p.SetState(6926)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserNULL:
		localctx = NewNullLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6916)
			p.Match(DorisSQLParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserFALSE, DorisSQLParserTRUE:
		localctx = NewBooleanLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6917)
			p.BooleanValue()
		}

	case DorisSQLParserINTEGER_VALUE, DorisSQLParserDECIMAL_VALUE, DorisSQLParserDOUBLE_VALUE:
		localctx = NewNumericLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6918)
			p.Number()
		}

	case DorisSQLParserDATE, DorisSQLParserDATETIME:
		localctx = NewDateLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6919)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserDATE || _la == DorisSQLParserDATETIME) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6920)
			p.String_()
		}

	case DorisSQLParserSINGLE_QUOTED_TEXT, DorisSQLParserDOUBLE_QUOTED_TEXT:
		localctx = NewStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6921)
			p.String_()
		}

	case DorisSQLParserINTERVAL:
		localctx = NewIntervalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6922)
			p.Interval()
		}

	case DorisSQLParserCEIL, DorisSQLParserFLOOR:
		localctx = NewUnitBoundaryLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6923)
			p.UnitBoundary()
		}

	case DorisSQLParserBINARY_SINGLE_QUOTED_TEXT, DorisSQLParserBINARY_DOUBLE_QUOTED_TEXT:
		localctx = NewBinaryLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6924)
			p.Binary()
		}

	case DorisSQLParserPARAMETER:
		localctx = NewParameterContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6925)
			p.Match(DorisSQLParserPARAMETER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_functionCall
	return p
}

func InitEmptyFunctionCallContext(p *FunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_functionCall
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) CopyAll(ctx *FunctionCallContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AggregationFunctionCallContext struct {
	FunctionCallContext
}

func NewAggregationFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AggregationFunctionCallContext {
	var p = new(AggregationFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *AggregationFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregationFunctionCallContext) AggregationFunction() IAggregationFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregationFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregationFunctionContext)
}

func (s *AggregationFunctionCallContext) Over() IOverContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverContext)
}

func (s *AggregationFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAggregationFunctionCall(s)
	}
}

func (s *AggregationFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAggregationFunctionCall(s)
	}
}

func (s *AggregationFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAggregationFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExtractContext struct {
	FunctionCallContext
}

func NewExtractContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExtractContext {
	var p = new(ExtractContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *ExtractContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXTRACT, 0)
}

func (s *ExtractContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExtractContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFROM, 0)
}

func (s *ExtractContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ExtractContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterExtract(s)
	}
}

func (s *ExtractContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitExtract(s)
	}
}

func (s *ExtractContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitExtract(s)

	default:
		return t.VisitChildren(s)
	}
}

type SpecialFunctionContext struct {
	FunctionCallContext
}

func NewSpecialFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialFunctionContext {
	var p = new(SpecialFunctionContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *SpecialFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialFunctionContext) SpecialFunctionExpression() ISpecialFunctionExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecialFunctionExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecialFunctionExpressionContext)
}

func (s *SpecialFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSpecialFunction(s)
	}
}

func (s *SpecialFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSpecialFunction(s)
	}
}

func (s *SpecialFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSpecialFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleFunctionCallContext struct {
	FunctionCallContext
}

func NewSimpleFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleFunctionCallContext {
	var p = new(SimpleFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *SimpleFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleFunctionCallContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SimpleFunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleFunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleFunctionCallContext) Over() IOverContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverContext)
}

func (s *SimpleFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSimpleFunctionCall(s)
	}
}

func (s *SimpleFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSimpleFunctionCall(s)
	}
}

func (s *SimpleFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSimpleFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type SpecialDateTimeContext struct {
	FunctionCallContext
}

func NewSpecialDateTimeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialDateTimeContext {
	var p = new(SpecialDateTimeContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *SpecialDateTimeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialDateTimeContext) SpecialDateTimeExpression() ISpecialDateTimeExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecialDateTimeExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecialDateTimeExpressionContext)
}

func (s *SpecialDateTimeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSpecialDateTime(s)
	}
}

func (s *SpecialDateTimeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSpecialDateTime(s)
	}
}

func (s *SpecialDateTimeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSpecialDateTime(s)

	default:
		return t.VisitChildren(s)
	}
}

type WindowFunctionCallContext struct {
	FunctionCallContext
}

func NewWindowFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WindowFunctionCallContext {
	var p = new(WindowFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *WindowFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFunctionCallContext) WindowFunction() IWindowFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFunctionContext)
}

func (s *WindowFunctionCallContext) Over() IOverContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverContext)
}

func (s *WindowFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterWindowFunctionCall(s)
	}
}

func (s *WindowFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitWindowFunctionCall(s)
	}
}

func (s *WindowFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitWindowFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type InformationFunctionContext struct {
	FunctionCallContext
}

func NewInformationFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InformationFunctionContext {
	var p = new(InformationFunctionContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *InformationFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InformationFunctionContext) InformationFunctionExpression() IInformationFunctionExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInformationFunctionExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInformationFunctionExpressionContext)
}

func (s *InformationFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterInformationFunction(s)
	}
}

func (s *InformationFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitInformationFunction(s)
	}
}

func (s *InformationFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitInformationFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type TranslateFunctionCallContext struct {
	FunctionCallContext
}

func NewTranslateFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TranslateFunctionCallContext {
	var p = new(TranslateFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *TranslateFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TranslateFunctionCallContext) TRANSLATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTRANSLATE, 0)
}

func (s *TranslateFunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TranslateFunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TranslateFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTranslateFunctionCall(s)
	}
}

func (s *TranslateFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTranslateFunctionCall(s)
	}
}

func (s *TranslateFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTranslateFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type GroupingOperationContext struct {
	FunctionCallContext
}

func NewGroupingOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GroupingOperationContext {
	var p = new(GroupingOperationContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *GroupingOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingOperationContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGROUPING, 0)
}

func (s *GroupingOperationContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupingOperationContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingOperationContext) GROUPING_ID() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGROUPING_ID, 0)
}

func (s *GroupingOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterGroupingOperation(s)
	}
}

func (s *GroupingOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitGroupingOperation(s)
	}
}

func (s *GroupingOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitGroupingOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) FunctionCall() (localctx IFunctionCallContext) {
	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 870, DorisSQLParserRULE_functionCall)
	var _la int

	p.SetState(7000)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 818, p.GetParserRuleContext()) {
	case 1:
		localctx = NewExtractContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6928)
			p.Match(DorisSQLParserEXTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6929)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6930)
			p.Identifier()
		}
		{
			p.SetState(6931)
			p.Match(DorisSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6932)
			p.valueExpression(0)
		}
		{
			p.SetState(6933)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewGroupingOperationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6935)
			p.Match(DorisSQLParserGROUPING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6936)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6945)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(6937)
				p.expression(0)
			}
			p.SetState(6942)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(6938)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6939)
					p.expression(0)
				}

				p.SetState(6944)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(6947)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewGroupingOperationContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6948)
			p.Match(DorisSQLParserGROUPING_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6949)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6958)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(6950)
				p.expression(0)
			}
			p.SetState(6955)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(6951)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6952)
					p.expression(0)
				}

				p.SetState(6957)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(6960)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewInformationFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6961)
			p.InformationFunctionExpression()
		}

	case 5:
		localctx = NewSpecialDateTimeContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6962)
			p.SpecialDateTimeExpression()
		}

	case 6:
		localctx = NewSpecialFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6963)
			p.SpecialFunctionExpression()
		}

	case 7:
		localctx = NewAggregationFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6964)
			p.AggregationFunction()
		}
		p.SetState(6966)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 812, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6965)
				p.Over()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 8:
		localctx = NewWindowFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6968)
			p.WindowFunction()
		}
		{
			p.SetState(6969)
			p.Over()
		}

	case 9:
		localctx = NewTranslateFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6971)
			p.Match(DorisSQLParserTRANSLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6972)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6981)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(6973)
				p.expression(0)
			}
			p.SetState(6978)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(6974)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6975)
					p.expression(0)
				}

				p.SetState(6980)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(6983)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewSimpleFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6984)
			p.QualifiedName()
		}
		{
			p.SetState(6985)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6994)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(6986)
				p.expression(0)
			}
			p.SetState(6991)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(6987)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6988)
					p.expression(0)
				}

				p.SetState(6993)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(6996)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6998)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 817, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6997)
				p.Over()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggregationFunctionContext is an interface to support dynamic dispatch.
type IAggregationFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AVG() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	SetQuantifier() ISetQuantifierContext
	COUNT() antlr.TerminalNode
	ASTERISK_SYMBOL() antlr.TerminalNode
	BracketHint() IBracketHintContext
	MAX() antlr.TerminalNode
	MIN() antlr.TerminalNode
	SUM() antlr.TerminalNode
	ARRAY_AGG() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	ARRAY_AGG_DISTINCT() antlr.TerminalNode
	GROUP_CONCAT() antlr.TerminalNode
	SEPARATOR() antlr.TerminalNode

	// IsAggregationFunctionContext differentiates from other interfaces.
	IsAggregationFunctionContext()
}

type AggregationFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregationFunctionContext() *AggregationFunctionContext {
	var p = new(AggregationFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_aggregationFunction
	return p
}

func InitEmptyAggregationFunctionContext(p *AggregationFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_aggregationFunction
}

func (*AggregationFunctionContext) IsAggregationFunctionContext() {}

func NewAggregationFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregationFunctionContext {
	var p = new(AggregationFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_aggregationFunction

	return p
}

func (s *AggregationFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregationFunctionContext) AVG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAVG, 0)
}

func (s *AggregationFunctionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AggregationFunctionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AggregationFunctionContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *AggregationFunctionContext) COUNT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOUNT, 0)
}

func (s *AggregationFunctionContext) ASTERISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserASTERISK_SYMBOL, 0)
}

func (s *AggregationFunctionContext) BracketHint() IBracketHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBracketHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBracketHintContext)
}

func (s *AggregationFunctionContext) MAX() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMAX, 0)
}

func (s *AggregationFunctionContext) MIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMIN, 0)
}

func (s *AggregationFunctionContext) SUM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSUM, 0)
}

func (s *AggregationFunctionContext) ARRAY_AGG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserARRAY_AGG, 0)
}

func (s *AggregationFunctionContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserORDER, 0)
}

func (s *AggregationFunctionContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *AggregationFunctionContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *AggregationFunctionContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *AggregationFunctionContext) ARRAY_AGG_DISTINCT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserARRAY_AGG_DISTINCT, 0)
}

func (s *AggregationFunctionContext) GROUP_CONCAT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGROUP_CONCAT, 0)
}

func (s *AggregationFunctionContext) SEPARATOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSEPARATOR, 0)
}

func (s *AggregationFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregationFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregationFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAggregationFunction(s)
	}
}

func (s *AggregationFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAggregationFunction(s)
	}
}

func (s *AggregationFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAggregationFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AggregationFunction() (localctx IAggregationFunctionContext) {
	localctx = NewAggregationFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 872, DorisSQLParserRULE_aggregationFunction)
	var _la int

	p.SetState(7127)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 838, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7002)
			p.Match(DorisSQLParserAVG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7003)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7005)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserALL || _la == DorisSQLParserDISTINCT {
			{
				p.SetState(7004)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(7007)
			p.expression(0)
		}
		{
			p.SetState(7008)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7010)
			p.Match(DorisSQLParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7011)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7013)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserASTERISK_SYMBOL {
			{
				p.SetState(7012)
				p.Match(DorisSQLParserASTERISK_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7015)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7016)
			p.Match(DorisSQLParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7017)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7022)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserALL || _la == DorisSQLParserDISTINCT {
			{
				p.SetState(7018)
				p.SetQuantifier()
			}
			p.SetState(7020)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 821, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(7019)
					p.BracketHint()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}
		p.SetState(7032)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(7024)
				p.expression(0)
			}
			p.SetState(7029)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(7025)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7026)
					p.expression(0)
				}

				p.SetState(7031)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7034)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7035)
			p.Match(DorisSQLParserMAX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7036)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7038)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserALL || _la == DorisSQLParserDISTINCT {
			{
				p.SetState(7037)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(7040)
			p.expression(0)
		}
		{
			p.SetState(7041)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7043)
			p.Match(DorisSQLParserMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7044)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7046)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserALL || _la == DorisSQLParserDISTINCT {
			{
				p.SetState(7045)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(7048)
			p.expression(0)
		}
		{
			p.SetState(7049)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7051)
			p.Match(DorisSQLParserSUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7052)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7054)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserALL || _la == DorisSQLParserDISTINCT {
			{
				p.SetState(7053)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(7056)
			p.expression(0)
		}
		{
			p.SetState(7057)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7059)
			p.Match(DorisSQLParserARRAY_AGG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7060)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7062)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserALL || _la == DorisSQLParserDISTINCT {
			{
				p.SetState(7061)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(7064)
			p.expression(0)
		}
		p.SetState(7075)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserORDER {
			{
				p.SetState(7065)
				p.Match(DorisSQLParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7066)
				p.Match(DorisSQLParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7067)
				p.SortItem()
			}
			p.SetState(7072)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(7068)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7069)
					p.SortItem()
				}

				p.SetState(7074)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7077)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7079)
			p.Match(DorisSQLParserARRAY_AGG_DISTINCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7080)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7081)
			p.expression(0)
		}
		p.SetState(7092)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserORDER {
			{
				p.SetState(7082)
				p.Match(DorisSQLParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7083)
				p.Match(DorisSQLParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7084)
				p.SortItem()
			}
			p.SetState(7089)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(7085)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7086)
					p.SortItem()
				}

				p.SetState(7091)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7094)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(7096)
			p.Match(DorisSQLParserGROUP_CONCAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7097)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7099)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserALL || _la == DorisSQLParserDISTINCT {
			{
				p.SetState(7098)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(7101)
			p.expression(0)
		}
		p.SetState(7106)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(7102)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7103)
				p.expression(0)
			}

			p.SetState(7108)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(7119)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserORDER {
			{
				p.SetState(7109)
				p.Match(DorisSQLParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7110)
				p.Match(DorisSQLParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7111)
				p.SortItem()
			}
			p.SetState(7116)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(7112)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7113)
					p.SortItem()
				}

				p.SetState(7118)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(7123)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserSEPARATOR {
			{
				p.SetState(7121)
				p.Match(DorisSQLParserSEPARATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7122)
				p.expression(0)
			}

		}
		{
			p.SetState(7125)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserVariableContext is an interface to support dynamic dispatch.
type IUserVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsUserVariableContext differentiates from other interfaces.
	IsUserVariableContext()
}

type UserVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserVariableContext() *UserVariableContext {
	var p = new(UserVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_userVariable
	return p
}

func InitEmptyUserVariableContext(p *UserVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_userVariable
}

func (*UserVariableContext) IsUserVariableContext() {}

func NewUserVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserVariableContext {
	var p = new(UserVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_userVariable

	return p
}

func (s *UserVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *UserVariableContext) AT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAT, 0)
}

func (s *UserVariableContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *UserVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterUserVariable(s)
	}
}

func (s *UserVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitUserVariable(s)
	}
}

func (s *UserVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitUserVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) UserVariable() (localctx IUserVariableContext) {
	localctx = NewUserVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 874, DorisSQLParserRULE_userVariable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7129)
		p.Match(DorisSQLParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7130)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISystemVariableContext is an interface to support dynamic dispatch.
type ISystemVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAT() []antlr.TerminalNode
	AT(i int) antlr.TerminalNode
	Identifier() IIdentifierContext
	VarType() IVarTypeContext

	// IsSystemVariableContext differentiates from other interfaces.
	IsSystemVariableContext()
}

type SystemVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystemVariableContext() *SystemVariableContext {
	var p = new(SystemVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_systemVariable
	return p
}

func InitEmptySystemVariableContext(p *SystemVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_systemVariable
}

func (*SystemVariableContext) IsSystemVariableContext() {}

func NewSystemVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SystemVariableContext {
	var p = new(SystemVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_systemVariable

	return p
}

func (s *SystemVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *SystemVariableContext) AllAT() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserAT)
}

func (s *SystemVariableContext) AT(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAT, i)
}

func (s *SystemVariableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SystemVariableContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *SystemVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SystemVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SystemVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSystemVariable(s)
	}
}

func (s *SystemVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSystemVariable(s)
	}
}

func (s *SystemVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSystemVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SystemVariable() (localctx ISystemVariableContext) {
	localctx = NewSystemVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 876, DorisSQLParserRULE_systemVariable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7132)
		p.Match(DorisSQLParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7133)
		p.Match(DorisSQLParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7137)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 839, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7134)
			p.VarType()
		}
		{
			p.SetState(7135)
			p.Match(DorisSQLParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(7139)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnReferenceContext is an interface to support dynamic dispatch.
type IColumnReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsColumnReferenceContext differentiates from other interfaces.
	IsColumnReferenceContext()
}

type ColumnReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnReferenceContext() *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_columnReference
	return p
}

func InitEmptyColumnReferenceContext(p *ColumnReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_columnReference
}

func (*ColumnReferenceContext) IsColumnReferenceContext() {}

func NewColumnReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_columnReference

	return p
}

func (s *ColumnReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnReferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterColumnReference(s)
	}
}

func (s *ColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitColumnReference(s)
	}
}

func (s *ColumnReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitColumnReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ColumnReference() (localctx IColumnReferenceContext) {
	localctx = NewColumnReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 878, DorisSQLParserRULE_columnReference)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7141)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInformationFunctionExpressionContext is an interface to support dynamic dispatch.
type IInformationFunctionExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	CATALOG() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	USER() antlr.TerminalNode
	CURRENT_USER() antlr.TerminalNode
	CURRENT_ROLE() antlr.TerminalNode
	CURRENT_GROUP() antlr.TerminalNode

	// IsInformationFunctionExpressionContext differentiates from other interfaces.
	IsInformationFunctionExpressionContext()
}

type InformationFunctionExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyInformationFunctionExpressionContext() *InformationFunctionExpressionContext {
	var p = new(InformationFunctionExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_informationFunctionExpression
	return p
}

func InitEmptyInformationFunctionExpressionContext(p *InformationFunctionExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_informationFunctionExpression
}

func (*InformationFunctionExpressionContext) IsInformationFunctionExpressionContext() {}

func NewInformationFunctionExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InformationFunctionExpressionContext {
	var p = new(InformationFunctionExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_informationFunctionExpression

	return p
}

func (s *InformationFunctionExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *InformationFunctionExpressionContext) GetName() antlr.Token { return s.name }

func (s *InformationFunctionExpressionContext) SetName(v antlr.Token) { s.name = v }

func (s *InformationFunctionExpressionContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCATALOG, 0)
}

func (s *InformationFunctionExpressionContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATABASE, 0)
}

func (s *InformationFunctionExpressionContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSCHEMA, 0)
}

func (s *InformationFunctionExpressionContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSER, 0)
}

func (s *InformationFunctionExpressionContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCURRENT_USER, 0)
}

func (s *InformationFunctionExpressionContext) CURRENT_ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCURRENT_ROLE, 0)
}

func (s *InformationFunctionExpressionContext) CURRENT_GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCURRENT_GROUP, 0)
}

func (s *InformationFunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InformationFunctionExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InformationFunctionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterInformationFunctionExpression(s)
	}
}

func (s *InformationFunctionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitInformationFunctionExpression(s)
	}
}

func (s *InformationFunctionExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitInformationFunctionExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) InformationFunctionExpression() (localctx IInformationFunctionExpressionContext) {
	localctx = NewInformationFunctionExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 880, DorisSQLParserRULE_informationFunctionExpression)
	p.SetState(7170)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserCATALOG:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7143)

			var _m = p.Match(DorisSQLParserCATALOG)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7144)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7145)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserDATABASE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7146)

			var _m = p.Match(DorisSQLParserDATABASE)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7147)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7148)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserSCHEMA:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7149)

			var _m = p.Match(DorisSQLParserSCHEMA)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7150)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7151)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserUSER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7152)

			var _m = p.Match(DorisSQLParserUSER)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7153)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7154)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserCURRENT_USER:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7155)

			var _m = p.Match(DorisSQLParserCURRENT_USER)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7158)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 840, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7156)
				p.Match(DorisSQLParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7157)
				p.Match(DorisSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case DorisSQLParserCURRENT_ROLE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7160)

			var _m = p.Match(DorisSQLParserCURRENT_ROLE)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7163)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 841, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7161)
				p.Match(DorisSQLParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7162)
				p.Match(DorisSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case DorisSQLParserCURRENT_GROUP:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7165)

			var _m = p.Match(DorisSQLParserCURRENT_GROUP)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7168)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 842, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7166)
				p.Match(DorisSQLParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7167)
				p.Match(DorisSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpecialDateTimeExpressionContext is an interface to support dynamic dispatch.
type ISpecialDateTimeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	CURRENT_DATE() antlr.TerminalNode
	CURRENT_TIME() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	LOCALTIME() antlr.TerminalNode
	LOCALTIMESTAMP() antlr.TerminalNode

	// IsSpecialDateTimeExpressionContext differentiates from other interfaces.
	IsSpecialDateTimeExpressionContext()
}

type SpecialDateTimeExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptySpecialDateTimeExpressionContext() *SpecialDateTimeExpressionContext {
	var p = new(SpecialDateTimeExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_specialDateTimeExpression
	return p
}

func InitEmptySpecialDateTimeExpressionContext(p *SpecialDateTimeExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_specialDateTimeExpression
}

func (*SpecialDateTimeExpressionContext) IsSpecialDateTimeExpressionContext() {}

func NewSpecialDateTimeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecialDateTimeExpressionContext {
	var p = new(SpecialDateTimeExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_specialDateTimeExpression

	return p
}

func (s *SpecialDateTimeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecialDateTimeExpressionContext) GetName() antlr.Token { return s.name }

func (s *SpecialDateTimeExpressionContext) SetName(v antlr.Token) { s.name = v }

func (s *SpecialDateTimeExpressionContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCURRENT_DATE, 0)
}

func (s *SpecialDateTimeExpressionContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCURRENT_TIME, 0)
}

func (s *SpecialDateTimeExpressionContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCURRENT_TIMESTAMP, 0)
}

func (s *SpecialDateTimeExpressionContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, 0)
}

func (s *SpecialDateTimeExpressionContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOCALTIME, 0)
}

func (s *SpecialDateTimeExpressionContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOCALTIMESTAMP, 0)
}

func (s *SpecialDateTimeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialDateTimeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecialDateTimeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSpecialDateTimeExpression(s)
	}
}

func (s *SpecialDateTimeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSpecialDateTimeExpression(s)
	}
}

func (s *SpecialDateTimeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSpecialDateTimeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SpecialDateTimeExpression() (localctx ISpecialDateTimeExpressionContext) {
	localctx = NewSpecialDateTimeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 882, DorisSQLParserRULE_specialDateTimeExpression)
	var _la int

	p.SetState(7200)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserCURRENT_DATE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7172)

			var _m = p.Match(DorisSQLParserCURRENT_DATE)

			localctx.(*SpecialDateTimeExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7175)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 844, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7173)
				p.Match(DorisSQLParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7174)
				p.Match(DorisSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case DorisSQLParserCURRENT_TIME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7177)

			var _m = p.Match(DorisSQLParserCURRENT_TIME)

			localctx.(*SpecialDateTimeExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7180)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 845, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7178)
				p.Match(DorisSQLParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7179)
				p.Match(DorisSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case DorisSQLParserCURRENT_TIMESTAMP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7182)

			var _m = p.Match(DorisSQLParserCURRENT_TIMESTAMP)

			localctx.(*SpecialDateTimeExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7188)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 847, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7183)
				p.Match(DorisSQLParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(7185)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserINTEGER_VALUE {
				{
					p.SetState(7184)
					p.Match(DorisSQLParserINTEGER_VALUE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(7187)
				p.Match(DorisSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case DorisSQLParserLOCALTIME:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7190)

			var _m = p.Match(DorisSQLParserLOCALTIME)

			localctx.(*SpecialDateTimeExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7193)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 848, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7191)
				p.Match(DorisSQLParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7192)
				p.Match(DorisSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case DorisSQLParserLOCALTIMESTAMP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7195)

			var _m = p.Match(DorisSQLParserLOCALTIMESTAMP)

			localctx.(*SpecialDateTimeExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7198)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 849, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7196)
				p.Match(DorisSQLParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7197)
				p.Match(DorisSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpecialFunctionExpressionContext is an interface to support dynamic dispatch.
type ISpecialFunctionExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHAR() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	IF() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MOD() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	REGEXP() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	RLIKE() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	TIMESTAMPADD() antlr.TerminalNode
	UnitIdentifier() IUnitIdentifierContext
	TIMESTAMPDIFF() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	String_() IStringContext
	FLOOR() antlr.TerminalNode
	CEIL() antlr.TerminalNode

	// IsSpecialFunctionExpressionContext differentiates from other interfaces.
	IsSpecialFunctionExpressionContext()
}

type SpecialFunctionExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecialFunctionExpressionContext() *SpecialFunctionExpressionContext {
	var p = new(SpecialFunctionExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_specialFunctionExpression
	return p
}

func InitEmptySpecialFunctionExpressionContext(p *SpecialFunctionExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_specialFunctionExpression
}

func (*SpecialFunctionExpressionContext) IsSpecialFunctionExpressionContext() {}

func NewSpecialFunctionExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecialFunctionExpressionContext {
	var p = new(SpecialFunctionExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_specialFunctionExpression

	return p
}

func (s *SpecialFunctionExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecialFunctionExpressionContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCHAR, 0)
}

func (s *SpecialFunctionExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SpecialFunctionExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SpecialFunctionExpressionContext) DAY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDAY, 0)
}

func (s *SpecialFunctionExpressionContext) HOUR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserHOUR, 0)
}

func (s *SpecialFunctionExpressionContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *SpecialFunctionExpressionContext) LEFT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLEFT, 0)
}

func (s *SpecialFunctionExpressionContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIKE, 0)
}

func (s *SpecialFunctionExpressionContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMINUTE, 0)
}

func (s *SpecialFunctionExpressionContext) MOD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMOD, 0)
}

func (s *SpecialFunctionExpressionContext) MONTH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMONTH, 0)
}

func (s *SpecialFunctionExpressionContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserQUARTER, 0)
}

func (s *SpecialFunctionExpressionContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREGEXP, 0)
}

func (s *SpecialFunctionExpressionContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPLACE, 0)
}

func (s *SpecialFunctionExpressionContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRIGHT, 0)
}

func (s *SpecialFunctionExpressionContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRLIKE, 0)
}

func (s *SpecialFunctionExpressionContext) SECOND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSECOND, 0)
}

func (s *SpecialFunctionExpressionContext) TIMESTAMPADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTIMESTAMPADD, 0)
}

func (s *SpecialFunctionExpressionContext) UnitIdentifier() IUnitIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitIdentifierContext)
}

func (s *SpecialFunctionExpressionContext) TIMESTAMPDIFF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTIMESTAMPDIFF, 0)
}

func (s *SpecialFunctionExpressionContext) YEAR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserYEAR, 0)
}

func (s *SpecialFunctionExpressionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPASSWORD, 0)
}

func (s *SpecialFunctionExpressionContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *SpecialFunctionExpressionContext) FLOOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFLOOR, 0)
}

func (s *SpecialFunctionExpressionContext) CEIL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCEIL, 0)
}

func (s *SpecialFunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialFunctionExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecialFunctionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSpecialFunctionExpression(s)
	}
}

func (s *SpecialFunctionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSpecialFunctionExpression(s)
	}
}

func (s *SpecialFunctionExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSpecialFunctionExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SpecialFunctionExpression() (localctx ISpecialFunctionExpressionContext) {
	localctx = NewSpecialFunctionExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 884, DorisSQLParserRULE_specialFunctionExpression)
	var _la int

	p.SetState(7343)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserCHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7202)
			p.Match(DorisSQLParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7203)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7204)
			p.expression(0)
		}
		{
			p.SetState(7205)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserDAY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7207)
			p.Match(DorisSQLParserDAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7208)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7209)
			p.expression(0)
		}
		{
			p.SetState(7210)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserHOUR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7212)
			p.Match(DorisSQLParserHOUR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7213)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7214)
			p.expression(0)
		}
		{
			p.SetState(7215)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserIF:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7217)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7218)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7227)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(7219)
				p.expression(0)
			}
			p.SetState(7224)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(7220)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7221)
					p.expression(0)
				}

				p.SetState(7226)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7229)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserLEFT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7230)
			p.Match(DorisSQLParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7231)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7232)
			p.expression(0)
		}
		{
			p.SetState(7233)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7234)
			p.expression(0)
		}
		{
			p.SetState(7235)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserLIKE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7237)
			p.Match(DorisSQLParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7238)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7239)
			p.expression(0)
		}
		{
			p.SetState(7240)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7241)
			p.expression(0)
		}
		{
			p.SetState(7242)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserMINUTE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7244)
			p.Match(DorisSQLParserMINUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7245)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7246)
			p.expression(0)
		}
		{
			p.SetState(7247)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserMOD:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7249)
			p.Match(DorisSQLParserMOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7250)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7251)
			p.expression(0)
		}
		{
			p.SetState(7252)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7253)
			p.expression(0)
		}
		{
			p.SetState(7254)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserMONTH:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(7256)
			p.Match(DorisSQLParserMONTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7257)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7258)
			p.expression(0)
		}
		{
			p.SetState(7259)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserQUARTER:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(7261)
			p.Match(DorisSQLParserQUARTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7262)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7263)
			p.expression(0)
		}
		{
			p.SetState(7264)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserREGEXP:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(7266)
			p.Match(DorisSQLParserREGEXP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7267)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7268)
			p.expression(0)
		}
		{
			p.SetState(7269)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7270)
			p.expression(0)
		}
		{
			p.SetState(7271)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserREPLACE:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(7273)
			p.Match(DorisSQLParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7274)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7283)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(7275)
				p.expression(0)
			}
			p.SetState(7280)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(7276)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7277)
					p.expression(0)
				}

				p.SetState(7282)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7285)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserRIGHT:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(7286)
			p.Match(DorisSQLParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7287)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7288)
			p.expression(0)
		}
		{
			p.SetState(7289)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7290)
			p.expression(0)
		}
		{
			p.SetState(7291)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserRLIKE:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(7293)
			p.Match(DorisSQLParserRLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7294)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7295)
			p.expression(0)
		}
		{
			p.SetState(7296)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7297)
			p.expression(0)
		}
		{
			p.SetState(7298)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserSECOND:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(7300)
			p.Match(DorisSQLParserSECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7301)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7302)
			p.expression(0)
		}
		{
			p.SetState(7303)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserTIMESTAMPADD:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(7305)
			p.Match(DorisSQLParserTIMESTAMPADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7306)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7307)
			p.UnitIdentifier()
		}
		{
			p.SetState(7308)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7309)
			p.expression(0)
		}
		{
			p.SetState(7310)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7311)
			p.expression(0)
		}
		{
			p.SetState(7312)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserTIMESTAMPDIFF:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(7314)
			p.Match(DorisSQLParserTIMESTAMPDIFF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7315)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7316)
			p.UnitIdentifier()
		}
		{
			p.SetState(7317)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7318)
			p.expression(0)
		}
		{
			p.SetState(7319)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7320)
			p.expression(0)
		}
		{
			p.SetState(7321)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserYEAR:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(7323)
			p.Match(DorisSQLParserYEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7324)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7325)
			p.expression(0)
		}
		{
			p.SetState(7326)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserPASSWORD:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(7328)
			p.Match(DorisSQLParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7329)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7330)
			p.String_()
		}
		{
			p.SetState(7331)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserFLOOR:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(7333)
			p.Match(DorisSQLParserFLOOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7334)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7335)
			p.expression(0)
		}
		{
			p.SetState(7336)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserCEIL:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(7338)
			p.Match(DorisSQLParserCEIL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7339)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7340)
			p.expression(0)
		}
		{
			p.SetState(7341)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFunctionContext is an interface to support dynamic dispatch.
type IWindowFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	ROW_NUMBER() antlr.TerminalNode
	RANK() antlr.TerminalNode
	DENSE_RANK() antlr.TerminalNode
	CUME_DIST() antlr.TerminalNode
	PERCENT_RANK() antlr.TerminalNode
	NTILE() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	LEAD() antlr.TerminalNode
	AllIgnoreNulls() []IIgnoreNullsContext
	IgnoreNulls(i int) IIgnoreNullsContext
	LAG() antlr.TerminalNode
	FIRST_VALUE() antlr.TerminalNode
	LAST_VALUE() antlr.TerminalNode

	// IsWindowFunctionContext differentiates from other interfaces.
	IsWindowFunctionContext()
}

type WindowFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyWindowFunctionContext() *WindowFunctionContext {
	var p = new(WindowFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_windowFunction
	return p
}

func InitEmptyWindowFunctionContext(p *WindowFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_windowFunction
}

func (*WindowFunctionContext) IsWindowFunctionContext() {}

func NewWindowFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFunctionContext {
	var p = new(WindowFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_windowFunction

	return p
}

func (s *WindowFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFunctionContext) GetName() antlr.Token { return s.name }

func (s *WindowFunctionContext) SetName(v antlr.Token) { s.name = v }

func (s *WindowFunctionContext) ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROW_NUMBER, 0)
}

func (s *WindowFunctionContext) RANK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRANK, 0)
}

func (s *WindowFunctionContext) DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDENSE_RANK, 0)
}

func (s *WindowFunctionContext) CUME_DIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCUME_DIST, 0)
}

func (s *WindowFunctionContext) PERCENT_RANK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPERCENT_RANK, 0)
}

func (s *WindowFunctionContext) NTILE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNTILE, 0)
}

func (s *WindowFunctionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WindowFunctionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WindowFunctionContext) LEAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLEAD, 0)
}

func (s *WindowFunctionContext) AllIgnoreNulls() []IIgnoreNullsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIgnoreNullsContext); ok {
			len++
		}
	}

	tst := make([]IIgnoreNullsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIgnoreNullsContext); ok {
			tst[i] = t.(IIgnoreNullsContext)
			i++
		}
	}

	return tst
}

func (s *WindowFunctionContext) IgnoreNulls(i int) IIgnoreNullsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIgnoreNullsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIgnoreNullsContext)
}

func (s *WindowFunctionContext) LAG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLAG, 0)
}

func (s *WindowFunctionContext) FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFIRST_VALUE, 0)
}

func (s *WindowFunctionContext) LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLAST_VALUE, 0)
}

func (s *WindowFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterWindowFunction(s)
	}
}

func (s *WindowFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitWindowFunction(s)
	}
}

func (s *WindowFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitWindowFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) WindowFunction() (localctx IWindowFunctionContext) {
	localctx = NewWindowFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 886, DorisSQLParserRULE_windowFunction)
	var _la int

	p.SetState(7442)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserROW_NUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7345)

			var _m = p.Match(DorisSQLParserROW_NUMBER)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7346)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7347)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserRANK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7348)

			var _m = p.Match(DorisSQLParserRANK)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7349)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7350)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserDENSE_RANK:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7351)

			var _m = p.Match(DorisSQLParserDENSE_RANK)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7352)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7353)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserCUME_DIST:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7354)

			var _m = p.Match(DorisSQLParserCUME_DIST)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7355)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7356)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserPERCENT_RANK:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7357)

			var _m = p.Match(DorisSQLParserPERCENT_RANK)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7358)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7359)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserNTILE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7360)

			var _m = p.Match(DorisSQLParserNTILE)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7361)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7363)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(7362)
				p.expression(0)
			}

		}
		{
			p.SetState(7365)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserLEAD:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7366)

			var _m = p.Match(DorisSQLParserLEAD)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7367)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7379)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(7368)
				p.expression(0)
			}
			p.SetState(7370)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserIGNORE {
				{
					p.SetState(7369)
					p.IgnoreNulls()
				}

			}
			p.SetState(7376)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(7372)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7373)
					p.expression(0)
				}

				p.SetState(7378)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7381)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7383)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserIGNORE {
			{
				p.SetState(7382)
				p.IgnoreNulls()
			}

		}

	case DorisSQLParserLAG:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7385)

			var _m = p.Match(DorisSQLParserLAG)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7386)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7398)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(7387)
				p.expression(0)
			}
			p.SetState(7389)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserIGNORE {
				{
					p.SetState(7388)
					p.IgnoreNulls()
				}

			}
			p.SetState(7395)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(7391)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7392)
					p.expression(0)
				}

				p.SetState(7397)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7400)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7402)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserIGNORE {
			{
				p.SetState(7401)
				p.IgnoreNulls()
			}

		}

	case DorisSQLParserFIRST_VALUE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(7404)

			var _m = p.Match(DorisSQLParserFIRST_VALUE)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7405)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7417)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(7406)
				p.expression(0)
			}
			p.SetState(7408)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserIGNORE {
				{
					p.SetState(7407)
					p.IgnoreNulls()
				}

			}
			p.SetState(7414)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(7410)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7411)
					p.expression(0)
				}

				p.SetState(7416)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7419)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7421)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserIGNORE {
			{
				p.SetState(7420)
				p.IgnoreNulls()
			}

		}

	case DorisSQLParserLAST_VALUE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(7423)

			var _m = p.Match(DorisSQLParserLAST_VALUE)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7424)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7436)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(7425)
				p.expression(0)
			}
			p.SetState(7427)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserIGNORE {
				{
					p.SetState(7426)
					p.IgnoreNulls()
				}

			}
			p.SetState(7433)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(7429)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7430)
					p.expression(0)
				}

				p.SetState(7435)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7438)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7440)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserIGNORE {
			{
				p.SetState(7439)
				p.IgnoreNulls()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetResult returns the result rule contexts.
	GetResult() IExpressionContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetResult sets the result rule contexts.
	SetResult(IExpressionContext)

	// Getter signatures
	WHEN() antlr.TerminalNode
	THEN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExpressionContext
	result    IExpressionContext
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_whenClause
	return p
}

func InitEmptyWhenClauseContext(p *WhenClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_whenClause
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) GetCondition() IExpressionContext { return s.condition }

func (s *WhenClauseContext) GetResult() IExpressionContext { return s.result }

func (s *WhenClauseContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *WhenClauseContext) SetResult(v IExpressionContext) { s.result = v }

func (s *WhenClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHEN, 0)
}

func (s *WhenClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTHEN, 0)
}

func (s *WhenClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WhenClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterWhenClause(s)
	}
}

func (s *WhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitWhenClause(s)
	}
}

func (s *WhenClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitWhenClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 888, DorisSQLParserRULE_whenClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7444)
		p.Match(DorisSQLParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7445)

		var _x = p.expression(0)

		localctx.(*WhenClauseContext).condition = _x
	}
	{
		p.SetState(7446)
		p.Match(DorisSQLParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7447)

		var _x = p.expression(0)

		localctx.(*WhenClauseContext).result = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOverContext is an interface to support dynamic dispatch.
type IOverContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetPartition returns the partition rule context list.
	GetPartition() []IExpressionContext

	// SetPartition sets the partition rule context list.
	SetPartition([]IExpressionContext)

	// Getter signatures
	OVER() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	ORDER() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	WindowFrame() IWindowFrameContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	BracketHint() IBracketHintContext

	// IsOverContext differentiates from other interfaces.
	IsOverContext()
}

type OverContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	_expression IExpressionContext
	partition   []IExpressionContext
}

func NewEmptyOverContext() *OverContext {
	var p = new(OverContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_over
	return p
}

func InitEmptyOverContext(p *OverContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_over
}

func (*OverContext) IsOverContext() {}

func NewOverContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverContext {
	var p = new(OverContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_over

	return p
}

func (s *OverContext) GetParser() antlr.Parser { return s.parser }

func (s *OverContext) Get_expression() IExpressionContext { return s._expression }

func (s *OverContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *OverContext) GetPartition() []IExpressionContext { return s.partition }

func (s *OverContext) SetPartition(v []IExpressionContext) { s.partition = v }

func (s *OverContext) OVER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOVER, 0)
}

func (s *OverContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPARTITION, 0)
}

func (s *OverContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserBY)
}

func (s *OverContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, i)
}

func (s *OverContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserORDER, 0)
}

func (s *OverContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *OverContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *OverContext) WindowFrame() IWindowFrameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameContext)
}

func (s *OverContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OverContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OverContext) BracketHint() IBracketHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBracketHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBracketHintContext)
}

func (s *OverContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterOver(s)
	}
}

func (s *OverContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitOver(s)
	}
}

func (s *OverContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitOver(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Over() (localctx IOverContext) {
	localctx = NewOverContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 890, DorisSQLParserRULE_over)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7449)
		p.Match(DorisSQLParserOVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7450)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7464)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserT__5 || _la == DorisSQLParserPARTITION {
		p.SetState(7452)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__5 {
			{
				p.SetState(7451)
				p.BracketHint()
			}

		}
		{
			p.SetState(7454)
			p.Match(DorisSQLParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7455)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7456)

			var _x = p.expression(0)

			localctx.(*OverContext)._expression = _x
		}
		localctx.(*OverContext).partition = append(localctx.(*OverContext).partition, localctx.(*OverContext)._expression)
		p.SetState(7461)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(7457)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7458)

				var _x = p.expression(0)

				localctx.(*OverContext)._expression = _x
			}
			localctx.(*OverContext).partition = append(localctx.(*OverContext).partition, localctx.(*OverContext)._expression)

			p.SetState(7463)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(7476)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserORDER {
		{
			p.SetState(7466)
			p.Match(DorisSQLParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7467)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7468)
			p.SortItem()
		}
		p.SetState(7473)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserT__2 {
			{
				p.SetState(7469)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7470)
				p.SortItem()
			}

			p.SetState(7475)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(7479)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserRANGE || _la == DorisSQLParserROWS {
		{
			p.SetState(7478)
			p.WindowFrame()
		}

	}
	{
		p.SetState(7481)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIgnoreNullsContext is an interface to support dynamic dispatch.
type IIgnoreNullsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IGNORE() antlr.TerminalNode
	NULLS() antlr.TerminalNode

	// IsIgnoreNullsContext differentiates from other interfaces.
	IsIgnoreNullsContext()
}

type IgnoreNullsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIgnoreNullsContext() *IgnoreNullsContext {
	var p = new(IgnoreNullsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_ignoreNulls
	return p
}

func InitEmptyIgnoreNullsContext(p *IgnoreNullsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_ignoreNulls
}

func (*IgnoreNullsContext) IsIgnoreNullsContext() {}

func NewIgnoreNullsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IgnoreNullsContext {
	var p = new(IgnoreNullsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_ignoreNulls

	return p
}

func (s *IgnoreNullsContext) GetParser() antlr.Parser { return s.parser }

func (s *IgnoreNullsContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIGNORE, 0)
}

func (s *IgnoreNullsContext) NULLS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNULLS, 0)
}

func (s *IgnoreNullsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IgnoreNullsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IgnoreNullsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterIgnoreNulls(s)
	}
}

func (s *IgnoreNullsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitIgnoreNulls(s)
	}
}

func (s *IgnoreNullsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitIgnoreNulls(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) IgnoreNulls() (localctx IIgnoreNullsContext) {
	localctx = NewIgnoreNullsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 892, DorisSQLParserRULE_ignoreNulls)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7483)
		p.Match(DorisSQLParserIGNORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7484)
		p.Match(DorisSQLParserNULLS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameContext is an interface to support dynamic dispatch.
type IWindowFrameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFrameType returns the frameType token.
	GetFrameType() antlr.Token

	// SetFrameType sets the frameType token.
	SetFrameType(antlr.Token)

	// GetStart_ returns the start_ rule contexts.
	GetStart_() IFrameBoundContext

	// GetEnd returns the end rule contexts.
	GetEnd() IFrameBoundContext

	// SetStart_ sets the start_ rule contexts.
	SetStart_(IFrameBoundContext)

	// SetEnd sets the end rule contexts.
	SetEnd(IFrameBoundContext)

	// Getter signatures
	RANGE() antlr.TerminalNode
	AllFrameBound() []IFrameBoundContext
	FrameBound(i int) IFrameBoundContext
	ROWS() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	AND() antlr.TerminalNode

	// IsWindowFrameContext differentiates from other interfaces.
	IsWindowFrameContext()
}

type WindowFrameContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	frameType antlr.Token
	start_    IFrameBoundContext
	end       IFrameBoundContext
}

func NewEmptyWindowFrameContext() *WindowFrameContext {
	var p = new(WindowFrameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_windowFrame
	return p
}

func InitEmptyWindowFrameContext(p *WindowFrameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_windowFrame
}

func (*WindowFrameContext) IsWindowFrameContext() {}

func NewWindowFrameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameContext {
	var p = new(WindowFrameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_windowFrame

	return p
}

func (s *WindowFrameContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameContext) GetFrameType() antlr.Token { return s.frameType }

func (s *WindowFrameContext) SetFrameType(v antlr.Token) { s.frameType = v }

func (s *WindowFrameContext) GetStart_() IFrameBoundContext { return s.start_ }

func (s *WindowFrameContext) GetEnd() IFrameBoundContext { return s.end }

func (s *WindowFrameContext) SetStart_(v IFrameBoundContext) { s.start_ = v }

func (s *WindowFrameContext) SetEnd(v IFrameBoundContext) { s.end = v }

func (s *WindowFrameContext) RANGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRANGE, 0)
}

func (s *WindowFrameContext) AllFrameBound() []IFrameBoundContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrameBoundContext); ok {
			len++
		}
	}

	tst := make([]IFrameBoundContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrameBoundContext); ok {
			tst[i] = t.(IFrameBoundContext)
			i++
		}
	}

	return tst
}

func (s *WindowFrameContext) FrameBound(i int) IFrameBoundContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameBoundContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameBoundContext)
}

func (s *WindowFrameContext) ROWS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROWS, 0)
}

func (s *WindowFrameContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBETWEEN, 0)
}

func (s *WindowFrameContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAND, 0)
}

func (s *WindowFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterWindowFrame(s)
	}
}

func (s *WindowFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitWindowFrame(s)
	}
}

func (s *WindowFrameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitWindowFrame(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) WindowFrame() (localctx IWindowFrameContext) {
	localctx = NewWindowFrameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 894, DorisSQLParserRULE_windowFrame)
	p.SetState(7502)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 880, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7486)

			var _m = p.Match(DorisSQLParserRANGE)

			localctx.(*WindowFrameContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7487)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start_ = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7488)

			var _m = p.Match(DorisSQLParserROWS)

			localctx.(*WindowFrameContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7489)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start_ = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7490)

			var _m = p.Match(DorisSQLParserRANGE)

			localctx.(*WindowFrameContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7491)
			p.Match(DorisSQLParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7492)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start_ = _x
		}
		{
			p.SetState(7493)
			p.Match(DorisSQLParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7494)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).end = _x
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7496)

			var _m = p.Match(DorisSQLParserROWS)

			localctx.(*WindowFrameContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7497)
			p.Match(DorisSQLParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7498)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start_ = _x
		}
		{
			p.SetState(7499)
			p.Match(DorisSQLParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7500)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).end = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameBoundContext is an interface to support dynamic dispatch.
type IFrameBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFrameBoundContext differentiates from other interfaces.
	IsFrameBoundContext()
}

type FrameBoundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameBoundContext() *FrameBoundContext {
	var p = new(FrameBoundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_frameBound
	return p
}

func InitEmptyFrameBoundContext(p *FrameBoundContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_frameBound
}

func (*FrameBoundContext) IsFrameBoundContext() {}

func NewFrameBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameBoundContext {
	var p = new(FrameBoundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_frameBound

	return p
}

func (s *FrameBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameBoundContext) CopyAll(ctx *FrameBoundContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FrameBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BoundedFrameContext struct {
	FrameBoundContext
	boundType antlr.Token
}

func NewBoundedFrameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BoundedFrameContext {
	var p = new(BoundedFrameContext)

	InitEmptyFrameBoundContext(&p.FrameBoundContext)
	p.parser = parser
	p.CopyAll(ctx.(*FrameBoundContext))

	return p
}

func (s *BoundedFrameContext) GetBoundType() antlr.Token { return s.boundType }

func (s *BoundedFrameContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *BoundedFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoundedFrameContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BoundedFrameContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPRECEDING, 0)
}

func (s *BoundedFrameContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFOLLOWING, 0)
}

func (s *BoundedFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterBoundedFrame(s)
	}
}

func (s *BoundedFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitBoundedFrame(s)
	}
}

func (s *BoundedFrameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitBoundedFrame(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnboundedFrameContext struct {
	FrameBoundContext
	boundType antlr.Token
}

func NewUnboundedFrameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnboundedFrameContext {
	var p = new(UnboundedFrameContext)

	InitEmptyFrameBoundContext(&p.FrameBoundContext)
	p.parser = parser
	p.CopyAll(ctx.(*FrameBoundContext))

	return p
}

func (s *UnboundedFrameContext) GetBoundType() antlr.Token { return s.boundType }

func (s *UnboundedFrameContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *UnboundedFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnboundedFrameContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUNBOUNDED, 0)
}

func (s *UnboundedFrameContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPRECEDING, 0)
}

func (s *UnboundedFrameContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFOLLOWING, 0)
}

func (s *UnboundedFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterUnboundedFrame(s)
	}
}

func (s *UnboundedFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitUnboundedFrame(s)
	}
}

func (s *UnboundedFrameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitUnboundedFrame(s)

	default:
		return t.VisitChildren(s)
	}
}

type CurrentRowBoundContext struct {
	FrameBoundContext
}

func NewCurrentRowBoundContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentRowBoundContext {
	var p = new(CurrentRowBoundContext)

	InitEmptyFrameBoundContext(&p.FrameBoundContext)
	p.parser = parser
	p.CopyAll(ctx.(*FrameBoundContext))

	return p
}

func (s *CurrentRowBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentRowBoundContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCURRENT, 0)
}

func (s *CurrentRowBoundContext) ROW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROW, 0)
}

func (s *CurrentRowBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterCurrentRowBound(s)
	}
}

func (s *CurrentRowBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitCurrentRowBound(s)
	}
}

func (s *CurrentRowBoundContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitCurrentRowBound(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) FrameBound() (localctx IFrameBoundContext) {
	localctx = NewFrameBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 896, DorisSQLParserRULE_frameBound)
	var _la int

	p.SetState(7513)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 881, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUnboundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7504)
			p.Match(DorisSQLParserUNBOUNDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7505)

			var _m = p.Match(DorisSQLParserPRECEDING)

			localctx.(*UnboundedFrameContext).boundType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewUnboundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7506)
			p.Match(DorisSQLParserUNBOUNDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7507)

			var _m = p.Match(DorisSQLParserFOLLOWING)

			localctx.(*UnboundedFrameContext).boundType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewCurrentRowBoundContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7508)
			p.Match(DorisSQLParserCURRENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7509)
			p.Match(DorisSQLParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewBoundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7510)
			p.expression(0)
		}
		{
			p.SetState(7511)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*BoundedFrameContext).boundType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserFOLLOWING || _la == DorisSQLParserPRECEDING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*BoundedFrameContext).boundType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBackupRestoreObjectDescContext is an interface to support dynamic dispatch.
type IBackupRestoreObjectDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BackupRestoreTableDesc() IBackupRestoreTableDescContext
	ALL() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	FUNCTION() antlr.TerminalNode
	FUNCTIONS() antlr.TerminalNode
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	VIEWS() antlr.TerminalNode

	// IsBackupRestoreObjectDescContext differentiates from other interfaces.
	IsBackupRestoreObjectDescContext()
}

type BackupRestoreObjectDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackupRestoreObjectDescContext() *BackupRestoreObjectDescContext {
	var p = new(BackupRestoreObjectDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_backupRestoreObjectDesc
	return p
}

func InitEmptyBackupRestoreObjectDescContext(p *BackupRestoreObjectDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_backupRestoreObjectDesc
}

func (*BackupRestoreObjectDescContext) IsBackupRestoreObjectDescContext() {}

func NewBackupRestoreObjectDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BackupRestoreObjectDescContext {
	var p = new(BackupRestoreObjectDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_backupRestoreObjectDesc

	return p
}

func (s *BackupRestoreObjectDescContext) GetParser() antlr.Parser { return s.parser }

func (s *BackupRestoreObjectDescContext) BackupRestoreTableDesc() IBackupRestoreTableDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackupRestoreTableDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackupRestoreTableDescContext)
}

func (s *BackupRestoreObjectDescContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, 0)
}

func (s *BackupRestoreObjectDescContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *BackupRestoreObjectDescContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFUNCTION, 0)
}

func (s *BackupRestoreObjectDescContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFUNCTIONS, 0)
}

func (s *BackupRestoreObjectDescContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *BackupRestoreObjectDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BackupRestoreObjectDescContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLE, 0)
}

func (s *BackupRestoreObjectDescContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLES, 0)
}

func (s *BackupRestoreObjectDescContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMATERIALIZED, 0)
}

func (s *BackupRestoreObjectDescContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVIEW, 0)
}

func (s *BackupRestoreObjectDescContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVIEWS, 0)
}

func (s *BackupRestoreObjectDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackupRestoreObjectDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BackupRestoreObjectDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterBackupRestoreObjectDesc(s)
	}
}

func (s *BackupRestoreObjectDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitBackupRestoreObjectDesc(s)
	}
}

func (s *BackupRestoreObjectDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitBackupRestoreObjectDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) BackupRestoreObjectDesc() (localctx IBackupRestoreObjectDescContext) {
	localctx = NewBackupRestoreObjectDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 898, DorisSQLParserRULE_backupRestoreObjectDesc)
	var _la int

	p.SetState(7554)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 889, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7515)
			p.BackupRestoreTableDesc()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(7524)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserALL:
			{
				p.SetState(7516)
				p.Match(DorisSQLParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7517)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserFUNCTION || _la == DorisSQLParserFUNCTIONS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		case DorisSQLParserFUNCTION, DorisSQLParserFUNCTIONS:
			{
				p.SetState(7518)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserFUNCTION || _la == DorisSQLParserFUNCTIONS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(7519)
				p.QualifiedName()
			}
			p.SetState(7522)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserAS {
				{
					p.SetState(7520)
					p.Match(DorisSQLParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7521)
					p.Identifier()
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(7530)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserALL:
			{
				p.SetState(7526)
				p.Match(DorisSQLParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7527)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserTABLE || _la == DorisSQLParserTABLES) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		case DorisSQLParserTABLE, DorisSQLParserTABLES:
			{
				p.SetState(7528)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserTABLE || _la == DorisSQLParserTABLES) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(7529)
				p.BackupRestoreTableDesc()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(7542)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserALL:
			{
				p.SetState(7532)
				p.Match(DorisSQLParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7533)
				p.Match(DorisSQLParserMATERIALIZED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7534)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserVIEW || _la == DorisSQLParserVIEWS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		case DorisSQLParserMATERIALIZED:
			{
				p.SetState(7535)
				p.Match(DorisSQLParserMATERIALIZED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7536)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserVIEW || _la == DorisSQLParserVIEWS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(7537)
				p.QualifiedName()
			}
			p.SetState(7540)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserAS {
				{
					p.SetState(7538)
					p.Match(DorisSQLParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7539)
					p.Identifier()
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(7552)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserALL:
			{
				p.SetState(7544)
				p.Match(DorisSQLParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7545)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserVIEW || _la == DorisSQLParserVIEWS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		case DorisSQLParserVIEW, DorisSQLParserVIEWS:
			{
				p.SetState(7546)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserVIEW || _la == DorisSQLParserVIEWS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(7547)
				p.QualifiedName()
			}
			p.SetState(7550)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserAS {
				{
					p.SetState(7548)
					p.Match(DorisSQLParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7549)
					p.Identifier()
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableDescContext is an interface to support dynamic dispatch.
type ITableDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext

	// IsTableDescContext differentiates from other interfaces.
	IsTableDescContext()
}

type TableDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableDescContext() *TableDescContext {
	var p = new(TableDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_tableDesc
	return p
}

func InitEmptyTableDescContext(p *TableDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_tableDesc
}

func (*TableDescContext) IsTableDescContext() {}

func NewTableDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableDescContext {
	var p = new(TableDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_tableDesc

	return p
}

func (s *TableDescContext) GetParser() antlr.Parser { return s.parser }

func (s *TableDescContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableDescContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *TableDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTableDesc(s)
	}
}

func (s *TableDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTableDesc(s)
	}
}

func (s *TableDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTableDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) TableDesc() (localctx ITableDescContext) {
	localctx = NewTableDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 900, DorisSQLParserRULE_tableDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7556)
		p.QualifiedName()
	}
	p.SetState(7558)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPARTITION || _la == DorisSQLParserPARTITIONS || _la == DorisSQLParserTEMPORARY {
		{
			p.SetState(7557)
			p.PartitionNames()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBackupRestoreTableDescContext is an interface to support dynamic dispatch.
type IBackupRestoreTableDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsBackupRestoreTableDescContext differentiates from other interfaces.
	IsBackupRestoreTableDescContext()
}

type BackupRestoreTableDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackupRestoreTableDescContext() *BackupRestoreTableDescContext {
	var p = new(BackupRestoreTableDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_backupRestoreTableDesc
	return p
}

func InitEmptyBackupRestoreTableDescContext(p *BackupRestoreTableDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_backupRestoreTableDesc
}

func (*BackupRestoreTableDescContext) IsBackupRestoreTableDescContext() {}

func NewBackupRestoreTableDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BackupRestoreTableDescContext {
	var p = new(BackupRestoreTableDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_backupRestoreTableDesc

	return p
}

func (s *BackupRestoreTableDescContext) GetParser() antlr.Parser { return s.parser }

func (s *BackupRestoreTableDescContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *BackupRestoreTableDescContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *BackupRestoreTableDescContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *BackupRestoreTableDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BackupRestoreTableDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackupRestoreTableDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BackupRestoreTableDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterBackupRestoreTableDesc(s)
	}
}

func (s *BackupRestoreTableDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitBackupRestoreTableDesc(s)
	}
}

func (s *BackupRestoreTableDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitBackupRestoreTableDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) BackupRestoreTableDesc() (localctx IBackupRestoreTableDescContext) {
	localctx = NewBackupRestoreTableDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 902, DorisSQLParserRULE_backupRestoreTableDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7560)
		p.QualifiedName()
	}
	p.SetState(7562)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPARTITION || _la == DorisSQLParserPARTITIONS || _la == DorisSQLParserTEMPORARY {
		{
			p.SetState(7561)
			p.PartitionNames()
		}

	}
	p.SetState(7566)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserAS {
		{
			p.SetState(7564)
			p.Match(DorisSQLParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7565)
			p.Identifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplainDescContext is an interface to support dynamic dispatch.
type IExplainDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	EXPLAIN() antlr.TerminalNode
	LOGICAL() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	VERBOSE() antlr.TerminalNode
	COSTS() antlr.TerminalNode
	SCHEDULER() antlr.TerminalNode

	// IsExplainDescContext differentiates from other interfaces.
	IsExplainDescContext()
}

type ExplainDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainDescContext() *ExplainDescContext {
	var p = new(ExplainDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_explainDesc
	return p
}

func InitEmptyExplainDescContext(p *ExplainDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_explainDesc
}

func (*ExplainDescContext) IsExplainDescContext() {}

func NewExplainDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainDescContext {
	var p = new(ExplainDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_explainDesc

	return p
}

func (s *ExplainDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainDescContext) DESC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDESC, 0)
}

func (s *ExplainDescContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDESCRIBE, 0)
}

func (s *ExplainDescContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXPLAIN, 0)
}

func (s *ExplainDescContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOGICAL, 0)
}

func (s *ExplainDescContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserANALYZE, 0)
}

func (s *ExplainDescContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVERBOSE, 0)
}

func (s *ExplainDescContext) COSTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOSTS, 0)
}

func (s *ExplainDescContext) SCHEDULER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSCHEDULER, 0)
}

func (s *ExplainDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplainDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterExplainDesc(s)
	}
}

func (s *ExplainDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitExplainDesc(s)
	}
}

func (s *ExplainDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitExplainDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ExplainDesc() (localctx IExplainDescContext) {
	localctx = NewExplainDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 904, DorisSQLParserRULE_explainDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7568)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-125)) & ^0x3f) == 0 && ((int64(1)<<(_la-125))&16777219) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(7570)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserANALYZE || _la == DorisSQLParserCOSTS || _la == DorisSQLParserLOGICAL || _la == DorisSQLParserSCHEDULER || _la == DorisSQLParserVERBOSE {
		{
			p.SetState(7569)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserANALYZE || _la == DorisSQLParserCOSTS || _la == DorisSQLParserLOGICAL || _la == DorisSQLParserSCHEDULER || _la == DorisSQLParserVERBOSE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptimizerTraceContext is an interface to support dynamic dispatch.
type IOptimizerTraceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRACE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	LOGS() antlr.TerminalNode
	TIMES() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	REASON() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsOptimizerTraceContext differentiates from other interfaces.
	IsOptimizerTraceContext()
}

type OptimizerTraceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptimizerTraceContext() *OptimizerTraceContext {
	var p = new(OptimizerTraceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_optimizerTrace
	return p
}

func InitEmptyOptimizerTraceContext(p *OptimizerTraceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_optimizerTrace
}

func (*OptimizerTraceContext) IsOptimizerTraceContext() {}

func NewOptimizerTraceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptimizerTraceContext {
	var p = new(OptimizerTraceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_optimizerTrace

	return p
}

func (s *OptimizerTraceContext) GetParser() antlr.Parser { return s.parser }

func (s *OptimizerTraceContext) TRACE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTRACE, 0)
}

func (s *OptimizerTraceContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserALL, 0)
}

func (s *OptimizerTraceContext) LOGS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOGS, 0)
}

func (s *OptimizerTraceContext) TIMES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTIMES, 0)
}

func (s *OptimizerTraceContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVALUES, 0)
}

func (s *OptimizerTraceContext) REASON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREASON, 0)
}

func (s *OptimizerTraceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *OptimizerTraceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptimizerTraceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptimizerTraceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterOptimizerTrace(s)
	}
}

func (s *OptimizerTraceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitOptimizerTrace(s)
	}
}

func (s *OptimizerTraceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitOptimizerTrace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) OptimizerTrace() (localctx IOptimizerTraceContext) {
	localctx = NewOptimizerTraceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 906, DorisSQLParserRULE_optimizerTrace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7572)
		p.Match(DorisSQLParserTRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7573)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserALL || _la == DorisSQLParserLOGS || _la == DorisSQLParserREASON || _la == DorisSQLParserTIMES || _la == DorisSQLParserVALUES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(7575)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262756702208) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-6664167256628462851) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-1331487429127569487) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&-7546427580836201) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-4573491655345179) != 0) || ((int64((_la-324)) & ^0x3f) == 0 && ((int64(1)<<(_la-324))&9114828243924942831) != 0) || ((int64((_la-389)) & ^0x3f) == 0 && ((int64(1)<<(_la-389))&-6956096606152176261) != 0) || ((int64((_la-453)) & ^0x3f) == 0 && ((int64(1)<<(_la-453))&70849595962729) != 0) || ((int64((_la-525)) & ^0x3f) == 0 && ((int64(1)<<(_la-525))&263) != 0) {
		{
			p.SetState(7574)
			p.Identifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionExprContext is an interface to support dynamic dispatch.
type IPartitionExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	FunctionCall() IFunctionCallContext

	// IsPartitionExprContext differentiates from other interfaces.
	IsPartitionExprContext()
}

type PartitionExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionExprContext() *PartitionExprContext {
	var p = new(PartitionExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_partitionExpr
	return p
}

func InitEmptyPartitionExprContext(p *PartitionExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_partitionExpr
}

func (*PartitionExprContext) IsPartitionExprContext() {}

func NewPartitionExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionExprContext {
	var p = new(PartitionExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_partitionExpr

	return p
}

func (s *PartitionExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionExprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PartitionExprContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *PartitionExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPartitionExpr(s)
	}
}

func (s *PartitionExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPartitionExpr(s)
	}
}

func (s *PartitionExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPartitionExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PartitionExpr() (localctx IPartitionExprContext) {
	localctx = NewPartitionExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 908, DorisSQLParserRULE_partitionExpr)
	p.SetState(7579)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 895, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7577)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7578)
			p.FunctionCall()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDescContext is an interface to support dynamic dispatch.
type IPartitionDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	AllRangePartitionDesc() []IRangePartitionDescContext
	RangePartitionDesc(i int) IRangePartitionDescContext
	PrimaryExpression() IPrimaryExpressionContext
	LIST() antlr.TerminalNode
	AllListPartitionDesc() []IListPartitionDescContext
	ListPartitionDesc(i int) IListPartitionDescContext
	FunctionCall() IFunctionCallContext
	AllPartitionExpr() []IPartitionExprContext
	PartitionExpr(i int) IPartitionExprContext

	// IsPartitionDescContext differentiates from other interfaces.
	IsPartitionDescContext()
}

type PartitionDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDescContext() *PartitionDescContext {
	var p = new(PartitionDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_partitionDesc
	return p
}

func InitEmptyPartitionDescContext(p *PartitionDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_partitionDesc
}

func (*PartitionDescContext) IsPartitionDescContext() {}

func NewPartitionDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDescContext {
	var p = new(PartitionDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_partitionDesc

	return p
}

func (s *PartitionDescContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDescContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPARTITION, 0)
}

func (s *PartitionDescContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *PartitionDescContext) RANGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRANGE, 0)
}

func (s *PartitionDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PartitionDescContext) AllRangePartitionDesc() []IRangePartitionDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRangePartitionDescContext); ok {
			len++
		}
	}

	tst := make([]IRangePartitionDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRangePartitionDescContext); ok {
			tst[i] = t.(IRangePartitionDescContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDescContext) RangePartitionDesc(i int) IRangePartitionDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangePartitionDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangePartitionDescContext)
}

func (s *PartitionDescContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *PartitionDescContext) LIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIST, 0)
}

func (s *PartitionDescContext) AllListPartitionDesc() []IListPartitionDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IListPartitionDescContext); ok {
			len++
		}
	}

	tst := make([]IListPartitionDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IListPartitionDescContext); ok {
			tst[i] = t.(IListPartitionDescContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDescContext) ListPartitionDesc(i int) IListPartitionDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListPartitionDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListPartitionDescContext)
}

func (s *PartitionDescContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *PartitionDescContext) AllPartitionExpr() []IPartitionExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionExprContext); ok {
			len++
		}
	}

	tst := make([]IPartitionExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionExprContext); ok {
			tst[i] = t.(IPartitionExprContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDescContext) PartitionExpr(i int) IPartitionExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionExprContext)
}

func (s *PartitionDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPartitionDesc(s)
	}
}

func (s *PartitionDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPartitionDesc(s)
	}
}

func (s *PartitionDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPartitionDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PartitionDesc() (localctx IPartitionDescContext) {
	localctx = NewPartitionDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 910, DorisSQLParserRULE_partitionDesc)
	var _la int

	var _alt int

	p.SetState(7669)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 907, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7581)
			p.Match(DorisSQLParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7582)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7583)
			p.Match(DorisSQLParserRANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7584)
			p.IdentifierList()
		}
		{
			p.SetState(7585)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7594)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserPARTITION || _la == DorisSQLParserSTART {
			{
				p.SetState(7586)
				p.RangePartitionDesc()
			}
			p.SetState(7591)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(7587)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7588)
					p.RangePartitionDesc()
				}

				p.SetState(7593)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7596)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7598)
			p.Match(DorisSQLParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7599)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7600)
			p.Match(DorisSQLParserRANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7601)
			p.primaryExpression(0)
		}
		{
			p.SetState(7602)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7611)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserPARTITION || _la == DorisSQLParserSTART {
			{
				p.SetState(7603)
				p.RangePartitionDesc()
			}
			p.SetState(7608)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(7604)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7605)
					p.RangePartitionDesc()
				}

				p.SetState(7610)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7613)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7615)
			p.Match(DorisSQLParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7616)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7618)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserLIST {
			{
				p.SetState(7617)
				p.Match(DorisSQLParserLIST)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7620)
			p.IdentifierList()
		}
		{
			p.SetState(7621)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7630)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserPARTITION {
			{
				p.SetState(7622)
				p.ListPartitionDesc()
			}
			p.SetState(7627)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(7623)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7624)
					p.ListPartitionDesc()
				}

				p.SetState(7629)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7632)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7634)
			p.Match(DorisSQLParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7635)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7637)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserLIST {
			{
				p.SetState(7636)
				p.Match(DorisSQLParserLIST)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7639)
			p.IdentifierList()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7640)
			p.Match(DorisSQLParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7641)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7642)
			p.FunctionCall()
		}
		{
			p.SetState(7643)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7652)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserPARTITION || _la == DorisSQLParserSTART {
			{
				p.SetState(7644)
				p.RangePartitionDesc()
			}
			p.SetState(7649)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserT__2 {
				{
					p.SetState(7645)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7646)
					p.RangePartitionDesc()
				}

				p.SetState(7651)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7654)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7656)
			p.Match(DorisSQLParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7657)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7658)
			p.FunctionCall()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7659)
			p.Match(DorisSQLParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7660)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7661)
			p.PartitionExpr()
		}
		p.SetState(7666)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 906, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(7662)
					p.Match(DorisSQLParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7663)
					p.PartitionExpr()
				}

			}
			p.SetState(7668)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 906, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListPartitionDescContext is an interface to support dynamic dispatch.
type IListPartitionDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleItemListPartitionDesc() ISingleItemListPartitionDescContext
	MultiItemListPartitionDesc() IMultiItemListPartitionDescContext

	// IsListPartitionDescContext differentiates from other interfaces.
	IsListPartitionDescContext()
}

type ListPartitionDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListPartitionDescContext() *ListPartitionDescContext {
	var p = new(ListPartitionDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_listPartitionDesc
	return p
}

func InitEmptyListPartitionDescContext(p *ListPartitionDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_listPartitionDesc
}

func (*ListPartitionDescContext) IsListPartitionDescContext() {}

func NewListPartitionDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListPartitionDescContext {
	var p = new(ListPartitionDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_listPartitionDesc

	return p
}

func (s *ListPartitionDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ListPartitionDescContext) SingleItemListPartitionDesc() ISingleItemListPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleItemListPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleItemListPartitionDescContext)
}

func (s *ListPartitionDescContext) MultiItemListPartitionDesc() IMultiItemListPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiItemListPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiItemListPartitionDescContext)
}

func (s *ListPartitionDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListPartitionDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListPartitionDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterListPartitionDesc(s)
	}
}

func (s *ListPartitionDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitListPartitionDesc(s)
	}
}

func (s *ListPartitionDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitListPartitionDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ListPartitionDesc() (localctx IListPartitionDescContext) {
	localctx = NewListPartitionDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 912, DorisSQLParserRULE_listPartitionDesc)
	p.SetState(7673)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 908, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7671)
			p.SingleItemListPartitionDesc()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7672)
			p.MultiItemListPartitionDesc()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleItemListPartitionDescContext is an interface to support dynamic dispatch.
type ISingleItemListPartitionDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	VALUES() antlr.TerminalNode
	IN() antlr.TerminalNode
	SingleListPartitionValues() ISingleListPartitionValuesContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsSingleItemListPartitionDescContext differentiates from other interfaces.
	IsSingleItemListPartitionDescContext()
}

type SingleItemListPartitionDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleItemListPartitionDescContext() *SingleItemListPartitionDescContext {
	var p = new(SingleItemListPartitionDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_singleItemListPartitionDesc
	return p
}

func InitEmptySingleItemListPartitionDescContext(p *SingleItemListPartitionDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_singleItemListPartitionDesc
}

func (*SingleItemListPartitionDescContext) IsSingleItemListPartitionDescContext() {}

func NewSingleItemListPartitionDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleItemListPartitionDescContext {
	var p = new(SingleItemListPartitionDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_singleItemListPartitionDesc

	return p
}

func (s *SingleItemListPartitionDescContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleItemListPartitionDescContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPARTITION, 0)
}

func (s *SingleItemListPartitionDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SingleItemListPartitionDescContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVALUES, 0)
}

func (s *SingleItemListPartitionDescContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *SingleItemListPartitionDescContext) SingleListPartitionValues() ISingleListPartitionValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleListPartitionValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleListPartitionValuesContext)
}

func (s *SingleItemListPartitionDescContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *SingleItemListPartitionDescContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *SingleItemListPartitionDescContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *SingleItemListPartitionDescContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *SingleItemListPartitionDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleItemListPartitionDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleItemListPartitionDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSingleItemListPartitionDesc(s)
	}
}

func (s *SingleItemListPartitionDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSingleItemListPartitionDesc(s)
	}
}

func (s *SingleItemListPartitionDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSingleItemListPartitionDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SingleItemListPartitionDesc() (localctx ISingleItemListPartitionDescContext) {
	localctx = NewSingleItemListPartitionDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 914, DorisSQLParserRULE_singleItemListPartitionDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7675)
		p.Match(DorisSQLParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7679)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(7676)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7677)
			p.Match(DorisSQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7678)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(7681)
		p.Identifier()
	}
	{
		p.SetState(7682)
		p.Match(DorisSQLParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7683)
		p.Match(DorisSQLParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7684)
		p.SingleListPartitionValues()
	}
	p.SetState(7686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserT__1 {
		{
			p.SetState(7685)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiItemListPartitionDescContext is an interface to support dynamic dispatch.
type IMultiItemListPartitionDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	VALUES() antlr.TerminalNode
	IN() antlr.TerminalNode
	MultiListPartitionValues() IMultiListPartitionValuesContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsMultiItemListPartitionDescContext differentiates from other interfaces.
	IsMultiItemListPartitionDescContext()
}

type MultiItemListPartitionDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiItemListPartitionDescContext() *MultiItemListPartitionDescContext {
	var p = new(MultiItemListPartitionDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_multiItemListPartitionDesc
	return p
}

func InitEmptyMultiItemListPartitionDescContext(p *MultiItemListPartitionDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_multiItemListPartitionDesc
}

func (*MultiItemListPartitionDescContext) IsMultiItemListPartitionDescContext() {}

func NewMultiItemListPartitionDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiItemListPartitionDescContext {
	var p = new(MultiItemListPartitionDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_multiItemListPartitionDesc

	return p
}

func (s *MultiItemListPartitionDescContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiItemListPartitionDescContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPARTITION, 0)
}

func (s *MultiItemListPartitionDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MultiItemListPartitionDescContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVALUES, 0)
}

func (s *MultiItemListPartitionDescContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIN, 0)
}

func (s *MultiItemListPartitionDescContext) MultiListPartitionValues() IMultiListPartitionValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiListPartitionValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiListPartitionValuesContext)
}

func (s *MultiItemListPartitionDescContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *MultiItemListPartitionDescContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *MultiItemListPartitionDescContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *MultiItemListPartitionDescContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *MultiItemListPartitionDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiItemListPartitionDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiItemListPartitionDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterMultiItemListPartitionDesc(s)
	}
}

func (s *MultiItemListPartitionDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitMultiItemListPartitionDesc(s)
	}
}

func (s *MultiItemListPartitionDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitMultiItemListPartitionDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) MultiItemListPartitionDesc() (localctx IMultiItemListPartitionDescContext) {
	localctx = NewMultiItemListPartitionDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 916, DorisSQLParserRULE_multiItemListPartitionDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7688)
		p.Match(DorisSQLParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7692)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(7689)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7690)
			p.Match(DorisSQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7691)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(7694)
		p.Identifier()
	}
	{
		p.SetState(7695)
		p.Match(DorisSQLParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7696)
		p.Match(DorisSQLParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7697)
		p.MultiListPartitionValues()
	}
	p.SetState(7699)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserT__1 {
		{
			p.SetState(7698)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiListPartitionValuesContext is an interface to support dynamic dispatch.
type IMultiListPartitionValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSingleListPartitionValues() []ISingleListPartitionValuesContext
	SingleListPartitionValues(i int) ISingleListPartitionValuesContext

	// IsMultiListPartitionValuesContext differentiates from other interfaces.
	IsMultiListPartitionValuesContext()
}

type MultiListPartitionValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiListPartitionValuesContext() *MultiListPartitionValuesContext {
	var p = new(MultiListPartitionValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_multiListPartitionValues
	return p
}

func InitEmptyMultiListPartitionValuesContext(p *MultiListPartitionValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_multiListPartitionValues
}

func (*MultiListPartitionValuesContext) IsMultiListPartitionValuesContext() {}

func NewMultiListPartitionValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiListPartitionValuesContext {
	var p = new(MultiListPartitionValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_multiListPartitionValues

	return p
}

func (s *MultiListPartitionValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiListPartitionValuesContext) AllSingleListPartitionValues() []ISingleListPartitionValuesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleListPartitionValuesContext); ok {
			len++
		}
	}

	tst := make([]ISingleListPartitionValuesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleListPartitionValuesContext); ok {
			tst[i] = t.(ISingleListPartitionValuesContext)
			i++
		}
	}

	return tst
}

func (s *MultiListPartitionValuesContext) SingleListPartitionValues(i int) ISingleListPartitionValuesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleListPartitionValuesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleListPartitionValuesContext)
}

func (s *MultiListPartitionValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiListPartitionValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiListPartitionValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterMultiListPartitionValues(s)
	}
}

func (s *MultiListPartitionValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitMultiListPartitionValues(s)
	}
}

func (s *MultiListPartitionValuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitMultiListPartitionValues(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) MultiListPartitionValues() (localctx IMultiListPartitionValuesContext) {
	localctx = NewMultiListPartitionValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 918, DorisSQLParserRULE_multiListPartitionValues)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7701)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7702)
		p.SingleListPartitionValues()
	}
	p.SetState(7707)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(7703)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7704)
			p.SingleListPartitionValues()
		}

		p.SetState(7709)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7710)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleListPartitionValuesContext is an interface to support dynamic dispatch.
type ISingleListPartitionValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllListPartitionValue() []IListPartitionValueContext
	ListPartitionValue(i int) IListPartitionValueContext

	// IsSingleListPartitionValuesContext differentiates from other interfaces.
	IsSingleListPartitionValuesContext()
}

type SingleListPartitionValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleListPartitionValuesContext() *SingleListPartitionValuesContext {
	var p = new(SingleListPartitionValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_singleListPartitionValues
	return p
}

func InitEmptySingleListPartitionValuesContext(p *SingleListPartitionValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_singleListPartitionValues
}

func (*SingleListPartitionValuesContext) IsSingleListPartitionValuesContext() {}

func NewSingleListPartitionValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleListPartitionValuesContext {
	var p = new(SingleListPartitionValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_singleListPartitionValues

	return p
}

func (s *SingleListPartitionValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleListPartitionValuesContext) AllListPartitionValue() []IListPartitionValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IListPartitionValueContext); ok {
			len++
		}
	}

	tst := make([]IListPartitionValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IListPartitionValueContext); ok {
			tst[i] = t.(IListPartitionValueContext)
			i++
		}
	}

	return tst
}

func (s *SingleListPartitionValuesContext) ListPartitionValue(i int) IListPartitionValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListPartitionValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListPartitionValueContext)
}

func (s *SingleListPartitionValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleListPartitionValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleListPartitionValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSingleListPartitionValues(s)
	}
}

func (s *SingleListPartitionValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSingleListPartitionValues(s)
	}
}

func (s *SingleListPartitionValuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSingleListPartitionValues(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SingleListPartitionValues() (localctx ISingleListPartitionValuesContext) {
	localctx = NewSingleListPartitionValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 920, DorisSQLParserRULE_singleListPartitionValues)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7712)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7713)
		p.ListPartitionValue()
	}
	p.SetState(7718)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(7714)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7715)
			p.ListPartitionValue()
		}

		p.SetState(7720)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7721)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListPartitionValuesContext is an interface to support dynamic dispatch.
type IListPartitionValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleListPartitionValues() ISingleListPartitionValuesContext
	MultiListPartitionValues() IMultiListPartitionValuesContext

	// IsListPartitionValuesContext differentiates from other interfaces.
	IsListPartitionValuesContext()
}

type ListPartitionValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListPartitionValuesContext() *ListPartitionValuesContext {
	var p = new(ListPartitionValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_listPartitionValues
	return p
}

func InitEmptyListPartitionValuesContext(p *ListPartitionValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_listPartitionValues
}

func (*ListPartitionValuesContext) IsListPartitionValuesContext() {}

func NewListPartitionValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListPartitionValuesContext {
	var p = new(ListPartitionValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_listPartitionValues

	return p
}

func (s *ListPartitionValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *ListPartitionValuesContext) SingleListPartitionValues() ISingleListPartitionValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleListPartitionValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleListPartitionValuesContext)
}

func (s *ListPartitionValuesContext) MultiListPartitionValues() IMultiListPartitionValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiListPartitionValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiListPartitionValuesContext)
}

func (s *ListPartitionValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListPartitionValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListPartitionValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterListPartitionValues(s)
	}
}

func (s *ListPartitionValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitListPartitionValues(s)
	}
}

func (s *ListPartitionValuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitListPartitionValues(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ListPartitionValues() (localctx IListPartitionValuesContext) {
	localctx = NewListPartitionValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 922, DorisSQLParserRULE_listPartitionValues)
	p.SetState(7725)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 915, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7723)
			p.SingleListPartitionValues()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7724)
			p.MultiListPartitionValues()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListPartitionValueContext is an interface to support dynamic dispatch.
type IListPartitionValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL() antlr.TerminalNode
	String_() IStringContext

	// IsListPartitionValueContext differentiates from other interfaces.
	IsListPartitionValueContext()
}

type ListPartitionValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListPartitionValueContext() *ListPartitionValueContext {
	var p = new(ListPartitionValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_listPartitionValue
	return p
}

func InitEmptyListPartitionValueContext(p *ListPartitionValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_listPartitionValue
}

func (*ListPartitionValueContext) IsListPartitionValueContext() {}

func NewListPartitionValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListPartitionValueContext {
	var p = new(ListPartitionValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_listPartitionValue

	return p
}

func (s *ListPartitionValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ListPartitionValueContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNULL, 0)
}

func (s *ListPartitionValueContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ListPartitionValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListPartitionValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListPartitionValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterListPartitionValue(s)
	}
}

func (s *ListPartitionValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitListPartitionValue(s)
	}
}

func (s *ListPartitionValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitListPartitionValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ListPartitionValue() (localctx IListPartitionValueContext) {
	localctx = NewListPartitionValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 924, DorisSQLParserRULE_listPartitionValue)
	p.SetState(7729)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserNULL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7727)
			p.Match(DorisSQLParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserSINGLE_QUOTED_TEXT, DorisSQLParserDOUBLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7728)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringListContext is an interface to support dynamic dispatch.
type IStringListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsStringListContext differentiates from other interfaces.
	IsStringListContext()
}

type StringListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringListContext() *StringListContext {
	var p = new(StringListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_stringList
	return p
}

func InitEmptyStringListContext(p *StringListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_stringList
}

func (*StringListContext) IsStringListContext() {}

func NewStringListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringListContext {
	var p = new(StringListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_stringList

	return p
}

func (s *StringListContext) GetParser() antlr.Parser { return s.parser }

func (s *StringListContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *StringListContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *StringListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterStringList(s)
	}
}

func (s *StringListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitStringList(s)
	}
}

func (s *StringListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitStringList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) StringList() (localctx IStringListContext) {
	localctx = NewStringListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 926, DorisSQLParserRULE_stringList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7731)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7732)
		p.String_()
	}
	p.SetState(7737)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(7733)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7734)
			p.String_()
		}

		p.SetState(7739)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7740)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralExpressionListContext is an interface to support dynamic dispatch.
type ILiteralExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLiteralExpression() []ILiteralExpressionContext
	LiteralExpression(i int) ILiteralExpressionContext

	// IsLiteralExpressionListContext differentiates from other interfaces.
	IsLiteralExpressionListContext()
}

type LiteralExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralExpressionListContext() *LiteralExpressionListContext {
	var p = new(LiteralExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_literalExpressionList
	return p
}

func InitEmptyLiteralExpressionListContext(p *LiteralExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_literalExpressionList
}

func (*LiteralExpressionListContext) IsLiteralExpressionListContext() {}

func NewLiteralExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralExpressionListContext {
	var p = new(LiteralExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_literalExpressionList

	return p
}

func (s *LiteralExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralExpressionListContext) AllLiteralExpression() []ILiteralExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			len++
		}
	}

	tst := make([]ILiteralExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILiteralExpressionContext); ok {
			tst[i] = t.(ILiteralExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LiteralExpressionListContext) LiteralExpression(i int) ILiteralExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionContext)
}

func (s *LiteralExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterLiteralExpressionList(s)
	}
}

func (s *LiteralExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitLiteralExpressionList(s)
	}
}

func (s *LiteralExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitLiteralExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) LiteralExpressionList() (localctx ILiteralExpressionListContext) {
	localctx = NewLiteralExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 928, DorisSQLParserRULE_literalExpressionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7742)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7743)
		p.LiteralExpression()
	}
	p.SetState(7748)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(7744)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7745)
			p.LiteralExpression()
		}

		p.SetState(7750)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7751)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangePartitionDescContext is an interface to support dynamic dispatch.
type IRangePartitionDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleRangePartition() ISingleRangePartitionContext
	MultiRangePartition() IMultiRangePartitionContext

	// IsRangePartitionDescContext differentiates from other interfaces.
	IsRangePartitionDescContext()
}

type RangePartitionDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangePartitionDescContext() *RangePartitionDescContext {
	var p = new(RangePartitionDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_rangePartitionDesc
	return p
}

func InitEmptyRangePartitionDescContext(p *RangePartitionDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_rangePartitionDesc
}

func (*RangePartitionDescContext) IsRangePartitionDescContext() {}

func NewRangePartitionDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangePartitionDescContext {
	var p = new(RangePartitionDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_rangePartitionDesc

	return p
}

func (s *RangePartitionDescContext) GetParser() antlr.Parser { return s.parser }

func (s *RangePartitionDescContext) SingleRangePartition() ISingleRangePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleRangePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleRangePartitionContext)
}

func (s *RangePartitionDescContext) MultiRangePartition() IMultiRangePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiRangePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiRangePartitionContext)
}

func (s *RangePartitionDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangePartitionDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangePartitionDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRangePartitionDesc(s)
	}
}

func (s *RangePartitionDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRangePartitionDesc(s)
	}
}

func (s *RangePartitionDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRangePartitionDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) RangePartitionDesc() (localctx IRangePartitionDescContext) {
	localctx = NewRangePartitionDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 930, DorisSQLParserRULE_rangePartitionDesc)
	p.SetState(7755)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserPARTITION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7753)
			p.SingleRangePartition()
		}

	case DorisSQLParserSTART:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7754)
			p.MultiRangePartition()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleRangePartitionContext is an interface to support dynamic dispatch.
type ISingleRangePartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	VALUES() antlr.TerminalNode
	PartitionKeyDesc() IPartitionKeyDescContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsSingleRangePartitionContext differentiates from other interfaces.
	IsSingleRangePartitionContext()
}

type SingleRangePartitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleRangePartitionContext() *SingleRangePartitionContext {
	var p = new(SingleRangePartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_singleRangePartition
	return p
}

func InitEmptySingleRangePartitionContext(p *SingleRangePartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_singleRangePartition
}

func (*SingleRangePartitionContext) IsSingleRangePartitionContext() {}

func NewSingleRangePartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleRangePartitionContext {
	var p = new(SingleRangePartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_singleRangePartition

	return p
}

func (s *SingleRangePartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleRangePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPARTITION, 0)
}

func (s *SingleRangePartitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SingleRangePartitionContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVALUES, 0)
}

func (s *SingleRangePartitionContext) PartitionKeyDesc() IPartitionKeyDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionKeyDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionKeyDescContext)
}

func (s *SingleRangePartitionContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIF, 0)
}

func (s *SingleRangePartitionContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNOT, 0)
}

func (s *SingleRangePartitionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXISTS, 0)
}

func (s *SingleRangePartitionContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *SingleRangePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleRangePartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleRangePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSingleRangePartition(s)
	}
}

func (s *SingleRangePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSingleRangePartition(s)
	}
}

func (s *SingleRangePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSingleRangePartition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SingleRangePartition() (localctx ISingleRangePartitionContext) {
	localctx = NewSingleRangePartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 932, DorisSQLParserRULE_singleRangePartition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7757)
		p.Match(DorisSQLParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7761)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserIF {
		{
			p.SetState(7758)
			p.Match(DorisSQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7759)
			p.Match(DorisSQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7760)
			p.Match(DorisSQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(7763)
		p.Identifier()
	}
	{
		p.SetState(7764)
		p.Match(DorisSQLParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7765)
		p.PartitionKeyDesc()
	}
	p.SetState(7767)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserT__1 {
		{
			p.SetState(7766)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiRangePartitionContext is an interface to support dynamic dispatch.
type IMultiRangePartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	END() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	Interval() IIntervalContext
	INTEGER_VALUE() antlr.TerminalNode

	// IsMultiRangePartitionContext differentiates from other interfaces.
	IsMultiRangePartitionContext()
}

type MultiRangePartitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiRangePartitionContext() *MultiRangePartitionContext {
	var p = new(MultiRangePartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_multiRangePartition
	return p
}

func InitEmptyMultiRangePartitionContext(p *MultiRangePartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_multiRangePartition
}

func (*MultiRangePartitionContext) IsMultiRangePartitionContext() {}

func NewMultiRangePartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiRangePartitionContext {
	var p = new(MultiRangePartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_multiRangePartition

	return p
}

func (s *MultiRangePartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiRangePartitionContext) START() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTART, 0)
}

func (s *MultiRangePartitionContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *MultiRangePartitionContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *MultiRangePartitionContext) END() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEND, 0)
}

func (s *MultiRangePartitionContext) EVERY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEVERY, 0)
}

func (s *MultiRangePartitionContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *MultiRangePartitionContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, 0)
}

func (s *MultiRangePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiRangePartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiRangePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterMultiRangePartition(s)
	}
}

func (s *MultiRangePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitMultiRangePartition(s)
	}
}

func (s *MultiRangePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitMultiRangePartition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) MultiRangePartition() (localctx IMultiRangePartitionContext) {
	localctx = NewMultiRangePartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 934, DorisSQLParserRULE_multiRangePartition)
	p.SetState(7795)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 922, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7769)
			p.Match(DorisSQLParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7770)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7771)
			p.String_()
		}
		{
			p.SetState(7772)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7773)
			p.Match(DorisSQLParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7774)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7775)
			p.String_()
		}
		{
			p.SetState(7776)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7777)
			p.Match(DorisSQLParserEVERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7778)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7779)
			p.Interval()
		}
		{
			p.SetState(7780)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7782)
			p.Match(DorisSQLParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7783)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7784)
			p.String_()
		}
		{
			p.SetState(7785)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7786)
			p.Match(DorisSQLParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7787)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7788)
			p.String_()
		}
		{
			p.SetState(7789)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7790)
			p.Match(DorisSQLParserEVERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7791)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7792)
			p.Match(DorisSQLParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7793)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionRangeDescContext is an interface to support dynamic dispatch.
type IPartitionRangeDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	END() antlr.TerminalNode

	// IsPartitionRangeDescContext differentiates from other interfaces.
	IsPartitionRangeDescContext()
}

type PartitionRangeDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionRangeDescContext() *PartitionRangeDescContext {
	var p = new(PartitionRangeDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_partitionRangeDesc
	return p
}

func InitEmptyPartitionRangeDescContext(p *PartitionRangeDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_partitionRangeDesc
}

func (*PartitionRangeDescContext) IsPartitionRangeDescContext() {}

func NewPartitionRangeDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionRangeDescContext {
	var p = new(PartitionRangeDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_partitionRangeDesc

	return p
}

func (s *PartitionRangeDescContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionRangeDescContext) START() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTART, 0)
}

func (s *PartitionRangeDescContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *PartitionRangeDescContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *PartitionRangeDescContext) END() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEND, 0)
}

func (s *PartitionRangeDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionRangeDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionRangeDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPartitionRangeDesc(s)
	}
}

func (s *PartitionRangeDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPartitionRangeDesc(s)
	}
}

func (s *PartitionRangeDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPartitionRangeDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PartitionRangeDesc() (localctx IPartitionRangeDescContext) {
	localctx = NewPartitionRangeDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 936, DorisSQLParserRULE_partitionRangeDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7797)
		p.Match(DorisSQLParserSTART)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7798)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7799)
		p.String_()
	}
	{
		p.SetState(7800)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7801)
		p.Match(DorisSQLParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7802)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7803)
		p.String_()
	}
	{
		p.SetState(7804)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionKeyDescContext is an interface to support dynamic dispatch.
type IPartitionKeyDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LESS() antlr.TerminalNode
	THAN() antlr.TerminalNode
	MAXVALUE() antlr.TerminalNode
	AllPartitionValueList() []IPartitionValueListContext
	PartitionValueList(i int) IPartitionValueListContext

	// IsPartitionKeyDescContext differentiates from other interfaces.
	IsPartitionKeyDescContext()
}

type PartitionKeyDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionKeyDescContext() *PartitionKeyDescContext {
	var p = new(PartitionKeyDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_partitionKeyDesc
	return p
}

func InitEmptyPartitionKeyDescContext(p *PartitionKeyDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_partitionKeyDesc
}

func (*PartitionKeyDescContext) IsPartitionKeyDescContext() {}

func NewPartitionKeyDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionKeyDescContext {
	var p = new(PartitionKeyDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_partitionKeyDesc

	return p
}

func (s *PartitionKeyDescContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionKeyDescContext) LESS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLESS, 0)
}

func (s *PartitionKeyDescContext) THAN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTHAN, 0)
}

func (s *PartitionKeyDescContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMAXVALUE, 0)
}

func (s *PartitionKeyDescContext) AllPartitionValueList() []IPartitionValueListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueListContext); ok {
			tst[i] = t.(IPartitionValueListContext)
			i++
		}
	}

	return tst
}

func (s *PartitionKeyDescContext) PartitionValueList(i int) IPartitionValueListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueListContext)
}

func (s *PartitionKeyDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionKeyDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionKeyDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPartitionKeyDesc(s)
	}
}

func (s *PartitionKeyDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPartitionKeyDesc(s)
	}
}

func (s *PartitionKeyDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPartitionKeyDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PartitionKeyDesc() (localctx IPartitionKeyDescContext) {
	localctx = NewPartitionKeyDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 938, DorisSQLParserRULE_partitionKeyDesc)
	p.SetState(7818)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserLESS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7806)
			p.Match(DorisSQLParserLESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7807)
			p.Match(DorisSQLParserTHAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7810)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserMAXVALUE:
			{
				p.SetState(7808)
				p.Match(DorisSQLParserMAXVALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisSQLParserT__1:
			{
				p.SetState(7809)
				p.PartitionValueList()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case DorisSQLParserT__5:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7812)
			p.Match(DorisSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7813)
			p.PartitionValueList()
		}
		{
			p.SetState(7814)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7815)
			p.PartitionValueList()
		}
		{
			p.SetState(7816)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionValueListContext is an interface to support dynamic dispatch.
type IPartitionValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPartitionValue() []IPartitionValueContext
	PartitionValue(i int) IPartitionValueContext

	// IsPartitionValueListContext differentiates from other interfaces.
	IsPartitionValueListContext()
}

type PartitionValueListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionValueListContext() *PartitionValueListContext {
	var p = new(PartitionValueListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_partitionValueList
	return p
}

func InitEmptyPartitionValueListContext(p *PartitionValueListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_partitionValueList
}

func (*PartitionValueListContext) IsPartitionValueListContext() {}

func NewPartitionValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValueListContext {
	var p = new(PartitionValueListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_partitionValueList

	return p
}

func (s *PartitionValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValueListContext) AllPartitionValue() []IPartitionValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueContext); ok {
			tst[i] = t.(IPartitionValueContext)
			i++
		}
	}

	return tst
}

func (s *PartitionValueListContext) PartitionValue(i int) IPartitionValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueContext)
}

func (s *PartitionValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionValueListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPartitionValueList(s)
	}
}

func (s *PartitionValueListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPartitionValueList(s)
	}
}

func (s *PartitionValueListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPartitionValueList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PartitionValueList() (localctx IPartitionValueListContext) {
	localctx = NewPartitionValueListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 940, DorisSQLParserRULE_partitionValueList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7820)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7821)
		p.PartitionValue()
	}
	p.SetState(7826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(7822)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7823)
			p.PartitionValue()
		}

		p.SetState(7828)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7829)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyPartitionContext is an interface to support dynamic dispatch.
type IKeyPartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionColName returns the partitionColName rule contexts.
	GetPartitionColName() IIdentifierContext

	// GetPartitionColValue returns the partitionColValue rule contexts.
	GetPartitionColValue() ILiteralExpressionContext

	// SetPartitionColName sets the partitionColName rule contexts.
	SetPartitionColName(IIdentifierContext)

	// SetPartitionColValue sets the partitionColValue rule contexts.
	SetPartitionColValue(ILiteralExpressionContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	Identifier() IIdentifierContext
	LiteralExpression() ILiteralExpressionContext

	// IsKeyPartitionContext differentiates from other interfaces.
	IsKeyPartitionContext()
}

type KeyPartitionContext struct {
	antlr.BaseParserRuleContext
	parser            antlr.Parser
	partitionColName  IIdentifierContext
	partitionColValue ILiteralExpressionContext
}

func NewEmptyKeyPartitionContext() *KeyPartitionContext {
	var p = new(KeyPartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_keyPartition
	return p
}

func InitEmptyKeyPartitionContext(p *KeyPartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_keyPartition
}

func (*KeyPartitionContext) IsKeyPartitionContext() {}

func NewKeyPartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyPartitionContext {
	var p = new(KeyPartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_keyPartition

	return p
}

func (s *KeyPartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyPartitionContext) GetPartitionColName() IIdentifierContext { return s.partitionColName }

func (s *KeyPartitionContext) GetPartitionColValue() ILiteralExpressionContext {
	return s.partitionColValue
}

func (s *KeyPartitionContext) SetPartitionColName(v IIdentifierContext) { s.partitionColName = v }

func (s *KeyPartitionContext) SetPartitionColValue(v ILiteralExpressionContext) {
	s.partitionColValue = v
}

func (s *KeyPartitionContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEQ, 0)
}

func (s *KeyPartitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *KeyPartitionContext) LiteralExpression() ILiteralExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionContext)
}

func (s *KeyPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyPartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterKeyPartition(s)
	}
}

func (s *KeyPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitKeyPartition(s)
	}
}

func (s *KeyPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitKeyPartition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) KeyPartition() (localctx IKeyPartitionContext) {
	localctx = NewKeyPartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 942, DorisSQLParserRULE_keyPartition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7831)

		var _x = p.Identifier()

		localctx.(*KeyPartitionContext).partitionColName = _x
	}
	{
		p.SetState(7832)
		p.Match(DorisSQLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7833)

		var _x = p.LiteralExpression()

		localctx.(*KeyPartitionContext).partitionColValue = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionValueContext is an interface to support dynamic dispatch.
type IPartitionValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAXVALUE() antlr.TerminalNode
	String_() IStringContext

	// IsPartitionValueContext differentiates from other interfaces.
	IsPartitionValueContext()
}

type PartitionValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionValueContext() *PartitionValueContext {
	var p = new(PartitionValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_partitionValue
	return p
}

func InitEmptyPartitionValueContext(p *PartitionValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_partitionValue
}

func (*PartitionValueContext) IsPartitionValueContext() {}

func NewPartitionValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValueContext {
	var p = new(PartitionValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_partitionValue

	return p
}

func (s *PartitionValueContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValueContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMAXVALUE, 0)
}

func (s *PartitionValueContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *PartitionValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPartitionValue(s)
	}
}

func (s *PartitionValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPartitionValue(s)
	}
}

func (s *PartitionValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPartitionValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PartitionValue() (localctx IPartitionValueContext) {
	localctx = NewPartitionValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 944, DorisSQLParserRULE_partitionValue)
	p.SetState(7837)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserMAXVALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7835)
			p.Match(DorisSQLParserMAXVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserSINGLE_QUOTED_TEXT, DorisSQLParserDOUBLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7836)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDistributionClauseContext is an interface to support dynamic dispatch.
type IDistributionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTRIBUTED() antlr.TerminalNode
	BY() antlr.TerminalNode
	HASH() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	BUCKETS() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsDistributionClauseContext differentiates from other interfaces.
	IsDistributionClauseContext()
}

type DistributionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistributionClauseContext() *DistributionClauseContext {
	var p = new(DistributionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_distributionClause
	return p
}

func InitEmptyDistributionClauseContext(p *DistributionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_distributionClause
}

func (*DistributionClauseContext) IsDistributionClauseContext() {}

func NewDistributionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistributionClauseContext {
	var p = new(DistributionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_distributionClause

	return p
}

func (s *DistributionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DistributionClauseContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDISTRIBUTED, 0)
}

func (s *DistributionClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *DistributionClauseContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserHASH, 0)
}

func (s *DistributionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DistributionClauseContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBUCKETS, 0)
}

func (s *DistributionClauseContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, 0)
}

func (s *DistributionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistributionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DistributionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDistributionClause(s)
	}
}

func (s *DistributionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDistributionClause(s)
	}
}

func (s *DistributionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDistributionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DistributionClause() (localctx IDistributionClauseContext) {
	localctx = NewDistributionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 946, DorisSQLParserRULE_distributionClause)
	var _la int

	p.SetState(7851)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 928, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7839)
			p.Match(DorisSQLParserDISTRIBUTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7840)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7841)
			p.Match(DorisSQLParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7842)
			p.IdentifierList()
		}
		p.SetState(7845)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserBUCKETS {
			{
				p.SetState(7843)
				p.Match(DorisSQLParserBUCKETS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7844)
				p.Match(DorisSQLParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7847)
			p.Match(DorisSQLParserDISTRIBUTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7848)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7849)
			p.Match(DorisSQLParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7850)
			p.IdentifierList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDistributionDescContext is an interface to support dynamic dispatch.
type IDistributionDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTRIBUTED() antlr.TerminalNode
	BY() antlr.TerminalNode
	HASH() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	BUCKETS() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	RANDOM() antlr.TerminalNode

	// IsDistributionDescContext differentiates from other interfaces.
	IsDistributionDescContext()
}

type DistributionDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistributionDescContext() *DistributionDescContext {
	var p = new(DistributionDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_distributionDesc
	return p
}

func InitEmptyDistributionDescContext(p *DistributionDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_distributionDesc
}

func (*DistributionDescContext) IsDistributionDescContext() {}

func NewDistributionDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistributionDescContext {
	var p = new(DistributionDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_distributionDesc

	return p
}

func (s *DistributionDescContext) GetParser() antlr.Parser { return s.parser }

func (s *DistributionDescContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDISTRIBUTED, 0)
}

func (s *DistributionDescContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBY, 0)
}

func (s *DistributionDescContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserHASH, 0)
}

func (s *DistributionDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DistributionDescContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBUCKETS, 0)
}

func (s *DistributionDescContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, 0)
}

func (s *DistributionDescContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRANDOM, 0)
}

func (s *DistributionDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistributionDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DistributionDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDistributionDesc(s)
	}
}

func (s *DistributionDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDistributionDesc(s)
	}
}

func (s *DistributionDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDistributionDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DistributionDesc() (localctx IDistributionDescContext) {
	localctx = NewDistributionDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 948, DorisSQLParserRULE_distributionDesc)
	var _la int

	p.SetState(7872)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 931, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7853)
			p.Match(DorisSQLParserDISTRIBUTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7854)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7855)
			p.Match(DorisSQLParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7856)
			p.IdentifierList()
		}
		p.SetState(7859)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserBUCKETS {
			{
				p.SetState(7857)
				p.Match(DorisSQLParserBUCKETS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7858)
				p.Match(DorisSQLParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7861)
			p.Match(DorisSQLParserDISTRIBUTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7862)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7863)
			p.Match(DorisSQLParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7864)
			p.IdentifierList()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7865)
			p.Match(DorisSQLParserDISTRIBUTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7866)
			p.Match(DorisSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7867)
			p.Match(DorisSQLParserRANDOM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7870)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserBUCKETS {
			{
				p.SetState(7868)
				p.Match(DorisSQLParserBUCKETS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7869)
				p.Match(DorisSQLParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshSchemeDescContext is an interface to support dynamic dispatch.
type IRefreshSchemeDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REFRESH() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	Interval() IIntervalContext
	INCREMENTAL() antlr.TerminalNode
	MANUAL() antlr.TerminalNode
	IMMEDIATE() antlr.TerminalNode
	DEFERRED() antlr.TerminalNode
	START() antlr.TerminalNode
	String_() IStringContext

	// IsRefreshSchemeDescContext differentiates from other interfaces.
	IsRefreshSchemeDescContext()
}

type RefreshSchemeDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefreshSchemeDescContext() *RefreshSchemeDescContext {
	var p = new(RefreshSchemeDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_refreshSchemeDesc
	return p
}

func InitEmptyRefreshSchemeDescContext(p *RefreshSchemeDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_refreshSchemeDesc
}

func (*RefreshSchemeDescContext) IsRefreshSchemeDescContext() {}

func NewRefreshSchemeDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshSchemeDescContext {
	var p = new(RefreshSchemeDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_refreshSchemeDesc

	return p
}

func (s *RefreshSchemeDescContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshSchemeDescContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREFRESH, 0)
}

func (s *RefreshSchemeDescContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserASYNC, 0)
}

func (s *RefreshSchemeDescContext) EVERY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEVERY, 0)
}

func (s *RefreshSchemeDescContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *RefreshSchemeDescContext) INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINCREMENTAL, 0)
}

func (s *RefreshSchemeDescContext) MANUAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMANUAL, 0)
}

func (s *RefreshSchemeDescContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIMMEDIATE, 0)
}

func (s *RefreshSchemeDescContext) DEFERRED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDEFERRED, 0)
}

func (s *RefreshSchemeDescContext) START() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTART, 0)
}

func (s *RefreshSchemeDescContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *RefreshSchemeDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshSchemeDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshSchemeDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterRefreshSchemeDesc(s)
	}
}

func (s *RefreshSchemeDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitRefreshSchemeDesc(s)
	}
}

func (s *RefreshSchemeDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitRefreshSchemeDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) RefreshSchemeDesc() (localctx IRefreshSchemeDescContext) {
	localctx = NewRefreshSchemeDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 950, DorisSQLParserRULE_refreshSchemeDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7874)
		p.Match(DorisSQLParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7876)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserDEFERRED || _la == DorisSQLParserIMMEDIATE {
		{
			p.SetState(7875)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserDEFERRED || _la == DorisSQLParserIMMEDIATE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(7894)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 934, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(7878)
			p.Match(DorisSQLParserASYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(7879)
			p.Match(DorisSQLParserASYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7885)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserSTART {
			{
				p.SetState(7880)
				p.Match(DorisSQLParserSTART)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7881)
				p.Match(DorisSQLParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7882)
				p.String_()
			}
			{
				p.SetState(7883)
				p.Match(DorisSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7887)
			p.Match(DorisSQLParserEVERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7888)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7889)
			p.Interval()
		}
		{
			p.SetState(7890)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(7892)
			p.Match(DorisSQLParserINCREMENTAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(7893)
			p.Match(DorisSQLParserMANUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatusDescContext is an interface to support dynamic dispatch.
type IStatusDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACTIVE() antlr.TerminalNode
	INACTIVE() antlr.TerminalNode

	// IsStatusDescContext differentiates from other interfaces.
	IsStatusDescContext()
}

type StatusDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatusDescContext() *StatusDescContext {
	var p = new(StatusDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_statusDesc
	return p
}

func InitEmptyStatusDescContext(p *StatusDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_statusDesc
}

func (*StatusDescContext) IsStatusDescContext() {}

func NewStatusDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatusDescContext {
	var p = new(StatusDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_statusDesc

	return p
}

func (s *StatusDescContext) GetParser() antlr.Parser { return s.parser }

func (s *StatusDescContext) ACTIVE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserACTIVE, 0)
}

func (s *StatusDescContext) INACTIVE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINACTIVE, 0)
}

func (s *StatusDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatusDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatusDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterStatusDesc(s)
	}
}

func (s *StatusDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitStatusDesc(s)
	}
}

func (s *StatusDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitStatusDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) StatusDesc() (localctx IStatusDescContext) {
	localctx = NewStatusDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 952, DorisSQLParserRULE_statusDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7896)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserACTIVE || _la == DorisSQLParserINACTIVE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertiesContext is an interface to support dynamic dispatch.
type IPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROPERTIES() antlr.TerminalNode
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext

	// IsPropertiesContext differentiates from other interfaces.
	IsPropertiesContext()
}

type PropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertiesContext() *PropertiesContext {
	var p = new(PropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_properties
	return p
}

func InitEmptyPropertiesContext(p *PropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_properties
}

func (*PropertiesContext) IsPropertiesContext() {}

func NewPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertiesContext {
	var p = new(PropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_properties

	return p
}

func (s *PropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertiesContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROPERTIES, 0)
}

func (s *PropertiesContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *PropertiesContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *PropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterProperties(s)
	}
}

func (s *PropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitProperties(s)
	}
}

func (s *PropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Properties() (localctx IPropertiesContext) {
	localctx = NewPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 954, DorisSQLParserRULE_properties)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7898)
		p.Match(DorisSQLParserPROPERTIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7899)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7900)
		p.Property()
	}
	p.SetState(7905)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(7901)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7902)
			p.Property()
		}

		p.SetState(7907)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7908)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtPropertiesContext is an interface to support dynamic dispatch.
type IExtPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BROKER() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsExtPropertiesContext differentiates from other interfaces.
	IsExtPropertiesContext()
}

type ExtPropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtPropertiesContext() *ExtPropertiesContext {
	var p = new(ExtPropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_extProperties
	return p
}

func InitEmptyExtPropertiesContext(p *ExtPropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_extProperties
}

func (*ExtPropertiesContext) IsExtPropertiesContext() {}

func NewExtPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtPropertiesContext {
	var p = new(ExtPropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_extProperties

	return p
}

func (s *ExtPropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtPropertiesContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBROKER, 0)
}

func (s *ExtPropertiesContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *ExtPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtPropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterExtProperties(s)
	}
}

func (s *ExtPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitExtProperties(s)
	}
}

func (s *ExtPropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitExtProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ExtProperties() (localctx IExtPropertiesContext) {
	localctx = NewExtPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 956, DorisSQLParserRULE_extProperties)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7910)
		p.Match(DorisSQLParserBROKER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7911)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyListContext is an interface to support dynamic dispatch.
type IPropertyListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext

	// IsPropertyListContext differentiates from other interfaces.
	IsPropertyListContext()
}

type PropertyListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyListContext() *PropertyListContext {
	var p = new(PropertyListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_propertyList
	return p
}

func InitEmptyPropertyListContext(p *PropertyListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_propertyList
}

func (*PropertyListContext) IsPropertyListContext() {}

func NewPropertyListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyListContext {
	var p = new(PropertyListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_propertyList

	return p
}

func (s *PropertyListContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyListContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *PropertyListContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *PropertyListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterPropertyList(s)
	}
}

func (s *PropertyListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitPropertyList(s)
	}
}

func (s *PropertyListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitPropertyList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) PropertyList() (localctx IPropertyListContext) {
	localctx = NewPropertyListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 958, DorisSQLParserRULE_propertyList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7913)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7914)
		p.Property()
	}
	p.SetState(7919)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(7915)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7916)
			p.Property()
		}

		p.SetState(7921)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7922)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserPropertyListContext is an interface to support dynamic dispatch.
type IUserPropertyListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext

	// IsUserPropertyListContext differentiates from other interfaces.
	IsUserPropertyListContext()
}

type UserPropertyListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserPropertyListContext() *UserPropertyListContext {
	var p = new(UserPropertyListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_userPropertyList
	return p
}

func InitEmptyUserPropertyListContext(p *UserPropertyListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_userPropertyList
}

func (*UserPropertyListContext) IsUserPropertyListContext() {}

func NewUserPropertyListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserPropertyListContext {
	var p = new(UserPropertyListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_userPropertyList

	return p
}

func (s *UserPropertyListContext) GetParser() antlr.Parser { return s.parser }

func (s *UserPropertyListContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *UserPropertyListContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *UserPropertyListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserPropertyListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserPropertyListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterUserPropertyList(s)
	}
}

func (s *UserPropertyListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitUserPropertyList(s)
	}
}

func (s *UserPropertyListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitUserPropertyList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) UserPropertyList() (localctx IUserPropertyListContext) {
	localctx = NewUserPropertyListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 960, DorisSQLParserRULE_userPropertyList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7924)
		p.Property()
	}
	p.SetState(7929)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(7925)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7926)
			p.Property()
		}

		p.SetState(7931)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyContext is an interface to support dynamic dispatch.
type IPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IStringContext

	// GetValue returns the value rule contexts.
	GetValue() IStringContext

	// SetKey sets the key rule contexts.
	SetKey(IStringContext)

	// SetValue sets the value rule contexts.
	SetValue(IStringContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsPropertyContext differentiates from other interfaces.
	IsPropertyContext()
}

type PropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IStringContext
	value  IStringContext
}

func NewEmptyPropertyContext() *PropertyContext {
	var p = new(PropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_property
	return p
}

func InitEmptyPropertyContext(p *PropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_property
}

func (*PropertyContext) IsPropertyContext() {}

func NewPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyContext {
	var p = new(PropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_property

	return p
}

func (s *PropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyContext) GetKey() IStringContext { return s.key }

func (s *PropertyContext) GetValue() IStringContext { return s.value }

func (s *PropertyContext) SetKey(v IStringContext) { s.key = v }

func (s *PropertyContext) SetValue(v IStringContext) { s.value = v }

func (s *PropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEQ, 0)
}

func (s *PropertyContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *PropertyContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *PropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterProperty(s)
	}
}

func (s *PropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitProperty(s)
	}
}

func (s *PropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Property() (localctx IPropertyContext) {
	localctx = NewPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 962, DorisSQLParserRULE_property)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7932)

		var _x = p.String_()

		localctx.(*PropertyContext).key = _x
	}
	{
		p.SetState(7933)
		p.Match(DorisSQLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7934)

		var _x = p.String_()

		localctx.(*PropertyContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlinePropertiesContext is an interface to support dynamic dispatch.
type IInlinePropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInlineProperty() []IInlinePropertyContext
	InlineProperty(i int) IInlinePropertyContext

	// IsInlinePropertiesContext differentiates from other interfaces.
	IsInlinePropertiesContext()
}

type InlinePropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlinePropertiesContext() *InlinePropertiesContext {
	var p = new(InlinePropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_inlineProperties
	return p
}

func InitEmptyInlinePropertiesContext(p *InlinePropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_inlineProperties
}

func (*InlinePropertiesContext) IsInlinePropertiesContext() {}

func NewInlinePropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlinePropertiesContext {
	var p = new(InlinePropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_inlineProperties

	return p
}

func (s *InlinePropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *InlinePropertiesContext) AllInlineProperty() []IInlinePropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInlinePropertyContext); ok {
			len++
		}
	}

	tst := make([]IInlinePropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInlinePropertyContext); ok {
			tst[i] = t.(IInlinePropertyContext)
			i++
		}
	}

	return tst
}

func (s *InlinePropertiesContext) InlineProperty(i int) IInlinePropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlinePropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlinePropertyContext)
}

func (s *InlinePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlinePropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlinePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterInlineProperties(s)
	}
}

func (s *InlinePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitInlineProperties(s)
	}
}

func (s *InlinePropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitInlineProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) InlineProperties() (localctx IInlinePropertiesContext) {
	localctx = NewInlinePropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 964, DorisSQLParserRULE_inlineProperties)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7936)
		p.InlineProperty()
	}
	p.SetState(7940)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262756702208) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-6664167256628462851) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-1331487429127569487) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&-7546427580836201) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-4573491655345179) != 0) || ((int64((_la-324)) & ^0x3f) == 0 && ((int64(1)<<(_la-324))&9114828243924942831) != 0) || ((int64((_la-389)) & ^0x3f) == 0 && ((int64(1)<<(_la-389))&-6956096606152176261) != 0) || ((int64((_la-453)) & ^0x3f) == 0 && ((int64(1)<<(_la-453))&70849595962729) != 0) || ((int64((_la-525)) & ^0x3f) == 0 && ((int64(1)<<(_la-525))&263) != 0) {
		{
			p.SetState(7937)
			p.InlineProperty()
		}

		p.SetState(7942)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlinePropertyContext is an interface to support dynamic dispatch.
type IInlinePropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IIdentifierContext

	// GetValue returns the value rule contexts.
	GetValue() IStringContext

	// SetKey sets the key rule contexts.
	SetKey(IIdentifierContext)

	// SetValue sets the value rule contexts.
	SetValue(IStringContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	Identifier() IIdentifierContext
	String_() IStringContext

	// IsInlinePropertyContext differentiates from other interfaces.
	IsInlinePropertyContext()
}

type InlinePropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IIdentifierContext
	value  IStringContext
}

func NewEmptyInlinePropertyContext() *InlinePropertyContext {
	var p = new(InlinePropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_inlineProperty
	return p
}

func InitEmptyInlinePropertyContext(p *InlinePropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_inlineProperty
}

func (*InlinePropertyContext) IsInlinePropertyContext() {}

func NewInlinePropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlinePropertyContext {
	var p = new(InlinePropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_inlineProperty

	return p
}

func (s *InlinePropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *InlinePropertyContext) GetKey() IIdentifierContext { return s.key }

func (s *InlinePropertyContext) GetValue() IStringContext { return s.value }

func (s *InlinePropertyContext) SetKey(v IIdentifierContext) { s.key = v }

func (s *InlinePropertyContext) SetValue(v IStringContext) { s.value = v }

func (s *InlinePropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEQ, 0)
}

func (s *InlinePropertyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InlinePropertyContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *InlinePropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlinePropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlinePropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterInlineProperty(s)
	}
}

func (s *InlinePropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitInlineProperty(s)
	}
}

func (s *InlinePropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitInlineProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) InlineProperty() (localctx IInlinePropertyContext) {
	localctx = NewInlinePropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 966, DorisSQLParserRULE_inlineProperty)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7943)

		var _x = p.Identifier()

		localctx.(*InlinePropertyContext).key = _x
	}
	{
		p.SetState(7944)
		p.Match(DorisSQLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7945)

		var _x = p.String_()

		localctx.(*InlinePropertyContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarTypeContext is an interface to support dynamic dispatch.
type IVarTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GLOBAL() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	VERBOSE() antlr.TerminalNode

	// IsVarTypeContext differentiates from other interfaces.
	IsVarTypeContext()
}

type VarTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarTypeContext() *VarTypeContext {
	var p = new(VarTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_varType
	return p
}

func InitEmptyVarTypeContext(p *VarTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_varType
}

func (*VarTypeContext) IsVarTypeContext() {}

func NewVarTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarTypeContext {
	var p = new(VarTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_varType

	return p
}

func (s *VarTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *VarTypeContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGLOBAL, 0)
}

func (s *VarTypeContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOCAL, 0)
}

func (s *VarTypeContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSESSION, 0)
}

func (s *VarTypeContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVERBOSE, 0)
}

func (s *VarTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterVarType(s)
	}
}

func (s *VarTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitVarType(s)
	}
}

func (s *VarTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitVarType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) VarType() (localctx IVarTypeContext) {
	localctx = NewVarTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 968, DorisSQLParserRULE_varType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7947)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserGLOBAL || _la == DorisSQLParserLOCAL || _la == DorisSQLParserSESSION || _la == DorisSQLParserVERBOSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommentContext is an interface to support dynamic dispatch.
type ICommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMENT() antlr.TerminalNode
	String_() IStringContext

	// IsCommentContext differentiates from other interfaces.
	IsCommentContext()
}

type CommentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentContext() *CommentContext {
	var p = new(CommentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_comment
	return p
}

func InitEmptyCommentContext(p *CommentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_comment
}

func (*CommentContext) IsCommentContext() {}

func NewCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentContext {
	var p = new(CommentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_comment

	return p
}

func (s *CommentContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOMMENT, 0)
}

func (s *CommentContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterComment(s)
	}
}

func (s *CommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitComment(s)
	}
}

func (s *CommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitComment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Comment() (localctx ICommentContext) {
	localctx = NewCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 970, DorisSQLParserRULE_comment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7949)
		p.Match(DorisSQLParserCOMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7950)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOutfileContext is an interface to support dynamic dispatch.
type IOutfileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFile returns the file rule contexts.
	GetFile() IStringContext

	// SetFile sets the file rule contexts.
	SetFile(IStringContext)

	// Getter signatures
	INTO() antlr.TerminalNode
	OUTFILE() antlr.TerminalNode
	String_() IStringContext
	FileFormat() IFileFormatContext
	Properties() IPropertiesContext

	// IsOutfileContext differentiates from other interfaces.
	IsOutfileContext()
}

type OutfileContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	file   IStringContext
}

func NewEmptyOutfileContext() *OutfileContext {
	var p = new(OutfileContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_outfile
	return p
}

func InitEmptyOutfileContext(p *OutfileContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_outfile
}

func (*OutfileContext) IsOutfileContext() {}

func NewOutfileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OutfileContext {
	var p = new(OutfileContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_outfile

	return p
}

func (s *OutfileContext) GetParser() antlr.Parser { return s.parser }

func (s *OutfileContext) GetFile() IStringContext { return s.file }

func (s *OutfileContext) SetFile(v IStringContext) { s.file = v }

func (s *OutfileContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTO, 0)
}

func (s *OutfileContext) OUTFILE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOUTFILE, 0)
}

func (s *OutfileContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *OutfileContext) FileFormat() IFileFormatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileFormatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileFormatContext)
}

func (s *OutfileContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *OutfileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OutfileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OutfileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterOutfile(s)
	}
}

func (s *OutfileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitOutfile(s)
	}
}

func (s *OutfileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitOutfile(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Outfile() (localctx IOutfileContext) {
	localctx = NewOutfileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 972, DorisSQLParserRULE_outfile)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7952)
		p.Match(DorisSQLParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7953)
		p.Match(DorisSQLParserOUTFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7954)

		var _x = p.String_()

		localctx.(*OutfileContext).file = _x
	}
	p.SetState(7956)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFORMAT {
		{
			p.SetState(7955)
			p.FileFormat()
		}

	}
	p.SetState(7959)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserPROPERTIES {
		{
			p.SetState(7958)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFileFormatContext is an interface to support dynamic dispatch.
type IFileFormatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FORMAT() antlr.TerminalNode
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext
	String_() IStringContext

	// IsFileFormatContext differentiates from other interfaces.
	IsFileFormatContext()
}

type FileFormatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileFormatContext() *FileFormatContext {
	var p = new(FileFormatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_fileFormat
	return p
}

func InitEmptyFileFormatContext(p *FileFormatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_fileFormat
}

func (*FileFormatContext) IsFileFormatContext() {}

func NewFileFormatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileFormatContext {
	var p = new(FileFormatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_fileFormat

	return p
}

func (s *FileFormatContext) GetParser() antlr.Parser { return s.parser }

func (s *FileFormatContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFORMAT, 0)
}

func (s *FileFormatContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *FileFormatContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FileFormatContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *FileFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileFormatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterFileFormat(s)
	}
}

func (s *FileFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitFileFormat(s)
	}
}

func (s *FileFormatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitFileFormat(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) FileFormat() (localctx IFileFormatContext) {
	localctx = NewFileFormatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 974, DorisSQLParserRULE_fileFormat)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7961)
		p.Match(DorisSQLParserFORMAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7962)
		p.Match(DorisSQLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7965)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserACCESS, DorisSQLParserACTIVE, DorisSQLParserADMIN, DorisSQLParserADVISOR, DorisSQLParserAFTER, DorisSQLParserAGGREGATE, DorisSQLParserANTI, DorisSQLParserAPPLY, DorisSQLParserARRAY_AGG, DorisSQLParserARRAY_AGG_DISTINCT, DorisSQLParserASYNC, DorisSQLParserAUTHORS, DorisSQLParserAUTHENTICATION, DorisSQLParserAUTOMATED, DorisSQLParserAUTO_INCREMENT, DorisSQLParserAVG, DorisSQLParserBACKEND, DorisSQLParserBACKENDS, DorisSQLParserBACKUP, DorisSQLParserBASE, DorisSQLParserBASELINE, DorisSQLParserBEGIN, DorisSQLParserBINARY, DorisSQLParserBITMAP_UNION, DorisSQLParserBLACKHOLE, DorisSQLParserBLACKLIST, DorisSQLParserBODY, DorisSQLParserBOOLEAN, DorisSQLParserBRANCH, DorisSQLParserBROKER, DorisSQLParserBUCKETS, DorisSQLParserBUILTIN, DorisSQLParserCACHE, DorisSQLParserCANCEL, DorisSQLParserCAST, DorisSQLParserCATALOG, DorisSQLParserCATALOGS, DorisSQLParserCEIL, DorisSQLParserCHAIN, DorisSQLParserCHARSET, DorisSQLParserCLEAN, DorisSQLParserCLEAR, DorisSQLParserCLUSTER, DorisSQLParserCLUSTERS, DorisSQLParserCNGROUP, DorisSQLParserCNGROUPS, DorisSQLParserCOLLATION, DorisSQLParserCOLUMNS, DorisSQLParserCOMMENT, DorisSQLParserCOMMIT, DorisSQLParserCOMMITTED, DorisSQLParserCOMPACT, DorisSQLParserCOMPUTE, DorisSQLParserCONFIG, DorisSQLParserCONNECTION, DorisSQLParserCONSISTENT, DorisSQLParserCOSTS, DorisSQLParserCOUNT, DorisSQLParserCUME_DIST, DorisSQLParserCUMULATIVE, DorisSQLParserCURRENT, DorisSQLParserDATA, DorisSQLParserDATACACHE, DorisSQLParserDATE, DorisSQLParserDATETIME, DorisSQLParserDAY, DorisSQLParserDAYS, DorisSQLParserDEALLOCATE, DorisSQLParserDECOMMISSION, DorisSQLParserDIALECT, DorisSQLParserDICTIONARY, DorisSQLParserDICTIONARY_GET, DorisSQLParserDISABLE, DorisSQLParserDISTRIBUTED, DorisSQLParserDISTRIBUTION, DorisSQLParserDUPLICATE, DorisSQLParserDYNAMIC, DorisSQLParserENABLE, DorisSQLParserENCLOSE, DorisSQLParserEND, DorisSQLParserENGINE, DorisSQLParserENGINES, DorisSQLParserERRORS, DorisSQLParserESCAPE, DorisSQLParserEVENTS, DorisSQLParserEXCEPT, DorisSQLParserEXCLUDE, DorisSQLParserEXECUTE, DorisSQLParserEXPORT, DorisSQLParserEXTERNAL, DorisSQLParserEXTRACT, DorisSQLParserEVERY, DorisSQLParserFAILPOINT, DorisSQLParserFAILPOINTS, DorisSQLParserFIELDS, DorisSQLParserFILE, DorisSQLParserFILTER, DorisSQLParserFIRST, DorisSQLParserFLOOR, DorisSQLParserFN, DorisSQLParserFOLLOWING, DorisSQLParserFOLLOWER, DorisSQLParserFORMAT, DorisSQLParserFREE, DorisSQLParserFRONTEND, DorisSQLParserFRONTENDS, DorisSQLParserFUNCTIONS, DorisSQLParserGLOBAL, DorisSQLParserGRANTS, DorisSQLParserGROUP_CONCAT, DorisSQLParserHASH, DorisSQLParserHELP, DorisSQLParserHISTOGRAM, DorisSQLParserHLL_UNION, DorisSQLParserHOST, DorisSQLParserHOUR, DorisSQLParserHOURS, DorisSQLParserHUB, DorisSQLParserIDENTIFIED, DorisSQLParserIMPERSONATE, DorisSQLParserIMAGE, DorisSQLParserINACTIVE, DorisSQLParserINCREMENTAL, DorisSQLParserINDEXES, DorisSQLParserINSTALL, DorisSQLParserINTEGRATION, DorisSQLParserINTEGRATIONS, DorisSQLParserINTERMEDIATE, DorisSQLParserINTERVAL, DorisSQLParserOVERWRITE, DorisSQLParserISOLATION, DorisSQLParserJOB, DorisSQLParserLABEL, DorisSQLParserLAST, DorisSQLParserLESS, DorisSQLParserLEVEL, DorisSQLParserLIST, DorisSQLParserLOCAL, DorisSQLParserLOCATION, DorisSQLParserLOCATIONS, DorisSQLParserLOGS, DorisSQLParserLOGICAL, DorisSQLParserMANUAL, DorisSQLParserMAP, DorisSQLParserMAPPING, DorisSQLParserMAPPINGS, DorisSQLParserMASKING, DorisSQLParserMATCH, DorisSQLParserMATERIALIZED, DorisSQLParserMAX, DorisSQLParserMERGE, DorisSQLParserMIN, DorisSQLParserMINUTE, DorisSQLParserMINUTES, DorisSQLParserMINUS, DorisSQLParserMETA, DorisSQLParserMODE, DorisSQLParserMODIFY, DorisSQLParserMONTH, DorisSQLParserMULTIPLE, DorisSQLParserNAME, DorisSQLParserNAMES, DorisSQLParserNEGATIVE, DorisSQLParserNGRAMBF, DorisSQLParserNO, DorisSQLParserNODE, DorisSQLParserNODES, DorisSQLParserNONE, DorisSQLParserNULLS, DorisSQLParserNUMBER, DorisSQLParserNUMERIC, DorisSQLParserOBSERVER, DorisSQLParserOF, DorisSQLParserOFF, DorisSQLParserOFFSET, DorisSQLParserONLY, DorisSQLParserOPEN, DorisSQLParserOPERATE, DorisSQLParserOPTIMIZER, DorisSQLParserOPTION, DorisSQLParserPARTITIONS, DorisSQLParserPASSWORD, DorisSQLParserPATH, DorisSQLParserPAUSE, DorisSQLParserPENDING, DorisSQLParserPERCENT_RANK, DorisSQLParserPERCENTILE_UNION, DorisSQLParserPLAN, DorisSQLParserPLUGIN, DorisSQLParserPLUGINS, DorisSQLParserPIPE, DorisSQLParserPIPES, DorisSQLParserPIVOT, DorisSQLParserPOLICY, DorisSQLParserPOLICIES, DorisSQLParserPRECEDING, DorisSQLParserPREDICATE, DorisSQLParserPRIORITY, DorisSQLParserPRIVILEGES, DorisSQLParserPROBABILITY, DorisSQLParserPROC, DorisSQLParserPROCESSLIST, DorisSQLParserPROFILE, DorisSQLParserPROFILELIST, DorisSQLParserPROPERTIES, DorisSQLParserPROPERTY, DorisSQLParserPROVIDER, DorisSQLParserPROVIDERS, DorisSQLParserQUALIFY, DorisSQLParserQUARTER, DorisSQLParserQUERY, DorisSQLParserQUERIES, DorisSQLParserQUEUE, DorisSQLParserQUOTA, DorisSQLParserRANDOM, DorisSQLParserRANK, DorisSQLParserREASON, DorisSQLParserRECOVER, DorisSQLParserREFRESH, DorisSQLParserREWRITE, DorisSQLParserREMOVE, DorisSQLParserREPAIR, DorisSQLParserREPEATABLE, DorisSQLParserREPLACE_IF_NOT_NULL, DorisSQLParserREPLICA, DorisSQLParserREPOSITORY, DorisSQLParserREPOSITORIES, DorisSQLParserRESOURCE, DorisSQLParserRESOURCES, DorisSQLParserRESTORE, DorisSQLParserRESUME, DorisSQLParserRETAIN, DorisSQLParserRETENTION, DorisSQLParserRETURNS, DorisSQLParserRETRY, DorisSQLParserREVERT, DorisSQLParserROLE, DorisSQLParserROLES, DorisSQLParserROLLBACK, DorisSQLParserROLLUP, DorisSQLParserROUTINE, DorisSQLParserROW, DorisSQLParserRULE, DorisSQLParserRULES, DorisSQLParserRUNNING, DorisSQLParserSAMPLE, DorisSQLParserSCHEDULE, DorisSQLParserSCHEDULER, DorisSQLParserSECOND, DorisSQLParserSECURITY, DorisSQLParserSEMI, DorisSQLParserSEPARATOR, DorisSQLParserSERIALIZABLE, DorisSQLParserSESSION, DorisSQLParserSETS, DorisSQLParserSIGNED, DorisSQLParserSKIP_HEADER, DorisSQLParserSNAPSHOT, DorisSQLParserSNAPSHOTS, DorisSQLParserSQLBLACKLIST, DorisSQLParserSTART, DorisSQLParserSTATS, DorisSQLParserSTATUS, DorisSQLParserSTOP, DorisSQLParserSTORAGE, DorisSQLParserSTREAM, DorisSQLParserSTRING, DorisSQLParserSUBMIT, DorisSQLParserSUM, DorisSQLParserSUSPEND, DorisSQLParserSYNC, DorisSQLParserSYSTEM_TIME, DorisSQLParserSWAP, DorisSQLParserSTRUCT, DorisSQLParserTABLES, DorisSQLParserTABLET, DorisSQLParserTABLETS, DorisSQLParserTAG, DorisSQLParserTASK, DorisSQLParserTEMPORARY, DorisSQLParserTHAN, DorisSQLParserTIME, DorisSQLParserTIMES, DorisSQLParserTIMESTAMP, DorisSQLParserTIMESTAMPADD, DorisSQLParserTIMESTAMPDIFF, DorisSQLParserTRANSACTION, DorisSQLParserTRANSLATE, DorisSQLParserTRACE, DorisSQLParserTRIGGERS, DorisSQLParserTRIM_SPACE, DorisSQLParserTRUNCATE, DorisSQLParserTYPE, DorisSQLParserTYPES, DorisSQLParserUNBOUNDED, DorisSQLParserUNCOMMITTED, DorisSQLParserUNINSTALL, DorisSQLParserUNSET, DorisSQLParserUSAGE, DorisSQLParserUSER, DorisSQLParserUSERS, DorisSQLParserVALUE, DorisSQLParserVARBINARY, DorisSQLParserVARIABLES, DorisSQLParserVECTOR, DorisSQLParserVERBOSE, DorisSQLParserVERSION, DorisSQLParserVIEW, DorisSQLParserVIEWS, DorisSQLParserVOLUME, DorisSQLParserVOLUMES, DorisSQLParserWAREHOUSE, DorisSQLParserWAREHOUSES, DorisSQLParserWARNINGS, DorisSQLParserWEEK, DorisSQLParserWHITELIST, DorisSQLParserWORK, DorisSQLParserWRITE, DorisSQLParserYEAR, DorisSQLParserLOCK, DorisSQLParserUNLOCK, DorisSQLParserLOW_PRIORITY, DorisSQLParserDISK, DorisSQLParserBEFORE, DorisSQLParserFIELD, DorisSQLParserPERSISTENT, DorisSQLParserARRAY_ELEMENT, DorisSQLParserLETTER_IDENTIFIER, DorisSQLParserDIGIT_IDENTIFIER, DorisSQLParserBACKQUOTED_IDENTIFIER, DorisSQLParserDOTDOTDOT:
		{
			p.SetState(7963)
			p.Identifier()
		}

	case DorisSQLParserSINGLE_QUOTED_TEXT, DorisSQLParserDOUBLE_QUOTED_TEXT:
		{
			p.SetState(7964)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringContext is an interface to support dynamic dispatch.
type IStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SINGLE_QUOTED_TEXT() antlr.TerminalNode
	DOUBLE_QUOTED_TEXT() antlr.TerminalNode

	// IsStringContext differentiates from other interfaces.
	IsStringContext()
}

type StringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringContext() *StringContext {
	var p = new(StringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_string
	return p
}

func InitEmptyStringContext(p *StringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_string
}

func (*StringContext) IsStringContext() {}

func NewStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringContext {
	var p = new(StringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_string

	return p
}

func (s *StringContext) GetParser() antlr.Parser { return s.parser }

func (s *StringContext) SINGLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSINGLE_QUOTED_TEXT, 0)
}

func (s *StringContext) DOUBLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDOUBLE_QUOTED_TEXT, 0)
}

func (s *StringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterString(s)
	}
}

func (s *StringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitString(s)
	}
}

func (s *StringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) String_() (localctx IStringContext) {
	localctx = NewStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 976, DorisSQLParserRULE_string)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7967)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserSINGLE_QUOTED_TEXT || _la == DorisSQLParserDOUBLE_QUOTED_TEXT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBinaryContext is an interface to support dynamic dispatch.
type IBinaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BINARY_SINGLE_QUOTED_TEXT() antlr.TerminalNode
	BINARY_DOUBLE_QUOTED_TEXT() antlr.TerminalNode

	// IsBinaryContext differentiates from other interfaces.
	IsBinaryContext()
}

type BinaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinaryContext() *BinaryContext {
	var p = new(BinaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_binary
	return p
}

func InitEmptyBinaryContext(p *BinaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_binary
}

func (*BinaryContext) IsBinaryContext() {}

func NewBinaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinaryContext {
	var p = new(BinaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_binary

	return p
}

func (s *BinaryContext) GetParser() antlr.Parser { return s.parser }

func (s *BinaryContext) BINARY_SINGLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBINARY_SINGLE_QUOTED_TEXT, 0)
}

func (s *BinaryContext) BINARY_DOUBLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBINARY_DOUBLE_QUOTED_TEXT, 0)
}

func (s *BinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterBinary(s)
	}
}

func (s *BinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitBinary(s)
	}
}

func (s *BinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Binary() (localctx IBinaryContext) {
	localctx = NewBinaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 978, DorisSQLParserRULE_binary)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7969)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserBINARY_SINGLE_QUOTED_TEXT || _la == DorisSQLParserBINARY_DOUBLE_QUOTED_TEXT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQ() antlr.TerminalNode
	NEQ() antlr.TerminalNode
	LT() antlr.TerminalNode
	LTE() antlr.TerminalNode
	GT() antlr.TerminalNode
	GTE() antlr.TerminalNode
	EQ_FOR_NULL() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_comparisonOperator
	return p
}

func InitEmptyComparisonOperatorContext(p *ComparisonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_comparisonOperator
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEQ, 0)
}

func (s *ComparisonOperatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNEQ, 0)
}

func (s *ComparisonOperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLT, 0)
}

func (s *ComparisonOperatorContext) LTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLTE, 0)
}

func (s *ComparisonOperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGT, 0)
}

func (s *ComparisonOperatorContext) GTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGTE, 0)
}

func (s *ComparisonOperatorContext) EQ_FOR_NULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEQ_FOR_NULL, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitComparisonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 980, DorisSQLParserRULE_comparisonOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7971)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-492)) & ^0x3f) == 0 && ((int64(1)<<(_la-492))&127) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanValueContext is an interface to support dynamic dispatch.
type IBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBooleanValueContext differentiates from other interfaces.
	IsBooleanValueContext()
}

type BooleanValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueContext() *BooleanValueContext {
	var p = new(BooleanValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_booleanValue
	return p
}

func InitEmptyBooleanValueContext(p *BooleanValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_booleanValue
}

func (*BooleanValueContext) IsBooleanValueContext() {}

func NewBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueContext {
	var p = new(BooleanValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_booleanValue

	return p
}

func (s *BooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTRUE, 0)
}

func (s *BooleanValueContext) FALSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFALSE, 0)
}

func (s *BooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterBooleanValue(s)
	}
}

func (s *BooleanValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitBooleanValue(s)
	}
}

func (s *BooleanValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitBooleanValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) BooleanValue() (localctx IBooleanValueContext) {
	localctx = NewBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 982, DorisSQLParserRULE_booleanValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7973)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserFALSE || _la == DorisSQLParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalContext is an interface to support dynamic dispatch.
type IIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value rule contexts.
	GetValue() IExpressionContext

	// GetFrom returns the from rule contexts.
	GetFrom() IUnitIdentifierContext

	// SetValue sets the value rule contexts.
	SetValue(IExpressionContext)

	// SetFrom sets the from rule contexts.
	SetFrom(IUnitIdentifierContext)

	// Getter signatures
	INTERVAL() antlr.TerminalNode
	Expression() IExpressionContext
	UnitIdentifier() IUnitIdentifierContext

	// IsIntervalContext differentiates from other interfaces.
	IsIntervalContext()
}

type IntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  IExpressionContext
	from   IUnitIdentifierContext
}

func NewEmptyIntervalContext() *IntervalContext {
	var p = new(IntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_interval
	return p
}

func InitEmptyIntervalContext(p *IntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_interval
}

func (*IntervalContext) IsIntervalContext() {}

func NewIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalContext {
	var p = new(IntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_interval

	return p
}

func (s *IntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalContext) GetValue() IExpressionContext { return s.value }

func (s *IntervalContext) GetFrom() IUnitIdentifierContext { return s.from }

func (s *IntervalContext) SetValue(v IExpressionContext) { s.value = v }

func (s *IntervalContext) SetFrom(v IUnitIdentifierContext) { s.from = v }

func (s *IntervalContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTERVAL, 0)
}

func (s *IntervalContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalContext) UnitIdentifier() IUnitIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitIdentifierContext)
}

func (s *IntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterInterval(s)
	}
}

func (s *IntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitInterval(s)
	}
}

func (s *IntervalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitInterval(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Interval() (localctx IIntervalContext) {
	localctx = NewIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 984, DorisSQLParserRULE_interval)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7975)
		p.Match(DorisSQLParserINTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7976)

		var _x = p.expression(0)

		localctx.(*IntervalContext).value = _x
	}
	{
		p.SetState(7977)

		var _x = p.UnitIdentifier()

		localctx.(*IntervalContext).from = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITaskIntervalContext is an interface to support dynamic dispatch.
type ITaskIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value rule contexts.
	GetValue() IExpressionContext

	// GetFrom returns the from rule contexts.
	GetFrom() ITaskUnitIdentifierContext

	// SetValue sets the value rule contexts.
	SetValue(IExpressionContext)

	// SetFrom sets the from rule contexts.
	SetFrom(ITaskUnitIdentifierContext)

	// Getter signatures
	INTERVAL() antlr.TerminalNode
	Expression() IExpressionContext
	TaskUnitIdentifier() ITaskUnitIdentifierContext

	// IsTaskIntervalContext differentiates from other interfaces.
	IsTaskIntervalContext()
}

type TaskIntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  IExpressionContext
	from   ITaskUnitIdentifierContext
}

func NewEmptyTaskIntervalContext() *TaskIntervalContext {
	var p = new(TaskIntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_taskInterval
	return p
}

func InitEmptyTaskIntervalContext(p *TaskIntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_taskInterval
}

func (*TaskIntervalContext) IsTaskIntervalContext() {}

func NewTaskIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TaskIntervalContext {
	var p = new(TaskIntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_taskInterval

	return p
}

func (s *TaskIntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *TaskIntervalContext) GetValue() IExpressionContext { return s.value }

func (s *TaskIntervalContext) GetFrom() ITaskUnitIdentifierContext { return s.from }

func (s *TaskIntervalContext) SetValue(v IExpressionContext) { s.value = v }

func (s *TaskIntervalContext) SetFrom(v ITaskUnitIdentifierContext) { s.from = v }

func (s *TaskIntervalContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTERVAL, 0)
}

func (s *TaskIntervalContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TaskIntervalContext) TaskUnitIdentifier() ITaskUnitIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITaskUnitIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITaskUnitIdentifierContext)
}

func (s *TaskIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TaskIntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TaskIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTaskInterval(s)
	}
}

func (s *TaskIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTaskInterval(s)
	}
}

func (s *TaskIntervalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTaskInterval(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) TaskInterval() (localctx ITaskIntervalContext) {
	localctx = NewTaskIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 986, DorisSQLParserRULE_taskInterval)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7979)
		p.Match(DorisSQLParserINTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7980)

		var _x = p.expression(0)

		localctx.(*TaskIntervalContext).value = _x
	}
	{
		p.SetState(7981)

		var _x = p.TaskUnitIdentifier()

		localctx.(*TaskIntervalContext).from = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITaskUnitIdentifierContext is an interface to support dynamic dispatch.
type ITaskUnitIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	SECOND() antlr.TerminalNode

	// IsTaskUnitIdentifierContext differentiates from other interfaces.
	IsTaskUnitIdentifierContext()
}

type TaskUnitIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTaskUnitIdentifierContext() *TaskUnitIdentifierContext {
	var p = new(TaskUnitIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_taskUnitIdentifier
	return p
}

func InitEmptyTaskUnitIdentifierContext(p *TaskUnitIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_taskUnitIdentifier
}

func (*TaskUnitIdentifierContext) IsTaskUnitIdentifierContext() {}

func NewTaskUnitIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TaskUnitIdentifierContext {
	var p = new(TaskUnitIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_taskUnitIdentifier

	return p
}

func (s *TaskUnitIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TaskUnitIdentifierContext) DAY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDAY, 0)
}

func (s *TaskUnitIdentifierContext) HOUR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserHOUR, 0)
}

func (s *TaskUnitIdentifierContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMINUTE, 0)
}

func (s *TaskUnitIdentifierContext) SECOND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSECOND, 0)
}

func (s *TaskUnitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TaskUnitIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TaskUnitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTaskUnitIdentifier(s)
	}
}

func (s *TaskUnitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTaskUnitIdentifier(s)
	}
}

func (s *TaskUnitIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTaskUnitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) TaskUnitIdentifier() (localctx ITaskUnitIdentifierContext) {
	localctx = NewTaskUnitIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 988, DorisSQLParserRULE_taskUnitIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7983)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserDAY || _la == DorisSQLParserHOUR || _la == DorisSQLParserMINUTE || _la == DorisSQLParserSECOND) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitIdentifierContext is an interface to support dynamic dispatch.
type IUnitIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YEAR() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	MILLISECOND() antlr.TerminalNode
	MICROSECOND() antlr.TerminalNode

	// IsUnitIdentifierContext differentiates from other interfaces.
	IsUnitIdentifierContext()
}

type UnitIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitIdentifierContext() *UnitIdentifierContext {
	var p = new(UnitIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_unitIdentifier
	return p
}

func InitEmptyUnitIdentifierContext(p *UnitIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_unitIdentifier
}

func (*UnitIdentifierContext) IsUnitIdentifierContext() {}

func NewUnitIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitIdentifierContext {
	var p = new(UnitIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_unitIdentifier

	return p
}

func (s *UnitIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitIdentifierContext) YEAR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserYEAR, 0)
}

func (s *UnitIdentifierContext) MONTH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMONTH, 0)
}

func (s *UnitIdentifierContext) WEEK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWEEK, 0)
}

func (s *UnitIdentifierContext) DAY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDAY, 0)
}

func (s *UnitIdentifierContext) HOUR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserHOUR, 0)
}

func (s *UnitIdentifierContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMINUTE, 0)
}

func (s *UnitIdentifierContext) SECOND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSECOND, 0)
}

func (s *UnitIdentifierContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserQUARTER, 0)
}

func (s *UnitIdentifierContext) MILLISECOND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMILLISECOND, 0)
}

func (s *UnitIdentifierContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMICROSECOND, 0)
}

func (s *UnitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterUnitIdentifier(s)
	}
}

func (s *UnitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitUnitIdentifier(s)
	}
}

func (s *UnitIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitUnitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) UnitIdentifier() (localctx IUnitIdentifierContext) {
	localctx = NewUnitIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 990, DorisSQLParserRULE_unitIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7985)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserDAY || _la == DorisSQLParserHOUR || ((int64((_la-261)) & ^0x3f) == 0 && ((int64(1)<<(_la-261))&1035) != 0) || _la == DorisSQLParserQUARTER || _la == DorisSQLParserSECOND || _la == DorisSQLParserWEEK || _la == DorisSQLParserYEAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitBoundaryContext is an interface to support dynamic dispatch.
type IUnitBoundaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLOOR() antlr.TerminalNode
	CEIL() antlr.TerminalNode

	// IsUnitBoundaryContext differentiates from other interfaces.
	IsUnitBoundaryContext()
}

type UnitBoundaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitBoundaryContext() *UnitBoundaryContext {
	var p = new(UnitBoundaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_unitBoundary
	return p
}

func InitEmptyUnitBoundaryContext(p *UnitBoundaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_unitBoundary
}

func (*UnitBoundaryContext) IsUnitBoundaryContext() {}

func NewUnitBoundaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitBoundaryContext {
	var p = new(UnitBoundaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_unitBoundary

	return p
}

func (s *UnitBoundaryContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitBoundaryContext) FLOOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFLOOR, 0)
}

func (s *UnitBoundaryContext) CEIL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCEIL, 0)
}

func (s *UnitBoundaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitBoundaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitBoundaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterUnitBoundary(s)
	}
}

func (s *UnitBoundaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitUnitBoundary(s)
	}
}

func (s *UnitBoundaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitUnitBoundary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) UnitBoundary() (localctx IUnitBoundaryContext) {
	localctx = NewUnitBoundaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 992, DorisSQLParserRULE_unitBoundary)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7987)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserCEIL || _la == DorisSQLParserFLOOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeContext is an interface to support dynamic dispatch.
type ITypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BaseType() IBaseTypeContext
	DecimalType() IDecimalTypeContext
	ArrayType() IArrayTypeContext
	StructType() IStructTypeContext
	MapType() IMapTypeContext

	// IsTypeContext differentiates from other interfaces.
	IsTypeContext()
}

type TypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeContext() *TypeContext {
	var p = new(TypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_type
	return p
}

func InitEmptyTypeContext(p *TypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_type
}

func (*TypeContext) IsTypeContext() {}

func NewTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeContext {
	var p = new(TypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_type

	return p
}

func (s *TypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeContext) BaseType() IBaseTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTypeContext)
}

func (s *TypeContext) DecimalType() IDecimalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalTypeContext)
}

func (s *TypeContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *TypeContext) StructType() IStructTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructTypeContext)
}

func (s *TypeContext) MapType() IMapTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapTypeContext)
}

func (s *TypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterType(s)
	}
}

func (s *TypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitType(s)
	}
}

func (s *TypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Type_() (localctx ITypeContext) {
	localctx = NewTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 994, DorisSQLParserRULE_type)
	p.SetState(7994)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserBIGINT, DorisSQLParserBINARY, DorisSQLParserBITMAP, DorisSQLParserBOOLEAN, DorisSQLParserCHAR, DorisSQLParserDATE, DorisSQLParserDATETIME, DorisSQLParserDOUBLE, DorisSQLParserFLOAT, DorisSQLParserHLL, DorisSQLParserINT, DorisSQLParserINTEGER, DorisSQLParserJSON, DorisSQLParserLARGEINT, DorisSQLParserPERCENTILE, DorisSQLParserSIGNED, DorisSQLParserSMALLINT, DorisSQLParserSTRING, DorisSQLParserTEXT, DorisSQLParserTIME, DorisSQLParserTINYINT, DorisSQLParserUNSIGNED, DorisSQLParserVARBINARY, DorisSQLParserVARCHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7989)
			p.BaseType()
		}

	case DorisSQLParserDECIMAL, DorisSQLParserDECIMALV2, DorisSQLParserDECIMAL32, DorisSQLParserDECIMAL64, DorisSQLParserDECIMAL128, DorisSQLParserNUMBER, DorisSQLParserNUMERIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7990)
			p.DecimalType()
		}

	case DorisSQLParserARRAY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7991)
			p.ArrayType()
		}

	case DorisSQLParserSTRUCT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7992)
			p.StructType()
		}

	case DorisSQLParserMAP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7993)
			p.MapType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY() antlr.TerminalNode
	LT() antlr.TerminalNode
	Type_() ITypeContext
	GT() antlr.TerminalNode

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_arrayType
	return p
}

func InitEmptyArrayTypeContext(p *ArrayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_arrayType
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserARRAY, 0)
}

func (s *ArrayTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLT, 0)
}

func (s *ArrayTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ArrayTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGT, 0)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (s *ArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 996, DorisSQLParserRULE_arrayType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7996)
		p.Match(DorisSQLParserARRAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7997)
		p.Match(DorisSQLParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7998)
		p.Type_()
	}
	{
		p.SetState(7999)
		p.Match(DorisSQLParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapTypeContext is an interface to support dynamic dispatch.
type IMapTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAP() antlr.TerminalNode
	LT() antlr.TerminalNode
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	GT() antlr.TerminalNode

	// IsMapTypeContext differentiates from other interfaces.
	IsMapTypeContext()
}

type MapTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapTypeContext() *MapTypeContext {
	var p = new(MapTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_mapType
	return p
}

func InitEmptyMapTypeContext(p *MapTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_mapType
}

func (*MapTypeContext) IsMapTypeContext() {}

func NewMapTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapTypeContext {
	var p = new(MapTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_mapType

	return p
}

func (s *MapTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *MapTypeContext) MAP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMAP, 0)
}

func (s *MapTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLT, 0)
}

func (s *MapTypeContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *MapTypeContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *MapTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGT, 0)
}

func (s *MapTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterMapType(s)
	}
}

func (s *MapTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitMapType(s)
	}
}

func (s *MapTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitMapType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) MapType() (localctx IMapTypeContext) {
	localctx = NewMapTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 998, DorisSQLParserRULE_mapType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8001)
		p.Match(DorisSQLParserMAP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8002)
		p.Match(DorisSQLParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8003)
		p.Type_()
	}
	{
		p.SetState(8004)
		p.Match(DorisSQLParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8005)
		p.Type_()
	}
	{
		p.SetState(8006)
		p.Match(DorisSQLParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubfieldDescContext is an interface to support dynamic dispatch.
type ISubfieldDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext
	Identifier() IIdentifierContext
	NestedFieldName() INestedFieldNameContext

	// IsSubfieldDescContext differentiates from other interfaces.
	IsSubfieldDescContext()
}

type SubfieldDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubfieldDescContext() *SubfieldDescContext {
	var p = new(SubfieldDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_subfieldDesc
	return p
}

func InitEmptySubfieldDescContext(p *SubfieldDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_subfieldDesc
}

func (*SubfieldDescContext) IsSubfieldDescContext() {}

func NewSubfieldDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubfieldDescContext {
	var p = new(SubfieldDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_subfieldDesc

	return p
}

func (s *SubfieldDescContext) GetParser() antlr.Parser { return s.parser }

func (s *SubfieldDescContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *SubfieldDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubfieldDescContext) NestedFieldName() INestedFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedFieldNameContext)
}

func (s *SubfieldDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubfieldDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubfieldDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSubfieldDesc(s)
	}
}

func (s *SubfieldDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSubfieldDesc(s)
	}
}

func (s *SubfieldDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSubfieldDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SubfieldDesc() (localctx ISubfieldDescContext) {
	localctx = NewSubfieldDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1000, DorisSQLParserRULE_subfieldDesc)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(8010)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 943, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(8008)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(8009)
			p.NestedFieldName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(8012)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubfieldDescsContext is an interface to support dynamic dispatch.
type ISubfieldDescsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSubfieldDesc() []ISubfieldDescContext
	SubfieldDesc(i int) ISubfieldDescContext

	// IsSubfieldDescsContext differentiates from other interfaces.
	IsSubfieldDescsContext()
}

type SubfieldDescsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubfieldDescsContext() *SubfieldDescsContext {
	var p = new(SubfieldDescsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_subfieldDescs
	return p
}

func InitEmptySubfieldDescsContext(p *SubfieldDescsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_subfieldDescs
}

func (*SubfieldDescsContext) IsSubfieldDescsContext() {}

func NewSubfieldDescsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubfieldDescsContext {
	var p = new(SubfieldDescsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_subfieldDescs

	return p
}

func (s *SubfieldDescsContext) GetParser() antlr.Parser { return s.parser }

func (s *SubfieldDescsContext) AllSubfieldDesc() []ISubfieldDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubfieldDescContext); ok {
			len++
		}
	}

	tst := make([]ISubfieldDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubfieldDescContext); ok {
			tst[i] = t.(ISubfieldDescContext)
			i++
		}
	}

	return tst
}

func (s *SubfieldDescsContext) SubfieldDesc(i int) ISubfieldDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubfieldDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubfieldDescContext)
}

func (s *SubfieldDescsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubfieldDescsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubfieldDescsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterSubfieldDescs(s)
	}
}

func (s *SubfieldDescsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitSubfieldDescs(s)
	}
}

func (s *SubfieldDescsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitSubfieldDescs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) SubfieldDescs() (localctx ISubfieldDescsContext) {
	localctx = NewSubfieldDescsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1002, DorisSQLParserRULE_subfieldDescs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8014)
		p.SubfieldDesc()
	}
	p.SetState(8019)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(8015)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8016)
			p.SubfieldDesc()
		}

		p.SetState(8021)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructTypeContext is an interface to support dynamic dispatch.
type IStructTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRUCT() antlr.TerminalNode
	LT() antlr.TerminalNode
	SubfieldDescs() ISubfieldDescsContext
	GT() antlr.TerminalNode

	// IsStructTypeContext differentiates from other interfaces.
	IsStructTypeContext()
}

type StructTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructTypeContext() *StructTypeContext {
	var p = new(StructTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_structType
	return p
}

func InitEmptyStructTypeContext(p *StructTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_structType
}

func (*StructTypeContext) IsStructTypeContext() {}

func NewStructTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructTypeContext {
	var p = new(StructTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_structType

	return p
}

func (s *StructTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StructTypeContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTRUCT, 0)
}

func (s *StructTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLT, 0)
}

func (s *StructTypeContext) SubfieldDescs() ISubfieldDescsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubfieldDescsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubfieldDescsContext)
}

func (s *StructTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGT, 0)
}

func (s *StructTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterStructType(s)
	}
}

func (s *StructTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitStructType(s)
	}
}

func (s *StructTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitStructType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) StructType() (localctx IStructTypeContext) {
	localctx = NewStructTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1004, DorisSQLParserRULE_structType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8022)
		p.Match(DorisSQLParserSTRUCT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8023)
		p.Match(DorisSQLParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8024)
		p.SubfieldDescs()
	}
	{
		p.SetState(8025)
		p.Match(DorisSQLParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER_VALUE() antlr.TerminalNode

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_typeParameter
	return p
}

func InitEmptyTypeParameterContext(p *TypeParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_typeParameter
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, 0)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (s *TypeParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTypeParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) TypeParameter() (localctx ITypeParameterContext) {
	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1006, DorisSQLParserRULE_typeParameter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8027)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8028)
		p.Match(DorisSQLParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8029)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBaseTypeContext is an interface to support dynamic dispatch.
type IBaseTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BOOLEAN() antlr.TerminalNode
	TINYINT() antlr.TerminalNode
	TypeParameter() ITypeParameterContext
	SMALLINT() antlr.TerminalNode
	SIGNED() antlr.TerminalNode
	INT() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	UNSIGNED() antlr.TerminalNode
	BIGINT() antlr.TerminalNode
	LARGEINT() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	TIME() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	VARCHAR() antlr.TerminalNode
	STRING() antlr.TerminalNode
	TEXT() antlr.TerminalNode
	BITMAP() antlr.TerminalNode
	HLL() antlr.TerminalNode
	PERCENTILE() antlr.TerminalNode
	JSON() antlr.TerminalNode
	VARBINARY() antlr.TerminalNode
	BINARY() antlr.TerminalNode

	// IsBaseTypeContext differentiates from other interfaces.
	IsBaseTypeContext()
}

type BaseTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseTypeContext() *BaseTypeContext {
	var p = new(BaseTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_baseType
	return p
}

func InitEmptyBaseTypeContext(p *BaseTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_baseType
}

func (*BaseTypeContext) IsBaseTypeContext() {}

func NewBaseTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseTypeContext {
	var p = new(BaseTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_baseType

	return p
}

func (s *BaseTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBOOLEAN, 0)
}

func (s *BaseTypeContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTINYINT, 0)
}

func (s *BaseTypeContext) TypeParameter() ITypeParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *BaseTypeContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSMALLINT, 0)
}

func (s *BaseTypeContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSIGNED, 0)
}

func (s *BaseTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINT, 0)
}

func (s *BaseTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER, 0)
}

func (s *BaseTypeContext) UNSIGNED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUNSIGNED, 0)
}

func (s *BaseTypeContext) BIGINT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBIGINT, 0)
}

func (s *BaseTypeContext) LARGEINT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLARGEINT, 0)
}

func (s *BaseTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFLOAT, 0)
}

func (s *BaseTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDOUBLE, 0)
}

func (s *BaseTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATE, 0)
}

func (s *BaseTypeContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATETIME, 0)
}

func (s *BaseTypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTIME, 0)
}

func (s *BaseTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCHAR, 0)
}

func (s *BaseTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVARCHAR, 0)
}

func (s *BaseTypeContext) STRING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTRING, 0)
}

func (s *BaseTypeContext) TEXT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTEXT, 0)
}

func (s *BaseTypeContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBITMAP, 0)
}

func (s *BaseTypeContext) HLL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserHLL, 0)
}

func (s *BaseTypeContext) PERCENTILE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPERCENTILE, 0)
}

func (s *BaseTypeContext) JSON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserJSON, 0)
}

func (s *BaseTypeContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVARBINARY, 0)
}

func (s *BaseTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBINARY, 0)
}

func (s *BaseTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterBaseType(s)
	}
}

func (s *BaseTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitBaseType(s)
	}
}

func (s *BaseTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitBaseType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) BaseType() (localctx IBaseTypeContext) {
	localctx = NewBaseTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1008, DorisSQLParserRULE_baseType)
	var _la int

	p.SetState(8099)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 959, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8031)
			p.Match(DorisSQLParserBOOLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8032)
			p.Match(DorisSQLParserTINYINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8034)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__1 {
			{
				p.SetState(8033)
				p.TypeParameter()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8036)
			p.Match(DorisSQLParserSMALLINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8038)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__1 {
			{
				p.SetState(8037)
				p.TypeParameter()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(8040)
			p.Match(DorisSQLParserSIGNED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8042)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserINT {
			{
				p.SetState(8041)
				p.Match(DorisSQLParserINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(8044)
			p.Match(DorisSQLParserSIGNED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8046)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserINTEGER {
			{
				p.SetState(8045)
				p.Match(DorisSQLParserINTEGER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(8048)
			p.Match(DorisSQLParserUNSIGNED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8050)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserINT {
			{
				p.SetState(8049)
				p.Match(DorisSQLParserINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(8052)
			p.Match(DorisSQLParserUNSIGNED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8054)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserINTEGER {
			{
				p.SetState(8053)
				p.Match(DorisSQLParserINTEGER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(8056)
			p.Match(DorisSQLParserINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8058)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__1 {
			{
				p.SetState(8057)
				p.TypeParameter()
			}

		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(8060)
			p.Match(DorisSQLParserINTEGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8062)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__1 {
			{
				p.SetState(8061)
				p.TypeParameter()
			}

		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(8064)
			p.Match(DorisSQLParserBIGINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8066)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__1 {
			{
				p.SetState(8065)
				p.TypeParameter()
			}

		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(8068)
			p.Match(DorisSQLParserLARGEINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8070)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__1 {
			{
				p.SetState(8069)
				p.TypeParameter()
			}

		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(8072)
			p.Match(DorisSQLParserFLOAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(8073)
			p.Match(DorisSQLParserDOUBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(8074)
			p.Match(DorisSQLParserDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(8075)
			p.Match(DorisSQLParserDATETIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(8076)
			p.Match(DorisSQLParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(8077)
			p.Match(DorisSQLParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8079)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__1 {
			{
				p.SetState(8078)
				p.TypeParameter()
			}

		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(8081)
			p.Match(DorisSQLParserVARCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8083)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__1 {
			{
				p.SetState(8082)
				p.TypeParameter()
			}

		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(8085)
			p.Match(DorisSQLParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(8086)
			p.Match(DorisSQLParserTEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(8087)
			p.Match(DorisSQLParserBITMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(8088)
			p.Match(DorisSQLParserHLL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(8089)
			p.Match(DorisSQLParserPERCENTILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(8090)
			p.Match(DorisSQLParserJSON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(8091)
			p.Match(DorisSQLParserVARBINARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8093)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__1 {
			{
				p.SetState(8092)
				p.TypeParameter()
			}

		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(8095)
			p.Match(DorisSQLParserBINARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8097)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__1 {
			{
				p.SetState(8096)
				p.TypeParameter()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecimalTypeContext is an interface to support dynamic dispatch.
type IDecimalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPrecision returns the precision token.
	GetPrecision() antlr.Token

	// GetScale returns the scale token.
	GetScale() antlr.Token

	// SetPrecision sets the precision token.
	SetPrecision(antlr.Token)

	// SetScale sets the scale token.
	SetScale(antlr.Token)

	// Getter signatures
	DECIMAL() antlr.TerminalNode
	DECIMALV2() antlr.TerminalNode
	DECIMAL32() antlr.TerminalNode
	DECIMAL64() antlr.TerminalNode
	DECIMAL128() antlr.TerminalNode
	NUMERIC() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsDecimalTypeContext differentiates from other interfaces.
	IsDecimalTypeContext()
}

type DecimalTypeContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	precision antlr.Token
	scale     antlr.Token
}

func NewEmptyDecimalTypeContext() *DecimalTypeContext {
	var p = new(DecimalTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_decimalType
	return p
}

func InitEmptyDecimalTypeContext(p *DecimalTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_decimalType
}

func (*DecimalTypeContext) IsDecimalTypeContext() {}

func NewDecimalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalTypeContext {
	var p = new(DecimalTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_decimalType

	return p
}

func (s *DecimalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalTypeContext) GetPrecision() antlr.Token { return s.precision }

func (s *DecimalTypeContext) GetScale() antlr.Token { return s.scale }

func (s *DecimalTypeContext) SetPrecision(v antlr.Token) { s.precision = v }

func (s *DecimalTypeContext) SetScale(v antlr.Token) { s.scale = v }

func (s *DecimalTypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDECIMAL, 0)
}

func (s *DecimalTypeContext) DECIMALV2() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDECIMALV2, 0)
}

func (s *DecimalTypeContext) DECIMAL32() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDECIMAL32, 0)
}

func (s *DecimalTypeContext) DECIMAL64() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDECIMAL64, 0)
}

func (s *DecimalTypeContext) DECIMAL128() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDECIMAL128, 0)
}

func (s *DecimalTypeContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNUMERIC, 0)
}

func (s *DecimalTypeContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNUMBER, 0)
}

func (s *DecimalTypeContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserINTEGER_VALUE)
}

func (s *DecimalTypeContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, i)
}

func (s *DecimalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDecimalType(s)
	}
}

func (s *DecimalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDecimalType(s)
	}
}

func (s *DecimalTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDecimalType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) DecimalType() (localctx IDecimalTypeContext) {
	localctx = NewDecimalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1010, DorisSQLParserRULE_decimalType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8101)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-111)) & ^0x3f) == 0 && ((int64(1)<<(_la-111))&31) != 0) || _la == DorisSQLParserNUMBER || _la == DorisSQLParserNUMERIC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(8109)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserT__1 {
		{
			p.SetState(8102)
			p.Match(DorisSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8103)

			var _m = p.Match(DorisSQLParserINTEGER_VALUE)

			localctx.(*DecimalTypeContext).precision = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8106)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserT__2 {
			{
				p.SetState(8104)
				p.Match(DorisSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8105)

				var _m = p.Match(DorisSQLParserINTEGER_VALUE)

				localctx.(*DecimalTypeContext).scale = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(8108)
			p.Match(DorisSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDOT_IDENTIFIER() []antlr.TerminalNode
	DOT_IDENTIFIER(i int) antlr.TerminalNode

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_qualifiedName
	return p
}

func InitEmptyQualifiedNameContext(p *QualifiedNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_qualifiedName
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedNameContext) AllDOT_IDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserDOT_IDENTIFIER)
}

func (s *QualifiedNameContext) DOT_IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDOT_IDENTIFIER, i)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterQualifiedName(s)
	}
}

func (s *QualifiedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitQualifiedName(s)
	}
}

func (s *QualifiedNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitQualifiedName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) QualifiedName() (localctx IQualifiedNameContext) {
	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1012, DorisSQLParserRULE_qualifiedName)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8111)
		p.Identifier()
	}
	p.SetState(8117)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 963, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(8115)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisSQLParserDOT_IDENTIFIER:
				{
					p.SetState(8112)
					p.Match(DorisSQLParserDOT_IDENTIFIER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case DorisSQLParserT__0:
				{
					p.SetState(8113)
					p.Match(DorisSQLParserT__0)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(8114)
					p.Identifier()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(8119)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 963, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableNameContext is an interface to support dynamic dispatch.
type ITableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext

	// IsTableNameContext differentiates from other interfaces.
	IsTableNameContext()
}

type TableNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableNameContext() *TableNameContext {
	var p = new(TableNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_tableName
	return p
}

func InitEmptyTableNameContext(p *TableNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_tableName
}

func (*TableNameContext) IsTableNameContext() {}

func NewTableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableNameContext {
	var p = new(TableNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_tableName

	return p
}

func (s *TableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TableNameContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (s *TableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitTableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) TableName() (localctx ITableNameContext) {
	localctx = NewTableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1014, DorisSQLParserRULE_tableName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8120)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWriteBranchContext is an interface to support dynamic dispatch.
type IWriteBranchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VERSION() antlr.TerminalNode
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode
	Identifier() IIdentifierContext
	FOR() antlr.TerminalNode

	// IsWriteBranchContext differentiates from other interfaces.
	IsWriteBranchContext()
}

type WriteBranchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteBranchContext() *WriteBranchContext {
	var p = new(WriteBranchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_writeBranch
	return p
}

func InitEmptyWriteBranchContext(p *WriteBranchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_writeBranch
}

func (*WriteBranchContext) IsWriteBranchContext() {}

func NewWriteBranchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteBranchContext {
	var p = new(WriteBranchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_writeBranch

	return p
}

func (s *WriteBranchContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteBranchContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVERSION, 0)
}

func (s *WriteBranchContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *WriteBranchContext) OF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOF, 0)
}

func (s *WriteBranchContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WriteBranchContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFOR, 0)
}

func (s *WriteBranchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteBranchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteBranchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterWriteBranch(s)
	}
}

func (s *WriteBranchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitWriteBranch(s)
	}
}

func (s *WriteBranchContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitWriteBranch(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) WriteBranch() (localctx IWriteBranchContext) {
	localctx = NewWriteBranchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1016, DorisSQLParserRULE_writeBranch)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(8123)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserFOR {
		{
			p.SetState(8122)
			p.Match(DorisSQLParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(8125)
		p.Match(DorisSQLParserVERSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8126)
		p.Match(DorisSQLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8127)
		p.Match(DorisSQLParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8128)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) CopyAll(ctx *IdentifierContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BackQuotedIdentifierContext struct {
	IdentifierContext
}

func NewBackQuotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BackQuotedIdentifierContext {
	var p = new(BackQuotedIdentifierContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *BackQuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackQuotedIdentifierContext) BACKQUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBACKQUOTED_IDENTIFIER, 0)
}

func (s *BackQuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterBackQuotedIdentifier(s)
	}
}

func (s *BackQuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitBackQuotedIdentifier(s)
	}
}

func (s *BackQuotedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitBackQuotedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type DigitIdentifierContext struct {
	IdentifierContext
}

func NewDigitIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DigitIdentifierContext {
	var p = new(DigitIdentifierContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *DigitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitIdentifierContext) DIGIT_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDIGIT_IDENTIFIER, 0)
}

func (s *DigitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDigitIdentifier(s)
	}
}

func (s *DigitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDigitIdentifier(s)
	}
}

func (s *DigitIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDigitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnquotedIdentifierContext struct {
	IdentifierContext
}

func NewUnquotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnquotedIdentifierContext {
	var p = new(UnquotedIdentifierContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *UnquotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnquotedIdentifierContext) LETTER_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLETTER_IDENTIFIER, 0)
}

func (s *UnquotedIdentifierContext) NonReserved() INonReservedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonReservedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonReservedContext)
}

func (s *UnquotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitUnquotedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1018, DorisSQLParserRULE_identifier)
	p.SetState(8134)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserLETTER_IDENTIFIER:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8130)
			p.Match(DorisSQLParserLETTER_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserACCESS, DorisSQLParserACTIVE, DorisSQLParserADMIN, DorisSQLParserADVISOR, DorisSQLParserAFTER, DorisSQLParserAGGREGATE, DorisSQLParserANTI, DorisSQLParserAPPLY, DorisSQLParserARRAY_AGG, DorisSQLParserARRAY_AGG_DISTINCT, DorisSQLParserASYNC, DorisSQLParserAUTHORS, DorisSQLParserAUTHENTICATION, DorisSQLParserAUTOMATED, DorisSQLParserAUTO_INCREMENT, DorisSQLParserAVG, DorisSQLParserBACKEND, DorisSQLParserBACKENDS, DorisSQLParserBACKUP, DorisSQLParserBASE, DorisSQLParserBASELINE, DorisSQLParserBEGIN, DorisSQLParserBINARY, DorisSQLParserBITMAP_UNION, DorisSQLParserBLACKHOLE, DorisSQLParserBLACKLIST, DorisSQLParserBODY, DorisSQLParserBOOLEAN, DorisSQLParserBRANCH, DorisSQLParserBROKER, DorisSQLParserBUCKETS, DorisSQLParserBUILTIN, DorisSQLParserCACHE, DorisSQLParserCANCEL, DorisSQLParserCAST, DorisSQLParserCATALOG, DorisSQLParserCATALOGS, DorisSQLParserCEIL, DorisSQLParserCHAIN, DorisSQLParserCHARSET, DorisSQLParserCLEAN, DorisSQLParserCLEAR, DorisSQLParserCLUSTER, DorisSQLParserCLUSTERS, DorisSQLParserCNGROUP, DorisSQLParserCNGROUPS, DorisSQLParserCOLLATION, DorisSQLParserCOLUMNS, DorisSQLParserCOMMENT, DorisSQLParserCOMMIT, DorisSQLParserCOMMITTED, DorisSQLParserCOMPACT, DorisSQLParserCOMPUTE, DorisSQLParserCONFIG, DorisSQLParserCONNECTION, DorisSQLParserCONSISTENT, DorisSQLParserCOSTS, DorisSQLParserCOUNT, DorisSQLParserCUME_DIST, DorisSQLParserCUMULATIVE, DorisSQLParserCURRENT, DorisSQLParserDATA, DorisSQLParserDATACACHE, DorisSQLParserDATE, DorisSQLParserDATETIME, DorisSQLParserDAY, DorisSQLParserDAYS, DorisSQLParserDEALLOCATE, DorisSQLParserDECOMMISSION, DorisSQLParserDIALECT, DorisSQLParserDICTIONARY, DorisSQLParserDICTIONARY_GET, DorisSQLParserDISABLE, DorisSQLParserDISTRIBUTED, DorisSQLParserDISTRIBUTION, DorisSQLParserDUPLICATE, DorisSQLParserDYNAMIC, DorisSQLParserENABLE, DorisSQLParserENCLOSE, DorisSQLParserEND, DorisSQLParserENGINE, DorisSQLParserENGINES, DorisSQLParserERRORS, DorisSQLParserESCAPE, DorisSQLParserEVENTS, DorisSQLParserEXCEPT, DorisSQLParserEXCLUDE, DorisSQLParserEXECUTE, DorisSQLParserEXPORT, DorisSQLParserEXTERNAL, DorisSQLParserEXTRACT, DorisSQLParserEVERY, DorisSQLParserFAILPOINT, DorisSQLParserFAILPOINTS, DorisSQLParserFIELDS, DorisSQLParserFILE, DorisSQLParserFILTER, DorisSQLParserFIRST, DorisSQLParserFLOOR, DorisSQLParserFN, DorisSQLParserFOLLOWING, DorisSQLParserFOLLOWER, DorisSQLParserFORMAT, DorisSQLParserFREE, DorisSQLParserFRONTEND, DorisSQLParserFRONTENDS, DorisSQLParserFUNCTIONS, DorisSQLParserGLOBAL, DorisSQLParserGRANTS, DorisSQLParserGROUP_CONCAT, DorisSQLParserHASH, DorisSQLParserHELP, DorisSQLParserHISTOGRAM, DorisSQLParserHLL_UNION, DorisSQLParserHOST, DorisSQLParserHOUR, DorisSQLParserHOURS, DorisSQLParserHUB, DorisSQLParserIDENTIFIED, DorisSQLParserIMPERSONATE, DorisSQLParserIMAGE, DorisSQLParserINACTIVE, DorisSQLParserINCREMENTAL, DorisSQLParserINDEXES, DorisSQLParserINSTALL, DorisSQLParserINTEGRATION, DorisSQLParserINTEGRATIONS, DorisSQLParserINTERMEDIATE, DorisSQLParserINTERVAL, DorisSQLParserOVERWRITE, DorisSQLParserISOLATION, DorisSQLParserJOB, DorisSQLParserLABEL, DorisSQLParserLAST, DorisSQLParserLESS, DorisSQLParserLEVEL, DorisSQLParserLIST, DorisSQLParserLOCAL, DorisSQLParserLOCATION, DorisSQLParserLOCATIONS, DorisSQLParserLOGS, DorisSQLParserLOGICAL, DorisSQLParserMANUAL, DorisSQLParserMAP, DorisSQLParserMAPPING, DorisSQLParserMAPPINGS, DorisSQLParserMASKING, DorisSQLParserMATCH, DorisSQLParserMATERIALIZED, DorisSQLParserMAX, DorisSQLParserMERGE, DorisSQLParserMIN, DorisSQLParserMINUTE, DorisSQLParserMINUTES, DorisSQLParserMINUS, DorisSQLParserMETA, DorisSQLParserMODE, DorisSQLParserMODIFY, DorisSQLParserMONTH, DorisSQLParserMULTIPLE, DorisSQLParserNAME, DorisSQLParserNAMES, DorisSQLParserNEGATIVE, DorisSQLParserNGRAMBF, DorisSQLParserNO, DorisSQLParserNODE, DorisSQLParserNODES, DorisSQLParserNONE, DorisSQLParserNULLS, DorisSQLParserNUMBER, DorisSQLParserNUMERIC, DorisSQLParserOBSERVER, DorisSQLParserOF, DorisSQLParserOFF, DorisSQLParserOFFSET, DorisSQLParserONLY, DorisSQLParserOPEN, DorisSQLParserOPERATE, DorisSQLParserOPTIMIZER, DorisSQLParserOPTION, DorisSQLParserPARTITIONS, DorisSQLParserPASSWORD, DorisSQLParserPATH, DorisSQLParserPAUSE, DorisSQLParserPENDING, DorisSQLParserPERCENT_RANK, DorisSQLParserPERCENTILE_UNION, DorisSQLParserPLAN, DorisSQLParserPLUGIN, DorisSQLParserPLUGINS, DorisSQLParserPIPE, DorisSQLParserPIPES, DorisSQLParserPIVOT, DorisSQLParserPOLICY, DorisSQLParserPOLICIES, DorisSQLParserPRECEDING, DorisSQLParserPREDICATE, DorisSQLParserPRIORITY, DorisSQLParserPRIVILEGES, DorisSQLParserPROBABILITY, DorisSQLParserPROC, DorisSQLParserPROCESSLIST, DorisSQLParserPROFILE, DorisSQLParserPROFILELIST, DorisSQLParserPROPERTIES, DorisSQLParserPROPERTY, DorisSQLParserPROVIDER, DorisSQLParserPROVIDERS, DorisSQLParserQUALIFY, DorisSQLParserQUARTER, DorisSQLParserQUERY, DorisSQLParserQUERIES, DorisSQLParserQUEUE, DorisSQLParserQUOTA, DorisSQLParserRANDOM, DorisSQLParserRANK, DorisSQLParserREASON, DorisSQLParserRECOVER, DorisSQLParserREFRESH, DorisSQLParserREWRITE, DorisSQLParserREMOVE, DorisSQLParserREPAIR, DorisSQLParserREPEATABLE, DorisSQLParserREPLACE_IF_NOT_NULL, DorisSQLParserREPLICA, DorisSQLParserREPOSITORY, DorisSQLParserREPOSITORIES, DorisSQLParserRESOURCE, DorisSQLParserRESOURCES, DorisSQLParserRESTORE, DorisSQLParserRESUME, DorisSQLParserRETAIN, DorisSQLParserRETENTION, DorisSQLParserRETURNS, DorisSQLParserRETRY, DorisSQLParserREVERT, DorisSQLParserROLE, DorisSQLParserROLES, DorisSQLParserROLLBACK, DorisSQLParserROLLUP, DorisSQLParserROUTINE, DorisSQLParserROW, DorisSQLParserRULE, DorisSQLParserRULES, DorisSQLParserRUNNING, DorisSQLParserSAMPLE, DorisSQLParserSCHEDULE, DorisSQLParserSCHEDULER, DorisSQLParserSECOND, DorisSQLParserSECURITY, DorisSQLParserSEMI, DorisSQLParserSEPARATOR, DorisSQLParserSERIALIZABLE, DorisSQLParserSESSION, DorisSQLParserSETS, DorisSQLParserSIGNED, DorisSQLParserSKIP_HEADER, DorisSQLParserSNAPSHOT, DorisSQLParserSNAPSHOTS, DorisSQLParserSQLBLACKLIST, DorisSQLParserSTART, DorisSQLParserSTATS, DorisSQLParserSTATUS, DorisSQLParserSTOP, DorisSQLParserSTORAGE, DorisSQLParserSTREAM, DorisSQLParserSTRING, DorisSQLParserSUBMIT, DorisSQLParserSUM, DorisSQLParserSUSPEND, DorisSQLParserSYNC, DorisSQLParserSYSTEM_TIME, DorisSQLParserSWAP, DorisSQLParserSTRUCT, DorisSQLParserTABLES, DorisSQLParserTABLET, DorisSQLParserTABLETS, DorisSQLParserTAG, DorisSQLParserTASK, DorisSQLParserTEMPORARY, DorisSQLParserTHAN, DorisSQLParserTIME, DorisSQLParserTIMES, DorisSQLParserTIMESTAMP, DorisSQLParserTIMESTAMPADD, DorisSQLParserTIMESTAMPDIFF, DorisSQLParserTRANSACTION, DorisSQLParserTRANSLATE, DorisSQLParserTRACE, DorisSQLParserTRIGGERS, DorisSQLParserTRIM_SPACE, DorisSQLParserTRUNCATE, DorisSQLParserTYPE, DorisSQLParserTYPES, DorisSQLParserUNBOUNDED, DorisSQLParserUNCOMMITTED, DorisSQLParserUNINSTALL, DorisSQLParserUNSET, DorisSQLParserUSAGE, DorisSQLParserUSER, DorisSQLParserUSERS, DorisSQLParserVALUE, DorisSQLParserVARBINARY, DorisSQLParserVARIABLES, DorisSQLParserVECTOR, DorisSQLParserVERBOSE, DorisSQLParserVERSION, DorisSQLParserVIEW, DorisSQLParserVIEWS, DorisSQLParserVOLUME, DorisSQLParserVOLUMES, DorisSQLParserWAREHOUSE, DorisSQLParserWAREHOUSES, DorisSQLParserWARNINGS, DorisSQLParserWEEK, DorisSQLParserWHITELIST, DorisSQLParserWORK, DorisSQLParserWRITE, DorisSQLParserYEAR, DorisSQLParserLOCK, DorisSQLParserUNLOCK, DorisSQLParserLOW_PRIORITY, DorisSQLParserDISK, DorisSQLParserBEFORE, DorisSQLParserFIELD, DorisSQLParserPERSISTENT, DorisSQLParserARRAY_ELEMENT, DorisSQLParserDOTDOTDOT:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8131)
			p.NonReserved()
		}

	case DorisSQLParserDIGIT_IDENTIFIER:
		localctx = NewDigitIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8132)
			p.Match(DorisSQLParserDIGIT_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserBACKQUOTED_IDENTIFIER:
		localctx = NewBackQuotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(8133)
			p.Match(DorisSQLParserBACKQUOTED_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierWithAliasContext is an interface to support dynamic dispatch.
type IIdentifierWithAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOriginalName returns the originalName rule contexts.
	GetOriginalName() IIdentifierContext

	// GetAlias returns the alias rule contexts.
	GetAlias() IIdentifierContext

	// SetOriginalName sets the originalName rule contexts.
	SetOriginalName(IIdentifierContext)

	// SetAlias sets the alias rule contexts.
	SetAlias(IIdentifierContext)

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AS() antlr.TerminalNode

	// IsIdentifierWithAliasContext differentiates from other interfaces.
	IsIdentifierWithAliasContext()
}

type IdentifierWithAliasContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	originalName IIdentifierContext
	alias        IIdentifierContext
}

func NewEmptyIdentifierWithAliasContext() *IdentifierWithAliasContext {
	var p = new(IdentifierWithAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_identifierWithAlias
	return p
}

func InitEmptyIdentifierWithAliasContext(p *IdentifierWithAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_identifierWithAlias
}

func (*IdentifierWithAliasContext) IsIdentifierWithAliasContext() {}

func NewIdentifierWithAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierWithAliasContext {
	var p = new(IdentifierWithAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_identifierWithAlias

	return p
}

func (s *IdentifierWithAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierWithAliasContext) GetOriginalName() IIdentifierContext { return s.originalName }

func (s *IdentifierWithAliasContext) GetAlias() IIdentifierContext { return s.alias }

func (s *IdentifierWithAliasContext) SetOriginalName(v IIdentifierContext) { s.originalName = v }

func (s *IdentifierWithAliasContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *IdentifierWithAliasContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierWithAliasContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierWithAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAS, 0)
}

func (s *IdentifierWithAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierWithAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierWithAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterIdentifierWithAlias(s)
	}
}

func (s *IdentifierWithAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitIdentifierWithAlias(s)
	}
}

func (s *IdentifierWithAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitIdentifierWithAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) IdentifierWithAlias() (localctx IIdentifierWithAliasContext) {
	localctx = NewIdentifierWithAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1020, DorisSQLParserRULE_identifierWithAlias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8136)

		var _x = p.Identifier()

		localctx.(*IdentifierWithAliasContext).originalName = _x
	}
	p.SetState(8139)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserAS {
		{
			p.SetState(8137)
			p.Match(DorisSQLParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8138)

			var _x = p.Identifier()

			localctx.(*IdentifierWithAliasContext).alias = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierWithAliasListContext is an interface to support dynamic dispatch.
type IIdentifierWithAliasListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierWithAlias() []IIdentifierWithAliasContext
	IdentifierWithAlias(i int) IIdentifierWithAliasContext

	// IsIdentifierWithAliasListContext differentiates from other interfaces.
	IsIdentifierWithAliasListContext()
}

type IdentifierWithAliasListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierWithAliasListContext() *IdentifierWithAliasListContext {
	var p = new(IdentifierWithAliasListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_identifierWithAliasList
	return p
}

func InitEmptyIdentifierWithAliasListContext(p *IdentifierWithAliasListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_identifierWithAliasList
}

func (*IdentifierWithAliasListContext) IsIdentifierWithAliasListContext() {}

func NewIdentifierWithAliasListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierWithAliasListContext {
	var p = new(IdentifierWithAliasListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_identifierWithAliasList

	return p
}

func (s *IdentifierWithAliasListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierWithAliasListContext) AllIdentifierWithAlias() []IIdentifierWithAliasContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierWithAliasContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierWithAliasContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierWithAliasContext); ok {
			tst[i] = t.(IIdentifierWithAliasContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierWithAliasListContext) IdentifierWithAlias(i int) IIdentifierWithAliasContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierWithAliasContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierWithAliasContext)
}

func (s *IdentifierWithAliasListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierWithAliasListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierWithAliasListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterIdentifierWithAliasList(s)
	}
}

func (s *IdentifierWithAliasListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitIdentifierWithAliasList(s)
	}
}

func (s *IdentifierWithAliasListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitIdentifierWithAliasList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) IdentifierWithAliasList() (localctx IIdentifierWithAliasListContext) {
	localctx = NewIdentifierWithAliasListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1022, DorisSQLParserRULE_identifierWithAliasList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8141)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8142)
		p.IdentifierWithAlias()
	}
	p.SetState(8147)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(8143)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8144)
			p.IdentifierWithAlias()
		}

		p.SetState(8149)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(8150)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_identifierList
	return p
}

func InitEmptyIdentifierListContext(p *IdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_identifierList
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierListContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (s *IdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1024, DorisSQLParserRULE_identifierList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8152)
		p.Match(DorisSQLParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8153)
		p.Identifier()
	}
	p.SetState(8158)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(8154)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8155)
			p.Identifier()
		}

		p.SetState(8160)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(8161)
		p.Match(DorisSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrStringContext is an interface to support dynamic dispatch.
type IIdentifierOrStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	String_() IStringContext

	// IsIdentifierOrStringContext differentiates from other interfaces.
	IsIdentifierOrStringContext()
}

type IdentifierOrStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrStringContext() *IdentifierOrStringContext {
	var p = new(IdentifierOrStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_identifierOrString
	return p
}

func InitEmptyIdentifierOrStringContext(p *IdentifierOrStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_identifierOrString
}

func (*IdentifierOrStringContext) IsIdentifierOrStringContext() {}

func NewIdentifierOrStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrStringContext {
	var p = new(IdentifierOrStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_identifierOrString

	return p
}

func (s *IdentifierOrStringContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrStringContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierOrStringContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *IdentifierOrStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterIdentifierOrString(s)
	}
}

func (s *IdentifierOrStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitIdentifierOrString(s)
	}
}

func (s *IdentifierOrStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitIdentifierOrString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) IdentifierOrString() (localctx IIdentifierOrStringContext) {
	localctx = NewIdentifierOrStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1026, DorisSQLParserRULE_identifierOrString)
	p.SetState(8165)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserACCESS, DorisSQLParserACTIVE, DorisSQLParserADMIN, DorisSQLParserADVISOR, DorisSQLParserAFTER, DorisSQLParserAGGREGATE, DorisSQLParserANTI, DorisSQLParserAPPLY, DorisSQLParserARRAY_AGG, DorisSQLParserARRAY_AGG_DISTINCT, DorisSQLParserASYNC, DorisSQLParserAUTHORS, DorisSQLParserAUTHENTICATION, DorisSQLParserAUTOMATED, DorisSQLParserAUTO_INCREMENT, DorisSQLParserAVG, DorisSQLParserBACKEND, DorisSQLParserBACKENDS, DorisSQLParserBACKUP, DorisSQLParserBASE, DorisSQLParserBASELINE, DorisSQLParserBEGIN, DorisSQLParserBINARY, DorisSQLParserBITMAP_UNION, DorisSQLParserBLACKHOLE, DorisSQLParserBLACKLIST, DorisSQLParserBODY, DorisSQLParserBOOLEAN, DorisSQLParserBRANCH, DorisSQLParserBROKER, DorisSQLParserBUCKETS, DorisSQLParserBUILTIN, DorisSQLParserCACHE, DorisSQLParserCANCEL, DorisSQLParserCAST, DorisSQLParserCATALOG, DorisSQLParserCATALOGS, DorisSQLParserCEIL, DorisSQLParserCHAIN, DorisSQLParserCHARSET, DorisSQLParserCLEAN, DorisSQLParserCLEAR, DorisSQLParserCLUSTER, DorisSQLParserCLUSTERS, DorisSQLParserCNGROUP, DorisSQLParserCNGROUPS, DorisSQLParserCOLLATION, DorisSQLParserCOLUMNS, DorisSQLParserCOMMENT, DorisSQLParserCOMMIT, DorisSQLParserCOMMITTED, DorisSQLParserCOMPACT, DorisSQLParserCOMPUTE, DorisSQLParserCONFIG, DorisSQLParserCONNECTION, DorisSQLParserCONSISTENT, DorisSQLParserCOSTS, DorisSQLParserCOUNT, DorisSQLParserCUME_DIST, DorisSQLParserCUMULATIVE, DorisSQLParserCURRENT, DorisSQLParserDATA, DorisSQLParserDATACACHE, DorisSQLParserDATE, DorisSQLParserDATETIME, DorisSQLParserDAY, DorisSQLParserDAYS, DorisSQLParserDEALLOCATE, DorisSQLParserDECOMMISSION, DorisSQLParserDIALECT, DorisSQLParserDICTIONARY, DorisSQLParserDICTIONARY_GET, DorisSQLParserDISABLE, DorisSQLParserDISTRIBUTED, DorisSQLParserDISTRIBUTION, DorisSQLParserDUPLICATE, DorisSQLParserDYNAMIC, DorisSQLParserENABLE, DorisSQLParserENCLOSE, DorisSQLParserEND, DorisSQLParserENGINE, DorisSQLParserENGINES, DorisSQLParserERRORS, DorisSQLParserESCAPE, DorisSQLParserEVENTS, DorisSQLParserEXCEPT, DorisSQLParserEXCLUDE, DorisSQLParserEXECUTE, DorisSQLParserEXPORT, DorisSQLParserEXTERNAL, DorisSQLParserEXTRACT, DorisSQLParserEVERY, DorisSQLParserFAILPOINT, DorisSQLParserFAILPOINTS, DorisSQLParserFIELDS, DorisSQLParserFILE, DorisSQLParserFILTER, DorisSQLParserFIRST, DorisSQLParserFLOOR, DorisSQLParserFN, DorisSQLParserFOLLOWING, DorisSQLParserFOLLOWER, DorisSQLParserFORMAT, DorisSQLParserFREE, DorisSQLParserFRONTEND, DorisSQLParserFRONTENDS, DorisSQLParserFUNCTIONS, DorisSQLParserGLOBAL, DorisSQLParserGRANTS, DorisSQLParserGROUP_CONCAT, DorisSQLParserHASH, DorisSQLParserHELP, DorisSQLParserHISTOGRAM, DorisSQLParserHLL_UNION, DorisSQLParserHOST, DorisSQLParserHOUR, DorisSQLParserHOURS, DorisSQLParserHUB, DorisSQLParserIDENTIFIED, DorisSQLParserIMPERSONATE, DorisSQLParserIMAGE, DorisSQLParserINACTIVE, DorisSQLParserINCREMENTAL, DorisSQLParserINDEXES, DorisSQLParserINSTALL, DorisSQLParserINTEGRATION, DorisSQLParserINTEGRATIONS, DorisSQLParserINTERMEDIATE, DorisSQLParserINTERVAL, DorisSQLParserOVERWRITE, DorisSQLParserISOLATION, DorisSQLParserJOB, DorisSQLParserLABEL, DorisSQLParserLAST, DorisSQLParserLESS, DorisSQLParserLEVEL, DorisSQLParserLIST, DorisSQLParserLOCAL, DorisSQLParserLOCATION, DorisSQLParserLOCATIONS, DorisSQLParserLOGS, DorisSQLParserLOGICAL, DorisSQLParserMANUAL, DorisSQLParserMAP, DorisSQLParserMAPPING, DorisSQLParserMAPPINGS, DorisSQLParserMASKING, DorisSQLParserMATCH, DorisSQLParserMATERIALIZED, DorisSQLParserMAX, DorisSQLParserMERGE, DorisSQLParserMIN, DorisSQLParserMINUTE, DorisSQLParserMINUTES, DorisSQLParserMINUS, DorisSQLParserMETA, DorisSQLParserMODE, DorisSQLParserMODIFY, DorisSQLParserMONTH, DorisSQLParserMULTIPLE, DorisSQLParserNAME, DorisSQLParserNAMES, DorisSQLParserNEGATIVE, DorisSQLParserNGRAMBF, DorisSQLParserNO, DorisSQLParserNODE, DorisSQLParserNODES, DorisSQLParserNONE, DorisSQLParserNULLS, DorisSQLParserNUMBER, DorisSQLParserNUMERIC, DorisSQLParserOBSERVER, DorisSQLParserOF, DorisSQLParserOFF, DorisSQLParserOFFSET, DorisSQLParserONLY, DorisSQLParserOPEN, DorisSQLParserOPERATE, DorisSQLParserOPTIMIZER, DorisSQLParserOPTION, DorisSQLParserPARTITIONS, DorisSQLParserPASSWORD, DorisSQLParserPATH, DorisSQLParserPAUSE, DorisSQLParserPENDING, DorisSQLParserPERCENT_RANK, DorisSQLParserPERCENTILE_UNION, DorisSQLParserPLAN, DorisSQLParserPLUGIN, DorisSQLParserPLUGINS, DorisSQLParserPIPE, DorisSQLParserPIPES, DorisSQLParserPIVOT, DorisSQLParserPOLICY, DorisSQLParserPOLICIES, DorisSQLParserPRECEDING, DorisSQLParserPREDICATE, DorisSQLParserPRIORITY, DorisSQLParserPRIVILEGES, DorisSQLParserPROBABILITY, DorisSQLParserPROC, DorisSQLParserPROCESSLIST, DorisSQLParserPROFILE, DorisSQLParserPROFILELIST, DorisSQLParserPROPERTIES, DorisSQLParserPROPERTY, DorisSQLParserPROVIDER, DorisSQLParserPROVIDERS, DorisSQLParserQUALIFY, DorisSQLParserQUARTER, DorisSQLParserQUERY, DorisSQLParserQUERIES, DorisSQLParserQUEUE, DorisSQLParserQUOTA, DorisSQLParserRANDOM, DorisSQLParserRANK, DorisSQLParserREASON, DorisSQLParserRECOVER, DorisSQLParserREFRESH, DorisSQLParserREWRITE, DorisSQLParserREMOVE, DorisSQLParserREPAIR, DorisSQLParserREPEATABLE, DorisSQLParserREPLACE_IF_NOT_NULL, DorisSQLParserREPLICA, DorisSQLParserREPOSITORY, DorisSQLParserREPOSITORIES, DorisSQLParserRESOURCE, DorisSQLParserRESOURCES, DorisSQLParserRESTORE, DorisSQLParserRESUME, DorisSQLParserRETAIN, DorisSQLParserRETENTION, DorisSQLParserRETURNS, DorisSQLParserRETRY, DorisSQLParserREVERT, DorisSQLParserROLE, DorisSQLParserROLES, DorisSQLParserROLLBACK, DorisSQLParserROLLUP, DorisSQLParserROUTINE, DorisSQLParserROW, DorisSQLParserRULE, DorisSQLParserRULES, DorisSQLParserRUNNING, DorisSQLParserSAMPLE, DorisSQLParserSCHEDULE, DorisSQLParserSCHEDULER, DorisSQLParserSECOND, DorisSQLParserSECURITY, DorisSQLParserSEMI, DorisSQLParserSEPARATOR, DorisSQLParserSERIALIZABLE, DorisSQLParserSESSION, DorisSQLParserSETS, DorisSQLParserSIGNED, DorisSQLParserSKIP_HEADER, DorisSQLParserSNAPSHOT, DorisSQLParserSNAPSHOTS, DorisSQLParserSQLBLACKLIST, DorisSQLParserSTART, DorisSQLParserSTATS, DorisSQLParserSTATUS, DorisSQLParserSTOP, DorisSQLParserSTORAGE, DorisSQLParserSTREAM, DorisSQLParserSTRING, DorisSQLParserSUBMIT, DorisSQLParserSUM, DorisSQLParserSUSPEND, DorisSQLParserSYNC, DorisSQLParserSYSTEM_TIME, DorisSQLParserSWAP, DorisSQLParserSTRUCT, DorisSQLParserTABLES, DorisSQLParserTABLET, DorisSQLParserTABLETS, DorisSQLParserTAG, DorisSQLParserTASK, DorisSQLParserTEMPORARY, DorisSQLParserTHAN, DorisSQLParserTIME, DorisSQLParserTIMES, DorisSQLParserTIMESTAMP, DorisSQLParserTIMESTAMPADD, DorisSQLParserTIMESTAMPDIFF, DorisSQLParserTRANSACTION, DorisSQLParserTRANSLATE, DorisSQLParserTRACE, DorisSQLParserTRIGGERS, DorisSQLParserTRIM_SPACE, DorisSQLParserTRUNCATE, DorisSQLParserTYPE, DorisSQLParserTYPES, DorisSQLParserUNBOUNDED, DorisSQLParserUNCOMMITTED, DorisSQLParserUNINSTALL, DorisSQLParserUNSET, DorisSQLParserUSAGE, DorisSQLParserUSER, DorisSQLParserUSERS, DorisSQLParserVALUE, DorisSQLParserVARBINARY, DorisSQLParserVARIABLES, DorisSQLParserVECTOR, DorisSQLParserVERBOSE, DorisSQLParserVERSION, DorisSQLParserVIEW, DorisSQLParserVIEWS, DorisSQLParserVOLUME, DorisSQLParserVOLUMES, DorisSQLParserWAREHOUSE, DorisSQLParserWAREHOUSES, DorisSQLParserWARNINGS, DorisSQLParserWEEK, DorisSQLParserWHITELIST, DorisSQLParserWORK, DorisSQLParserWRITE, DorisSQLParserYEAR, DorisSQLParserLOCK, DorisSQLParserUNLOCK, DorisSQLParserLOW_PRIORITY, DorisSQLParserDISK, DorisSQLParserBEFORE, DorisSQLParserFIELD, DorisSQLParserPERSISTENT, DorisSQLParserARRAY_ELEMENT, DorisSQLParserLETTER_IDENTIFIER, DorisSQLParserDIGIT_IDENTIFIER, DorisSQLParserBACKQUOTED_IDENTIFIER, DorisSQLParserDOTDOTDOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8163)
			p.Identifier()
		}

	case DorisSQLParserSINGLE_QUOTED_TEXT, DorisSQLParserDOUBLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8164)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrStringListContext is an interface to support dynamic dispatch.
type IIdentifierOrStringListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext

	// IsIdentifierOrStringListContext differentiates from other interfaces.
	IsIdentifierOrStringListContext()
}

type IdentifierOrStringListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrStringListContext() *IdentifierOrStringListContext {
	var p = new(IdentifierOrStringListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_identifierOrStringList
	return p
}

func InitEmptyIdentifierOrStringListContext(p *IdentifierOrStringListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_identifierOrStringList
}

func (*IdentifierOrStringListContext) IsIdentifierOrStringListContext() {}

func NewIdentifierOrStringListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrStringListContext {
	var p = new(IdentifierOrStringListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_identifierOrStringList

	return p
}

func (s *IdentifierOrStringListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrStringListContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierOrStringListContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *IdentifierOrStringListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrStringListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrStringListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterIdentifierOrStringList(s)
	}
}

func (s *IdentifierOrStringListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitIdentifierOrStringList(s)
	}
}

func (s *IdentifierOrStringListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitIdentifierOrStringList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) IdentifierOrStringList() (localctx IIdentifierOrStringListContext) {
	localctx = NewIdentifierOrStringListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1028, DorisSQLParserRULE_identifierOrStringList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8167)
		p.IdentifierOrString()
	}
	p.SetState(8172)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(8168)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8169)
			p.IdentifierOrString()
		}

		p.SetState(8174)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrStringOrStarContext is an interface to support dynamic dispatch.
type IIdentifierOrStringOrStarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASTERISK_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	String_() IStringContext

	// IsIdentifierOrStringOrStarContext differentiates from other interfaces.
	IsIdentifierOrStringOrStarContext()
}

type IdentifierOrStringOrStarContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrStringOrStarContext() *IdentifierOrStringOrStarContext {
	var p = new(IdentifierOrStringOrStarContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_identifierOrStringOrStar
	return p
}

func InitEmptyIdentifierOrStringOrStarContext(p *IdentifierOrStringOrStarContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_identifierOrStringOrStar
}

func (*IdentifierOrStringOrStarContext) IsIdentifierOrStringOrStarContext() {}

func NewIdentifierOrStringOrStarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrStringOrStarContext {
	var p = new(IdentifierOrStringOrStarContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_identifierOrStringOrStar

	return p
}

func (s *IdentifierOrStringOrStarContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrStringOrStarContext) ASTERISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserASTERISK_SYMBOL, 0)
}

func (s *IdentifierOrStringOrStarContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierOrStringOrStarContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *IdentifierOrStringOrStarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrStringOrStarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrStringOrStarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterIdentifierOrStringOrStar(s)
	}
}

func (s *IdentifierOrStringOrStarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitIdentifierOrStringOrStar(s)
	}
}

func (s *IdentifierOrStringOrStarContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitIdentifierOrStringOrStar(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) IdentifierOrStringOrStar() (localctx IIdentifierOrStringOrStarContext) {
	localctx = NewIdentifierOrStringOrStarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1030, DorisSQLParserRULE_identifierOrStringOrStar)
	p.SetState(8178)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserASTERISK_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8175)
			p.Match(DorisSQLParserASTERISK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserACCESS, DorisSQLParserACTIVE, DorisSQLParserADMIN, DorisSQLParserADVISOR, DorisSQLParserAFTER, DorisSQLParserAGGREGATE, DorisSQLParserANTI, DorisSQLParserAPPLY, DorisSQLParserARRAY_AGG, DorisSQLParserARRAY_AGG_DISTINCT, DorisSQLParserASYNC, DorisSQLParserAUTHORS, DorisSQLParserAUTHENTICATION, DorisSQLParserAUTOMATED, DorisSQLParserAUTO_INCREMENT, DorisSQLParserAVG, DorisSQLParserBACKEND, DorisSQLParserBACKENDS, DorisSQLParserBACKUP, DorisSQLParserBASE, DorisSQLParserBASELINE, DorisSQLParserBEGIN, DorisSQLParserBINARY, DorisSQLParserBITMAP_UNION, DorisSQLParserBLACKHOLE, DorisSQLParserBLACKLIST, DorisSQLParserBODY, DorisSQLParserBOOLEAN, DorisSQLParserBRANCH, DorisSQLParserBROKER, DorisSQLParserBUCKETS, DorisSQLParserBUILTIN, DorisSQLParserCACHE, DorisSQLParserCANCEL, DorisSQLParserCAST, DorisSQLParserCATALOG, DorisSQLParserCATALOGS, DorisSQLParserCEIL, DorisSQLParserCHAIN, DorisSQLParserCHARSET, DorisSQLParserCLEAN, DorisSQLParserCLEAR, DorisSQLParserCLUSTER, DorisSQLParserCLUSTERS, DorisSQLParserCNGROUP, DorisSQLParserCNGROUPS, DorisSQLParserCOLLATION, DorisSQLParserCOLUMNS, DorisSQLParserCOMMENT, DorisSQLParserCOMMIT, DorisSQLParserCOMMITTED, DorisSQLParserCOMPACT, DorisSQLParserCOMPUTE, DorisSQLParserCONFIG, DorisSQLParserCONNECTION, DorisSQLParserCONSISTENT, DorisSQLParserCOSTS, DorisSQLParserCOUNT, DorisSQLParserCUME_DIST, DorisSQLParserCUMULATIVE, DorisSQLParserCURRENT, DorisSQLParserDATA, DorisSQLParserDATACACHE, DorisSQLParserDATE, DorisSQLParserDATETIME, DorisSQLParserDAY, DorisSQLParserDAYS, DorisSQLParserDEALLOCATE, DorisSQLParserDECOMMISSION, DorisSQLParserDIALECT, DorisSQLParserDICTIONARY, DorisSQLParserDICTIONARY_GET, DorisSQLParserDISABLE, DorisSQLParserDISTRIBUTED, DorisSQLParserDISTRIBUTION, DorisSQLParserDUPLICATE, DorisSQLParserDYNAMIC, DorisSQLParserENABLE, DorisSQLParserENCLOSE, DorisSQLParserEND, DorisSQLParserENGINE, DorisSQLParserENGINES, DorisSQLParserERRORS, DorisSQLParserESCAPE, DorisSQLParserEVENTS, DorisSQLParserEXCEPT, DorisSQLParserEXCLUDE, DorisSQLParserEXECUTE, DorisSQLParserEXPORT, DorisSQLParserEXTERNAL, DorisSQLParserEXTRACT, DorisSQLParserEVERY, DorisSQLParserFAILPOINT, DorisSQLParserFAILPOINTS, DorisSQLParserFIELDS, DorisSQLParserFILE, DorisSQLParserFILTER, DorisSQLParserFIRST, DorisSQLParserFLOOR, DorisSQLParserFN, DorisSQLParserFOLLOWING, DorisSQLParserFOLLOWER, DorisSQLParserFORMAT, DorisSQLParserFREE, DorisSQLParserFRONTEND, DorisSQLParserFRONTENDS, DorisSQLParserFUNCTIONS, DorisSQLParserGLOBAL, DorisSQLParserGRANTS, DorisSQLParserGROUP_CONCAT, DorisSQLParserHASH, DorisSQLParserHELP, DorisSQLParserHISTOGRAM, DorisSQLParserHLL_UNION, DorisSQLParserHOST, DorisSQLParserHOUR, DorisSQLParserHOURS, DorisSQLParserHUB, DorisSQLParserIDENTIFIED, DorisSQLParserIMPERSONATE, DorisSQLParserIMAGE, DorisSQLParserINACTIVE, DorisSQLParserINCREMENTAL, DorisSQLParserINDEXES, DorisSQLParserINSTALL, DorisSQLParserINTEGRATION, DorisSQLParserINTEGRATIONS, DorisSQLParserINTERMEDIATE, DorisSQLParserINTERVAL, DorisSQLParserOVERWRITE, DorisSQLParserISOLATION, DorisSQLParserJOB, DorisSQLParserLABEL, DorisSQLParserLAST, DorisSQLParserLESS, DorisSQLParserLEVEL, DorisSQLParserLIST, DorisSQLParserLOCAL, DorisSQLParserLOCATION, DorisSQLParserLOCATIONS, DorisSQLParserLOGS, DorisSQLParserLOGICAL, DorisSQLParserMANUAL, DorisSQLParserMAP, DorisSQLParserMAPPING, DorisSQLParserMAPPINGS, DorisSQLParserMASKING, DorisSQLParserMATCH, DorisSQLParserMATERIALIZED, DorisSQLParserMAX, DorisSQLParserMERGE, DorisSQLParserMIN, DorisSQLParserMINUTE, DorisSQLParserMINUTES, DorisSQLParserMINUS, DorisSQLParserMETA, DorisSQLParserMODE, DorisSQLParserMODIFY, DorisSQLParserMONTH, DorisSQLParserMULTIPLE, DorisSQLParserNAME, DorisSQLParserNAMES, DorisSQLParserNEGATIVE, DorisSQLParserNGRAMBF, DorisSQLParserNO, DorisSQLParserNODE, DorisSQLParserNODES, DorisSQLParserNONE, DorisSQLParserNULLS, DorisSQLParserNUMBER, DorisSQLParserNUMERIC, DorisSQLParserOBSERVER, DorisSQLParserOF, DorisSQLParserOFF, DorisSQLParserOFFSET, DorisSQLParserONLY, DorisSQLParserOPEN, DorisSQLParserOPERATE, DorisSQLParserOPTIMIZER, DorisSQLParserOPTION, DorisSQLParserPARTITIONS, DorisSQLParserPASSWORD, DorisSQLParserPATH, DorisSQLParserPAUSE, DorisSQLParserPENDING, DorisSQLParserPERCENT_RANK, DorisSQLParserPERCENTILE_UNION, DorisSQLParserPLAN, DorisSQLParserPLUGIN, DorisSQLParserPLUGINS, DorisSQLParserPIPE, DorisSQLParserPIPES, DorisSQLParserPIVOT, DorisSQLParserPOLICY, DorisSQLParserPOLICIES, DorisSQLParserPRECEDING, DorisSQLParserPREDICATE, DorisSQLParserPRIORITY, DorisSQLParserPRIVILEGES, DorisSQLParserPROBABILITY, DorisSQLParserPROC, DorisSQLParserPROCESSLIST, DorisSQLParserPROFILE, DorisSQLParserPROFILELIST, DorisSQLParserPROPERTIES, DorisSQLParserPROPERTY, DorisSQLParserPROVIDER, DorisSQLParserPROVIDERS, DorisSQLParserQUALIFY, DorisSQLParserQUARTER, DorisSQLParserQUERY, DorisSQLParserQUERIES, DorisSQLParserQUEUE, DorisSQLParserQUOTA, DorisSQLParserRANDOM, DorisSQLParserRANK, DorisSQLParserREASON, DorisSQLParserRECOVER, DorisSQLParserREFRESH, DorisSQLParserREWRITE, DorisSQLParserREMOVE, DorisSQLParserREPAIR, DorisSQLParserREPEATABLE, DorisSQLParserREPLACE_IF_NOT_NULL, DorisSQLParserREPLICA, DorisSQLParserREPOSITORY, DorisSQLParserREPOSITORIES, DorisSQLParserRESOURCE, DorisSQLParserRESOURCES, DorisSQLParserRESTORE, DorisSQLParserRESUME, DorisSQLParserRETAIN, DorisSQLParserRETENTION, DorisSQLParserRETURNS, DorisSQLParserRETRY, DorisSQLParserREVERT, DorisSQLParserROLE, DorisSQLParserROLES, DorisSQLParserROLLBACK, DorisSQLParserROLLUP, DorisSQLParserROUTINE, DorisSQLParserROW, DorisSQLParserRULE, DorisSQLParserRULES, DorisSQLParserRUNNING, DorisSQLParserSAMPLE, DorisSQLParserSCHEDULE, DorisSQLParserSCHEDULER, DorisSQLParserSECOND, DorisSQLParserSECURITY, DorisSQLParserSEMI, DorisSQLParserSEPARATOR, DorisSQLParserSERIALIZABLE, DorisSQLParserSESSION, DorisSQLParserSETS, DorisSQLParserSIGNED, DorisSQLParserSKIP_HEADER, DorisSQLParserSNAPSHOT, DorisSQLParserSNAPSHOTS, DorisSQLParserSQLBLACKLIST, DorisSQLParserSTART, DorisSQLParserSTATS, DorisSQLParserSTATUS, DorisSQLParserSTOP, DorisSQLParserSTORAGE, DorisSQLParserSTREAM, DorisSQLParserSTRING, DorisSQLParserSUBMIT, DorisSQLParserSUM, DorisSQLParserSUSPEND, DorisSQLParserSYNC, DorisSQLParserSYSTEM_TIME, DorisSQLParserSWAP, DorisSQLParserSTRUCT, DorisSQLParserTABLES, DorisSQLParserTABLET, DorisSQLParserTABLETS, DorisSQLParserTAG, DorisSQLParserTASK, DorisSQLParserTEMPORARY, DorisSQLParserTHAN, DorisSQLParserTIME, DorisSQLParserTIMES, DorisSQLParserTIMESTAMP, DorisSQLParserTIMESTAMPADD, DorisSQLParserTIMESTAMPDIFF, DorisSQLParserTRANSACTION, DorisSQLParserTRANSLATE, DorisSQLParserTRACE, DorisSQLParserTRIGGERS, DorisSQLParserTRIM_SPACE, DorisSQLParserTRUNCATE, DorisSQLParserTYPE, DorisSQLParserTYPES, DorisSQLParserUNBOUNDED, DorisSQLParserUNCOMMITTED, DorisSQLParserUNINSTALL, DorisSQLParserUNSET, DorisSQLParserUSAGE, DorisSQLParserUSER, DorisSQLParserUSERS, DorisSQLParserVALUE, DorisSQLParserVARBINARY, DorisSQLParserVARIABLES, DorisSQLParserVECTOR, DorisSQLParserVERBOSE, DorisSQLParserVERSION, DorisSQLParserVIEW, DorisSQLParserVIEWS, DorisSQLParserVOLUME, DorisSQLParserVOLUMES, DorisSQLParserWAREHOUSE, DorisSQLParserWAREHOUSES, DorisSQLParserWARNINGS, DorisSQLParserWEEK, DorisSQLParserWHITELIST, DorisSQLParserWORK, DorisSQLParserWRITE, DorisSQLParserYEAR, DorisSQLParserLOCK, DorisSQLParserUNLOCK, DorisSQLParserLOW_PRIORITY, DorisSQLParserDISK, DorisSQLParserBEFORE, DorisSQLParserFIELD, DorisSQLParserPERSISTENT, DorisSQLParserARRAY_ELEMENT, DorisSQLParserLETTER_IDENTIFIER, DorisSQLParserDIGIT_IDENTIFIER, DorisSQLParserBACKQUOTED_IDENTIFIER, DorisSQLParserDOTDOTDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8176)
			p.Identifier()
		}

	case DorisSQLParserSINGLE_QUOTED_TEXT, DorisSQLParserDOUBLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8177)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserContext is an interface to support dynamic dispatch.
type IUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUserContext differentiates from other interfaces.
	IsUserContext()
}

type UserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserContext() *UserContext {
	var p = new(UserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_user
	return p
}

func InitEmptyUserContext(p *UserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_user
}

func (*UserContext) IsUserContext() {}

func NewUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserContext {
	var p = new(UserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_user

	return p
}

func (s *UserContext) GetParser() antlr.Parser { return s.parser }

func (s *UserContext) CopyAll(ctx *UserContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UserWithHostAndBlanketContext struct {
	UserContext
}

func NewUserWithHostAndBlanketContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserWithHostAndBlanketContext {
	var p = new(UserWithHostAndBlanketContext)

	InitEmptyUserContext(&p.UserContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserContext))

	return p
}

func (s *UserWithHostAndBlanketContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserWithHostAndBlanketContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *UserWithHostAndBlanketContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *UserWithHostAndBlanketContext) AT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAT, 0)
}

func (s *UserWithHostAndBlanketContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterUserWithHostAndBlanket(s)
	}
}

func (s *UserWithHostAndBlanketContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitUserWithHostAndBlanket(s)
	}
}

func (s *UserWithHostAndBlanketContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitUserWithHostAndBlanket(s)

	default:
		return t.VisitChildren(s)
	}
}

type UserWithHostContext struct {
	UserContext
}

func NewUserWithHostContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserWithHostContext {
	var p = new(UserWithHostContext)

	InitEmptyUserContext(&p.UserContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserContext))

	return p
}

func (s *UserWithHostContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserWithHostContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *UserWithHostContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *UserWithHostContext) AT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAT, 0)
}

func (s *UserWithHostContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterUserWithHost(s)
	}
}

func (s *UserWithHostContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitUserWithHost(s)
	}
}

func (s *UserWithHostContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitUserWithHost(s)

	default:
		return t.VisitChildren(s)
	}
}

type UserWithoutHostContext struct {
	UserContext
}

func NewUserWithoutHostContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserWithoutHostContext {
	var p = new(UserWithoutHostContext)

	InitEmptyUserContext(&p.UserContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserContext))

	return p
}

func (s *UserWithoutHostContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserWithoutHostContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *UserWithoutHostContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterUserWithoutHost(s)
	}
}

func (s *UserWithoutHostContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitUserWithoutHost(s)
	}
}

func (s *UserWithoutHostContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitUserWithoutHost(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) User() (localctx IUserContext) {
	localctx = NewUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1032, DorisSQLParserRULE_user)
	p.SetState(8191)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 972, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUserWithoutHostContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8180)
			p.IdentifierOrString()
		}

	case 2:
		localctx = NewUserWithHostContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8181)
			p.IdentifierOrString()
		}
		{
			p.SetState(8182)
			p.Match(DorisSQLParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8183)
			p.IdentifierOrString()
		}

	case 3:
		localctx = NewUserWithHostAndBlanketContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8185)
			p.IdentifierOrString()
		}
		{
			p.SetState(8186)
			p.Match(DorisSQLParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8187)
			p.Match(DorisSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8188)
			p.IdentifierOrString()
		}
		{
			p.SetState(8189)
			p.Match(DorisSQLParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentContext is an interface to support dynamic dispatch.
type IAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQ() antlr.TerminalNode
	ExpressionOrDefault() IExpressionOrDefaultContext

	// IsAssignmentContext differentiates from other interfaces.
	IsAssignmentContext()
}

type AssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentContext() *AssignmentContext {
	var p = new(AssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_assignment
	return p
}

func InitEmptyAssignmentContext(p *AssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_assignment
}

func (*AssignmentContext) IsAssignmentContext() {}

func NewAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentContext {
	var p = new(AssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_assignment

	return p
}

func (s *AssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEQ, 0)
}

func (s *AssignmentContext) ExpressionOrDefault() IExpressionOrDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionOrDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionOrDefaultContext)
}

func (s *AssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAssignment(s)
	}
}

func (s *AssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAssignment(s)
	}
}

func (s *AssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Assignment() (localctx IAssignmentContext) {
	localctx = NewAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1034, DorisSQLParserRULE_assignment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8193)
		p.Identifier()
	}
	{
		p.SetState(8194)
		p.Match(DorisSQLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8195)
		p.ExpressionOrDefault()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentListContext is an interface to support dynamic dispatch.
type IAssignmentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAssignment() []IAssignmentContext
	Assignment(i int) IAssignmentContext

	// IsAssignmentListContext differentiates from other interfaces.
	IsAssignmentListContext()
}

type AssignmentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentListContext() *AssignmentListContext {
	var p = new(AssignmentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_assignmentList
	return p
}

func InitEmptyAssignmentListContext(p *AssignmentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_assignmentList
}

func (*AssignmentListContext) IsAssignmentListContext() {}

func NewAssignmentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentListContext {
	var p = new(AssignmentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_assignmentList

	return p
}

func (s *AssignmentListContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentListContext) AllAssignment() []IAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentContext); ok {
			tst[i] = t.(IAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentListContext) Assignment(i int) IAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *AssignmentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterAssignmentList(s)
	}
}

func (s *AssignmentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitAssignmentList(s)
	}
}

func (s *AssignmentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitAssignmentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) AssignmentList() (localctx IAssignmentListContext) {
	localctx = NewAssignmentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1036, DorisSQLParserRULE_assignmentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8197)
		p.Assignment()
	}
	p.SetState(8202)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserT__2 {
		{
			p.SetState(8198)
			p.Match(DorisSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8199)
			p.Assignment()
		}

		p.SetState(8204)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_number
	return p
}

func InitEmptyNumberContext(p *NumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_number
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) CopyAll(ctx *NumberContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DecimalValueContext struct {
	NumberContext
}

func NewDecimalValueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecimalValueContext {
	var p = new(DecimalValueContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *DecimalValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalValueContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDECIMAL_VALUE, 0)
}

func (s *DecimalValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDecimalValue(s)
	}
}

func (s *DecimalValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDecimalValue(s)
	}
}

func (s *DecimalValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDecimalValue(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntegerValueContext struct {
	NumberContext
}

func NewIntegerValueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerValueContext {
	var p = new(IntegerValueContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *IntegerValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerValueContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGER_VALUE, 0)
}

func (s *IntegerValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterIntegerValue(s)
	}
}

func (s *IntegerValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitIntegerValue(s)
	}
}

func (s *IntegerValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitIntegerValue(s)

	default:
		return t.VisitChildren(s)
	}
}

type DoubleValueContext struct {
	NumberContext
}

func NewDoubleValueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoubleValueContext {
	var p = new(DoubleValueContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *DoubleValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoubleValueContext) DOUBLE_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDOUBLE_VALUE, 0)
}

func (s *DoubleValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterDoubleValue(s)
	}
}

func (s *DoubleValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitDoubleValue(s)
	}
}

func (s *DoubleValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitDoubleValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1038, DorisSQLParserRULE_number)
	p.SetState(8208)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserDECIMAL_VALUE:
		localctx = NewDecimalValueContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8205)
			p.Match(DorisSQLParserDECIMAL_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserDOUBLE_VALUE:
		localctx = NewDoubleValueContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8206)
			p.Match(DorisSQLParserDOUBLE_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserINTEGER_VALUE:
		localctx = NewIntegerValueContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8207)
			p.Match(DorisSQLParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonReservedContext is an interface to support dynamic dispatch.
type INonReservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACCESS() antlr.TerminalNode
	ACTIVE() antlr.TerminalNode
	ADVISOR() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	AGGREGATE() antlr.TerminalNode
	APPLY() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	AUTHORS() antlr.TerminalNode
	AVG() antlr.TerminalNode
	ADMIN() antlr.TerminalNode
	ANTI() antlr.TerminalNode
	AUTHENTICATION() antlr.TerminalNode
	AUTO_INCREMENT() antlr.TerminalNode
	AUTOMATED() antlr.TerminalNode
	ARRAY_AGG() antlr.TerminalNode
	ARRAY_AGG_DISTINCT() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	BACKENDS() antlr.TerminalNode
	BACKUP() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	BITMAP_UNION() antlr.TerminalNode
	BLACKLIST() antlr.TerminalNode
	BLACKHOLE() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	BODY() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	BRANCH() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	BUILTIN() antlr.TerminalNode
	BASE() antlr.TerminalNode
	BEFORE() antlr.TerminalNode
	BASELINE() antlr.TerminalNode
	CACHE() antlr.TerminalNode
	CAST() antlr.TerminalNode
	CANCEL() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	CATALOGS() antlr.TerminalNode
	CEIL() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CLEAN() antlr.TerminalNode
	CLEAR() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	CLUSTERS() antlr.TerminalNode
	CNGROUP() antlr.TerminalNode
	CNGROUPS() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	CUME_DIST() antlr.TerminalNode
	CUMULATIVE() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	COMPUTE() antlr.TerminalNode
	CONNECTION() antlr.TerminalNode
	CONSISTENT() antlr.TerminalNode
	COSTS() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	CONFIG() antlr.TerminalNode
	COMPACT() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATACACHE() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	DAY() antlr.TerminalNode
	DAYS() antlr.TerminalNode
	DECOMMISSION() antlr.TerminalNode
	DIALECT() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	DISK() antlr.TerminalNode
	DISTRIBUTION() antlr.TerminalNode
	DUPLICATE() antlr.TerminalNode
	DYNAMIC() antlr.TerminalNode
	DISTRIBUTED() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	DICTIONARY_GET() antlr.TerminalNode
	DEALLOCATE() antlr.TerminalNode
	ENABLE() antlr.TerminalNode
	END() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	ENGINES() antlr.TerminalNode
	ERRORS() antlr.TerminalNode
	EVENTS() antlr.TerminalNode
	EXECUTE() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	EXTRACT() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	ENCLOSE() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	FAILPOINT() antlr.TerminalNode
	FAILPOINTS() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	FILE() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	FLOOR() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	FN() antlr.TerminalNode
	FRONTEND() antlr.TerminalNode
	FRONTENDS() antlr.TerminalNode
	FOLLOWER() antlr.TerminalNode
	FREE() antlr.TerminalNode
	FUNCTIONS() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	GRANTS() antlr.TerminalNode
	GROUP_CONCAT() antlr.TerminalNode
	HASH() antlr.TerminalNode
	HISTOGRAM() antlr.TerminalNode
	HELP() antlr.TerminalNode
	HLL_UNION() antlr.TerminalNode
	HOST() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	HOURS() antlr.TerminalNode
	HUB() antlr.TerminalNode
	IDENTIFIED() antlr.TerminalNode
	IMAGE() antlr.TerminalNode
	IMPERSONATE() antlr.TerminalNode
	INACTIVE() antlr.TerminalNode
	INCREMENTAL() antlr.TerminalNode
	INDEXES() antlr.TerminalNode
	INSTALL() antlr.TerminalNode
	INTEGRATION() antlr.TerminalNode
	INTEGRATIONS() antlr.TerminalNode
	INTERMEDIATE() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	ISOLATION() antlr.TerminalNode
	JOB() antlr.TerminalNode
	LABEL() antlr.TerminalNode
	LAST() antlr.TerminalNode
	LESS() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	LIST() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	LOCATION() antlr.TerminalNode
	LOGS() antlr.TerminalNode
	LOGICAL() antlr.TerminalNode
	LOW_PRIORITY() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	LOCATIONS() antlr.TerminalNode
	MANUAL() antlr.TerminalNode
	MAP() antlr.TerminalNode
	MAPPING() antlr.TerminalNode
	MAPPINGS() antlr.TerminalNode
	MASKING() antlr.TerminalNode
	MATCH() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	MAX() antlr.TerminalNode
	META() antlr.TerminalNode
	MIN() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MINUTES() antlr.TerminalNode
	MODE() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	MULTIPLE() antlr.TerminalNode
	NAME() antlr.TerminalNode
	NAMES() antlr.TerminalNode
	NEGATIVE() antlr.TerminalNode
	NO() antlr.TerminalNode
	NODE() antlr.TerminalNode
	NODES() antlr.TerminalNode
	NONE() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	NUMERIC() antlr.TerminalNode
	OBSERVER() antlr.TerminalNode
	OF() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	OPTIMIZER() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	OPERATE() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	OVERWRITE() antlr.TerminalNode
	OFF() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	PATH() antlr.TerminalNode
	PAUSE() antlr.TerminalNode
	PENDING() antlr.TerminalNode
	PERCENTILE_UNION() antlr.TerminalNode
	PIVOT() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	PLUGINS() antlr.TerminalNode
	POLICY() antlr.TerminalNode
	POLICIES() antlr.TerminalNode
	PERCENT_RANK() antlr.TerminalNode
	PREDICATE() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	PRIORITY() antlr.TerminalNode
	PROC() antlr.TerminalNode
	PROCESSLIST() antlr.TerminalNode
	PROFILE() antlr.TerminalNode
	PROFILELIST() antlr.TerminalNode
	PROVIDER() antlr.TerminalNode
	PROVIDERS() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	PROBABILITY() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode
	PIPE() antlr.TerminalNode
	PIPES() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	QUERIES() antlr.TerminalNode
	QUEUE() antlr.TerminalNode
	QUOTA() antlr.TerminalNode
	QUALIFY() antlr.TerminalNode
	REASON() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	REWRITE() antlr.TerminalNode
	RANDOM() antlr.TerminalNode
	RANK() antlr.TerminalNode
	RECOVER() antlr.TerminalNode
	REFRESH() antlr.TerminalNode
	REPAIR() antlr.TerminalNode
	REPEATABLE() antlr.TerminalNode
	REPLACE_IF_NOT_NULL() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	REPOSITORY() antlr.TerminalNode
	REPOSITORIES() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	RESOURCES() antlr.TerminalNode
	RESTORE() antlr.TerminalNode
	RESUME() antlr.TerminalNode
	RETAIN() antlr.TerminalNode
	RETENTION() antlr.TerminalNode
	RETURNS() antlr.TerminalNode
	RETRY() antlr.TerminalNode
	REVERT() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	ROLES() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	ROW() antlr.TerminalNode
	RUNNING() antlr.TerminalNode
	RULE() antlr.TerminalNode
	RULES() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	SCHEDULER() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	SEPARATOR() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	SETS() antlr.TerminalNode
	SIGNED() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	SNAPSHOTS() antlr.TerminalNode
	SQLBLACKLIST() antlr.TerminalNode
	START() antlr.TerminalNode
	STREAM() antlr.TerminalNode
	SUM() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	STOP() antlr.TerminalNode
	SKIP_HEADER() antlr.TerminalNode
	SWAP() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	STRING() antlr.TerminalNode
	STRUCT() antlr.TerminalNode
	STATS() antlr.TerminalNode
	SUBMIT() antlr.TerminalNode
	SUSPEND() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	SYSTEM_TIME() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	TABLET() antlr.TerminalNode
	TABLETS() antlr.TerminalNode
	TAG() antlr.TerminalNode
	TASK() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	TIMESTAMPADD() antlr.TerminalNode
	TIMESTAMPDIFF() antlr.TerminalNode
	THAN() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMES() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	TRACE() antlr.TerminalNode
	TRANSLATE() antlr.TerminalNode
	TRIM_SPACE() antlr.TerminalNode
	TRIGGERS() antlr.TerminalNode
	TRUNCATE() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	TYPES() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	UNSET() antlr.TerminalNode
	UNINSTALL() antlr.TerminalNode
	USAGE() antlr.TerminalNode
	USER() antlr.TerminalNode
	USERS() antlr.TerminalNode
	UNLOCK() antlr.TerminalNode
	VALUE() antlr.TerminalNode
	VARBINARY() antlr.TerminalNode
	VARIABLES() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	VIEWS() antlr.TerminalNode
	VERBOSE() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	VOLUMES() antlr.TerminalNode
	WARNINGS() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	WHITELIST() antlr.TerminalNode
	WORK() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	WAREHOUSES() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	DOTDOTDOT() antlr.TerminalNode
	NGRAMBF() antlr.TerminalNode
	VECTOR() antlr.TerminalNode
	FIELD() antlr.TerminalNode
	ARRAY_ELEMENT() antlr.TerminalNode
	PERSISTENT() antlr.TerminalNode
	EXCLUDE() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode

	// IsNonReservedContext differentiates from other interfaces.
	IsNonReservedContext()
}

type NonReservedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedContext() *NonReservedContext {
	var p = new(NonReservedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_nonReserved
	return p
}

func InitEmptyNonReservedContext(p *NonReservedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserRULE_nonReserved
}

func (*NonReservedContext) IsNonReservedContext() {}

func NewNonReservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedContext {
	var p = new(NonReservedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserRULE_nonReserved

	return p
}

func (s *NonReservedContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedContext) ACCESS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserACCESS, 0)
}

func (s *NonReservedContext) ACTIVE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserACTIVE, 0)
}

func (s *NonReservedContext) ADVISOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADVISOR, 0)
}

func (s *NonReservedContext) AFTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAFTER, 0)
}

func (s *NonReservedContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAGGREGATE, 0)
}

func (s *NonReservedContext) APPLY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAPPLY, 0)
}

func (s *NonReservedContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserASYNC, 0)
}

func (s *NonReservedContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAUTHORS, 0)
}

func (s *NonReservedContext) AVG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAVG, 0)
}

func (s *NonReservedContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserADMIN, 0)
}

func (s *NonReservedContext) ANTI() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserANTI, 0)
}

func (s *NonReservedContext) AUTHENTICATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAUTHENTICATION, 0)
}

func (s *NonReservedContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAUTO_INCREMENT, 0)
}

func (s *NonReservedContext) AUTOMATED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserAUTOMATED, 0)
}

func (s *NonReservedContext) ARRAY_AGG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserARRAY_AGG, 0)
}

func (s *NonReservedContext) ARRAY_AGG_DISTINCT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserARRAY_AGG_DISTINCT, 0)
}

func (s *NonReservedContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBACKEND, 0)
}

func (s *NonReservedContext) BACKENDS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBACKENDS, 0)
}

func (s *NonReservedContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBACKUP, 0)
}

func (s *NonReservedContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBEGIN, 0)
}

func (s *NonReservedContext) BITMAP_UNION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBITMAP_UNION, 0)
}

func (s *NonReservedContext) BLACKLIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBLACKLIST, 0)
}

func (s *NonReservedContext) BLACKHOLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBLACKHOLE, 0)
}

func (s *NonReservedContext) BINARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBINARY, 0)
}

func (s *NonReservedContext) BODY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBODY, 0)
}

func (s *NonReservedContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBOOLEAN, 0)
}

func (s *NonReservedContext) BRANCH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBRANCH, 0)
}

func (s *NonReservedContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBROKER, 0)
}

func (s *NonReservedContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBUCKETS, 0)
}

func (s *NonReservedContext) BUILTIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBUILTIN, 0)
}

func (s *NonReservedContext) BASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBASE, 0)
}

func (s *NonReservedContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBEFORE, 0)
}

func (s *NonReservedContext) BASELINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserBASELINE, 0)
}

func (s *NonReservedContext) CACHE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCACHE, 0)
}

func (s *NonReservedContext) CAST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCAST, 0)
}

func (s *NonReservedContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCANCEL, 0)
}

func (s *NonReservedContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCATALOG, 0)
}

func (s *NonReservedContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCATALOGS, 0)
}

func (s *NonReservedContext) CEIL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCEIL, 0)
}

func (s *NonReservedContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCHAIN, 0)
}

func (s *NonReservedContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCHARSET, 0)
}

func (s *NonReservedContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCLEAN, 0)
}

func (s *NonReservedContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCLEAR, 0)
}

func (s *NonReservedContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCLUSTER, 0)
}

func (s *NonReservedContext) CLUSTERS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCLUSTERS, 0)
}

func (s *NonReservedContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCNGROUP, 0)
}

func (s *NonReservedContext) CNGROUPS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCNGROUPS, 0)
}

func (s *NonReservedContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCURRENT, 0)
}

func (s *NonReservedContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLLATION, 0)
}

func (s *NonReservedContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOLUMNS, 0)
}

func (s *NonReservedContext) CUME_DIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCUME_DIST, 0)
}

func (s *NonReservedContext) CUMULATIVE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCUMULATIVE, 0)
}

func (s *NonReservedContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOMMENT, 0)
}

func (s *NonReservedContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOMMIT, 0)
}

func (s *NonReservedContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOMMITTED, 0)
}

func (s *NonReservedContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOMPUTE, 0)
}

func (s *NonReservedContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCONNECTION, 0)
}

func (s *NonReservedContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCONSISTENT, 0)
}

func (s *NonReservedContext) COSTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOSTS, 0)
}

func (s *NonReservedContext) COUNT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOUNT, 0)
}

func (s *NonReservedContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCONFIG, 0)
}

func (s *NonReservedContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserCOMPACT, 0)
}

func (s *NonReservedContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATA, 0)
}

func (s *NonReservedContext) DATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATE, 0)
}

func (s *NonReservedContext) DATACACHE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATACACHE, 0)
}

func (s *NonReservedContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDATETIME, 0)
}

func (s *NonReservedContext) DAY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDAY, 0)
}

func (s *NonReservedContext) DAYS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDAYS, 0)
}

func (s *NonReservedContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDECOMMISSION, 0)
}

func (s *NonReservedContext) DIALECT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDIALECT, 0)
}

func (s *NonReservedContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDISABLE, 0)
}

func (s *NonReservedContext) DISK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDISK, 0)
}

func (s *NonReservedContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDISTRIBUTION, 0)
}

func (s *NonReservedContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDUPLICATE, 0)
}

func (s *NonReservedContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDYNAMIC, 0)
}

func (s *NonReservedContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDISTRIBUTED, 0)
}

func (s *NonReservedContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDICTIONARY, 0)
}

func (s *NonReservedContext) DICTIONARY_GET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDICTIONARY_GET, 0)
}

func (s *NonReservedContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDEALLOCATE, 0)
}

func (s *NonReservedContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserENABLE, 0)
}

func (s *NonReservedContext) END() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEND, 0)
}

func (s *NonReservedContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserENGINE, 0)
}

func (s *NonReservedContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserENGINES, 0)
}

func (s *NonReservedContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserERRORS, 0)
}

func (s *NonReservedContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEVENTS, 0)
}

func (s *NonReservedContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXECUTE, 0)
}

func (s *NonReservedContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXTERNAL, 0)
}

func (s *NonReservedContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXTRACT, 0)
}

func (s *NonReservedContext) EVERY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEVERY, 0)
}

func (s *NonReservedContext) ENCLOSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserENCLOSE, 0)
}

func (s *NonReservedContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserESCAPE, 0)
}

func (s *NonReservedContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXPORT, 0)
}

func (s *NonReservedContext) FAILPOINT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFAILPOINT, 0)
}

func (s *NonReservedContext) FAILPOINTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFAILPOINTS, 0)
}

func (s *NonReservedContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFIELDS, 0)
}

func (s *NonReservedContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFILE, 0)
}

func (s *NonReservedContext) FILTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFILTER, 0)
}

func (s *NonReservedContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFIRST, 0)
}

func (s *NonReservedContext) FLOOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFLOOR, 0)
}

func (s *NonReservedContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFOLLOWING, 0)
}

func (s *NonReservedContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFORMAT, 0)
}

func (s *NonReservedContext) FN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFN, 0)
}

func (s *NonReservedContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFRONTEND, 0)
}

func (s *NonReservedContext) FRONTENDS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFRONTENDS, 0)
}

func (s *NonReservedContext) FOLLOWER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFOLLOWER, 0)
}

func (s *NonReservedContext) FREE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFREE, 0)
}

func (s *NonReservedContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFUNCTIONS, 0)
}

func (s *NonReservedContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGLOBAL, 0)
}

func (s *NonReservedContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGRANTS, 0)
}

func (s *NonReservedContext) GROUP_CONCAT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserGROUP_CONCAT, 0)
}

func (s *NonReservedContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserHASH, 0)
}

func (s *NonReservedContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserHISTOGRAM, 0)
}

func (s *NonReservedContext) HELP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserHELP, 0)
}

func (s *NonReservedContext) HLL_UNION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserHLL_UNION, 0)
}

func (s *NonReservedContext) HOST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserHOST, 0)
}

func (s *NonReservedContext) HOUR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserHOUR, 0)
}

func (s *NonReservedContext) HOURS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserHOURS, 0)
}

func (s *NonReservedContext) HUB() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserHUB, 0)
}

func (s *NonReservedContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIDENTIFIED, 0)
}

func (s *NonReservedContext) IMAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIMAGE, 0)
}

func (s *NonReservedContext) IMPERSONATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserIMPERSONATE, 0)
}

func (s *NonReservedContext) INACTIVE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINACTIVE, 0)
}

func (s *NonReservedContext) INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINCREMENTAL, 0)
}

func (s *NonReservedContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINDEXES, 0)
}

func (s *NonReservedContext) INSTALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINSTALL, 0)
}

func (s *NonReservedContext) INTEGRATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGRATION, 0)
}

func (s *NonReservedContext) INTEGRATIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTEGRATIONS, 0)
}

func (s *NonReservedContext) INTERMEDIATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTERMEDIATE, 0)
}

func (s *NonReservedContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserINTERVAL, 0)
}

func (s *NonReservedContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserISOLATION, 0)
}

func (s *NonReservedContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserJOB, 0)
}

func (s *NonReservedContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLABEL, 0)
}

func (s *NonReservedContext) LAST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLAST, 0)
}

func (s *NonReservedContext) LESS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLESS, 0)
}

func (s *NonReservedContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLEVEL, 0)
}

func (s *NonReservedContext) LIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLIST, 0)
}

func (s *NonReservedContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOCAL, 0)
}

func (s *NonReservedContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOCATION, 0)
}

func (s *NonReservedContext) LOGS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOGS, 0)
}

func (s *NonReservedContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOGICAL, 0)
}

func (s *NonReservedContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOW_PRIORITY, 0)
}

func (s *NonReservedContext) LOCK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOCK, 0)
}

func (s *NonReservedContext) LOCATIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserLOCATIONS, 0)
}

func (s *NonReservedContext) MANUAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMANUAL, 0)
}

func (s *NonReservedContext) MAP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMAP, 0)
}

func (s *NonReservedContext) MAPPING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMAPPING, 0)
}

func (s *NonReservedContext) MAPPINGS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMAPPINGS, 0)
}

func (s *NonReservedContext) MASKING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMASKING, 0)
}

func (s *NonReservedContext) MATCH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMATCH, 0)
}

func (s *NonReservedContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMATERIALIZED, 0)
}

func (s *NonReservedContext) MAX() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMAX, 0)
}

func (s *NonReservedContext) META() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMETA, 0)
}

func (s *NonReservedContext) MIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMIN, 0)
}

func (s *NonReservedContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMINUTE, 0)
}

func (s *NonReservedContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMINUTES, 0)
}

func (s *NonReservedContext) MODE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMODE, 0)
}

func (s *NonReservedContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMODIFY, 0)
}

func (s *NonReservedContext) MONTH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMONTH, 0)
}

func (s *NonReservedContext) MERGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMERGE, 0)
}

func (s *NonReservedContext) MINUS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMINUS, 0)
}

func (s *NonReservedContext) MULTIPLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserMULTIPLE, 0)
}

func (s *NonReservedContext) NAME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNAME, 0)
}

func (s *NonReservedContext) NAMES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNAMES, 0)
}

func (s *NonReservedContext) NEGATIVE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNEGATIVE, 0)
}

func (s *NonReservedContext) NO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNO, 0)
}

func (s *NonReservedContext) NODE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNODE, 0)
}

func (s *NonReservedContext) NODES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNODES, 0)
}

func (s *NonReservedContext) NONE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNONE, 0)
}

func (s *NonReservedContext) NULLS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNULLS, 0)
}

func (s *NonReservedContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNUMBER, 0)
}

func (s *NonReservedContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNUMERIC, 0)
}

func (s *NonReservedContext) OBSERVER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOBSERVER, 0)
}

func (s *NonReservedContext) OF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOF, 0)
}

func (s *NonReservedContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOFFSET, 0)
}

func (s *NonReservedContext) ONLY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserONLY, 0)
}

func (s *NonReservedContext) OPTIMIZER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOPTIMIZER, 0)
}

func (s *NonReservedContext) OPEN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOPEN, 0)
}

func (s *NonReservedContext) OPERATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOPERATE, 0)
}

func (s *NonReservedContext) OPTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOPTION, 0)
}

func (s *NonReservedContext) OVERWRITE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOVERWRITE, 0)
}

func (s *NonReservedContext) OFF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserOFF, 0)
}

func (s *NonReservedContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPARTITIONS, 0)
}

func (s *NonReservedContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPASSWORD, 0)
}

func (s *NonReservedContext) PATH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPATH, 0)
}

func (s *NonReservedContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPAUSE, 0)
}

func (s *NonReservedContext) PENDING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPENDING, 0)
}

func (s *NonReservedContext) PERCENTILE_UNION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPERCENTILE_UNION, 0)
}

func (s *NonReservedContext) PIVOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPIVOT, 0)
}

func (s *NonReservedContext) PLAN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPLAN, 0)
}

func (s *NonReservedContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPLUGIN, 0)
}

func (s *NonReservedContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPLUGINS, 0)
}

func (s *NonReservedContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPOLICY, 0)
}

func (s *NonReservedContext) POLICIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPOLICIES, 0)
}

func (s *NonReservedContext) PERCENT_RANK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPERCENT_RANK, 0)
}

func (s *NonReservedContext) PREDICATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPREDICATE, 0)
}

func (s *NonReservedContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPRECEDING, 0)
}

func (s *NonReservedContext) PRIORITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPRIORITY, 0)
}

func (s *NonReservedContext) PROC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROC, 0)
}

func (s *NonReservedContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROCESSLIST, 0)
}

func (s *NonReservedContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROFILE, 0)
}

func (s *NonReservedContext) PROFILELIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROFILELIST, 0)
}

func (s *NonReservedContext) PROVIDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROVIDER, 0)
}

func (s *NonReservedContext) PROVIDERS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROVIDERS, 0)
}

func (s *NonReservedContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPRIVILEGES, 0)
}

func (s *NonReservedContext) PROBABILITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROBABILITY, 0)
}

func (s *NonReservedContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROPERTIES, 0)
}

func (s *NonReservedContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPROPERTY, 0)
}

func (s *NonReservedContext) PIPE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPIPE, 0)
}

func (s *NonReservedContext) PIPES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPIPES, 0)
}

func (s *NonReservedContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserQUARTER, 0)
}

func (s *NonReservedContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserQUERY, 0)
}

func (s *NonReservedContext) QUERIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserQUERIES, 0)
}

func (s *NonReservedContext) QUEUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserQUEUE, 0)
}

func (s *NonReservedContext) QUOTA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserQUOTA, 0)
}

func (s *NonReservedContext) QUALIFY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserQUALIFY, 0)
}

func (s *NonReservedContext) REASON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREASON, 0)
}

func (s *NonReservedContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREMOVE, 0)
}

func (s *NonReservedContext) REWRITE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREWRITE, 0)
}

func (s *NonReservedContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRANDOM, 0)
}

func (s *NonReservedContext) RANK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRANK, 0)
}

func (s *NonReservedContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRECOVER, 0)
}

func (s *NonReservedContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREFRESH, 0)
}

func (s *NonReservedContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPAIR, 0)
}

func (s *NonReservedContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPEATABLE, 0)
}

func (s *NonReservedContext) REPLACE_IF_NOT_NULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPLACE_IF_NOT_NULL, 0)
}

func (s *NonReservedContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPLICA, 0)
}

func (s *NonReservedContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPOSITORY, 0)
}

func (s *NonReservedContext) REPOSITORIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREPOSITORIES, 0)
}

func (s *NonReservedContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRESOURCE, 0)
}

func (s *NonReservedContext) RESOURCES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRESOURCES, 0)
}

func (s *NonReservedContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRESTORE, 0)
}

func (s *NonReservedContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRESUME, 0)
}

func (s *NonReservedContext) RETAIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRETAIN, 0)
}

func (s *NonReservedContext) RETENTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRETENTION, 0)
}

func (s *NonReservedContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRETURNS, 0)
}

func (s *NonReservedContext) RETRY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRETRY, 0)
}

func (s *NonReservedContext) REVERT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserREVERT, 0)
}

func (s *NonReservedContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROLE, 0)
}

func (s *NonReservedContext) ROLES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROLES, 0)
}

func (s *NonReservedContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROLLUP, 0)
}

func (s *NonReservedContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROLLBACK, 0)
}

func (s *NonReservedContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROUTINE, 0)
}

func (s *NonReservedContext) ROW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserROW, 0)
}

func (s *NonReservedContext) RUNNING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRUNNING, 0)
}

func (s *NonReservedContext) RULE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRULE, 0)
}

func (s *NonReservedContext) RULES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserRULES, 0)
}

func (s *NonReservedContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSAMPLE, 0)
}

func (s *NonReservedContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSCHEDULE, 0)
}

func (s *NonReservedContext) SCHEDULER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSCHEDULER, 0)
}

func (s *NonReservedContext) SECOND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSECOND, 0)
}

func (s *NonReservedContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSECURITY, 0)
}

func (s *NonReservedContext) SEPARATOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSEPARATOR, 0)
}

func (s *NonReservedContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSERIALIZABLE, 0)
}

func (s *NonReservedContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSEMI, 0)
}

func (s *NonReservedContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSESSION, 0)
}

func (s *NonReservedContext) SETS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSETS, 0)
}

func (s *NonReservedContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSIGNED, 0)
}

func (s *NonReservedContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSNAPSHOT, 0)
}

func (s *NonReservedContext) SNAPSHOTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSNAPSHOTS, 0)
}

func (s *NonReservedContext) SQLBLACKLIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSQLBLACKLIST, 0)
}

func (s *NonReservedContext) START() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTART, 0)
}

func (s *NonReservedContext) STREAM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTREAM, 0)
}

func (s *NonReservedContext) SUM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSUM, 0)
}

func (s *NonReservedContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTATUS, 0)
}

func (s *NonReservedContext) STOP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTOP, 0)
}

func (s *NonReservedContext) SKIP_HEADER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSKIP_HEADER, 0)
}

func (s *NonReservedContext) SWAP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSWAP, 0)
}

func (s *NonReservedContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTORAGE, 0)
}

func (s *NonReservedContext) STRING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTRING, 0)
}

func (s *NonReservedContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTRUCT, 0)
}

func (s *NonReservedContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSTATS, 0)
}

func (s *NonReservedContext) SUBMIT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSUBMIT, 0)
}

func (s *NonReservedContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSUSPEND, 0)
}

func (s *NonReservedContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSYNC, 0)
}

func (s *NonReservedContext) SYSTEM_TIME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserSYSTEM_TIME, 0)
}

func (s *NonReservedContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLES, 0)
}

func (s *NonReservedContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLET, 0)
}

func (s *NonReservedContext) TABLETS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTABLETS, 0)
}

func (s *NonReservedContext) TAG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTAG, 0)
}

func (s *NonReservedContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTASK, 0)
}

func (s *NonReservedContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTEMPORARY, 0)
}

func (s *NonReservedContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTIMESTAMP, 0)
}

func (s *NonReservedContext) TIMESTAMPADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTIMESTAMPADD, 0)
}

func (s *NonReservedContext) TIMESTAMPDIFF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTIMESTAMPDIFF, 0)
}

func (s *NonReservedContext) THAN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTHAN, 0)
}

func (s *NonReservedContext) TIME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTIME, 0)
}

func (s *NonReservedContext) TIMES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTIMES, 0)
}

func (s *NonReservedContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTRANSACTION, 0)
}

func (s *NonReservedContext) TRACE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTRACE, 0)
}

func (s *NonReservedContext) TRANSLATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTRANSLATE, 0)
}

func (s *NonReservedContext) TRIM_SPACE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTRIM_SPACE, 0)
}

func (s *NonReservedContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTRIGGERS, 0)
}

func (s *NonReservedContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTRUNCATE, 0)
}

func (s *NonReservedContext) TYPE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTYPE, 0)
}

func (s *NonReservedContext) TYPES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserTYPES, 0)
}

func (s *NonReservedContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUNBOUNDED, 0)
}

func (s *NonReservedContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUNCOMMITTED, 0)
}

func (s *NonReservedContext) UNSET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUNSET, 0)
}

func (s *NonReservedContext) UNINSTALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUNINSTALL, 0)
}

func (s *NonReservedContext) USAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSAGE, 0)
}

func (s *NonReservedContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSER, 0)
}

func (s *NonReservedContext) USERS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUSERS, 0)
}

func (s *NonReservedContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserUNLOCK, 0)
}

func (s *NonReservedContext) VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVALUE, 0)
}

func (s *NonReservedContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVARBINARY, 0)
}

func (s *NonReservedContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVARIABLES, 0)
}

func (s *NonReservedContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVIEW, 0)
}

func (s *NonReservedContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVIEWS, 0)
}

func (s *NonReservedContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVERBOSE, 0)
}

func (s *NonReservedContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVERSION, 0)
}

func (s *NonReservedContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVOLUME, 0)
}

func (s *NonReservedContext) VOLUMES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVOLUMES, 0)
}

func (s *NonReservedContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWARNINGS, 0)
}

func (s *NonReservedContext) WEEK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWEEK, 0)
}

func (s *NonReservedContext) WHITELIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWHITELIST, 0)
}

func (s *NonReservedContext) WORK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWORK, 0)
}

func (s *NonReservedContext) WRITE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWRITE, 0)
}

func (s *NonReservedContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWAREHOUSE, 0)
}

func (s *NonReservedContext) WAREHOUSES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserWAREHOUSES, 0)
}

func (s *NonReservedContext) YEAR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserYEAR, 0)
}

func (s *NonReservedContext) DOTDOTDOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserDOTDOTDOT, 0)
}

func (s *NonReservedContext) NGRAMBF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserNGRAMBF, 0)
}

func (s *NonReservedContext) VECTOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserVECTOR, 0)
}

func (s *NonReservedContext) FIELD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserFIELD, 0)
}

func (s *NonReservedContext) ARRAY_ELEMENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserARRAY_ELEMENT, 0)
}

func (s *NonReservedContext) PERSISTENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserPERSISTENT, 0)
}

func (s *NonReservedContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXCLUDE, 0)
}

func (s *NonReservedContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserEXCEPT, 0)
}

func (s *NonReservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonReservedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.EnterNonReserved(s)
	}
}

func (s *NonReservedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLListener); ok {
		listenerT.ExitNonReserved(s)
	}
}

func (s *NonReservedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLVisitor:
		return t.VisitNonReserved(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParser) NonReserved() (localctx INonReservedContext) {
	localctx = NewNonReservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1040, DorisSQLParserRULE_nonReserved)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8210)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262756702208) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-6664167256628462851) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-1331487429127569487) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&-7546427580836201) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-4573491655345179) != 0) || ((int64((_la-324)) & ^0x3f) == 0 && ((int64(1)<<(_la-324))&9114828243924942831) != 0) || ((int64((_la-389)) & ^0x3f) == 0 && ((int64(1)<<(_la-389))&-6956096606152176261) != 0) || ((int64((_la-453)) & ^0x3f) == 0 && ((int64(1)<<(_la-453))&70849595962729) != 0) || _la == DorisSQLParserDOTDOTDOT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *DorisSQLParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 382:
		var t *QueryPrimaryContext = nil
		if localctx != nil {
			t = localctx.(*QueryPrimaryContext)
		}
		return p.QueryPrimary_Sempred(t, predIndex)

	case 426:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 428:
		var t *BooleanExpressionContext = nil
		if localctx != nil {
			t = localctx.(*BooleanExpressionContext)
		}
		return p.BooleanExpression_Sempred(t, predIndex)

	case 432:
		var t *ValueExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ValueExpressionContext)
		}
		return p.ValueExpression_Sempred(t, predIndex)

	case 433:
		var t *PrimaryExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryExpressionContext)
		}
		return p.PrimaryExpression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *DorisSQLParser) QueryPrimary_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DorisSQLParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DorisSQLParser) BooleanExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DorisSQLParser) ValueExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DorisSQLParser) PrimaryExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 15:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 23)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 20)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 20:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 21:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
