// Code generated from DorisSQLParser.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // DorisSQLParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type DorisSQLParserParser struct {
	*antlr.BaseParser
}

var DorisSQLParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func dorissqlparserParserInit() {
	staticData := &DorisSQLParserParserStaticData
	staticData.LiteralNames = []string{
		"", "'.'", "'('", "','", "')'", "'=>'", "'['", "']'", "':'", "'{'",
		"'}'", "'ACCESS'", "'ACTIVE'", "'ADD'", "'ADMIN'", "'ADVISOR'", "'AFTER'",
		"'AGGREGATE'", "'ALL'", "'ALTER'", "'ANALYZE'", "'AND'", "'ANTI'", "'APPLY'",
		"'ARRAY'", "'ARRAY_AGG'", "'ARRAY_AGG_DISTINCT'", "'AS'", "'ASC'", "'ASYNC'",
		"'AUTHORS'", "'AUTHENTICATION'", "'AUTOMATED'", "'AUTO_INCREMENT'",
		"'AVG'", "'BACKEND'", "'BACKENDS'", "'BACKUP'", "'BASE'", "'BASELINE'",
		"'BEGIN'", "'BETWEEN'", "'BIGINT'", "'BINARY'", "'BITMAP'", "'BITMAP_UNION'",
		"'BLACKHOLE'", "'BLACKLIST'", "'BODY'", "'BOOLEAN'", "'BOTH'", "'BRANCH'",
		"'BROKER'", "'BUCKETS'", "'BUILTIN'", "'BY'", "'CACHE'", "'CANCEL'",
		"'CASE'", "'CAST'", "'CATALOG'", "'CATALOGS'", "'CEIL'", "'CHAIN'",
		"'CHAR'", "'CHARACTER'", "'CHARSET'", "'CHECK'", "'CLEAN'", "'CLEAR'",
		"'CLUSTER'", "'CLUSTERS'", "'CNGROUP'", "'CNGROUPS'", "'COLLATE'", "'COLLATION'",
		"'COLUMN'", "'COLUMNS'", "'COMMENT'", "'COMMIT'", "'COMMITTED'", "'COMPACT'",
		"'COMPACTION'", "'COMPUTE'", "'CONFIG'", "'CONNECTION'", "'CONSISTENT'",
		"'CONVERT'", "'COSTS'", "'COUNT'", "'CREATE'", "'CROSS'", "'CUBE'",
		"'CUME_DIST'", "'CUMULATIVE'", "'CURRENT'", "'CURRENT_DATE'", "'CURRENT_GROUP'",
		"'CURRENT_ROLE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'CURRENT_USER'",
		"'DATA'", "'DATACACHE'", "'DATABASE'", "'DATABASES'", "'DATE'", "'DATETIME'",
		"'DAY'", "'DAYS'", "'DEALLOCATE'", "'DECIMAL'", "'DECIMALV2'", "'DECIMAL32'",
		"'DECIMAL64'", "'DECIMAL128'", "'DECOMMISSION'", "'DEFAULT'", "'DELETE'",
		"'DENSE_RANK'", "'DEFERRED'", "'DIALECT'", "'DICTIONARY'", "'DICTIONARY_GET'",
		"'NTILE'", "'DESC'", "'DESCRIBE'", "'DISABLE'", "'DISTINCT'", "'DISTRIBUTED'",
		"'DISTRIBUTION'", "'DOUBLE'", "'DROP'", "'DUAL'", "'DUPLICATE'", "'DYNAMIC'",
		"'ELSE'", "'ENABLE'", "'ENCLOSE'", "'END'", "'ENGINE'", "'ENGINES'",
		"'ERRORS'", "'ESCAPE'", "'EVENTS'", "'EXCEPT'", "'EXCLUDE'", "'EXECUTE'",
		"'EXISTS'", "'EXPLAIN'", "'EXPORT'", "'EXTERNAL'", "'EXTRACT'", "'EVERY'",
		"'FAILPOINT'", "'FAILPOINTS'", "'FALSE'", "'FIELDS'", "'FILE'", "'FILES'",
		"'FILTER'", "'FIRST'", "'FIRST_VALUE'", "'FLOAT'", "'FLOOR'", "'FN'",
		"'FOLLOWING'", "'FOLLOWER'", "'FOR'", "'FORCE'", "'FORMAT'", "'FREE'",
		"'FROM'", "'FRONTEND'", "'FRONTENDS'", "'FULL'", "'FUNCTION'", "'FUNCTIONS'",
		"'GLOBAL'", "'GRANT'", "'GRANTS'", "'GROUP'", "'GROUPS'", "'GROUPING'",
		"'GROUPING_ID'", "'GROUP_CONCAT'", "'HASH'", "'HAVING'", "'HELP'", "'HISTOGRAM'",
		"'HLL'", "'HLL_UNION'", "'HOST'", "'HOUR'", "'HOURS'", "'HUB'", "'IDENTIFIED'",
		"'IF'", "'IMPERSONATE'", "'IMMEDIATE'", "'IGNORE'", "'IMAGE'", "'IN'",
		"'INACTIVE'", "'INCREMENTAL'", "'INDEX'", "'INDEXES'", "'INFILE'", "'INNER'",
		"'INSTALL'", "'INSERT'", "'INT'", "'INTEGER'", "'INTEGRATION'", "'INTEGRATIONS'",
		"'INTERMEDIATE'", "'INTERSECT'", "'INTERVAL'", "'INTO'", "'INVOKER'",
		"'GIN'", "'OVERWRITE'", "'IS'", "'ISOLATION'", "'JOB'", "'JOIN'", "'JSON'",
		"'KEY'", "'KEYS'", "'KILL'", "'LABEL'", "'LAG'", "'LARGEINT'", "'LAST'",
		"'LAST_VALUE'", "'LATERAL'", "'LEAD'", "'LEFT'", "'LESS'", "'LEVEL'",
		"'LIKE'", "'LIMIT'", "'LIST'", "'LOAD'", "'LOCAL'", "'LOCALTIME'", "'LOCALTIMESTAMP'",
		"'LOCATION'", "'LOCATIONS'", "'LOGS'", "'LOGICAL'", "'MANUAL'", "'MAP'",
		"'MAPPING'", "'MAPPINGS'", "'MASKING'", "'MATCH'", "'MATERIALIZED'",
		"'MAX'", "'MAXVALUE'", "'MERGE'", "'MICROSECOND'", "'MILLISECOND'",
		"'MIN'", "'MINUTE'", "'MINUTES'", "'MINUS'", "'META'", "'MOD'", "'MODE'",
		"'MODIFY'", "'MONTH'", "'MULTIPLE'", "'NAME'", "'NAMES'", "'NEGATIVE'",
		"'NGRAMBF'", "'NO'", "'NODE'", "'NODES'", "'NONE'", "'NOT'", "'NULL'",
		"'NULLS'", "'NUMBER'", "'NUMERIC'", "'OBSERVER'", "'OF'", "'OFF'", "'OFFSET'",
		"'ON'", "'ONLY'", "'OPEN'", "'OPERATE'", "'OPTIMIZE'", "'OPTIMIZER'",
		"'OPTION'", "'OR'", "'ORDER'", "'OUTER'", "'OUTFILE'", "'OVER'", "'?'",
		"'PARTITION'", "'PARTITIONS'", "'PASSWORD'", "'PATH'", "'PAUSE'", "'PENDING'",
		"'PERCENT_RANK'", "'PERCENTILE'", "'PERCENTILE_UNION'", "'PLAN'", "'PLUGIN'",
		"'PLUGINS'", "'PIPE'", "'PIPES'", "'PIVOT'", "'POLICY'", "'POLICIES'",
		"'PRECEDING'", "'PREDICATE'", "'PREPARE'", "'PRIMARY'", "'PRIORITY'",
		"'PRIVILEGES'", "'PROBABILITY'", "'PROC'", "'PROCEDURE'", "'PROCESSLIST'",
		"'PROFILE'", "'PROFILELIST'", "'PROPERTIES'", "'PROPERTY'", "'PROVIDER'",
		"'PROVIDERS'", "'QUALIFY'", "'QUARTER'", "'QUERY'", "'QUERIES'", "'QUEUE'",
		"'QUOTA'", "'RANDOM'", "'RANGE'", "'RANK'", "'READ'", "'REASON'", "'RECOVER'",
		"'REFRESH'", "'REWRITE'", "'REGEXP'", "'RELEASE'", "'REMOVE'", "'RENAME'",
		"'REPAIR'", "'REPEATABLE'", "'REPLACE'", "'REPLACE_IF_NOT_NULL'", "'REPLICA'",
		"'REPOSITORY'", "'REPOSITORIES'", "'RESOURCE'", "'RESOURCES'", "'RESTORE'",
		"'RESUME'", "'RETAIN'", "'RETENTION'", "'RETURNS'", "'RETRY'", "'REVOKE'",
		"'REVERT'", "'RIGHT'", "'RLIKE'", "'ROLE'", "'ROLES'", "'ROLLBACK'",
		"'ROLLUP'", "'ROUTINE'", "'ROW'", "'ROWS'", "'ROW_NUMBER'", "'RULE'",
		"'RULES'", "'RUNNING'", "'SAMPLE'", "'SCHEDULE'", "'SCHEDULER'", "'SCHEMA'",
		"'SCHEMAS'", "'SECOND'", "'SECURITY'", "'SELECT'", "'SEMI'", "'SEPARATOR'",
		"'SERIALIZABLE'", "'SESSION'", "'SET'", "'SETS'", "'SET_VAR'", "'SIGNED'",
		"'SKIP_HEADER'", "'SHOW'", "'SMALLINT'", "'SNAPSHOT'", "'SNAPSHOTS'",
		"'SQLBLACKLIST'", "'START'", "'STATS'", "'STATUS'", "'STOP'", "'STORAGE'",
		"'STREAM'", "'STRING'", "'TEXT'", "'SUBMIT'", "'SUM'", "'SUSPEND'",
		"'SYNC'", "'SYSTEM'", "'SYSTEM_TIME'", "'SWAP'", "'STRUCT'", "'TABLE'",
		"'TABLES'", "'TABLET'", "'TABLETS'", "'TAG'", "'TASK'", "'TEMPORARY'",
		"'TERMINATED'", "'THAN'", "'THEN'", "'TIME'", "'TIMES'", "'TIMESTAMP'",
		"'TIMESTAMPADD'", "'TIMESTAMPDIFF'", "'TINYINT'", "'TRANSACTION'", "'TRANSLATE'",
		"'TO'", "'TRACE'", "'TRIGGERS'", "'TRIM_SPACE'", "'TRUE'", "'TRUNCATE'",
		"'TYPE'", "'TYPES'", "'UNBOUNDED'", "'UNCOMMITTED'", "'UNION'", "'UNIQUE'",
		"'UNINSTALL'", "'UNSET'", "'UNSIGNED'", "'UPDATE'", "'USAGE'", "'USE'",
		"'USER'", "'USERS'", "'USING'", "'VALUE'", "'VALUES'", "'VARBINARY'",
		"'VARCHAR'", "'VARIABLES'", "'VECTOR'", "'VERBOSE'", "'VERSION'", "'VIEW'",
		"'VIEWS'", "'VOLUME'", "'VOLUMES'", "'WAREHOUSE'", "'WAREHOUSES'", "'WARNINGS'",
		"'WEEK'", "'WHEN'", "'WHERE'", "'WHITELIST'", "'WITH'", "'WORK'", "'WRITE'",
		"'YEAR'", "'LOCK'", "'UNLOCK'", "'LOW_PRIORITY'", "'DISK'", "'BEFORE'",
		"'$$'", "'FIELD'", "'PERSISTENT'", "'='", "", "'<'", "'<='", "'>'",
		"'>='", "'<=>'", "'[*]'", "'+'", "'-'", "'*'", "'/'", "'%'", "'||'",
		"'&&'", "'!'", "'DIV'", "'&'", "'|'", "'^'", "'~'", "'BITSHIFTLEFT'",
		"'BITSHIFTRIGHT'", "'BITSHIFTRIGHTLOGICAL'", "'->'", "'@'", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "';'", "'...'",
	}
	staticData.SymbolicNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "ACCESS", "ACTIVE", "ADD",
		"ADMIN", "ADVISOR", "AFTER", "AGGREGATE", "ALL", "ALTER", "ANALYZE",
		"AND", "ANTI", "APPLY", "ARRAY", "ARRAY_AGG", "ARRAY_AGG_DISTINCT",
		"AS", "ASC", "ASYNC", "AUTHORS", "AUTHENTICATION", "AUTOMATED", "AUTO_INCREMENT",
		"AVG", "BACKEND", "BACKENDS", "BACKUP", "BASE", "BASELINE", "BEGIN",
		"BETWEEN", "BIGINT", "BINARY", "BITMAP", "BITMAP_UNION", "BLACKHOLE",
		"BLACKLIST", "BODY", "BOOLEAN", "BOTH", "BRANCH", "BROKER", "BUCKETS",
		"BUILTIN", "BY", "CACHE", "CANCEL", "CASE", "CAST", "CATALOG", "CATALOGS",
		"CEIL", "CHAIN", "CHAR", "CHARACTER", "CHARSET", "CHECK", "CLEAN", "CLEAR",
		"CLUSTER", "CLUSTERS", "CNGROUP", "CNGROUPS", "COLLATE", "COLLATION",
		"COLUMN", "COLUMNS", "COMMENT", "COMMIT", "COMMITTED", "COMPACT", "COMPACTION",
		"COMPUTE", "CONFIG", "CONNECTION", "CONSISTENT", "CONVERT", "COSTS",
		"COUNT", "CREATE", "CROSS", "CUBE", "CUME_DIST", "CUMULATIVE", "CURRENT",
		"CURRENT_DATE", "CURRENT_GROUP", "CURRENT_ROLE", "CURRENT_TIME", "CURRENT_TIMESTAMP",
		"CURRENT_USER", "DATA", "DATACACHE", "DATABASE", "DATABASES", "DATE",
		"DATETIME", "DAY", "DAYS", "DEALLOCATE", "DECIMAL", "DECIMALV2", "DECIMAL32",
		"DECIMAL64", "DECIMAL128", "DECOMMISSION", "DEFAULT", "DELETE", "DENSE_RANK",
		"DEFERRED", "DIALECT", "DICTIONARY", "DICTIONARY_GET", "NTILE", "DESC",
		"DESCRIBE", "DISABLE", "DISTINCT", "DISTRIBUTED", "DISTRIBUTION", "DOUBLE",
		"DROP", "DUAL", "DUPLICATE", "DYNAMIC", "ELSE", "ENABLE", "ENCLOSE",
		"END", "ENGINE", "ENGINES", "ERRORS", "ESCAPE", "EVENTS", "EXCEPT",
		"EXCLUDE", "EXECUTE", "EXISTS", "EXPLAIN", "EXPORT", "EXTERNAL", "EXTRACT",
		"EVERY", "FAILPOINT", "FAILPOINTS", "FALSE", "FIELDS", "FILE", "FILES",
		"FILTER", "FIRST", "FIRST_VALUE", "FLOAT", "FLOOR", "FN", "FOLLOWING",
		"FOLLOWER", "FOR", "FORCE", "FORMAT", "FREE", "FROM", "FRONTEND", "FRONTENDS",
		"FULL", "FUNCTION", "FUNCTIONS", "GLOBAL", "GRANT", "GRANTS", "GROUP",
		"GROUPS", "GROUPING", "GROUPING_ID", "GROUP_CONCAT", "HASH", "HAVING",
		"HELP", "HISTOGRAM", "HLL", "HLL_UNION", "HOST", "HOUR", "HOURS", "HUB",
		"IDENTIFIED", "IF", "IMPERSONATE", "IMMEDIATE", "IGNORE", "IMAGE", "IN",
		"INACTIVE", "INCREMENTAL", "INDEX", "INDEXES", "INFILE", "INNER", "INSTALL",
		"INSERT", "INT", "INTEGER", "INTEGRATION", "INTEGRATIONS", "INTERMEDIATE",
		"INTERSECT", "INTERVAL", "INTO", "INVOKER", "GIN", "OVERWRITE", "IS",
		"ISOLATION", "JOB", "JOIN", "JSON", "KEY", "KEYS", "KILL", "LABEL",
		"LAG", "LARGEINT", "LAST", "LAST_VALUE", "LATERAL", "LEAD", "LEFT",
		"LESS", "LEVEL", "LIKE", "LIMIT", "LIST", "LOAD", "LOCAL", "LOCALTIME",
		"LOCALTIMESTAMP", "LOCATION", "LOCATIONS", "LOGS", "LOGICAL", "MANUAL",
		"MAP", "MAPPING", "MAPPINGS", "MASKING", "MATCH", "MATERIALIZED", "MAX",
		"MAXVALUE", "MERGE", "MICROSECOND", "MILLISECOND", "MIN", "MINUTE",
		"MINUTES", "MINUS", "META", "MOD", "MODE", "MODIFY", "MONTH", "MULTIPLE",
		"NAME", "NAMES", "NEGATIVE", "NGRAMBF", "NO", "NODE", "NODES", "NONE",
		"NOT", "NULL", "NULLS", "NUMBER", "NUMERIC", "OBSERVER", "OF", "OFF",
		"OFFSET", "ON", "ONLY", "OPEN", "OPERATE", "OPTIMIZE", "OPTIMIZER",
		"OPTION", "OR", "ORDER", "OUTER", "OUTFILE", "OVER", "PARAMETER", "PARTITION",
		"PARTITIONS", "PASSWORD", "PATH", "PAUSE", "PENDING", "PERCENT_RANK",
		"PERCENTILE", "PERCENTILE_UNION", "PLAN", "PLUGIN", "PLUGINS", "PIPE",
		"PIPES", "PIVOT", "POLICY", "POLICIES", "PRECEDING", "PREDICATE", "PREPARE",
		"PRIMARY", "PRIORITY", "PRIVILEGES", "PROBABILITY", "PROC", "PROCEDURE",
		"PROCESSLIST", "PROFILE", "PROFILELIST", "PROPERTIES", "PROPERTY", "PROVIDER",
		"PROVIDERS", "QUALIFY", "QUARTER", "QUERY", "QUERIES", "QUEUE", "QUOTA",
		"RANDOM", "RANGE", "RANK", "READ", "REASON", "RECOVER", "REFRESH", "REWRITE",
		"REGEXP", "RELEASE", "REMOVE", "RENAME", "REPAIR", "REPEATABLE", "REPLACE",
		"REPLACE_IF_NOT_NULL", "REPLICA", "REPOSITORY", "REPOSITORIES", "RESOURCE",
		"RESOURCES", "RESTORE", "RESUME", "RETAIN", "RETENTION", "RETURNS",
		"RETRY", "REVOKE", "REVERT", "RIGHT", "RLIKE", "ROLE", "ROLES", "ROLLBACK",
		"ROLLUP", "ROUTINE", "ROW", "ROWS", "ROW_NUMBER", "RULE", "RULES", "RUNNING",
		"SAMPLE", "SCHEDULE", "SCHEDULER", "SCHEMA", "SCHEMAS", "SECOND", "SECURITY",
		"SELECT", "SEMI", "SEPARATOR", "SERIALIZABLE", "SESSION", "SET", "SETS",
		"SET_VAR", "SIGNED", "SKIP_HEADER", "SHOW", "SMALLINT", "SNAPSHOT",
		"SNAPSHOTS", "SQLBLACKLIST", "START", "STATS", "STATUS", "STOP", "STORAGE",
		"STREAM", "STRING", "TEXT", "SUBMIT", "SUM", "SUSPEND", "SYNC", "SYSTEM",
		"SYSTEM_TIME", "SWAP", "STRUCT", "TABLE", "TABLES", "TABLET", "TABLETS",
		"TAG", "TASK", "TEMPORARY", "TERMINATED", "THAN", "THEN", "TIME", "TIMES",
		"TIMESTAMP", "TIMESTAMPADD", "TIMESTAMPDIFF", "TINYINT", "TRANSACTION",
		"TRANSLATE", "TO", "TRACE", "TRIGGERS", "TRIM_SPACE", "TRUE", "TRUNCATE",
		"TYPE", "TYPES", "UNBOUNDED", "UNCOMMITTED", "UNION", "UNIQUE", "UNINSTALL",
		"UNSET", "UNSIGNED", "UPDATE", "USAGE", "USE", "USER", "USERS", "USING",
		"VALUE", "VALUES", "VARBINARY", "VARCHAR", "VARIABLES", "VECTOR", "VERBOSE",
		"VERSION", "VIEW", "VIEWS", "VOLUME", "VOLUMES", "WAREHOUSE", "WAREHOUSES",
		"WARNINGS", "WEEK", "WHEN", "WHERE", "WHITELIST", "WITH", "WORK", "WRITE",
		"YEAR", "LOCK", "UNLOCK", "LOW_PRIORITY", "DISK", "BEFORE", "DOUBLE_DOLLAR",
		"FIELD", "PERSISTENT", "EQ", "NEQ", "LT", "LTE", "GT", "GTE", "EQ_FOR_NULL",
		"ARRAY_ELEMENT", "PLUS_SYMBOL", "MINUS_SYMBOL", "ASTERISK_SYMBOL", "SLASH_SYMBOL",
		"PERCENT_SYMBOL", "LOGICAL_OR", "LOGICAL_AND", "LOGICAL_NOT", "INT_DIV",
		"BITAND", "BITOR", "BITXOR", "BITNOT", "BIT_SHIFT_LEFT", "BIT_SHIFT_RIGHT",
		"BIT_SHIFT_RIGHT_LOGICAL", "ARROW", "AT", "INTEGER_VALUE", "DECIMAL_VALUE",
		"DOUBLE_VALUE", "SINGLE_QUOTED_TEXT", "DOUBLE_QUOTED_TEXT", "BINARY_SINGLE_QUOTED_TEXT",
		"BINARY_DOUBLE_QUOTED_TEXT", "LETTER_IDENTIFIER", "DIGIT_IDENTIFIER",
		"BACKQUOTED_IDENTIFIER", "DOT_IDENTIFIER", "SIMPLE_COMMENT", "BRACKETED_COMMENT",
		"OPTIMIZER_HINT", "SEMICOLON", "DOTDOTDOT", "WS", "ATTACHMENT", "CONCAT",
	}
	staticData.RuleNames = []string{
		"sqlStatements", "singleStatement", "emptyStatement", "statement", "useDatabaseStatement",
		"useCatalogStatement", "setCatalogStatement", "showDatabasesStatement",
		"alterDbQuotaStatement", "createDbStatement", "dropDbStatement", "showCreateDbStatement",
		"alterDatabaseRenameStatement", "recoverDbStmt", "showDataStmt", "showDataDistributionStmt",
		"createTableStatement", "columnDesc", "charsetName", "defaultDesc",
		"generatedColumnDesc", "indexDesc", "engineDesc", "charsetDesc", "collateDesc",
		"keyDesc", "orderByDesc", "columnNullable", "typeWithNullable", "aggStateDesc",
		"aggDesc", "rollupDesc", "rollupItem", "dupKeys", "fromRollup", "orReplace",
		"ifNotExists", "createTableAsSelectStatement", "dropTableStatement",
		"cleanTemporaryTableStatement", "alterTableStatement", "createIndexStatement",
		"dropIndexStatement", "indexType", "showTableStatement", "showTemporaryTablesStatement",
		"showCreateTableStatement", "showColumnStatement", "showTableStatusStatement",
		"refreshTableStatement", "showAlterStatement", "descTableStatement",
		"createTableLikeStatement", "showIndexStatement", "recoverTableStatement",
		"truncateTableStatement", "cancelAlterTableStatement", "showPartitionsStatement",
		"recoverPartitionStatement", "createViewStatement", "alterViewStatement",
		"dropViewStatement", "columnNameWithComment", "submitTaskStatement",
		"taskClause", "dropTaskStatement", "taskScheduleDesc", "createMaterializedViewStatement",
		"mvPartitionExprs", "materializedViewDesc", "showMaterializedViewsStatement",
		"dropMaterializedViewStatement", "alterMaterializedViewStatement", "refreshMaterializedViewStatement",
		"cancelRefreshMaterializedViewStatement", "adminSetConfigStatement",
		"adminSetReplicaStatusStatement", "adminShowConfigStatement", "adminShowReplicaDistributionStatement",
		"adminShowReplicaStatusStatement", "adminRepairTableStatement", "adminCancelRepairTableStatement",
		"adminCheckTabletsStatement", "adminSetPartitionVersion", "killStatement",
		"syncStatement", "adminSetAutomatedSnapshotOnStatement", "adminSetAutomatedSnapshotOffStatement",
		"alterSystemStatement", "cancelAlterSystemStatement", "showComputeNodesStatement",
		"createExternalCatalogStatement", "showCreateExternalCatalogStatement",
		"dropExternalCatalogStatement", "showCatalogsStatement", "alterCatalogStatement",
		"createStorageVolumeStatement", "typeDesc", "locationsDesc", "showStorageVolumesStatement",
		"dropStorageVolumeStatement", "alterStorageVolumeStatement", "alterStorageVolumeClause",
		"modifyStorageVolumePropertiesClause", "modifyStorageVolumeCommentClause",
		"descStorageVolumeStatement", "setDefaultStorageVolumeStatement", "updateFailPointStatusStatement",
		"showFailPointStatement", "createDictionaryStatement", "dropDictionaryStatement",
		"refreshDictionaryStatement", "showDictionaryStatement", "cancelRefreshDictionaryStatement",
		"dictionaryColumnDesc", "dictionaryName", "alterClause", "addFrontendClause",
		"dropFrontendClause", "modifyFrontendHostClause", "addBackendClause",
		"dropBackendClause", "decommissionBackendClause", "modifyBackendClause",
		"addComputeNodeClause", "dropComputeNodeClause", "modifyBrokerClause",
		"alterLoadErrorUrlClause", "createImageClause", "cleanTabletSchedQClause",
		"decommissionDiskClause", "cancelDecommissionDiskClause", "disableDiskClause",
		"cancelDisableDiskClause", "createIndexClause", "dropIndexClause", "tableRenameClause",
		"swapTableClause", "modifyPropertiesClause", "modifyCommentClause",
		"optimizeRange", "optimizeClause", "addColumnClause", "addColumnsClause",
		"dropColumnClause", "modifyColumnClause", "modifyColumnCommentClause",
		"columnRenameClause", "reorderColumnsClause", "rollupRenameClause",
		"compactionClause", "subfieldName", "nestedFieldName", "addFieldClause",
		"dropFieldClause", "createOrReplaceTagClause", "createOrReplaceBranchClause",
		"dropBranchClause", "dropTagClause", "tableOperationClause", "tagOptions",
		"branchOptions", "snapshotRetention", "refRetain", "maxSnapshotAge",
		"minSnapshotsToKeep", "snapshotId", "timeUnit", "integer_list", "dropPersistentIndexClause",
		"addPartitionClause", "dropPartitionClause", "truncatePartitionClause",
		"modifyPartitionClause", "replacePartitionClause", "partitionRenameClause",
		"insertStatement", "insertLabelOrColumnAliases", "columnAliasesOrByName",
		"updateStatement", "deleteStatement", "createRoutineLoadStatement",
		"alterRoutineLoadStatement", "dataSource", "loadProperties", "colSeparatorProperty",
		"rowDelimiterProperty", "importColumns", "columnProperties", "jobProperties",
		"dataSourceProperties", "stopRoutineLoadStatement", "resumeRoutineLoadStatement",
		"pauseRoutineLoadStatement", "showRoutineLoadStatement", "showRoutineLoadTaskStatement",
		"showCreateRoutineLoadStatement", "showStreamLoadStatement", "analyzeStatement",
		"analyzeColumnClause", "dropStatsStatement", "histogramStatement", "analyzeHistogramStatement",
		"dropHistogramStatement", "createAnalyzeStatement", "dropAnalyzeJobStatement",
		"showAnalyzeStatement", "showStatsMetaStatement", "showHistogramMetaStatement",
		"killAnalyzeStatement", "analyzeProfileStatement", "createBaselinePlanStatement",
		"dropBaselinePlanStatement", "showBaselinePlanStatement", "createResourceGroupStatement",
		"dropResourceGroupStatement", "alterResourceGroupStatement", "showResourceGroupStatement",
		"showResourceGroupUsageStatement", "createResourceStatement", "alterResourceStatement",
		"dropResourceStatement", "showResourceStatement", "classifier", "showFunctionsStatement",
		"dropFunctionStatement", "createFunctionStatement", "inlineFunction",
		"typeList", "loadStatement", "labelName", "dataDescList", "dataDesc",
		"formatProps", "brokerDesc", "resourceDesc", "showLoadStatement", "showLoadWarningsStatement",
		"cancelLoadStatement", "alterLoadStatement", "cancelCompactionStatement",
		"showAuthorStatement", "showBackendsStatement", "showBrokerStatement",
		"showCharsetStatement", "showCollationStatement", "showDeleteStatement",
		"showDynamicPartitionStatement", "showEventsStatement", "showEnginesStatement",
		"showFrontendsStatement", "showPluginsStatement", "showRepositoriesStatement",
		"showOpenTableStatement", "showPrivilegesStatement", "showProcedureStatement",
		"showProcStatement", "showProcesslistStatement", "showProfilelistStatement",
		"showRunningQueriesStatement", "showStatusStatement", "showTabletStatement",
		"showTransactionStatement", "showTriggersStatement", "showUserPropertyStatement",
		"showVariablesStatement", "showWarningStatement", "helpStatement", "createUserStatement",
		"dropUserStatement", "alterUserStatement", "showUserStatement", "showAuthenticationStatement",
		"executeAsStatement", "createRoleStatement", "alterRoleStatement", "dropRoleStatement",
		"showRolesStatement", "grantRoleStatement", "revokeRoleStatement", "setRoleStatement",
		"setDefaultRoleStatement", "grantRevokeClause", "grantPrivilegeStatement",
		"revokePrivilegeStatement", "showGrantsStatement", "authOption", "privObjectName",
		"privObjectNameList", "privFunctionObjectNameList", "privilegeTypeList",
		"privilegeType", "privObjectType", "privObjectTypePlural", "createSecurityIntegrationStatement",
		"alterSecurityIntegrationStatement", "dropSecurityIntegrationStatement",
		"showSecurityIntegrationStatement", "showCreateSecurityIntegrationStatement",
		"createGroupProviderStatement", "dropGroupProviderStatement", "showGroupProvidersStatement",
		"showCreateGroupProviderStatement", "backupStatement", "cancelBackupStatement",
		"showBackupStatement", "restoreStatement", "cancelRestoreStatement",
		"showRestoreStatement", "showSnapshotStatement", "createRepositoryStatement",
		"dropRepositoryStatement", "addSqlBlackListStatement", "delSqlBlackListStatement",
		"showSqlBlackListStatement", "showWhiteListStatement", "addBackendBlackListStatement",
		"delBackendBlackListStatement", "showBackendBlackListStatement", "dataCacheTarget",
		"createDataCacheRuleStatement", "showDataCacheRulesStatement", "dropDataCacheRuleStatement",
		"clearDataCacheRulesStatement", "dataCacheSelectStatement", "exportStatement",
		"cancelExportStatement", "showExportStatement", "installPluginStatement",
		"uninstallPluginStatement", "createFileStatement", "dropFileStatement",
		"showSmallFilesStatement", "createPipeStatement", "dropPipeStatement",
		"alterPipeClause", "alterPipeStatement", "descPipeStatement", "showPipeStatement",
		"setStatement", "setVar", "transaction_characteristics", "transaction_access_mode",
		"isolation_level", "isolation_types", "setExprOrDefault", "setUserPropertyStatement",
		"roleList", "executeScriptStatement", "unsupportedStatement", "lock_item",
		"lock_type", "alterPlanAdvisorAddStatement", "truncatePlanAdvisorStatement",
		"alterPlanAdvisorDropStatement", "showPlanAdvisorStatement", "createWarehouseStatement",
		"dropWarehouseStatement", "suspendWarehouseStatement", "resumeWarehouseStatement",
		"setWarehouseStatement", "showWarehousesStatement", "showClustersStatement",
		"showNodesStatement", "alterWarehouseStatement", "createCNGroupStatement",
		"dropCNGroupStatement", "enableCNGroupStatement", "disableCNGroupStatement",
		"alterCNGroupStatement", "beginStatement", "commitStatement", "rollbackStatement",
		"translateStatement", "dialect", "translateSQL", "queryStatement", "queryRelation",
		"withClause", "queryNoWith", "queryPeriod", "periodType", "queryPrimary",
		"subquery", "rowConstructor", "sortItem", "limitConstExpr", "limitElement",
		"querySpecification", "fromClause", "groupingElement", "groupingSet",
		"commonTableExpression", "setQuantifier", "selectItem", "excludeClause",
		"relations", "relation", "relationPrimary", "pivotClause", "pivotAggregationExpression",
		"pivotValue", "sampleClause", "argumentList", "namedArgumentList", "namedArgument",
		"joinRelation", "crossOrInnerJoinType", "outerAndSemiJoinType", "bracketHint",
		"hintMap", "joinCriteria", "columnAliases", "partitionNames", "keyPartitions",
		"tabletList", "prepareStatement", "prepareSql", "executeStatement",
		"deallocateStatement", "replicaList", "expressionsWithDefault", "expressionOrDefault",
		"mapExpressionList", "mapExpression", "expressionSingleton", "expression",
		"expressionList", "booleanExpression", "predicate", "tupleInSubquery",
		"predicateOperations", "valueExpression", "primaryExpression", "literalExpression",
		"functionCall", "aggregationFunction", "userVariable", "systemVariable",
		"columnReference", "informationFunctionExpression", "specialDateTimeExpression",
		"specialFunctionExpression", "windowFunction", "whenClause", "over",
		"ignoreNulls", "windowFrame", "frameBound", "backupRestoreObjectDesc",
		"tableDesc", "backupRestoreTableDesc", "explainDesc", "optimizerTrace",
		"partitionExpr", "partitionDesc", "listPartitionDesc", "singleItemListPartitionDesc",
		"multiItemListPartitionDesc", "multiListPartitionValues", "singleListPartitionValues",
		"listPartitionValues", "listPartitionValue", "stringList", "literalExpressionList",
		"rangePartitionDesc", "singleRangePartition", "multiRangePartition",
		"partitionRangeDesc", "partitionKeyDesc", "partitionValueList", "keyPartition",
		"partitionValue", "distributionClause", "distributionDesc", "refreshSchemeDesc",
		"statusDesc", "properties", "extProperties", "propertyList", "userPropertyList",
		"property", "inlineProperties", "inlineProperty", "varType", "comment",
		"outfile", "fileFormat", "string", "binary", "comparisonOperator", "booleanValue",
		"interval", "taskInterval", "taskUnitIdentifier", "unitIdentifier",
		"unitBoundary", "type", "arrayType", "mapType", "subfieldDesc", "subfieldDescs",
		"structType", "typeParameter", "baseType", "decimalType", "qualifiedName",
		"tableName", "writeBranch", "identifier", "identifierWithAlias", "identifierWithAliasList",
		"identifierList", "identifierOrString", "identifierOrStringList", "identifierOrStringOrStar",
		"user", "assignment", "assignmentList", "number", "nonReserved",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 536, 8213, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7,
		198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2,
		203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7,
		207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2,
		212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7,
		216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2,
		221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7,
		225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2,
		230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7,
		234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2,
		239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 2, 243, 7,
		243, 2, 244, 7, 244, 2, 245, 7, 245, 2, 246, 7, 246, 2, 247, 7, 247, 2,
		248, 7, 248, 2, 249, 7, 249, 2, 250, 7, 250, 2, 251, 7, 251, 2, 252, 7,
		252, 2, 253, 7, 253, 2, 254, 7, 254, 2, 255, 7, 255, 2, 256, 7, 256, 2,
		257, 7, 257, 2, 258, 7, 258, 2, 259, 7, 259, 2, 260, 7, 260, 2, 261, 7,
		261, 2, 262, 7, 262, 2, 263, 7, 263, 2, 264, 7, 264, 2, 265, 7, 265, 2,
		266, 7, 266, 2, 267, 7, 267, 2, 268, 7, 268, 2, 269, 7, 269, 2, 270, 7,
		270, 2, 271, 7, 271, 2, 272, 7, 272, 2, 273, 7, 273, 2, 274, 7, 274, 2,
		275, 7, 275, 2, 276, 7, 276, 2, 277, 7, 277, 2, 278, 7, 278, 2, 279, 7,
		279, 2, 280, 7, 280, 2, 281, 7, 281, 2, 282, 7, 282, 2, 283, 7, 283, 2,
		284, 7, 284, 2, 285, 7, 285, 2, 286, 7, 286, 2, 287, 7, 287, 2, 288, 7,
		288, 2, 289, 7, 289, 2, 290, 7, 290, 2, 291, 7, 291, 2, 292, 7, 292, 2,
		293, 7, 293, 2, 294, 7, 294, 2, 295, 7, 295, 2, 296, 7, 296, 2, 297, 7,
		297, 2, 298, 7, 298, 2, 299, 7, 299, 2, 300, 7, 300, 2, 301, 7, 301, 2,
		302, 7, 302, 2, 303, 7, 303, 2, 304, 7, 304, 2, 305, 7, 305, 2, 306, 7,
		306, 2, 307, 7, 307, 2, 308, 7, 308, 2, 309, 7, 309, 2, 310, 7, 310, 2,
		311, 7, 311, 2, 312, 7, 312, 2, 313, 7, 313, 2, 314, 7, 314, 2, 315, 7,
		315, 2, 316, 7, 316, 2, 317, 7, 317, 2, 318, 7, 318, 2, 319, 7, 319, 2,
		320, 7, 320, 2, 321, 7, 321, 2, 322, 7, 322, 2, 323, 7, 323, 2, 324, 7,
		324, 2, 325, 7, 325, 2, 326, 7, 326, 2, 327, 7, 327, 2, 328, 7, 328, 2,
		329, 7, 329, 2, 330, 7, 330, 2, 331, 7, 331, 2, 332, 7, 332, 2, 333, 7,
		333, 2, 334, 7, 334, 2, 335, 7, 335, 2, 336, 7, 336, 2, 337, 7, 337, 2,
		338, 7, 338, 2, 339, 7, 339, 2, 340, 7, 340, 2, 341, 7, 341, 2, 342, 7,
		342, 2, 343, 7, 343, 2, 344, 7, 344, 2, 345, 7, 345, 2, 346, 7, 346, 2,
		347, 7, 347, 2, 348, 7, 348, 2, 349, 7, 349, 2, 350, 7, 350, 2, 351, 7,
		351, 2, 352, 7, 352, 2, 353, 7, 353, 2, 354, 7, 354, 2, 355, 7, 355, 2,
		356, 7, 356, 2, 357, 7, 357, 2, 358, 7, 358, 2, 359, 7, 359, 2, 360, 7,
		360, 2, 361, 7, 361, 2, 362, 7, 362, 2, 363, 7, 363, 2, 364, 7, 364, 2,
		365, 7, 365, 2, 366, 7, 366, 2, 367, 7, 367, 2, 368, 7, 368, 2, 369, 7,
		369, 2, 370, 7, 370, 2, 371, 7, 371, 2, 372, 7, 372, 2, 373, 7, 373, 2,
		374, 7, 374, 2, 375, 7, 375, 2, 376, 7, 376, 2, 377, 7, 377, 2, 378, 7,
		378, 2, 379, 7, 379, 2, 380, 7, 380, 2, 381, 7, 381, 2, 382, 7, 382, 2,
		383, 7, 383, 2, 384, 7, 384, 2, 385, 7, 385, 2, 386, 7, 386, 2, 387, 7,
		387, 2, 388, 7, 388, 2, 389, 7, 389, 2, 390, 7, 390, 2, 391, 7, 391, 2,
		392, 7, 392, 2, 393, 7, 393, 2, 394, 7, 394, 2, 395, 7, 395, 2, 396, 7,
		396, 2, 397, 7, 397, 2, 398, 7, 398, 2, 399, 7, 399, 2, 400, 7, 400, 2,
		401, 7, 401, 2, 402, 7, 402, 2, 403, 7, 403, 2, 404, 7, 404, 2, 405, 7,
		405, 2, 406, 7, 406, 2, 407, 7, 407, 2, 408, 7, 408, 2, 409, 7, 409, 2,
		410, 7, 410, 2, 411, 7, 411, 2, 412, 7, 412, 2, 413, 7, 413, 2, 414, 7,
		414, 2, 415, 7, 415, 2, 416, 7, 416, 2, 417, 7, 417, 2, 418, 7, 418, 2,
		419, 7, 419, 2, 420, 7, 420, 2, 421, 7, 421, 2, 422, 7, 422, 2, 423, 7,
		423, 2, 424, 7, 424, 2, 425, 7, 425, 2, 426, 7, 426, 2, 427, 7, 427, 2,
		428, 7, 428, 2, 429, 7, 429, 2, 430, 7, 430, 2, 431, 7, 431, 2, 432, 7,
		432, 2, 433, 7, 433, 2, 434, 7, 434, 2, 435, 7, 435, 2, 436, 7, 436, 2,
		437, 7, 437, 2, 438, 7, 438, 2, 439, 7, 439, 2, 440, 7, 440, 2, 441, 7,
		441, 2, 442, 7, 442, 2, 443, 7, 443, 2, 444, 7, 444, 2, 445, 7, 445, 2,
		446, 7, 446, 2, 447, 7, 447, 2, 448, 7, 448, 2, 449, 7, 449, 2, 450, 7,
		450, 2, 451, 7, 451, 2, 452, 7, 452, 2, 453, 7, 453, 2, 454, 7, 454, 2,
		455, 7, 455, 2, 456, 7, 456, 2, 457, 7, 457, 2, 458, 7, 458, 2, 459, 7,
		459, 2, 460, 7, 460, 2, 461, 7, 461, 2, 462, 7, 462, 2, 463, 7, 463, 2,
		464, 7, 464, 2, 465, 7, 465, 2, 466, 7, 466, 2, 467, 7, 467, 2, 468, 7,
		468, 2, 469, 7, 469, 2, 470, 7, 470, 2, 471, 7, 471, 2, 472, 7, 472, 2,
		473, 7, 473, 2, 474, 7, 474, 2, 475, 7, 475, 2, 476, 7, 476, 2, 477, 7,
		477, 2, 478, 7, 478, 2, 479, 7, 479, 2, 480, 7, 480, 2, 481, 7, 481, 2,
		482, 7, 482, 2, 483, 7, 483, 2, 484, 7, 484, 2, 485, 7, 485, 2, 486, 7,
		486, 2, 487, 7, 487, 2, 488, 7, 488, 2, 489, 7, 489, 2, 490, 7, 490, 2,
		491, 7, 491, 2, 492, 7, 492, 2, 493, 7, 493, 2, 494, 7, 494, 2, 495, 7,
		495, 2, 496, 7, 496, 2, 497, 7, 497, 2, 498, 7, 498, 2, 499, 7, 499, 2,
		500, 7, 500, 2, 501, 7, 501, 2, 502, 7, 502, 2, 503, 7, 503, 2, 504, 7,
		504, 2, 505, 7, 505, 2, 506, 7, 506, 2, 507, 7, 507, 2, 508, 7, 508, 2,
		509, 7, 509, 2, 510, 7, 510, 2, 511, 7, 511, 2, 512, 7, 512, 2, 513, 7,
		513, 2, 514, 7, 514, 2, 515, 7, 515, 2, 516, 7, 516, 2, 517, 7, 517, 2,
		518, 7, 518, 2, 519, 7, 519, 2, 520, 7, 520, 1, 0, 4, 0, 1044, 8, 0, 11,
		0, 12, 0, 1045, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1054, 8, 1, 1,
		2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 3, 3, 1298, 8, 3, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 1314, 8, 7, 1, 7, 1, 7, 1,
		7, 1, 7, 3, 7, 1320, 8, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 1328,
		8, 7, 3, 7, 1330, 8, 7, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 1348, 8, 8, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1355, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1360,
		8, 9, 1, 9, 1, 9, 3, 9, 1364, 8, 9, 1, 9, 3, 9, 1367, 8, 9, 1, 9, 3, 9,
		1370, 8, 9, 1, 10, 1, 10, 1, 10, 1, 10, 3, 10, 1376, 8, 10, 1, 10, 1, 10,
		1, 10, 3, 10, 1381, 8, 10, 1, 10, 1, 10, 3, 10, 1385, 8, 10, 1, 11, 1,
		11, 1, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13,
		1, 13, 1, 13, 1, 13, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 1408,
		8, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 1416, 8, 15, 1,
		16, 1, 16, 3, 16, 1420, 8, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 1426,
		8, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 5, 16, 1433, 8, 16, 10, 16, 12,
		16, 1436, 9, 16, 1, 16, 1, 16, 5, 16, 1440, 8, 16, 10, 16, 12, 16, 1443,
		9, 16, 1, 16, 1, 16, 3, 16, 1447, 8, 16, 1, 16, 3, 16, 1450, 8, 16, 1,
		16, 3, 16, 1453, 8, 16, 1, 16, 3, 16, 1456, 8, 16, 1, 16, 3, 16, 1459,
		8, 16, 1, 16, 3, 16, 1462, 8, 16, 1, 16, 3, 16, 1465, 8, 16, 1, 16, 3,
		16, 1468, 8, 16, 1, 16, 3, 16, 1471, 8, 16, 1, 16, 3, 16, 1474, 8, 16,
		1, 17, 1, 17, 3, 17, 1478, 8, 17, 1, 17, 3, 17, 1481, 8, 17, 1, 17, 3,
		17, 1484, 8, 17, 1, 17, 3, 17, 1487, 8, 17, 1, 17, 3, 17, 1490, 8, 17,
		1, 17, 1, 17, 1, 17, 3, 17, 1495, 8, 17, 1, 17, 3, 17, 1498, 8, 17, 1,
		18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 1508, 8, 18,
		1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3,
		19, 1520, 8, 19, 1, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21,
		3, 21, 1530, 8, 21, 3, 21, 1532, 8, 21, 1, 21, 3, 21, 1535, 8, 21, 1, 22,
		1, 22, 1, 22, 1, 22, 1, 23, 3, 23, 1542, 8, 23, 1, 23, 1, 23, 1, 23, 1,
		23, 1, 23, 3, 23, 1549, 8, 23, 1, 23, 3, 23, 1552, 8, 23, 1, 23, 1, 23,
		1, 24, 3, 24, 1557, 8, 24, 1, 24, 1, 24, 3, 24, 1561, 8, 24, 1, 24, 1,
		24, 1, 25, 1, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27,
		1, 27, 3, 27, 1576, 8, 27, 1, 28, 1, 28, 3, 28, 1580, 8, 28, 1, 29, 1,
		29, 1, 29, 1, 29, 1, 29, 5, 29, 1587, 8, 29, 10, 29, 12, 29, 1590, 9, 29,
		1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 3, 30, 1603, 8, 30, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 5, 31, 1610,
		8, 31, 10, 31, 12, 31, 1613, 9, 31, 1, 31, 1, 31, 1, 32, 1, 32, 1, 32,
		3, 32, 1620, 8, 32, 1, 32, 3, 32, 1623, 8, 32, 1, 32, 3, 32, 1626, 8, 32,
		1, 33, 1, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35, 3, 35, 1637,
		8, 35, 1, 36, 1, 36, 1, 36, 3, 36, 1642, 8, 36, 1, 37, 1, 37, 3, 37, 1646,
		8, 37, 1, 37, 1, 37, 1, 37, 1, 37, 3, 37, 1652, 8, 37, 1, 37, 1, 37, 1,
		37, 1, 37, 1, 37, 5, 37, 1659, 8, 37, 10, 37, 12, 37, 1662, 9, 37, 1, 37,
		1, 37, 5, 37, 1666, 8, 37, 10, 37, 12, 37, 1669, 9, 37, 1, 37, 1, 37, 1,
		37, 5, 37, 1674, 8, 37, 10, 37, 12, 37, 1677, 9, 37, 3, 37, 1679, 8, 37,
		1, 37, 1, 37, 3, 37, 1683, 8, 37, 1, 37, 3, 37, 1686, 8, 37, 1, 37, 3,
		37, 1689, 8, 37, 1, 37, 3, 37, 1692, 8, 37, 1, 37, 3, 37, 1695, 8, 37,
		1, 37, 3, 37, 1698, 8, 37, 1, 37, 3, 37, 1701, 8, 37, 1, 37, 1, 37, 1,
		37, 1, 38, 1, 38, 3, 38, 1708, 8, 38, 1, 38, 1, 38, 1, 38, 3, 38, 1713,
		8, 38, 1, 38, 1, 38, 3, 38, 1717, 8, 38, 1, 39, 1, 39, 1, 39, 1, 39, 1,
		39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 5, 40, 1732,
		8, 40, 10, 40, 12, 40, 1735, 9, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40,
		1, 40, 1, 40, 1, 40, 5, 40, 1745, 8, 40, 10, 40, 12, 40, 1748, 9, 40, 1,
		40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 5, 40, 1758, 8, 40,
		10, 40, 12, 40, 1761, 9, 40, 3, 40, 1763, 8, 40, 1, 41, 1, 41, 1, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 1773, 8, 41, 3, 41, 1775, 8, 41,
		1, 41, 3, 41, 1778, 8, 41, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1,
		43, 1, 43, 1, 43, 1, 44, 1, 44, 3, 44, 1791, 8, 44, 1, 44, 1, 44, 1, 44,
		3, 44, 1796, 8, 44, 1, 44, 1, 44, 1, 44, 1, 44, 3, 44, 1802, 8, 44, 1,
		45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 1809, 8, 45, 1, 45, 1, 45, 1, 45,
		1, 45, 3, 45, 1815, 8, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3,
		46, 1823, 8, 46, 1, 46, 1, 46, 1, 47, 1, 47, 3, 47, 1829, 8, 47, 1, 47,
		1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 1837, 8, 47, 1, 47, 1, 47, 1,
		47, 1, 47, 3, 47, 1843, 8, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48,
		1850, 8, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 1856, 8, 48, 1, 49, 1,
		49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 5, 49, 1867, 8, 49,
		10, 49, 12, 49, 1870, 9, 49, 1, 49, 1, 49, 3, 49, 1874, 8, 49, 1, 50, 1,
		50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 1882, 8, 50, 1, 50, 1, 50, 3, 50,
		1886, 8, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 5, 50, 1893, 8, 50, 10,
		50, 12, 50, 1896, 9, 50, 3, 50, 1898, 8, 50, 1, 50, 3, 50, 1901, 8, 50,
		1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 1909, 8, 50, 1, 50, 1,
		50, 3, 50, 1913, 8, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 5, 50, 1920,
		8, 50, 10, 50, 12, 50, 1923, 9, 50, 3, 50, 1925, 8, 50, 1, 50, 3, 50, 1928,
		8, 50, 3, 50, 1930, 8, 50, 1, 51, 1, 51, 1, 51, 3, 51, 1935, 8, 51, 1,
		51, 1, 51, 3, 51, 1939, 8, 51, 1, 52, 1, 52, 3, 52, 1943, 8, 52, 1, 52,
		1, 52, 1, 52, 1, 52, 3, 52, 1949, 8, 52, 1, 52, 1, 52, 3, 52, 1953, 8,
		52, 1, 52, 3, 52, 1956, 8, 52, 1, 52, 3, 52, 1959, 8, 52, 1, 52, 1, 52,
		1, 52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1971, 8,
		53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 1981,
		8, 55, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 1987, 8, 56, 1, 56, 1, 56, 1,
		56, 1, 56, 1, 56, 1, 56, 5, 56, 1995, 8, 56, 10, 56, 12, 56, 1998, 9, 56,
		1, 56, 3, 56, 2001, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3,
		56, 2009, 8, 56, 1, 57, 1, 57, 3, 57, 2013, 8, 57, 1, 57, 1, 57, 1, 57,
		1, 57, 1, 57, 3, 57, 2020, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 5,
		57, 2027, 8, 57, 10, 57, 12, 57, 2030, 9, 57, 3, 57, 2032, 8, 57, 1, 57,
		3, 57, 2035, 8, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 59, 1,
		59, 1, 59, 3, 59, 2046, 8, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 2052,
		8, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 2059, 8, 59, 10, 59, 12,
		59, 2062, 9, 59, 1, 59, 1, 59, 3, 59, 2066, 8, 59, 1, 59, 3, 59, 2069,
		8, 59, 1, 59, 1, 59, 3, 59, 2073, 8, 59, 1, 59, 1, 59, 1, 59, 1, 60, 1,
		60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 5, 60, 2085, 8, 60, 10, 60, 12,
		60, 2088, 9, 60, 1, 60, 1, 60, 3, 60, 2092, 8, 60, 1, 60, 1, 60, 1, 60,
		1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1,
		60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60,
		2117, 8, 60, 1, 61, 1, 61, 1, 61, 1, 61, 3, 61, 2123, 8, 61, 1, 61, 1,
		61, 1, 62, 1, 62, 3, 62, 2129, 8, 62, 1, 63, 1, 63, 1, 63, 3, 63, 2134,
		8, 63, 1, 63, 5, 63, 2137, 8, 63, 10, 63, 12, 63, 2140, 9, 63, 1, 63, 1,
		63, 1, 63, 1, 63, 3, 63, 2146, 8, 63, 1, 64, 1, 64, 3, 64, 2150, 8, 64,
		1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 2156, 8, 65, 1, 66, 1, 66, 1, 66, 1,
		66, 1, 66, 1, 66, 3, 66, 2164, 8, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66,
		1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 3, 67, 2177, 8, 67, 1, 67, 1,
		67, 1, 67, 1, 67, 1, 67, 5, 67, 2184, 8, 67, 10, 67, 12, 67, 2187, 9, 67,
		1, 67, 1, 67, 5, 67, 2191, 8, 67, 10, 67, 12, 67, 2194, 9, 67, 1, 67, 1,
		67, 3, 67, 2198, 8, 67, 1, 67, 3, 67, 2201, 8, 67, 1, 67, 5, 67, 2204,
		8, 67, 10, 67, 12, 67, 2207, 9, 67, 1, 67, 1, 67, 1, 67, 1, 68, 1, 68,
		1, 68, 1, 68, 1, 68, 5, 68, 2217, 8, 68, 10, 68, 12, 68, 2220, 9, 68, 1,
		68, 1, 68, 3, 68, 2224, 8, 68, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69,
		1, 69, 3, 69, 2233, 8, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 2240,
		8, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 2246, 8, 70, 1, 71, 1, 71, 1,
		71, 1, 71, 1, 71, 3, 71, 2253, 8, 71, 1, 71, 1, 71, 1, 72, 1, 72, 1, 72,
		1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 2265, 8, 72, 1, 72, 1, 72, 1,
		72, 1, 72, 1, 72, 1, 72, 3, 72, 2273, 8, 72, 1, 73, 1, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 1, 73, 3, 73, 2282, 8, 73, 3, 73, 2284, 8, 73, 1, 73, 3,
		73, 2287, 8, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2292, 8, 73, 1, 73, 1, 73,
		1, 73, 3, 73, 2297, 8, 73, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3,
		74, 2305, 8, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75,
		1, 75, 3, 75, 2316, 8, 75, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1,
		77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 2330, 8, 77, 1, 78, 1, 78,
		1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 2339, 8, 78, 1, 79, 1, 79, 1,
		79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 2348, 8, 79, 1, 79, 1, 79, 3, 79,
		2352, 8, 79, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 3, 80, 2359, 8, 80, 1,
		81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 3, 81, 2367, 8, 81, 1, 82, 1, 82,
		1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 83, 1, 83, 1, 83, 1, 83, 1,
		83, 1, 83, 1, 83, 1, 83, 3, 83, 2385, 8, 83, 1, 83, 1, 83, 1, 83, 1, 83,
		1, 83, 1, 84, 1, 84, 3, 84, 2394, 8, 84, 1, 84, 3, 84, 2397, 8, 84, 1,
		84, 1, 84, 3, 84, 2401, 8, 84, 1, 85, 1, 85, 1, 86, 1, 86, 1, 86, 1, 86,
		1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 3, 86, 2414, 8, 86, 1, 87, 1, 87, 1,
		87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 1, 88, 1, 89, 1, 89,
		1, 89, 1, 89, 1, 89, 1, 89, 5, 89, 2433, 8, 89, 10, 89, 12, 89, 2436, 9,
		89, 1, 90, 1, 90, 1, 90, 1, 90, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91,
		3, 91, 2448, 8, 91, 1, 91, 1, 91, 3, 91, 2452, 8, 91, 1, 91, 1, 91, 1,
		92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 93, 1, 93, 1, 93, 1, 93, 3, 93, 2465,
		8, 93, 1, 93, 1, 93, 1, 94, 1, 94, 1, 94, 1, 94, 3, 94, 2473, 8, 94, 1,
		95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96,
		3, 96, 2486, 8, 96, 1, 96, 1, 96, 1, 96, 1, 96, 3, 96, 2492, 8, 96, 1,
		96, 3, 96, 2495, 8, 96, 1, 97, 1, 97, 1, 97, 1, 97, 1, 98, 1, 98, 1, 98,
		1, 98, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 3, 99, 2510, 8, 99, 1, 100, 1,
		100, 1, 100, 1, 100, 1, 100, 3, 100, 2517, 8, 100, 1, 100, 1, 100, 1, 101,
		1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 5, 101, 2528, 8, 101, 10,
		101, 12, 101, 2531, 9, 101, 1, 102, 1, 102, 3, 102, 2535, 8, 102, 1, 103,
		1, 103, 1, 103, 1, 104, 1, 104, 1, 104, 1, 104, 1, 105, 1, 105, 1, 105,
		1, 105, 1, 105, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106,
		1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107,
		3, 107, 2565, 8, 107, 3, 107, 2567, 8, 107, 1, 107, 1, 107, 1, 107, 1,
		107, 3, 107, 2573, 8, 107, 3, 107, 2575, 8, 107, 1, 108, 1, 108, 1, 108,
		1, 108, 3, 108, 2581, 8, 108, 1, 108, 1, 108, 1, 108, 3, 108, 2586, 8,
		108, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1,
		109, 5, 109, 2597, 8, 109, 10, 109, 12, 109, 2600, 9, 109, 1, 109, 1, 109,
		3, 109, 2604, 8, 109, 1, 110, 1, 110, 1, 110, 1, 110, 3, 110, 2610, 8,
		110, 1, 111, 1, 111, 1, 111, 1, 111, 1, 112, 1, 112, 1, 112, 3, 112, 2619,
		8, 112, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 114, 1, 114, 1, 114,
		1, 114, 1, 114, 1, 114, 3, 114, 2632, 8, 114, 1, 115, 1, 115, 1, 116, 1,
		116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1,
		116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1,
		116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1,
		116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1,
		116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1,
		116, 1, 116, 3, 116, 2684, 8, 116, 1, 117, 1, 117, 1, 117, 1, 117, 1, 118,
		1, 118, 1, 118, 1, 118, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119,
		1, 119, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 5, 120, 2706, 8, 120, 10,
		120, 12, 120, 2709, 9, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 3,
		120, 2716, 8, 120, 3, 120, 2718, 8, 120, 1, 121, 1, 121, 1, 121, 1, 121,
		1, 121, 5, 121, 2725, 8, 121, 10, 121, 12, 121, 2728, 9, 121, 1, 121, 1,
		121, 1, 121, 1, 121, 1, 121, 3, 121, 2735, 8, 121, 3, 121, 2737, 8, 121,
		1, 121, 3, 121, 2740, 8, 121, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 5,
		122, 2747, 8, 122, 10, 122, 12, 122, 2750, 9, 122, 1, 123, 1, 123, 1, 123,
		1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123,
		1, 123, 3, 123, 2765, 8, 123, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1,
		124, 5, 124, 2773, 8, 124, 10, 124, 12, 124, 2776, 9, 124, 1, 124, 1, 124,
		1, 124, 1, 124, 1, 124, 3, 124, 2783, 8, 124, 3, 124, 2785, 8, 124, 1,
		125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 5, 125, 2793, 8, 125, 10,
		125, 12, 125, 2796, 9, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 3,
		125, 2803, 8, 125, 3, 125, 2805, 8, 125, 1, 126, 1, 126, 1, 126, 1, 126,
		1, 126, 1, 126, 5, 126, 2813, 8, 126, 10, 126, 12, 126, 2816, 9, 126, 1,
		126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 5, 126, 2824, 8, 126, 10,
		126, 12, 126, 2827, 9, 126, 1, 126, 1, 126, 1, 126, 1, 126, 3, 126, 2833,
		8, 126, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 3, 127, 2840, 8, 127, 1,
		128, 1, 128, 1, 128, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 130, 1,
		130, 1, 130, 1, 130, 1, 130, 5, 130, 2855, 8, 130, 10, 130, 12, 130, 2858,
		9, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 131, 1, 131, 1, 131, 1, 131,
		1, 131, 1, 131, 5, 131, 2870, 8, 131, 10, 131, 12, 131, 2873, 9, 131, 1,
		131, 1, 131, 1, 131, 1, 131, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 5,
		132, 2884, 8, 132, 10, 132, 12, 132, 2887, 9, 132, 1, 132, 1, 132, 1, 132,
		1, 132, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 5, 133, 2899, 8,
		133, 10, 133, 12, 133, 2902, 9, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1,
		134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 3, 134, 2914, 8, 134, 3, 134,
		2916, 8, 134, 1, 134, 3, 134, 2919, 8, 134, 1, 135, 1, 135, 1, 135, 1,
		135, 1, 136, 1, 136, 1, 136, 1, 137, 1, 137, 1, 137, 1, 137, 1, 138, 1,
		138, 1, 138, 1, 139, 1, 139, 1, 139, 1, 139, 1, 140, 1, 140, 1, 140, 1,
		140, 1, 140, 1, 141, 3, 141, 2945, 8, 141, 1, 141, 3, 141, 2948, 8, 141,
		1, 141, 3, 141, 2951, 8, 141, 1, 141, 3, 141, 2954, 8, 141, 1, 141, 3,
		141, 2957, 8, 141, 1, 141, 3, 141, 2960, 8, 141, 1, 142, 1, 142, 1, 142,
		1, 142, 1, 142, 1, 142, 3, 142, 2968, 8, 142, 1, 142, 1, 142, 3, 142, 2972,
		8, 142, 1, 142, 3, 142, 2975, 8, 142, 1, 143, 1, 143, 1, 143, 1, 143, 1,
		143, 1, 143, 5, 143, 2983, 8, 143, 10, 143, 12, 143, 2986, 9, 143, 1, 143,
		1, 143, 1, 143, 3, 143, 2991, 8, 143, 1, 143, 3, 143, 2994, 8, 143, 1,
		144, 1, 144, 1, 144, 1, 144, 1, 144, 3, 144, 3001, 8, 144, 1, 144, 3, 144,
		3004, 8, 144, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 3, 145, 3012,
		8, 145, 1, 145, 1, 145, 3, 145, 3016, 8, 145, 1, 145, 3, 145, 3019, 8,
		145, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 147, 1, 147, 1, 147, 1,
		147, 1, 147, 1, 147, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 3, 148, 3037,
		8, 148, 1, 148, 3, 148, 3040, 8, 148, 1, 149, 1, 149, 1, 149, 1, 149, 1,
		149, 1, 150, 3, 150, 3048, 8, 150, 1, 150, 1, 150, 1, 150, 3, 150, 3053,
		8, 150, 1, 151, 1, 151, 3, 151, 3057, 8, 151, 1, 152, 1, 152, 1, 152, 1,
		152, 5, 152, 3063, 8, 152, 10, 152, 12, 152, 3066, 9, 152, 1, 153, 1, 153,
		1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 3, 153, 3077, 8,
		153, 1, 153, 3, 153, 3080, 8, 153, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154,
		1, 154, 1, 154, 3, 154, 3089, 8, 154, 1, 155, 1, 155, 3, 155, 3093, 8,
		155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1,
		155, 1, 155, 3, 155, 3105, 8, 155, 1, 155, 1, 155, 1, 155, 3, 155, 3110,
		8, 155, 1, 156, 1, 156, 3, 156, 3114, 8, 156, 1, 156, 1, 156, 1, 156, 1,
		156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 3, 156, 3126, 8, 156,
		1, 156, 1, 156, 1, 156, 3, 156, 3131, 8, 156, 1, 157, 1, 157, 1, 157, 1,
		157, 3, 157, 3137, 8, 157, 1, 157, 1, 157, 1, 158, 1, 158, 1, 158, 1, 158,
		3, 158, 3145, 8, 158, 1, 158, 1, 158, 1, 159, 1, 159, 1, 159, 1, 160, 1,
		160, 1, 160, 1, 160, 3, 160, 3156, 8, 160, 1, 160, 3, 160, 3159, 8, 160,
		1, 161, 1, 161, 1, 161, 1, 161, 3, 161, 3165, 8, 161, 1, 161, 3, 161, 3168,
		8, 161, 1, 161, 3, 161, 3171, 8, 161, 1, 162, 1, 162, 1, 162, 1, 162, 1,
		162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1,
		162, 3, 162, 3187, 8, 162, 1, 163, 1, 163, 1, 163, 1, 163, 1, 164, 1, 164,
		1, 164, 1, 165, 1, 165, 1, 165, 1, 166, 1, 166, 1, 167, 1, 167, 1, 168,
		1, 168, 1, 168, 1, 168, 5, 168, 3207, 8, 168, 10, 168, 12, 168, 3210, 9,
		168, 1, 168, 1, 168, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 1,
		169, 1, 170, 1, 170, 3, 170, 3223, 8, 170, 1, 170, 1, 170, 1, 170, 3, 170,
		3228, 8, 170, 1, 170, 3, 170, 3231, 8, 170, 1, 170, 3, 170, 3234, 8, 170,
		1, 170, 1, 170, 3, 170, 3238, 8, 170, 1, 170, 1, 170, 3, 170, 3242, 8,
		170, 1, 170, 3, 170, 3245, 8, 170, 1, 170, 3, 170, 3248, 8, 170, 3, 170,
		3250, 8, 170, 1, 171, 1, 171, 3, 171, 3254, 8, 171, 1, 171, 1, 171, 1,
		171, 3, 171, 3259, 8, 171, 1, 171, 1, 171, 1, 171, 1, 171, 3, 171, 3265,
		8, 171, 1, 171, 3, 171, 3268, 8, 171, 1, 171, 3, 171, 3271, 8, 171, 1,
		171, 1, 171, 3, 171, 3275, 8, 171, 1, 171, 1, 171, 1, 171, 3, 171, 3280,
		8, 171, 1, 171, 1, 171, 3, 171, 3284, 8, 171, 1, 171, 1, 171, 3, 171, 3288,
		8, 171, 1, 171, 1, 171, 1, 171, 3, 171, 3293, 8, 171, 1, 171, 1, 171, 1,
		171, 3, 171, 3298, 8, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 3, 171,
		3305, 8, 171, 3, 171, 3307, 8, 171, 1, 172, 1, 172, 1, 172, 1, 173, 1,
		173, 1, 173, 1, 173, 1, 173, 1, 173, 1, 173, 3, 173, 3319, 8, 173, 1, 173,
		1, 173, 1, 173, 1, 173, 1, 173, 3, 173, 3326, 8, 173, 1, 174, 1, 174, 1,
		174, 1, 174, 1, 174, 3, 174, 3333, 8, 174, 1, 175, 1, 175, 1, 175, 1, 175,
		1, 175, 1, 176, 3, 176, 3341, 8, 176, 1, 176, 1, 176, 1, 176, 1, 176, 3,
		176, 3347, 8, 176, 1, 176, 3, 176, 3350, 8, 176, 1, 176, 1, 176, 1, 176,
		1, 176, 1, 176, 3, 176, 3357, 8, 176, 1, 176, 5, 176, 3360, 8, 176, 10,
		176, 12, 176, 3363, 9, 176, 1, 176, 3, 176, 3366, 8, 176, 1, 176, 1, 176,
		1, 176, 1, 176, 1, 176, 5, 176, 3373, 8, 176, 10, 176, 12, 176, 3376, 9,
		176, 3, 176, 3378, 8, 176, 1, 177, 1, 177, 1, 177, 1, 177, 3, 177, 3384,
		8, 177, 1, 178, 1, 178, 1, 178, 3, 178, 3389, 8, 178, 1, 179, 3, 179, 3392,
		8, 179, 1, 179, 3, 179, 3395, 8, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1,
		179, 1, 179, 1, 179, 3, 179, 3404, 8, 179, 1, 180, 3, 180, 3407, 8, 180,
		1, 180, 3, 180, 3410, 8, 180, 1, 180, 1, 180, 1, 180, 1, 180, 3, 180, 3416,
		8, 180, 1, 180, 1, 180, 3, 180, 3420, 8, 180, 1, 180, 1, 180, 3, 180, 3424,
		8, 180, 1, 181, 1, 181, 1, 181, 1, 181, 1, 181, 1, 181, 3, 181, 3432, 8,
		181, 1, 181, 1, 181, 1, 181, 1, 181, 1, 181, 1, 181, 5, 181, 3440, 8, 181,
		10, 181, 12, 181, 3443, 9, 181, 3, 181, 3445, 8, 181, 1, 181, 3, 181, 3448,
		8, 181, 1, 181, 1, 181, 1, 181, 3, 181, 3453, 8, 181, 1, 182, 1, 182, 1,
		182, 1, 182, 1, 182, 1, 182, 1, 182, 3, 182, 3462, 8, 182, 1, 182, 1, 182,
		1, 182, 1, 182, 5, 182, 3468, 8, 182, 10, 182, 12, 182, 3471, 9, 182, 3,
		182, 3473, 8, 182, 1, 182, 3, 182, 3476, 8, 182, 1, 182, 3, 182, 3479,
		8, 182, 1, 183, 1, 183, 1, 183, 1, 183, 1, 184, 1, 184, 1, 184, 1, 184,
		1, 184, 1, 184, 3, 184, 3491, 8, 184, 1, 185, 1, 185, 1, 185, 1, 185, 1,
		185, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 187, 1, 187, 1, 187, 1,
		188, 1, 188, 1, 188, 3, 188, 3509, 8, 188, 1, 188, 1, 188, 1, 188, 3, 188,
		3514, 8, 188, 5, 188, 3516, 8, 188, 10, 188, 12, 188, 3519, 9, 188, 1,
		188, 1, 188, 1, 189, 1, 189, 1, 190, 1, 190, 1, 191, 1, 191, 1, 191, 1,
		191, 1, 191, 1, 191, 1, 191, 3, 191, 3534, 8, 191, 1, 191, 1, 191, 1, 192,
		1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 3, 192, 3545, 8, 192, 1,
		192, 1, 192, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 3,
		193, 3556, 8, 193, 1, 193, 1, 193, 1, 194, 1, 194, 3, 194, 3562, 8, 194,
		1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 3, 194, 3570, 8, 194, 1,
		194, 3, 194, 3573, 8, 194, 1, 194, 1, 194, 3, 194, 3577, 8, 194, 1, 194,
		1, 194, 3, 194, 3581, 8, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 5,
		194, 3588, 8, 194, 10, 194, 12, 194, 3591, 9, 194, 3, 194, 3593, 8, 194,
		1, 194, 3, 194, 3596, 8, 194, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1,
		195, 3, 195, 3604, 8, 195, 1, 195, 1, 195, 1, 195, 1, 196, 1, 196, 1, 196,
		1, 196, 1, 196, 1, 196, 1, 196, 3, 196, 3616, 8, 196, 1, 196, 1, 196, 1,
		197, 1, 197, 3, 197, 3622, 8, 197, 1, 197, 1, 197, 1, 197, 1, 197, 1, 197,
		1, 197, 3, 197, 3630, 8, 197, 1, 197, 3, 197, 3633, 8, 197, 1, 197, 1,
		197, 3, 197, 3637, 8, 197, 1, 197, 1, 197, 3, 197, 3641, 8, 197, 1, 197,
		1, 197, 1, 197, 1, 197, 1, 197, 5, 197, 3648, 8, 197, 10, 197, 12, 197,
		3651, 9, 197, 3, 197, 3653, 8, 197, 1, 197, 3, 197, 3656, 8, 197, 1, 198,
		1, 198, 3, 198, 3660, 8, 198, 1, 198, 1, 198, 1, 198, 3, 198, 3665, 8,
		198, 1, 198, 3, 198, 3668, 8, 198, 1, 198, 1, 198, 1, 198, 3, 198, 3673,
		8, 198, 1, 198, 3, 198, 3676, 8, 198, 1, 199, 1, 199, 1, 199, 1, 199, 5,
		199, 3682, 8, 199, 10, 199, 12, 199, 3685, 9, 199, 1, 199, 1, 199, 1, 199,
		1, 199, 1, 199, 5, 199, 3692, 8, 199, 10, 199, 12, 199, 3695, 9, 199, 1,
		199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1,
		199, 5, 199, 3707, 8, 199, 10, 199, 12, 199, 3710, 9, 199, 1, 199, 1, 199,
		3, 199, 3714, 8, 199, 1, 200, 1, 200, 1, 200, 3, 200, 3719, 8, 200, 1,
		200, 1, 200, 1, 200, 1, 201, 1, 201, 1, 201, 1, 201, 1, 201, 1, 201, 1,
		201, 1, 201, 1, 201, 1, 201, 3, 201, 3734, 8, 201, 1, 201, 3, 201, 3737,
		8, 201, 1, 202, 1, 202, 1, 202, 1, 202, 3, 202, 3743, 8, 202, 1, 203, 1,
		203, 1, 203, 1, 203, 1, 203, 1, 203, 1, 203, 1, 203, 1, 203, 5, 203, 3754,
		8, 203, 10, 203, 12, 203, 3757, 9, 203, 1, 204, 1, 204, 1, 204, 3, 204,
		3762, 8, 204, 1, 204, 1, 204, 3, 204, 3766, 8, 204, 1, 204, 1, 204, 1,
		204, 3, 204, 3771, 8, 204, 1, 204, 1, 204, 1, 204, 3, 204, 3776, 8, 204,
		1, 204, 1, 204, 1, 204, 3, 204, 3781, 8, 204, 1, 204, 1, 204, 1, 204, 1,
		204, 1, 204, 1, 204, 5, 204, 3789, 8, 204, 10, 204, 12, 204, 3792, 9, 204,
		1, 204, 1, 204, 3, 204, 3796, 8, 204, 1, 204, 3, 204, 3799, 8, 204, 1,
		204, 1, 204, 3, 204, 3803, 8, 204, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205,
		1, 205, 1, 205, 3, 205, 3812, 8, 205, 1, 206, 1, 206, 1, 206, 3, 206, 3817,
		8, 206, 1, 206, 1, 206, 3, 206, 3821, 8, 206, 1, 206, 1, 206, 1, 206, 1,
		206, 1, 206, 5, 206, 3828, 8, 206, 10, 206, 12, 206, 3831, 9, 206, 3, 206,
		3833, 8, 206, 1, 206, 3, 206, 3836, 8, 206, 1, 207, 1, 207, 1, 207, 3,
		207, 3841, 8, 207, 1, 207, 1, 207, 1, 207, 1, 207, 3, 207, 3847, 8, 207,
		1, 207, 1, 207, 1, 207, 1, 207, 1, 207, 5, 207, 3854, 8, 207, 10, 207,
		12, 207, 3857, 9, 207, 3, 207, 3859, 8, 207, 1, 207, 3, 207, 3862, 8, 207,
		1, 208, 1, 208, 1, 208, 1, 208, 1, 208, 3, 208, 3869, 8, 208, 1, 208, 1,
		208, 1, 208, 1, 208, 1, 208, 5, 208, 3876, 8, 208, 10, 208, 12, 208, 3879,
		9, 208, 3, 208, 3881, 8, 208, 1, 208, 3, 208, 3884, 8, 208, 1, 209, 1,
		209, 1, 209, 1, 209, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1,
		210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 5, 210, 3902, 8, 210, 10,
		210, 12, 210, 3905, 9, 210, 3, 210, 3907, 8, 210, 1, 211, 1, 211, 3, 211,
		3911, 8, 211, 1, 211, 1, 211, 1, 211, 3, 211, 3916, 8, 211, 1, 211, 1,
		211, 1, 211, 3, 211, 3921, 8, 211, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212,
		5, 212, 3928, 8, 212, 10, 212, 12, 212, 3931, 9, 212, 1, 213, 1, 213, 1,
		213, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 3, 214, 3942, 8, 214,
		1, 214, 1, 214, 3, 214, 3946, 8, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1,
		214, 5, 214, 3953, 8, 214, 10, 214, 12, 214, 3956, 9, 214, 3, 214, 3958,
		8, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 5, 214, 3965, 8, 214, 10,
		214, 12, 214, 3968, 9, 214, 1, 214, 1, 214, 1, 215, 1, 215, 1, 215, 1,
		215, 1, 215, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1,
		216, 5, 216, 3985, 8, 216, 10, 216, 12, 216, 3988, 9, 216, 1, 216, 1, 216,
		1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 5, 216, 3999, 8,
		216, 10, 216, 12, 216, 4002, 9, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1,
		216, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1,
		216, 1, 216, 1, 216, 1, 216, 1, 216, 5, 216, 4022, 8, 216, 10, 216, 12,
		216, 4025, 9, 216, 1, 216, 1, 216, 3, 216, 4029, 8, 216, 1, 217, 1, 217,
		3, 217, 4033, 8, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 3, 217, 4040,
		8, 217, 1, 217, 1, 217, 1, 217, 3, 217, 4045, 8, 217, 3, 217, 4047, 8,
		217, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1,
		218, 3, 218, 4058, 8, 218, 1, 219, 1, 219, 3, 219, 4062, 8, 219, 1, 219,
		1, 219, 1, 219, 3, 219, 4067, 8, 219, 1, 220, 1, 220, 1, 220, 1, 220, 1,
		220, 1, 220, 1, 221, 1, 221, 1, 221, 1, 221, 1, 222, 1, 222, 1, 222, 1,
		223, 1, 223, 1, 223, 1, 223, 1, 224, 1, 224, 3, 224, 4088, 8, 224, 1, 224,
		3, 224, 4091, 8, 224, 1, 224, 1, 224, 1, 224, 3, 224, 4096, 8, 224, 1,
		224, 1, 224, 1, 224, 1, 224, 3, 224, 4102, 8, 224, 1, 225, 1, 225, 3, 225,
		4106, 8, 225, 1, 225, 1, 225, 1, 225, 3, 225, 4111, 8, 225, 1, 225, 1,
		225, 1, 225, 1, 225, 1, 225, 1, 226, 1, 226, 1, 226, 3, 226, 4121, 8, 226,
		1, 226, 3, 226, 4124, 8, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1,
		226, 1, 226, 1, 226, 1, 226, 1, 226, 3, 226, 4136, 8, 226, 1, 226, 3, 226,
		4139, 8, 226, 1, 227, 1, 227, 1, 227, 1, 228, 3, 228, 4145, 8, 228, 1,
		228, 1, 228, 5, 228, 4149, 8, 228, 10, 228, 12, 228, 4152, 9, 228, 1, 228,
		1, 228, 3, 228, 4156, 8, 228, 1, 229, 1, 229, 1, 229, 1, 229, 3, 229, 4162,
		8, 229, 1, 229, 3, 229, 4165, 8, 229, 1, 229, 1, 229, 3, 229, 4169, 8,
		229, 1, 229, 1, 229, 3, 229, 4173, 8, 229, 1, 229, 1, 229, 1, 229, 1, 229,
		3, 229, 4179, 8, 229, 1, 229, 1, 229, 1, 229, 3, 229, 4184, 8, 229, 3,
		229, 4186, 8, 229, 1, 230, 1, 230, 1, 230, 3, 230, 4191, 8, 230, 1, 230,
		1, 230, 1, 231, 1, 231, 1, 231, 1, 231, 5, 231, 4199, 8, 231, 10, 231,
		12, 231, 4202, 9, 231, 1, 231, 1, 231, 1, 232, 1, 232, 1, 232, 1, 232,
		3, 232, 4210, 8, 232, 1, 232, 1, 232, 1, 232, 1, 232, 3, 232, 4216, 8,
		232, 1, 232, 1, 232, 1, 232, 1, 232, 3, 232, 4222, 8, 232, 1, 232, 1, 232,
		1, 232, 1, 232, 3, 232, 4228, 8, 232, 1, 232, 3, 232, 4231, 8, 232, 1,
		232, 3, 232, 4234, 8, 232, 1, 232, 3, 232, 4237, 8, 232, 1, 232, 1, 232,
		1, 232, 1, 232, 1, 232, 3, 232, 4244, 8, 232, 1, 232, 1, 232, 3, 232, 4248,
		8, 232, 1, 232, 1, 232, 3, 232, 4252, 8, 232, 1, 232, 1, 232, 1, 232, 1,
		232, 1, 232, 3, 232, 4259, 8, 232, 1, 232, 1, 232, 1, 232, 1, 232, 3, 232,
		4265, 8, 232, 1, 232, 1, 232, 3, 232, 4269, 8, 232, 1, 232, 1, 232, 3,
		232, 4273, 8, 232, 3, 232, 4275, 8, 232, 1, 233, 1, 233, 1, 233, 1, 233,
		3, 233, 4281, 8, 233, 1, 233, 1, 233, 1, 233, 3, 233, 4286, 8, 233, 1,
		233, 1, 233, 1, 233, 3, 233, 4291, 8, 233, 1, 233, 1, 233, 1, 233, 3, 233,
		4296, 8, 233, 1, 233, 1, 233, 1, 234, 1, 234, 1, 234, 3, 234, 4303, 8,
		234, 1, 234, 1, 234, 1, 234, 1, 234, 3, 234, 4309, 8, 234, 3, 234, 4311,
		8, 234, 1, 235, 1, 235, 1, 235, 1, 235, 3, 235, 4317, 8, 235, 1, 236, 1,
		236, 1, 236, 3, 236, 4322, 8, 236, 1, 236, 1, 236, 3, 236, 4326, 8, 236,
		1, 236, 1, 236, 3, 236, 4330, 8, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1,
		236, 5, 236, 4337, 8, 236, 10, 236, 12, 236, 4340, 9, 236, 3, 236, 4342,
		8, 236, 1, 236, 3, 236, 4345, 8, 236, 1, 237, 1, 237, 1, 237, 1, 237, 1,
		237, 3, 237, 4352, 8, 237, 1, 237, 1, 237, 3, 237, 4356, 8, 237, 1, 237,
		3, 237, 4359, 8, 237, 1, 237, 1, 237, 1, 237, 1, 237, 1, 237, 3, 237, 4366,
		8, 237, 1, 238, 1, 238, 1, 238, 1, 238, 3, 238, 4372, 8, 238, 1, 238, 1,
		238, 3, 238, 4376, 8, 238, 1, 239, 1, 239, 1, 239, 1, 239, 1, 239, 1, 239,
		3, 239, 4384, 8, 239, 1, 239, 1, 239, 3, 239, 4388, 8, 239, 1, 240, 1,
		240, 1, 240, 1, 240, 1, 240, 1, 241, 1, 241, 1, 241, 1, 242, 1, 242, 1,
		242, 1, 243, 1, 243, 1, 243, 1, 244, 1, 244, 1, 244, 1, 244, 1, 244, 1,
		244, 3, 244, 4410, 8, 244, 1, 244, 1, 244, 1, 244, 1, 244, 3, 244, 4416,
		8, 244, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 3, 245, 4424, 8,
		245, 1, 246, 1, 246, 1, 246, 1, 246, 3, 246, 4430, 8, 246, 1, 247, 1, 247,
		1, 247, 1, 247, 1, 247, 1, 247, 3, 247, 4438, 8, 247, 1, 248, 1, 248, 1,
		248, 1, 248, 3, 248, 4444, 8, 248, 1, 248, 1, 248, 1, 248, 1, 248, 3, 248,
		4450, 8, 248, 1, 249, 1, 249, 1, 249, 1, 250, 1, 250, 1, 250, 1, 251, 1,
		251, 1, 251, 1, 252, 1, 252, 1, 252, 1, 253, 1, 253, 1, 253, 1, 253, 1,
		254, 1, 254, 1, 254, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1,
		255, 3, 255, 4478, 8, 255, 1, 256, 1, 256, 1, 256, 1, 256, 1, 257, 1, 257,
		3, 257, 4486, 8, 257, 1, 257, 1, 257, 1, 257, 3, 257, 4491, 8, 257, 1,
		258, 1, 258, 1, 258, 1, 258, 3, 258, 4497, 8, 258, 1, 259, 1, 259, 1, 259,
		1, 259, 1, 259, 3, 259, 4504, 8, 259, 1, 260, 1, 260, 3, 260, 4508, 8,
		260, 1, 260, 1, 260, 1, 260, 1, 260, 1, 260, 3, 260, 4515, 8, 260, 1, 261,
		1, 261, 1, 261, 1, 261, 1, 261, 1, 261, 1, 261, 1, 261, 3, 261, 4525, 8,
		261, 1, 261, 1, 261, 3, 261, 4529, 8, 261, 1, 261, 1, 261, 1, 261, 1, 261,
		1, 261, 5, 261, 4536, 8, 261, 10, 261, 12, 261, 4539, 9, 261, 3, 261, 4541,
		8, 261, 1, 261, 3, 261, 4544, 8, 261, 3, 261, 4546, 8, 261, 1, 262, 1,
		262, 1, 262, 1, 262, 3, 262, 4552, 8, 262, 1, 262, 1, 262, 3, 262, 4556,
		8, 262, 1, 263, 1, 263, 3, 263, 4560, 8, 263, 1, 263, 1, 263, 1, 263, 3,
		263, 4565, 8, 263, 1, 263, 1, 263, 1, 263, 1, 263, 3, 263, 4571, 8, 263,
		1, 264, 1, 264, 1, 264, 1, 264, 3, 264, 4577, 8, 264, 1, 264, 1, 264, 3,
		264, 4581, 8, 264, 1, 264, 1, 264, 1, 264, 1, 264, 3, 264, 4587, 8, 264,
		1, 264, 1, 264, 3, 264, 4591, 8, 264, 3, 264, 4593, 8, 264, 1, 265, 1,
		265, 3, 265, 4597, 8, 265, 1, 265, 1, 265, 1, 265, 1, 265, 1, 265, 3, 265,
		4604, 8, 265, 1, 266, 1, 266, 1, 266, 3, 266, 4609, 8, 266, 1, 267, 1,
		267, 1, 267, 1, 268, 1, 268, 1, 268, 1, 268, 1, 268, 3, 268, 4619, 8, 268,
		1, 268, 1, 268, 3, 268, 4623, 8, 268, 1, 268, 1, 268, 1, 268, 3, 268, 4628,
		8, 268, 1, 268, 3, 268, 4631, 8, 268, 1, 269, 1, 269, 1, 269, 1, 269, 3,
		269, 4637, 8, 269, 1, 269, 1, 269, 1, 270, 1, 270, 1, 270, 1, 270, 3, 270,
		4645, 8, 270, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 3,
		270, 4654, 8, 270, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 3, 270,
		4662, 8, 270, 1, 270, 1, 270, 1, 270, 1, 270, 3, 270, 4668, 8, 270, 1,
		270, 1, 270, 1, 270, 1, 270, 3, 270, 4674, 8, 270, 1, 271, 1, 271, 1, 271,
		1, 272, 1, 272, 1, 272, 1, 272, 1, 272, 1, 272, 1, 272, 3, 272, 4686, 8,
		272, 3, 272, 4688, 8, 272, 1, 273, 1, 273, 1, 273, 1, 273, 1, 273, 1, 273,
		3, 273, 4696, 8, 273, 1, 274, 1, 274, 1, 274, 1, 274, 1, 274, 3, 274, 4703,
		8, 274, 1, 274, 1, 274, 3, 274, 4707, 8, 274, 1, 275, 1, 275, 1, 275, 1,
		275, 3, 275, 4713, 8, 275, 1, 275, 1, 275, 1, 275, 1, 275, 1, 275, 1, 275,
		1, 276, 1, 276, 1, 276, 1, 276, 3, 276, 4725, 8, 276, 1, 276, 1, 276, 1,
		277, 1, 277, 1, 277, 1, 278, 1, 278, 1, 278, 1, 278, 3, 278, 4736, 8, 278,
		1, 278, 1, 278, 1, 278, 1, 278, 1, 278, 1, 278, 1, 278, 1, 278, 3, 278,
		4746, 8, 278, 1, 279, 1, 279, 1, 279, 1, 279, 3, 279, 4752, 8, 279, 1,
		279, 1, 279, 1, 279, 1, 279, 1, 279, 1, 279, 1, 279, 1, 279, 3, 279, 4762,
		8, 279, 1, 280, 1, 280, 1, 280, 1, 280, 1, 280, 1, 280, 1, 280, 1, 280,
		1, 280, 1, 280, 1, 280, 3, 280, 4775, 8, 280, 1, 280, 1, 280, 1, 280, 3,
		280, 4780, 8, 280, 1, 281, 1, 281, 1, 281, 1, 281, 1, 281, 1, 281, 3, 281,
		4788, 8, 281, 1, 281, 1, 281, 1, 281, 1, 282, 3, 282, 4794, 8, 282, 1,
		282, 1, 282, 1, 282, 3, 282, 4799, 8, 282, 1, 283, 1, 283, 1, 283, 1, 283,
		1, 283, 1, 283, 1, 283, 5, 283, 4808, 8, 283, 10, 283, 12, 283, 4811, 9,
		283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 3, 283, 4818, 8, 283, 1, 283,
		1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 3, 283,
		4829, 8, 283, 1, 283, 1, 283, 1, 283, 1, 283, 3, 283, 4835, 8, 283, 1,
		283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 3, 283, 4844, 8, 283,
		1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283,
		3, 283, 4855, 8, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1,
		283, 1, 283, 1, 283, 1, 283, 3, 283, 4867, 8, 283, 1, 283, 1, 283, 1, 283,
		1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 3, 283,
		4880, 8, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 3, 283, 4887, 8,
		283, 3, 283, 4889, 8, 283, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284,
		1, 284, 5, 284, 4898, 8, 284, 10, 284, 12, 284, 4901, 9, 284, 1, 284, 1,
		284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1,
		284, 1, 284, 1, 284, 1, 284, 3, 284, 4917, 8, 284, 1, 284, 1, 284, 1, 284,
		1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284,
		1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284,
		1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284,
		1, 284, 3, 284, 4950, 8, 284, 1, 284, 1, 284, 1, 284, 3, 284, 4955, 8,
		284, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 3, 285, 4963, 8, 285,
		1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 3, 285, 4971, 8, 285, 1,
		286, 1, 286, 1, 286, 3, 286, 4976, 8, 286, 1, 286, 1, 286, 1, 286, 1, 286,
		1, 286, 1, 286, 3, 286, 4984, 8, 286, 3, 286, 4986, 8, 286, 1, 287, 1,
		287, 1, 287, 3, 287, 4991, 8, 287, 1, 288, 1, 288, 1, 288, 5, 288, 4996,
		8, 288, 10, 288, 12, 288, 4999, 9, 288, 1, 289, 1, 289, 1, 289, 1, 289,
		1, 289, 1, 289, 1, 289, 1, 289, 1, 289, 1, 289, 5, 289, 5011, 8, 289, 10,
		289, 12, 289, 5014, 9, 289, 1, 290, 1, 290, 1, 290, 5, 290, 5019, 8, 290,
		10, 290, 12, 290, 5022, 9, 290, 1, 291, 1, 291, 3, 291, 5026, 8, 291, 1,
		291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1,
		291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1,
		291, 1, 291, 1, 291, 1, 291, 3, 291, 5050, 8, 291, 1, 291, 1, 291, 1, 291,
		1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291,
		1, 291, 1, 291, 1, 291, 3, 291, 5067, 8, 291, 1, 292, 1, 292, 1, 292, 1,
		292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1,
		292, 1, 292, 3, 292, 5083, 8, 292, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293,
		1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293,
		1, 293, 1, 293, 1, 293, 1, 293, 3, 293, 5103, 8, 293, 1, 294, 1, 294, 1,
		294, 1, 294, 1, 294, 1, 294, 1, 295, 1, 295, 1, 295, 1, 295, 1, 295, 1,
		295, 1, 295, 1, 296, 1, 296, 1, 296, 1, 296, 1, 296, 1, 297, 1, 297, 1,
		297, 1, 297, 1, 298, 1, 298, 1, 298, 1, 298, 1, 298, 1, 298, 1, 299, 1,
		299, 1, 299, 1, 299, 1, 299, 1, 299, 1, 300, 1, 300, 1, 300, 1, 300, 1,
		300, 1, 301, 1, 301, 1, 301, 1, 301, 1, 302, 1, 302, 1, 302, 1, 302, 1,
		302, 1, 302, 1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 3,
		303, 5161, 8, 303, 1, 303, 1, 303, 3, 303, 5165, 8, 303, 1, 303, 1, 303,
		1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 5, 303, 5176, 8,
		303, 10, 303, 12, 303, 5179, 9, 303, 1, 303, 1, 303, 3, 303, 5183, 8, 303,
		1, 303, 1, 303, 3, 303, 5187, 8, 303, 1, 304, 1, 304, 1, 304, 1, 304, 1,
		304, 1, 304, 1, 304, 3, 304, 5196, 8, 304, 1, 305, 1, 305, 1, 305, 1, 305,
		3, 305, 5202, 8, 305, 1, 306, 1, 306, 1, 306, 1, 306, 1, 306, 1, 306, 1,
		306, 1, 306, 1, 306, 1, 306, 1, 306, 3, 306, 5215, 8, 306, 1, 306, 1, 306,
		1, 306, 1, 306, 3, 306, 5221, 8, 306, 3, 306, 5223, 8, 306, 1, 306, 1,
		306, 1, 306, 1, 306, 1, 306, 5, 306, 5230, 8, 306, 10, 306, 12, 306, 5233,
		9, 306, 1, 306, 1, 306, 3, 306, 5237, 8, 306, 1, 306, 1, 306, 3, 306, 5241,
		8, 306, 1, 307, 1, 307, 1, 307, 1, 307, 1, 307, 1, 307, 1, 307, 3, 307,
		5250, 8, 307, 1, 308, 1, 308, 1, 308, 1, 308, 3, 308, 5256, 8, 308, 1,
		308, 1, 308, 3, 308, 5260, 8, 308, 1, 309, 1, 309, 1, 309, 1, 309, 1, 309,
		1, 309, 3, 309, 5268, 8, 309, 1, 310, 1, 310, 1, 310, 3, 310, 5273, 8,
		310, 1, 310, 1, 310, 1, 310, 1, 310, 1, 310, 3, 310, 5280, 8, 310, 1, 310,
		1, 310, 1, 310, 1, 310, 1, 310, 3, 310, 5287, 8, 310, 1, 311, 1, 311, 1,
		311, 1, 311, 1, 312, 1, 312, 1, 312, 1, 312, 1, 313, 1, 313, 1, 313, 1,
		313, 1, 313, 5, 313, 5302, 8, 313, 10, 313, 12, 313, 5305, 9, 313, 1, 314,
		1, 314, 1, 314, 1, 315, 1, 315, 1, 315, 1, 316, 1, 316, 1, 316, 1, 316,
		1, 316, 1, 316, 5, 316, 5319, 8, 316, 10, 316, 12, 316, 5322, 9, 316, 1,
		317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 5, 317, 5330, 8, 317, 10,
		317, 12, 317, 5333, 9, 317, 1, 318, 1, 318, 1, 318, 1, 318, 1, 319, 1,
		319, 1, 319, 1, 319, 1, 319, 1, 319, 1, 320, 1, 320, 1, 320, 1, 320, 1,
		320, 1, 320, 3, 320, 5351, 8, 320, 1, 320, 1, 320, 1, 320, 3, 320, 5356,
		8, 320, 1, 320, 1, 320, 3, 320, 5360, 8, 320, 1, 321, 1, 321, 1, 321, 1,
		321, 1, 322, 1, 322, 1, 322, 1, 322, 1, 322, 1, 323, 1, 323, 1, 323, 1,
		323, 1, 324, 1, 324, 1, 324, 1, 324, 1, 324, 5, 324, 5380, 8, 324, 10,
		324, 12, 324, 5383, 9, 324, 1, 324, 1, 324, 1, 324, 1, 324, 3, 324, 5389,
		8, 324, 1, 324, 3, 324, 5392, 8, 324, 1, 325, 1, 325, 1, 325, 1, 325, 3,
		325, 5398, 8, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 3, 325, 5405,
		8, 325, 1, 325, 3, 325, 5408, 8, 325, 1, 325, 3, 325, 5411, 8, 325, 1,
		326, 1, 326, 1, 326, 1, 326, 3, 326, 5417, 8, 326, 1, 326, 1, 326, 1, 326,
		1, 326, 3, 326, 5423, 8, 326, 1, 327, 1, 327, 1, 327, 1, 327, 3, 327, 5429,
		8, 327, 1, 327, 1, 327, 1, 327, 1, 327, 3, 327, 5435, 8, 327, 1, 327, 1,
		327, 1, 327, 1, 327, 1, 327, 5, 327, 5442, 8, 327, 10, 327, 12, 327, 5445,
		9, 327, 3, 327, 5447, 8, 327, 1, 327, 3, 327, 5450, 8, 327, 1, 328, 1,
		328, 1, 328, 1, 328, 1, 328, 3, 328, 5457, 8, 328, 1, 329, 1, 329, 1, 329,
		1, 329, 1, 330, 1, 330, 1, 330, 1, 330, 1, 330, 3, 330, 5468, 8, 330, 1,
		330, 1, 330, 1, 331, 1, 331, 1, 331, 1, 331, 1, 331, 3, 331, 5477, 8, 331,
		1, 331, 1, 331, 1, 332, 1, 332, 1, 332, 1, 332, 3, 332, 5485, 8, 332, 1,
		333, 1, 333, 1, 333, 1, 333, 1, 333, 1, 333, 3, 333, 5493, 8, 333, 1, 333,
		1, 333, 1, 333, 1, 334, 1, 334, 1, 334, 1, 334, 3, 334, 5502, 8, 334, 1,
		334, 1, 334, 1, 335, 1, 335, 1, 335, 1, 335, 1, 335, 1, 335, 1, 335, 1,
		335, 1, 335, 3, 335, 5515, 8, 335, 1, 336, 1, 336, 1, 336, 1, 336, 1, 336,
		1, 337, 1, 337, 1, 337, 1, 337, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338,
		1, 338, 1, 338, 1, 338, 3, 338, 5534, 8, 338, 1, 338, 1, 338, 1, 338, 1,
		338, 1, 338, 5, 338, 5541, 8, 338, 10, 338, 12, 338, 5544, 9, 338, 3, 338,
		5546, 8, 338, 1, 338, 3, 338, 5549, 8, 338, 1, 339, 1, 339, 1, 339, 1,
		339, 5, 339, 5555, 8, 339, 10, 339, 12, 339, 5558, 9, 339, 1, 340, 1, 340,
		1, 340, 1, 340, 1, 340, 3, 340, 5565, 8, 340, 1, 340, 1, 340, 3, 340, 5569,
		8, 340, 1, 340, 1, 340, 1, 340, 3, 340, 5574, 8, 340, 1, 340, 1, 340, 1,
		340, 3, 340, 5579, 8, 340, 3, 340, 5581, 8, 340, 1, 340, 1, 340, 1, 340,
		1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 3, 340, 5591, 8, 340, 1, 340, 1,
		340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 3,
		340, 5603, 8, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 3, 340, 5610,
		8, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340,
		1, 340, 3, 340, 5621, 8, 340, 1, 340, 1, 340, 3, 340, 5625, 8, 340, 1,
		341, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 1,
		341, 3, 341, 5637, 8, 341, 1, 342, 1, 342, 1, 342, 1, 342, 3, 342, 5643,
		8, 342, 1, 343, 1, 343, 1, 343, 1, 343, 1, 344, 1, 344, 1, 344, 1, 344,
		1, 344, 1, 344, 1, 344, 3, 344, 5656, 8, 344, 1, 345, 1, 345, 1, 345, 1,
		345, 3, 345, 5662, 8, 345, 1, 346, 1, 346, 1, 346, 1, 346, 3, 346, 5668,
		8, 346, 1, 346, 1, 346, 1, 347, 1, 347, 1, 347, 5, 347, 5675, 8, 347, 10,
		347, 12, 347, 5678, 9, 347, 1, 348, 1, 348, 1, 348, 1, 348, 1, 348, 1,
		348, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 5, 349, 5691, 8, 349, 10,
		349, 12, 349, 5694, 9, 349, 1, 349, 1, 349, 3, 349, 5698, 8, 349, 1, 350,
		1, 350, 3, 350, 5702, 8, 350, 1, 350, 3, 350, 5705, 8, 350, 1, 350, 1,
		350, 1, 351, 1, 351, 3, 351, 5711, 8, 351, 1, 351, 3, 351, 5714, 8, 351,
		1, 351, 3, 351, 5717, 8, 351, 1, 352, 1, 352, 1, 352, 1, 352, 1, 352, 1,
		352, 1, 353, 1, 353, 1, 353, 1, 353, 1, 354, 1, 354, 1, 354, 1, 354, 1,
		354, 1, 354, 1, 355, 1, 355, 1, 355, 1, 355, 1, 356, 1, 356, 1, 356, 1,
		356, 1, 356, 3, 356, 5744, 8, 356, 1, 356, 1, 356, 3, 356, 5748, 8, 356,
		1, 356, 3, 356, 5751, 8, 356, 1, 357, 1, 357, 1, 357, 1, 357, 3, 357, 5757,
		8, 357, 1, 357, 1, 357, 1, 358, 1, 358, 1, 358, 1, 358, 3, 358, 5765, 8,
		358, 1, 358, 1, 358, 1, 359, 1, 359, 1, 359, 1, 359, 3, 359, 5773, 8, 359,
		1, 359, 1, 359, 1, 360, 1, 360, 3, 360, 5779, 8, 360, 1, 360, 1, 360, 3,
		360, 5783, 8, 360, 1, 360, 1, 360, 1, 361, 1, 361, 1, 361, 1, 361, 3, 361,
		5791, 8, 361, 1, 362, 1, 362, 1, 362, 1, 362, 1, 362, 1, 362, 1, 363, 1,
		363, 1, 363, 1, 363, 1, 363, 1, 363, 3, 363, 5805, 8, 363, 1, 363, 1, 363,
		1, 363, 1, 363, 1, 363, 1, 363, 1, 363, 3, 363, 5814, 8, 363, 3, 363, 5816,
		8, 363, 1, 364, 1, 364, 1, 364, 1, 364, 1, 364, 1, 365, 1, 365, 1, 365,
		1, 365, 1, 365, 1, 365, 1, 365, 1, 365, 3, 365, 5831, 8, 365, 1, 365, 1,
		365, 3, 365, 5835, 8, 365, 1, 365, 3, 365, 5838, 8, 365, 1, 366, 1, 366,
		1, 366, 1, 366, 1, 366, 1, 366, 1, 366, 3, 366, 5847, 8, 366, 1, 366, 1,
		366, 3, 366, 5851, 8, 366, 1, 367, 1, 367, 1, 367, 1, 367, 1, 367, 1, 367,
		1, 367, 1, 368, 1, 368, 1, 368, 1, 368, 1, 368, 1, 368, 1, 368, 1, 369,
		1, 369, 1, 369, 1, 369, 1, 369, 1, 369, 1, 369, 1, 369, 1, 370, 1, 370,
		1, 370, 1, 370, 1, 370, 3, 370, 5880, 8, 370, 1, 370, 1, 370, 3, 370, 5884,
		8, 370, 3, 370, 5886, 8, 370, 1, 371, 1, 371, 3, 371, 5890, 8, 371, 1,
		371, 1, 371, 3, 371, 5894, 8, 371, 1, 371, 3, 371, 5897, 8, 371, 1, 371,
		3, 371, 5900, 8, 371, 1, 371, 3, 371, 5903, 8, 371, 1, 372, 1, 372, 3,
		372, 5907, 8, 372, 1, 372, 1, 372, 3, 372, 5911, 8, 372, 1, 372, 3, 372,
		5914, 8, 372, 1, 372, 3, 372, 5917, 8, 372, 1, 372, 3, 372, 5920, 8, 372,
		1, 373, 1, 373, 1, 373, 1, 373, 1, 374, 1, 374, 1, 375, 4, 375, 5929, 8,
		375, 11, 375, 12, 375, 5930, 1, 376, 1, 376, 3, 376, 5935, 8, 376, 1, 376,
		1, 376, 3, 376, 5939, 8, 376, 1, 377, 3, 377, 5942, 8, 377, 1, 377, 1,
		377, 1, 378, 1, 378, 1, 378, 1, 378, 5, 378, 5950, 8, 378, 10, 378, 12,
		378, 5953, 9, 378, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379, 5, 379,
		5961, 8, 379, 10, 379, 12, 379, 5964, 9, 379, 3, 379, 5966, 8, 379, 1,
		379, 3, 379, 5969, 8, 379, 1, 380, 3, 380, 5972, 8, 380, 1, 380, 1, 380,
		1, 380, 1, 380, 1, 380, 1, 380, 1, 380, 3, 380, 5981, 8, 380, 1, 380, 1,
		380, 1, 380, 1, 380, 1, 380, 1, 380, 1, 380, 3, 380, 5990, 8, 380, 1, 380,
		1, 380, 1, 380, 1, 380, 3, 380, 5996, 8, 380, 1, 380, 1, 380, 1, 380, 1,
		380, 1, 380, 3, 380, 6003, 8, 380, 1, 381, 1, 381, 1, 382, 1, 382, 1, 382,
		3, 382, 6010, 8, 382, 1, 382, 1, 382, 1, 382, 3, 382, 6015, 8, 382, 1,
		382, 1, 382, 1, 382, 1, 382, 3, 382, 6021, 8, 382, 1, 382, 5, 382, 6024,
		8, 382, 10, 382, 12, 382, 6027, 9, 382, 1, 383, 1, 383, 1, 383, 1, 383,
		1, 384, 1, 384, 1, 384, 1, 384, 1, 385, 1, 385, 3, 385, 6039, 8, 385, 1,
		385, 1, 385, 3, 385, 6043, 8, 385, 1, 386, 1, 386, 1, 386, 3, 386, 6048,
		8, 386, 1, 387, 1, 387, 1, 387, 1, 387, 3, 387, 6054, 8, 387, 1, 387, 1,
		387, 1, 387, 1, 387, 1, 387, 3, 387, 6061, 8, 387, 1, 388, 1, 388, 3, 388,
		6065, 8, 388, 1, 388, 1, 388, 1, 388, 5, 388, 6070, 8, 388, 10, 388, 12,
		388, 6073, 9, 388, 1, 388, 1, 388, 1, 388, 3, 388, 6078, 8, 388, 1, 388,
		1, 388, 1, 388, 3, 388, 6083, 8, 388, 1, 388, 1, 388, 3, 388, 6087, 8,
		388, 1, 388, 1, 388, 1, 388, 1, 388, 1, 388, 3, 388, 6094, 8, 388, 1, 389,
		1, 389, 1, 389, 3, 389, 6099, 8, 389, 3, 389, 6101, 8, 389, 1, 389, 1,
		389, 3, 389, 6105, 8, 389, 1, 390, 1, 390, 1, 390, 3, 390, 6110, 8, 390,
		1, 390, 1, 390, 1, 390, 1, 390, 3, 390, 6116, 8, 390, 1, 390, 1, 390, 1,
		390, 1, 390, 1, 390, 1, 390, 1, 390, 5, 390, 6125, 8, 390, 10, 390, 12,
		390, 6128, 9, 390, 1, 390, 1, 390, 1, 390, 3, 390, 6133, 8, 390, 1, 391,
		1, 391, 3, 391, 6137, 8, 391, 1, 391, 1, 391, 5, 391, 6141, 8, 391, 10,
		391, 12, 391, 6144, 9, 391, 1, 391, 1, 391, 1, 392, 1, 392, 3, 392, 6150,
		8, 392, 1, 392, 1, 392, 1, 392, 1, 392, 1, 392, 1, 393, 1, 393, 1, 394,
		1, 394, 3, 394, 6161, 8, 394, 1, 394, 1, 394, 3, 394, 6165, 8, 394, 3,
		394, 6167, 8, 394, 1, 394, 1, 394, 1, 394, 1, 394, 3, 394, 6173, 8, 394,
		1, 394, 1, 394, 3, 394, 6177, 8, 394, 3, 394, 6179, 8, 394, 1, 395, 1,
		395, 1, 395, 1, 395, 1, 395, 5, 395, 6186, 8, 395, 10, 395, 12, 395, 6189,
		9, 395, 1, 395, 1, 395, 1, 396, 1, 396, 1, 396, 3, 396, 6196, 8, 396, 1,
		396, 5, 396, 6199, 8, 396, 10, 396, 12, 396, 6202, 9, 396, 1, 397, 1, 397,
		5, 397, 6206, 8, 397, 10, 397, 12, 397, 6209, 9, 397, 1, 397, 1, 397, 1,
		397, 5, 397, 6214, 8, 397, 10, 397, 12, 397, 6217, 9, 397, 1, 397, 1, 397,
		3, 397, 6221, 8, 397, 1, 398, 1, 398, 3, 398, 6225, 8, 398, 1, 398, 3,
		398, 6228, 8, 398, 1, 398, 3, 398, 6231, 8, 398, 1, 398, 3, 398, 6234,
		8, 398, 1, 398, 3, 398, 6237, 8, 398, 1, 398, 3, 398, 6240, 8, 398, 1,
		398, 3, 398, 6243, 8, 398, 1, 398, 3, 398, 6246, 8, 398, 1, 398, 1, 398,
		3, 398, 6250, 8, 398, 1, 398, 1, 398, 1, 398, 1, 398, 1, 398, 5, 398, 6257,
		8, 398, 10, 398, 12, 398, 6260, 9, 398, 1, 398, 1, 398, 3, 398, 6264, 8,
		398, 1, 398, 1, 398, 3, 398, 6268, 8, 398, 3, 398, 6270, 8, 398, 1, 398,
		1, 398, 3, 398, 6274, 8, 398, 1, 398, 1, 398, 3, 398, 6278, 8, 398, 3,
		398, 6280, 8, 398, 1, 398, 1, 398, 1, 398, 1, 398, 1, 398, 3, 398, 6287,
		8, 398, 1, 398, 1, 398, 3, 398, 6291, 8, 398, 3, 398, 6293, 8, 398, 1,
		398, 1, 398, 1, 398, 1, 398, 1, 398, 1, 398, 1, 398, 1, 398, 3, 398, 6303,
		8, 398, 1, 398, 1, 398, 3, 398, 6307, 8, 398, 3, 398, 6309, 8, 398, 1,
		398, 1, 398, 1, 398, 3, 398, 6314, 8, 398, 1, 398, 1, 398, 3, 398, 6318,
		8, 398, 3, 398, 6320, 8, 398, 1, 398, 1, 398, 1, 398, 1, 398, 3, 398, 6326,
		8, 398, 1, 399, 1, 399, 1, 399, 1, 399, 1, 399, 5, 399, 6333, 8, 399, 10,
		399, 12, 399, 6336, 9, 399, 1, 399, 1, 399, 1, 399, 3, 399, 6341, 8, 399,
		1, 399, 1, 399, 1, 399, 1, 399, 1, 399, 5, 399, 6348, 8, 399, 10, 399,
		12, 399, 6351, 9, 399, 1, 399, 1, 399, 1, 399, 1, 400, 1, 400, 3, 400,
		6358, 8, 400, 1, 400, 1, 400, 3, 400, 6362, 8, 400, 3, 400, 6364, 8, 400,
		1, 401, 1, 401, 3, 401, 6368, 8, 401, 1, 401, 3, 401, 6371, 8, 401, 1,
		401, 1, 401, 3, 401, 6375, 8, 401, 3, 401, 6377, 8, 401, 1, 402, 1, 402,
		3, 402, 6381, 8, 402, 1, 403, 1, 403, 3, 403, 6385, 8, 403, 1, 404, 1,
		404, 1, 404, 5, 404, 6390, 8, 404, 10, 404, 12, 404, 6393, 9, 404, 1, 405,
		1, 405, 1, 405, 1, 405, 1, 406, 1, 406, 3, 406, 6401, 8, 406, 1, 406, 3,
		406, 6404, 8, 406, 1, 406, 1, 406, 3, 406, 6408, 8, 406, 1, 406, 1, 406,
		3, 406, 6412, 8, 406, 1, 406, 3, 406, 6415, 8, 406, 1, 406, 1, 406, 1,
		406, 3, 406, 6420, 8, 406, 1, 407, 1, 407, 1, 407, 1, 407, 1, 407, 1, 407,
		3, 407, 6428, 8, 407, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1,
		408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1,
		408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1,
		408, 1, 408, 1, 408, 3, 408, 6457, 8, 408, 1, 409, 1, 409, 1, 409, 1, 409,
		5, 409, 6463, 8, 409, 10, 409, 12, 409, 6466, 9, 409, 1, 409, 1, 409, 1,
		409, 1, 409, 1, 409, 1, 409, 1, 409, 1, 409, 1, 409, 3, 409, 6477, 8, 409,
		1, 410, 1, 410, 1, 410, 1, 410, 1, 411, 1, 411, 1, 411, 1, 411, 1, 411,
		1, 411, 1, 411, 5, 411, 6490, 8, 411, 10, 411, 12, 411, 6493, 9, 411, 1,
		411, 1, 411, 3, 411, 6497, 8, 411, 1, 412, 1, 412, 1, 412, 1, 412, 5, 412,
		6503, 8, 412, 10, 412, 12, 412, 6506, 9, 412, 1, 412, 1, 412, 1, 413, 3,
		413, 6511, 8, 413, 1, 413, 1, 413, 1, 413, 1, 413, 1, 413, 5, 413, 6518,
		8, 413, 10, 413, 12, 413, 6521, 9, 413, 1, 413, 1, 413, 1, 413, 3, 413,
		6526, 8, 413, 1, 413, 1, 413, 1, 413, 3, 413, 6531, 8, 413, 1, 414, 1,
		414, 1, 414, 1, 414, 1, 414, 5, 414, 6538, 8, 414, 10, 414, 12, 414, 6541,
		9, 414, 1, 414, 1, 414, 1, 415, 1, 415, 1, 415, 1, 415, 1, 415, 5, 415,
		6550, 8, 415, 10, 415, 12, 415, 6553, 9, 415, 1, 415, 1, 415, 1, 416, 1,
		416, 1, 416, 1, 416, 1, 416, 1, 417, 1, 417, 3, 417, 6564, 8, 417, 1, 418,
		1, 418, 1, 418, 1, 418, 1, 418, 1, 418, 1, 418, 1, 418, 5, 418, 6574, 8,
		418, 10, 418, 12, 418, 6577, 9, 418, 3, 418, 6579, 8, 418, 1, 419, 1, 419,
		1, 419, 1, 419, 1, 420, 1, 420, 1, 420, 1, 420, 1, 420, 5, 420, 6590, 8,
		420, 10, 420, 12, 420, 6593, 9, 420, 1, 420, 1, 420, 1, 421, 1, 421, 1,
		421, 1, 421, 5, 421, 6601, 8, 421, 10, 421, 12, 421, 6604, 9, 421, 1, 421,
		1, 421, 1, 422, 1, 422, 3, 422, 6610, 8, 422, 1, 423, 1, 423, 1, 423, 5,
		423, 6615, 8, 423, 10, 423, 12, 423, 6618, 9, 423, 1, 424, 1, 424, 1, 424,
		1, 424, 1, 425, 1, 425, 1, 425, 1, 426, 1, 426, 3, 426, 6629, 8, 426, 1,
		426, 1, 426, 1, 426, 3, 426, 6634, 8, 426, 1, 426, 1, 426, 1, 426, 1, 426,
		1, 426, 1, 426, 5, 426, 6642, 8, 426, 10, 426, 12, 426, 6645, 9, 426, 1,
		427, 1, 427, 1, 427, 5, 427, 6650, 8, 427, 10, 427, 12, 427, 6653, 9, 427,
		1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 3, 428, 6661, 8, 428, 1,
		428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1,
		428, 1, 428, 5, 428, 6674, 8, 428, 10, 428, 12, 428, 6677, 9, 428, 1, 429,
		1, 429, 3, 429, 6681, 8, 429, 1, 429, 3, 429, 6684, 8, 429, 1, 430, 1,
		430, 1, 430, 1, 430, 4, 430, 6690, 8, 430, 11, 430, 12, 430, 6691, 1, 430,
		1, 430, 3, 430, 6696, 8, 430, 1, 430, 1, 430, 1, 430, 1, 430, 1, 430, 1,
		431, 3, 431, 6704, 8, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431,
		3, 431, 6712, 8, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 3,
		431, 6720, 8, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 3, 431,
		6728, 8, 431, 1, 431, 1, 431, 3, 431, 6732, 8, 431, 1, 432, 1, 432, 1,
		432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1,
		432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1,
		432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 5, 432, 6761, 8, 432,
		10, 432, 12, 432, 6764, 9, 432, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433,
		1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433,
		1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433,
		1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433,
		1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433,
		1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 4, 433, 6813, 8, 433, 11,
		433, 12, 433, 6814, 1, 433, 1, 433, 3, 433, 6819, 8, 433, 1, 433, 1, 433,
		1, 433, 1, 433, 4, 433, 6825, 8, 433, 11, 433, 12, 433, 6826, 1, 433, 1,
		433, 3, 433, 6831, 8, 433, 1, 433, 1, 433, 1, 433, 3, 433, 6836, 8, 433,
		1, 433, 1, 433, 3, 433, 6840, 8, 433, 1, 433, 1, 433, 1, 433, 1, 433, 3,
		433, 6846, 8, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 3, 433, 6853,
		8, 433, 1, 433, 1, 433, 1, 433, 3, 433, 6858, 8, 433, 1, 433, 1, 433, 1,
		433, 1, 433, 1, 433, 1, 433, 1, 433, 3, 433, 6867, 8, 433, 1, 433, 1, 433,
		3, 433, 6871, 8, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 3, 433, 6878,
		8, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 3, 433, 6886, 8,
		433, 1, 433, 1, 433, 1, 433, 1, 433, 3, 433, 6892, 8, 433, 1, 433, 1, 433,
		1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 3, 433, 6902, 8, 433, 1,
		433, 1, 433, 3, 433, 6906, 8, 433, 1, 433, 1, 433, 1, 433, 1, 433, 5, 433,
		6912, 8, 433, 10, 433, 12, 433, 6915, 9, 433, 1, 434, 1, 434, 1, 434, 1,
		434, 1, 434, 1, 434, 1, 434, 1, 434, 1, 434, 1, 434, 3, 434, 6927, 8, 434,
		1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435,
		1, 435, 1, 435, 1, 435, 5, 435, 6941, 8, 435, 10, 435, 12, 435, 6944, 9,
		435, 3, 435, 6946, 8, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435,
		5, 435, 6954, 8, 435, 10, 435, 12, 435, 6957, 9, 435, 3, 435, 6959, 8,
		435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 3, 435, 6967, 8, 435,
		1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 5, 435,
		6977, 8, 435, 10, 435, 12, 435, 6980, 9, 435, 3, 435, 6982, 8, 435, 1,
		435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 5, 435, 6990, 8, 435, 10,
		435, 12, 435, 6993, 9, 435, 3, 435, 6995, 8, 435, 1, 435, 1, 435, 3, 435,
		6999, 8, 435, 3, 435, 7001, 8, 435, 1, 436, 1, 436, 1, 436, 3, 436, 7006,
		8, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 3, 436, 7014, 8,
		436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 3, 436, 7021, 8, 436, 3, 436,
		7023, 8, 436, 1, 436, 1, 436, 1, 436, 5, 436, 7028, 8, 436, 10, 436, 12,
		436, 7031, 9, 436, 3, 436, 7033, 8, 436, 1, 436, 1, 436, 1, 436, 1, 436,
		3, 436, 7039, 8, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 3,
		436, 7047, 8, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 3, 436,
		7055, 8, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 3, 436, 7063,
		8, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 5, 436, 7071, 8,
		436, 10, 436, 12, 436, 7074, 9, 436, 3, 436, 7076, 8, 436, 1, 436, 1, 436,
		1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 5, 436,
		7088, 8, 436, 10, 436, 12, 436, 7091, 9, 436, 3, 436, 7093, 8, 436, 1,
		436, 1, 436, 1, 436, 1, 436, 1, 436, 3, 436, 7100, 8, 436, 1, 436, 1, 436,
		1, 436, 5, 436, 7105, 8, 436, 10, 436, 12, 436, 7108, 9, 436, 1, 436, 1,
		436, 1, 436, 1, 436, 1, 436, 5, 436, 7115, 8, 436, 10, 436, 12, 436, 7118,
		9, 436, 3, 436, 7120, 8, 436, 1, 436, 1, 436, 3, 436, 7124, 8, 436, 1,
		436, 1, 436, 3, 436, 7128, 8, 436, 1, 437, 1, 437, 1, 437, 1, 438, 1, 438,
		1, 438, 1, 438, 1, 438, 3, 438, 7138, 8, 438, 1, 438, 1, 438, 1, 439, 1,
		439, 1, 440, 1, 440, 1, 440, 1, 440, 1, 440, 1, 440, 1, 440, 1, 440, 1,
		440, 1, 440, 1, 440, 1, 440, 1, 440, 1, 440, 1, 440, 3, 440, 7159, 8, 440,
		1, 440, 1, 440, 1, 440, 3, 440, 7164, 8, 440, 1, 440, 1, 440, 1, 440, 3,
		440, 7169, 8, 440, 3, 440, 7171, 8, 440, 1, 441, 1, 441, 1, 441, 3, 441,
		7176, 8, 441, 1, 441, 1, 441, 1, 441, 3, 441, 7181, 8, 441, 1, 441, 1,
		441, 1, 441, 3, 441, 7186, 8, 441, 1, 441, 3, 441, 7189, 8, 441, 1, 441,
		1, 441, 1, 441, 3, 441, 7194, 8, 441, 1, 441, 1, 441, 1, 441, 3, 441, 7199,
		8, 441, 3, 441, 7201, 8, 441, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1,
		442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1,
		442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 5, 442, 7223, 8, 442, 10,
		442, 12, 442, 7226, 9, 442, 3, 442, 7228, 8, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 5, 442, 7279, 8, 442, 10, 442, 12, 442, 7282, 9, 442, 3, 442, 7284,
		8, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 3, 442, 7344, 8, 442, 1, 443, 1,
		443, 1, 443, 1, 443, 1, 443, 1, 443, 1, 443, 1, 443, 1, 443, 1, 443, 1,
		443, 1, 443, 1, 443, 1, 443, 1, 443, 1, 443, 1, 443, 1, 443, 3, 443, 7364,
		8, 443, 1, 443, 1, 443, 1, 443, 1, 443, 1, 443, 3, 443, 7371, 8, 443, 1,
		443, 1, 443, 5, 443, 7375, 8, 443, 10, 443, 12, 443, 7378, 9, 443, 3, 443,
		7380, 8, 443, 1, 443, 1, 443, 3, 443, 7384, 8, 443, 1, 443, 1, 443, 1,
		443, 1, 443, 3, 443, 7390, 8, 443, 1, 443, 1, 443, 5, 443, 7394, 8, 443,
		10, 443, 12, 443, 7397, 9, 443, 3, 443, 7399, 8, 443, 1, 443, 1, 443, 3,
		443, 7403, 8, 443, 1, 443, 1, 443, 1, 443, 1, 443, 3, 443, 7409, 8, 443,
		1, 443, 1, 443, 5, 443, 7413, 8, 443, 10, 443, 12, 443, 7416, 9, 443, 3,
		443, 7418, 8, 443, 1, 443, 1, 443, 3, 443, 7422, 8, 443, 1, 443, 1, 443,
		1, 443, 1, 443, 3, 443, 7428, 8, 443, 1, 443, 1, 443, 5, 443, 7432, 8,
		443, 10, 443, 12, 443, 7435, 9, 443, 3, 443, 7437, 8, 443, 1, 443, 1, 443,
		3, 443, 7441, 8, 443, 3, 443, 7443, 8, 443, 1, 444, 1, 444, 1, 444, 1,
		444, 1, 444, 1, 445, 1, 445, 1, 445, 3, 445, 7453, 8, 445, 1, 445, 1, 445,
		1, 445, 1, 445, 1, 445, 5, 445, 7460, 8, 445, 10, 445, 12, 445, 7463, 9,
		445, 3, 445, 7465, 8, 445, 1, 445, 1, 445, 1, 445, 1, 445, 1, 445, 5, 445,
		7472, 8, 445, 10, 445, 12, 445, 7475, 9, 445, 3, 445, 7477, 8, 445, 1,
		445, 3, 445, 7480, 8, 445, 1, 445, 1, 445, 1, 446, 1, 446, 1, 446, 1, 447,
		1, 447, 1, 447, 1, 447, 1, 447, 1, 447, 1, 447, 1, 447, 1, 447, 1, 447,
		1, 447, 1, 447, 1, 447, 1, 447, 1, 447, 1, 447, 3, 447, 7503, 8, 447, 1,
		448, 1, 448, 1, 448, 1, 448, 1, 448, 1, 448, 1, 448, 1, 448, 1, 448, 3,
		448, 7514, 8, 448, 1, 449, 1, 449, 1, 449, 1, 449, 1, 449, 1, 449, 1, 449,
		3, 449, 7523, 8, 449, 3, 449, 7525, 8, 449, 1, 449, 1, 449, 1, 449, 1,
		449, 3, 449, 7531, 8, 449, 1, 449, 1, 449, 1, 449, 1, 449, 1, 449, 1, 449,
		1, 449, 1, 449, 3, 449, 7541, 8, 449, 3, 449, 7543, 8, 449, 1, 449, 1,
		449, 1, 449, 1, 449, 1, 449, 1, 449, 3, 449, 7551, 8, 449, 3, 449, 7553,
		8, 449, 3, 449, 7555, 8, 449, 1, 450, 1, 450, 3, 450, 7559, 8, 450, 1,
		451, 1, 451, 3, 451, 7563, 8, 451, 1, 451, 1, 451, 3, 451, 7567, 8, 451,
		1, 452, 1, 452, 3, 452, 7571, 8, 452, 1, 453, 1, 453, 1, 453, 3, 453, 7576,
		8, 453, 1, 454, 1, 454, 3, 454, 7580, 8, 454, 1, 455, 1, 455, 1, 455, 1,
		455, 1, 455, 1, 455, 1, 455, 1, 455, 5, 455, 7590, 8, 455, 10, 455, 12,
		455, 7593, 9, 455, 3, 455, 7595, 8, 455, 1, 455, 1, 455, 1, 455, 1, 455,
		1, 455, 1, 455, 1, 455, 1, 455, 1, 455, 1, 455, 5, 455, 7607, 8, 455, 10,
		455, 12, 455, 7610, 9, 455, 3, 455, 7612, 8, 455, 1, 455, 1, 455, 1, 455,
		1, 455, 1, 455, 3, 455, 7619, 8, 455, 1, 455, 1, 455, 1, 455, 1, 455, 1,
		455, 5, 455, 7626, 8, 455, 10, 455, 12, 455, 7629, 9, 455, 3, 455, 7631,
		8, 455, 1, 455, 1, 455, 1, 455, 1, 455, 1, 455, 3, 455, 7638, 8, 455, 1,
		455, 1, 455, 1, 455, 1, 455, 1, 455, 1, 455, 1, 455, 1, 455, 5, 455, 7648,
		8, 455, 10, 455, 12, 455, 7651, 9, 455, 3, 455, 7653, 8, 455, 1, 455, 1,
		455, 1, 455, 1, 455, 1, 455, 1, 455, 1, 455, 1, 455, 1, 455, 1, 455, 5,
		455, 7665, 8, 455, 10, 455, 12, 455, 7668, 9, 455, 3, 455, 7670, 8, 455,
		1, 456, 1, 456, 3, 456, 7674, 8, 456, 1, 457, 1, 457, 1, 457, 1, 457, 3,
		457, 7680, 8, 457, 1, 457, 1, 457, 1, 457, 1, 457, 1, 457, 3, 457, 7687,
		8, 457, 1, 458, 1, 458, 1, 458, 1, 458, 3, 458, 7693, 8, 458, 1, 458, 1,
		458, 1, 458, 1, 458, 1, 458, 3, 458, 7700, 8, 458, 1, 459, 1, 459, 1, 459,
		1, 459, 5, 459, 7706, 8, 459, 10, 459, 12, 459, 7709, 9, 459, 1, 459, 1,
		459, 1, 460, 1, 460, 1, 460, 1, 460, 5, 460, 7717, 8, 460, 10, 460, 12,
		460, 7720, 9, 460, 1, 460, 1, 460, 1, 461, 1, 461, 3, 461, 7726, 8, 461,
		1, 462, 1, 462, 3, 462, 7730, 8, 462, 1, 463, 1, 463, 1, 463, 1, 463, 5,
		463, 7736, 8, 463, 10, 463, 12, 463, 7739, 9, 463, 1, 463, 1, 463, 1, 464,
		1, 464, 1, 464, 1, 464, 5, 464, 7747, 8, 464, 10, 464, 12, 464, 7750, 9,
		464, 1, 464, 1, 464, 1, 465, 1, 465, 3, 465, 7756, 8, 465, 1, 466, 1, 466,
		1, 466, 1, 466, 3, 466, 7762, 8, 466, 1, 466, 1, 466, 1, 466, 1, 466, 3,
		466, 7768, 8, 466, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467,
		1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467,
		1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467,
		1, 467, 3, 467, 7796, 8, 467, 1, 468, 1, 468, 1, 468, 1, 468, 1, 468, 1,
		468, 1, 468, 1, 468, 1, 468, 1, 469, 1, 469, 1, 469, 1, 469, 3, 469, 7811,
		8, 469, 1, 469, 1, 469, 1, 469, 1, 469, 1, 469, 1, 469, 3, 469, 7819, 8,
		469, 1, 470, 1, 470, 1, 470, 1, 470, 5, 470, 7825, 8, 470, 10, 470, 12,
		470, 7828, 9, 470, 1, 470, 1, 470, 1, 471, 1, 471, 1, 471, 1, 471, 1, 472,
		1, 472, 3, 472, 7838, 8, 472, 1, 473, 1, 473, 1, 473, 1, 473, 1, 473, 1,
		473, 3, 473, 7846, 8, 473, 1, 473, 1, 473, 1, 473, 1, 473, 3, 473, 7852,
		8, 473, 1, 474, 1, 474, 1, 474, 1, 474, 1, 474, 1, 474, 3, 474, 7860, 8,
		474, 1, 474, 1, 474, 1, 474, 1, 474, 1, 474, 1, 474, 1, 474, 1, 474, 1,
		474, 3, 474, 7871, 8, 474, 3, 474, 7873, 8, 474, 1, 475, 1, 475, 3, 475,
		7877, 8, 475, 1, 475, 1, 475, 1, 475, 1, 475, 1, 475, 1, 475, 1, 475, 3,
		475, 7886, 8, 475, 1, 475, 1, 475, 1, 475, 1, 475, 1, 475, 1, 475, 1, 475,
		3, 475, 7895, 8, 475, 1, 476, 1, 476, 1, 477, 1, 477, 1, 477, 1, 477, 1,
		477, 5, 477, 7904, 8, 477, 10, 477, 12, 477, 7907, 9, 477, 1, 477, 1, 477,
		1, 478, 1, 478, 1, 478, 1, 479, 1, 479, 1, 479, 1, 479, 5, 479, 7918, 8,
		479, 10, 479, 12, 479, 7921, 9, 479, 1, 479, 1, 479, 1, 480, 1, 480, 1,
		480, 5, 480, 7928, 8, 480, 10, 480, 12, 480, 7931, 9, 480, 1, 481, 1, 481,
		1, 481, 1, 481, 1, 482, 1, 482, 5, 482, 7939, 8, 482, 10, 482, 12, 482,
		7942, 9, 482, 1, 483, 1, 483, 1, 483, 1, 483, 1, 484, 1, 484, 1, 485, 1,
		485, 1, 485, 1, 486, 1, 486, 1, 486, 1, 486, 3, 486, 7957, 8, 486, 1, 486,
		3, 486, 7960, 8, 486, 1, 487, 1, 487, 1, 487, 1, 487, 3, 487, 7966, 8,
		487, 1, 488, 1, 488, 1, 489, 1, 489, 1, 490, 1, 490, 1, 491, 1, 491, 1,
		492, 1, 492, 1, 492, 1, 492, 1, 493, 1, 493, 1, 493, 1, 493, 1, 494, 1,
		494, 1, 495, 1, 495, 1, 496, 1, 496, 1, 497, 1, 497, 1, 497, 1, 497, 1,
		497, 3, 497, 7995, 8, 497, 1, 498, 1, 498, 1, 498, 1, 498, 1, 498, 1, 499,
		1, 499, 1, 499, 1, 499, 1, 499, 1, 499, 1, 499, 1, 500, 1, 500, 3, 500,
		8011, 8, 500, 1, 500, 1, 500, 1, 501, 1, 501, 1, 501, 5, 501, 8018, 8,
		501, 10, 501, 12, 501, 8021, 9, 501, 1, 502, 1, 502, 1, 502, 1, 502, 1,
		502, 1, 503, 1, 503, 1, 503, 1, 503, 1, 504, 1, 504, 1, 504, 3, 504, 8035,
		8, 504, 1, 504, 1, 504, 3, 504, 8039, 8, 504, 1, 504, 1, 504, 3, 504, 8043,
		8, 504, 1, 504, 1, 504, 3, 504, 8047, 8, 504, 1, 504, 1, 504, 3, 504, 8051,
		8, 504, 1, 504, 1, 504, 3, 504, 8055, 8, 504, 1, 504, 1, 504, 3, 504, 8059,
		8, 504, 1, 504, 1, 504, 3, 504, 8063, 8, 504, 1, 504, 1, 504, 3, 504, 8067,
		8, 504, 1, 504, 1, 504, 3, 504, 8071, 8, 504, 1, 504, 1, 504, 1, 504, 1,
		504, 1, 504, 1, 504, 1, 504, 3, 504, 8080, 8, 504, 1, 504, 1, 504, 3, 504,
		8084, 8, 504, 1, 504, 1, 504, 1, 504, 1, 504, 1, 504, 1, 504, 1, 504, 1,
		504, 3, 504, 8094, 8, 504, 1, 504, 1, 504, 3, 504, 8098, 8, 504, 3, 504,
		8100, 8, 504, 1, 505, 1, 505, 1, 505, 1, 505, 1, 505, 3, 505, 8107, 8,
		505, 1, 505, 3, 505, 8110, 8, 505, 1, 506, 1, 506, 1, 506, 1, 506, 5, 506,
		8116, 8, 506, 10, 506, 12, 506, 8119, 9, 506, 1, 507, 1, 507, 1, 508, 3,
		508, 8124, 8, 508, 1, 508, 1, 508, 1, 508, 1, 508, 1, 508, 1, 509, 1, 509,
		1, 509, 1, 509, 3, 509, 8135, 8, 509, 1, 510, 1, 510, 1, 510, 3, 510, 8140,
		8, 510, 1, 511, 1, 511, 1, 511, 1, 511, 5, 511, 8146, 8, 511, 10, 511,
		12, 511, 8149, 9, 511, 1, 511, 1, 511, 1, 512, 1, 512, 1, 512, 1, 512,
		5, 512, 8157, 8, 512, 10, 512, 12, 512, 8160, 9, 512, 1, 512, 1, 512, 1,
		513, 1, 513, 3, 513, 8166, 8, 513, 1, 514, 1, 514, 1, 514, 5, 514, 8171,
		8, 514, 10, 514, 12, 514, 8174, 9, 514, 1, 515, 1, 515, 1, 515, 3, 515,
		8179, 8, 515, 1, 516, 1, 516, 1, 516, 1, 516, 1, 516, 1, 516, 1, 516, 1,
		516, 1, 516, 1, 516, 1, 516, 3, 516, 8192, 8, 516, 1, 517, 1, 517, 1, 517,
		1, 517, 1, 518, 1, 518, 1, 518, 5, 518, 8201, 8, 518, 10, 518, 12, 518,
		8204, 9, 518, 1, 519, 1, 519, 1, 519, 3, 519, 8209, 8, 519, 1, 520, 1,
		520, 1, 520, 1, 4135, 5, 764, 852, 856, 864, 866, 521, 0, 2, 4, 6, 8, 10,
		12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46,
		48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82,
		84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114,
		116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144,
		146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174,
		176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204,
		206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234,
		236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264,
		266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294,
		296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322, 324,
		326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354,
		356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 382, 384,
		386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408, 410, 412, 414,
		416, 418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442, 444,
		446, 448, 450, 452, 454, 456, 458, 460, 462, 464, 466, 468, 470, 472, 474,
		476, 478, 480, 482, 484, 486, 488, 490, 492, 494, 496, 498, 500, 502, 504,
		506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534,
		536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562, 564,
		566, 568, 570, 572, 574, 576, 578, 580, 582, 584, 586, 588, 590, 592, 594,
		596, 598, 600, 602, 604, 606, 608, 610, 612, 614, 616, 618, 620, 622, 624,
		626, 628, 630, 632, 634, 636, 638, 640, 642, 644, 646, 648, 650, 652, 654,
		656, 658, 660, 662, 664, 666, 668, 670, 672, 674, 676, 678, 680, 682, 684,
		686, 688, 690, 692, 694, 696, 698, 700, 702, 704, 706, 708, 710, 712, 714,
		716, 718, 720, 722, 724, 726, 728, 730, 732, 734, 736, 738, 740, 742, 744,
		746, 748, 750, 752, 754, 756, 758, 760, 762, 764, 766, 768, 770, 772, 774,
		776, 778, 780, 782, 784, 786, 788, 790, 792, 794, 796, 798, 800, 802, 804,
		806, 808, 810, 812, 814, 816, 818, 820, 822, 824, 826, 828, 830, 832, 834,
		836, 838, 840, 842, 844, 846, 848, 850, 852, 854, 856, 858, 860, 862, 864,
		866, 868, 870, 872, 874, 876, 878, 880, 882, 884, 886, 888, 890, 892, 894,
		896, 898, 900, 902, 904, 906, 908, 910, 912, 914, 916, 918, 920, 922, 924,
		926, 928, 930, 932, 934, 936, 938, 940, 942, 944, 946, 948, 950, 952, 954,
		956, 958, 960, 962, 964, 966, 968, 970, 972, 974, 976, 978, 980, 982, 984,
		986, 988, 990, 992, 994, 996, 998, 1000, 1002, 1004, 1006, 1008, 1010,
		1012, 1014, 1016, 1018, 1020, 1022, 1024, 1026, 1028, 1030, 1032, 1034,
		1036, 1038, 1040, 0, 65, 1, 1, 532, 532, 2, 0, 172, 172, 202, 202, 2, 0,
		104, 104, 387, 387, 2, 0, 151, 151, 428, 428, 4, 0, 17, 17, 134, 134, 323,
		323, 451, 451, 4, 0, 44, 44, 220, 220, 276, 276, 466, 466, 2, 0, 77, 77,
		157, 157, 3, 0, 76, 76, 294, 294, 376, 376, 1, 0, 125, 126, 2, 0, 205,
		206, 227, 228, 2, 0, 219, 219, 280, 280, 2, 0, 13, 13, 270, 270, 2, 0,
		29, 29, 417, 417, 2, 0, 127, 127, 137, 137, 2, 0, 167, 167, 286, 286, 2,
		0, 202, 202, 440, 440, 2, 0, 38, 38, 94, 94, 3, 0, 109, 109, 194, 194,
		265, 265, 2, 0, 218, 218, 221, 221, 2, 0, 175, 175, 384, 384, 2, 0, 224,
		224, 408, 408, 2, 0, 54, 54, 178, 178, 2, 0, 17, 17, 422, 422, 2, 0, 176,
		176, 328, 328, 1, 0, 424, 425, 2, 0, 142, 142, 475, 475, 1, 0, 458, 459,
		2, 0, 27, 27, 55, 55, 1, 0, 60, 61, 2, 0, 173, 173, 518, 518, 2, 0, 71,
		71, 73, 73, 3, 0, 419, 419, 434, 434, 468, 468, 3, 0, 145, 145, 266, 266,
		450, 450, 2, 0, 28, 28, 125, 125, 2, 0, 161, 161, 233, 233, 2, 0, 18, 18,
		128, 128, 1, 0, 145, 146, 1, 0, 303, 304, 2, 0, 110, 110, 132, 132, 2,
		0, 21, 21, 506, 506, 2, 0, 297, 297, 505, 505, 3, 0, 240, 240, 350, 350,
		372, 372, 3, 0, 268, 268, 502, 504, 508, 508, 1, 0, 500, 501, 2, 0, 500,
		501, 512, 512, 1, 0, 106, 107, 2, 0, 166, 166, 320, 320, 1, 0, 176, 177,
		1, 0, 422, 423, 1, 0, 469, 470, 2, 0, 125, 126, 149, 149, 5, 0, 20, 20,
		88, 88, 250, 250, 386, 386, 467, 467, 5, 0, 18, 18, 249, 249, 346, 346,
		433, 433, 462, 462, 2, 0, 120, 120, 199, 199, 2, 0, 12, 12, 203, 203, 4,
		0, 178, 178, 244, 244, 395, 395, 467, 467, 1, 0, 521, 522, 1, 0, 523, 524,
		1, 0, 492, 498, 2, 0, 156, 156, 444, 444, 4, 0, 108, 108, 193, 193, 264,
		264, 389, 389, 9, 0, 108, 108, 193, 193, 261, 262, 264, 264, 271, 271,
		337, 337, 389, 389, 476, 476, 483, 483, 2, 0, 62, 62, 164, 164, 2, 0, 111,
		115, 284, 285, 93, 0, 11, 12, 14, 17, 22, 23, 25, 26, 29, 40, 43, 43, 45,
		49, 51, 54, 56, 57, 59, 63, 66, 66, 68, 73, 75, 75, 77, 81, 83, 86, 88,
		89, 93, 95, 102, 103, 106, 110, 116, 116, 121, 123, 127, 127, 129, 130,
		134, 135, 137, 147, 150, 155, 157, 158, 160, 161, 164, 167, 170, 171, 173,
		174, 177, 178, 180, 180, 185, 186, 188, 189, 191, 196, 198, 198, 201, 201,
		203, 204, 206, 206, 209, 209, 213, 215, 217, 217, 221, 221, 223, 224, 230,
		230, 233, 233, 238, 239, 242, 242, 244, 244, 247, 258, 260, 260, 263, 267,
		269, 280, 283, 289, 291, 293, 295, 296, 304, 309, 311, 321, 324, 327, 329,
		342, 344, 344, 346, 349, 352, 352, 354, 355, 357, 368, 370, 370, 373, 378,
		381, 386, 389, 390, 392, 395, 397, 397, 399, 400, 403, 412, 414, 417, 419,
		421, 423, 428, 430, 430, 432, 436, 438, 439, 441, 443, 445, 449, 452, 453,
		456, 456, 458, 459, 461, 461, 463, 463, 465, 476, 479, 479, 481, 488, 490,
		491, 499, 499, 533, 533, 9260, 0, 1043, 1, 0, 0, 0, 2, 1053, 1, 0, 0, 0,
		4, 1055, 1, 0, 0, 0, 6, 1297, 1, 0, 0, 0, 8, 1299, 1, 0, 0, 0, 10, 1302,
		1, 0, 0, 0, 12, 1305, 1, 0, 0, 0, 14, 1329, 1, 0, 0, 0, 16, 1347, 1, 0,
		0, 0, 18, 1349, 1, 0, 0, 0, 20, 1371, 1, 0, 0, 0, 22, 1386, 1, 0, 0, 0,
		24, 1391, 1, 0, 0, 0, 26, 1397, 1, 0, 0, 0, 28, 1407, 1, 0, 0, 0, 30, 1409,
		1, 0, 0, 0, 32, 1417, 1, 0, 0, 0, 34, 1475, 1, 0, 0, 0, 36, 1507, 1, 0,
		0, 0, 38, 1509, 1, 0, 0, 0, 40, 1521, 1, 0, 0, 0, 42, 1524, 1, 0, 0, 0,
		44, 1536, 1, 0, 0, 0, 46, 1541, 1, 0, 0, 0, 48, 1556, 1, 0, 0, 0, 50, 1564,
		1, 0, 0, 0, 52, 1568, 1, 0, 0, 0, 54, 1575, 1, 0, 0, 0, 56, 1577, 1, 0,
		0, 0, 58, 1581, 1, 0, 0, 0, 60, 1602, 1, 0, 0, 0, 62, 1604, 1, 0, 0, 0,
		64, 1616, 1, 0, 0, 0, 66, 1627, 1, 0, 0, 0, 68, 1631, 1, 0, 0, 0, 70, 1636,
		1, 0, 0, 0, 72, 1641, 1, 0, 0, 0, 74, 1643, 1, 0, 0, 0, 76, 1705, 1, 0,
		0, 0, 78, 1718, 1, 0, 0, 0, 80, 1762, 1, 0, 0, 0, 82, 1764, 1, 0, 0, 0,
		84, 1779, 1, 0, 0, 0, 86, 1785, 1, 0, 0, 0, 88, 1788, 1, 0, 0, 0, 90, 1803,
		1, 0, 0, 0, 92, 1816, 1, 0, 0, 0, 94, 1826, 1, 0, 0, 0, 96, 1844, 1, 0,
		0, 0, 98, 1857, 1, 0, 0, 0, 100, 1929, 1, 0, 0, 0, 102, 1931, 1, 0, 0,
		0, 104, 1940, 1, 0, 0, 0, 106, 1963, 1, 0, 0, 0, 108, 1972, 1, 0, 0, 0,
		110, 1976, 1, 0, 0, 0, 112, 2008, 1, 0, 0, 0, 114, 2010, 1, 0, 0, 0, 116,
		2036, 1, 0, 0, 0, 118, 2042, 1, 0, 0, 0, 120, 2116, 1, 0, 0, 0, 122, 2118,
		1, 0, 0, 0, 124, 2126, 1, 0, 0, 0, 126, 2130, 1, 0, 0, 0, 128, 2149, 1,
		0, 0, 0, 130, 2151, 1, 0, 0, 0, 132, 2157, 1, 0, 0, 0, 134, 2170, 1, 0,
		0, 0, 136, 2223, 1, 0, 0, 0, 138, 2232, 1, 0, 0, 0, 140, 2234, 1, 0, 0,
		0, 142, 2247, 1, 0, 0, 0, 144, 2272, 1, 0, 0, 0, 146, 2274, 1, 0, 0, 0,
		148, 2298, 1, 0, 0, 0, 150, 2306, 1, 0, 0, 0, 152, 2317, 1, 0, 0, 0, 154,
		2323, 1, 0, 0, 0, 156, 2331, 1, 0, 0, 0, 158, 2340, 1, 0, 0, 0, 160, 2353,
		1, 0, 0, 0, 162, 2360, 1, 0, 0, 0, 164, 2368, 1, 0, 0, 0, 166, 2376, 1,
		0, 0, 0, 168, 2391, 1, 0, 0, 0, 170, 2402, 1, 0, 0, 0, 172, 2404, 1, 0,
		0, 0, 174, 2415, 1, 0, 0, 0, 176, 2422, 1, 0, 0, 0, 178, 2426, 1, 0, 0,
		0, 180, 2437, 1, 0, 0, 0, 182, 2441, 1, 0, 0, 0, 184, 2455, 1, 0, 0, 0,
		186, 2460, 1, 0, 0, 0, 188, 2468, 1, 0, 0, 0, 190, 2474, 1, 0, 0, 0, 192,
		2479, 1, 0, 0, 0, 194, 2496, 1, 0, 0, 0, 196, 2500, 1, 0, 0, 0, 198, 2504,
		1, 0, 0, 0, 200, 2511, 1, 0, 0, 0, 202, 2520, 1, 0, 0, 0, 204, 2534, 1,
		0, 0, 0, 206, 2536, 1, 0, 0, 0, 208, 2539, 1, 0, 0, 0, 210, 2543, 1, 0,
		0, 0, 212, 2548, 1, 0, 0, 0, 214, 2555, 1, 0, 0, 0, 216, 2576, 1, 0, 0,
		0, 218, 2587, 1, 0, 0, 0, 220, 2605, 1, 0, 0, 0, 222, 2611, 1, 0, 0, 0,
		224, 2615, 1, 0, 0, 0, 226, 2620, 1, 0, 0, 0, 228, 2631, 1, 0, 0, 0, 230,
		2633, 1, 0, 0, 0, 232, 2683, 1, 0, 0, 0, 234, 2685, 1, 0, 0, 0, 236, 2689,
		1, 0, 0, 0, 238, 2693, 1, 0, 0, 0, 240, 2700, 1, 0, 0, 0, 242, 2719, 1,
		0, 0, 0, 244, 2741, 1, 0, 0, 0, 246, 2764, 1, 0, 0, 0, 248, 2766, 1, 0,
		0, 0, 250, 2786, 1, 0, 0, 0, 252, 2832, 1, 0, 0, 0, 254, 2834, 1, 0, 0,
		0, 256, 2841, 1, 0, 0, 0, 258, 2844, 1, 0, 0, 0, 260, 2849, 1, 0, 0, 0,
		262, 2863, 1, 0, 0, 0, 264, 2878, 1, 0, 0, 0, 266, 2892, 1, 0, 0, 0, 268,
		2907, 1, 0, 0, 0, 270, 2920, 1, 0, 0, 0, 272, 2924, 1, 0, 0, 0, 274, 2927,
		1, 0, 0, 0, 276, 2931, 1, 0, 0, 0, 278, 2934, 1, 0, 0, 0, 280, 2938, 1,
		0, 0, 0, 282, 2944, 1, 0, 0, 0, 284, 2961, 1, 0, 0, 0, 286, 2976, 1, 0,
		0, 0, 288, 2995, 1, 0, 0, 0, 290, 3005, 1, 0, 0, 0, 292, 3020, 1, 0, 0,
		0, 294, 3025, 1, 0, 0, 0, 296, 3031, 1, 0, 0, 0, 298, 3041, 1, 0, 0, 0,
		300, 3047, 1, 0, 0, 0, 302, 3056, 1, 0, 0, 0, 304, 3058, 1, 0, 0, 0, 306,
		3067, 1, 0, 0, 0, 308, 3081, 1, 0, 0, 0, 310, 3109, 1, 0, 0, 0, 312, 3130,
		1, 0, 0, 0, 314, 3132, 1, 0, 0, 0, 316, 3140, 1, 0, 0, 0, 318, 3148, 1,
		0, 0, 0, 320, 3155, 1, 0, 0, 0, 322, 3164, 1, 0, 0, 0, 324, 3186, 1, 0,
		0, 0, 326, 3188, 1, 0, 0, 0, 328, 3192, 1, 0, 0, 0, 330, 3195, 1, 0, 0,
		0, 332, 3198, 1, 0, 0, 0, 334, 3200, 1, 0, 0, 0, 336, 3202, 1, 0, 0, 0,
		338, 3213, 1, 0, 0, 0, 340, 3249, 1, 0, 0, 0, 342, 3306, 1, 0, 0, 0, 344,
		3308, 1, 0, 0, 0, 346, 3325, 1, 0, 0, 0, 348, 3327, 1, 0, 0, 0, 350, 3334,
		1, 0, 0, 0, 352, 3340, 1, 0, 0, 0, 354, 3383, 1, 0, 0, 0, 356, 3388, 1,
		0, 0, 0, 358, 3391, 1, 0, 0, 0, 360, 3406, 1, 0, 0, 0, 362, 3425, 1, 0,
		0, 0, 364, 3454, 1, 0, 0, 0, 366, 3480, 1, 0, 0, 0, 368, 3490, 1, 0, 0,
		0, 370, 3492, 1, 0, 0, 0, 372, 3497, 1, 0, 0, 0, 374, 3502, 1, 0, 0, 0,
		376, 3505, 1, 0, 0, 0, 378, 3522, 1, 0, 0, 0, 380, 3524, 1, 0, 0, 0, 382,
		3526, 1, 0, 0, 0, 384, 3537, 1, 0, 0, 0, 386, 3548, 1, 0, 0, 0, 388, 3559,
		1, 0, 0, 0, 390, 3597, 1, 0, 0, 0, 392, 3608, 1, 0, 0, 0, 394, 3619, 1,
		0, 0, 0, 396, 3657, 1, 0, 0, 0, 398, 3713, 1, 0, 0, 0, 400, 3715, 1, 0,
		0, 0, 402, 3723, 1, 0, 0, 0, 404, 3738, 1, 0, 0, 0, 406, 3744, 1, 0, 0,
		0, 408, 3802, 1, 0, 0, 0, 410, 3811, 1, 0, 0, 0, 412, 3813, 1, 0, 0, 0,
		414, 3837, 1, 0, 0, 0, 416, 3863, 1, 0, 0, 0, 418, 3885, 1, 0, 0, 0, 420,
		3906, 1, 0, 0, 0, 422, 3908, 1, 0, 0, 0, 424, 3922, 1, 0, 0, 0, 426, 3932,
		1, 0, 0, 0, 428, 3935, 1, 0, 0, 0, 430, 3971, 1, 0, 0, 0, 432, 4028, 1,
		0, 0, 0, 434, 4046, 1, 0, 0, 0, 436, 4057, 1, 0, 0, 0, 438, 4059, 1, 0,
		0, 0, 440, 4068, 1, 0, 0, 0, 442, 4074, 1, 0, 0, 0, 444, 4078, 1, 0, 0,
		0, 446, 4081, 1, 0, 0, 0, 448, 4085, 1, 0, 0, 0, 450, 4103, 1, 0, 0, 0,
		452, 4117, 1, 0, 0, 0, 454, 4140, 1, 0, 0, 0, 456, 4144, 1, 0, 0, 0, 458,
		4185, 1, 0, 0, 0, 460, 4190, 1, 0, 0, 0, 462, 4194, 1, 0, 0, 0, 464, 4274,
		1, 0, 0, 0, 466, 4276, 1, 0, 0, 0, 468, 4310, 1, 0, 0, 0, 470, 4312, 1,
		0, 0, 0, 472, 4318, 1, 0, 0, 0, 474, 4365, 1, 0, 0, 0, 476, 4367, 1, 0,
		0, 0, 478, 4377, 1, 0, 0, 0, 480, 4389, 1, 0, 0, 0, 482, 4394, 1, 0, 0,
		0, 484, 4397, 1, 0, 0, 0, 486, 4400, 1, 0, 0, 0, 488, 4403, 1, 0, 0, 0,
		490, 4417, 1, 0, 0, 0, 492, 4425, 1, 0, 0, 0, 494, 4431, 1, 0, 0, 0, 496,
		4439, 1, 0, 0, 0, 498, 4451, 1, 0, 0, 0, 500, 4454, 1, 0, 0, 0, 502, 4457,
		1, 0, 0, 0, 504, 4460, 1, 0, 0, 0, 506, 4463, 1, 0, 0, 0, 508, 4467, 1,
		0, 0, 0, 510, 4470, 1, 0, 0, 0, 512, 4479, 1, 0, 0, 0, 514, 4483, 1, 0,
		0, 0, 516, 4492, 1, 0, 0, 0, 518, 4498, 1, 0, 0, 0, 520, 4505, 1, 0, 0,
		0, 522, 4545, 1, 0, 0, 0, 524, 4547, 1, 0, 0, 0, 526, 4557, 1, 0, 0, 0,
		528, 4592, 1, 0, 0, 0, 530, 4594, 1, 0, 0, 0, 532, 4605, 1, 0, 0, 0, 534,
		4610, 1, 0, 0, 0, 536, 4613, 1, 0, 0, 0, 538, 4632, 1, 0, 0, 0, 540, 4673,
		1, 0, 0, 0, 542, 4675, 1, 0, 0, 0, 544, 4687, 1, 0, 0, 0, 546, 4689, 1,
		0, 0, 0, 548, 4697, 1, 0, 0, 0, 550, 4708, 1, 0, 0, 0, 552, 4720, 1, 0,
		0, 0, 554, 4728, 1, 0, 0, 0, 556, 4745, 1, 0, 0, 0, 558, 4761, 1, 0, 0,
		0, 560, 4779, 1, 0, 0, 0, 562, 4781, 1, 0, 0, 0, 564, 4798, 1, 0, 0, 0,
		566, 4888, 1, 0, 0, 0, 568, 4954, 1, 0, 0, 0, 570, 4970, 1, 0, 0, 0, 572,
		4985, 1, 0, 0, 0, 574, 4987, 1, 0, 0, 0, 576, 4992, 1, 0, 0, 0, 578, 5000,
		1, 0, 0, 0, 580, 5015, 1, 0, 0, 0, 582, 5066, 1, 0, 0, 0, 584, 5082, 1,
		0, 0, 0, 586, 5102, 1, 0, 0, 0, 588, 5104, 1, 0, 0, 0, 590, 5110, 1, 0,
		0, 0, 592, 5117, 1, 0, 0, 0, 594, 5122, 1, 0, 0, 0, 596, 5126, 1, 0, 0,
		0, 598, 5132, 1, 0, 0, 0, 600, 5138, 1, 0, 0, 0, 602, 5143, 1, 0, 0, 0,
		604, 5147, 1, 0, 0, 0, 606, 5153, 1, 0, 0, 0, 608, 5188, 1, 0, 0, 0, 610,
		5197, 1, 0, 0, 0, 612, 5203, 1, 0, 0, 0, 614, 5242, 1, 0, 0, 0, 616, 5251,
		1, 0, 0, 0, 618, 5261, 1, 0, 0, 0, 620, 5269, 1, 0, 0, 0, 622, 5288, 1,
		0, 0, 0, 624, 5292, 1, 0, 0, 0, 626, 5296, 1, 0, 0, 0, 628, 5306, 1, 0,
		0, 0, 630, 5309, 1, 0, 0, 0, 632, 5312, 1, 0, 0, 0, 634, 5323, 1, 0, 0,
		0, 636, 5334, 1, 0, 0, 0, 638, 5338, 1, 0, 0, 0, 640, 5344, 1, 0, 0, 0,
		642, 5361, 1, 0, 0, 0, 644, 5365, 1, 0, 0, 0, 646, 5370, 1, 0, 0, 0, 648,
		5374, 1, 0, 0, 0, 650, 5393, 1, 0, 0, 0, 652, 5412, 1, 0, 0, 0, 654, 5424,
		1, 0, 0, 0, 656, 5451, 1, 0, 0, 0, 658, 5458, 1, 0, 0, 0, 660, 5462, 1,
		0, 0, 0, 662, 5471, 1, 0, 0, 0, 664, 5480, 1, 0, 0, 0, 666, 5486, 1, 0,
		0, 0, 668, 5497, 1, 0, 0, 0, 670, 5514, 1, 0, 0, 0, 672, 5516, 1, 0, 0,
		0, 674, 5521, 1, 0, 0, 0, 676, 5525, 1, 0, 0, 0, 678, 5550, 1, 0, 0, 0,
		680, 5624, 1, 0, 0, 0, 682, 5636, 1, 0, 0, 0, 684, 5642, 1, 0, 0, 0, 686,
		5644, 1, 0, 0, 0, 688, 5655, 1, 0, 0, 0, 690, 5661, 1, 0, 0, 0, 692, 5663,
		1, 0, 0, 0, 694, 5671, 1, 0, 0, 0, 696, 5679, 1, 0, 0, 0, 698, 5697, 1,
		0, 0, 0, 700, 5699, 1, 0, 0, 0, 702, 5716, 1, 0, 0, 0, 704, 5718, 1, 0,
		0, 0, 706, 5724, 1, 0, 0, 0, 708, 5728, 1, 0, 0, 0, 710, 5734, 1, 0, 0,
		0, 712, 5738, 1, 0, 0, 0, 714, 5752, 1, 0, 0, 0, 716, 5760, 1, 0, 0, 0,
		718, 5768, 1, 0, 0, 0, 720, 5776, 1, 0, 0, 0, 722, 5786, 1, 0, 0, 0, 724,
		5792, 1, 0, 0, 0, 726, 5815, 1, 0, 0, 0, 728, 5817, 1, 0, 0, 0, 730, 5822,
		1, 0, 0, 0, 732, 5839, 1, 0, 0, 0, 734, 5852, 1, 0, 0, 0, 736, 5859, 1,
		0, 0, 0, 738, 5866, 1, 0, 0, 0, 740, 5885, 1, 0, 0, 0, 742, 5887, 1, 0,
		0, 0, 744, 5904, 1, 0, 0, 0, 746, 5921, 1, 0, 0, 0, 748, 5925, 1, 0, 0,
		0, 750, 5928, 1, 0, 0, 0, 752, 5934, 1, 0, 0, 0, 754, 5941, 1, 0, 0, 0,
		756, 5945, 1, 0, 0, 0, 758, 5954, 1, 0, 0, 0, 760, 6002, 1, 0, 0, 0, 762,
		6004, 1, 0, 0, 0, 764, 6009, 1, 0, 0, 0, 766, 6028, 1, 0, 0, 0, 768, 6032,
		1, 0, 0, 0, 770, 6036, 1, 0, 0, 0, 772, 6047, 1, 0, 0, 0, 774, 6060, 1,
		0, 0, 0, 776, 6062, 1, 0, 0, 0, 778, 6104, 1, 0, 0, 0, 780, 6132, 1, 0,
		0, 0, 782, 6134, 1, 0, 0, 0, 784, 6147, 1, 0, 0, 0, 786, 6156, 1, 0, 0,
		0, 788, 6178, 1, 0, 0, 0, 790, 6180, 1, 0, 0, 0, 792, 6192, 1, 0, 0, 0,
		794, 6220, 1, 0, 0, 0, 796, 6325, 1, 0, 0, 0, 798, 6327, 1, 0, 0, 0, 800,
		6355, 1, 0, 0, 0, 802, 6367, 1, 0, 0, 0, 804, 6378, 1, 0, 0, 0, 806, 6384,
		1, 0, 0, 0, 808, 6386, 1, 0, 0, 0, 810, 6394, 1, 0, 0, 0, 812, 6419, 1,
		0, 0, 0, 814, 6427, 1, 0, 0, 0, 816, 6456, 1, 0, 0, 0, 818, 6476, 1, 0,
		0, 0, 820, 6478, 1, 0, 0, 0, 822, 6496, 1, 0, 0, 0, 824, 6498, 1, 0, 0,
		0, 826, 6530, 1, 0, 0, 0, 828, 6532, 1, 0, 0, 0, 830, 6544, 1, 0, 0, 0,
		832, 6556, 1, 0, 0, 0, 834, 6563, 1, 0, 0, 0, 836, 6565, 1, 0, 0, 0, 838,
		6580, 1, 0, 0, 0, 840, 6584, 1, 0, 0, 0, 842, 6596, 1, 0, 0, 0, 844, 6609,
		1, 0, 0, 0, 846, 6611, 1, 0, 0, 0, 848, 6619, 1, 0, 0, 0, 850, 6623, 1,
		0, 0, 0, 852, 6633, 1, 0, 0, 0, 854, 6646, 1, 0, 0, 0, 856, 6654, 1, 0,
		0, 0, 858, 6683, 1, 0, 0, 0, 860, 6685, 1, 0, 0, 0, 862, 6731, 1, 0, 0,
		0, 864, 6733, 1, 0, 0, 0, 866, 6870, 1, 0, 0, 0, 868, 6926, 1, 0, 0, 0,
		870, 7000, 1, 0, 0, 0, 872, 7127, 1, 0, 0, 0, 874, 7129, 1, 0, 0, 0, 876,
		7132, 1, 0, 0, 0, 878, 7141, 1, 0, 0, 0, 880, 7170, 1, 0, 0, 0, 882, 7200,
		1, 0, 0, 0, 884, 7343, 1, 0, 0, 0, 886, 7442, 1, 0, 0, 0, 888, 7444, 1,
		0, 0, 0, 890, 7449, 1, 0, 0, 0, 892, 7483, 1, 0, 0, 0, 894, 7502, 1, 0,
		0, 0, 896, 7513, 1, 0, 0, 0, 898, 7554, 1, 0, 0, 0, 900, 7556, 1, 0, 0,
		0, 902, 7560, 1, 0, 0, 0, 904, 7568, 1, 0, 0, 0, 906, 7572, 1, 0, 0, 0,
		908, 7579, 1, 0, 0, 0, 910, 7669, 1, 0, 0, 0, 912, 7673, 1, 0, 0, 0, 914,
		7675, 1, 0, 0, 0, 916, 7688, 1, 0, 0, 0, 918, 7701, 1, 0, 0, 0, 920, 7712,
		1, 0, 0, 0, 922, 7725, 1, 0, 0, 0, 924, 7729, 1, 0, 0, 0, 926, 7731, 1,
		0, 0, 0, 928, 7742, 1, 0, 0, 0, 930, 7755, 1, 0, 0, 0, 932, 7757, 1, 0,
		0, 0, 934, 7795, 1, 0, 0, 0, 936, 7797, 1, 0, 0, 0, 938, 7818, 1, 0, 0,
		0, 940, 7820, 1, 0, 0, 0, 942, 7831, 1, 0, 0, 0, 944, 7837, 1, 0, 0, 0,
		946, 7851, 1, 0, 0, 0, 948, 7872, 1, 0, 0, 0, 950, 7874, 1, 0, 0, 0, 952,
		7896, 1, 0, 0, 0, 954, 7898, 1, 0, 0, 0, 956, 7910, 1, 0, 0, 0, 958, 7913,
		1, 0, 0, 0, 960, 7924, 1, 0, 0, 0, 962, 7932, 1, 0, 0, 0, 964, 7936, 1,
		0, 0, 0, 966, 7943, 1, 0, 0, 0, 968, 7947, 1, 0, 0, 0, 970, 7949, 1, 0,
		0, 0, 972, 7952, 1, 0, 0, 0, 974, 7961, 1, 0, 0, 0, 976, 7967, 1, 0, 0,
		0, 978, 7969, 1, 0, 0, 0, 980, 7971, 1, 0, 0, 0, 982, 7973, 1, 0, 0, 0,
		984, 7975, 1, 0, 0, 0, 986, 7979, 1, 0, 0, 0, 988, 7983, 1, 0, 0, 0, 990,
		7985, 1, 0, 0, 0, 992, 7987, 1, 0, 0, 0, 994, 7994, 1, 0, 0, 0, 996, 7996,
		1, 0, 0, 0, 998, 8001, 1, 0, 0, 0, 1000, 8010, 1, 0, 0, 0, 1002, 8014,
		1, 0, 0, 0, 1004, 8022, 1, 0, 0, 0, 1006, 8027, 1, 0, 0, 0, 1008, 8099,
		1, 0, 0, 0, 1010, 8101, 1, 0, 0, 0, 1012, 8111, 1, 0, 0, 0, 1014, 8120,
		1, 0, 0, 0, 1016, 8123, 1, 0, 0, 0, 1018, 8134, 1, 0, 0, 0, 1020, 8136,
		1, 0, 0, 0, 1022, 8141, 1, 0, 0, 0, 1024, 8152, 1, 0, 0, 0, 1026, 8165,
		1, 0, 0, 0, 1028, 8167, 1, 0, 0, 0, 1030, 8178, 1, 0, 0, 0, 1032, 8191,
		1, 0, 0, 0, 1034, 8193, 1, 0, 0, 0, 1036, 8197, 1, 0, 0, 0, 1038, 8208,
		1, 0, 0, 0, 1040, 8210, 1, 0, 0, 0, 1042, 1044, 3, 2, 1, 0, 1043, 1042,
		1, 0, 0, 0, 1044, 1045, 1, 0, 0, 0, 1045, 1043, 1, 0, 0, 0, 1045, 1046,
		1, 0, 0, 0, 1046, 1047, 1, 0, 0, 0, 1047, 1048, 5, 0, 0, 1, 1048, 1, 1,
		0, 0, 0, 1049, 1050, 3, 6, 3, 0, 1050, 1051, 7, 0, 0, 0, 1051, 1054, 1,
		0, 0, 0, 1052, 1054, 3, 4, 2, 0, 1053, 1049, 1, 0, 0, 0, 1053, 1052, 1,
		0, 0, 0, 1054, 3, 1, 0, 0, 0, 1055, 1056, 5, 532, 0, 0, 1056, 5, 1, 0,
		0, 0, 1057, 1298, 3, 752, 376, 0, 1058, 1298, 3, 8, 4, 0, 1059, 1298, 3,
		10, 5, 0, 1060, 1298, 3, 12, 6, 0, 1061, 1298, 3, 14, 7, 0, 1062, 1298,
		3, 16, 8, 0, 1063, 1298, 3, 18, 9, 0, 1064, 1298, 3, 20, 10, 0, 1065, 1298,
		3, 22, 11, 0, 1066, 1298, 3, 24, 12, 0, 1067, 1298, 3, 26, 13, 0, 1068,
		1298, 3, 28, 14, 0, 1069, 1298, 3, 30, 15, 0, 1070, 1298, 3, 32, 16, 0,
		1071, 1298, 3, 74, 37, 0, 1072, 1298, 3, 104, 52, 0, 1073, 1298, 3, 92,
		46, 0, 1074, 1298, 3, 76, 38, 0, 1075, 1298, 3, 78, 39, 0, 1076, 1298,
		3, 108, 54, 0, 1077, 1298, 3, 110, 55, 0, 1078, 1298, 3, 88, 44, 0, 1079,
		1298, 3, 102, 51, 0, 1080, 1298, 3, 96, 48, 0, 1081, 1298, 3, 94, 47, 0,
		1082, 1298, 3, 98, 49, 0, 1083, 1298, 3, 80, 40, 0, 1084, 1298, 3, 112,
		56, 0, 1085, 1298, 3, 100, 50, 0, 1086, 1298, 3, 90, 45, 0, 1087, 1298,
		3, 118, 59, 0, 1088, 1298, 3, 120, 60, 0, 1089, 1298, 3, 122, 61, 0, 1090,
		1298, 3, 114, 57, 0, 1091, 1298, 3, 116, 58, 0, 1092, 1298, 3, 82, 41,
		0, 1093, 1298, 3, 84, 42, 0, 1094, 1298, 3, 106, 53, 0, 1095, 1298, 3,
		126, 63, 0, 1096, 1298, 3, 130, 65, 0, 1097, 1298, 3, 134, 67, 0, 1098,
		1298, 3, 140, 70, 0, 1099, 1298, 3, 142, 71, 0, 1100, 1298, 3, 144, 72,
		0, 1101, 1298, 3, 146, 73, 0, 1102, 1298, 3, 148, 74, 0, 1103, 1298, 3,
		182, 91, 0, 1104, 1298, 3, 186, 93, 0, 1105, 1298, 3, 188, 94, 0, 1106,
		1298, 3, 184, 92, 0, 1107, 1298, 3, 190, 95, 0, 1108, 1298, 3, 352, 176,
		0, 1109, 1298, 3, 358, 179, 0, 1110, 1298, 3, 360, 180, 0, 1111, 1298,
		3, 362, 181, 0, 1112, 1298, 3, 364, 182, 0, 1113, 1298, 3, 382, 191, 0,
		1114, 1298, 3, 384, 192, 0, 1115, 1298, 3, 386, 193, 0, 1116, 1298, 3,
		388, 194, 0, 1117, 1298, 3, 390, 195, 0, 1118, 1298, 3, 392, 196, 0, 1119,
		1298, 3, 394, 197, 0, 1120, 1298, 3, 150, 75, 0, 1121, 1298, 3, 152, 76,
		0, 1122, 1298, 3, 154, 77, 0, 1123, 1298, 3, 156, 78, 0, 1124, 1298, 3,
		158, 79, 0, 1125, 1298, 3, 160, 80, 0, 1126, 1298, 3, 162, 81, 0, 1127,
		1298, 3, 164, 82, 0, 1128, 1298, 3, 166, 83, 0, 1129, 1298, 3, 168, 84,
		0, 1130, 1298, 3, 170, 85, 0, 1131, 1298, 3, 696, 348, 0, 1132, 1298, 3,
		172, 86, 0, 1133, 1298, 3, 174, 87, 0, 1134, 1298, 3, 176, 88, 0, 1135,
		1298, 3, 178, 89, 0, 1136, 1298, 3, 180, 90, 0, 1137, 1298, 3, 396, 198,
		0, 1138, 1298, 3, 400, 200, 0, 1139, 1298, 3, 408, 204, 0, 1140, 1298,
		3, 410, 205, 0, 1141, 1298, 3, 404, 202, 0, 1142, 1298, 3, 406, 203, 0,
		1143, 1298, 3, 412, 206, 0, 1144, 1298, 3, 414, 207, 0, 1145, 1298, 3,
		416, 208, 0, 1146, 1298, 3, 418, 209, 0, 1147, 1298, 3, 420, 210, 0, 1148,
		1298, 3, 428, 214, 0, 1149, 1298, 3, 430, 215, 0, 1150, 1298, 3, 432, 216,
		0, 1151, 1298, 3, 434, 217, 0, 1152, 1298, 3, 436, 218, 0, 1153, 1298,
		3, 438, 219, 0, 1154, 1298, 3, 440, 220, 0, 1155, 1298, 3, 442, 221, 0,
		1156, 1298, 3, 444, 222, 0, 1157, 1298, 3, 448, 224, 0, 1158, 1298, 3,
		450, 225, 0, 1159, 1298, 3, 452, 226, 0, 1160, 1298, 3, 458, 229, 0, 1161,
		1298, 3, 472, 236, 0, 1162, 1298, 3, 474, 237, 0, 1163, 1298, 3, 476, 238,
		0, 1164, 1298, 3, 478, 239, 0, 1165, 1298, 3, 482, 241, 0, 1166, 1298,
		3, 484, 242, 0, 1167, 1298, 3, 486, 243, 0, 1168, 1298, 3, 488, 244, 0,
		1169, 1298, 3, 490, 245, 0, 1170, 1298, 3, 492, 246, 0, 1171, 1298, 3,
		494, 247, 0, 1172, 1298, 3, 496, 248, 0, 1173, 1298, 3, 498, 249, 0, 1174,
		1298, 3, 500, 250, 0, 1175, 1298, 3, 502, 251, 0, 1176, 1298, 3, 504, 252,
		0, 1177, 1298, 3, 506, 253, 0, 1178, 1298, 3, 508, 254, 0, 1179, 1298,
		3, 510, 255, 0, 1180, 1298, 3, 512, 256, 0, 1181, 1298, 3, 514, 257, 0,
		1182, 1298, 3, 516, 258, 0, 1183, 1298, 3, 518, 259, 0, 1184, 1298, 3,
		520, 260, 0, 1185, 1298, 3, 522, 261, 0, 1186, 1298, 3, 524, 262, 0, 1187,
		1298, 3, 526, 263, 0, 1188, 1298, 3, 528, 264, 0, 1189, 1298, 3, 530, 265,
		0, 1190, 1298, 3, 532, 266, 0, 1191, 1298, 3, 534, 267, 0, 1192, 1298,
		3, 536, 268, 0, 1193, 1298, 3, 538, 269, 0, 1194, 1298, 3, 540, 270, 0,
		1195, 1298, 3, 542, 271, 0, 1196, 1298, 3, 544, 272, 0, 1197, 1298, 3,
		546, 273, 0, 1198, 1298, 3, 548, 274, 0, 1199, 1298, 3, 550, 275, 0, 1200,
		1298, 3, 552, 276, 0, 1201, 1298, 3, 554, 277, 0, 1202, 1298, 3, 556, 278,
		0, 1203, 1298, 3, 558, 279, 0, 1204, 1298, 3, 560, 280, 0, 1205, 1298,
		3, 562, 281, 0, 1206, 1298, 3, 566, 283, 0, 1207, 1298, 3, 568, 284, 0,
		1208, 1298, 3, 570, 285, 0, 1209, 1298, 3, 588, 294, 0, 1210, 1298, 3,
		590, 295, 0, 1211, 1298, 3, 592, 296, 0, 1212, 1298, 3, 594, 297, 0, 1213,
		1298, 3, 596, 298, 0, 1214, 1298, 3, 598, 299, 0, 1215, 1298, 3, 600, 300,
		0, 1216, 1298, 3, 602, 301, 0, 1217, 1298, 3, 604, 302, 0, 1218, 1298,
		3, 606, 303, 0, 1219, 1298, 3, 608, 304, 0, 1220, 1298, 3, 610, 305, 0,
		1221, 1298, 3, 612, 306, 0, 1222, 1298, 3, 614, 307, 0, 1223, 1298, 3,
		616, 308, 0, 1224, 1298, 3, 618, 309, 0, 1225, 1298, 3, 620, 310, 0, 1226,
		1298, 3, 622, 311, 0, 1227, 1298, 3, 624, 312, 0, 1228, 1298, 3, 626, 313,
		0, 1229, 1298, 3, 628, 314, 0, 1230, 1298, 3, 630, 315, 0, 1231, 1298,
		3, 632, 316, 0, 1232, 1298, 3, 634, 317, 0, 1233, 1298, 3, 636, 318, 0,
		1234, 1298, 3, 640, 320, 0, 1235, 1298, 3, 642, 321, 0, 1236, 1298, 3,
		644, 322, 0, 1237, 1298, 3, 646, 323, 0, 1238, 1298, 3, 648, 324, 0, 1239,
		1298, 3, 650, 325, 0, 1240, 1298, 3, 652, 326, 0, 1241, 1298, 3, 654, 327,
		0, 1242, 1298, 3, 656, 328, 0, 1243, 1298, 3, 658, 329, 0, 1244, 1298,
		3, 660, 330, 0, 1245, 1298, 3, 662, 331, 0, 1246, 1298, 3, 664, 332, 0,
		1247, 1298, 3, 678, 339, 0, 1248, 1298, 3, 692, 346, 0, 1249, 1298, 3,
		192, 96, 0, 1250, 1298, 3, 202, 101, 0, 1251, 1298, 3, 200, 100, 0, 1252,
		1298, 3, 198, 99, 0, 1253, 1298, 3, 210, 105, 0, 1254, 1298, 3, 212, 106,
		0, 1255, 1298, 3, 666, 333, 0, 1256, 1298, 3, 668, 334, 0, 1257, 1298,
		3, 672, 336, 0, 1258, 1298, 3, 676, 338, 0, 1259, 1298, 3, 674, 337, 0,
		1260, 1298, 3, 480, 240, 0, 1261, 1298, 3, 214, 107, 0, 1262, 1298, 3,
		216, 108, 0, 1263, 1298, 3, 832, 416, 0, 1264, 1298, 3, 836, 418, 0, 1265,
		1298, 3, 838, 419, 0, 1266, 1298, 3, 218, 109, 0, 1267, 1298, 3, 220, 110,
		0, 1268, 1298, 3, 222, 111, 0, 1269, 1298, 3, 224, 112, 0, 1270, 1298,
		3, 226, 113, 0, 1271, 1298, 3, 704, 352, 0, 1272, 1298, 3, 706, 353, 0,
		1273, 1298, 3, 708, 354, 0, 1274, 1298, 3, 710, 355, 0, 1275, 1298, 3,
		712, 356, 0, 1276, 1298, 3, 714, 357, 0, 1277, 1298, 3, 716, 358, 0, 1278,
		1298, 3, 718, 359, 0, 1279, 1298, 3, 720, 360, 0, 1280, 1298, 3, 722, 361,
		0, 1281, 1298, 3, 724, 362, 0, 1282, 1298, 3, 726, 363, 0, 1283, 1298,
		3, 728, 364, 0, 1284, 1298, 3, 730, 365, 0, 1285, 1298, 3, 732, 366, 0,
		1286, 1298, 3, 734, 367, 0, 1287, 1298, 3, 736, 368, 0, 1288, 1298, 3,
		738, 369, 0, 1289, 1298, 3, 740, 370, 0, 1290, 1298, 3, 742, 371, 0, 1291,
		1298, 3, 744, 372, 0, 1292, 1298, 3, 746, 373, 0, 1293, 1298, 3, 422, 211,
		0, 1294, 1298, 3, 424, 212, 0, 1295, 1298, 3, 426, 213, 0, 1296, 1298,
		3, 698, 349, 0, 1297, 1057, 1, 0, 0, 0, 1297, 1058, 1, 0, 0, 0, 1297, 1059,
		1, 0, 0, 0, 1297, 1060, 1, 0, 0, 0, 1297, 1061, 1, 0, 0, 0, 1297, 1062,
		1, 0, 0, 0, 1297, 1063, 1, 0, 0, 0, 1297, 1064, 1, 0, 0, 0, 1297, 1065,
		1, 0, 0, 0, 1297, 1066, 1, 0, 0, 0, 1297, 1067, 1, 0, 0, 0, 1297, 1068,
		1, 0, 0, 0, 1297, 1069, 1, 0, 0, 0, 1297, 1070, 1, 0, 0, 0, 1297, 1071,
		1, 0, 0, 0, 1297, 1072, 1, 0, 0, 0, 1297, 1073, 1, 0, 0, 0, 1297, 1074,
		1, 0, 0, 0, 1297, 1075, 1, 0, 0, 0, 1297, 1076, 1, 0, 0, 0, 1297, 1077,
		1, 0, 0, 0, 1297, 1078, 1, 0, 0, 0, 1297, 1079, 1, 0, 0, 0, 1297, 1080,
		1, 0, 0, 0, 1297, 1081, 1, 0, 0, 0, 1297, 1082, 1, 0, 0, 0, 1297, 1083,
		1, 0, 0, 0, 1297, 1084, 1, 0, 0, 0, 1297, 1085, 1, 0, 0, 0, 1297, 1086,
		1, 0, 0, 0, 1297, 1087, 1, 0, 0, 0, 1297, 1088, 1, 0, 0, 0, 1297, 1089,
		1, 0, 0, 0, 1297, 1090, 1, 0, 0, 0, 1297, 1091, 1, 0, 0, 0, 1297, 1092,
		1, 0, 0, 0, 1297, 1093, 1, 0, 0, 0, 1297, 1094, 1, 0, 0, 0, 1297, 1095,
		1, 0, 0, 0, 1297, 1096, 1, 0, 0, 0, 1297, 1097, 1, 0, 0, 0, 1297, 1098,
		1, 0, 0, 0, 1297, 1099, 1, 0, 0, 0, 1297, 1100, 1, 0, 0, 0, 1297, 1101,
		1, 0, 0, 0, 1297, 1102, 1, 0, 0, 0, 1297, 1103, 1, 0, 0, 0, 1297, 1104,
		1, 0, 0, 0, 1297, 1105, 1, 0, 0, 0, 1297, 1106, 1, 0, 0, 0, 1297, 1107,
		1, 0, 0, 0, 1297, 1108, 1, 0, 0, 0, 1297, 1109, 1, 0, 0, 0, 1297, 1110,
		1, 0, 0, 0, 1297, 1111, 1, 0, 0, 0, 1297, 1112, 1, 0, 0, 0, 1297, 1113,
		1, 0, 0, 0, 1297, 1114, 1, 0, 0, 0, 1297, 1115, 1, 0, 0, 0, 1297, 1116,
		1, 0, 0, 0, 1297, 1117, 1, 0, 0, 0, 1297, 1118, 1, 0, 0, 0, 1297, 1119,
		1, 0, 0, 0, 1297, 1120, 1, 0, 0, 0, 1297, 1121, 1, 0, 0, 0, 1297, 1122,
		1, 0, 0, 0, 1297, 1123, 1, 0, 0, 0, 1297, 1124, 1, 0, 0, 0, 1297, 1125,
		1, 0, 0, 0, 1297, 1126, 1, 0, 0, 0, 1297, 1127, 1, 0, 0, 0, 1297, 1128,
		1, 0, 0, 0, 1297, 1129, 1, 0, 0, 0, 1297, 1130, 1, 0, 0, 0, 1297, 1131,
		1, 0, 0, 0, 1297, 1132, 1, 0, 0, 0, 1297, 1133, 1, 0, 0, 0, 1297, 1134,
		1, 0, 0, 0, 1297, 1135, 1, 0, 0, 0, 1297, 1136, 1, 0, 0, 0, 1297, 1137,
		1, 0, 0, 0, 1297, 1138, 1, 0, 0, 0, 1297, 1139, 1, 0, 0, 0, 1297, 1140,
		1, 0, 0, 0, 1297, 1141, 1, 0, 0, 0, 1297, 1142, 1, 0, 0, 0, 1297, 1143,
		1, 0, 0, 0, 1297, 1144, 1, 0, 0, 0, 1297, 1145, 1, 0, 0, 0, 1297, 1146,
		1, 0, 0, 0, 1297, 1147, 1, 0, 0, 0, 1297, 1148, 1, 0, 0, 0, 1297, 1149,
		1, 0, 0, 0, 1297, 1150, 1, 0, 0, 0, 1297, 1151, 1, 0, 0, 0, 1297, 1152,
		1, 0, 0, 0, 1297, 1153, 1, 0, 0, 0, 1297, 1154, 1, 0, 0, 0, 1297, 1155,
		1, 0, 0, 0, 1297, 1156, 1, 0, 0, 0, 1297, 1157, 1, 0, 0, 0, 1297, 1158,
		1, 0, 0, 0, 1297, 1159, 1, 0, 0, 0, 1297, 1160, 1, 0, 0, 0, 1297, 1161,
		1, 0, 0, 0, 1297, 1162, 1, 0, 0, 0, 1297, 1163, 1, 0, 0, 0, 1297, 1164,
		1, 0, 0, 0, 1297, 1165, 1, 0, 0, 0, 1297, 1166, 1, 0, 0, 0, 1297, 1167,
		1, 0, 0, 0, 1297, 1168, 1, 0, 0, 0, 1297, 1169, 1, 0, 0, 0, 1297, 1170,
		1, 0, 0, 0, 1297, 1171, 1, 0, 0, 0, 1297, 1172, 1, 0, 0, 0, 1297, 1173,
		1, 0, 0, 0, 1297, 1174, 1, 0, 0, 0, 1297, 1175, 1, 0, 0, 0, 1297, 1176,
		1, 0, 0, 0, 1297, 1177, 1, 0, 0, 0, 1297, 1178, 1, 0, 0, 0, 1297, 1179,
		1, 0, 0, 0, 1297, 1180, 1, 0, 0, 0, 1297, 1181, 1, 0, 0, 0, 1297, 1182,
		1, 0, 0, 0, 1297, 1183, 1, 0, 0, 0, 1297, 1184, 1, 0, 0, 0, 1297, 1185,
		1, 0, 0, 0, 1297, 1186, 1, 0, 0, 0, 1297, 1187, 1, 0, 0, 0, 1297, 1188,
		1, 0, 0, 0, 1297, 1189, 1, 0, 0, 0, 1297, 1190, 1, 0, 0, 0, 1297, 1191,
		1, 0, 0, 0, 1297, 1192, 1, 0, 0, 0, 1297, 1193, 1, 0, 0, 0, 1297, 1194,
		1, 0, 0, 0, 1297, 1195, 1, 0, 0, 0, 1297, 1196, 1, 0, 0, 0, 1297, 1197,
		1, 0, 0, 0, 1297, 1198, 1, 0, 0, 0, 1297, 1199, 1, 0, 0, 0, 1297, 1200,
		1, 0, 0, 0, 1297, 1201, 1, 0, 0, 0, 1297, 1202, 1, 0, 0, 0, 1297, 1203,
		1, 0, 0, 0, 1297, 1204, 1, 0, 0, 0, 1297, 1205, 1, 0, 0, 0, 1297, 1206,
		1, 0, 0, 0, 1297, 1207, 1, 0, 0, 0, 1297, 1208, 1, 0, 0, 0, 1297, 1209,
		1, 0, 0, 0, 1297, 1210, 1, 0, 0, 0, 1297, 1211, 1, 0, 0, 0, 1297, 1212,
		1, 0, 0, 0, 1297, 1213, 1, 0, 0, 0, 1297, 1214, 1, 0, 0, 0, 1297, 1215,
		1, 0, 0, 0, 1297, 1216, 1, 0, 0, 0, 1297, 1217, 1, 0, 0, 0, 1297, 1218,
		1, 0, 0, 0, 1297, 1219, 1, 0, 0, 0, 1297, 1220, 1, 0, 0, 0, 1297, 1221,
		1, 0, 0, 0, 1297, 1222, 1, 0, 0, 0, 1297, 1223, 1, 0, 0, 0, 1297, 1224,
		1, 0, 0, 0, 1297, 1225, 1, 0, 0, 0, 1297, 1226, 1, 0, 0, 0, 1297, 1227,
		1, 0, 0, 0, 1297, 1228, 1, 0, 0, 0, 1297, 1229, 1, 0, 0, 0, 1297, 1230,
		1, 0, 0, 0, 1297, 1231, 1, 0, 0, 0, 1297, 1232, 1, 0, 0, 0, 1297, 1233,
		1, 0, 0, 0, 1297, 1234, 1, 0, 0, 0, 1297, 1235, 1, 0, 0, 0, 1297, 1236,
		1, 0, 0, 0, 1297, 1237, 1, 0, 0, 0, 1297, 1238, 1, 0, 0, 0, 1297, 1239,
		1, 0, 0, 0, 1297, 1240, 1, 0, 0, 0, 1297, 1241, 1, 0, 0, 0, 1297, 1242,
		1, 0, 0, 0, 1297, 1243, 1, 0, 0, 0, 1297, 1244, 1, 0, 0, 0, 1297, 1245,
		1, 0, 0, 0, 1297, 1246, 1, 0, 0, 0, 1297, 1247, 1, 0, 0, 0, 1297, 1248,
		1, 0, 0, 0, 1297, 1249, 1, 0, 0, 0, 1297, 1250, 1, 0, 0, 0, 1297, 1251,
		1, 0, 0, 0, 1297, 1252, 1, 0, 0, 0, 1297, 1253, 1, 0, 0, 0, 1297, 1254,
		1, 0, 0, 0, 1297, 1255, 1, 0, 0, 0, 1297, 1256, 1, 0, 0, 0, 1297, 1257,
		1, 0, 0, 0, 1297, 1258, 1, 0, 0, 0, 1297, 1259, 1, 0, 0, 0, 1297, 1260,
		1, 0, 0, 0, 1297, 1261, 1, 0, 0, 0, 1297, 1262, 1, 0, 0, 0, 1297, 1263,
		1, 0, 0, 0, 1297, 1264, 1, 0, 0, 0, 1297, 1265, 1, 0, 0, 0, 1297, 1266,
		1, 0, 0, 0, 1297, 1267, 1, 0, 0, 0, 1297, 1268, 1, 0, 0, 0, 1297, 1269,
		1, 0, 0, 0, 1297, 1270, 1, 0, 0, 0, 1297, 1271, 1, 0, 0, 0, 1297, 1272,
		1, 0, 0, 0, 1297, 1273, 1, 0, 0, 0, 1297, 1274, 1, 0, 0, 0, 1297, 1275,
		1, 0, 0, 0, 1297, 1276, 1, 0, 0, 0, 1297, 1277, 1, 0, 0, 0, 1297, 1278,
		1, 0, 0, 0, 1297, 1279, 1, 0, 0, 0, 1297, 1280, 1, 0, 0, 0, 1297, 1281,
		1, 0, 0, 0, 1297, 1282, 1, 0, 0, 0, 1297, 1283, 1, 0, 0, 0, 1297, 1284,
		1, 0, 0, 0, 1297, 1285, 1, 0, 0, 0, 1297, 1286, 1, 0, 0, 0, 1297, 1287,
		1, 0, 0, 0, 1297, 1288, 1, 0, 0, 0, 1297, 1289, 1, 0, 0, 0, 1297, 1290,
		1, 0, 0, 0, 1297, 1291, 1, 0, 0, 0, 1297, 1292, 1, 0, 0, 0, 1297, 1293,
		1, 0, 0, 0, 1297, 1294, 1, 0, 0, 0, 1297, 1295, 1, 0, 0, 0, 1297, 1296,
		1, 0, 0, 0, 1298, 7, 1, 0, 0, 0, 1299, 1300, 5, 457, 0, 0, 1300, 1301,
		3, 1012, 506, 0, 1301, 9, 1, 0, 0, 0, 1302, 1303, 5, 457, 0, 0, 1303, 1304,
		3, 976, 488, 0, 1304, 11, 1, 0, 0, 0, 1305, 1306, 5, 396, 0, 0, 1306, 1307,
		5, 60, 0, 0, 1307, 1308, 3, 1026, 513, 0, 1308, 13, 1, 0, 0, 0, 1309, 1310,
		5, 401, 0, 0, 1310, 1313, 5, 105, 0, 0, 1311, 1312, 7, 1, 0, 0, 1312, 1314,
		3, 1012, 506, 0, 1313, 1311, 1, 0, 0, 0, 1313, 1314, 1, 0, 0, 0, 1314,
		1319, 1, 0, 0, 0, 1315, 1316, 5, 240, 0, 0, 1316, 1320, 3, 976, 488, 0,
		1317, 1318, 5, 478, 0, 0, 1318, 1320, 3, 852, 426, 0, 1319, 1315, 1, 0,
		0, 0, 1319, 1317, 1, 0, 0, 0, 1319, 1320, 1, 0, 0, 0, 1320, 1330, 1, 0,
		0, 0, 1321, 1322, 5, 401, 0, 0, 1322, 1327, 5, 388, 0, 0, 1323, 1324, 5,
		240, 0, 0, 1324, 1328, 3, 976, 488, 0, 1325, 1326, 5, 478, 0, 0, 1326,
		1328, 3, 852, 426, 0, 1327, 1323, 1, 0, 0, 0, 1327, 1325, 1, 0, 0, 0, 1327,
		1328, 1, 0, 0, 0, 1328, 1330, 1, 0, 0, 0, 1329, 1309, 1, 0, 0, 0, 1329,
		1321, 1, 0, 0, 0, 1330, 15, 1, 0, 0, 0, 1331, 1332, 5, 19, 0, 0, 1332,
		1333, 5, 104, 0, 0, 1333, 1334, 3, 1018, 509, 0, 1334, 1335, 5, 396, 0,
		0, 1335, 1336, 5, 102, 0, 0, 1336, 1337, 5, 341, 0, 0, 1337, 1338, 3, 1018,
		509, 0, 1338, 1348, 1, 0, 0, 0, 1339, 1340, 5, 19, 0, 0, 1340, 1341, 5,
		104, 0, 0, 1341, 1342, 3, 1018, 509, 0, 1342, 1343, 5, 396, 0, 0, 1343,
		1344, 5, 358, 0, 0, 1344, 1345, 5, 341, 0, 0, 1345, 1346, 5, 518, 0, 0,
		1346, 1348, 1, 0, 0, 0, 1347, 1331, 1, 0, 0, 0, 1347, 1339, 1, 0, 0, 0,
		1348, 17, 1, 0, 0, 0, 1349, 1350, 5, 90, 0, 0, 1350, 1354, 7, 2, 0, 0,
		1351, 1352, 5, 197, 0, 0, 1352, 1353, 5, 281, 0, 0, 1353, 1355, 5, 148,
		0, 0, 1354, 1351, 1, 0, 0, 0, 1354, 1355, 1, 0, 0, 0, 1355, 1359, 1, 0,
		0, 0, 1356, 1357, 3, 1018, 509, 0, 1357, 1358, 5, 1, 0, 0, 1358, 1360,
		1, 0, 0, 0, 1359, 1356, 1, 0, 0, 0, 1359, 1360, 1, 0, 0, 0, 1360, 1361,
		1, 0, 0, 0, 1361, 1363, 3, 1012, 506, 0, 1362, 1364, 3, 46, 23, 0, 1363,
		1362, 1, 0, 0, 0, 1363, 1364, 1, 0, 0, 0, 1364, 1366, 1, 0, 0, 0, 1365,
		1367, 3, 48, 24, 0, 1366, 1365, 1, 0, 0, 0, 1366, 1367, 1, 0, 0, 0, 1367,
		1369, 1, 0, 0, 0, 1368, 1370, 3, 954, 477, 0, 1369, 1368, 1, 0, 0, 0, 1369,
		1370, 1, 0, 0, 0, 1370, 19, 1, 0, 0, 0, 1371, 1372, 5, 132, 0, 0, 1372,
		1375, 7, 2, 0, 0, 1373, 1374, 5, 197, 0, 0, 1374, 1376, 5, 148, 0, 0, 1375,
		1373, 1, 0, 0, 0, 1375, 1376, 1, 0, 0, 0, 1376, 1380, 1, 0, 0, 0, 1377,
		1378, 3, 1018, 509, 0, 1378, 1379, 5, 1, 0, 0, 1379, 1381, 1, 0, 0, 0,
		1380, 1377, 1, 0, 0, 0, 1380, 1381, 1, 0, 0, 0, 1381, 1382, 1, 0, 0, 0,
		1382, 1384, 3, 1012, 506, 0, 1383, 1385, 5, 169, 0, 0, 1384, 1383, 1, 0,
		0, 0, 1384, 1385, 1, 0, 0, 0, 1385, 21, 1, 0, 0, 0, 1386, 1387, 5, 401,
		0, 0, 1387, 1388, 5, 90, 0, 0, 1388, 1389, 7, 2, 0, 0, 1389, 1390, 3, 1018,
		509, 0, 1390, 23, 1, 0, 0, 0, 1391, 1392, 5, 19, 0, 0, 1392, 1393, 5, 104,
		0, 0, 1393, 1394, 3, 1018, 509, 0, 1394, 1395, 5, 353, 0, 0, 1395, 1396,
		3, 1018, 509, 0, 1396, 25, 1, 0, 0, 0, 1397, 1398, 5, 347, 0, 0, 1398,
		1399, 7, 2, 0, 0, 1399, 1400, 3, 1018, 509, 0, 1400, 27, 1, 0, 0, 0, 1401,
		1402, 5, 401, 0, 0, 1402, 1408, 5, 102, 0, 0, 1403, 1404, 5, 401, 0, 0,
		1404, 1405, 5, 102, 0, 0, 1405, 1406, 5, 172, 0, 0, 1406, 1408, 3, 1012,
		506, 0, 1407, 1401, 1, 0, 0, 0, 1407, 1403, 1, 0, 0, 0, 1408, 29, 1, 0,
		0, 0, 1409, 1410, 5, 401, 0, 0, 1410, 1411, 5, 102, 0, 0, 1411, 1412, 5,
		130, 0, 0, 1412, 1413, 5, 172, 0, 0, 1413, 1415, 3, 1012, 506, 0, 1414,
		1416, 3, 826, 413, 0, 1415, 1414, 1, 0, 0, 0, 1415, 1416, 1, 0, 0, 0, 1416,
		31, 1, 0, 0, 0, 1417, 1419, 5, 90, 0, 0, 1418, 1420, 7, 3, 0, 0, 1419,
		1418, 1, 0, 0, 0, 1419, 1420, 1, 0, 0, 0, 1420, 1421, 1, 0, 0, 0, 1421,
		1425, 5, 422, 0, 0, 1422, 1423, 5, 197, 0, 0, 1423, 1424, 5, 281, 0, 0,
		1424, 1426, 5, 148, 0, 0, 1425, 1422, 1, 0, 0, 0, 1425, 1426, 1, 0, 0,
		0, 1426, 1427, 1, 0, 0, 0, 1427, 1428, 3, 1012, 506, 0, 1428, 1429, 5,
		2, 0, 0, 1429, 1434, 3, 34, 17, 0, 1430, 1431, 5, 3, 0, 0, 1431, 1433,
		3, 34, 17, 0, 1432, 1430, 1, 0, 0, 0, 1433, 1436, 1, 0, 0, 0, 1434, 1432,
		1, 0, 0, 0, 1434, 1435, 1, 0, 0, 0, 1435, 1441, 1, 0, 0, 0, 1436, 1434,
		1, 0, 0, 0, 1437, 1438, 5, 3, 0, 0, 1438, 1440, 3, 42, 21, 0, 1439, 1437,
		1, 0, 0, 0, 1440, 1443, 1, 0, 0, 0, 1441, 1439, 1, 0, 0, 0, 1441, 1442,
		1, 0, 0, 0, 1442, 1444, 1, 0, 0, 0, 1443, 1441, 1, 0, 0, 0, 1444, 1446,
		5, 4, 0, 0, 1445, 1447, 3, 44, 22, 0, 1446, 1445, 1, 0, 0, 0, 1446, 1447,
		1, 0, 0, 0, 1447, 1449, 1, 0, 0, 0, 1448, 1450, 3, 46, 23, 0, 1449, 1448,
		1, 0, 0, 0, 1449, 1450, 1, 0, 0, 0, 1450, 1452, 1, 0, 0, 0, 1451, 1453,
		3, 50, 25, 0, 1452, 1451, 1, 0, 0, 0, 1452, 1453, 1, 0, 0, 0, 1453, 1455,
		1, 0, 0, 0, 1454, 1456, 3, 970, 485, 0, 1455, 1454, 1, 0, 0, 0, 1455, 1456,
		1, 0, 0, 0, 1456, 1458, 1, 0, 0, 0, 1457, 1459, 3, 910, 455, 0, 1458, 1457,
		1, 0, 0, 0, 1458, 1459, 1, 0, 0, 0, 1459, 1461, 1, 0, 0, 0, 1460, 1462,
		3, 948, 474, 0, 1461, 1460, 1, 0, 0, 0, 1461, 1462, 1, 0, 0, 0, 1462, 1464,
		1, 0, 0, 0, 1463, 1465, 3, 52, 26, 0, 1464, 1463, 1, 0, 0, 0, 1464, 1465,
		1, 0, 0, 0, 1465, 1467, 1, 0, 0, 0, 1466, 1468, 3, 62, 31, 0, 1467, 1466,
		1, 0, 0, 0, 1467, 1468, 1, 0, 0, 0, 1468, 1470, 1, 0, 0, 0, 1469, 1471,
		3, 954, 477, 0, 1470, 1469, 1, 0, 0, 0, 1470, 1471, 1, 0, 0, 0, 1471, 1473,
		1, 0, 0, 0, 1472, 1474, 3, 956, 478, 0, 1473, 1472, 1, 0, 0, 0, 1473, 1474,
		1, 0, 0, 0, 1474, 33, 1, 0, 0, 0, 1475, 1477, 3, 1018, 509, 0, 1476, 1478,
		3, 994, 497, 0, 1477, 1476, 1, 0, 0, 0, 1477, 1478, 1, 0, 0, 0, 1478, 1480,
		1, 0, 0, 0, 1479, 1481, 3, 36, 18, 0, 1480, 1479, 1, 0, 0, 0, 1480, 1481,
		1, 0, 0, 0, 1481, 1483, 1, 0, 0, 0, 1482, 1484, 5, 227, 0, 0, 1483, 1482,
		1, 0, 0, 0, 1483, 1484, 1, 0, 0, 0, 1484, 1486, 1, 0, 0, 0, 1485, 1487,
		3, 60, 30, 0, 1486, 1485, 1, 0, 0, 0, 1486, 1487, 1, 0, 0, 0, 1487, 1489,
		1, 0, 0, 0, 1488, 1490, 3, 54, 27, 0, 1489, 1488, 1, 0, 0, 0, 1489, 1490,
		1, 0, 0, 0, 1490, 1494, 1, 0, 0, 0, 1491, 1495, 3, 38, 19, 0, 1492, 1495,
		5, 33, 0, 0, 1493, 1495, 3, 40, 20, 0, 1494, 1491, 1, 0, 0, 0, 1494, 1492,
		1, 0, 0, 0, 1494, 1493, 1, 0, 0, 0, 1494, 1495, 1, 0, 0, 0, 1495, 1497,
		1, 0, 0, 0, 1496, 1498, 3, 970, 485, 0, 1497, 1496, 1, 0, 0, 0, 1497, 1498,
		1, 0, 0, 0, 1498, 35, 1, 0, 0, 0, 1499, 1500, 5, 64, 0, 0, 1500, 1501,
		5, 396, 0, 0, 1501, 1508, 3, 1018, 509, 0, 1502, 1503, 5, 66, 0, 0, 1503,
		1508, 3, 1018, 509, 0, 1504, 1505, 5, 65, 0, 0, 1505, 1506, 5, 396, 0,
		0, 1506, 1508, 3, 1018, 509, 0, 1507, 1499, 1, 0, 0, 0, 1507, 1502, 1,
		0, 0, 0, 1507, 1504, 1, 0, 0, 0, 1508, 37, 1, 0, 0, 0, 1509, 1519, 5, 117,
		0, 0, 1510, 1520, 3, 976, 488, 0, 1511, 1520, 5, 282, 0, 0, 1512, 1520,
		5, 100, 0, 0, 1513, 1514, 5, 2, 0, 0, 1514, 1515, 3, 1012, 506, 0, 1515,
		1516, 5, 2, 0, 0, 1516, 1517, 5, 4, 0, 0, 1517, 1518, 5, 4, 0, 0, 1518,
		1520, 1, 0, 0, 0, 1519, 1510, 1, 0, 0, 0, 1519, 1511, 1, 0, 0, 0, 1519,
		1512, 1, 0, 0, 0, 1519, 1513, 1, 0, 0, 0, 1520, 39, 1, 0, 0, 0, 1521, 1522,
		5, 27, 0, 0, 1522, 1523, 3, 852, 426, 0, 1523, 41, 1, 0, 0, 0, 1524, 1525,
		5, 205, 0, 0, 1525, 1526, 3, 1018, 509, 0, 1526, 1531, 3, 1024, 512, 0,
		1527, 1529, 3, 86, 43, 0, 1528, 1530, 3, 958, 479, 0, 1529, 1528, 1, 0,
		0, 0, 1529, 1530, 1, 0, 0, 0, 1530, 1532, 1, 0, 0, 0, 1531, 1527, 1, 0,
		0, 0, 1531, 1532, 1, 0, 0, 0, 1532, 1534, 1, 0, 0, 0, 1533, 1535, 3, 970,
		485, 0, 1534, 1533, 1, 0, 0, 0, 1534, 1535, 1, 0, 0, 0, 1535, 43, 1, 0,
		0, 0, 1536, 1537, 5, 140, 0, 0, 1537, 1538, 5, 492, 0, 0, 1538, 1539, 3,
		1018, 509, 0, 1539, 45, 1, 0, 0, 0, 1540, 1542, 5, 117, 0, 0, 1541, 1540,
		1, 0, 0, 0, 1541, 1542, 1, 0, 0, 0, 1542, 1548, 1, 0, 0, 0, 1543, 1544,
		5, 64, 0, 0, 1544, 1549, 5, 396, 0, 0, 1545, 1549, 5, 66, 0, 0, 1546, 1547,
		5, 65, 0, 0, 1547, 1549, 5, 396, 0, 0, 1548, 1543, 1, 0, 0, 0, 1548, 1545,
		1, 0, 0, 0, 1548, 1546, 1, 0, 0, 0, 1549, 1551, 1, 0, 0, 0, 1550, 1552,
		5, 492, 0, 0, 1551, 1550, 1, 0, 0, 0, 1551, 1552, 1, 0, 0, 0, 1552, 1553,
		1, 0, 0, 0, 1553, 1554, 3, 1026, 513, 0, 1554, 47, 1, 0, 0, 0, 1555, 1557,
		5, 117, 0, 0, 1556, 1555, 1, 0, 0, 0, 1556, 1557, 1, 0, 0, 0, 1557, 1558,
		1, 0, 0, 0, 1558, 1560, 5, 74, 0, 0, 1559, 1561, 5, 492, 0, 0, 1560, 1559,
		1, 0, 0, 0, 1560, 1561, 1, 0, 0, 0, 1561, 1562, 1, 0, 0, 0, 1562, 1563,
		3, 1026, 513, 0, 1563, 49, 1, 0, 0, 0, 1564, 1565, 7, 4, 0, 0, 1565, 1566,
		5, 227, 0, 0, 1566, 1567, 3, 1024, 512, 0, 1567, 51, 1, 0, 0, 0, 1568,
		1569, 5, 298, 0, 0, 1569, 1570, 5, 55, 0, 0, 1570, 1571, 3, 1024, 512,
		0, 1571, 53, 1, 0, 0, 0, 1572, 1576, 5, 282, 0, 0, 1573, 1574, 5, 281,
		0, 0, 1574, 1576, 5, 282, 0, 0, 1575, 1572, 1, 0, 0, 0, 1575, 1573, 1,
		0, 0, 0, 1576, 55, 1, 0, 0, 0, 1577, 1579, 3, 994, 497, 0, 1578, 1580,
		3, 54, 27, 0, 1579, 1578, 1, 0, 0, 0, 1579, 1580, 1, 0, 0, 0, 1580, 57,
		1, 0, 0, 0, 1581, 1582, 3, 1018, 509, 0, 1582, 1583, 5, 2, 0, 0, 1583,
		1588, 3, 56, 28, 0, 1584, 1585, 5, 3, 0, 0, 1585, 1587, 3, 56, 28, 0, 1586,
		1584, 1, 0, 0, 0, 1587, 1590, 1, 0, 0, 0, 1588, 1586, 1, 0, 0, 0, 1588,
		1589, 1, 0, 0, 0, 1589, 1591, 1, 0, 0, 0, 1590, 1588, 1, 0, 0, 0, 1591,
		1592, 5, 4, 0, 0, 1592, 59, 1, 0, 0, 0, 1593, 1603, 5, 415, 0, 0, 1594,
		1603, 5, 258, 0, 0, 1595, 1603, 5, 263, 0, 0, 1596, 1603, 5, 356, 0, 0,
		1597, 1603, 5, 191, 0, 0, 1598, 1603, 5, 45, 0, 0, 1599, 1603, 5, 311,
		0, 0, 1600, 1603, 5, 357, 0, 0, 1601, 1603, 3, 58, 29, 0, 1602, 1593, 1,
		0, 0, 0, 1602, 1594, 1, 0, 0, 0, 1602, 1595, 1, 0, 0, 0, 1602, 1596, 1,
		0, 0, 0, 1602, 1597, 1, 0, 0, 0, 1602, 1598, 1, 0, 0, 0, 1602, 1599, 1,
		0, 0, 0, 1602, 1600, 1, 0, 0, 0, 1602, 1601, 1, 0, 0, 0, 1603, 61, 1, 0,
		0, 0, 1604, 1605, 5, 376, 0, 0, 1605, 1606, 5, 2, 0, 0, 1606, 1611, 3,
		64, 32, 0, 1607, 1608, 5, 3, 0, 0, 1608, 1610, 3, 64, 32, 0, 1609, 1607,
		1, 0, 0, 0, 1610, 1613, 1, 0, 0, 0, 1611, 1609, 1, 0, 0, 0, 1611, 1612,
		1, 0, 0, 0, 1612, 1614, 1, 0, 0, 0, 1613, 1611, 1, 0, 0, 0, 1614, 1615,
		5, 4, 0, 0, 1615, 63, 1, 0, 0, 0, 1616, 1617, 3, 1018, 509, 0, 1617, 1619,
		3, 1024, 512, 0, 1618, 1620, 3, 66, 33, 0, 1619, 1618, 1, 0, 0, 0, 1619,
		1620, 1, 0, 0, 0, 1620, 1622, 1, 0, 0, 0, 1621, 1623, 3, 68, 34, 0, 1622,
		1621, 1, 0, 0, 0, 1622, 1623, 1, 0, 0, 0, 1623, 1625, 1, 0, 0, 0, 1624,
		1626, 3, 954, 477, 0, 1625, 1624, 1, 0, 0, 0, 1625, 1626, 1, 0, 0, 0, 1626,
		65, 1, 0, 0, 0, 1627, 1628, 5, 134, 0, 0, 1628, 1629, 5, 227, 0, 0, 1629,
		1630, 3, 1024, 512, 0, 1630, 67, 1, 0, 0, 0, 1631, 1632, 5, 172, 0, 0,
		1632, 1633, 3, 1018, 509, 0, 1633, 69, 1, 0, 0, 0, 1634, 1635, 5, 297,
		0, 0, 1635, 1637, 5, 356, 0, 0, 1636, 1634, 1, 0, 0, 0, 1636, 1637, 1,
		0, 0, 0, 1637, 71, 1, 0, 0, 0, 1638, 1639, 5, 197, 0, 0, 1639, 1640, 5,
		281, 0, 0, 1640, 1642, 5, 148, 0, 0, 1641, 1638, 1, 0, 0, 0, 1641, 1642,
		1, 0, 0, 0, 1642, 73, 1, 0, 0, 0, 1643, 1645, 5, 90, 0, 0, 1644, 1646,
		5, 428, 0, 0, 1645, 1644, 1, 0, 0, 0, 1645, 1646, 1, 0, 0, 0, 1646, 1647,
		1, 0, 0, 0, 1647, 1651, 5, 422, 0, 0, 1648, 1649, 5, 197, 0, 0, 1649, 1650,
		5, 281, 0, 0, 1650, 1652, 5, 148, 0, 0, 1651, 1648, 1, 0, 0, 0, 1651, 1652,
		1, 0, 0, 0, 1652, 1653, 1, 0, 0, 0, 1653, 1682, 3, 1012, 506, 0, 1654,
		1678, 5, 2, 0, 0, 1655, 1660, 3, 1018, 509, 0, 1656, 1657, 5, 3, 0, 0,
		1657, 1659, 3, 1018, 509, 0, 1658, 1656, 1, 0, 0, 0, 1659, 1662, 1, 0,
		0, 0, 1660, 1658, 1, 0, 0, 0, 1660, 1661, 1, 0, 0, 0, 1661, 1667, 1, 0,
		0, 0, 1662, 1660, 1, 0, 0, 0, 1663, 1664, 5, 3, 0, 0, 1664, 1666, 3, 42,
		21, 0, 1665, 1663, 1, 0, 0, 0, 1666, 1669, 1, 0, 0, 0, 1667, 1665, 1, 0,
		0, 0, 1667, 1668, 1, 0, 0, 0, 1668, 1679, 1, 0, 0, 0, 1669, 1667, 1, 0,
		0, 0, 1670, 1675, 3, 42, 21, 0, 1671, 1672, 5, 3, 0, 0, 1672, 1674, 3,
		42, 21, 0, 1673, 1671, 1, 0, 0, 0, 1674, 1677, 1, 0, 0, 0, 1675, 1673,
		1, 0, 0, 0, 1675, 1676, 1, 0, 0, 0, 1676, 1679, 1, 0, 0, 0, 1677, 1675,
		1, 0, 0, 0, 1678, 1655, 1, 0, 0, 0, 1678, 1670, 1, 0, 0, 0, 1679, 1680,
		1, 0, 0, 0, 1680, 1681, 5, 4, 0, 0, 1681, 1683, 1, 0, 0, 0, 1682, 1654,
		1, 0, 0, 0, 1682, 1683, 1, 0, 0, 0, 1683, 1685, 1, 0, 0, 0, 1684, 1686,
		3, 50, 25, 0, 1685, 1684, 1, 0, 0, 0, 1685, 1686, 1, 0, 0, 0, 1686, 1688,
		1, 0, 0, 0, 1687, 1689, 3, 970, 485, 0, 1688, 1687, 1, 0, 0, 0, 1688, 1689,
		1, 0, 0, 0, 1689, 1691, 1, 0, 0, 0, 1690, 1692, 3, 910, 455, 0, 1691, 1690,
		1, 0, 0, 0, 1691, 1692, 1, 0, 0, 0, 1692, 1694, 1, 0, 0, 0, 1693, 1695,
		3, 948, 474, 0, 1694, 1693, 1, 0, 0, 0, 1694, 1695, 1, 0, 0, 0, 1695, 1697,
		1, 0, 0, 0, 1696, 1698, 3, 52, 26, 0, 1697, 1696, 1, 0, 0, 0, 1697, 1698,
		1, 0, 0, 0, 1698, 1700, 1, 0, 0, 0, 1699, 1701, 3, 954, 477, 0, 1700, 1699,
		1, 0, 0, 0, 1700, 1701, 1, 0, 0, 0, 1701, 1702, 1, 0, 0, 0, 1702, 1703,
		5, 27, 0, 0, 1703, 1704, 3, 752, 376, 0, 1704, 75, 1, 0, 0, 0, 1705, 1707,
		5, 132, 0, 0, 1706, 1708, 5, 428, 0, 0, 1707, 1706, 1, 0, 0, 0, 1707, 1708,
		1, 0, 0, 0, 1708, 1709, 1, 0, 0, 0, 1709, 1712, 5, 422, 0, 0, 1710, 1711,
		5, 197, 0, 0, 1711, 1713, 5, 148, 0, 0, 1712, 1710, 1, 0, 0, 0, 1712, 1713,
		1, 0, 0, 0, 1713, 1714, 1, 0, 0, 0, 1714, 1716, 3, 1012, 506, 0, 1715,
		1717, 5, 169, 0, 0, 1716, 1715, 1, 0, 0, 0, 1716, 1717, 1, 0, 0, 0, 1717,
		77, 1, 0, 0, 0, 1718, 1719, 5, 68, 0, 0, 1719, 1720, 5, 428, 0, 0, 1720,
		1721, 5, 422, 0, 0, 1721, 1722, 5, 290, 0, 0, 1722, 1723, 5, 395, 0, 0,
		1723, 1724, 3, 976, 488, 0, 1724, 79, 1, 0, 0, 0, 1725, 1726, 5, 19, 0,
		0, 1726, 1727, 5, 422, 0, 0, 1727, 1728, 3, 1012, 506, 0, 1728, 1733, 3,
		232, 116, 0, 1729, 1730, 5, 3, 0, 0, 1730, 1732, 3, 232, 116, 0, 1731,
		1729, 1, 0, 0, 0, 1732, 1735, 1, 0, 0, 0, 1733, 1731, 1, 0, 0, 0, 1733,
		1734, 1, 0, 0, 0, 1734, 1763, 1, 0, 0, 0, 1735, 1733, 1, 0, 0, 0, 1736,
		1737, 5, 19, 0, 0, 1737, 1738, 5, 422, 0, 0, 1738, 1739, 3, 1012, 506,
		0, 1739, 1740, 5, 13, 0, 0, 1740, 1741, 5, 376, 0, 0, 1741, 1746, 3, 64,
		32, 0, 1742, 1743, 5, 3, 0, 0, 1743, 1745, 3, 64, 32, 0, 1744, 1742, 1,
		0, 0, 0, 1745, 1748, 1, 0, 0, 0, 1746, 1744, 1, 0, 0, 0, 1746, 1747, 1,
		0, 0, 0, 1747, 1763, 1, 0, 0, 0, 1748, 1746, 1, 0, 0, 0, 1749, 1750, 5,
		19, 0, 0, 1750, 1751, 5, 422, 0, 0, 1751, 1752, 3, 1012, 506, 0, 1752,
		1753, 5, 132, 0, 0, 1753, 1754, 5, 376, 0, 0, 1754, 1759, 3, 1018, 509,
		0, 1755, 1756, 5, 3, 0, 0, 1756, 1758, 3, 1018, 509, 0, 1757, 1755, 1,
		0, 0, 0, 1758, 1761, 1, 0, 0, 0, 1759, 1757, 1, 0, 0, 0, 1759, 1760, 1,
		0, 0, 0, 1760, 1763, 1, 0, 0, 0, 1761, 1759, 1, 0, 0, 0, 1762, 1725, 1,
		0, 0, 0, 1762, 1736, 1, 0, 0, 0, 1762, 1749, 1, 0, 0, 0, 1763, 81, 1, 0,
		0, 0, 1764, 1765, 5, 90, 0, 0, 1765, 1766, 5, 205, 0, 0, 1766, 1767, 3,
		1018, 509, 0, 1767, 1768, 5, 290, 0, 0, 1768, 1769, 3, 1012, 506, 0, 1769,
		1774, 3, 1024, 512, 0, 1770, 1772, 3, 86, 43, 0, 1771, 1773, 3, 958, 479,
		0, 1772, 1771, 1, 0, 0, 0, 1772, 1773, 1, 0, 0, 0, 1773, 1775, 1, 0, 0,
		0, 1774, 1770, 1, 0, 0, 0, 1774, 1775, 1, 0, 0, 0, 1775, 1777, 1, 0, 0,
		0, 1776, 1778, 3, 970, 485, 0, 1777, 1776, 1, 0, 0, 0, 1777, 1778, 1, 0,
		0, 0, 1778, 83, 1, 0, 0, 0, 1779, 1780, 5, 132, 0, 0, 1780, 1781, 5, 205,
		0, 0, 1781, 1782, 3, 1018, 509, 0, 1782, 1783, 5, 290, 0, 0, 1783, 1784,
		3, 1012, 506, 0, 1784, 85, 1, 0, 0, 0, 1785, 1786, 5, 460, 0, 0, 1786,
		1787, 7, 5, 0, 0, 1787, 87, 1, 0, 0, 0, 1788, 1790, 5, 401, 0, 0, 1789,
		1791, 5, 175, 0, 0, 1790, 1789, 1, 0, 0, 0, 1790, 1791, 1, 0, 0, 0, 1791,
		1792, 1, 0, 0, 0, 1792, 1795, 5, 423, 0, 0, 1793, 1794, 7, 1, 0, 0, 1794,
		1796, 3, 1012, 506, 0, 1795, 1793, 1, 0, 0, 0, 1795, 1796, 1, 0, 0, 0,
		1796, 1801, 1, 0, 0, 0, 1797, 1798, 5, 240, 0, 0, 1798, 1802, 3, 976, 488,
		0, 1799, 1800, 5, 478, 0, 0, 1800, 1802, 3, 852, 426, 0, 1801, 1797, 1,
		0, 0, 0, 1801, 1799, 1, 0, 0, 0, 1801, 1802, 1, 0, 0, 0, 1802, 89, 1, 0,
		0, 0, 1803, 1804, 5, 401, 0, 0, 1804, 1805, 5, 428, 0, 0, 1805, 1808, 5,
		423, 0, 0, 1806, 1807, 7, 1, 0, 0, 1807, 1809, 3, 1012, 506, 0, 1808, 1806,
		1, 0, 0, 0, 1808, 1809, 1, 0, 0, 0, 1809, 1814, 1, 0, 0, 0, 1810, 1811,
		5, 240, 0, 0, 1811, 1815, 3, 976, 488, 0, 1812, 1813, 5, 478, 0, 0, 1813,
		1815, 3, 852, 426, 0, 1814, 1810, 1, 0, 0, 0, 1814, 1812, 1, 0, 0, 0, 1814,
		1815, 1, 0, 0, 0, 1815, 91, 1, 0, 0, 0, 1816, 1817, 5, 401, 0, 0, 1817,
		1822, 5, 90, 0, 0, 1818, 1823, 5, 422, 0, 0, 1819, 1823, 5, 469, 0, 0,
		1820, 1821, 5, 257, 0, 0, 1821, 1823, 5, 469, 0, 0, 1822, 1818, 1, 0, 0,
		0, 1822, 1819, 1, 0, 0, 0, 1822, 1820, 1, 0, 0, 0, 1823, 1824, 1, 0, 0,
		0, 1824, 1825, 3, 1012, 506, 0, 1825, 93, 1, 0, 0, 0, 1826, 1828, 5, 401,
		0, 0, 1827, 1829, 5, 175, 0, 0, 1828, 1827, 1, 0, 0, 0, 1828, 1829, 1,
		0, 0, 0, 1829, 1830, 1, 0, 0, 0, 1830, 1831, 7, 6, 0, 0, 1831, 1832, 7,
		1, 0, 0, 1832, 1833, 3, 1012, 506, 0, 1833, 1836, 1, 0, 0, 0, 1834, 1835,
		7, 1, 0, 0, 1835, 1837, 3, 1012, 506, 0, 1836, 1834, 1, 0, 0, 0, 1836,
		1837, 1, 0, 0, 0, 1837, 1842, 1, 0, 0, 0, 1838, 1839, 5, 240, 0, 0, 1839,
		1843, 3, 976, 488, 0, 1840, 1841, 5, 478, 0, 0, 1841, 1843, 3, 852, 426,
		0, 1842, 1838, 1, 0, 0, 0, 1842, 1840, 1, 0, 0, 0, 1842, 1843, 1, 0, 0,
		0, 1843, 95, 1, 0, 0, 0, 1844, 1845, 5, 401, 0, 0, 1845, 1846, 5, 422,
		0, 0, 1846, 1849, 5, 408, 0, 0, 1847, 1848, 7, 1, 0, 0, 1848, 1850, 3,
		1012, 506, 0, 1849, 1847, 1, 0, 0, 0, 1849, 1850, 1, 0, 0, 0, 1850, 1855,
		1, 0, 0, 0, 1851, 1852, 5, 240, 0, 0, 1852, 1856, 3, 976, 488, 0, 1853,
		1854, 5, 478, 0, 0, 1854, 1856, 3, 852, 426, 0, 1855, 1851, 1, 0, 0, 0,
		1855, 1853, 1, 0, 0, 0, 1855, 1856, 1, 0, 0, 0, 1856, 97, 1, 0, 0, 0, 1857,
		1858, 5, 348, 0, 0, 1858, 1859, 5, 151, 0, 0, 1859, 1860, 5, 422, 0, 0,
		1860, 1873, 3, 1012, 506, 0, 1861, 1862, 5, 303, 0, 0, 1862, 1863, 5, 2,
		0, 0, 1863, 1868, 3, 976, 488, 0, 1864, 1865, 5, 3, 0, 0, 1865, 1867, 3,
		976, 488, 0, 1866, 1864, 1, 0, 0, 0, 1867, 1870, 1, 0, 0, 0, 1868, 1866,
		1, 0, 0, 0, 1868, 1869, 1, 0, 0, 0, 1869, 1871, 1, 0, 0, 0, 1870, 1868,
		1, 0, 0, 0, 1871, 1872, 5, 4, 0, 0, 1872, 1874, 1, 0, 0, 0, 1873, 1861,
		1, 0, 0, 0, 1873, 1874, 1, 0, 0, 0, 1874, 99, 1, 0, 0, 0, 1875, 1876, 5,
		401, 0, 0, 1876, 1877, 5, 19, 0, 0, 1877, 1878, 5, 422, 0, 0, 1878, 1881,
		7, 7, 0, 0, 1879, 1880, 7, 1, 0, 0, 1880, 1882, 3, 1012, 506, 0, 1881,
		1879, 1, 0, 0, 0, 1881, 1882, 1, 0, 0, 0, 1882, 1885, 1, 0, 0, 0, 1883,
		1884, 5, 478, 0, 0, 1884, 1886, 3, 852, 426, 0, 1885, 1883, 1, 0, 0, 0,
		1885, 1886, 1, 0, 0, 0, 1886, 1897, 1, 0, 0, 0, 1887, 1888, 5, 298, 0,
		0, 1888, 1889, 5, 55, 0, 0, 1889, 1894, 3, 770, 385, 0, 1890, 1891, 5,
		3, 0, 0, 1891, 1893, 3, 770, 385, 0, 1892, 1890, 1, 0, 0, 0, 1893, 1896,
		1, 0, 0, 0, 1894, 1892, 1, 0, 0, 0, 1894, 1895, 1, 0, 0, 0, 1895, 1898,
		1, 0, 0, 0, 1896, 1894, 1, 0, 0, 0, 1897, 1887, 1, 0, 0, 0, 1897, 1898,
		1, 0, 0, 0, 1898, 1900, 1, 0, 0, 0, 1899, 1901, 3, 774, 387, 0, 1900, 1899,
		1, 0, 0, 0, 1900, 1901, 1, 0, 0, 0, 1901, 1930, 1, 0, 0, 0, 1902, 1903,
		5, 401, 0, 0, 1903, 1904, 5, 19, 0, 0, 1904, 1905, 5, 257, 0, 0, 1905,
		1908, 5, 469, 0, 0, 1906, 1907, 7, 1, 0, 0, 1907, 1909, 3, 1012, 506, 0,
		1908, 1906, 1, 0, 0, 0, 1908, 1909, 1, 0, 0, 0, 1909, 1912, 1, 0, 0, 0,
		1910, 1911, 5, 478, 0, 0, 1911, 1913, 3, 852, 426, 0, 1912, 1910, 1, 0,
		0, 0, 1912, 1913, 1, 0, 0, 0, 1913, 1924, 1, 0, 0, 0, 1914, 1915, 5, 298,
		0, 0, 1915, 1916, 5, 55, 0, 0, 1916, 1921, 3, 770, 385, 0, 1917, 1918,
		5, 3, 0, 0, 1918, 1920, 3, 770, 385, 0, 1919, 1917, 1, 0, 0, 0, 1920, 1923,
		1, 0, 0, 0, 1921, 1919, 1, 0, 0, 0, 1921, 1922, 1, 0, 0, 0, 1922, 1925,
		1, 0, 0, 0, 1923, 1921, 1, 0, 0, 0, 1924, 1914, 1, 0, 0, 0, 1924, 1925,
		1, 0, 0, 0, 1925, 1927, 1, 0, 0, 0, 1926, 1928, 3, 774, 387, 0, 1927, 1926,
		1, 0, 0, 0, 1927, 1928, 1, 0, 0, 0, 1928, 1930, 1, 0, 0, 0, 1929, 1875,
		1, 0, 0, 0, 1929, 1902, 1, 0, 0, 0, 1930, 101, 1, 0, 0, 0, 1931, 1938,
		7, 8, 0, 0, 1932, 1934, 3, 1012, 506, 0, 1933, 1935, 5, 18, 0, 0, 1934,
		1933, 1, 0, 0, 0, 1934, 1935, 1, 0, 0, 0, 1935, 1939, 1, 0, 0, 0, 1936,
		1937, 5, 159, 0, 0, 1937, 1939, 3, 958, 479, 0, 1938, 1932, 1, 0, 0, 0,
		1938, 1936, 1, 0, 0, 0, 1939, 103, 1, 0, 0, 0, 1940, 1942, 5, 90, 0, 0,
		1941, 1943, 7, 3, 0, 0, 1942, 1941, 1, 0, 0, 0, 1942, 1943, 1, 0, 0, 0,
		1943, 1944, 1, 0, 0, 0, 1944, 1948, 5, 422, 0, 0, 1945, 1946, 5, 197, 0,
		0, 1946, 1947, 5, 281, 0, 0, 1947, 1949, 5, 148, 0, 0, 1948, 1945, 1, 0,
		0, 0, 1948, 1949, 1, 0, 0, 0, 1949, 1950, 1, 0, 0, 0, 1950, 1952, 3, 1012,
		506, 0, 1951, 1953, 3, 910, 455, 0, 1952, 1951, 1, 0, 0, 0, 1952, 1953,
		1, 0, 0, 0, 1953, 1955, 1, 0, 0, 0, 1954, 1956, 3, 948, 474, 0, 1955, 1954,
		1, 0, 0, 0, 1955, 1956, 1, 0, 0, 0, 1956, 1958, 1, 0, 0, 0, 1957, 1959,
		3, 954, 477, 0, 1958, 1957, 1, 0, 0, 0, 1958, 1959, 1, 0, 0, 0, 1959, 1960,
		1, 0, 0, 0, 1960, 1961, 5, 240, 0, 0, 1961, 1962, 3, 1012, 506, 0, 1962,
		105, 1, 0, 0, 0, 1963, 1964, 5, 401, 0, 0, 1964, 1965, 7, 9, 0, 0, 1965,
		1966, 7, 1, 0, 0, 1966, 1967, 3, 1012, 506, 0, 1967, 1970, 1, 0, 0, 0,
		1968, 1969, 7, 1, 0, 0, 1969, 1971, 3, 1012, 506, 0, 1970, 1968, 1, 0,
		0, 0, 1970, 1971, 1, 0, 0, 0, 1971, 107, 1, 0, 0, 0, 1972, 1973, 5, 347,
		0, 0, 1973, 1974, 5, 422, 0, 0, 1974, 1975, 3, 1012, 506, 0, 1975, 109,
		1, 0, 0, 0, 1976, 1977, 5, 445, 0, 0, 1977, 1978, 5, 422, 0, 0, 1978, 1980,
		3, 1012, 506, 0, 1979, 1981, 3, 826, 413, 0, 1980, 1979, 1, 0, 0, 0, 1980,
		1981, 1, 0, 0, 0, 1981, 111, 1, 0, 0, 0, 1982, 1983, 5, 57, 0, 0, 1983,
		1984, 5, 19, 0, 0, 1984, 1986, 5, 422, 0, 0, 1985, 1987, 7, 7, 0, 0, 1986,
		1985, 1, 0, 0, 0, 1986, 1987, 1, 0, 0, 0, 1987, 1988, 1, 0, 0, 0, 1988,
		1989, 5, 172, 0, 0, 1989, 2000, 3, 1012, 506, 0, 1990, 1991, 5, 2, 0, 0,
		1991, 1996, 5, 518, 0, 0, 1992, 1993, 5, 3, 0, 0, 1993, 1995, 5, 518, 0,
		0, 1994, 1992, 1, 0, 0, 0, 1995, 1998, 1, 0, 0, 0, 1996, 1994, 1, 0, 0,
		0, 1996, 1997, 1, 0, 0, 0, 1997, 1999, 1, 0, 0, 0, 1998, 1996, 1, 0, 0,
		0, 1999, 2001, 5, 4, 0, 0, 2000, 1990, 1, 0, 0, 0, 2000, 2001, 1, 0, 0,
		0, 2001, 2009, 1, 0, 0, 0, 2002, 2003, 5, 57, 0, 0, 2003, 2004, 5, 19,
		0, 0, 2004, 2005, 5, 257, 0, 0, 2005, 2006, 5, 469, 0, 0, 2006, 2007, 5,
		172, 0, 0, 2007, 2009, 3, 1012, 506, 0, 2008, 1982, 1, 0, 0, 0, 2008, 2002,
		1, 0, 0, 0, 2009, 113, 1, 0, 0, 0, 2010, 2012, 5, 401, 0, 0, 2011, 2013,
		5, 428, 0, 0, 2012, 2011, 1, 0, 0, 0, 2012, 2013, 1, 0, 0, 0, 2013, 2014,
		1, 0, 0, 0, 2014, 2015, 5, 304, 0, 0, 2015, 2016, 5, 172, 0, 0, 2016, 2019,
		3, 1012, 506, 0, 2017, 2018, 5, 478, 0, 0, 2018, 2020, 3, 852, 426, 0,
		2019, 2017, 1, 0, 0, 0, 2019, 2020, 1, 0, 0, 0, 2020, 2031, 1, 0, 0, 0,
		2021, 2022, 5, 298, 0, 0, 2022, 2023, 5, 55, 0, 0, 2023, 2028, 3, 770,
		385, 0, 2024, 2025, 5, 3, 0, 0, 2025, 2027, 3, 770, 385, 0, 2026, 2024,
		1, 0, 0, 0, 2027, 2030, 1, 0, 0, 0, 2028, 2026, 1, 0, 0, 0, 2028, 2029,
		1, 0, 0, 0, 2029, 2032, 1, 0, 0, 0, 2030, 2028, 1, 0, 0, 0, 2031, 2021,
		1, 0, 0, 0, 2031, 2032, 1, 0, 0, 0, 2032, 2034, 1, 0, 0, 0, 2033, 2035,
		3, 774, 387, 0, 2034, 2033, 1, 0, 0, 0, 2034, 2035, 1, 0, 0, 0, 2035, 115,
		1, 0, 0, 0, 2036, 2037, 5, 347, 0, 0, 2037, 2038, 5, 303, 0, 0, 2038, 2039,
		3, 1018, 509, 0, 2039, 2040, 5, 172, 0, 0, 2040, 2041, 3, 1012, 506, 0,
		2041, 117, 1, 0, 0, 0, 2042, 2045, 5, 90, 0, 0, 2043, 2044, 5, 297, 0,
		0, 2044, 2046, 5, 356, 0, 0, 2045, 2043, 1, 0, 0, 0, 2045, 2046, 1, 0,
		0, 0, 2046, 2047, 1, 0, 0, 0, 2047, 2051, 5, 469, 0, 0, 2048, 2049, 5,
		197, 0, 0, 2049, 2050, 5, 281, 0, 0, 2050, 2052, 5, 148, 0, 0, 2051, 2048,
		1, 0, 0, 0, 2051, 2052, 1, 0, 0, 0, 2052, 2053, 1, 0, 0, 0, 2053, 2065,
		3, 1012, 506, 0, 2054, 2055, 5, 2, 0, 0, 2055, 2060, 3, 124, 62, 0, 2056,
		2057, 5, 3, 0, 0, 2057, 2059, 3, 124, 62, 0, 2058, 2056, 1, 0, 0, 0, 2059,
		2062, 1, 0, 0, 0, 2060, 2058, 1, 0, 0, 0, 2060, 2061, 1, 0, 0, 0, 2061,
		2063, 1, 0, 0, 0, 2062, 2060, 1, 0, 0, 0, 2063, 2064, 5, 4, 0, 0, 2064,
		2066, 1, 0, 0, 0, 2065, 2054, 1, 0, 0, 0, 2065, 2066, 1, 0, 0, 0, 2066,
		2068, 1, 0, 0, 0, 2067, 2069, 3, 970, 485, 0, 2068, 2067, 1, 0, 0, 0, 2068,
		2069, 1, 0, 0, 0, 2069, 2072, 1, 0, 0, 0, 2070, 2071, 5, 390, 0, 0, 2071,
		2073, 7, 10, 0, 0, 2072, 2070, 1, 0, 0, 0, 2072, 2073, 1, 0, 0, 0, 2073,
		2074, 1, 0, 0, 0, 2074, 2075, 5, 27, 0, 0, 2075, 2076, 3, 752, 376, 0,
		2076, 119, 1, 0, 0, 0, 2077, 2078, 5, 19, 0, 0, 2078, 2079, 5, 469, 0,
		0, 2079, 2091, 3, 1012, 506, 0, 2080, 2081, 5, 2, 0, 0, 2081, 2086, 3,
		124, 62, 0, 2082, 2083, 5, 3, 0, 0, 2083, 2085, 3, 124, 62, 0, 2084, 2082,
		1, 0, 0, 0, 2085, 2088, 1, 0, 0, 0, 2086, 2084, 1, 0, 0, 0, 2086, 2087,
		1, 0, 0, 0, 2087, 2089, 1, 0, 0, 0, 2088, 2086, 1, 0, 0, 0, 2089, 2090,
		5, 4, 0, 0, 2090, 2092, 1, 0, 0, 0, 2091, 2080, 1, 0, 0, 0, 2091, 2092,
		1, 0, 0, 0, 2092, 2093, 1, 0, 0, 0, 2093, 2094, 5, 27, 0, 0, 2094, 2095,
		3, 752, 376, 0, 2095, 2117, 1, 0, 0, 0, 2096, 2097, 5, 19, 0, 0, 2097,
		2098, 5, 469, 0, 0, 2098, 2099, 3, 1012, 506, 0, 2099, 2100, 5, 396, 0,
		0, 2100, 2101, 5, 390, 0, 0, 2101, 2102, 7, 10, 0, 0, 2102, 2117, 1, 0,
		0, 0, 2103, 2104, 5, 19, 0, 0, 2104, 2105, 5, 469, 0, 0, 2105, 2106, 3,
		1012, 506, 0, 2106, 2107, 5, 396, 0, 0, 2107, 2108, 3, 954, 477, 0, 2108,
		2117, 1, 0, 0, 0, 2109, 2110, 5, 19, 0, 0, 2110, 2111, 5, 469, 0, 0, 2111,
		2112, 3, 1012, 506, 0, 2112, 2113, 7, 11, 0, 0, 2113, 2114, 5, 121, 0,
		0, 2114, 2115, 3, 752, 376, 0, 2115, 2117, 1, 0, 0, 0, 2116, 2077, 1, 0,
		0, 0, 2116, 2096, 1, 0, 0, 0, 2116, 2103, 1, 0, 0, 0, 2116, 2109, 1, 0,
		0, 0, 2117, 121, 1, 0, 0, 0, 2118, 2119, 5, 132, 0, 0, 2119, 2122, 5, 469,
		0, 0, 2120, 2121, 5, 197, 0, 0, 2121, 2123, 5, 148, 0, 0, 2122, 2120, 1,
		0, 0, 0, 2122, 2123, 1, 0, 0, 0, 2123, 2124, 1, 0, 0, 0, 2124, 2125, 3,
		1012, 506, 0, 2125, 123, 1, 0, 0, 0, 2126, 2128, 3, 1018, 509, 0, 2127,
		2129, 3, 970, 485, 0, 2128, 2127, 1, 0, 0, 0, 2128, 2129, 1, 0, 0, 0, 2129,
		125, 1, 0, 0, 0, 2130, 2131, 5, 414, 0, 0, 2131, 2133, 5, 427, 0, 0, 2132,
		2134, 3, 1012, 506, 0, 2133, 2132, 1, 0, 0, 0, 2133, 2134, 1, 0, 0, 0,
		2134, 2138, 1, 0, 0, 0, 2135, 2137, 3, 128, 64, 0, 2136, 2135, 1, 0, 0,
		0, 2137, 2140, 1, 0, 0, 0, 2138, 2136, 1, 0, 0, 0, 2138, 2139, 1, 0, 0,
		0, 2139, 2141, 1, 0, 0, 0, 2140, 2138, 1, 0, 0, 0, 2141, 2145, 5, 27, 0,
		0, 2142, 2146, 3, 74, 37, 0, 2143, 2146, 3, 352, 176, 0, 2144, 2146, 3,
		648, 324, 0, 2145, 2142, 1, 0, 0, 0, 2145, 2143, 1, 0, 0, 0, 2145, 2144,
		1, 0, 0, 0, 2146, 127, 1, 0, 0, 0, 2147, 2150, 3, 954, 477, 0, 2148, 2150,
		3, 132, 66, 0, 2149, 2147, 1, 0, 0, 0, 2149, 2148, 1, 0, 0, 0, 2150, 129,
		1, 0, 0, 0, 2151, 2152, 5, 132, 0, 0, 2152, 2153, 5, 427, 0, 0, 2153, 2155,
		3, 1012, 506, 0, 2154, 2156, 5, 169, 0, 0, 2155, 2154, 1, 0, 0, 0, 2155,
		2156, 1, 0, 0, 0, 2156, 131, 1, 0, 0, 0, 2157, 2163, 5, 385, 0, 0, 2158,
		2159, 5, 406, 0, 0, 2159, 2160, 5, 2, 0, 0, 2160, 2161, 3, 976, 488, 0,
		2161, 2162, 5, 4, 0, 0, 2162, 2164, 1, 0, 0, 0, 2163, 2158, 1, 0, 0, 0,
		2163, 2164, 1, 0, 0, 0, 2164, 2165, 1, 0, 0, 0, 2165, 2166, 5, 153, 0,
		0, 2166, 2167, 5, 2, 0, 0, 2167, 2168, 3, 986, 493, 0, 2168, 2169, 5, 4,
		0, 0, 2169, 133, 1, 0, 0, 0, 2170, 2171, 5, 90, 0, 0, 2171, 2172, 5, 257,
		0, 0, 2172, 2176, 5, 469, 0, 0, 2173, 2174, 5, 197, 0, 0, 2174, 2175, 5,
		281, 0, 0, 2175, 2177, 5, 148, 0, 0, 2176, 2173, 1, 0, 0, 0, 2176, 2177,
		1, 0, 0, 0, 2177, 2178, 1, 0, 0, 0, 2178, 2197, 3, 1012, 506, 0, 2179,
		2180, 5, 2, 0, 0, 2180, 2185, 3, 124, 62, 0, 2181, 2182, 5, 3, 0, 0, 2182,
		2184, 3, 124, 62, 0, 2183, 2181, 1, 0, 0, 0, 2184, 2187, 1, 0, 0, 0, 2185,
		2183, 1, 0, 0, 0, 2185, 2186, 1, 0, 0, 0, 2186, 2192, 1, 0, 0, 0, 2187,
		2185, 1, 0, 0, 0, 2188, 2189, 5, 3, 0, 0, 2189, 2191, 3, 42, 21, 0, 2190,
		2188, 1, 0, 0, 0, 2191, 2194, 1, 0, 0, 0, 2192, 2190, 1, 0, 0, 0, 2192,
		2193, 1, 0, 0, 0, 2193, 2195, 1, 0, 0, 0, 2194, 2192, 1, 0, 0, 0, 2195,
		2196, 5, 4, 0, 0, 2196, 2198, 1, 0, 0, 0, 2197, 2179, 1, 0, 0, 0, 2197,
		2198, 1, 0, 0, 0, 2198, 2200, 1, 0, 0, 0, 2199, 2201, 3, 970, 485, 0, 2200,
		2199, 1, 0, 0, 0, 2200, 2201, 1, 0, 0, 0, 2201, 2205, 1, 0, 0, 0, 2202,
		2204, 3, 138, 69, 0, 2203, 2202, 1, 0, 0, 0, 2204, 2207, 1, 0, 0, 0, 2205,
		2203, 1, 0, 0, 0, 2205, 2206, 1, 0, 0, 0, 2206, 2208, 1, 0, 0, 0, 2207,
		2205, 1, 0, 0, 0, 2208, 2209, 5, 27, 0, 0, 2209, 2210, 3, 752, 376, 0,
		2210, 135, 1, 0, 0, 0, 2211, 2224, 3, 866, 433, 0, 2212, 2213, 5, 2, 0,
		0, 2213, 2218, 3, 866, 433, 0, 2214, 2215, 5, 3, 0, 0, 2215, 2217, 3, 866,
		433, 0, 2216, 2214, 1, 0, 0, 0, 2217, 2220, 1, 0, 0, 0, 2218, 2216, 1,
		0, 0, 0, 2218, 2219, 1, 0, 0, 0, 2219, 2221, 1, 0, 0, 0, 2220, 2218, 1,
		0, 0, 0, 2221, 2222, 5, 4, 0, 0, 2222, 2224, 1, 0, 0, 0, 2223, 2211, 1,
		0, 0, 0, 2223, 2212, 1, 0, 0, 0, 2224, 137, 1, 0, 0, 0, 2225, 2226, 5,
		303, 0, 0, 2226, 2227, 5, 55, 0, 0, 2227, 2233, 3, 136, 68, 0, 2228, 2233,
		3, 948, 474, 0, 2229, 2233, 3, 52, 26, 0, 2230, 2233, 3, 950, 475, 0, 2231,
		2233, 3, 954, 477, 0, 2232, 2225, 1, 0, 0, 0, 2232, 2228, 1, 0, 0, 0, 2232,
		2229, 1, 0, 0, 0, 2232, 2230, 1, 0, 0, 0, 2232, 2231, 1, 0, 0, 0, 2233,
		139, 1, 0, 0, 0, 2234, 2235, 5, 401, 0, 0, 2235, 2236, 5, 257, 0, 0, 2236,
		2239, 5, 470, 0, 0, 2237, 2238, 7, 1, 0, 0, 2238, 2240, 3, 1012, 506, 0,
		2239, 2237, 1, 0, 0, 0, 2239, 2240, 1, 0, 0, 0, 2240, 2245, 1, 0, 0, 0,
		2241, 2242, 5, 240, 0, 0, 2242, 2246, 3, 976, 488, 0, 2243, 2244, 5, 478,
		0, 0, 2244, 2246, 3, 852, 426, 0, 2245, 2241, 1, 0, 0, 0, 2245, 2243, 1,
		0, 0, 0, 2245, 2246, 1, 0, 0, 0, 2246, 141, 1, 0, 0, 0, 2247, 2248, 5,
		132, 0, 0, 2248, 2249, 5, 257, 0, 0, 2249, 2252, 5, 469, 0, 0, 2250, 2251,
		5, 197, 0, 0, 2251, 2253, 5, 148, 0, 0, 2252, 2250, 1, 0, 0, 0, 2252, 2253,
		1, 0, 0, 0, 2253, 2254, 1, 0, 0, 0, 2254, 2255, 3, 1012, 506, 0, 2255,
		143, 1, 0, 0, 0, 2256, 2257, 5, 19, 0, 0, 2257, 2258, 5, 257, 0, 0, 2258,
		2259, 5, 469, 0, 0, 2259, 2264, 3, 1012, 506, 0, 2260, 2265, 3, 950, 475,
		0, 2261, 2265, 3, 272, 136, 0, 2262, 2265, 3, 276, 138, 0, 2263, 2265,
		3, 274, 137, 0, 2264, 2260, 1, 0, 0, 0, 2264, 2261, 1, 0, 0, 0, 2264, 2262,
		1, 0, 0, 0, 2264, 2263, 1, 0, 0, 0, 2265, 2273, 1, 0, 0, 0, 2266, 2267,
		5, 19, 0, 0, 2267, 2268, 5, 257, 0, 0, 2268, 2269, 5, 469, 0, 0, 2269,
		2270, 3, 1012, 506, 0, 2270, 2271, 3, 952, 476, 0, 2271, 2273, 1, 0, 0,
		0, 2272, 2256, 1, 0, 0, 0, 2272, 2266, 1, 0, 0, 0, 2273, 145, 1, 0, 0,
		0, 2274, 2275, 5, 348, 0, 0, 2275, 2276, 5, 257, 0, 0, 2276, 2277, 5, 469,
		0, 0, 2277, 2283, 3, 1012, 506, 0, 2278, 2281, 5, 303, 0, 0, 2279, 2282,
		3, 936, 468, 0, 2280, 2282, 3, 922, 461, 0, 2281, 2279, 1, 0, 0, 0, 2281,
		2280, 1, 0, 0, 0, 2282, 2284, 1, 0, 0, 0, 2283, 2278, 1, 0, 0, 0, 2283,
		2284, 1, 0, 0, 0, 2284, 2286, 1, 0, 0, 0, 2285, 2287, 5, 169, 0, 0, 2286,
		2285, 1, 0, 0, 0, 2286, 2287, 1, 0, 0, 0, 2287, 2291, 1, 0, 0, 0, 2288,
		2289, 5, 480, 0, 0, 2289, 2290, 7, 12, 0, 0, 2290, 2292, 5, 269, 0, 0,
		2291, 2288, 1, 0, 0, 0, 2291, 2292, 1, 0, 0, 0, 2292, 2296, 1, 0, 0, 0,
		2293, 2294, 5, 480, 0, 0, 2294, 2295, 5, 324, 0, 0, 2295, 2297, 5, 518,
		0, 0, 2296, 2293, 1, 0, 0, 0, 2296, 2297, 1, 0, 0, 0, 2297, 147, 1, 0,
		0, 0, 2298, 2299, 5, 57, 0, 0, 2299, 2300, 5, 348, 0, 0, 2300, 2301, 5,
		257, 0, 0, 2301, 2302, 5, 469, 0, 0, 2302, 2304, 3, 1012, 506, 0, 2303,
		2305, 5, 169, 0, 0, 2304, 2303, 1, 0, 0, 0, 2304, 2305, 1, 0, 0, 0, 2305,
		149, 1, 0, 0, 0, 2306, 2307, 5, 14, 0, 0, 2307, 2308, 5, 396, 0, 0, 2308,
		2309, 5, 173, 0, 0, 2309, 2310, 5, 84, 0, 0, 2310, 2311, 5, 2, 0, 0, 2311,
		2312, 3, 962, 481, 0, 2312, 2315, 5, 4, 0, 0, 2313, 2314, 5, 480, 0, 0,
		2314, 2316, 5, 491, 0, 0, 2315, 2313, 1, 0, 0, 0, 2315, 2316, 1, 0, 0,
		0, 2316, 151, 1, 0, 0, 0, 2317, 2318, 5, 14, 0, 0, 2318, 2319, 5, 396,
		0, 0, 2319, 2320, 5, 358, 0, 0, 2320, 2321, 5, 408, 0, 0, 2321, 2322, 3,
		954, 477, 0, 2322, 153, 1, 0, 0, 0, 2323, 2324, 5, 14, 0, 0, 2324, 2325,
		5, 401, 0, 0, 2325, 2326, 5, 173, 0, 0, 2326, 2329, 5, 84, 0, 0, 2327,
		2328, 5, 240, 0, 0, 2328, 2330, 3, 976, 488, 0, 2329, 2327, 1, 0, 0, 0,
		2329, 2330, 1, 0, 0, 0, 2330, 155, 1, 0, 0, 0, 2331, 2332, 5, 14, 0, 0,
		2332, 2333, 5, 401, 0, 0, 2333, 2334, 5, 358, 0, 0, 2334, 2335, 5, 130,
		0, 0, 2335, 2336, 5, 172, 0, 0, 2336, 2338, 3, 1012, 506, 0, 2337, 2339,
		3, 826, 413, 0, 2338, 2337, 1, 0, 0, 0, 2338, 2339, 1, 0, 0, 0, 2339, 157,
		1, 0, 0, 0, 2340, 2341, 5, 14, 0, 0, 2341, 2342, 5, 401, 0, 0, 2342, 2343,
		5, 358, 0, 0, 2343, 2344, 5, 408, 0, 0, 2344, 2345, 5, 172, 0, 0, 2345,
		2347, 3, 1012, 506, 0, 2346, 2348, 3, 826, 413, 0, 2347, 2346, 1, 0, 0,
		0, 2347, 2348, 1, 0, 0, 0, 2348, 2351, 1, 0, 0, 0, 2349, 2350, 5, 478,
		0, 0, 2350, 2352, 3, 852, 426, 0, 2351, 2349, 1, 0, 0, 0, 2351, 2352, 1,
		0, 0, 0, 2352, 159, 1, 0, 0, 0, 2353, 2354, 5, 14, 0, 0, 2354, 2355, 5,
		354, 0, 0, 2355, 2356, 5, 422, 0, 0, 2356, 2358, 3, 1012, 506, 0, 2357,
		2359, 3, 826, 413, 0, 2358, 2357, 1, 0, 0, 0, 2358, 2359, 1, 0, 0, 0, 2359,
		161, 1, 0, 0, 0, 2360, 2361, 5, 14, 0, 0, 2361, 2362, 5, 57, 0, 0, 2362,
		2363, 5, 354, 0, 0, 2363, 2364, 5, 422, 0, 0, 2364, 2366, 3, 1012, 506,
		0, 2365, 2367, 3, 826, 413, 0, 2366, 2365, 1, 0, 0, 0, 2366, 2367, 1, 0,
		0, 0, 2367, 163, 1, 0, 0, 0, 2368, 2369, 5, 14, 0, 0, 2369, 2370, 5, 67,
		0, 0, 2370, 2371, 3, 830, 415, 0, 2371, 2372, 5, 332, 0, 0, 2372, 2373,
		5, 2, 0, 0, 2373, 2374, 3, 962, 481, 0, 2374, 2375, 5, 4, 0, 0, 2375, 165,
		1, 0, 0, 0, 2376, 2377, 5, 14, 0, 0, 2377, 2378, 5, 396, 0, 0, 2378, 2379,
		5, 422, 0, 0, 2379, 2380, 3, 1012, 506, 0, 2380, 2381, 5, 303, 0, 0, 2381,
		2384, 5, 2, 0, 0, 2382, 2385, 3, 1026, 513, 0, 2383, 2385, 5, 518, 0, 0,
		2384, 2382, 1, 0, 0, 0, 2384, 2383, 1, 0, 0, 0, 2385, 2386, 1, 0, 0, 0,
		2386, 2387, 5, 4, 0, 0, 2387, 2388, 5, 468, 0, 0, 2388, 2389, 5, 440, 0,
		0, 2389, 2390, 5, 518, 0, 0, 2390, 167, 1, 0, 0, 0, 2391, 2396, 5, 229,
		0, 0, 2392, 2394, 5, 85, 0, 0, 2393, 2392, 1, 0, 0, 0, 2393, 2394, 1, 0,
		0, 0, 2394, 2397, 1, 0, 0, 0, 2395, 2397, 5, 338, 0, 0, 2396, 2393, 1,
		0, 0, 0, 2396, 2395, 1, 0, 0, 0, 2397, 2400, 1, 0, 0, 0, 2398, 2401, 5,
		518, 0, 0, 2399, 2401, 3, 976, 488, 0, 2400, 2398, 1, 0, 0, 0, 2400, 2399,
		1, 0, 0, 0, 2401, 169, 1, 0, 0, 0, 2402, 2403, 5, 417, 0, 0, 2403, 171,
		1, 0, 0, 0, 2404, 2405, 5, 14, 0, 0, 2405, 2406, 5, 396, 0, 0, 2406, 2407,
		5, 32, 0, 0, 2407, 2408, 5, 70, 0, 0, 2408, 2409, 5, 403, 0, 0, 2409, 2413,
		5, 290, 0, 0, 2410, 2411, 5, 410, 0, 0, 2411, 2412, 5, 471, 0, 0, 2412,
		2414, 3, 1018, 509, 0, 2413, 2410, 1, 0, 0, 0, 2413, 2414, 1, 0, 0, 0,
		2414, 173, 1, 0, 0, 0, 2415, 2416, 5, 14, 0, 0, 2416, 2417, 5, 396, 0,
		0, 2417, 2418, 5, 32, 0, 0, 2418, 2419, 5, 70, 0, 0, 2419, 2420, 5, 403,
		0, 0, 2420, 2421, 5, 288, 0, 0, 2421, 175, 1, 0, 0, 0, 2422, 2423, 5, 19,
		0, 0, 2423, 2424, 5, 418, 0, 0, 2424, 2425, 3, 232, 116, 0, 2425, 177,
		1, 0, 0, 0, 2426, 2427, 5, 57, 0, 0, 2427, 2428, 5, 116, 0, 0, 2428, 2429,
		5, 35, 0, 0, 2429, 2434, 3, 976, 488, 0, 2430, 2431, 5, 3, 0, 0, 2431,
		2433, 3, 976, 488, 0, 2432, 2430, 1, 0, 0, 0, 2433, 2436, 1, 0, 0, 0, 2434,
		2432, 1, 0, 0, 0, 2434, 2435, 1, 0, 0, 0, 2435, 179, 1, 0, 0, 0, 2436,
		2434, 1, 0, 0, 0, 2437, 2438, 5, 401, 0, 0, 2438, 2439, 5, 83, 0, 0, 2439,
		2440, 5, 279, 0, 0, 2440, 181, 1, 0, 0, 0, 2441, 2442, 5, 90, 0, 0, 2442,
		2443, 5, 151, 0, 0, 2443, 2447, 5, 60, 0, 0, 2444, 2445, 5, 197, 0, 0,
		2445, 2446, 5, 281, 0, 0, 2446, 2448, 5, 148, 0, 0, 2447, 2444, 1, 0, 0,
		0, 2447, 2448, 1, 0, 0, 0, 2448, 2449, 1, 0, 0, 0, 2449, 2451, 3, 1026,
		513, 0, 2450, 2452, 3, 970, 485, 0, 2451, 2450, 1, 0, 0, 0, 2451, 2452,
		1, 0, 0, 0, 2452, 2453, 1, 0, 0, 0, 2453, 2454, 3, 954, 477, 0, 2454, 183,
		1, 0, 0, 0, 2455, 2456, 5, 401, 0, 0, 2456, 2457, 5, 90, 0, 0, 2457, 2458,
		5, 60, 0, 0, 2458, 2459, 3, 1026, 513, 0, 2459, 185, 1, 0, 0, 0, 2460,
		2461, 5, 132, 0, 0, 2461, 2464, 5, 60, 0, 0, 2462, 2463, 5, 197, 0, 0,
		2463, 2465, 5, 148, 0, 0, 2464, 2462, 1, 0, 0, 0, 2464, 2465, 1, 0, 0,
		0, 2465, 2466, 1, 0, 0, 0, 2466, 2467, 3, 1026, 513, 0, 2467, 187, 1, 0,
		0, 0, 2468, 2469, 5, 401, 0, 0, 2469, 2472, 5, 61, 0, 0, 2470, 2471, 5,
		240, 0, 0, 2471, 2473, 3, 976, 488, 0, 2472, 2470, 1, 0, 0, 0, 2472, 2473,
		1, 0, 0, 0, 2473, 189, 1, 0, 0, 0, 2474, 2475, 5, 19, 0, 0, 2475, 2476,
		5, 60, 0, 0, 2476, 2477, 3, 1026, 513, 0, 2477, 2478, 3, 276, 138, 0, 2478,
		191, 1, 0, 0, 0, 2479, 2480, 5, 90, 0, 0, 2480, 2481, 5, 410, 0, 0, 2481,
		2485, 5, 471, 0, 0, 2482, 2483, 5, 197, 0, 0, 2483, 2484, 5, 281, 0, 0,
		2484, 2486, 5, 148, 0, 0, 2485, 2482, 1, 0, 0, 0, 2485, 2486, 1, 0, 0,
		0, 2486, 2487, 1, 0, 0, 0, 2487, 2488, 3, 1026, 513, 0, 2488, 2489, 3,
		194, 97, 0, 2489, 2491, 3, 196, 98, 0, 2490, 2492, 3, 970, 485, 0, 2491,
		2490, 1, 0, 0, 0, 2491, 2492, 1, 0, 0, 0, 2492, 2494, 1, 0, 0, 0, 2493,
		2495, 3, 954, 477, 0, 2494, 2493, 1, 0, 0, 0, 2494, 2495, 1, 0, 0, 0, 2495,
		193, 1, 0, 0, 0, 2496, 2497, 5, 446, 0, 0, 2497, 2498, 5, 492, 0, 0, 2498,
		2499, 3, 1018, 509, 0, 2499, 195, 1, 0, 0, 0, 2500, 2501, 5, 248, 0, 0,
		2501, 2502, 5, 492, 0, 0, 2502, 2503, 3, 926, 463, 0, 2503, 197, 1, 0,
		0, 0, 2504, 2505, 5, 401, 0, 0, 2505, 2506, 5, 410, 0, 0, 2506, 2509, 5,
		472, 0, 0, 2507, 2508, 5, 240, 0, 0, 2508, 2510, 3, 976, 488, 0, 2509,
		2507, 1, 0, 0, 0, 2509, 2510, 1, 0, 0, 0, 2510, 199, 1, 0, 0, 0, 2511,
		2512, 5, 132, 0, 0, 2512, 2513, 5, 410, 0, 0, 2513, 2516, 5, 471, 0, 0,
		2514, 2515, 5, 197, 0, 0, 2515, 2517, 5, 148, 0, 0, 2516, 2514, 1, 0, 0,
		0, 2516, 2517, 1, 0, 0, 0, 2517, 2518, 1, 0, 0, 0, 2518, 2519, 3, 1026,
		513, 0, 2519, 201, 1, 0, 0, 0, 2520, 2521, 5, 19, 0, 0, 2521, 2522, 5,
		410, 0, 0, 2522, 2523, 5, 471, 0, 0, 2523, 2524, 3, 1026, 513, 0, 2524,
		2529, 3, 204, 102, 0, 2525, 2526, 5, 3, 0, 0, 2526, 2528, 3, 204, 102,
		0, 2527, 2525, 1, 0, 0, 0, 2528, 2531, 1, 0, 0, 0, 2529, 2527, 1, 0, 0,
		0, 2529, 2530, 1, 0, 0, 0, 2530, 203, 1, 0, 0, 0, 2531, 2529, 1, 0, 0,
		0, 2532, 2535, 3, 208, 104, 0, 2533, 2535, 3, 206, 103, 0, 2534, 2532,
		1, 0, 0, 0, 2534, 2533, 1, 0, 0, 0, 2535, 205, 1, 0, 0, 0, 2536, 2537,
		5, 396, 0, 0, 2537, 2538, 3, 958, 479, 0, 2538, 207, 1, 0, 0, 0, 2539,
		2540, 5, 78, 0, 0, 2540, 2541, 5, 492, 0, 0, 2541, 2542, 3, 976, 488, 0,
		2542, 209, 1, 0, 0, 0, 2543, 2544, 7, 8, 0, 0, 2544, 2545, 5, 410, 0, 0,
		2545, 2546, 5, 471, 0, 0, 2546, 2547, 3, 1026, 513, 0, 2547, 211, 1, 0,
		0, 0, 2548, 2549, 5, 396, 0, 0, 2549, 2550, 3, 1026, 513, 0, 2550, 2551,
		5, 27, 0, 0, 2551, 2552, 5, 117, 0, 0, 2552, 2553, 5, 410, 0, 0, 2553,
		2554, 5, 471, 0, 0, 2554, 213, 1, 0, 0, 0, 2555, 2556, 5, 14, 0, 0, 2556,
		2557, 7, 13, 0, 0, 2557, 2558, 5, 154, 0, 0, 2558, 2566, 3, 976, 488, 0,
		2559, 2564, 5, 480, 0, 0, 2560, 2561, 5, 518, 0, 0, 2561, 2565, 5, 433,
		0, 0, 2562, 2563, 5, 519, 0, 0, 2563, 2565, 5, 326, 0, 0, 2564, 2560, 1,
		0, 0, 0, 2564, 2562, 1, 0, 0, 0, 2565, 2567, 1, 0, 0, 0, 2566, 2559, 1,
		0, 0, 0, 2566, 2567, 1, 0, 0, 0, 2567, 2574, 1, 0, 0, 0, 2568, 2572, 5,
		290, 0, 0, 2569, 2570, 5, 35, 0, 0, 2570, 2573, 3, 976, 488, 0, 2571, 2573,
		5, 173, 0, 0, 2572, 2569, 1, 0, 0, 0, 2572, 2571, 1, 0, 0, 0, 2573, 2575,
		1, 0, 0, 0, 2574, 2568, 1, 0, 0, 0, 2574, 2575, 1, 0, 0, 0, 2575, 215,
		1, 0, 0, 0, 2576, 2577, 5, 401, 0, 0, 2577, 2580, 5, 155, 0, 0, 2578, 2579,
		5, 240, 0, 0, 2579, 2581, 3, 976, 488, 0, 2580, 2578, 1, 0, 0, 0, 2580,
		2581, 1, 0, 0, 0, 2581, 2585, 1, 0, 0, 0, 2582, 2583, 5, 290, 0, 0, 2583,
		2584, 5, 35, 0, 0, 2584, 2586, 3, 976, 488, 0, 2585, 2582, 1, 0, 0, 0,
		2585, 2586, 1, 0, 0, 0, 2586, 217, 1, 0, 0, 0, 2587, 2588, 5, 90, 0, 0,
		2588, 2589, 5, 122, 0, 0, 2589, 2590, 3, 230, 115, 0, 2590, 2591, 5, 460,
		0, 0, 2591, 2592, 3, 1012, 506, 0, 2592, 2593, 5, 2, 0, 0, 2593, 2598,
		3, 228, 114, 0, 2594, 2595, 5, 3, 0, 0, 2595, 2597, 3, 228, 114, 0, 2596,
		2594, 1, 0, 0, 0, 2597, 2600, 1, 0, 0, 0, 2598, 2596, 1, 0, 0, 0, 2598,
		2599, 1, 0, 0, 0, 2599, 2601, 1, 0, 0, 0, 2600, 2598, 1, 0, 0, 0, 2601,
		2603, 5, 4, 0, 0, 2602, 2604, 3, 954, 477, 0, 2603, 2602, 1, 0, 0, 0, 2603,
		2604, 1, 0, 0, 0, 2604, 219, 1, 0, 0, 0, 2605, 2606, 5, 132, 0, 0, 2606,
		2607, 5, 122, 0, 0, 2607, 2609, 3, 1012, 506, 0, 2608, 2610, 5, 56, 0,
		0, 2609, 2608, 1, 0, 0, 0, 2609, 2610, 1, 0, 0, 0, 2610, 221, 1, 0, 0,
		0, 2611, 2612, 5, 348, 0, 0, 2612, 2613, 5, 122, 0, 0, 2613, 2614, 3, 1012,
		506, 0, 2614, 223, 1, 0, 0, 0, 2615, 2616, 5, 401, 0, 0, 2616, 2618, 5,
		122, 0, 0, 2617, 2619, 3, 1012, 506, 0, 2618, 2617, 1, 0, 0, 0, 2618, 2619,
		1, 0, 0, 0, 2619, 225, 1, 0, 0, 0, 2620, 2621, 5, 57, 0, 0, 2621, 2622,
		5, 348, 0, 0, 2622, 2623, 5, 122, 0, 0, 2623, 2624, 3, 1012, 506, 0, 2624,
		227, 1, 0, 0, 0, 2625, 2626, 3, 1012, 506, 0, 2626, 2627, 5, 227, 0, 0,
		2627, 2632, 1, 0, 0, 0, 2628, 2629, 3, 1012, 506, 0, 2629, 2630, 5, 461,
		0, 0, 2630, 2632, 1, 0, 0, 0, 2631, 2625, 1, 0, 0, 0, 2631, 2628, 1, 0,
		0, 0, 2632, 229, 1, 0, 0, 0, 2633, 2634, 3, 1012, 506, 0, 2634, 231, 1,
		0, 0, 0, 2635, 2684, 3, 234, 117, 0, 2636, 2684, 3, 236, 118, 0, 2637,
		2684, 3, 238, 119, 0, 2638, 2684, 3, 240, 120, 0, 2639, 2684, 3, 242, 121,
		0, 2640, 2684, 3, 244, 122, 0, 2641, 2684, 3, 246, 123, 0, 2642, 2684,
		3, 248, 124, 0, 2643, 2684, 3, 250, 125, 0, 2644, 2684, 3, 252, 126, 0,
		2645, 2684, 3, 254, 127, 0, 2646, 2684, 3, 256, 128, 0, 2647, 2684, 3,
		258, 129, 0, 2648, 2684, 3, 260, 130, 0, 2649, 2684, 3, 262, 131, 0, 2650,
		2684, 3, 264, 132, 0, 2651, 2684, 3, 266, 133, 0, 2652, 2684, 3, 268, 134,
		0, 2653, 2684, 3, 270, 135, 0, 2654, 2684, 3, 272, 136, 0, 2655, 2684,
		3, 274, 137, 0, 2656, 2684, 3, 276, 138, 0, 2657, 2684, 3, 284, 142, 0,
		2658, 2684, 3, 286, 143, 0, 2659, 2684, 3, 288, 144, 0, 2660, 2684, 3,
		292, 146, 0, 2661, 2684, 3, 290, 145, 0, 2662, 2684, 3, 294, 147, 0, 2663,
		2684, 3, 296, 148, 0, 2664, 2684, 3, 298, 149, 0, 2665, 2684, 3, 300, 150,
		0, 2666, 2684, 3, 278, 139, 0, 2667, 2684, 3, 282, 141, 0, 2668, 2684,
		3, 306, 153, 0, 2669, 2684, 3, 308, 154, 0, 2670, 2684, 3, 312, 156, 0,
		2671, 2684, 3, 310, 155, 0, 2672, 2684, 3, 314, 157, 0, 2673, 2684, 3,
		316, 158, 0, 2674, 2684, 3, 318, 159, 0, 2675, 2684, 3, 338, 169, 0, 2676,
		2684, 3, 340, 170, 0, 2677, 2684, 3, 342, 171, 0, 2678, 2684, 3, 946, 473,
		0, 2679, 2684, 3, 344, 172, 0, 2680, 2684, 3, 346, 173, 0, 2681, 2684,
		3, 348, 174, 0, 2682, 2684, 3, 350, 175, 0, 2683, 2635, 1, 0, 0, 0, 2683,
		2636, 1, 0, 0, 0, 2683, 2637, 1, 0, 0, 0, 2683, 2638, 1, 0, 0, 0, 2683,
		2639, 1, 0, 0, 0, 2683, 2640, 1, 0, 0, 0, 2683, 2641, 1, 0, 0, 0, 2683,
		2642, 1, 0, 0, 0, 2683, 2643, 1, 0, 0, 0, 2683, 2644, 1, 0, 0, 0, 2683,
		2645, 1, 0, 0, 0, 2683, 2646, 1, 0, 0, 0, 2683, 2647, 1, 0, 0, 0, 2683,
		2648, 1, 0, 0, 0, 2683, 2649, 1, 0, 0, 0, 2683, 2650, 1, 0, 0, 0, 2683,
		2651, 1, 0, 0, 0, 2683, 2652, 1, 0, 0, 0, 2683, 2653, 1, 0, 0, 0, 2683,
		2654, 1, 0, 0, 0, 2683, 2655, 1, 0, 0, 0, 2683, 2656, 1, 0, 0, 0, 2683,
		2657, 1, 0, 0, 0, 2683, 2658, 1, 0, 0, 0, 2683, 2659, 1, 0, 0, 0, 2683,
		2660, 1, 0, 0, 0, 2683, 2661, 1, 0, 0, 0, 2683, 2662, 1, 0, 0, 0, 2683,
		2663, 1, 0, 0, 0, 2683, 2664, 1, 0, 0, 0, 2683, 2665, 1, 0, 0, 0, 2683,
		2666, 1, 0, 0, 0, 2683, 2667, 1, 0, 0, 0, 2683, 2668, 1, 0, 0, 0, 2683,
		2669, 1, 0, 0, 0, 2683, 2670, 1, 0, 0, 0, 2683, 2671, 1, 0, 0, 0, 2683,
		2672, 1, 0, 0, 0, 2683, 2673, 1, 0, 0, 0, 2683, 2674, 1, 0, 0, 0, 2683,
		2675, 1, 0, 0, 0, 2683, 2676, 1, 0, 0, 0, 2683, 2677, 1, 0, 0, 0, 2683,
		2678, 1, 0, 0, 0, 2683, 2679, 1, 0, 0, 0, 2683, 2680, 1, 0, 0, 0, 2683,
		2681, 1, 0, 0, 0, 2683, 2682, 1, 0, 0, 0, 2684, 233, 1, 0, 0, 0, 2685,
		2686, 5, 13, 0, 0, 2686, 2687, 7, 14, 0, 0, 2687, 2688, 3, 976, 488, 0,
		2688, 235, 1, 0, 0, 0, 2689, 2690, 5, 132, 0, 0, 2690, 2691, 7, 14, 0,
		0, 2691, 2692, 3, 976, 488, 0, 2692, 237, 1, 0, 0, 0, 2693, 2694, 5, 270,
		0, 0, 2694, 2695, 5, 173, 0, 0, 2695, 2696, 5, 192, 0, 0, 2696, 2697, 3,
		976, 488, 0, 2697, 2698, 5, 440, 0, 0, 2698, 2699, 3, 976, 488, 0, 2699,
		239, 1, 0, 0, 0, 2700, 2701, 5, 13, 0, 0, 2701, 2702, 5, 35, 0, 0, 2702,
		2707, 3, 976, 488, 0, 2703, 2704, 5, 3, 0, 0, 2704, 2706, 3, 976, 488,
		0, 2705, 2703, 1, 0, 0, 0, 2706, 2709, 1, 0, 0, 0, 2707, 2705, 1, 0, 0,
		0, 2707, 2708, 1, 0, 0, 0, 2708, 2717, 1, 0, 0, 0, 2709, 2707, 1, 0, 0,
		0, 2710, 2711, 5, 218, 0, 0, 2711, 2712, 5, 473, 0, 0, 2712, 2715, 3, 1026,
		513, 0, 2713, 2714, 5, 72, 0, 0, 2714, 2716, 3, 1026, 513, 0, 2715, 2713,
		1, 0, 0, 0, 2715, 2716, 1, 0, 0, 0, 2716, 2718, 1, 0, 0, 0, 2717, 2710,
		1, 0, 0, 0, 2717, 2718, 1, 0, 0, 0, 2718, 241, 1, 0, 0, 0, 2719, 2720,
		5, 132, 0, 0, 2720, 2721, 5, 35, 0, 0, 2721, 2726, 3, 976, 488, 0, 2722,
		2723, 5, 3, 0, 0, 2723, 2725, 3, 976, 488, 0, 2724, 2722, 1, 0, 0, 0, 2725,
		2728, 1, 0, 0, 0, 2726, 2724, 1, 0, 0, 0, 2726, 2727, 1, 0, 0, 0, 2727,
		2736, 1, 0, 0, 0, 2728, 2726, 1, 0, 0, 0, 2729, 2730, 5, 172, 0, 0, 2730,
		2731, 5, 473, 0, 0, 2731, 2734, 3, 1026, 513, 0, 2732, 2733, 5, 72, 0,
		0, 2733, 2735, 3, 1026, 513, 0, 2734, 2732, 1, 0, 0, 0, 2734, 2735, 1,
		0, 0, 0, 2735, 2737, 1, 0, 0, 0, 2736, 2729, 1, 0, 0, 0, 2736, 2737, 1,
		0, 0, 0, 2737, 2739, 1, 0, 0, 0, 2738, 2740, 5, 169, 0, 0, 2739, 2738,
		1, 0, 0, 0, 2739, 2740, 1, 0, 0, 0, 2740, 243, 1, 0, 0, 0, 2741, 2742,
		5, 116, 0, 0, 2742, 2743, 5, 35, 0, 0, 2743, 2748, 3, 976, 488, 0, 2744,
		2745, 5, 3, 0, 0, 2745, 2747, 3, 976, 488, 0, 2746, 2744, 1, 0, 0, 0, 2747,
		2750, 1, 0, 0, 0, 2748, 2746, 1, 0, 0, 0, 2748, 2749, 1, 0, 0, 0, 2749,
		245, 1, 0, 0, 0, 2750, 2748, 1, 0, 0, 0, 2751, 2752, 5, 270, 0, 0, 2752,
		2753, 5, 35, 0, 0, 2753, 2754, 5, 192, 0, 0, 2754, 2755, 3, 976, 488, 0,
		2755, 2756, 5, 440, 0, 0, 2756, 2757, 3, 976, 488, 0, 2757, 2765, 1, 0,
		0, 0, 2758, 2759, 5, 270, 0, 0, 2759, 2760, 5, 35, 0, 0, 2760, 2761, 3,
		976, 488, 0, 2761, 2762, 5, 396, 0, 0, 2762, 2763, 3, 958, 479, 0, 2763,
		2765, 1, 0, 0, 0, 2764, 2751, 1, 0, 0, 0, 2764, 2758, 1, 0, 0, 0, 2765,
		247, 1, 0, 0, 0, 2766, 2767, 5, 13, 0, 0, 2767, 2768, 5, 83, 0, 0, 2768,
		2769, 5, 278, 0, 0, 2769, 2774, 3, 976, 488, 0, 2770, 2771, 5, 3, 0, 0,
		2771, 2773, 3, 976, 488, 0, 2772, 2770, 1, 0, 0, 0, 2773, 2776, 1, 0, 0,
		0, 2774, 2772, 1, 0, 0, 0, 2774, 2775, 1, 0, 0, 0, 2775, 2784, 1, 0, 0,
		0, 2776, 2774, 1, 0, 0, 0, 2777, 2778, 5, 218, 0, 0, 2778, 2779, 5, 473,
		0, 0, 2779, 2782, 3, 1026, 513, 0, 2780, 2781, 5, 72, 0, 0, 2781, 2783,
		3, 1026, 513, 0, 2782, 2780, 1, 0, 0, 0, 2782, 2783, 1, 0, 0, 0, 2783,
		2785, 1, 0, 0, 0, 2784, 2777, 1, 0, 0, 0, 2784, 2785, 1, 0, 0, 0, 2785,
		249, 1, 0, 0, 0, 2786, 2787, 5, 132, 0, 0, 2787, 2788, 5, 83, 0, 0, 2788,
		2789, 5, 278, 0, 0, 2789, 2794, 3, 976, 488, 0, 2790, 2791, 5, 3, 0, 0,
		2791, 2793, 3, 976, 488, 0, 2792, 2790, 1, 0, 0, 0, 2793, 2796, 1, 0, 0,
		0, 2794, 2792, 1, 0, 0, 0, 2794, 2795, 1, 0, 0, 0, 2795, 2804, 1, 0, 0,
		0, 2796, 2794, 1, 0, 0, 0, 2797, 2798, 5, 172, 0, 0, 2798, 2799, 5, 473,
		0, 0, 2799, 2802, 3, 1026, 513, 0, 2800, 2801, 5, 72, 0, 0, 2801, 2803,
		3, 1026, 513, 0, 2802, 2800, 1, 0, 0, 0, 2802, 2803, 1, 0, 0, 0, 2803,
		2805, 1, 0, 0, 0, 2804, 2797, 1, 0, 0, 0, 2804, 2805, 1, 0, 0, 0, 2805,
		251, 1, 0, 0, 0, 2806, 2807, 5, 13, 0, 0, 2807, 2808, 5, 52, 0, 0, 2808,
		2809, 3, 1026, 513, 0, 2809, 2814, 3, 976, 488, 0, 2810, 2811, 5, 3, 0,
		0, 2811, 2813, 3, 976, 488, 0, 2812, 2810, 1, 0, 0, 0, 2813, 2816, 1, 0,
		0, 0, 2814, 2812, 1, 0, 0, 0, 2814, 2815, 1, 0, 0, 0, 2815, 2833, 1, 0,
		0, 0, 2816, 2814, 1, 0, 0, 0, 2817, 2818, 5, 132, 0, 0, 2818, 2819, 5,
		52, 0, 0, 2819, 2820, 3, 1026, 513, 0, 2820, 2825, 3, 976, 488, 0, 2821,
		2822, 5, 3, 0, 0, 2822, 2824, 3, 976, 488, 0, 2823, 2821, 1, 0, 0, 0, 2824,
		2827, 1, 0, 0, 0, 2825, 2823, 1, 0, 0, 0, 2825, 2826, 1, 0, 0, 0, 2826,
		2833, 1, 0, 0, 0, 2827, 2825, 1, 0, 0, 0, 2828, 2829, 5, 132, 0, 0, 2829,
		2830, 5, 18, 0, 0, 2830, 2831, 5, 52, 0, 0, 2831, 2833, 3, 1026, 513, 0,
		2832, 2806, 1, 0, 0, 0, 2832, 2817, 1, 0, 0, 0, 2832, 2828, 1, 0, 0, 0,
		2833, 253, 1, 0, 0, 0, 2834, 2835, 5, 396, 0, 0, 2835, 2836, 5, 243, 0,
		0, 2836, 2837, 5, 142, 0, 0, 2837, 2839, 5, 195, 0, 0, 2838, 2840, 3, 954,
		477, 0, 2839, 2838, 1, 0, 0, 0, 2839, 2840, 1, 0, 0, 0, 2840, 255, 1, 0,
		0, 0, 2841, 2842, 5, 90, 0, 0, 2842, 2843, 5, 201, 0, 0, 2843, 257, 1,
		0, 0, 0, 2844, 2845, 5, 68, 0, 0, 2845, 2846, 5, 424, 0, 0, 2846, 2847,
		5, 386, 0, 0, 2847, 2848, 5, 340, 0, 0, 2848, 259, 1, 0, 0, 0, 2849, 2850,
		5, 116, 0, 0, 2850, 2851, 5, 487, 0, 0, 2851, 2856, 3, 976, 488, 0, 2852,
		2853, 5, 3, 0, 0, 2853, 2855, 3, 976, 488, 0, 2854, 2852, 1, 0, 0, 0, 2855,
		2858, 1, 0, 0, 0, 2856, 2854, 1, 0, 0, 0, 2856, 2857, 1, 0, 0, 0, 2857,
		2859, 1, 0, 0, 0, 2858, 2856, 1, 0, 0, 0, 2859, 2860, 5, 290, 0, 0, 2860,
		2861, 5, 35, 0, 0, 2861, 2862, 3, 976, 488, 0, 2862, 261, 1, 0, 0, 0, 2863,
		2864, 5, 57, 0, 0, 2864, 2865, 5, 116, 0, 0, 2865, 2866, 5, 487, 0, 0,
		2866, 2871, 3, 976, 488, 0, 2867, 2868, 5, 3, 0, 0, 2868, 2870, 3, 976,
		488, 0, 2869, 2867, 1, 0, 0, 0, 2870, 2873, 1, 0, 0, 0, 2871, 2869, 1,
		0, 0, 0, 2871, 2872, 1, 0, 0, 0, 2872, 2874, 1, 0, 0, 0, 2873, 2871, 1,
		0, 0, 0, 2874, 2875, 5, 290, 0, 0, 2875, 2876, 5, 35, 0, 0, 2876, 2877,
		3, 976, 488, 0, 2877, 263, 1, 0, 0, 0, 2878, 2879, 5, 127, 0, 0, 2879,
		2880, 5, 487, 0, 0, 2880, 2885, 3, 976, 488, 0, 2881, 2882, 5, 3, 0, 0,
		2882, 2884, 3, 976, 488, 0, 2883, 2881, 1, 0, 0, 0, 2884, 2887, 1, 0, 0,
		0, 2885, 2883, 1, 0, 0, 0, 2885, 2886, 1, 0, 0, 0, 2886, 2888, 1, 0, 0,
		0, 2887, 2885, 1, 0, 0, 0, 2888, 2889, 5, 290, 0, 0, 2889, 2890, 5, 35,
		0, 0, 2890, 2891, 3, 976, 488, 0, 2891, 265, 1, 0, 0, 0, 2892, 2893, 5,
		57, 0, 0, 2893, 2894, 5, 127, 0, 0, 2894, 2895, 5, 487, 0, 0, 2895, 2900,
		3, 976, 488, 0, 2896, 2897, 5, 3, 0, 0, 2897, 2899, 3, 976, 488, 0, 2898,
		2896, 1, 0, 0, 0, 2899, 2902, 1, 0, 0, 0, 2900, 2898, 1, 0, 0, 0, 2900,
		2901, 1, 0, 0, 0, 2901, 2903, 1, 0, 0, 0, 2902, 2900, 1, 0, 0, 0, 2903,
		2904, 5, 290, 0, 0, 2904, 2905, 5, 35, 0, 0, 2905, 2906, 3, 976, 488, 0,
		2906, 267, 1, 0, 0, 0, 2907, 2908, 5, 13, 0, 0, 2908, 2909, 5, 205, 0,
		0, 2909, 2910, 3, 1018, 509, 0, 2910, 2915, 3, 1024, 512, 0, 2911, 2913,
		3, 86, 43, 0, 2912, 2914, 3, 958, 479, 0, 2913, 2912, 1, 0, 0, 0, 2913,
		2914, 1, 0, 0, 0, 2914, 2916, 1, 0, 0, 0, 2915, 2911, 1, 0, 0, 0, 2915,
		2916, 1, 0, 0, 0, 2916, 2918, 1, 0, 0, 0, 2917, 2919, 3, 970, 485, 0, 2918,
		2917, 1, 0, 0, 0, 2918, 2919, 1, 0, 0, 0, 2919, 269, 1, 0, 0, 0, 2920,
		2921, 5, 132, 0, 0, 2921, 2922, 5, 205, 0, 0, 2922, 2923, 3, 1018, 509,
		0, 2923, 271, 1, 0, 0, 0, 2924, 2925, 5, 353, 0, 0, 2925, 2926, 3, 1018,
		509, 0, 2926, 273, 1, 0, 0, 0, 2927, 2928, 5, 420, 0, 0, 2928, 2929, 5,
		480, 0, 0, 2929, 2930, 3, 1018, 509, 0, 2930, 275, 1, 0, 0, 0, 2931, 2932,
		5, 396, 0, 0, 2932, 2933, 3, 958, 479, 0, 2933, 277, 1, 0, 0, 0, 2934,
		2935, 5, 78, 0, 0, 2935, 2936, 5, 492, 0, 0, 2936, 2937, 3, 976, 488, 0,
		2937, 279, 1, 0, 0, 0, 2938, 2939, 5, 41, 0, 0, 2939, 2940, 3, 976, 488,
		0, 2940, 2941, 5, 21, 0, 0, 2941, 2942, 3, 976, 488, 0, 2942, 281, 1, 0,
		0, 0, 2943, 2945, 3, 826, 413, 0, 2944, 2943, 1, 0, 0, 0, 2944, 2945, 1,
		0, 0, 0, 2945, 2947, 1, 0, 0, 0, 2946, 2948, 3, 50, 25, 0, 2947, 2946,
		1, 0, 0, 0, 2947, 2948, 1, 0, 0, 0, 2948, 2950, 1, 0, 0, 0, 2949, 2951,
		3, 910, 455, 0, 2950, 2949, 1, 0, 0, 0, 2950, 2951, 1, 0, 0, 0, 2951, 2953,
		1, 0, 0, 0, 2952, 2954, 3, 52, 26, 0, 2953, 2952, 1, 0, 0, 0, 2953, 2954,
		1, 0, 0, 0, 2954, 2956, 1, 0, 0, 0, 2955, 2957, 3, 948, 474, 0, 2956, 2955,
		1, 0, 0, 0, 2956, 2957, 1, 0, 0, 0, 2957, 2959, 1, 0, 0, 0, 2958, 2960,
		3, 280, 140, 0, 2959, 2958, 1, 0, 0, 0, 2959, 2960, 1, 0, 0, 0, 2960, 283,
		1, 0, 0, 0, 2961, 2962, 5, 13, 0, 0, 2962, 2963, 5, 76, 0, 0, 2963, 2967,
		3, 34, 17, 0, 2964, 2968, 5, 161, 0, 0, 2965, 2966, 5, 16, 0, 0, 2966,
		2968, 3, 1018, 509, 0, 2967, 2964, 1, 0, 0, 0, 2967, 2965, 1, 0, 0, 0,
		2967, 2968, 1, 0, 0, 0, 2968, 2971, 1, 0, 0, 0, 2969, 2970, 7, 15, 0, 0,
		2970, 2972, 3, 1018, 509, 0, 2971, 2969, 1, 0, 0, 0, 2971, 2972, 1, 0,
		0, 0, 2972, 2974, 1, 0, 0, 0, 2973, 2975, 3, 954, 477, 0, 2974, 2973, 1,
		0, 0, 0, 2974, 2975, 1, 0, 0, 0, 2975, 285, 1, 0, 0, 0, 2976, 2977, 5,
		13, 0, 0, 2977, 2978, 5, 76, 0, 0, 2978, 2979, 5, 2, 0, 0, 2979, 2984,
		3, 34, 17, 0, 2980, 2981, 5, 3, 0, 0, 2981, 2983, 3, 34, 17, 0, 2982, 2980,
		1, 0, 0, 0, 2983, 2986, 1, 0, 0, 0, 2984, 2982, 1, 0, 0, 0, 2984, 2985,
		1, 0, 0, 0, 2985, 2987, 1, 0, 0, 0, 2986, 2984, 1, 0, 0, 0, 2987, 2990,
		5, 4, 0, 0, 2988, 2989, 7, 15, 0, 0, 2989, 2991, 3, 1018, 509, 0, 2990,
		2988, 1, 0, 0, 0, 2990, 2991, 1, 0, 0, 0, 2991, 2993, 1, 0, 0, 0, 2992,
		2994, 3, 954, 477, 0, 2993, 2992, 1, 0, 0, 0, 2993, 2994, 1, 0, 0, 0, 2994,
		287, 1, 0, 0, 0, 2995, 2996, 5, 132, 0, 0, 2996, 2997, 5, 76, 0, 0, 2997,
		3000, 3, 1018, 509, 0, 2998, 2999, 5, 172, 0, 0, 2999, 3001, 3, 1018, 509,
		0, 3000, 2998, 1, 0, 0, 0, 3000, 3001, 1, 0, 0, 0, 3001, 3003, 1, 0, 0,
		0, 3002, 3004, 3, 954, 477, 0, 3003, 3002, 1, 0, 0, 0, 3003, 3004, 1, 0,
		0, 0, 3004, 289, 1, 0, 0, 0, 3005, 3006, 5, 270, 0, 0, 3006, 3007, 5, 76,
		0, 0, 3007, 3011, 3, 34, 17, 0, 3008, 3012, 5, 161, 0, 0, 3009, 3010, 5,
		16, 0, 0, 3010, 3012, 3, 1018, 509, 0, 3011, 3008, 1, 0, 0, 0, 3011, 3009,
		1, 0, 0, 0, 3011, 3012, 1, 0, 0, 0, 3012, 3015, 1, 0, 0, 0, 3013, 3014,
		5, 172, 0, 0, 3014, 3016, 3, 1018, 509, 0, 3015, 3013, 1, 0, 0, 0, 3015,
		3016, 1, 0, 0, 0, 3016, 3018, 1, 0, 0, 0, 3017, 3019, 3, 954, 477, 0, 3018,
		3017, 1, 0, 0, 0, 3018, 3019, 1, 0, 0, 0, 3019, 291, 1, 0, 0, 0, 3020,
		3021, 5, 270, 0, 0, 3021, 3022, 5, 76, 0, 0, 3022, 3023, 3, 1018, 509,
		0, 3023, 3024, 3, 970, 485, 0, 3024, 293, 1, 0, 0, 0, 3025, 3026, 5, 353,
		0, 0, 3026, 3027, 5, 76, 0, 0, 3027, 3028, 3, 1018, 509, 0, 3028, 3029,
		5, 440, 0, 0, 3029, 3030, 3, 1018, 509, 0, 3030, 295, 1, 0, 0, 0, 3031,
		3032, 5, 298, 0, 0, 3032, 3033, 5, 55, 0, 0, 3033, 3036, 3, 1024, 512,
		0, 3034, 3035, 5, 172, 0, 0, 3035, 3037, 3, 1018, 509, 0, 3036, 3034, 1,
		0, 0, 0, 3036, 3037, 1, 0, 0, 0, 3037, 3039, 1, 0, 0, 0, 3038, 3040, 3,
		954, 477, 0, 3039, 3038, 1, 0, 0, 0, 3039, 3040, 1, 0, 0, 0, 3040, 297,
		1, 0, 0, 0, 3041, 3042, 5, 353, 0, 0, 3042, 3043, 5, 376, 0, 0, 3043, 3044,
		3, 1018, 509, 0, 3044, 3045, 3, 1018, 509, 0, 3045, 299, 1, 0, 0, 0, 3046,
		3048, 7, 16, 0, 0, 3047, 3046, 1, 0, 0, 0, 3047, 3048, 1, 0, 0, 0, 3048,
		3049, 1, 0, 0, 0, 3049, 3052, 5, 81, 0, 0, 3050, 3053, 3, 1018, 509, 0,
		3051, 3053, 3, 1024, 512, 0, 3052, 3050, 1, 0, 0, 0, 3052, 3051, 1, 0,
		0, 0, 3052, 3053, 1, 0, 0, 0, 3053, 301, 1, 0, 0, 0, 3054, 3057, 3, 1018,
		509, 0, 3055, 3057, 5, 499, 0, 0, 3056, 3054, 1, 0, 0, 0, 3056, 3055, 1,
		0, 0, 0, 3057, 303, 1, 0, 0, 0, 3058, 3064, 3, 302, 151, 0, 3059, 3063,
		5, 528, 0, 0, 3060, 3061, 5, 1, 0, 0, 3061, 3063, 3, 302, 151, 0, 3062,
		3059, 1, 0, 0, 0, 3062, 3060, 1, 0, 0, 0, 3063, 3066, 1, 0, 0, 0, 3064,
		3062, 1, 0, 0, 0, 3064, 3065, 1, 0, 0, 0, 3065, 305, 1, 0, 0, 0, 3066,
		3064, 1, 0, 0, 0, 3067, 3068, 5, 270, 0, 0, 3068, 3069, 5, 76, 0, 0, 3069,
		3070, 3, 1018, 509, 0, 3070, 3071, 5, 13, 0, 0, 3071, 3072, 5, 490, 0,
		0, 3072, 3076, 3, 1000, 500, 0, 3073, 3077, 5, 161, 0, 0, 3074, 3075, 5,
		16, 0, 0, 3075, 3077, 3, 1018, 509, 0, 3076, 3073, 1, 0, 0, 0, 3076, 3074,
		1, 0, 0, 0, 3076, 3077, 1, 0, 0, 0, 3077, 3079, 1, 0, 0, 0, 3078, 3080,
		3, 954, 477, 0, 3079, 3078, 1, 0, 0, 0, 3079, 3080, 1, 0, 0, 0, 3080, 307,
		1, 0, 0, 0, 3081, 3082, 5, 270, 0, 0, 3082, 3083, 5, 76, 0, 0, 3083, 3084,
		3, 1018, 509, 0, 3084, 3085, 5, 132, 0, 0, 3085, 3086, 5, 490, 0, 0, 3086,
		3088, 3, 304, 152, 0, 3087, 3089, 3, 954, 477, 0, 3088, 3087, 1, 0, 0,
		0, 3088, 3089, 1, 0, 0, 0, 3089, 309, 1, 0, 0, 0, 3090, 3091, 5, 90, 0,
		0, 3091, 3093, 5, 297, 0, 0, 3092, 3090, 1, 0, 0, 0, 3092, 3093, 1, 0,
		0, 0, 3093, 3094, 1, 0, 0, 0, 3094, 3095, 5, 356, 0, 0, 3095, 3096, 5,
		426, 0, 0, 3096, 3097, 3, 1018, 509, 0, 3097, 3098, 3, 320, 160, 0, 3098,
		3110, 1, 0, 0, 0, 3099, 3100, 5, 90, 0, 0, 3100, 3104, 5, 426, 0, 0, 3101,
		3102, 5, 197, 0, 0, 3102, 3103, 5, 281, 0, 0, 3103, 3105, 5, 148, 0, 0,
		3104, 3101, 1, 0, 0, 0, 3104, 3105, 1, 0, 0, 0, 3105, 3106, 1, 0, 0, 0,
		3106, 3107, 3, 1018, 509, 0, 3107, 3108, 3, 320, 160, 0, 3108, 3110, 1,
		0, 0, 0, 3109, 3092, 1, 0, 0, 0, 3109, 3099, 1, 0, 0, 0, 3110, 311, 1,
		0, 0, 0, 3111, 3112, 5, 90, 0, 0, 3112, 3114, 5, 297, 0, 0, 3113, 3111,
		1, 0, 0, 0, 3113, 3114, 1, 0, 0, 0, 3114, 3115, 1, 0, 0, 0, 3115, 3116,
		5, 356, 0, 0, 3116, 3117, 5, 51, 0, 0, 3117, 3118, 3, 1018, 509, 0, 3118,
		3119, 3, 322, 161, 0, 3119, 3131, 1, 0, 0, 0, 3120, 3121, 5, 90, 0, 0,
		3121, 3125, 5, 51, 0, 0, 3122, 3123, 5, 197, 0, 0, 3123, 3124, 5, 281,
		0, 0, 3124, 3126, 5, 148, 0, 0, 3125, 3122, 1, 0, 0, 0, 3125, 3126, 1,
		0, 0, 0, 3126, 3127, 1, 0, 0, 0, 3127, 3128, 3, 1018, 509, 0, 3128, 3129,
		3, 322, 161, 0, 3129, 3131, 1, 0, 0, 0, 3130, 3113, 1, 0, 0, 0, 3130, 3120,
		1, 0, 0, 0, 3131, 313, 1, 0, 0, 0, 3132, 3133, 5, 132, 0, 0, 3133, 3136,
		5, 51, 0, 0, 3134, 3135, 5, 197, 0, 0, 3135, 3137, 5, 148, 0, 0, 3136,
		3134, 1, 0, 0, 0, 3136, 3137, 1, 0, 0, 0, 3137, 3138, 1, 0, 0, 0, 3138,
		3139, 3, 1018, 509, 0, 3139, 315, 1, 0, 0, 0, 3140, 3141, 5, 132, 0, 0,
		3141, 3144, 5, 426, 0, 0, 3142, 3143, 5, 197, 0, 0, 3143, 3145, 5, 148,
		0, 0, 3144, 3142, 1, 0, 0, 0, 3144, 3145, 1, 0, 0, 0, 3145, 3146, 1, 0,
		0, 0, 3146, 3147, 3, 1018, 509, 0, 3147, 317, 1, 0, 0, 0, 3148, 3149, 5,
		147, 0, 0, 3149, 3150, 3, 870, 435, 0, 3150, 319, 1, 0, 0, 0, 3151, 3152,
		5, 27, 0, 0, 3152, 3153, 5, 287, 0, 0, 3153, 3154, 5, 468, 0, 0, 3154,
		3156, 3, 332, 166, 0, 3155, 3151, 1, 0, 0, 0, 3155, 3156, 1, 0, 0, 0, 3156,
		3158, 1, 0, 0, 0, 3157, 3159, 3, 326, 163, 0, 3158, 3157, 1, 0, 0, 0, 3158,
		3159, 1, 0, 0, 0, 3159, 321, 1, 0, 0, 0, 3160, 3161, 5, 27, 0, 0, 3161,
		3162, 5, 287, 0, 0, 3162, 3163, 5, 468, 0, 0, 3163, 3165, 3, 332, 166,
		0, 3164, 3160, 1, 0, 0, 0, 3164, 3165, 1, 0, 0, 0, 3165, 3167, 1, 0, 0,
		0, 3166, 3168, 3, 326, 163, 0, 3167, 3166, 1, 0, 0, 0, 3167, 3168, 1, 0,
		0, 0, 3168, 3170, 1, 0, 0, 0, 3169, 3171, 3, 324, 162, 0, 3170, 3169, 1,
		0, 0, 0, 3170, 3171, 1, 0, 0, 0, 3171, 323, 1, 0, 0, 0, 3172, 3173, 5,
		480, 0, 0, 3173, 3174, 5, 403, 0, 0, 3174, 3175, 5, 366, 0, 0, 3175, 3187,
		3, 330, 165, 0, 3176, 3177, 5, 480, 0, 0, 3177, 3178, 5, 403, 0, 0, 3178,
		3179, 5, 366, 0, 0, 3179, 3187, 3, 328, 164, 0, 3180, 3181, 5, 480, 0,
		0, 3181, 3182, 5, 403, 0, 0, 3182, 3183, 5, 366, 0, 0, 3183, 3184, 3, 330,
		165, 0, 3184, 3185, 3, 328, 164, 0, 3185, 3187, 1, 0, 0, 0, 3186, 3172,
		1, 0, 0, 0, 3186, 3176, 1, 0, 0, 0, 3186, 3180, 1, 0, 0, 0, 3187, 325,
		1, 0, 0, 0, 3188, 3189, 5, 365, 0, 0, 3189, 3190, 3, 1038, 519, 0, 3190,
		3191, 3, 334, 167, 0, 3191, 327, 1, 0, 0, 0, 3192, 3193, 3, 1038, 519,
		0, 3193, 3194, 3, 334, 167, 0, 3194, 329, 1, 0, 0, 0, 3195, 3196, 3, 1038,
		519, 0, 3196, 3197, 5, 404, 0, 0, 3197, 331, 1, 0, 0, 0, 3198, 3199, 3,
		1038, 519, 0, 3199, 333, 1, 0, 0, 0, 3200, 3201, 7, 17, 0, 0, 3201, 335,
		1, 0, 0, 0, 3202, 3203, 5, 2, 0, 0, 3203, 3208, 5, 518, 0, 0, 3204, 3205,
		5, 3, 0, 0, 3205, 3207, 5, 518, 0, 0, 3206, 3204, 1, 0, 0, 0, 3207, 3210,
		1, 0, 0, 0, 3208, 3206, 1, 0, 0, 0, 3208, 3209, 1, 0, 0, 0, 3209, 3211,
		1, 0, 0, 0, 3210, 3208, 1, 0, 0, 0, 3211, 3212, 5, 4, 0, 0, 3212, 337,
		1, 0, 0, 0, 3213, 3214, 5, 132, 0, 0, 3214, 3215, 5, 491, 0, 0, 3215, 3216,
		5, 205, 0, 0, 3216, 3217, 5, 290, 0, 0, 3217, 3218, 5, 425, 0, 0, 3218,
		3219, 3, 336, 168, 0, 3219, 339, 1, 0, 0, 0, 3220, 3222, 5, 13, 0, 0, 3221,
		3223, 5, 428, 0, 0, 3222, 3221, 1, 0, 0, 0, 3222, 3223, 1, 0, 0, 0, 3223,
		3227, 1, 0, 0, 0, 3224, 3228, 3, 932, 466, 0, 3225, 3226, 5, 304, 0, 0,
		3226, 3228, 3, 934, 467, 0, 3227, 3224, 1, 0, 0, 0, 3227, 3225, 1, 0, 0,
		0, 3228, 3230, 1, 0, 0, 0, 3229, 3231, 3, 948, 474, 0, 3230, 3229, 1, 0,
		0, 0, 3230, 3231, 1, 0, 0, 0, 3231, 3233, 1, 0, 0, 0, 3232, 3234, 3, 954,
		477, 0, 3233, 3232, 1, 0, 0, 0, 3233, 3234, 1, 0, 0, 0, 3234, 3250, 1,
		0, 0, 0, 3235, 3237, 5, 13, 0, 0, 3236, 3238, 5, 428, 0, 0, 3237, 3236,
		1, 0, 0, 0, 3237, 3238, 1, 0, 0, 0, 3238, 3241, 1, 0, 0, 0, 3239, 3242,
		3, 914, 457, 0, 3240, 3242, 3, 916, 458, 0, 3241, 3239, 1, 0, 0, 0, 3241,
		3240, 1, 0, 0, 0, 3242, 3244, 1, 0, 0, 0, 3243, 3245, 3, 948, 474, 0, 3244,
		3243, 1, 0, 0, 0, 3244, 3245, 1, 0, 0, 0, 3245, 3247, 1, 0, 0, 0, 3246,
		3248, 3, 954, 477, 0, 3247, 3246, 1, 0, 0, 0, 3247, 3248, 1, 0, 0, 0, 3248,
		3250, 1, 0, 0, 0, 3249, 3220, 1, 0, 0, 0, 3249, 3235, 1, 0, 0, 0, 3250,
		341, 1, 0, 0, 0, 3251, 3253, 5, 132, 0, 0, 3252, 3254, 5, 428, 0, 0, 3253,
		3252, 1, 0, 0, 0, 3253, 3254, 1, 0, 0, 0, 3254, 3267, 1, 0, 0, 0, 3255,
		3258, 5, 303, 0, 0, 3256, 3257, 5, 197, 0, 0, 3257, 3259, 5, 148, 0, 0,
		3258, 3256, 1, 0, 0, 0, 3258, 3259, 1, 0, 0, 0, 3259, 3260, 1, 0, 0, 0,
		3260, 3268, 3, 1018, 509, 0, 3261, 3264, 5, 304, 0, 0, 3262, 3263, 5, 197,
		0, 0, 3263, 3265, 5, 148, 0, 0, 3264, 3262, 1, 0, 0, 0, 3264, 3265, 1,
		0, 0, 0, 3265, 3266, 1, 0, 0, 0, 3266, 3268, 3, 1024, 512, 0, 3267, 3255,
		1, 0, 0, 0, 3267, 3261, 1, 0, 0, 0, 3268, 3270, 1, 0, 0, 0, 3269, 3271,
		5, 169, 0, 0, 3270, 3269, 1, 0, 0, 0, 3270, 3271, 1, 0, 0, 0, 3271, 3307,
		1, 0, 0, 0, 3272, 3274, 5, 132, 0, 0, 3273, 3275, 5, 428, 0, 0, 3274, 3273,
		1, 0, 0, 0, 3274, 3275, 1, 0, 0, 0, 3275, 3276, 1, 0, 0, 0, 3276, 3279,
		5, 304, 0, 0, 3277, 3278, 5, 197, 0, 0, 3278, 3280, 5, 148, 0, 0, 3279,
		3277, 1, 0, 0, 0, 3279, 3280, 1, 0, 0, 0, 3280, 3281, 1, 0, 0, 0, 3281,
		3283, 3, 934, 467, 0, 3282, 3284, 5, 169, 0, 0, 3283, 3282, 1, 0, 0, 0,
		3283, 3284, 1, 0, 0, 0, 3284, 3307, 1, 0, 0, 0, 3285, 3287, 5, 132, 0,
		0, 3286, 3288, 5, 428, 0, 0, 3287, 3286, 1, 0, 0, 0, 3287, 3288, 1, 0,
		0, 0, 3288, 3289, 1, 0, 0, 0, 3289, 3292, 5, 304, 0, 0, 3290, 3291, 5,
		197, 0, 0, 3291, 3293, 5, 148, 0, 0, 3292, 3290, 1, 0, 0, 0, 3292, 3293,
		1, 0, 0, 0, 3293, 3294, 1, 0, 0, 0, 3294, 3295, 5, 478, 0, 0, 3295, 3297,
		3, 852, 426, 0, 3296, 3298, 5, 169, 0, 0, 3297, 3296, 1, 0, 0, 0, 3297,
		3298, 1, 0, 0, 0, 3298, 3307, 1, 0, 0, 0, 3299, 3300, 5, 132, 0, 0, 3300,
		3301, 5, 18, 0, 0, 3301, 3302, 5, 428, 0, 0, 3302, 3304, 5, 304, 0, 0,
		3303, 3305, 5, 169, 0, 0, 3304, 3303, 1, 0, 0, 0, 3304, 3305, 1, 0, 0,
		0, 3305, 3307, 1, 0, 0, 0, 3306, 3251, 1, 0, 0, 0, 3306, 3272, 1, 0, 0,
		0, 3306, 3285, 1, 0, 0, 0, 3306, 3299, 1, 0, 0, 0, 3307, 343, 1, 0, 0,
		0, 3308, 3309, 5, 445, 0, 0, 3309, 3310, 3, 826, 413, 0, 3310, 345, 1,
		0, 0, 0, 3311, 3312, 5, 270, 0, 0, 3312, 3318, 5, 303, 0, 0, 3313, 3319,
		3, 1018, 509, 0, 3314, 3319, 3, 1024, 512, 0, 3315, 3316, 5, 2, 0, 0, 3316,
		3317, 5, 502, 0, 0, 3317, 3319, 5, 4, 0, 0, 3318, 3313, 1, 0, 0, 0, 3318,
		3314, 1, 0, 0, 0, 3318, 3315, 1, 0, 0, 0, 3319, 3320, 1, 0, 0, 0, 3320,
		3321, 5, 396, 0, 0, 3321, 3326, 3, 958, 479, 0, 3322, 3323, 5, 270, 0,
		0, 3323, 3324, 5, 303, 0, 0, 3324, 3326, 3, 948, 474, 0, 3325, 3311, 1,
		0, 0, 0, 3325, 3322, 1, 0, 0, 0, 3326, 347, 1, 0, 0, 0, 3327, 3328, 5,
		356, 0, 0, 3328, 3329, 3, 826, 413, 0, 3329, 3330, 5, 480, 0, 0, 3330,
		3332, 3, 826, 413, 0, 3331, 3333, 3, 954, 477, 0, 3332, 3331, 1, 0, 0,
		0, 3332, 3333, 1, 0, 0, 0, 3333, 349, 1, 0, 0, 0, 3334, 3335, 5, 353, 0,
		0, 3335, 3336, 5, 303, 0, 0, 3336, 3337, 3, 1018, 509, 0, 3337, 3338, 3,
		1018, 509, 0, 3338, 351, 1, 0, 0, 0, 3339, 3341, 3, 904, 452, 0, 3340,
		3339, 1, 0, 0, 0, 3340, 3341, 1, 0, 0, 0, 3341, 3342, 1, 0, 0, 0, 3342,
		3343, 5, 210, 0, 0, 3343, 3356, 7, 18, 0, 0, 3344, 3346, 3, 1012, 506,
		0, 3345, 3347, 3, 1016, 508, 0, 3346, 3345, 1, 0, 0, 0, 3346, 3347, 1,
		0, 0, 0, 3347, 3349, 1, 0, 0, 0, 3348, 3350, 3, 826, 413, 0, 3349, 3348,
		1, 0, 0, 0, 3349, 3350, 1, 0, 0, 0, 3350, 3357, 1, 0, 0, 0, 3351, 3352,
		5, 159, 0, 0, 3352, 3357, 3, 958, 479, 0, 3353, 3354, 5, 46, 0, 0, 3354,
		3355, 5, 2, 0, 0, 3355, 3357, 5, 4, 0, 0, 3356, 3344, 1, 0, 0, 0, 3356,
		3351, 1, 0, 0, 0, 3356, 3353, 1, 0, 0, 0, 3357, 3361, 1, 0, 0, 0, 3358,
		3360, 3, 354, 177, 0, 3359, 3358, 1, 0, 0, 0, 3360, 3363, 1, 0, 0, 0, 3361,
		3359, 1, 0, 0, 0, 3361, 3362, 1, 0, 0, 0, 3362, 3365, 1, 0, 0, 0, 3363,
		3361, 1, 0, 0, 0, 3364, 3366, 3, 954, 477, 0, 3365, 3364, 1, 0, 0, 0, 3365,
		3366, 1, 0, 0, 0, 3366, 3377, 1, 0, 0, 0, 3367, 3378, 3, 752, 376, 0, 3368,
		3369, 5, 462, 0, 0, 3369, 3374, 3, 842, 421, 0, 3370, 3371, 5, 3, 0, 0,
		3371, 3373, 3, 842, 421, 0, 3372, 3370, 1, 0, 0, 0, 3373, 3376, 1, 0, 0,
		0, 3374, 3372, 1, 0, 0, 0, 3374, 3375, 1, 0, 0, 0, 3375, 3378, 1, 0, 0,
		0, 3376, 3374, 1, 0, 0, 0, 3377, 3367, 1, 0, 0, 0, 3377, 3368, 1, 0, 0,
		0, 3378, 353, 1, 0, 0, 0, 3379, 3384, 3, 356, 178, 0, 3380, 3381, 5, 480,
		0, 0, 3381, 3382, 5, 230, 0, 0, 3382, 3384, 3, 1018, 509, 0, 3383, 3379,
		1, 0, 0, 0, 3383, 3380, 1, 0, 0, 0, 3384, 355, 1, 0, 0, 0, 3385, 3389,
		3, 824, 412, 0, 3386, 3387, 5, 55, 0, 0, 3387, 3389, 5, 273, 0, 0, 3388,
		3385, 1, 0, 0, 0, 3388, 3386, 1, 0, 0, 0, 3389, 357, 1, 0, 0, 0, 3390,
		3392, 3, 904, 452, 0, 3391, 3390, 1, 0, 0, 0, 3391, 3392, 1, 0, 0, 0, 3392,
		3394, 1, 0, 0, 0, 3393, 3395, 3, 756, 378, 0, 3394, 3393, 1, 0, 0, 0, 3394,
		3395, 1, 0, 0, 0, 3395, 3396, 1, 0, 0, 0, 3396, 3397, 5, 455, 0, 0, 3397,
		3398, 3, 1012, 506, 0, 3398, 3399, 5, 396, 0, 0, 3399, 3400, 3, 1036, 518,
		0, 3400, 3403, 3, 778, 389, 0, 3401, 3402, 5, 478, 0, 0, 3402, 3404, 3,
		852, 426, 0, 3403, 3401, 1, 0, 0, 0, 3403, 3404, 1, 0, 0, 0, 3404, 359,
		1, 0, 0, 0, 3405, 3407, 3, 904, 452, 0, 3406, 3405, 1, 0, 0, 0, 3406, 3407,
		1, 0, 0, 0, 3407, 3409, 1, 0, 0, 0, 3408, 3410, 3, 756, 378, 0, 3409, 3408,
		1, 0, 0, 0, 3409, 3410, 1, 0, 0, 0, 3410, 3411, 1, 0, 0, 0, 3411, 3412,
		5, 118, 0, 0, 3412, 3413, 5, 172, 0, 0, 3413, 3415, 3, 1012, 506, 0, 3414,
		3416, 3, 826, 413, 0, 3415, 3414, 1, 0, 0, 0, 3415, 3416, 1, 0, 0, 0, 3416,
		3419, 1, 0, 0, 0, 3417, 3418, 5, 460, 0, 0, 3418, 3420, 3, 792, 396, 0,
		3419, 3417, 1, 0, 0, 0, 3419, 3420, 1, 0, 0, 0, 3420, 3423, 1, 0, 0, 0,
		3421, 3422, 5, 478, 0, 0, 3422, 3424, 3, 852, 426, 0, 3423, 3421, 1, 0,
		0, 0, 3423, 3424, 1, 0, 0, 0, 3424, 361, 1, 0, 0, 0, 3425, 3426, 5, 90,
		0, 0, 3426, 3427, 5, 377, 0, 0, 3427, 3431, 5, 243, 0, 0, 3428, 3429, 3,
		1012, 506, 0, 3429, 3430, 5, 1, 0, 0, 3430, 3432, 1, 0, 0, 0, 3431, 3428,
		1, 0, 0, 0, 3431, 3432, 1, 0, 0, 0, 3432, 3433, 1, 0, 0, 0, 3433, 3434,
		3, 1018, 509, 0, 3434, 3435, 5, 290, 0, 0, 3435, 3444, 3, 1012, 506, 0,
		3436, 3441, 3, 368, 184, 0, 3437, 3438, 5, 3, 0, 0, 3438, 3440, 3, 368,
		184, 0, 3439, 3437, 1, 0, 0, 0, 3440, 3443, 1, 0, 0, 0, 3441, 3439, 1,
		0, 0, 0, 3441, 3442, 1, 0, 0, 0, 3442, 3445, 1, 0, 0, 0, 3443, 3441, 1,
		0, 0, 0, 3444, 3436, 1, 0, 0, 0, 3444, 3445, 1, 0, 0, 0, 3445, 3447, 1,
		0, 0, 0, 3446, 3448, 3, 378, 189, 0, 3447, 3446, 1, 0, 0, 0, 3447, 3448,
		1, 0, 0, 0, 3448, 3449, 1, 0, 0, 0, 3449, 3450, 5, 172, 0, 0, 3450, 3452,
		3, 1018, 509, 0, 3451, 3453, 3, 380, 190, 0, 3452, 3451, 1, 0, 0, 0, 3452,
		3453, 1, 0, 0, 0, 3453, 363, 1, 0, 0, 0, 3454, 3455, 5, 19, 0, 0, 3455,
		3456, 5, 377, 0, 0, 3456, 3457, 5, 243, 0, 0, 3457, 3461, 5, 168, 0, 0,
		3458, 3459, 3, 1012, 506, 0, 3459, 3460, 5, 1, 0, 0, 3460, 3462, 1, 0,
		0, 0, 3461, 3458, 1, 0, 0, 0, 3461, 3462, 1, 0, 0, 0, 3462, 3463, 1, 0,
		0, 0, 3463, 3472, 3, 1018, 509, 0, 3464, 3469, 3, 368, 184, 0, 3465, 3466,
		5, 3, 0, 0, 3466, 3468, 3, 368, 184, 0, 3467, 3465, 1, 0, 0, 0, 3468, 3471,
		1, 0, 0, 0, 3469, 3467, 1, 0, 0, 0, 3469, 3470, 1, 0, 0, 0, 3470, 3473,
		1, 0, 0, 0, 3471, 3469, 1, 0, 0, 0, 3472, 3464, 1, 0, 0, 0, 3472, 3473,
		1, 0, 0, 0, 3473, 3475, 1, 0, 0, 0, 3474, 3476, 3, 378, 189, 0, 3475, 3474,
		1, 0, 0, 0, 3475, 3476, 1, 0, 0, 0, 3476, 3478, 1, 0, 0, 0, 3477, 3479,
		3, 366, 183, 0, 3478, 3477, 1, 0, 0, 0, 3478, 3479, 1, 0, 0, 0, 3479, 365,
		1, 0, 0, 0, 3480, 3481, 5, 172, 0, 0, 3481, 3482, 3, 1018, 509, 0, 3482,
		3483, 3, 380, 190, 0, 3483, 367, 1, 0, 0, 0, 3484, 3491, 3, 370, 185, 0,
		3485, 3491, 3, 372, 186, 0, 3486, 3491, 3, 374, 187, 0, 3487, 3488, 5,
		478, 0, 0, 3488, 3491, 3, 852, 426, 0, 3489, 3491, 3, 826, 413, 0, 3490,
		3484, 1, 0, 0, 0, 3490, 3485, 1, 0, 0, 0, 3490, 3486, 1, 0, 0, 0, 3490,
		3487, 1, 0, 0, 0, 3490, 3489, 1, 0, 0, 0, 3491, 369, 1, 0, 0, 0, 3492,
		3493, 5, 77, 0, 0, 3493, 3494, 5, 429, 0, 0, 3494, 3495, 5, 55, 0, 0, 3495,
		3496, 3, 976, 488, 0, 3496, 371, 1, 0, 0, 0, 3497, 3498, 5, 379, 0, 0,
		3498, 3499, 5, 429, 0, 0, 3499, 3500, 5, 55, 0, 0, 3500, 3501, 3, 976,
		488, 0, 3501, 373, 1, 0, 0, 0, 3502, 3503, 5, 77, 0, 0, 3503, 3504, 3,
		376, 188, 0, 3504, 375, 1, 0, 0, 0, 3505, 3508, 5, 2, 0, 0, 3506, 3509,
		3, 1012, 506, 0, 3507, 3509, 3, 1034, 517, 0, 3508, 3506, 1, 0, 0, 0, 3508,
		3507, 1, 0, 0, 0, 3509, 3517, 1, 0, 0, 0, 3510, 3513, 5, 3, 0, 0, 3511,
		3514, 3, 1012, 506, 0, 3512, 3514, 3, 1034, 517, 0, 3513, 3511, 1, 0, 0,
		0, 3513, 3512, 1, 0, 0, 0, 3514, 3516, 1, 0, 0, 0, 3515, 3510, 1, 0, 0,
		0, 3516, 3519, 1, 0, 0, 0, 3517, 3515, 1, 0, 0, 0, 3517, 3518, 1, 0, 0,
		0, 3518, 3520, 1, 0, 0, 0, 3519, 3517, 1, 0, 0, 0, 3520, 3521, 5, 4, 0,
		0, 3521, 377, 1, 0, 0, 0, 3522, 3523, 3, 954, 477, 0, 3523, 379, 1, 0,
		0, 0, 3524, 3525, 3, 958, 479, 0, 3525, 381, 1, 0, 0, 0, 3526, 3527, 5,
		409, 0, 0, 3527, 3528, 5, 377, 0, 0, 3528, 3529, 5, 243, 0, 0, 3529, 3533,
		5, 168, 0, 0, 3530, 3531, 3, 1012, 506, 0, 3531, 3532, 5, 1, 0, 0, 3532,
		3534, 1, 0, 0, 0, 3533, 3530, 1, 0, 0, 0, 3533, 3534, 1, 0, 0, 0, 3534,
		3535, 1, 0, 0, 0, 3535, 3536, 3, 1018, 509, 0, 3536, 383, 1, 0, 0, 0, 3537,
		3538, 5, 364, 0, 0, 3538, 3539, 5, 377, 0, 0, 3539, 3540, 5, 243, 0, 0,
		3540, 3544, 5, 168, 0, 0, 3541, 3542, 3, 1012, 506, 0, 3542, 3543, 5, 1,
		0, 0, 3543, 3545, 1, 0, 0, 0, 3544, 3541, 1, 0, 0, 0, 3544, 3545, 1, 0,
		0, 0, 3545, 3546, 1, 0, 0, 0, 3546, 3547, 3, 1018, 509, 0, 3547, 385, 1,
		0, 0, 0, 3548, 3549, 5, 307, 0, 0, 3549, 3550, 5, 377, 0, 0, 3550, 3551,
		5, 243, 0, 0, 3551, 3555, 5, 168, 0, 0, 3552, 3553, 3, 1012, 506, 0, 3553,
		3554, 5, 1, 0, 0, 3554, 3556, 1, 0, 0, 0, 3555, 3552, 1, 0, 0, 0, 3555,
		3556, 1, 0, 0, 0, 3556, 3557, 1, 0, 0, 0, 3557, 3558, 3, 1018, 509, 0,
		3558, 387, 1, 0, 0, 0, 3559, 3561, 5, 401, 0, 0, 3560, 3562, 5, 18, 0,
		0, 3561, 3560, 1, 0, 0, 0, 3561, 3562, 1, 0, 0, 0, 3562, 3563, 1, 0, 0,
		0, 3563, 3564, 5, 377, 0, 0, 3564, 3572, 5, 243, 0, 0, 3565, 3569, 5, 168,
		0, 0, 3566, 3567, 3, 1012, 506, 0, 3567, 3568, 5, 1, 0, 0, 3568, 3570,
		1, 0, 0, 0, 3569, 3566, 1, 0, 0, 0, 3569, 3570, 1, 0, 0, 0, 3570, 3571,
		1, 0, 0, 0, 3571, 3573, 3, 1018, 509, 0, 3572, 3565, 1, 0, 0, 0, 3572,
		3573, 1, 0, 0, 0, 3573, 3576, 1, 0, 0, 0, 3574, 3575, 5, 172, 0, 0, 3575,
		3577, 3, 1012, 506, 0, 3576, 3574, 1, 0, 0, 0, 3576, 3577, 1, 0, 0, 0,
		3577, 3580, 1, 0, 0, 0, 3578, 3579, 5, 478, 0, 0, 3579, 3581, 3, 852, 426,
		0, 3580, 3578, 1, 0, 0, 0, 3580, 3581, 1, 0, 0, 0, 3581, 3592, 1, 0, 0,
		0, 3582, 3583, 5, 298, 0, 0, 3583, 3584, 5, 55, 0, 0, 3584, 3589, 3, 770,
		385, 0, 3585, 3586, 5, 3, 0, 0, 3586, 3588, 3, 770, 385, 0, 3587, 3585,
		1, 0, 0, 0, 3588, 3591, 1, 0, 0, 0, 3589, 3587, 1, 0, 0, 0, 3589, 3590,
		1, 0, 0, 0, 3590, 3593, 1, 0, 0, 0, 3591, 3589, 1, 0, 0, 0, 3592, 3582,
		1, 0, 0, 0, 3592, 3593, 1, 0, 0, 0, 3593, 3595, 1, 0, 0, 0, 3594, 3596,
		3, 774, 387, 0, 3595, 3594, 1, 0, 0, 0, 3595, 3596, 1, 0, 0, 0, 3596, 389,
		1, 0, 0, 0, 3597, 3598, 5, 401, 0, 0, 3598, 3599, 5, 377, 0, 0, 3599, 3600,
		5, 243, 0, 0, 3600, 3603, 5, 427, 0, 0, 3601, 3602, 5, 172, 0, 0, 3602,
		3604, 3, 1012, 506, 0, 3603, 3601, 1, 0, 0, 0, 3603, 3604, 1, 0, 0, 0,
		3604, 3605, 1, 0, 0, 0, 3605, 3606, 5, 478, 0, 0, 3606, 3607, 3, 852, 426,
		0, 3607, 391, 1, 0, 0, 0, 3608, 3609, 5, 401, 0, 0, 3609, 3610, 5, 90,
		0, 0, 3610, 3611, 5, 377, 0, 0, 3611, 3615, 5, 243, 0, 0, 3612, 3613, 3,
		1012, 506, 0, 3613, 3614, 5, 1, 0, 0, 3614, 3616, 1, 0, 0, 0, 3615, 3612,
		1, 0, 0, 0, 3615, 3616, 1, 0, 0, 0, 3616, 3617, 1, 0, 0, 0, 3617, 3618,
		3, 1018, 509, 0, 3618, 393, 1, 0, 0, 0, 3619, 3621, 5, 401, 0, 0, 3620,
		3622, 5, 18, 0, 0, 3621, 3620, 1, 0, 0, 0, 3621, 3622, 1, 0, 0, 0, 3622,
		3623, 1, 0, 0, 0, 3623, 3624, 5, 411, 0, 0, 3624, 3632, 5, 243, 0, 0, 3625,
		3629, 5, 168, 0, 0, 3626, 3627, 3, 1012, 506, 0, 3627, 3628, 5, 1, 0, 0,
		3628, 3630, 1, 0, 0, 0, 3629, 3626, 1, 0, 0, 0, 3629, 3630, 1, 0, 0, 0,
		3630, 3631, 1, 0, 0, 0, 3631, 3633, 3, 1018, 509, 0, 3632, 3625, 1, 0,
		0, 0, 3632, 3633, 1, 0, 0, 0, 3633, 3636, 1, 0, 0, 0, 3634, 3635, 5, 172,
		0, 0, 3635, 3637, 3, 1012, 506, 0, 3636, 3634, 1, 0, 0, 0, 3636, 3637,
		1, 0, 0, 0, 3637, 3640, 1, 0, 0, 0, 3638, 3639, 5, 478, 0, 0, 3639, 3641,
		3, 852, 426, 0, 3640, 3638, 1, 0, 0, 0, 3640, 3641, 1, 0, 0, 0, 3641, 3652,
		1, 0, 0, 0, 3642, 3643, 5, 298, 0, 0, 3643, 3644, 5, 55, 0, 0, 3644, 3649,
		3, 770, 385, 0, 3645, 3646, 5, 3, 0, 0, 3646, 3648, 3, 770, 385, 0, 3647,
		3645, 1, 0, 0, 0, 3648, 3651, 1, 0, 0, 0, 3649, 3647, 1, 0, 0, 0, 3649,
		3650, 1, 0, 0, 0, 3650, 3653, 1, 0, 0, 0, 3651, 3649, 1, 0, 0, 0, 3652,
		3642, 1, 0, 0, 0, 3652, 3653, 1, 0, 0, 0, 3653, 3655, 1, 0, 0, 0, 3654,
		3656, 3, 774, 387, 0, 3655, 3654, 1, 0, 0, 0, 3655, 3656, 1, 0, 0, 0, 3656,
		395, 1, 0, 0, 0, 3657, 3659, 5, 20, 0, 0, 3658, 3660, 7, 19, 0, 0, 3659,
		3658, 1, 0, 0, 0, 3659, 3660, 1, 0, 0, 0, 3660, 3661, 1, 0, 0, 0, 3661,
		3662, 5, 422, 0, 0, 3662, 3664, 3, 1014, 507, 0, 3663, 3665, 3, 398, 199,
		0, 3664, 3663, 1, 0, 0, 0, 3664, 3665, 1, 0, 0, 0, 3665, 3667, 1, 0, 0,
		0, 3666, 3668, 3, 826, 413, 0, 3667, 3666, 1, 0, 0, 0, 3667, 3668, 1, 0,
		0, 0, 3668, 3672, 1, 0, 0, 0, 3669, 3670, 5, 480, 0, 0, 3670, 3671, 7,
		12, 0, 0, 3671, 3673, 5, 269, 0, 0, 3672, 3669, 1, 0, 0, 0, 3672, 3673,
		1, 0, 0, 0, 3673, 3675, 1, 0, 0, 0, 3674, 3676, 3, 954, 477, 0, 3675, 3674,
		1, 0, 0, 0, 3675, 3676, 1, 0, 0, 0, 3676, 397, 1, 0, 0, 0, 3677, 3678,
		5, 2, 0, 0, 3678, 3683, 3, 1012, 506, 0, 3679, 3680, 5, 3, 0, 0, 3680,
		3682, 3, 1012, 506, 0, 3681, 3679, 1, 0, 0, 0, 3682, 3685, 1, 0, 0, 0,
		3683, 3681, 1, 0, 0, 0, 3683, 3684, 1, 0, 0, 0, 3684, 3686, 1, 0, 0, 0,
		3685, 3683, 1, 0, 0, 0, 3686, 3687, 5, 4, 0, 0, 3687, 3714, 1, 0, 0, 0,
		3688, 3693, 3, 1012, 506, 0, 3689, 3690, 5, 3, 0, 0, 3690, 3692, 3, 1012,
		506, 0, 3691, 3689, 1, 0, 0, 0, 3692, 3695, 1, 0, 0, 0, 3693, 3691, 1,
		0, 0, 0, 3693, 3694, 1, 0, 0, 0, 3694, 3714, 1, 0, 0, 0, 3695, 3693, 1,
		0, 0, 0, 3696, 3697, 5, 18, 0, 0, 3697, 3714, 5, 77, 0, 0, 3698, 3699,
		5, 321, 0, 0, 3699, 3714, 5, 77, 0, 0, 3700, 3701, 5, 272, 0, 0, 3701,
		3702, 5, 77, 0, 0, 3702, 3703, 5, 2, 0, 0, 3703, 3708, 3, 1012, 506, 0,
		3704, 3705, 5, 3, 0, 0, 3705, 3707, 3, 1012, 506, 0, 3706, 3704, 1, 0,
		0, 0, 3707, 3710, 1, 0, 0, 0, 3708, 3706, 1, 0, 0, 0, 3708, 3709, 1, 0,
		0, 0, 3709, 3711, 1, 0, 0, 0, 3710, 3708, 1, 0, 0, 0, 3711, 3712, 5, 4,
		0, 0, 3712, 3714, 1, 0, 0, 0, 3713, 3677, 1, 0, 0, 0, 3713, 3688, 1, 0,
		0, 0, 3713, 3696, 1, 0, 0, 0, 3713, 3698, 1, 0, 0, 0, 3713, 3700, 1, 0,
		0, 0, 3714, 399, 1, 0, 0, 0, 3715, 3718, 5, 132, 0, 0, 3716, 3717, 5, 272,
		0, 0, 3717, 3719, 5, 77, 0, 0, 3718, 3716, 1, 0, 0, 0, 3718, 3719, 1, 0,
		0, 0, 3719, 3720, 1, 0, 0, 0, 3720, 3721, 5, 407, 0, 0, 3721, 3722, 3,
		1012, 506, 0, 3722, 401, 1, 0, 0, 0, 3723, 3724, 5, 20, 0, 0, 3724, 3725,
		5, 422, 0, 0, 3725, 3726, 3, 1014, 507, 0, 3726, 3727, 5, 455, 0, 0, 3727,
		3728, 5, 189, 0, 0, 3728, 3729, 5, 290, 0, 0, 3729, 3733, 3, 398, 199,
		0, 3730, 3731, 5, 480, 0, 0, 3731, 3732, 5, 518, 0, 0, 3732, 3734, 5, 53,
		0, 0, 3733, 3730, 1, 0, 0, 0, 3733, 3734, 1, 0, 0, 0, 3734, 3736, 1, 0,
		0, 0, 3735, 3737, 3, 954, 477, 0, 3736, 3735, 1, 0, 0, 0, 3736, 3737, 1,
		0, 0, 0, 3737, 403, 1, 0, 0, 0, 3738, 3742, 3, 402, 201, 0, 3739, 3740,
		5, 480, 0, 0, 3740, 3741, 7, 12, 0, 0, 3741, 3743, 5, 269, 0, 0, 3742,
		3739, 1, 0, 0, 0, 3742, 3743, 1, 0, 0, 0, 3743, 405, 1, 0, 0, 0, 3744,
		3745, 5, 20, 0, 0, 3745, 3746, 5, 422, 0, 0, 3746, 3747, 3, 1012, 506,
		0, 3747, 3748, 5, 132, 0, 0, 3748, 3749, 5, 189, 0, 0, 3749, 3750, 5, 290,
		0, 0, 3750, 3755, 3, 1012, 506, 0, 3751, 3752, 5, 3, 0, 0, 3752, 3754,
		3, 1012, 506, 0, 3753, 3751, 1, 0, 0, 0, 3754, 3757, 1, 0, 0, 0, 3755,
		3753, 1, 0, 0, 0, 3755, 3756, 1, 0, 0, 0, 3756, 407, 1, 0, 0, 0, 3757,
		3755, 1, 0, 0, 0, 3758, 3759, 5, 90, 0, 0, 3759, 3761, 5, 20, 0, 0, 3760,
		3762, 7, 19, 0, 0, 3761, 3760, 1, 0, 0, 0, 3761, 3762, 1, 0, 0, 0, 3762,
		3763, 1, 0, 0, 0, 3763, 3765, 5, 18, 0, 0, 3764, 3766, 3, 954, 477, 0,
		3765, 3764, 1, 0, 0, 0, 3765, 3766, 1, 0, 0, 0, 3766, 3803, 1, 0, 0, 0,
		3767, 3768, 5, 90, 0, 0, 3768, 3770, 5, 20, 0, 0, 3769, 3771, 7, 19, 0,
		0, 3770, 3769, 1, 0, 0, 0, 3770, 3771, 1, 0, 0, 0, 3771, 3772, 1, 0, 0,
		0, 3772, 3773, 5, 104, 0, 0, 3773, 3775, 3, 1018, 509, 0, 3774, 3776, 3,
		954, 477, 0, 3775, 3774, 1, 0, 0, 0, 3775, 3776, 1, 0, 0, 0, 3776, 3803,
		1, 0, 0, 0, 3777, 3778, 5, 90, 0, 0, 3778, 3780, 5, 20, 0, 0, 3779, 3781,
		7, 19, 0, 0, 3780, 3779, 1, 0, 0, 0, 3780, 3781, 1, 0, 0, 0, 3781, 3782,
		1, 0, 0, 0, 3782, 3783, 5, 422, 0, 0, 3783, 3795, 3, 1012, 506, 0, 3784,
		3785, 5, 2, 0, 0, 3785, 3790, 3, 1012, 506, 0, 3786, 3787, 5, 3, 0, 0,
		3787, 3789, 3, 1012, 506, 0, 3788, 3786, 1, 0, 0, 0, 3789, 3792, 1, 0,
		0, 0, 3790, 3788, 1, 0, 0, 0, 3790, 3791, 1, 0, 0, 0, 3791, 3793, 1, 0,
		0, 0, 3792, 3790, 1, 0, 0, 0, 3793, 3794, 5, 4, 0, 0, 3794, 3796, 1, 0,
		0, 0, 3795, 3784, 1, 0, 0, 0, 3795, 3796, 1, 0, 0, 0, 3796, 3798, 1, 0,
		0, 0, 3797, 3799, 3, 954, 477, 0, 3798, 3797, 1, 0, 0, 0, 3798, 3799, 1,
		0, 0, 0, 3799, 3803, 1, 0, 0, 0, 3800, 3801, 5, 90, 0, 0, 3801, 3803, 3,
		402, 201, 0, 3802, 3758, 1, 0, 0, 0, 3802, 3767, 1, 0, 0, 0, 3802, 3777,
		1, 0, 0, 0, 3802, 3800, 1, 0, 0, 0, 3803, 409, 1, 0, 0, 0, 3804, 3805,
		5, 132, 0, 0, 3805, 3806, 5, 20, 0, 0, 3806, 3812, 5, 518, 0, 0, 3807,
		3808, 5, 132, 0, 0, 3808, 3809, 5, 18, 0, 0, 3809, 3810, 5, 20, 0, 0, 3810,
		3812, 5, 224, 0, 0, 3811, 3804, 1, 0, 0, 0, 3811, 3807, 1, 0, 0, 0, 3812,
		411, 1, 0, 0, 0, 3813, 3814, 5, 401, 0, 0, 3814, 3816, 5, 20, 0, 0, 3815,
		3817, 7, 20, 0, 0, 3816, 3815, 1, 0, 0, 0, 3816, 3817, 1, 0, 0, 0, 3817,
		3820, 1, 0, 0, 0, 3818, 3819, 5, 478, 0, 0, 3819, 3821, 3, 852, 426, 0,
		3820, 3818, 1, 0, 0, 0, 3820, 3821, 1, 0, 0, 0, 3821, 3832, 1, 0, 0, 0,
		3822, 3823, 5, 298, 0, 0, 3823, 3824, 5, 55, 0, 0, 3824, 3829, 3, 770,
		385, 0, 3825, 3826, 5, 3, 0, 0, 3826, 3828, 3, 770, 385, 0, 3827, 3825,
		1, 0, 0, 0, 3828, 3831, 1, 0, 0, 0, 3829, 3827, 1, 0, 0, 0, 3829, 3830,
		1, 0, 0, 0, 3830, 3833, 1, 0, 0, 0, 3831, 3829, 1, 0, 0, 0, 3832, 3822,
		1, 0, 0, 0, 3832, 3833, 1, 0, 0, 0, 3833, 3835, 1, 0, 0, 0, 3834, 3836,
		3, 774, 387, 0, 3835, 3834, 1, 0, 0, 0, 3835, 3836, 1, 0, 0, 0, 3836, 413,
		1, 0, 0, 0, 3837, 3840, 5, 401, 0, 0, 3838, 3839, 5, 272, 0, 0, 3839, 3841,
		5, 77, 0, 0, 3840, 3838, 1, 0, 0, 0, 3840, 3841, 1, 0, 0, 0, 3841, 3842,
		1, 0, 0, 0, 3842, 3843, 5, 407, 0, 0, 3843, 3846, 5, 267, 0, 0, 3844, 3845,
		5, 478, 0, 0, 3845, 3847, 3, 852, 426, 0, 3846, 3844, 1, 0, 0, 0, 3846,
		3847, 1, 0, 0, 0, 3847, 3858, 1, 0, 0, 0, 3848, 3849, 5, 298, 0, 0, 3849,
		3850, 5, 55, 0, 0, 3850, 3855, 3, 770, 385, 0, 3851, 3852, 5, 3, 0, 0,
		3852, 3854, 3, 770, 385, 0, 3853, 3851, 1, 0, 0, 0, 3854, 3857, 1, 0, 0,
		0, 3855, 3853, 1, 0, 0, 0, 3855, 3856, 1, 0, 0, 0, 3856, 3859, 1, 0, 0,
		0, 3857, 3855, 1, 0, 0, 0, 3858, 3848, 1, 0, 0, 0, 3858, 3859, 1, 0, 0,
		0, 3859, 3861, 1, 0, 0, 0, 3860, 3862, 3, 774, 387, 0, 3861, 3860, 1, 0,
		0, 0, 3861, 3862, 1, 0, 0, 0, 3862, 415, 1, 0, 0, 0, 3863, 3864, 5, 401,
		0, 0, 3864, 3865, 5, 189, 0, 0, 3865, 3868, 5, 267, 0, 0, 3866, 3867, 5,
		478, 0, 0, 3867, 3869, 3, 852, 426, 0, 3868, 3866, 1, 0, 0, 0, 3868, 3869,
		1, 0, 0, 0, 3869, 3880, 1, 0, 0, 0, 3870, 3871, 5, 298, 0, 0, 3871, 3872,
		5, 55, 0, 0, 3872, 3877, 3, 770, 385, 0, 3873, 3874, 5, 3, 0, 0, 3874,
		3876, 3, 770, 385, 0, 3875, 3873, 1, 0, 0, 0, 3876, 3879, 1, 0, 0, 0, 3877,
		3875, 1, 0, 0, 0, 3877, 3878, 1, 0, 0, 0, 3878, 3881, 1, 0, 0, 0, 3879,
		3877, 1, 0, 0, 0, 3880, 3870, 1, 0, 0, 0, 3880, 3881, 1, 0, 0, 0, 3881,
		3883, 1, 0, 0, 0, 3882, 3884, 3, 774, 387, 0, 3883, 3882, 1, 0, 0, 0, 3883,
		3884, 1, 0, 0, 0, 3884, 417, 1, 0, 0, 0, 3885, 3886, 5, 229, 0, 0, 3886,
		3887, 5, 20, 0, 0, 3887, 3888, 5, 518, 0, 0, 3888, 419, 1, 0, 0, 0, 3889,
		3890, 5, 20, 0, 0, 3890, 3891, 5, 330, 0, 0, 3891, 3892, 5, 172, 0, 0,
		3892, 3907, 3, 976, 488, 0, 3893, 3894, 5, 20, 0, 0, 3894, 3895, 5, 330,
		0, 0, 3895, 3896, 5, 172, 0, 0, 3896, 3897, 3, 976, 488, 0, 3897, 3898,
		5, 3, 0, 0, 3898, 3903, 5, 518, 0, 0, 3899, 3900, 5, 3, 0, 0, 3900, 3902,
		5, 518, 0, 0, 3901, 3899, 1, 0, 0, 0, 3902, 3905, 1, 0, 0, 0, 3903, 3901,
		1, 0, 0, 0, 3903, 3904, 1, 0, 0, 0, 3904, 3907, 1, 0, 0, 0, 3905, 3903,
		1, 0, 0, 0, 3906, 3889, 1, 0, 0, 0, 3906, 3893, 1, 0, 0, 0, 3907, 421,
		1, 0, 0, 0, 3908, 3910, 5, 90, 0, 0, 3909, 3911, 5, 178, 0, 0, 3910, 3909,
		1, 0, 0, 0, 3910, 3911, 1, 0, 0, 0, 3911, 3912, 1, 0, 0, 0, 3912, 3915,
		5, 39, 0, 0, 3913, 3914, 5, 290, 0, 0, 3914, 3916, 3, 754, 377, 0, 3915,
		3913, 1, 0, 0, 0, 3915, 3916, 1, 0, 0, 0, 3916, 3917, 1, 0, 0, 0, 3917,
		3918, 5, 460, 0, 0, 3918, 3920, 3, 754, 377, 0, 3919, 3921, 3, 954, 477,
		0, 3920, 3919, 1, 0, 0, 0, 3920, 3921, 1, 0, 0, 0, 3921, 423, 1, 0, 0,
		0, 3922, 3923, 5, 132, 0, 0, 3923, 3924, 5, 39, 0, 0, 3924, 3929, 5, 518,
		0, 0, 3925, 3926, 5, 3, 0, 0, 3926, 3928, 5, 518, 0, 0, 3927, 3925, 1,
		0, 0, 0, 3928, 3931, 1, 0, 0, 0, 3929, 3927, 1, 0, 0, 0, 3929, 3930, 1,
		0, 0, 0, 3930, 425, 1, 0, 0, 0, 3931, 3929, 1, 0, 0, 0, 3932, 3933, 5,
		401, 0, 0, 3933, 3934, 5, 39, 0, 0, 3934, 427, 1, 0, 0, 0, 3935, 3936,
		5, 90, 0, 0, 3936, 3937, 5, 361, 0, 0, 3937, 3941, 5, 181, 0, 0, 3938,
		3939, 5, 197, 0, 0, 3939, 3940, 5, 281, 0, 0, 3940, 3942, 5, 148, 0, 0,
		3941, 3938, 1, 0, 0, 0, 3941, 3942, 1, 0, 0, 0, 3942, 3945, 1, 0, 0, 0,
		3943, 3944, 5, 297, 0, 0, 3944, 3946, 5, 356, 0, 0, 3945, 3943, 1, 0, 0,
		0, 3945, 3946, 1, 0, 0, 0, 3946, 3947, 1, 0, 0, 0, 3947, 3957, 3, 1018,
		509, 0, 3948, 3949, 5, 440, 0, 0, 3949, 3954, 3, 446, 223, 0, 3950, 3951,
		5, 3, 0, 0, 3951, 3953, 3, 446, 223, 0, 3952, 3950, 1, 0, 0, 0, 3953, 3956,
		1, 0, 0, 0, 3954, 3952, 1, 0, 0, 0, 3954, 3955, 1, 0, 0, 0, 3955, 3958,
		1, 0, 0, 0, 3956, 3954, 1, 0, 0, 0, 3957, 3948, 1, 0, 0, 0, 3957, 3958,
		1, 0, 0, 0, 3958, 3959, 1, 0, 0, 0, 3959, 3960, 5, 480, 0, 0, 3960, 3961,
		5, 2, 0, 0, 3961, 3966, 3, 962, 481, 0, 3962, 3963, 5, 3, 0, 0, 3963, 3965,
		3, 962, 481, 0, 3964, 3962, 1, 0, 0, 0, 3965, 3968, 1, 0, 0, 0, 3966, 3964,
		1, 0, 0, 0, 3966, 3967, 1, 0, 0, 0, 3967, 3969, 1, 0, 0, 0, 3968, 3966,
		1, 0, 0, 0, 3969, 3970, 5, 4, 0, 0, 3970, 429, 1, 0, 0, 0, 3971, 3972,
		5, 132, 0, 0, 3972, 3973, 5, 361, 0, 0, 3973, 3974, 5, 181, 0, 0, 3974,
		3975, 3, 1018, 509, 0, 3975, 431, 1, 0, 0, 0, 3976, 3977, 5, 19, 0, 0,
		3977, 3978, 5, 361, 0, 0, 3978, 3979, 5, 181, 0, 0, 3979, 3980, 3, 1018,
		509, 0, 3980, 3981, 5, 13, 0, 0, 3981, 3986, 3, 446, 223, 0, 3982, 3983,
		5, 3, 0, 0, 3983, 3985, 3, 446, 223, 0, 3984, 3982, 1, 0, 0, 0, 3985, 3988,
		1, 0, 0, 0, 3986, 3984, 1, 0, 0, 0, 3986, 3987, 1, 0, 0, 0, 3987, 4029,
		1, 0, 0, 0, 3988, 3986, 1, 0, 0, 0, 3989, 3990, 5, 19, 0, 0, 3990, 3991,
		5, 361, 0, 0, 3991, 3992, 5, 181, 0, 0, 3992, 3993, 3, 1018, 509, 0, 3993,
		3994, 5, 132, 0, 0, 3994, 3995, 5, 2, 0, 0, 3995, 4000, 5, 518, 0, 0, 3996,
		3997, 5, 3, 0, 0, 3997, 3999, 5, 518, 0, 0, 3998, 3996, 1, 0, 0, 0, 3999,
		4002, 1, 0, 0, 0, 4000, 3998, 1, 0, 0, 0, 4000, 4001, 1, 0, 0, 0, 4001,
		4003, 1, 0, 0, 0, 4002, 4000, 1, 0, 0, 0, 4003, 4004, 5, 4, 0, 0, 4004,
		4029, 1, 0, 0, 0, 4005, 4006, 5, 19, 0, 0, 4006, 4007, 5, 361, 0, 0, 4007,
		4008, 5, 181, 0, 0, 4008, 4009, 3, 1018, 509, 0, 4009, 4010, 5, 132, 0,
		0, 4010, 4011, 5, 18, 0, 0, 4011, 4029, 1, 0, 0, 0, 4012, 4013, 5, 19,
		0, 0, 4013, 4014, 5, 361, 0, 0, 4014, 4015, 5, 181, 0, 0, 4015, 4016, 3,
		1018, 509, 0, 4016, 4017, 5, 480, 0, 0, 4017, 4018, 5, 2, 0, 0, 4018, 4023,
		3, 962, 481, 0, 4019, 4020, 5, 3, 0, 0, 4020, 4022, 3, 962, 481, 0, 4021,
		4019, 1, 0, 0, 0, 4022, 4025, 1, 0, 0, 0, 4023, 4021, 1, 0, 0, 0, 4023,
		4024, 1, 0, 0, 0, 4024, 4026, 1, 0, 0, 0, 4025, 4023, 1, 0, 0, 0, 4026,
		4027, 5, 4, 0, 0, 4027, 4029, 1, 0, 0, 0, 4028, 3976, 1, 0, 0, 0, 4028,
		3989, 1, 0, 0, 0, 4028, 4005, 1, 0, 0, 0, 4028, 4012, 1, 0, 0, 0, 4029,
		433, 1, 0, 0, 0, 4030, 4032, 5, 401, 0, 0, 4031, 4033, 5, 467, 0, 0, 4032,
		4031, 1, 0, 0, 0, 4032, 4033, 1, 0, 0, 0, 4033, 4034, 1, 0, 0, 0, 4034,
		4035, 5, 361, 0, 0, 4035, 4036, 5, 181, 0, 0, 4036, 4047, 3, 1018, 509,
		0, 4037, 4039, 5, 401, 0, 0, 4038, 4040, 5, 467, 0, 0, 4039, 4038, 1, 0,
		0, 0, 4039, 4040, 1, 0, 0, 0, 4040, 4041, 1, 0, 0, 0, 4041, 4042, 5, 361,
		0, 0, 4042, 4044, 5, 182, 0, 0, 4043, 4045, 5, 18, 0, 0, 4044, 4043, 1,
		0, 0, 0, 4044, 4045, 1, 0, 0, 0, 4045, 4047, 1, 0, 0, 0, 4046, 4030, 1,
		0, 0, 0, 4046, 4037, 1, 0, 0, 0, 4047, 435, 1, 0, 0, 0, 4048, 4049, 5,
		401, 0, 0, 4049, 4050, 5, 456, 0, 0, 4050, 4051, 5, 361, 0, 0, 4051, 4052,
		5, 181, 0, 0, 4052, 4058, 3, 1018, 509, 0, 4053, 4054, 5, 401, 0, 0, 4054,
		4055, 5, 456, 0, 0, 4055, 4056, 5, 361, 0, 0, 4056, 4058, 5, 182, 0, 0,
		4057, 4048, 1, 0, 0, 0, 4057, 4053, 1, 0, 0, 0, 4058, 437, 1, 0, 0, 0,
		4059, 4061, 5, 90, 0, 0, 4060, 4062, 5, 151, 0, 0, 4061, 4060, 1, 0, 0,
		0, 4061, 4062, 1, 0, 0, 0, 4062, 4063, 1, 0, 0, 0, 4063, 4064, 5, 361,
		0, 0, 4064, 4066, 3, 1026, 513, 0, 4065, 4067, 3, 954, 477, 0, 4066, 4065,
		1, 0, 0, 0, 4066, 4067, 1, 0, 0, 0, 4067, 439, 1, 0, 0, 0, 4068, 4069,
		5, 19, 0, 0, 4069, 4070, 5, 361, 0, 0, 4070, 4071, 3, 1026, 513, 0, 4071,
		4072, 5, 396, 0, 0, 4072, 4073, 3, 954, 477, 0, 4073, 441, 1, 0, 0, 0,
		4074, 4075, 5, 132, 0, 0, 4075, 4076, 5, 361, 0, 0, 4076, 4077, 3, 1026,
		513, 0, 4077, 443, 1, 0, 0, 0, 4078, 4079, 5, 401, 0, 0, 4079, 4080, 5,
		362, 0, 0, 4080, 445, 1, 0, 0, 0, 4081, 4082, 5, 2, 0, 0, 4082, 4083, 3,
		854, 427, 0, 4083, 4084, 5, 4, 0, 0, 4084, 447, 1, 0, 0, 0, 4085, 4087,
		5, 401, 0, 0, 4086, 4088, 5, 175, 0, 0, 4087, 4086, 1, 0, 0, 0, 4087, 4088,
		1, 0, 0, 0, 4088, 4090, 1, 0, 0, 0, 4089, 4091, 7, 21, 0, 0, 4090, 4089,
		1, 0, 0, 0, 4090, 4091, 1, 0, 0, 0, 4091, 4092, 1, 0, 0, 0, 4092, 4095,
		5, 177, 0, 0, 4093, 4094, 7, 1, 0, 0, 4094, 4096, 3, 1012, 506, 0, 4095,
		4093, 1, 0, 0, 0, 4095, 4096, 1, 0, 0, 0, 4096, 4101, 1, 0, 0, 0, 4097,
		4098, 5, 240, 0, 0, 4098, 4102, 3, 976, 488, 0, 4099, 4100, 5, 478, 0,
		0, 4100, 4102, 3, 852, 426, 0, 4101, 4097, 1, 0, 0, 0, 4101, 4099, 1, 0,
		0, 0, 4101, 4102, 1, 0, 0, 0, 4102, 449, 1, 0, 0, 0, 4103, 4105, 5, 132,
		0, 0, 4104, 4106, 5, 178, 0, 0, 4105, 4104, 1, 0, 0, 0, 4105, 4106, 1,
		0, 0, 0, 4106, 4107, 1, 0, 0, 0, 4107, 4110, 5, 176, 0, 0, 4108, 4109,
		5, 197, 0, 0, 4109, 4111, 5, 148, 0, 0, 4110, 4108, 1, 0, 0, 0, 4110, 4111,
		1, 0, 0, 0, 4111, 4112, 1, 0, 0, 0, 4112, 4113, 3, 1012, 506, 0, 4113,
		4114, 5, 2, 0, 0, 4114, 4115, 3, 456, 228, 0, 4115, 4116, 5, 4, 0, 0, 4116,
		451, 1, 0, 0, 0, 4117, 4118, 5, 90, 0, 0, 4118, 4120, 3, 70, 35, 0, 4119,
		4121, 5, 178, 0, 0, 4120, 4119, 1, 0, 0, 0, 4120, 4121, 1, 0, 0, 0, 4121,
		4123, 1, 0, 0, 0, 4122, 4124, 7, 22, 0, 0, 4123, 4122, 1, 0, 0, 0, 4123,
		4124, 1, 0, 0, 0, 4124, 4125, 1, 0, 0, 0, 4125, 4126, 5, 176, 0, 0, 4126,
		4127, 3, 72, 36, 0, 4127, 4128, 3, 1012, 506, 0, 4128, 4129, 5, 2, 0, 0,
		4129, 4130, 3, 456, 228, 0, 4130, 4131, 5, 4, 0, 0, 4131, 4132, 5, 367,
		0, 0, 4132, 4135, 3, 994, 497, 0, 4133, 4136, 3, 954, 477, 0, 4134, 4136,
		3, 964, 482, 0, 4135, 4136, 1, 0, 0, 0, 4135, 4133, 1, 0, 0, 0, 4135, 4134,
		1, 0, 0, 0, 4136, 4138, 1, 0, 0, 0, 4137, 4139, 3, 454, 227, 0, 4138, 4137,
		1, 0, 0, 0, 4138, 4139, 1, 0, 0, 0, 4139, 453, 1, 0, 0, 0, 4140, 4141,
		5, 27, 0, 0, 4141, 4142, 5, 535, 0, 0, 4142, 455, 1, 0, 0, 0, 4143, 4145,
		3, 994, 497, 0, 4144, 4143, 1, 0, 0, 0, 4144, 4145, 1, 0, 0, 0, 4145, 4150,
		1, 0, 0, 0, 4146, 4147, 5, 3, 0, 0, 4147, 4149, 3, 994, 497, 0, 4148, 4146,
		1, 0, 0, 0, 4149, 4152, 1, 0, 0, 0, 4150, 4148, 1, 0, 0, 0, 4150, 4151,
		1, 0, 0, 0, 4151, 4155, 1, 0, 0, 0, 4152, 4150, 1, 0, 0, 0, 4153, 4154,
		5, 3, 0, 0, 4154, 4156, 5, 533, 0, 0, 4155, 4153, 1, 0, 0, 0, 4155, 4156,
		1, 0, 0, 0, 4156, 457, 1, 0, 0, 0, 4157, 4158, 5, 243, 0, 0, 4158, 4159,
		5, 230, 0, 0, 4159, 4161, 3, 460, 230, 0, 4160, 4162, 3, 462, 231, 0, 4161,
		4160, 1, 0, 0, 0, 4161, 4162, 1, 0, 0, 0, 4162, 4164, 1, 0, 0, 0, 4163,
		4165, 3, 468, 234, 0, 4164, 4163, 1, 0, 0, 0, 4164, 4165, 1, 0, 0, 0, 4165,
		4168, 1, 0, 0, 0, 4166, 4167, 5, 55, 0, 0, 4167, 4169, 3, 1026, 513, 0,
		4168, 4166, 1, 0, 0, 0, 4168, 4169, 1, 0, 0, 0, 4169, 4172, 1, 0, 0, 0,
		4170, 4171, 5, 332, 0, 0, 4171, 4173, 3, 958, 479, 0, 4172, 4170, 1, 0,
		0, 0, 4172, 4173, 1, 0, 0, 0, 4173, 4186, 1, 0, 0, 0, 4174, 4175, 5, 243,
		0, 0, 4175, 4176, 5, 230, 0, 0, 4176, 4178, 3, 460, 230, 0, 4177, 4179,
		3, 462, 231, 0, 4178, 4177, 1, 0, 0, 0, 4178, 4179, 1, 0, 0, 0, 4179, 4180,
		1, 0, 0, 0, 4180, 4183, 3, 470, 235, 0, 4181, 4182, 5, 332, 0, 0, 4182,
		4184, 3, 958, 479, 0, 4183, 4181, 1, 0, 0, 0, 4183, 4184, 1, 0, 0, 0, 4184,
		4186, 1, 0, 0, 0, 4185, 4157, 1, 0, 0, 0, 4185, 4174, 1, 0, 0, 0, 4186,
		459, 1, 0, 0, 0, 4187, 4188, 3, 1018, 509, 0, 4188, 4189, 5, 1, 0, 0, 4189,
		4191, 1, 0, 0, 0, 4190, 4187, 1, 0, 0, 0, 4190, 4191, 1, 0, 0, 0, 4191,
		4192, 1, 0, 0, 0, 4192, 4193, 3, 1018, 509, 0, 4193, 461, 1, 0, 0, 0, 4194,
		4195, 5, 2, 0, 0, 4195, 4200, 3, 464, 232, 0, 4196, 4197, 5, 3, 0, 0, 4197,
		4199, 3, 464, 232, 0, 4198, 4196, 1, 0, 0, 0, 4199, 4202, 1, 0, 0, 0, 4200,
		4198, 1, 0, 0, 0, 4200, 4201, 1, 0, 0, 0, 4201, 4203, 1, 0, 0, 0, 4202,
		4200, 1, 0, 0, 0, 4203, 4204, 5, 4, 0, 0, 4204, 463, 1, 0, 0, 0, 4205,
		4206, 5, 102, 0, 0, 4206, 4207, 5, 207, 0, 0, 4207, 4209, 3, 926, 463,
		0, 4208, 4210, 5, 275, 0, 0, 4209, 4208, 1, 0, 0, 0, 4209, 4210, 1, 0,
		0, 0, 4210, 4211, 1, 0, 0, 0, 4211, 4212, 5, 218, 0, 0, 4212, 4213, 5,
		422, 0, 0, 4213, 4215, 3, 1018, 509, 0, 4214, 4216, 3, 826, 413, 0, 4215,
		4214, 1, 0, 0, 0, 4215, 4216, 1, 0, 0, 0, 4216, 4221, 1, 0, 0, 0, 4217,
		4218, 5, 77, 0, 0, 4218, 4219, 5, 429, 0, 0, 4219, 4220, 5, 55, 0, 0, 4220,
		4222, 3, 976, 488, 0, 4221, 4217, 1, 0, 0, 0, 4221, 4222, 1, 0, 0, 0, 4222,
		4227, 1, 0, 0, 0, 4223, 4224, 5, 379, 0, 0, 4224, 4225, 5, 429, 0, 0, 4225,
		4226, 5, 55, 0, 0, 4226, 4228, 3, 976, 488, 0, 4227, 4223, 1, 0, 0, 0,
		4227, 4228, 1, 0, 0, 0, 4228, 4230, 1, 0, 0, 0, 4229, 4231, 3, 974, 487,
		0, 4230, 4229, 1, 0, 0, 0, 4230, 4231, 1, 0, 0, 0, 4231, 4233, 1, 0, 0,
		0, 4232, 4234, 3, 466, 233, 0, 4233, 4232, 1, 0, 0, 0, 4233, 4234, 1, 0,
		0, 0, 4234, 4236, 1, 0, 0, 0, 4235, 4237, 3, 824, 412, 0, 4236, 4235, 1,
		0, 0, 0, 4236, 4237, 1, 0, 0, 0, 4237, 4243, 1, 0, 0, 0, 4238, 4239, 5,
		77, 0, 0, 4239, 4240, 5, 172, 0, 0, 4240, 4241, 5, 306, 0, 0, 4241, 4242,
		5, 27, 0, 0, 4242, 4244, 3, 1024, 512, 0, 4243, 4238, 1, 0, 0, 0, 4243,
		4244, 1, 0, 0, 0, 4244, 4247, 1, 0, 0, 0, 4245, 4246, 5, 396, 0, 0, 4246,
		4248, 3, 446, 223, 0, 4247, 4245, 1, 0, 0, 0, 4247, 4248, 1, 0, 0, 0, 4248,
		4251, 1, 0, 0, 0, 4249, 4250, 5, 478, 0, 0, 4250, 4252, 3, 852, 426, 0,
		4251, 4249, 1, 0, 0, 0, 4251, 4252, 1, 0, 0, 0, 4252, 4275, 1, 0, 0, 0,
		4253, 4254, 5, 102, 0, 0, 4254, 4255, 5, 172, 0, 0, 4255, 4256, 5, 422,
		0, 0, 4256, 4258, 3, 1018, 509, 0, 4257, 4259, 5, 275, 0, 0, 4258, 4257,
		1, 0, 0, 0, 4258, 4259, 1, 0, 0, 0, 4259, 4260, 1, 0, 0, 0, 4260, 4261,
		5, 218, 0, 0, 4261, 4262, 5, 422, 0, 0, 4262, 4264, 3, 1018, 509, 0, 4263,
		4265, 3, 826, 413, 0, 4264, 4263, 1, 0, 0, 0, 4264, 4265, 1, 0, 0, 0, 4265,
		4268, 1, 0, 0, 0, 4266, 4267, 5, 396, 0, 0, 4267, 4269, 3, 446, 223, 0,
		4268, 4266, 1, 0, 0, 0, 4268, 4269, 1, 0, 0, 0, 4269, 4272, 1, 0, 0, 0,
		4270, 4271, 5, 478, 0, 0, 4271, 4273, 3, 852, 426, 0, 4272, 4270, 1, 0,
		0, 0, 4272, 4273, 1, 0, 0, 0, 4273, 4275, 1, 0, 0, 0, 4274, 4205, 1, 0,
		0, 0, 4274, 4253, 1, 0, 0, 0, 4275, 465, 1, 0, 0, 0, 4276, 4280, 5, 2,
		0, 0, 4277, 4278, 5, 400, 0, 0, 4278, 4279, 5, 492, 0, 0, 4279, 4281, 5,
		518, 0, 0, 4280, 4277, 1, 0, 0, 0, 4280, 4281, 1, 0, 0, 0, 4281, 4285,
		1, 0, 0, 0, 4282, 4283, 5, 443, 0, 0, 4283, 4284, 5, 492, 0, 0, 4284, 4286,
		3, 982, 491, 0, 4285, 4282, 1, 0, 0, 0, 4285, 4286, 1, 0, 0, 0, 4286, 4290,
		1, 0, 0, 0, 4287, 4288, 5, 138, 0, 0, 4288, 4289, 5, 492, 0, 0, 4289, 4291,
		3, 976, 488, 0, 4290, 4287, 1, 0, 0, 0, 4290, 4291, 1, 0, 0, 0, 4291, 4295,
		1, 0, 0, 0, 4292, 4293, 5, 143, 0, 0, 4293, 4294, 5, 492, 0, 0, 4294, 4296,
		3, 976, 488, 0, 4295, 4292, 1, 0, 0, 0, 4295, 4296, 1, 0, 0, 0, 4296, 4297,
		1, 0, 0, 0, 4297, 4298, 5, 4, 0, 0, 4298, 467, 1, 0, 0, 0, 4299, 4300,
		5, 480, 0, 0, 4300, 4302, 5, 52, 0, 0, 4301, 4303, 3, 958, 479, 0, 4302,
		4301, 1, 0, 0, 0, 4302, 4303, 1, 0, 0, 0, 4303, 4311, 1, 0, 0, 0, 4304,
		4305, 5, 480, 0, 0, 4305, 4306, 5, 52, 0, 0, 4306, 4308, 3, 1026, 513,
		0, 4307, 4309, 3, 958, 479, 0, 4308, 4307, 1, 0, 0, 0, 4308, 4309, 1, 0,
		0, 0, 4309, 4311, 1, 0, 0, 0, 4310, 4299, 1, 0, 0, 0, 4310, 4304, 1, 0,
		0, 0, 4311, 469, 1, 0, 0, 0, 4312, 4313, 5, 480, 0, 0, 4313, 4314, 5, 361,
		0, 0, 4314, 4316, 3, 1026, 513, 0, 4315, 4317, 3, 958, 479, 0, 4316, 4315,
		1, 0, 0, 0, 4316, 4317, 1, 0, 0, 0, 4317, 471, 1, 0, 0, 0, 4318, 4319,
		5, 401, 0, 0, 4319, 4321, 5, 243, 0, 0, 4320, 4322, 5, 18, 0, 0, 4321,
		4320, 1, 0, 0, 0, 4321, 4322, 1, 0, 0, 0, 4322, 4325, 1, 0, 0, 0, 4323,
		4324, 5, 172, 0, 0, 4324, 4326, 3, 1018, 509, 0, 4325, 4323, 1, 0, 0, 0,
		4325, 4326, 1, 0, 0, 0, 4326, 4329, 1, 0, 0, 0, 4327, 4328, 5, 478, 0,
		0, 4328, 4330, 3, 852, 426, 0, 4329, 4327, 1, 0, 0, 0, 4329, 4330, 1, 0,
		0, 0, 4330, 4341, 1, 0, 0, 0, 4331, 4332, 5, 298, 0, 0, 4332, 4333, 5,
		55, 0, 0, 4333, 4338, 3, 770, 385, 0, 4334, 4335, 5, 3, 0, 0, 4335, 4337,
		3, 770, 385, 0, 4336, 4334, 1, 0, 0, 0, 4337, 4340, 1, 0, 0, 0, 4338, 4336,
		1, 0, 0, 0, 4338, 4339, 1, 0, 0, 0, 4339, 4342, 1, 0, 0, 0, 4340, 4338,
		1, 0, 0, 0, 4341, 4331, 1, 0, 0, 0, 4341, 4342, 1, 0, 0, 0, 4342, 4344,
		1, 0, 0, 0, 4343, 4345, 3, 774, 387, 0, 4344, 4343, 1, 0, 0, 0, 4344, 4345,
		1, 0, 0, 0, 4345, 473, 1, 0, 0, 0, 4346, 4347, 5, 401, 0, 0, 4347, 4348,
		5, 243, 0, 0, 4348, 4351, 5, 475, 0, 0, 4349, 4350, 5, 172, 0, 0, 4350,
		4352, 3, 1018, 509, 0, 4351, 4349, 1, 0, 0, 0, 4351, 4352, 1, 0, 0, 0,
		4352, 4355, 1, 0, 0, 0, 4353, 4354, 5, 478, 0, 0, 4354, 4356, 3, 852, 426,
		0, 4355, 4353, 1, 0, 0, 0, 4355, 4356, 1, 0, 0, 0, 4356, 4358, 1, 0, 0,
		0, 4357, 4359, 3, 774, 387, 0, 4358, 4357, 1, 0, 0, 0, 4358, 4359, 1, 0,
		0, 0, 4359, 4366, 1, 0, 0, 0, 4360, 4361, 5, 401, 0, 0, 4361, 4362, 5,
		243, 0, 0, 4362, 4363, 5, 475, 0, 0, 4363, 4364, 5, 290, 0, 0, 4364, 4366,
		3, 976, 488, 0, 4365, 4346, 1, 0, 0, 0, 4365, 4360, 1, 0, 0, 0, 4366, 475,
		1, 0, 0, 0, 4367, 4368, 5, 57, 0, 0, 4368, 4371, 5, 243, 0, 0, 4369, 4370,
		5, 172, 0, 0, 4370, 4372, 3, 1018, 509, 0, 4371, 4369, 1, 0, 0, 0, 4371,
		4372, 1, 0, 0, 0, 4372, 4375, 1, 0, 0, 0, 4373, 4374, 5, 478, 0, 0, 4374,
		4376, 3, 852, 426, 0, 4375, 4373, 1, 0, 0, 0, 4375, 4376, 1, 0, 0, 0, 4376,
		477, 1, 0, 0, 0, 4377, 4378, 5, 19, 0, 0, 4378, 4379, 5, 243, 0, 0, 4379,
		4383, 5, 168, 0, 0, 4380, 4381, 3, 1012, 506, 0, 4381, 4382, 5, 1, 0, 0,
		4382, 4384, 1, 0, 0, 0, 4383, 4380, 1, 0, 0, 0, 4383, 4384, 1, 0, 0, 0,
		4384, 4385, 1, 0, 0, 0, 4385, 4387, 3, 1018, 509, 0, 4386, 4388, 3, 378,
		189, 0, 4387, 4386, 1, 0, 0, 0, 4387, 4388, 1, 0, 0, 0, 4388, 479, 1, 0,
		0, 0, 4389, 4390, 5, 57, 0, 0, 4390, 4391, 5, 82, 0, 0, 4391, 4392, 5,
		478, 0, 0, 4392, 4393, 3, 852, 426, 0, 4393, 481, 1, 0, 0, 0, 4394, 4395,
		5, 401, 0, 0, 4395, 4396, 5, 30, 0, 0, 4396, 483, 1, 0, 0, 0, 4397, 4398,
		5, 401, 0, 0, 4398, 4399, 5, 36, 0, 0, 4399, 485, 1, 0, 0, 0, 4400, 4401,
		5, 401, 0, 0, 4401, 4402, 5, 52, 0, 0, 4402, 487, 1, 0, 0, 0, 4403, 4409,
		5, 401, 0, 0, 4404, 4405, 5, 64, 0, 0, 4405, 4410, 5, 396, 0, 0, 4406,
		4410, 5, 66, 0, 0, 4407, 4408, 5, 65, 0, 0, 4408, 4410, 5, 396, 0, 0, 4409,
		4404, 1, 0, 0, 0, 4409, 4406, 1, 0, 0, 0, 4409, 4407, 1, 0, 0, 0, 4410,
		4415, 1, 0, 0, 0, 4411, 4412, 5, 240, 0, 0, 4412, 4416, 3, 976, 488, 0,
		4413, 4414, 5, 478, 0, 0, 4414, 4416, 3, 852, 426, 0, 4415, 4411, 1, 0,
		0, 0, 4415, 4413, 1, 0, 0, 0, 4415, 4416, 1, 0, 0, 0, 4416, 489, 1, 0,
		0, 0, 4417, 4418, 5, 401, 0, 0, 4418, 4423, 5, 75, 0, 0, 4419, 4420, 5,
		240, 0, 0, 4420, 4424, 3, 976, 488, 0, 4421, 4422, 5, 478, 0, 0, 4422,
		4424, 3, 852, 426, 0, 4423, 4419, 1, 0, 0, 0, 4423, 4421, 1, 0, 0, 0, 4423,
		4424, 1, 0, 0, 0, 4424, 491, 1, 0, 0, 0, 4425, 4426, 5, 401, 0, 0, 4426,
		4429, 5, 118, 0, 0, 4427, 4428, 7, 1, 0, 0, 4428, 4430, 3, 1012, 506, 0,
		4429, 4427, 1, 0, 0, 0, 4429, 4430, 1, 0, 0, 0, 4430, 493, 1, 0, 0, 0,
		4431, 4432, 5, 401, 0, 0, 4432, 4433, 5, 135, 0, 0, 4433, 4434, 5, 303,
		0, 0, 4434, 4437, 5, 423, 0, 0, 4435, 4436, 7, 1, 0, 0, 4436, 4438, 3,
		1012, 506, 0, 4437, 4435, 1, 0, 0, 0, 4437, 4438, 1, 0, 0, 0, 4438, 495,
		1, 0, 0, 0, 4439, 4440, 5, 401, 0, 0, 4440, 4443, 5, 144, 0, 0, 4441, 4442,
		7, 1, 0, 0, 4442, 4444, 3, 1012, 506, 0, 4443, 4441, 1, 0, 0, 0, 4443,
		4444, 1, 0, 0, 0, 4444, 4449, 1, 0, 0, 0, 4445, 4446, 5, 240, 0, 0, 4446,
		4450, 3, 976, 488, 0, 4447, 4448, 5, 478, 0, 0, 4448, 4450, 3, 852, 426,
		0, 4449, 4445, 1, 0, 0, 0, 4449, 4447, 1, 0, 0, 0, 4449, 4450, 1, 0, 0,
		0, 4450, 497, 1, 0, 0, 0, 4451, 4452, 5, 401, 0, 0, 4452, 4453, 5, 141,
		0, 0, 4453, 499, 1, 0, 0, 0, 4454, 4455, 5, 401, 0, 0, 4455, 4456, 5, 174,
		0, 0, 4456, 501, 1, 0, 0, 0, 4457, 4458, 5, 401, 0, 0, 4458, 4459, 5, 314,
		0, 0, 4459, 503, 1, 0, 0, 0, 4460, 4461, 5, 401, 0, 0, 4461, 4462, 5, 360,
		0, 0, 4462, 505, 1, 0, 0, 0, 4463, 4464, 5, 401, 0, 0, 4464, 4465, 5, 292,
		0, 0, 4465, 4466, 5, 423, 0, 0, 4466, 507, 1, 0, 0, 0, 4467, 4468, 5, 401,
		0, 0, 4468, 4469, 5, 325, 0, 0, 4469, 509, 1, 0, 0, 0, 4470, 4471, 5, 401,
		0, 0, 4471, 4472, 7, 23, 0, 0, 4472, 4477, 5, 408, 0, 0, 4473, 4474, 5,
		240, 0, 0, 4474, 4478, 3, 976, 488, 0, 4475, 4476, 5, 478, 0, 0, 4476,
		4478, 3, 852, 426, 0, 4477, 4473, 1, 0, 0, 0, 4477, 4475, 1, 0, 0, 0, 4477,
		4478, 1, 0, 0, 0, 4478, 511, 1, 0, 0, 0, 4479, 4480, 5, 401, 0, 0, 4480,
		4481, 5, 327, 0, 0, 4481, 4482, 3, 976, 488, 0, 4482, 513, 1, 0, 0, 0,
		4483, 4485, 5, 401, 0, 0, 4484, 4486, 5, 175, 0, 0, 4485, 4484, 1, 0, 0,
		0, 4485, 4486, 1, 0, 0, 0, 4486, 4487, 1, 0, 0, 0, 4487, 4490, 5, 329,
		0, 0, 4488, 4489, 5, 168, 0, 0, 4489, 4491, 3, 976, 488, 0, 4490, 4488,
		1, 0, 0, 0, 4490, 4491, 1, 0, 0, 0, 4491, 515, 1, 0, 0, 0, 4492, 4493,
		5, 401, 0, 0, 4493, 4496, 5, 331, 0, 0, 4494, 4495, 5, 241, 0, 0, 4495,
		4497, 5, 518, 0, 0, 4496, 4494, 1, 0, 0, 0, 4496, 4497, 1, 0, 0, 0, 4497,
		517, 1, 0, 0, 0, 4498, 4499, 5, 401, 0, 0, 4499, 4500, 5, 383, 0, 0, 4500,
		4503, 5, 339, 0, 0, 4501, 4502, 5, 241, 0, 0, 4502, 4504, 5, 518, 0, 0,
		4503, 4501, 1, 0, 0, 0, 4503, 4504, 1, 0, 0, 0, 4504, 519, 1, 0, 0, 0,
		4505, 4507, 5, 401, 0, 0, 4506, 4508, 3, 968, 484, 0, 4507, 4506, 1, 0,
		0, 0, 4507, 4508, 1, 0, 0, 0, 4508, 4509, 1, 0, 0, 0, 4509, 4514, 5, 408,
		0, 0, 4510, 4511, 5, 240, 0, 0, 4511, 4515, 3, 976, 488, 0, 4512, 4513,
		5, 478, 0, 0, 4513, 4515, 3, 852, 426, 0, 4514, 4510, 1, 0, 0, 0, 4514,
		4512, 1, 0, 0, 0, 4514, 4515, 1, 0, 0, 0, 4515, 521, 1, 0, 0, 0, 4516,
		4517, 5, 401, 0, 0, 4517, 4518, 5, 424, 0, 0, 4518, 4546, 5, 518, 0, 0,
		4519, 4520, 5, 401, 0, 0, 4520, 4521, 7, 24, 0, 0, 4521, 4522, 5, 172,
		0, 0, 4522, 4524, 3, 1012, 506, 0, 4523, 4525, 3, 826, 413, 0, 4524, 4523,
		1, 0, 0, 0, 4524, 4525, 1, 0, 0, 0, 4525, 4528, 1, 0, 0, 0, 4526, 4527,
		5, 478, 0, 0, 4527, 4529, 3, 852, 426, 0, 4528, 4526, 1, 0, 0, 0, 4528,
		4529, 1, 0, 0, 0, 4529, 4540, 1, 0, 0, 0, 4530, 4531, 5, 298, 0, 0, 4531,
		4532, 5, 55, 0, 0, 4532, 4537, 3, 770, 385, 0, 4533, 4534, 5, 3, 0, 0,
		4534, 4536, 3, 770, 385, 0, 4535, 4533, 1, 0, 0, 0, 4536, 4539, 1, 0, 0,
		0, 4537, 4535, 1, 0, 0, 0, 4537, 4538, 1, 0, 0, 0, 4538, 4541, 1, 0, 0,
		0, 4539, 4537, 1, 0, 0, 0, 4540, 4530, 1, 0, 0, 0, 4540, 4541, 1, 0, 0,
		0, 4541, 4543, 1, 0, 0, 0, 4542, 4544, 3, 774, 387, 0, 4543, 4542, 1, 0,
		0, 0, 4543, 4544, 1, 0, 0, 0, 4544, 4546, 1, 0, 0, 0, 4545, 4516, 1, 0,
		0, 0, 4545, 4519, 1, 0, 0, 0, 4546, 523, 1, 0, 0, 0, 4547, 4548, 5, 401,
		0, 0, 4548, 4551, 5, 438, 0, 0, 4549, 4550, 7, 1, 0, 0, 4550, 4552, 3,
		1012, 506, 0, 4551, 4549, 1, 0, 0, 0, 4551, 4552, 1, 0, 0, 0, 4552, 4555,
		1, 0, 0, 0, 4553, 4554, 5, 478, 0, 0, 4554, 4556, 3, 852, 426, 0, 4555,
		4553, 1, 0, 0, 0, 4555, 4556, 1, 0, 0, 0, 4556, 525, 1, 0, 0, 0, 4557,
		4559, 5, 401, 0, 0, 4558, 4560, 5, 175, 0, 0, 4559, 4558, 1, 0, 0, 0, 4559,
		4560, 1, 0, 0, 0, 4560, 4561, 1, 0, 0, 0, 4561, 4564, 5, 442, 0, 0, 4562,
		4563, 7, 1, 0, 0, 4563, 4565, 3, 1012, 506, 0, 4564, 4562, 1, 0, 0, 0,
		4564, 4565, 1, 0, 0, 0, 4565, 4570, 1, 0, 0, 0, 4566, 4567, 5, 240, 0,
		0, 4567, 4571, 3, 976, 488, 0, 4568, 4569, 5, 478, 0, 0, 4569, 4571, 3,
		852, 426, 0, 4570, 4566, 1, 0, 0, 0, 4570, 4568, 1, 0, 0, 0, 4570, 4571,
		1, 0, 0, 0, 4571, 527, 1, 0, 0, 0, 4572, 4573, 5, 401, 0, 0, 4573, 4576,
		5, 333, 0, 0, 4574, 4575, 5, 168, 0, 0, 4575, 4577, 3, 976, 488, 0, 4576,
		4574, 1, 0, 0, 0, 4576, 4577, 1, 0, 0, 0, 4577, 4580, 1, 0, 0, 0, 4578,
		4579, 5, 240, 0, 0, 4579, 4581, 3, 976, 488, 0, 4580, 4578, 1, 0, 0, 0,
		4580, 4581, 1, 0, 0, 0, 4581, 4593, 1, 0, 0, 0, 4582, 4583, 5, 401, 0,
		0, 4583, 4586, 5, 332, 0, 0, 4584, 4585, 5, 168, 0, 0, 4585, 4587, 3, 976,
		488, 0, 4586, 4584, 1, 0, 0, 0, 4586, 4587, 1, 0, 0, 0, 4587, 4590, 1,
		0, 0, 0, 4588, 4589, 5, 240, 0, 0, 4589, 4591, 3, 976, 488, 0, 4590, 4588,
		1, 0, 0, 0, 4590, 4591, 1, 0, 0, 0, 4591, 4593, 1, 0, 0, 0, 4592, 4572,
		1, 0, 0, 0, 4592, 4582, 1, 0, 0, 0, 4593, 529, 1, 0, 0, 0, 4594, 4596,
		5, 401, 0, 0, 4595, 4597, 3, 968, 484, 0, 4596, 4595, 1, 0, 0, 0, 4596,
		4597, 1, 0, 0, 0, 4597, 4598, 1, 0, 0, 0, 4598, 4603, 5, 465, 0, 0, 4599,
		4600, 5, 240, 0, 0, 4600, 4604, 3, 976, 488, 0, 4601, 4602, 5, 478, 0,
		0, 4602, 4604, 3, 852, 426, 0, 4603, 4599, 1, 0, 0, 0, 4603, 4601, 1, 0,
		0, 0, 4603, 4604, 1, 0, 0, 0, 4604, 531, 1, 0, 0, 0, 4605, 4606, 5, 401,
		0, 0, 4606, 4608, 7, 25, 0, 0, 4607, 4609, 3, 774, 387, 0, 4608, 4607,
		1, 0, 0, 0, 4608, 4609, 1, 0, 0, 0, 4609, 533, 1, 0, 0, 0, 4610, 4611,
		5, 188, 0, 0, 4611, 4612, 3, 1026, 513, 0, 4612, 535, 1, 0, 0, 0, 4613,
		4614, 5, 90, 0, 0, 4614, 4618, 5, 458, 0, 0, 4615, 4616, 5, 197, 0, 0,
		4616, 4617, 5, 281, 0, 0, 4617, 4619, 5, 148, 0, 0, 4618, 4615, 1, 0, 0,
		0, 4618, 4619, 1, 0, 0, 0, 4619, 4620, 1, 0, 0, 0, 4620, 4622, 3, 1032,
		516, 0, 4621, 4623, 3, 572, 286, 0, 4622, 4621, 1, 0, 0, 0, 4622, 4623,
		1, 0, 0, 0, 4623, 4627, 1, 0, 0, 0, 4624, 4625, 5, 117, 0, 0, 4625, 4626,
		5, 373, 0, 0, 4626, 4628, 3, 694, 347, 0, 4627, 4624, 1, 0, 0, 0, 4627,
		4628, 1, 0, 0, 0, 4628, 4630, 1, 0, 0, 0, 4629, 4631, 3, 954, 477, 0, 4630,
		4629, 1, 0, 0, 0, 4630, 4631, 1, 0, 0, 0, 4631, 537, 1, 0, 0, 0, 4632,
		4633, 5, 132, 0, 0, 4633, 4636, 5, 458, 0, 0, 4634, 4635, 5, 197, 0, 0,
		4635, 4637, 5, 148, 0, 0, 4636, 4634, 1, 0, 0, 0, 4636, 4637, 1, 0, 0,
		0, 4637, 4638, 1, 0, 0, 0, 4638, 4639, 3, 1032, 516, 0, 4639, 539, 1, 0,
		0, 0, 4640, 4641, 5, 19, 0, 0, 4641, 4644, 5, 458, 0, 0, 4642, 4643, 5,
		197, 0, 0, 4643, 4645, 5, 148, 0, 0, 4644, 4642, 1, 0, 0, 0, 4644, 4645,
		1, 0, 0, 0, 4645, 4646, 1, 0, 0, 0, 4646, 4647, 3, 1032, 516, 0, 4647,
		4648, 3, 572, 286, 0, 4648, 4674, 1, 0, 0, 0, 4649, 4650, 5, 19, 0, 0,
		4650, 4653, 5, 458, 0, 0, 4651, 4652, 5, 197, 0, 0, 4652, 4654, 5, 148,
		0, 0, 4653, 4651, 1, 0, 0, 0, 4653, 4654, 1, 0, 0, 0, 4654, 4655, 1, 0,
		0, 0, 4655, 4656, 3, 1032, 516, 0, 4656, 4657, 5, 117, 0, 0, 4657, 4661,
		5, 373, 0, 0, 4658, 4662, 5, 280, 0, 0, 4659, 4662, 5, 18, 0, 0, 4660,
		4662, 3, 694, 347, 0, 4661, 4658, 1, 0, 0, 0, 4661, 4659, 1, 0, 0, 0, 4661,
		4660, 1, 0, 0, 0, 4662, 4674, 1, 0, 0, 0, 4663, 4664, 5, 19, 0, 0, 4664,
		4667, 5, 458, 0, 0, 4665, 4666, 5, 197, 0, 0, 4666, 4668, 5, 148, 0, 0,
		4667, 4665, 1, 0, 0, 0, 4667, 4668, 1, 0, 0, 0, 4668, 4669, 1, 0, 0, 0,
		4669, 4670, 3, 1032, 516, 0, 4670, 4671, 5, 396, 0, 0, 4671, 4672, 3, 954,
		477, 0, 4672, 4674, 1, 0, 0, 0, 4673, 4640, 1, 0, 0, 0, 4673, 4649, 1,
		0, 0, 0, 4673, 4663, 1, 0, 0, 0, 4674, 541, 1, 0, 0, 0, 4675, 4676, 5,
		401, 0, 0, 4676, 4677, 7, 26, 0, 0, 4677, 543, 1, 0, 0, 0, 4678, 4679,
		5, 401, 0, 0, 4679, 4680, 5, 18, 0, 0, 4680, 4688, 5, 31, 0, 0, 4681, 4682,
		5, 401, 0, 0, 4682, 4685, 5, 31, 0, 0, 4683, 4684, 5, 168, 0, 0, 4684,
		4686, 3, 1032, 516, 0, 4685, 4683, 1, 0, 0, 0, 4685, 4686, 1, 0, 0, 0,
		4686, 4688, 1, 0, 0, 0, 4687, 4678, 1, 0, 0, 0, 4687, 4681, 1, 0, 0, 0,
		4688, 545, 1, 0, 0, 0, 4689, 4690, 5, 147, 0, 0, 4690, 4691, 5, 27, 0,
		0, 4691, 4695, 3, 1032, 516, 0, 4692, 4693, 5, 480, 0, 0, 4693, 4694, 5,
		277, 0, 0, 4694, 4696, 5, 370, 0, 0, 4695, 4692, 1, 0, 0, 0, 4695, 4696,
		1, 0, 0, 0, 4696, 547, 1, 0, 0, 0, 4697, 4698, 5, 90, 0, 0, 4698, 4702,
		5, 373, 0, 0, 4699, 4700, 5, 197, 0, 0, 4700, 4701, 5, 281, 0, 0, 4701,
		4703, 5, 148, 0, 0, 4702, 4699, 1, 0, 0, 0, 4702, 4703, 1, 0, 0, 0, 4703,
		4704, 1, 0, 0, 0, 4704, 4706, 3, 694, 347, 0, 4705, 4707, 3, 970, 485,
		0, 4706, 4705, 1, 0, 0, 0, 4706, 4707, 1, 0, 0, 0, 4707, 549, 1, 0, 0,
		0, 4708, 4709, 5, 19, 0, 0, 4709, 4712, 5, 373, 0, 0, 4710, 4711, 5, 197,
		0, 0, 4711, 4713, 5, 148, 0, 0, 4712, 4710, 1, 0, 0, 0, 4712, 4713, 1,
		0, 0, 0, 4713, 4714, 1, 0, 0, 0, 4714, 4715, 3, 694, 347, 0, 4715, 4716,
		5, 396, 0, 0, 4716, 4717, 5, 78, 0, 0, 4717, 4718, 5, 492, 0, 0, 4718,
		4719, 3, 976, 488, 0, 4719, 551, 1, 0, 0, 0, 4720, 4721, 5, 132, 0, 0,
		4721, 4724, 5, 373, 0, 0, 4722, 4723, 5, 197, 0, 0, 4723, 4725, 5, 148,
		0, 0, 4724, 4722, 1, 0, 0, 0, 4724, 4725, 1, 0, 0, 0, 4725, 4726, 1, 0,
		0, 0, 4726, 4727, 3, 694, 347, 0, 4727, 553, 1, 0, 0, 0, 4728, 4729, 5,
		401, 0, 0, 4729, 4730, 5, 374, 0, 0, 4730, 555, 1, 0, 0, 0, 4731, 4732,
		5, 179, 0, 0, 4732, 4733, 3, 1028, 514, 0, 4733, 4735, 5, 440, 0, 0, 4734,
		4736, 5, 458, 0, 0, 4735, 4734, 1, 0, 0, 0, 4735, 4736, 1, 0, 0, 0, 4736,
		4737, 1, 0, 0, 0, 4737, 4738, 3, 1032, 516, 0, 4738, 4746, 1, 0, 0, 0,
		4739, 4740, 5, 179, 0, 0, 4740, 4741, 3, 1028, 514, 0, 4741, 4742, 5, 440,
		0, 0, 4742, 4743, 5, 373, 0, 0, 4743, 4744, 3, 1026, 513, 0, 4744, 4746,
		1, 0, 0, 0, 4745, 4731, 1, 0, 0, 0, 4745, 4739, 1, 0, 0, 0, 4746, 557,
		1, 0, 0, 0, 4747, 4748, 5, 369, 0, 0, 4748, 4749, 3, 1028, 514, 0, 4749,
		4751, 5, 172, 0, 0, 4750, 4752, 5, 458, 0, 0, 4751, 4750, 1, 0, 0, 0, 4751,
		4752, 1, 0, 0, 0, 4752, 4753, 1, 0, 0, 0, 4753, 4754, 3, 1032, 516, 0,
		4754, 4762, 1, 0, 0, 0, 4755, 4756, 5, 369, 0, 0, 4756, 4757, 3, 1028,
		514, 0, 4757, 4758, 5, 172, 0, 0, 4758, 4759, 5, 373, 0, 0, 4759, 4760,
		3, 1026, 513, 0, 4760, 4762, 1, 0, 0, 0, 4761, 4747, 1, 0, 0, 0, 4761,
		4755, 1, 0, 0, 0, 4762, 559, 1, 0, 0, 0, 4763, 4764, 5, 396, 0, 0, 4764,
		4765, 5, 373, 0, 0, 4765, 4780, 5, 117, 0, 0, 4766, 4767, 5, 396, 0, 0,
		4767, 4768, 5, 373, 0, 0, 4768, 4780, 5, 280, 0, 0, 4769, 4770, 5, 396,
		0, 0, 4770, 4771, 5, 373, 0, 0, 4771, 4774, 5, 18, 0, 0, 4772, 4773, 5,
		145, 0, 0, 4773, 4775, 3, 694, 347, 0, 4774, 4772, 1, 0, 0, 0, 4774, 4775,
		1, 0, 0, 0, 4775, 4780, 1, 0, 0, 0, 4776, 4777, 5, 396, 0, 0, 4777, 4778,
		5, 373, 0, 0, 4778, 4780, 3, 694, 347, 0, 4779, 4763, 1, 0, 0, 0, 4779,
		4766, 1, 0, 0, 0, 4779, 4769, 1, 0, 0, 0, 4779, 4776, 1, 0, 0, 0, 4780,
		561, 1, 0, 0, 0, 4781, 4782, 5, 396, 0, 0, 4782, 4783, 5, 117, 0, 0, 4783,
		4787, 5, 373, 0, 0, 4784, 4788, 5, 280, 0, 0, 4785, 4788, 5, 18, 0, 0,
		4786, 4788, 3, 694, 347, 0, 4787, 4784, 1, 0, 0, 0, 4787, 4785, 1, 0, 0,
		0, 4787, 4786, 1, 0, 0, 0, 4788, 4789, 1, 0, 0, 0, 4789, 4790, 5, 440,
		0, 0, 4790, 4791, 3, 1032, 516, 0, 4791, 563, 1, 0, 0, 0, 4792, 4794, 5,
		458, 0, 0, 4793, 4792, 1, 0, 0, 0, 4793, 4794, 1, 0, 0, 0, 4794, 4795,
		1, 0, 0, 0, 4795, 4799, 3, 1032, 516, 0, 4796, 4797, 5, 373, 0, 0, 4797,
		4799, 3, 1026, 513, 0, 4798, 4793, 1, 0, 0, 0, 4798, 4796, 1, 0, 0, 0,
		4799, 565, 1, 0, 0, 0, 4800, 4801, 5, 179, 0, 0, 4801, 4802, 5, 198, 0,
		0, 4802, 4803, 5, 290, 0, 0, 4803, 4804, 5, 458, 0, 0, 4804, 4809, 3, 1032,
		516, 0, 4805, 4806, 5, 3, 0, 0, 4806, 4808, 3, 1032, 516, 0, 4807, 4805,
		1, 0, 0, 0, 4808, 4811, 1, 0, 0, 0, 4809, 4807, 1, 0, 0, 0, 4809, 4810,
		1, 0, 0, 0, 4810, 4812, 1, 0, 0, 0, 4811, 4809, 1, 0, 0, 0, 4812, 4813,
		5, 440, 0, 0, 4813, 4817, 3, 564, 282, 0, 4814, 4815, 5, 480, 0, 0, 4815,
		4816, 5, 179, 0, 0, 4816, 4818, 5, 296, 0, 0, 4817, 4814, 1, 0, 0, 0, 4817,
		4818, 1, 0, 0, 0, 4818, 4889, 1, 0, 0, 0, 4819, 4820, 5, 179, 0, 0, 4820,
		4821, 3, 580, 290, 0, 4821, 4822, 5, 290, 0, 0, 4822, 4823, 3, 576, 288,
		0, 4823, 4824, 5, 440, 0, 0, 4824, 4828, 3, 564, 282, 0, 4825, 4826, 5,
		480, 0, 0, 4826, 4827, 5, 179, 0, 0, 4827, 4829, 5, 296, 0, 0, 4828, 4825,
		1, 0, 0, 0, 4828, 4829, 1, 0, 0, 0, 4829, 4889, 1, 0, 0, 0, 4830, 4831,
		5, 179, 0, 0, 4831, 4832, 3, 580, 290, 0, 4832, 4834, 5, 290, 0, 0, 4833,
		4835, 5, 178, 0, 0, 4834, 4833, 1, 0, 0, 0, 4834, 4835, 1, 0, 0, 0, 4835,
		4836, 1, 0, 0, 0, 4836, 4837, 5, 176, 0, 0, 4837, 4838, 3, 578, 289, 0,
		4838, 4839, 5, 440, 0, 0, 4839, 4843, 3, 564, 282, 0, 4840, 4841, 5, 480,
		0, 0, 4841, 4842, 5, 179, 0, 0, 4842, 4844, 5, 296, 0, 0, 4843, 4840, 1,
		0, 0, 0, 4843, 4844, 1, 0, 0, 0, 4844, 4889, 1, 0, 0, 0, 4845, 4846, 5,
		179, 0, 0, 4846, 4847, 3, 580, 290, 0, 4847, 4848, 5, 290, 0, 0, 4848,
		4849, 5, 418, 0, 0, 4849, 4850, 5, 440, 0, 0, 4850, 4854, 3, 564, 282,
		0, 4851, 4852, 5, 480, 0, 0, 4852, 4853, 5, 179, 0, 0, 4853, 4855, 5, 296,
		0, 0, 4854, 4851, 1, 0, 0, 0, 4854, 4855, 1, 0, 0, 0, 4855, 4889, 1, 0,
		0, 0, 4856, 4857, 5, 179, 0, 0, 4857, 4858, 3, 580, 290, 0, 4858, 4859,
		5, 290, 0, 0, 4859, 4860, 3, 584, 292, 0, 4860, 4861, 3, 576, 288, 0, 4861,
		4862, 5, 440, 0, 0, 4862, 4866, 3, 564, 282, 0, 4863, 4864, 5, 480, 0,
		0, 4864, 4865, 5, 179, 0, 0, 4865, 4867, 5, 296, 0, 0, 4866, 4863, 1, 0,
		0, 0, 4866, 4867, 1, 0, 0, 0, 4867, 4889, 1, 0, 0, 0, 4868, 4869, 5, 179,
		0, 0, 4869, 4870, 3, 580, 290, 0, 4870, 4871, 5, 290, 0, 0, 4871, 4872,
		5, 18, 0, 0, 4872, 4879, 3, 586, 293, 0, 4873, 4874, 5, 202, 0, 0, 4874,
		4875, 5, 18, 0, 0, 4875, 4880, 5, 105, 0, 0, 4876, 4877, 5, 202, 0, 0,
		4877, 4878, 5, 104, 0, 0, 4878, 4880, 3, 1026, 513, 0, 4879, 4873, 1, 0,
		0, 0, 4879, 4876, 1, 0, 0, 0, 4879, 4880, 1, 0, 0, 0, 4880, 4881, 1, 0,
		0, 0, 4881, 4882, 5, 440, 0, 0, 4882, 4886, 3, 564, 282, 0, 4883, 4884,
		5, 480, 0, 0, 4884, 4885, 5, 179, 0, 0, 4885, 4887, 5, 296, 0, 0, 4886,
		4883, 1, 0, 0, 0, 4886, 4887, 1, 0, 0, 0, 4887, 4889, 1, 0, 0, 0, 4888,
		4800, 1, 0, 0, 0, 4888, 4819, 1, 0, 0, 0, 4888, 4830, 1, 0, 0, 0, 4888,
		4845, 1, 0, 0, 0, 4888, 4856, 1, 0, 0, 0, 4888, 4868, 1, 0, 0, 0, 4889,
		567, 1, 0, 0, 0, 4890, 4891, 5, 369, 0, 0, 4891, 4892, 5, 198, 0, 0, 4892,
		4893, 5, 290, 0, 0, 4893, 4894, 5, 458, 0, 0, 4894, 4899, 3, 1032, 516,
		0, 4895, 4896, 5, 3, 0, 0, 4896, 4898, 3, 1032, 516, 0, 4897, 4895, 1,
		0, 0, 0, 4898, 4901, 1, 0, 0, 0, 4899, 4897, 1, 0, 0, 0, 4899, 4900, 1,
		0, 0, 0, 4900, 4902, 1, 0, 0, 0, 4901, 4899, 1, 0, 0, 0, 4902, 4903, 5,
		172, 0, 0, 4903, 4904, 3, 564, 282, 0, 4904, 4955, 1, 0, 0, 0, 4905, 4906,
		5, 369, 0, 0, 4906, 4907, 3, 580, 290, 0, 4907, 4908, 5, 290, 0, 0, 4908,
		4909, 3, 576, 288, 0, 4909, 4910, 5, 172, 0, 0, 4910, 4911, 3, 564, 282,
		0, 4911, 4955, 1, 0, 0, 0, 4912, 4913, 5, 369, 0, 0, 4913, 4914, 3, 580,
		290, 0, 4914, 4916, 5, 290, 0, 0, 4915, 4917, 5, 178, 0, 0, 4916, 4915,
		1, 0, 0, 0, 4916, 4917, 1, 0, 0, 0, 4917, 4918, 1, 0, 0, 0, 4918, 4919,
		5, 176, 0, 0, 4919, 4920, 3, 578, 289, 0, 4920, 4921, 5, 172, 0, 0, 4921,
		4922, 3, 564, 282, 0, 4922, 4955, 1, 0, 0, 0, 4923, 4924, 5, 369, 0, 0,
		4924, 4925, 3, 580, 290, 0, 4925, 4926, 5, 290, 0, 0, 4926, 4927, 5, 418,
		0, 0, 4927, 4928, 5, 172, 0, 0, 4928, 4929, 3, 564, 282, 0, 4929, 4955,
		1, 0, 0, 0, 4930, 4931, 5, 369, 0, 0, 4931, 4932, 3, 580, 290, 0, 4932,
		4933, 5, 290, 0, 0, 4933, 4934, 3, 584, 292, 0, 4934, 4935, 3, 576, 288,
		0, 4935, 4936, 5, 172, 0, 0, 4936, 4937, 3, 564, 282, 0, 4937, 4955, 1,
		0, 0, 0, 4938, 4939, 5, 369, 0, 0, 4939, 4940, 3, 580, 290, 0, 4940, 4941,
		5, 290, 0, 0, 4941, 4942, 5, 18, 0, 0, 4942, 4949, 3, 586, 293, 0, 4943,
		4944, 5, 202, 0, 0, 4944, 4945, 5, 18, 0, 0, 4945, 4950, 5, 105, 0, 0,
		4946, 4947, 5, 202, 0, 0, 4947, 4948, 5, 104, 0, 0, 4948, 4950, 3, 1026,
		513, 0, 4949, 4943, 1, 0, 0, 0, 4949, 4946, 1, 0, 0, 0, 4949, 4950, 1,
		0, 0, 0, 4950, 4951, 1, 0, 0, 0, 4951, 4952, 5, 172, 0, 0, 4952, 4953,
		3, 564, 282, 0, 4953, 4955, 1, 0, 0, 0, 4954, 4890, 1, 0, 0, 0, 4954, 4905,
		1, 0, 0, 0, 4954, 4912, 1, 0, 0, 0, 4954, 4923, 1, 0, 0, 0, 4954, 4930,
		1, 0, 0, 0, 4954, 4938, 1, 0, 0, 0, 4955, 569, 1, 0, 0, 0, 4956, 4957,
		5, 401, 0, 0, 4957, 4971, 5, 180, 0, 0, 4958, 4959, 5, 401, 0, 0, 4959,
		4960, 5, 180, 0, 0, 4960, 4962, 5, 168, 0, 0, 4961, 4963, 5, 458, 0, 0,
		4962, 4961, 1, 0, 0, 0, 4962, 4963, 1, 0, 0, 0, 4963, 4964, 1, 0, 0, 0,
		4964, 4971, 3, 1032, 516, 0, 4965, 4966, 5, 401, 0, 0, 4966, 4967, 5, 180,
		0, 0, 4967, 4968, 5, 168, 0, 0, 4968, 4969, 5, 373, 0, 0, 4969, 4971, 3,
		1026, 513, 0, 4970, 4956, 1, 0, 0, 0, 4970, 4958, 1, 0, 0, 0, 4970, 4965,
		1, 0, 0, 0, 4971, 571, 1, 0, 0, 0, 4972, 4973, 5, 196, 0, 0, 4973, 4975,
		5, 55, 0, 0, 4974, 4976, 5, 305, 0, 0, 4975, 4974, 1, 0, 0, 0, 4975, 4976,
		1, 0, 0, 0, 4976, 4977, 1, 0, 0, 0, 4977, 4986, 3, 976, 488, 0, 4978, 4979,
		5, 196, 0, 0, 4979, 4980, 5, 480, 0, 0, 4980, 4983, 3, 1026, 513, 0, 4981,
		4982, 7, 27, 0, 0, 4982, 4984, 3, 976, 488, 0, 4983, 4981, 1, 0, 0, 0,
		4983, 4984, 1, 0, 0, 0, 4984, 4986, 1, 0, 0, 0, 4985, 4972, 1, 0, 0, 0,
		4985, 4978, 1, 0, 0, 0, 4986, 573, 1, 0, 0, 0, 4987, 4990, 3, 1030, 515,
		0, 4988, 4989, 5, 1, 0, 0, 4989, 4991, 3, 1030, 515, 0, 4990, 4988, 1,
		0, 0, 0, 4990, 4991, 1, 0, 0, 0, 4991, 575, 1, 0, 0, 0, 4992, 4997, 3,
		574, 287, 0, 4993, 4994, 5, 3, 0, 0, 4994, 4996, 3, 574, 287, 0, 4995,
		4993, 1, 0, 0, 0, 4996, 4999, 1, 0, 0, 0, 4997, 4995, 1, 0, 0, 0, 4997,
		4998, 1, 0, 0, 0, 4998, 577, 1, 0, 0, 0, 4999, 4997, 1, 0, 0, 0, 5000,
		5001, 3, 1012, 506, 0, 5001, 5002, 5, 2, 0, 0, 5002, 5003, 3, 456, 228,
		0, 5003, 5012, 5, 4, 0, 0, 5004, 5005, 5, 3, 0, 0, 5005, 5006, 3, 1012,
		506, 0, 5006, 5007, 5, 2, 0, 0, 5007, 5008, 3, 456, 228, 0, 5008, 5009,
		5, 4, 0, 0, 5009, 5011, 1, 0, 0, 0, 5010, 5004, 1, 0, 0, 0, 5011, 5014,
		1, 0, 0, 0, 5012, 5010, 1, 0, 0, 0, 5012, 5013, 1, 0, 0, 0, 5013, 579,
		1, 0, 0, 0, 5014, 5012, 1, 0, 0, 0, 5015, 5020, 3, 582, 291, 0, 5016, 5017,
		5, 3, 0, 0, 5017, 5019, 3, 582, 291, 0, 5018, 5016, 1, 0, 0, 0, 5019, 5022,
		1, 0, 0, 0, 5020, 5018, 1, 0, 0, 0, 5020, 5021, 1, 0, 0, 0, 5021, 581,
		1, 0, 0, 0, 5022, 5020, 1, 0, 0, 0, 5023, 5025, 5, 18, 0, 0, 5024, 5026,
		5, 325, 0, 0, 5025, 5024, 1, 0, 0, 0, 5025, 5026, 1, 0, 0, 0, 5026, 5067,
		1, 0, 0, 0, 5027, 5067, 5, 19, 0, 0, 5028, 5067, 5, 23, 0, 0, 5029, 5067,
		5, 47, 0, 0, 5030, 5049, 5, 90, 0, 0, 5031, 5050, 5, 104, 0, 0, 5032, 5050,
		5, 422, 0, 0, 5033, 5050, 5, 469, 0, 0, 5034, 5050, 5, 176, 0, 0, 5035,
		5036, 5, 178, 0, 0, 5036, 5050, 5, 176, 0, 0, 5037, 5038, 5, 257, 0, 0,
		5038, 5050, 5, 469, 0, 0, 5039, 5050, 5, 361, 0, 0, 5040, 5041, 5, 361,
		0, 0, 5041, 5050, 5, 181, 0, 0, 5042, 5043, 5, 151, 0, 0, 5043, 5050, 5,
		60, 0, 0, 5044, 5045, 5, 410, 0, 0, 5045, 5050, 5, 471, 0, 0, 5046, 5050,
		5, 473, 0, 0, 5047, 5050, 5, 72, 0, 0, 5048, 5050, 5, 315, 0, 0, 5049,
		5031, 1, 0, 0, 0, 5049, 5032, 1, 0, 0, 0, 5049, 5033, 1, 0, 0, 0, 5049,
		5034, 1, 0, 0, 0, 5049, 5035, 1, 0, 0, 0, 5049, 5037, 1, 0, 0, 0, 5049,
		5039, 1, 0, 0, 0, 5049, 5040, 1, 0, 0, 0, 5049, 5042, 1, 0, 0, 0, 5049,
		5044, 1, 0, 0, 0, 5049, 5046, 1, 0, 0, 0, 5049, 5047, 1, 0, 0, 0, 5049,
		5048, 1, 0, 0, 0, 5050, 5067, 1, 0, 0, 0, 5051, 5067, 5, 118, 0, 0, 5052,
		5067, 5, 132, 0, 0, 5053, 5067, 5, 150, 0, 0, 5054, 5067, 5, 158, 0, 0,
		5055, 5067, 5, 198, 0, 0, 5056, 5067, 5, 210, 0, 0, 5057, 5067, 5, 179,
		0, 0, 5058, 5067, 5, 278, 0, 0, 5059, 5067, 5, 293, 0, 0, 5060, 5067, 5,
		313, 0, 0, 5061, 5067, 5, 359, 0, 0, 5062, 5067, 5, 348, 0, 0, 5063, 5067,
		5, 391, 0, 0, 5064, 5067, 5, 455, 0, 0, 5065, 5067, 5, 456, 0, 0, 5066,
		5023, 1, 0, 0, 0, 5066, 5027, 1, 0, 0, 0, 5066, 5028, 1, 0, 0, 0, 5066,
		5029, 1, 0, 0, 0, 5066, 5030, 1, 0, 0, 0, 5066, 5051, 1, 0, 0, 0, 5066,
		5052, 1, 0, 0, 0, 5066, 5053, 1, 0, 0, 0, 5066, 5054, 1, 0, 0, 0, 5066,
		5055, 1, 0, 0, 0, 5066, 5056, 1, 0, 0, 0, 5066, 5057, 1, 0, 0, 0, 5066,
		5058, 1, 0, 0, 0, 5066, 5059, 1, 0, 0, 0, 5066, 5060, 1, 0, 0, 0, 5066,
		5061, 1, 0, 0, 0, 5066, 5062, 1, 0, 0, 0, 5066, 5063, 1, 0, 0, 0, 5066,
		5064, 1, 0, 0, 0, 5066, 5065, 1, 0, 0, 0, 5067, 583, 1, 0, 0, 0, 5068,
		5083, 5, 60, 0, 0, 5069, 5083, 5, 104, 0, 0, 5070, 5071, 5, 257, 0, 0,
		5071, 5083, 5, 469, 0, 0, 5072, 5083, 5, 361, 0, 0, 5073, 5074, 5, 361,
		0, 0, 5074, 5083, 5, 181, 0, 0, 5075, 5076, 5, 410, 0, 0, 5076, 5083, 5,
		471, 0, 0, 5077, 5083, 5, 418, 0, 0, 5078, 5083, 5, 422, 0, 0, 5079, 5083,
		5, 469, 0, 0, 5080, 5083, 5, 473, 0, 0, 5081, 5083, 5, 315, 0, 0, 5082,
		5068, 1, 0, 0, 0, 5082, 5069, 1, 0, 0, 0, 5082, 5070, 1, 0, 0, 0, 5082,
		5072, 1, 0, 0, 0, 5082, 5073, 1, 0, 0, 0, 5082, 5075, 1, 0, 0, 0, 5082,
		5077, 1, 0, 0, 0, 5082, 5078, 1, 0, 0, 0, 5082, 5079, 1, 0, 0, 0, 5082,
		5080, 1, 0, 0, 0, 5082, 5081, 1, 0, 0, 0, 5083, 585, 1, 0, 0, 0, 5084,
		5103, 5, 61, 0, 0, 5085, 5103, 5, 105, 0, 0, 5086, 5103, 5, 177, 0, 0,
		5087, 5088, 5, 178, 0, 0, 5088, 5103, 5, 177, 0, 0, 5089, 5090, 5, 257,
		0, 0, 5090, 5103, 5, 470, 0, 0, 5091, 5103, 5, 319, 0, 0, 5092, 5103, 5,
		362, 0, 0, 5093, 5094, 5, 361, 0, 0, 5094, 5103, 5, 182, 0, 0, 5095, 5096,
		5, 410, 0, 0, 5096, 5103, 5, 472, 0, 0, 5097, 5103, 5, 423, 0, 0, 5098,
		5103, 5, 459, 0, 0, 5099, 5103, 5, 470, 0, 0, 5100, 5103, 5, 474, 0, 0,
		5101, 5103, 5, 316, 0, 0, 5102, 5084, 1, 0, 0, 0, 5102, 5085, 1, 0, 0,
		0, 5102, 5086, 1, 0, 0, 0, 5102, 5087, 1, 0, 0, 0, 5102, 5089, 1, 0, 0,
		0, 5102, 5091, 1, 0, 0, 0, 5102, 5092, 1, 0, 0, 0, 5102, 5093, 1, 0, 0,
		0, 5102, 5095, 1, 0, 0, 0, 5102, 5097, 1, 0, 0, 0, 5102, 5098, 1, 0, 0,
		0, 5102, 5099, 1, 0, 0, 0, 5102, 5100, 1, 0, 0, 0, 5102, 5101, 1, 0, 0,
		0, 5103, 587, 1, 0, 0, 0, 5104, 5105, 5, 90, 0, 0, 5105, 5106, 5, 390,
		0, 0, 5106, 5107, 5, 213, 0, 0, 5107, 5108, 3, 1018, 509, 0, 5108, 5109,
		3, 954, 477, 0, 5109, 589, 1, 0, 0, 0, 5110, 5111, 5, 19, 0, 0, 5111, 5112,
		5, 390, 0, 0, 5112, 5113, 5, 213, 0, 0, 5113, 5114, 3, 1018, 509, 0, 5114,
		5115, 5, 396, 0, 0, 5115, 5116, 3, 958, 479, 0, 5116, 591, 1, 0, 0, 0,
		5117, 5118, 5, 132, 0, 0, 5118, 5119, 5, 390, 0, 0, 5119, 5120, 5, 213,
		0, 0, 5120, 5121, 3, 1018, 509, 0, 5121, 593, 1, 0, 0, 0, 5122, 5123, 5,
		401, 0, 0, 5123, 5124, 5, 390, 0, 0, 5124, 5125, 5, 214, 0, 0, 5125, 595,
		1, 0, 0, 0, 5126, 5127, 5, 401, 0, 0, 5127, 5128, 5, 90, 0, 0, 5128, 5129,
		5, 390, 0, 0, 5129, 5130, 5, 213, 0, 0, 5130, 5131, 3, 1018, 509, 0, 5131,
		597, 1, 0, 0, 0, 5132, 5133, 5, 90, 0, 0, 5133, 5134, 5, 181, 0, 0, 5134,
		5135, 5, 334, 0, 0, 5135, 5136, 3, 1018, 509, 0, 5136, 5137, 3, 954, 477,
		0, 5137, 599, 1, 0, 0, 0, 5138, 5139, 5, 132, 0, 0, 5139, 5140, 5, 181,
		0, 0, 5140, 5141, 5, 334, 0, 0, 5141, 5142, 3, 1018, 509, 0, 5142, 601,
		1, 0, 0, 0, 5143, 5144, 5, 401, 0, 0, 5144, 5145, 5, 181, 0, 0, 5145, 5146,
		5, 335, 0, 0, 5146, 603, 1, 0, 0, 0, 5147, 5148, 5, 401, 0, 0, 5148, 5149,
		5, 90, 0, 0, 5149, 5150, 5, 181, 0, 0, 5150, 5151, 5, 334, 0, 0, 5151,
		5152, 3, 1018, 509, 0, 5152, 605, 1, 0, 0, 0, 5153, 5160, 5, 37, 0, 0,
		5154, 5155, 5, 18, 0, 0, 5155, 5156, 5, 151, 0, 0, 5156, 5161, 5, 61, 0,
		0, 5157, 5158, 5, 151, 0, 0, 5158, 5159, 7, 28, 0, 0, 5159, 5161, 3, 1024,
		512, 0, 5160, 5154, 1, 0, 0, 0, 5160, 5157, 1, 0, 0, 0, 5160, 5161, 1,
		0, 0, 0, 5161, 5164, 1, 0, 0, 0, 5162, 5163, 5, 104, 0, 0, 5163, 5165,
		3, 1018, 509, 0, 5164, 5162, 1, 0, 0, 0, 5164, 5165, 1, 0, 0, 0, 5165,
		5166, 1, 0, 0, 0, 5166, 5167, 5, 403, 0, 0, 5167, 5168, 3, 1012, 506, 0,
		5168, 5169, 5, 440, 0, 0, 5169, 5182, 3, 1018, 509, 0, 5170, 5171, 5, 290,
		0, 0, 5171, 5172, 5, 2, 0, 0, 5172, 5177, 3, 898, 449, 0, 5173, 5174, 5,
		3, 0, 0, 5174, 5176, 3, 898, 449, 0, 5175, 5173, 1, 0, 0, 0, 5176, 5179,
		1, 0, 0, 0, 5177, 5175, 1, 0, 0, 0, 5177, 5178, 1, 0, 0, 0, 5178, 5180,
		1, 0, 0, 0, 5179, 5177, 1, 0, 0, 0, 5180, 5181, 5, 4, 0, 0, 5181, 5183,
		1, 0, 0, 0, 5182, 5170, 1, 0, 0, 0, 5182, 5183, 1, 0, 0, 0, 5183, 5186,
		1, 0, 0, 0, 5184, 5185, 5, 332, 0, 0, 5185, 5187, 3, 958, 479, 0, 5186,
		5184, 1, 0, 0, 0, 5186, 5187, 1, 0, 0, 0, 5187, 607, 1, 0, 0, 0, 5188,
		5189, 5, 57, 0, 0, 5189, 5195, 5, 37, 0, 0, 5190, 5191, 7, 1, 0, 0, 5191,
		5196, 3, 1018, 509, 0, 5192, 5193, 5, 168, 0, 0, 5193, 5194, 5, 151, 0,
		0, 5194, 5196, 5, 60, 0, 0, 5195, 5190, 1, 0, 0, 0, 5195, 5192, 1, 0, 0,
		0, 5195, 5196, 1, 0, 0, 0, 5196, 609, 1, 0, 0, 0, 5197, 5198, 5, 401, 0,
		0, 5198, 5201, 5, 37, 0, 0, 5199, 5200, 7, 1, 0, 0, 5200, 5202, 3, 1018,
		509, 0, 5201, 5199, 1, 0, 0, 0, 5201, 5202, 1, 0, 0, 0, 5202, 611, 1, 0,
		0, 0, 5203, 5204, 5, 363, 0, 0, 5204, 5205, 5, 403, 0, 0, 5205, 5206, 3,
		1012, 506, 0, 5206, 5207, 5, 172, 0, 0, 5207, 5214, 3, 1018, 509, 0, 5208,
		5209, 5, 18, 0, 0, 5209, 5210, 5, 151, 0, 0, 5210, 5215, 5, 61, 0, 0, 5211,
		5212, 5, 151, 0, 0, 5212, 5213, 7, 28, 0, 0, 5213, 5215, 3, 1022, 511,
		0, 5214, 5208, 1, 0, 0, 0, 5214, 5211, 1, 0, 0, 0, 5214, 5215, 1, 0, 0,
		0, 5215, 5222, 1, 0, 0, 0, 5216, 5217, 5, 104, 0, 0, 5217, 5220, 3, 1018,
		509, 0, 5218, 5219, 5, 27, 0, 0, 5219, 5221, 3, 1018, 509, 0, 5220, 5218,
		1, 0, 0, 0, 5220, 5221, 1, 0, 0, 0, 5221, 5223, 1, 0, 0, 0, 5222, 5216,
		1, 0, 0, 0, 5222, 5223, 1, 0, 0, 0, 5223, 5236, 1, 0, 0, 0, 5224, 5225,
		5, 290, 0, 0, 5225, 5226, 5, 2, 0, 0, 5226, 5231, 3, 898, 449, 0, 5227,
		5228, 5, 3, 0, 0, 5228, 5230, 3, 898, 449, 0, 5229, 5227, 1, 0, 0, 0, 5230,
		5233, 1, 0, 0, 0, 5231, 5229, 1, 0, 0, 0, 5231, 5232, 1, 0, 0, 0, 5232,
		5234, 1, 0, 0, 0, 5233, 5231, 1, 0, 0, 0, 5234, 5235, 5, 4, 0, 0, 5235,
		5237, 1, 0, 0, 0, 5236, 5224, 1, 0, 0, 0, 5236, 5237, 1, 0, 0, 0, 5237,
		5240, 1, 0, 0, 0, 5238, 5239, 5, 332, 0, 0, 5239, 5241, 3, 958, 479, 0,
		5240, 5238, 1, 0, 0, 0, 5240, 5241, 1, 0, 0, 0, 5241, 613, 1, 0, 0, 0,
		5242, 5243, 5, 57, 0, 0, 5243, 5249, 5, 363, 0, 0, 5244, 5245, 7, 1, 0,
		0, 5245, 5250, 3, 1018, 509, 0, 5246, 5247, 5, 168, 0, 0, 5247, 5248, 5,
		151, 0, 0, 5248, 5250, 5, 60, 0, 0, 5249, 5244, 1, 0, 0, 0, 5249, 5246,
		1, 0, 0, 0, 5249, 5250, 1, 0, 0, 0, 5250, 615, 1, 0, 0, 0, 5251, 5252,
		5, 401, 0, 0, 5252, 5255, 5, 363, 0, 0, 5253, 5254, 7, 1, 0, 0, 5254, 5256,
		3, 1018, 509, 0, 5255, 5253, 1, 0, 0, 0, 5255, 5256, 1, 0, 0, 0, 5256,
		5259, 1, 0, 0, 0, 5257, 5258, 5, 478, 0, 0, 5258, 5260, 3, 852, 426, 0,
		5259, 5257, 1, 0, 0, 0, 5259, 5260, 1, 0, 0, 0, 5260, 617, 1, 0, 0, 0,
		5261, 5262, 5, 401, 0, 0, 5262, 5263, 5, 403, 0, 0, 5263, 5264, 5, 290,
		0, 0, 5264, 5267, 3, 1018, 509, 0, 5265, 5266, 5, 478, 0, 0, 5266, 5268,
		3, 852, 426, 0, 5267, 5265, 1, 0, 0, 0, 5267, 5268, 1, 0, 0, 0, 5268, 619,
		1, 0, 0, 0, 5269, 5272, 5, 90, 0, 0, 5270, 5271, 5, 345, 0, 0, 5271, 5273,
		5, 291, 0, 0, 5272, 5270, 1, 0, 0, 0, 5272, 5273, 1, 0, 0, 0, 5273, 5274,
		1, 0, 0, 0, 5274, 5275, 5, 359, 0, 0, 5275, 5276, 3, 1018, 509, 0, 5276,
		5277, 5, 480, 0, 0, 5277, 5279, 5, 52, 0, 0, 5278, 5280, 3, 1026, 513,
		0, 5279, 5278, 1, 0, 0, 0, 5279, 5280, 1, 0, 0, 0, 5280, 5281, 1, 0, 0,
		0, 5281, 5282, 5, 290, 0, 0, 5282, 5283, 5, 247, 0, 0, 5283, 5286, 3, 976,
		488, 0, 5284, 5285, 5, 332, 0, 0, 5285, 5287, 3, 958, 479, 0, 5286, 5284,
		1, 0, 0, 0, 5286, 5287, 1, 0, 0, 0, 5287, 621, 1, 0, 0, 0, 5288, 5289,
		5, 132, 0, 0, 5289, 5290, 5, 359, 0, 0, 5290, 5291, 3, 1018, 509, 0, 5291,
		623, 1, 0, 0, 0, 5292, 5293, 5, 13, 0, 0, 5293, 5294, 5, 405, 0, 0, 5294,
		5295, 3, 976, 488, 0, 5295, 625, 1, 0, 0, 0, 5296, 5297, 5, 118, 0, 0,
		5297, 5298, 5, 405, 0, 0, 5298, 5303, 5, 518, 0, 0, 5299, 5300, 5, 3, 0,
		0, 5300, 5302, 5, 518, 0, 0, 5301, 5299, 1, 0, 0, 0, 5302, 5305, 1, 0,
		0, 0, 5303, 5301, 1, 0, 0, 0, 5303, 5304, 1, 0, 0, 0, 5304, 627, 1, 0,
		0, 0, 5305, 5303, 1, 0, 0, 0, 5306, 5307, 5, 401, 0, 0, 5307, 5308, 5,
		405, 0, 0, 5308, 629, 1, 0, 0, 0, 5309, 5310, 5, 401, 0, 0, 5310, 5311,
		5, 479, 0, 0, 5311, 631, 1, 0, 0, 0, 5312, 5313, 5, 13, 0, 0, 5313, 5314,
		5, 35, 0, 0, 5314, 5315, 5, 47, 0, 0, 5315, 5320, 5, 518, 0, 0, 5316, 5317,
		5, 3, 0, 0, 5317, 5319, 5, 518, 0, 0, 5318, 5316, 1, 0, 0, 0, 5319, 5322,
		1, 0, 0, 0, 5320, 5318, 1, 0, 0, 0, 5320, 5321, 1, 0, 0, 0, 5321, 633,
		1, 0, 0, 0, 5322, 5320, 1, 0, 0, 0, 5323, 5324, 5, 118, 0, 0, 5324, 5325,
		5, 35, 0, 0, 5325, 5326, 5, 47, 0, 0, 5326, 5331, 5, 518, 0, 0, 5327, 5328,
		5, 3, 0, 0, 5328, 5330, 5, 518, 0, 0, 5329, 5327, 1, 0, 0, 0, 5330, 5333,
		1, 0, 0, 0, 5331, 5329, 1, 0, 0, 0, 5331, 5332, 1, 0, 0, 0, 5332, 635,
		1, 0, 0, 0, 5333, 5331, 1, 0, 0, 0, 5334, 5335, 5, 401, 0, 0, 5335, 5336,
		5, 35, 0, 0, 5336, 5337, 5, 47, 0, 0, 5337, 637, 1, 0, 0, 0, 5338, 5339,
		3, 1030, 515, 0, 5339, 5340, 5, 1, 0, 0, 5340, 5341, 3, 1030, 515, 0, 5341,
		5342, 5, 1, 0, 0, 5342, 5343, 3, 1030, 515, 0, 5343, 639, 1, 0, 0, 0, 5344,
		5345, 5, 90, 0, 0, 5345, 5346, 5, 103, 0, 0, 5346, 5347, 5, 381, 0, 0,
		5347, 5350, 3, 638, 319, 0, 5348, 5349, 5, 478, 0, 0, 5349, 5351, 3, 852,
		426, 0, 5350, 5348, 1, 0, 0, 0, 5350, 5351, 1, 0, 0, 0, 5351, 5352, 1,
		0, 0, 0, 5352, 5353, 5, 324, 0, 0, 5353, 5355, 5, 492, 0, 0, 5354, 5356,
		5, 501, 0, 0, 5355, 5354, 1, 0, 0, 0, 5355, 5356, 1, 0, 0, 0, 5356, 5357,
		1, 0, 0, 0, 5357, 5359, 5, 518, 0, 0, 5358, 5360, 3, 954, 477, 0, 5359,
		5358, 1, 0, 0, 0, 5359, 5360, 1, 0, 0, 0, 5360, 641, 1, 0, 0, 0, 5361,
		5362, 5, 401, 0, 0, 5362, 5363, 5, 103, 0, 0, 5363, 5364, 5, 382, 0, 0,
		5364, 643, 1, 0, 0, 0, 5365, 5366, 5, 132, 0, 0, 5366, 5367, 5, 103, 0,
		0, 5367, 5368, 5, 381, 0, 0, 5368, 5369, 5, 518, 0, 0, 5369, 645, 1, 0,
		0, 0, 5370, 5371, 5, 69, 0, 0, 5371, 5372, 5, 103, 0, 0, 5372, 5373, 5,
		382, 0, 0, 5373, 647, 1, 0, 0, 0, 5374, 5375, 5, 56, 0, 0, 5375, 5376,
		5, 391, 0, 0, 5376, 5381, 3, 788, 394, 0, 5377, 5378, 5, 3, 0, 0, 5378,
		5380, 3, 788, 394, 0, 5379, 5377, 1, 0, 0, 0, 5380, 5383, 1, 0, 0, 0, 5381,
		5379, 1, 0, 0, 0, 5381, 5382, 1, 0, 0, 0, 5382, 5384, 1, 0, 0, 0, 5383,
		5381, 1, 0, 0, 0, 5384, 5385, 5, 172, 0, 0, 5385, 5388, 3, 1012, 506, 0,
		5386, 5387, 5, 478, 0, 0, 5387, 5389, 3, 852, 426, 0, 5388, 5386, 1, 0,
		0, 0, 5388, 5389, 1, 0, 0, 0, 5389, 5391, 1, 0, 0, 0, 5390, 5392, 3, 954,
		477, 0, 5391, 5390, 1, 0, 0, 0, 5391, 5392, 1, 0, 0, 0, 5392, 649, 1, 0,
		0, 0, 5393, 5394, 5, 150, 0, 0, 5394, 5395, 5, 422, 0, 0, 5395, 5397, 3,
		900, 450, 0, 5396, 5398, 3, 824, 412, 0, 5397, 5396, 1, 0, 0, 0, 5397,
		5398, 1, 0, 0, 0, 5398, 5399, 1, 0, 0, 0, 5399, 5400, 5, 440, 0, 0, 5400,
		5404, 3, 976, 488, 0, 5401, 5402, 5, 480, 0, 0, 5402, 5403, 7, 12, 0, 0,
		5403, 5405, 5, 269, 0, 0, 5404, 5401, 1, 0, 0, 0, 5404, 5405, 1, 0, 0,
		0, 5405, 5407, 1, 0, 0, 0, 5406, 5408, 3, 954, 477, 0, 5407, 5406, 1, 0,
		0, 0, 5407, 5408, 1, 0, 0, 0, 5408, 5410, 1, 0, 0, 0, 5409, 5411, 3, 468,
		234, 0, 5410, 5409, 1, 0, 0, 0, 5410, 5411, 1, 0, 0, 0, 5411, 651, 1, 0,
		0, 0, 5412, 5413, 5, 57, 0, 0, 5413, 5416, 5, 150, 0, 0, 5414, 5415, 7,
		1, 0, 0, 5415, 5417, 3, 1012, 506, 0, 5416, 5414, 1, 0, 0, 0, 5416, 5417,
		1, 0, 0, 0, 5417, 5422, 1, 0, 0, 0, 5418, 5419, 5, 240, 0, 0, 5419, 5423,
		3, 976, 488, 0, 5420, 5421, 5, 478, 0, 0, 5421, 5423, 3, 852, 426, 0, 5422,
		5418, 1, 0, 0, 0, 5422, 5420, 1, 0, 0, 0, 5422, 5423, 1, 0, 0, 0, 5423,
		653, 1, 0, 0, 0, 5424, 5425, 5, 401, 0, 0, 5425, 5428, 5, 150, 0, 0, 5426,
		5427, 7, 1, 0, 0, 5427, 5429, 3, 1012, 506, 0, 5428, 5426, 1, 0, 0, 0,
		5428, 5429, 1, 0, 0, 0, 5429, 5434, 1, 0, 0, 0, 5430, 5431, 5, 240, 0,
		0, 5431, 5435, 3, 976, 488, 0, 5432, 5433, 5, 478, 0, 0, 5433, 5435, 3,
		852, 426, 0, 5434, 5430, 1, 0, 0, 0, 5434, 5432, 1, 0, 0, 0, 5434, 5435,
		1, 0, 0, 0, 5435, 5446, 1, 0, 0, 0, 5436, 5437, 5, 298, 0, 0, 5437, 5438,
		5, 55, 0, 0, 5438, 5443, 3, 770, 385, 0, 5439, 5440, 5, 3, 0, 0, 5440,
		5442, 3, 770, 385, 0, 5441, 5439, 1, 0, 0, 0, 5442, 5445, 1, 0, 0, 0, 5443,
		5441, 1, 0, 0, 0, 5443, 5444, 1, 0, 0, 0, 5444, 5447, 1, 0, 0, 0, 5445,
		5443, 1, 0, 0, 0, 5446, 5436, 1, 0, 0, 0, 5446, 5447, 1, 0, 0, 0, 5447,
		5449, 1, 0, 0, 0, 5448, 5450, 3, 774, 387, 0, 5449, 5448, 1, 0, 0, 0, 5449,
		5450, 1, 0, 0, 0, 5450, 655, 1, 0, 0, 0, 5451, 5452, 5, 209, 0, 0, 5452,
		5453, 5, 313, 0, 0, 5453, 5454, 5, 172, 0, 0, 5454, 5456, 3, 1026, 513,
		0, 5455, 5457, 3, 954, 477, 0, 5456, 5455, 1, 0, 0, 0, 5456, 5457, 1, 0,
		0, 0, 5457, 657, 1, 0, 0, 0, 5458, 5459, 5, 452, 0, 0, 5459, 5460, 5, 313,
		0, 0, 5460, 5461, 3, 1026, 513, 0, 5461, 659, 1, 0, 0, 0, 5462, 5463, 5,
		90, 0, 0, 5463, 5464, 5, 158, 0, 0, 5464, 5467, 3, 976, 488, 0, 5465, 5466,
		7, 1, 0, 0, 5466, 5468, 3, 1012, 506, 0, 5467, 5465, 1, 0, 0, 0, 5467,
		5468, 1, 0, 0, 0, 5468, 5469, 1, 0, 0, 0, 5469, 5470, 3, 954, 477, 0, 5470,
		661, 1, 0, 0, 0, 5471, 5472, 5, 132, 0, 0, 5472, 5473, 5, 158, 0, 0, 5473,
		5476, 3, 976, 488, 0, 5474, 5475, 7, 1, 0, 0, 5475, 5477, 3, 1012, 506,
		0, 5476, 5474, 1, 0, 0, 0, 5476, 5477, 1, 0, 0, 0, 5477, 5478, 1, 0, 0,
		0, 5478, 5479, 3, 954, 477, 0, 5479, 663, 1, 0, 0, 0, 5480, 5481, 5, 401,
		0, 0, 5481, 5484, 5, 158, 0, 0, 5482, 5483, 7, 1, 0, 0, 5483, 5485, 3,
		1012, 506, 0, 5484, 5482, 1, 0, 0, 0, 5484, 5485, 1, 0, 0, 0, 5485, 665,
		1, 0, 0, 0, 5486, 5487, 5, 90, 0, 0, 5487, 5488, 3, 70, 35, 0, 5488, 5489,
		5, 315, 0, 0, 5489, 5490, 3, 72, 36, 0, 5490, 5492, 3, 1012, 506, 0, 5491,
		5493, 3, 954, 477, 0, 5492, 5491, 1, 0, 0, 0, 5492, 5493, 1, 0, 0, 0, 5493,
		5494, 1, 0, 0, 0, 5494, 5495, 5, 27, 0, 0, 5495, 5496, 3, 352, 176, 0,
		5496, 667, 1, 0, 0, 0, 5497, 5498, 5, 132, 0, 0, 5498, 5501, 5, 315, 0,
		0, 5499, 5500, 5, 197, 0, 0, 5500, 5502, 5, 148, 0, 0, 5501, 5499, 1, 0,
		0, 0, 5501, 5502, 1, 0, 0, 0, 5502, 5503, 1, 0, 0, 0, 5503, 5504, 3, 1012,
		506, 0, 5504, 669, 1, 0, 0, 0, 5505, 5515, 5, 416, 0, 0, 5506, 5515, 5,
		364, 0, 0, 5507, 5508, 5, 368, 0, 0, 5508, 5515, 5, 18, 0, 0, 5509, 5510,
		5, 368, 0, 0, 5510, 5511, 5, 158, 0, 0, 5511, 5515, 3, 976, 488, 0, 5512,
		5513, 5, 396, 0, 0, 5513, 5515, 3, 958, 479, 0, 5514, 5505, 1, 0, 0, 0,
		5514, 5506, 1, 0, 0, 0, 5514, 5507, 1, 0, 0, 0, 5514, 5509, 1, 0, 0, 0,
		5514, 5512, 1, 0, 0, 0, 5515, 671, 1, 0, 0, 0, 5516, 5517, 5, 19, 0, 0,
		5517, 5518, 5, 315, 0, 0, 5518, 5519, 3, 1012, 506, 0, 5519, 5520, 3, 670,
		335, 0, 5520, 673, 1, 0, 0, 0, 5521, 5522, 7, 8, 0, 0, 5522, 5523, 5, 315,
		0, 0, 5523, 5524, 3, 1012, 506, 0, 5524, 675, 1, 0, 0, 0, 5525, 5526, 5,
		401, 0, 0, 5526, 5533, 5, 316, 0, 0, 5527, 5528, 5, 240, 0, 0, 5528, 5534,
		3, 976, 488, 0, 5529, 5530, 5, 478, 0, 0, 5530, 5534, 3, 852, 426, 0, 5531,
		5532, 5, 172, 0, 0, 5532, 5534, 3, 1012, 506, 0, 5533, 5527, 1, 0, 0, 0,
		5533, 5529, 1, 0, 0, 0, 5533, 5531, 1, 0, 0, 0, 5533, 5534, 1, 0, 0, 0,
		5534, 5545, 1, 0, 0, 0, 5535, 5536, 5, 298, 0, 0, 5536, 5537, 5, 55, 0,
		0, 5537, 5542, 3, 770, 385, 0, 5538, 5539, 5, 3, 0, 0, 5539, 5541, 3, 770,
		385, 0, 5540, 5538, 1, 0, 0, 0, 5541, 5544, 1, 0, 0, 0, 5542, 5540, 1,
		0, 0, 0, 5542, 5543, 1, 0, 0, 0, 5543, 5546, 1, 0, 0, 0, 5544, 5542, 1,
		0, 0, 0, 5545, 5535, 1, 0, 0, 0, 5545, 5546, 1, 0, 0, 0, 5546, 5548, 1,
		0, 0, 0, 5547, 5549, 3, 774, 387, 0, 5548, 5547, 1, 0, 0, 0, 5548, 5549,
		1, 0, 0, 0, 5549, 677, 1, 0, 0, 0, 5550, 5551, 5, 396, 0, 0, 5551, 5556,
		3, 680, 340, 0, 5552, 5553, 5, 3, 0, 0, 5553, 5555, 3, 680, 340, 0, 5554,
		5552, 1, 0, 0, 0, 5555, 5558, 1, 0, 0, 0, 5556, 5554, 1, 0, 0, 0, 5556,
		5557, 1, 0, 0, 0, 5557, 679, 1, 0, 0, 0, 5558, 5556, 1, 0, 0, 0, 5559,
		5560, 5, 64, 0, 0, 5560, 5565, 5, 396, 0, 0, 5561, 5565, 5, 66, 0, 0, 5562,
		5563, 5, 65, 0, 0, 5563, 5565, 5, 396, 0, 0, 5564, 5559, 1, 0, 0, 0, 5564,
		5561, 1, 0, 0, 0, 5564, 5562, 1, 0, 0, 0, 5565, 5568, 1, 0, 0, 0, 5566,
		5569, 3, 1026, 513, 0, 5567, 5569, 5, 117, 0, 0, 5568, 5566, 1, 0, 0, 0,
		5568, 5567, 1, 0, 0, 0, 5569, 5625, 1, 0, 0, 0, 5570, 5573, 5, 274, 0,
		0, 5571, 5574, 3, 1026, 513, 0, 5572, 5574, 5, 117, 0, 0, 5573, 5571, 1,
		0, 0, 0, 5573, 5572, 1, 0, 0, 0, 5574, 5580, 1, 0, 0, 0, 5575, 5578, 5,
		74, 0, 0, 5576, 5579, 3, 1026, 513, 0, 5577, 5579, 5, 117, 0, 0, 5578,
		5576, 1, 0, 0, 0, 5578, 5577, 1, 0, 0, 0, 5579, 5581, 1, 0, 0, 0, 5580,
		5575, 1, 0, 0, 0, 5580, 5581, 1, 0, 0, 0, 5581, 5625, 1, 0, 0, 0, 5582,
		5583, 5, 305, 0, 0, 5583, 5590, 5, 492, 0, 0, 5584, 5591, 3, 976, 488,
		0, 5585, 5586, 5, 305, 0, 0, 5586, 5587, 5, 2, 0, 0, 5587, 5588, 3, 976,
		488, 0, 5588, 5589, 5, 4, 0, 0, 5589, 5591, 1, 0, 0, 0, 5590, 5584, 1,
		0, 0, 0, 5590, 5585, 1, 0, 0, 0, 5591, 5625, 1, 0, 0, 0, 5592, 5593, 5,
		305, 0, 0, 5593, 5594, 5, 168, 0, 0, 5594, 5595, 3, 1032, 516, 0, 5595,
		5602, 5, 492, 0, 0, 5596, 5603, 3, 976, 488, 0, 5597, 5598, 5, 305, 0,
		0, 5598, 5599, 5, 2, 0, 0, 5599, 5600, 3, 976, 488, 0, 5600, 5601, 5, 4,
		0, 0, 5601, 5603, 1, 0, 0, 0, 5602, 5596, 1, 0, 0, 0, 5602, 5597, 1, 0,
		0, 0, 5603, 5625, 1, 0, 0, 0, 5604, 5605, 3, 874, 437, 0, 5605, 5606, 5,
		492, 0, 0, 5606, 5607, 3, 852, 426, 0, 5607, 5625, 1, 0, 0, 0, 5608, 5610,
		3, 968, 484, 0, 5609, 5608, 1, 0, 0, 0, 5609, 5610, 1, 0, 0, 0, 5610, 5611,
		1, 0, 0, 0, 5611, 5612, 3, 1018, 509, 0, 5612, 5613, 5, 492, 0, 0, 5613,
		5614, 3, 690, 345, 0, 5614, 5625, 1, 0, 0, 0, 5615, 5616, 3, 876, 438,
		0, 5616, 5617, 5, 492, 0, 0, 5617, 5618, 3, 690, 345, 0, 5618, 5625, 1,
		0, 0, 0, 5619, 5621, 3, 968, 484, 0, 5620, 5619, 1, 0, 0, 0, 5620, 5621,
		1, 0, 0, 0, 5621, 5622, 1, 0, 0, 0, 5622, 5623, 5, 438, 0, 0, 5623, 5625,
		3, 682, 341, 0, 5624, 5564, 1, 0, 0, 0, 5624, 5570, 1, 0, 0, 0, 5624, 5582,
		1, 0, 0, 0, 5624, 5592, 1, 0, 0, 0, 5624, 5604, 1, 0, 0, 0, 5624, 5609,
		1, 0, 0, 0, 5624, 5615, 1, 0, 0, 0, 5624, 5620, 1, 0, 0, 0, 5625, 681,
		1, 0, 0, 0, 5626, 5637, 3, 684, 342, 0, 5627, 5637, 3, 686, 343, 0, 5628,
		5629, 3, 684, 342, 0, 5629, 5630, 5, 3, 0, 0, 5630, 5631, 3, 686, 343,
		0, 5631, 5637, 1, 0, 0, 0, 5632, 5633, 3, 686, 343, 0, 5633, 5634, 5, 3,
		0, 0, 5634, 5635, 3, 684, 342, 0, 5635, 5637, 1, 0, 0, 0, 5636, 5626, 1,
		0, 0, 0, 5636, 5627, 1, 0, 0, 0, 5636, 5628, 1, 0, 0, 0, 5636, 5632, 1,
		0, 0, 0, 5637, 683, 1, 0, 0, 0, 5638, 5639, 5, 345, 0, 0, 5639, 5643, 5,
		291, 0, 0, 5640, 5641, 5, 345, 0, 0, 5641, 5643, 5, 482, 0, 0, 5642, 5638,
		1, 0, 0, 0, 5642, 5640, 1, 0, 0, 0, 5643, 685, 1, 0, 0, 0, 5644, 5645,
		5, 223, 0, 0, 5645, 5646, 5, 239, 0, 0, 5646, 5647, 3, 688, 344, 0, 5647,
		687, 1, 0, 0, 0, 5648, 5649, 5, 345, 0, 0, 5649, 5656, 5, 449, 0, 0, 5650,
		5651, 5, 345, 0, 0, 5651, 5656, 5, 80, 0, 0, 5652, 5653, 5, 355, 0, 0,
		5653, 5656, 5, 345, 0, 0, 5654, 5656, 5, 394, 0, 0, 5655, 5648, 1, 0, 0,
		0, 5655, 5650, 1, 0, 0, 0, 5655, 5652, 1, 0, 0, 0, 5655, 5654, 1, 0, 0,
		0, 5656, 689, 1, 0, 0, 0, 5657, 5662, 5, 117, 0, 0, 5658, 5662, 5, 290,
		0, 0, 5659, 5662, 5, 18, 0, 0, 5660, 5662, 3, 852, 426, 0, 5661, 5657,
		1, 0, 0, 0, 5661, 5658, 1, 0, 0, 0, 5661, 5659, 1, 0, 0, 0, 5661, 5660,
		1, 0, 0, 0, 5662, 691, 1, 0, 0, 0, 5663, 5664, 5, 396, 0, 0, 5664, 5667,
		5, 333, 0, 0, 5665, 5666, 5, 168, 0, 0, 5666, 5668, 3, 976, 488, 0, 5667,
		5665, 1, 0, 0, 0, 5667, 5668, 1, 0, 0, 0, 5668, 5669, 1, 0, 0, 0, 5669,
		5670, 3, 960, 480, 0, 5670, 693, 1, 0, 0, 0, 5671, 5676, 3, 1026, 513,
		0, 5672, 5673, 5, 3, 0, 0, 5673, 5675, 3, 1026, 513, 0, 5674, 5672, 1,
		0, 0, 0, 5675, 5678, 1, 0, 0, 0, 5676, 5674, 1, 0, 0, 0, 5676, 5677, 1,
		0, 0, 0, 5677, 695, 1, 0, 0, 0, 5678, 5676, 1, 0, 0, 0, 5679, 5680, 5,
		14, 0, 0, 5680, 5681, 5, 147, 0, 0, 5681, 5682, 5, 290, 0, 0, 5682, 5683,
		7, 29, 0, 0, 5683, 5684, 3, 976, 488, 0, 5684, 697, 1, 0, 0, 0, 5685, 5686,
		5, 484, 0, 0, 5686, 5687, 5, 423, 0, 0, 5687, 5692, 3, 700, 350, 0, 5688,
		5689, 5, 3, 0, 0, 5689, 5691, 3, 700, 350, 0, 5690, 5688, 1, 0, 0, 0, 5691,
		5694, 1, 0, 0, 0, 5692, 5690, 1, 0, 0, 0, 5692, 5693, 1, 0, 0, 0, 5693,
		5698, 1, 0, 0, 0, 5694, 5692, 1, 0, 0, 0, 5695, 5696, 5, 485, 0, 0, 5696,
		5698, 5, 423, 0, 0, 5697, 5685, 1, 0, 0, 0, 5697, 5695, 1, 0, 0, 0, 5698,
		699, 1, 0, 0, 0, 5699, 5704, 3, 1018, 509, 0, 5700, 5702, 5, 27, 0, 0,
		5701, 5700, 1, 0, 0, 0, 5701, 5702, 1, 0, 0, 0, 5702, 5703, 1, 0, 0, 0,
		5703, 5705, 3, 1018, 509, 0, 5704, 5701, 1, 0, 0, 0, 5704, 5705, 1, 0,
		0, 0, 5705, 5706, 1, 0, 0, 0, 5706, 5707, 3, 702, 351, 0, 5707, 701, 1,
		0, 0, 0, 5708, 5710, 5, 345, 0, 0, 5709, 5711, 5, 244, 0, 0, 5710, 5709,
		1, 0, 0, 0, 5710, 5711, 1, 0, 0, 0, 5711, 5717, 1, 0, 0, 0, 5712, 5714,
		5, 486, 0, 0, 5713, 5712, 1, 0, 0, 0, 5713, 5714, 1, 0, 0, 0, 5714, 5715,
		1, 0, 0, 0, 5715, 5717, 5, 482, 0, 0, 5716, 5708, 1, 0, 0, 0, 5716, 5713,
		1, 0, 0, 0, 5717, 703, 1, 0, 0, 0, 5718, 5719, 5, 19, 0, 0, 5719, 5720,
		5, 312, 0, 0, 5720, 5721, 5, 15, 0, 0, 5721, 5722, 5, 13, 0, 0, 5722, 5723,
		3, 752, 376, 0, 5723, 705, 1, 0, 0, 0, 5724, 5725, 5, 445, 0, 0, 5725,
		5726, 5, 312, 0, 0, 5726, 5727, 5, 15, 0, 0, 5727, 707, 1, 0, 0, 0, 5728,
		5729, 5, 19, 0, 0, 5729, 5730, 5, 312, 0, 0, 5730, 5731, 5, 15, 0, 0, 5731,
		5732, 5, 132, 0, 0, 5732, 5733, 3, 976, 488, 0, 5733, 709, 1, 0, 0, 0,
		5734, 5735, 5, 401, 0, 0, 5735, 5736, 5, 312, 0, 0, 5736, 5737, 5, 15,
		0, 0, 5737, 711, 1, 0, 0, 0, 5738, 5739, 5, 90, 0, 0, 5739, 5743, 5, 473,
		0, 0, 5740, 5741, 5, 197, 0, 0, 5741, 5742, 5, 281, 0, 0, 5742, 5744, 5,
		148, 0, 0, 5743, 5740, 1, 0, 0, 0, 5743, 5744, 1, 0, 0, 0, 5744, 5745,
		1, 0, 0, 0, 5745, 5747, 3, 1026, 513, 0, 5746, 5748, 3, 970, 485, 0, 5747,
		5746, 1, 0, 0, 0, 5747, 5748, 1, 0, 0, 0, 5748, 5750, 1, 0, 0, 0, 5749,
		5751, 3, 954, 477, 0, 5750, 5749, 1, 0, 0, 0, 5750, 5751, 1, 0, 0, 0, 5751,
		713, 1, 0, 0, 0, 5752, 5753, 5, 132, 0, 0, 5753, 5756, 5, 473, 0, 0, 5754,
		5755, 5, 197, 0, 0, 5755, 5757, 5, 148, 0, 0, 5756, 5754, 1, 0, 0, 0, 5756,
		5757, 1, 0, 0, 0, 5757, 5758, 1, 0, 0, 0, 5758, 5759, 3, 1026, 513, 0,
		5759, 715, 1, 0, 0, 0, 5760, 5761, 5, 416, 0, 0, 5761, 5764, 5, 473, 0,
		0, 5762, 5763, 5, 197, 0, 0, 5763, 5765, 5, 148, 0, 0, 5764, 5762, 1, 0,
		0, 0, 5764, 5765, 1, 0, 0, 0, 5765, 5766, 1, 0, 0, 0, 5766, 5767, 3, 1018,
		509, 0, 5767, 717, 1, 0, 0, 0, 5768, 5769, 5, 364, 0, 0, 5769, 5772, 5,
		473, 0, 0, 5770, 5771, 5, 197, 0, 0, 5771, 5773, 5, 148, 0, 0, 5772, 5770,
		1, 0, 0, 0, 5772, 5773, 1, 0, 0, 0, 5773, 5774, 1, 0, 0, 0, 5774, 5775,
		3, 1018, 509, 0, 5775, 719, 1, 0, 0, 0, 5776, 5778, 5, 396, 0, 0, 5777,
		5779, 5, 395, 0, 0, 5778, 5777, 1, 0, 0, 0, 5778, 5779, 1, 0, 0, 0, 5779,
		5780, 1, 0, 0, 0, 5780, 5782, 5, 473, 0, 0, 5781, 5783, 5, 492, 0, 0, 5782,
		5781, 1, 0, 0, 0, 5782, 5783, 1, 0, 0, 0, 5783, 5784, 1, 0, 0, 0, 5784,
		5785, 3, 1026, 513, 0, 5785, 721, 1, 0, 0, 0, 5786, 5787, 5, 401, 0, 0,
		5787, 5790, 5, 474, 0, 0, 5788, 5789, 5, 240, 0, 0, 5789, 5791, 3, 976,
		488, 0, 5790, 5788, 1, 0, 0, 0, 5790, 5791, 1, 0, 0, 0, 5791, 723, 1, 0,
		0, 0, 5792, 5793, 5, 401, 0, 0, 5793, 5794, 7, 30, 0, 0, 5794, 5795, 5,
		172, 0, 0, 5795, 5796, 5, 473, 0, 0, 5796, 5797, 3, 1018, 509, 0, 5797,
		725, 1, 0, 0, 0, 5798, 5799, 5, 401, 0, 0, 5799, 5800, 5, 279, 0, 0, 5800,
		5801, 5, 172, 0, 0, 5801, 5804, 5, 474, 0, 0, 5802, 5803, 5, 240, 0, 0,
		5803, 5805, 3, 976, 488, 0, 5804, 5802, 1, 0, 0, 0, 5804, 5805, 1, 0, 0,
		0, 5805, 5816, 1, 0, 0, 0, 5806, 5807, 5, 401, 0, 0, 5807, 5808, 5, 279,
		0, 0, 5808, 5809, 5, 172, 0, 0, 5809, 5810, 5, 473, 0, 0, 5810, 5813, 3,
		1018, 509, 0, 5811, 5812, 5, 72, 0, 0, 5812, 5814, 3, 1026, 513, 0, 5813,
		5811, 1, 0, 0, 0, 5813, 5814, 1, 0, 0, 0, 5814, 5816, 1, 0, 0, 0, 5815,
		5798, 1, 0, 0, 0, 5815, 5806, 1, 0, 0, 0, 5816, 727, 1, 0, 0, 0, 5817,
		5818, 5, 19, 0, 0, 5818, 5819, 5, 473, 0, 0, 5819, 5820, 3, 1026, 513,
		0, 5820, 5821, 3, 276, 138, 0, 5821, 729, 1, 0, 0, 0, 5822, 5823, 5, 19,
		0, 0, 5823, 5824, 5, 473, 0, 0, 5824, 5825, 3, 1026, 513, 0, 5825, 5826,
		5, 13, 0, 0, 5826, 5830, 5, 72, 0, 0, 5827, 5828, 5, 197, 0, 0, 5828, 5829,
		5, 281, 0, 0, 5829, 5831, 5, 148, 0, 0, 5830, 5827, 1, 0, 0, 0, 5830, 5831,
		1, 0, 0, 0, 5831, 5832, 1, 0, 0, 0, 5832, 5834, 3, 1026, 513, 0, 5833,
		5835, 3, 970, 485, 0, 5834, 5833, 1, 0, 0, 0, 5834, 5835, 1, 0, 0, 0, 5835,
		5837, 1, 0, 0, 0, 5836, 5838, 3, 954, 477, 0, 5837, 5836, 1, 0, 0, 0, 5837,
		5838, 1, 0, 0, 0, 5838, 731, 1, 0, 0, 0, 5839, 5840, 5, 19, 0, 0, 5840,
		5841, 5, 473, 0, 0, 5841, 5842, 3, 1026, 513, 0, 5842, 5843, 5, 132, 0,
		0, 5843, 5846, 5, 72, 0, 0, 5844, 5845, 5, 197, 0, 0, 5845, 5847, 5, 148,
		0, 0, 5846, 5844, 1, 0, 0, 0, 5846, 5847, 1, 0, 0, 0, 5847, 5848, 1, 0,
		0, 0, 5848, 5850, 3, 1026, 513, 0, 5849, 5851, 5, 169, 0, 0, 5850, 5849,
		1, 0, 0, 0, 5850, 5851, 1, 0, 0, 0, 5851, 733, 1, 0, 0, 0, 5852, 5853,
		5, 19, 0, 0, 5853, 5854, 5, 473, 0, 0, 5854, 5855, 3, 1026, 513, 0, 5855,
		5856, 5, 137, 0, 0, 5856, 5857, 5, 72, 0, 0, 5857, 5858, 3, 1026, 513,
		0, 5858, 735, 1, 0, 0, 0, 5859, 5860, 5, 19, 0, 0, 5860, 5861, 5, 473,
		0, 0, 5861, 5862, 3, 1026, 513, 0, 5862, 5863, 5, 127, 0, 0, 5863, 5864,
		5, 72, 0, 0, 5864, 5865, 3, 1026, 513, 0, 5865, 737, 1, 0, 0, 0, 5866,
		5867, 5, 19, 0, 0, 5867, 5868, 5, 473, 0, 0, 5868, 5869, 3, 1026, 513,
		0, 5869, 5870, 5, 270, 0, 0, 5870, 5871, 5, 72, 0, 0, 5871, 5872, 3, 1026,
		513, 0, 5872, 5873, 3, 276, 138, 0, 5873, 739, 1, 0, 0, 0, 5874, 5875,
		5, 406, 0, 0, 5875, 5879, 5, 438, 0, 0, 5876, 5877, 5, 480, 0, 0, 5877,
		5878, 5, 86, 0, 0, 5878, 5880, 5, 403, 0, 0, 5879, 5876, 1, 0, 0, 0, 5879,
		5880, 1, 0, 0, 0, 5880, 5886, 1, 0, 0, 0, 5881, 5883, 5, 40, 0, 0, 5882,
		5884, 5, 481, 0, 0, 5883, 5882, 1, 0, 0, 0, 5883, 5884, 1, 0, 0, 0, 5884,
		5886, 1, 0, 0, 0, 5885, 5874, 1, 0, 0, 0, 5885, 5881, 1, 0, 0, 0, 5886,
		741, 1, 0, 0, 0, 5887, 5889, 5, 79, 0, 0, 5888, 5890, 5, 481, 0, 0, 5889,
		5888, 1, 0, 0, 0, 5889, 5890, 1, 0, 0, 0, 5890, 5896, 1, 0, 0, 0, 5891,
		5893, 5, 21, 0, 0, 5892, 5894, 5, 277, 0, 0, 5893, 5892, 1, 0, 0, 0, 5893,
		5894, 1, 0, 0, 0, 5894, 5895, 1, 0, 0, 0, 5895, 5897, 5, 63, 0, 0, 5896,
		5891, 1, 0, 0, 0, 5896, 5897, 1, 0, 0, 0, 5897, 5902, 1, 0, 0, 0, 5898,
		5900, 5, 277, 0, 0, 5899, 5898, 1, 0, 0, 0, 5899, 5900, 1, 0, 0, 0, 5900,
		5901, 1, 0, 0, 0, 5901, 5903, 5, 351, 0, 0, 5902, 5899, 1, 0, 0, 0, 5902,
		5903, 1, 0, 0, 0, 5903, 743, 1, 0, 0, 0, 5904, 5906, 5, 375, 0, 0, 5905,
		5907, 5, 481, 0, 0, 5906, 5905, 1, 0, 0, 0, 5906, 5907, 1, 0, 0, 0, 5907,
		5913, 1, 0, 0, 0, 5908, 5910, 5, 21, 0, 0, 5909, 5911, 5, 277, 0, 0, 5910,
		5909, 1, 0, 0, 0, 5910, 5911, 1, 0, 0, 0, 5911, 5912, 1, 0, 0, 0, 5912,
		5914, 5, 63, 0, 0, 5913, 5908, 1, 0, 0, 0, 5913, 5914, 1, 0, 0, 0, 5914,
		5919, 1, 0, 0, 0, 5915, 5917, 5, 277, 0, 0, 5916, 5915, 1, 0, 0, 0, 5916,
		5917, 1, 0, 0, 0, 5917, 5918, 1, 0, 0, 0, 5918, 5920, 5, 351, 0, 0, 5919,
		5916, 1, 0, 0, 0, 5919, 5920, 1, 0, 0, 0, 5920, 745, 1, 0, 0, 0, 5921,
		5922, 5, 439, 0, 0, 5922, 5923, 3, 748, 374, 0, 5923, 5924, 3, 750, 375,
		0, 5924, 747, 1, 0, 0, 0, 5925, 5926, 3, 1018, 509, 0, 5926, 749, 1, 0,
		0, 0, 5927, 5929, 9, 0, 0, 0, 5928, 5927, 1, 0, 0, 0, 5929, 5930, 1, 0,
		0, 0, 5930, 5928, 1, 0, 0, 0, 5930, 5931, 1, 0, 0, 0, 5931, 751, 1, 0,
		0, 0, 5932, 5935, 3, 904, 452, 0, 5933, 5935, 3, 906, 453, 0, 5934, 5932,
		1, 0, 0, 0, 5934, 5933, 1, 0, 0, 0, 5934, 5935, 1, 0, 0, 0, 5935, 5936,
		1, 0, 0, 0, 5936, 5938, 3, 754, 377, 0, 5937, 5939, 3, 972, 486, 0, 5938,
		5937, 1, 0, 0, 0, 5938, 5939, 1, 0, 0, 0, 5939, 753, 1, 0, 0, 0, 5940,
		5942, 3, 756, 378, 0, 5941, 5940, 1, 0, 0, 0, 5941, 5942, 1, 0, 0, 0, 5942,
		5943, 1, 0, 0, 0, 5943, 5944, 3, 758, 379, 0, 5944, 755, 1, 0, 0, 0, 5945,
		5946, 5, 480, 0, 0, 5946, 5951, 3, 784, 392, 0, 5947, 5948, 5, 3, 0, 0,
		5948, 5950, 3, 784, 392, 0, 5949, 5947, 1, 0, 0, 0, 5950, 5953, 1, 0, 0,
		0, 5951, 5949, 1, 0, 0, 0, 5951, 5952, 1, 0, 0, 0, 5952, 757, 1, 0, 0,
		0, 5953, 5951, 1, 0, 0, 0, 5954, 5965, 3, 764, 382, 0, 5955, 5956, 5, 298,
		0, 0, 5956, 5957, 5, 55, 0, 0, 5957, 5962, 3, 770, 385, 0, 5958, 5959,
		5, 3, 0, 0, 5959, 5961, 3, 770, 385, 0, 5960, 5958, 1, 0, 0, 0, 5961, 5964,
		1, 0, 0, 0, 5962, 5960, 1, 0, 0, 0, 5962, 5963, 1, 0, 0, 0, 5963, 5966,
		1, 0, 0, 0, 5964, 5962, 1, 0, 0, 0, 5965, 5955, 1, 0, 0, 0, 5965, 5966,
		1, 0, 0, 0, 5966, 5968, 1, 0, 0, 0, 5967, 5969, 3, 774, 387, 0, 5968, 5967,
		1, 0, 0, 0, 5968, 5969, 1, 0, 0, 0, 5969, 759, 1, 0, 0, 0, 5970, 5972,
		5, 168, 0, 0, 5971, 5970, 1, 0, 0, 0, 5971, 5972, 1, 0, 0, 0, 5972, 5973,
		1, 0, 0, 0, 5973, 5974, 3, 762, 381, 0, 5974, 5975, 5, 41, 0, 0, 5975,
		5976, 3, 852, 426, 0, 5976, 5977, 5, 21, 0, 0, 5977, 5978, 3, 852, 426,
		0, 5978, 6003, 1, 0, 0, 0, 5979, 5981, 5, 168, 0, 0, 5980, 5979, 1, 0,
		0, 0, 5980, 5981, 1, 0, 0, 0, 5981, 5982, 1, 0, 0, 0, 5982, 5983, 3, 762,
		381, 0, 5983, 5984, 5, 172, 0, 0, 5984, 5985, 3, 852, 426, 0, 5985, 5986,
		5, 440, 0, 0, 5986, 5987, 3, 852, 426, 0, 5987, 6003, 1, 0, 0, 0, 5988,
		5990, 5, 168, 0, 0, 5989, 5988, 1, 0, 0, 0, 5989, 5990, 1, 0, 0, 0, 5990,
		5991, 1, 0, 0, 0, 5991, 5992, 3, 762, 381, 0, 5992, 5993, 5, 18, 0, 0,
		5993, 6003, 1, 0, 0, 0, 5994, 5996, 5, 168, 0, 0, 5995, 5994, 1, 0, 0,
		0, 5995, 5996, 1, 0, 0, 0, 5996, 5997, 1, 0, 0, 0, 5997, 5998, 3, 762,
		381, 0, 5998, 5999, 5, 27, 0, 0, 5999, 6000, 5, 287, 0, 0, 6000, 6001,
		3, 852, 426, 0, 6001, 6003, 1, 0, 0, 0, 6002, 5971, 1, 0, 0, 0, 6002, 5980,
		1, 0, 0, 0, 6002, 5989, 1, 0, 0, 0, 6002, 5995, 1, 0, 0, 0, 6003, 761,
		1, 0, 0, 0, 6004, 6005, 7, 31, 0, 0, 6005, 763, 1, 0, 0, 0, 6006, 6007,
		6, 382, -1, 0, 6007, 6010, 3, 776, 388, 0, 6008, 6010, 3, 766, 383, 0,
		6009, 6006, 1, 0, 0, 0, 6009, 6008, 1, 0, 0, 0, 6010, 6025, 1, 0, 0, 0,
		6011, 6012, 10, 2, 0, 0, 6012, 6014, 5, 216, 0, 0, 6013, 6015, 3, 786,
		393, 0, 6014, 6013, 1, 0, 0, 0, 6014, 6015, 1, 0, 0, 0, 6015, 6016, 1,
		0, 0, 0, 6016, 6024, 3, 764, 382, 3, 6017, 6018, 10, 1, 0, 0, 6018, 6020,
		7, 32, 0, 0, 6019, 6021, 3, 786, 393, 0, 6020, 6019, 1, 0, 0, 0, 6020,
		6021, 1, 0, 0, 0, 6021, 6022, 1, 0, 0, 0, 6022, 6024, 3, 764, 382, 2, 6023,
		6011, 1, 0, 0, 0, 6023, 6017, 1, 0, 0, 0, 6024, 6027, 1, 0, 0, 0, 6025,
		6023, 1, 0, 0, 0, 6025, 6026, 1, 0, 0, 0, 6026, 765, 1, 0, 0, 0, 6027,
		6025, 1, 0, 0, 0, 6028, 6029, 5, 2, 0, 0, 6029, 6030, 3, 754, 377, 0, 6030,
		6031, 5, 4, 0, 0, 6031, 767, 1, 0, 0, 0, 6032, 6033, 5, 2, 0, 0, 6033,
		6034, 3, 854, 427, 0, 6034, 6035, 5, 4, 0, 0, 6035, 769, 1, 0, 0, 0, 6036,
		6038, 3, 852, 426, 0, 6037, 6039, 7, 33, 0, 0, 6038, 6037, 1, 0, 0, 0,
		6038, 6039, 1, 0, 0, 0, 6039, 6042, 1, 0, 0, 0, 6040, 6041, 5, 283, 0,
		0, 6041, 6043, 7, 34, 0, 0, 6042, 6040, 1, 0, 0, 0, 6042, 6043, 1, 0, 0,
		0, 6043, 771, 1, 0, 0, 0, 6044, 6048, 5, 518, 0, 0, 6045, 6048, 5, 302,
		0, 0, 6046, 6048, 3, 874, 437, 0, 6047, 6044, 1, 0, 0, 0, 6047, 6045, 1,
		0, 0, 0, 6047, 6046, 1, 0, 0, 0, 6048, 773, 1, 0, 0, 0, 6049, 6050, 5,
		241, 0, 0, 6050, 6053, 3, 772, 386, 0, 6051, 6052, 5, 289, 0, 0, 6052,
		6054, 3, 772, 386, 0, 6053, 6051, 1, 0, 0, 0, 6053, 6054, 1, 0, 0, 0, 6054,
		6061, 1, 0, 0, 0, 6055, 6056, 5, 241, 0, 0, 6056, 6057, 3, 772, 386, 0,
		6057, 6058, 5, 3, 0, 0, 6058, 6059, 3, 772, 386, 0, 6059, 6061, 1, 0, 0,
		0, 6060, 6049, 1, 0, 0, 0, 6060, 6055, 1, 0, 0, 0, 6061, 775, 1, 0, 0,
		0, 6062, 6064, 5, 391, 0, 0, 6063, 6065, 3, 786, 393, 0, 6064, 6063, 1,
		0, 0, 0, 6064, 6065, 1, 0, 0, 0, 6065, 6066, 1, 0, 0, 0, 6066, 6071, 3,
		788, 394, 0, 6067, 6068, 5, 3, 0, 0, 6068, 6070, 3, 788, 394, 0, 6069,
		6067, 1, 0, 0, 0, 6070, 6073, 1, 0, 0, 0, 6071, 6069, 1, 0, 0, 0, 6071,
		6072, 1, 0, 0, 0, 6072, 6074, 1, 0, 0, 0, 6073, 6071, 1, 0, 0, 0, 6074,
		6077, 3, 778, 389, 0, 6075, 6076, 5, 478, 0, 0, 6076, 6078, 3, 852, 426,
		0, 6077, 6075, 1, 0, 0, 0, 6077, 6078, 1, 0, 0, 0, 6078, 6082, 1, 0, 0,
		0, 6079, 6080, 5, 181, 0, 0, 6080, 6081, 5, 55, 0, 0, 6081, 6083, 3, 780,
		390, 0, 6082, 6079, 1, 0, 0, 0, 6082, 6083, 1, 0, 0, 0, 6083, 6086, 1,
		0, 0, 0, 6084, 6085, 5, 187, 0, 0, 6085, 6087, 3, 852, 426, 0, 6086, 6084,
		1, 0, 0, 0, 6086, 6087, 1, 0, 0, 0, 6087, 6093, 1, 0, 0, 0, 6088, 6089,
		5, 336, 0, 0, 6089, 6090, 3, 788, 394, 0, 6090, 6091, 3, 980, 490, 0, 6091,
		6092, 5, 518, 0, 0, 6092, 6094, 1, 0, 0, 0, 6093, 6088, 1, 0, 0, 0, 6093,
		6094, 1, 0, 0, 0, 6094, 777, 1, 0, 0, 0, 6095, 6096, 5, 172, 0, 0, 6096,
		6098, 3, 792, 396, 0, 6097, 6099, 3, 798, 399, 0, 6098, 6097, 1, 0, 0,
		0, 6098, 6099, 1, 0, 0, 0, 6099, 6101, 1, 0, 0, 0, 6100, 6095, 1, 0, 0,
		0, 6100, 6101, 1, 0, 0, 0, 6101, 6105, 1, 0, 0, 0, 6102, 6103, 5, 172,
		0, 0, 6103, 6105, 5, 133, 0, 0, 6104, 6100, 1, 0, 0, 0, 6104, 6102, 1,
		0, 0, 0, 6105, 779, 1, 0, 0, 0, 6106, 6107, 5, 376, 0, 0, 6107, 6109, 5,
		2, 0, 0, 6108, 6110, 3, 854, 427, 0, 6109, 6108, 1, 0, 0, 0, 6109, 6110,
		1, 0, 0, 0, 6110, 6111, 1, 0, 0, 0, 6111, 6133, 5, 4, 0, 0, 6112, 6113,
		5, 92, 0, 0, 6113, 6115, 5, 2, 0, 0, 6114, 6116, 3, 854, 427, 0, 6115,
		6114, 1, 0, 0, 0, 6115, 6116, 1, 0, 0, 0, 6116, 6117, 1, 0, 0, 0, 6117,
		6133, 5, 4, 0, 0, 6118, 6119, 5, 183, 0, 0, 6119, 6120, 5, 397, 0, 0, 6120,
		6121, 5, 2, 0, 0, 6121, 6126, 3, 782, 391, 0, 6122, 6123, 5, 3, 0, 0, 6123,
		6125, 3, 782, 391, 0, 6124, 6122, 1, 0, 0, 0, 6125, 6128, 1, 0, 0, 0, 6126,
		6124, 1, 0, 0, 0, 6126, 6127, 1, 0, 0, 0, 6127, 6129, 1, 0, 0, 0, 6128,
		6126, 1, 0, 0, 0, 6129, 6130, 5, 4, 0, 0, 6130, 6133, 1, 0, 0, 0, 6131,
		6133, 3, 854, 427, 0, 6132, 6106, 1, 0, 0, 0, 6132, 6112, 1, 0, 0, 0, 6132,
		6118, 1, 0, 0, 0, 6132, 6131, 1, 0, 0, 0, 6133, 781, 1, 0, 0, 0, 6134,
		6136, 5, 2, 0, 0, 6135, 6137, 3, 852, 426, 0, 6136, 6135, 1, 0, 0, 0, 6136,
		6137, 1, 0, 0, 0, 6137, 6142, 1, 0, 0, 0, 6138, 6139, 5, 3, 0, 0, 6139,
		6141, 3, 852, 426, 0, 6140, 6138, 1, 0, 0, 0, 6141, 6144, 1, 0, 0, 0, 6142,
		6140, 1, 0, 0, 0, 6142, 6143, 1, 0, 0, 0, 6143, 6145, 1, 0, 0, 0, 6144,
		6142, 1, 0, 0, 0, 6145, 6146, 5, 4, 0, 0, 6146, 783, 1, 0, 0, 0, 6147,
		6149, 3, 1018, 509, 0, 6148, 6150, 3, 824, 412, 0, 6149, 6148, 1, 0, 0,
		0, 6149, 6150, 1, 0, 0, 0, 6150, 6151, 1, 0, 0, 0, 6151, 6152, 5, 27, 0,
		0, 6152, 6153, 5, 2, 0, 0, 6153, 6154, 3, 754, 377, 0, 6154, 6155, 5, 4,
		0, 0, 6155, 785, 1, 0, 0, 0, 6156, 6157, 7, 35, 0, 0, 6157, 787, 1, 0,
		0, 0, 6158, 6166, 3, 852, 426, 0, 6159, 6161, 5, 27, 0, 0, 6160, 6159,
		1, 0, 0, 0, 6160, 6161, 1, 0, 0, 0, 6161, 6164, 1, 0, 0, 0, 6162, 6165,
		3, 1018, 509, 0, 6163, 6165, 3, 976, 488, 0, 6164, 6162, 1, 0, 0, 0, 6164,
		6163, 1, 0, 0, 0, 6165, 6167, 1, 0, 0, 0, 6166, 6160, 1, 0, 0, 0, 6166,
		6167, 1, 0, 0, 0, 6167, 6179, 1, 0, 0, 0, 6168, 6169, 3, 1012, 506, 0,
		6169, 6170, 5, 1, 0, 0, 6170, 6172, 5, 502, 0, 0, 6171, 6173, 3, 790, 395,
		0, 6172, 6171, 1, 0, 0, 0, 6172, 6173, 1, 0, 0, 0, 6173, 6179, 1, 0, 0,
		0, 6174, 6176, 5, 502, 0, 0, 6175, 6177, 3, 790, 395, 0, 6176, 6175, 1,
		0, 0, 0, 6176, 6177, 1, 0, 0, 0, 6177, 6179, 1, 0, 0, 0, 6178, 6158, 1,
		0, 0, 0, 6178, 6168, 1, 0, 0, 0, 6178, 6174, 1, 0, 0, 0, 6179, 789, 1,
		0, 0, 0, 6180, 6181, 7, 36, 0, 0, 6181, 6182, 5, 2, 0, 0, 6182, 6187, 3,
		1018, 509, 0, 6183, 6184, 5, 3, 0, 0, 6184, 6186, 3, 1018, 509, 0, 6185,
		6183, 1, 0, 0, 0, 6186, 6189, 1, 0, 0, 0, 6187, 6185, 1, 0, 0, 0, 6187,
		6188, 1, 0, 0, 0, 6188, 6190, 1, 0, 0, 0, 6189, 6187, 1, 0, 0, 0, 6190,
		6191, 5, 4, 0, 0, 6191, 791, 1, 0, 0, 0, 6192, 6200, 3, 794, 397, 0, 6193,
		6195, 5, 3, 0, 0, 6194, 6196, 5, 235, 0, 0, 6195, 6194, 1, 0, 0, 0, 6195,
		6196, 1, 0, 0, 0, 6196, 6197, 1, 0, 0, 0, 6197, 6199, 3, 794, 397, 0, 6198,
		6193, 1, 0, 0, 0, 6199, 6202, 1, 0, 0, 0, 6200, 6198, 1, 0, 0, 0, 6200,
		6201, 1, 0, 0, 0, 6201, 793, 1, 0, 0, 0, 6202, 6200, 1, 0, 0, 0, 6203,
		6207, 3, 796, 398, 0, 6204, 6206, 3, 812, 406, 0, 6205, 6204, 1, 0, 0,
		0, 6206, 6209, 1, 0, 0, 0, 6207, 6205, 1, 0, 0, 0, 6207, 6208, 1, 0, 0,
		0, 6208, 6221, 1, 0, 0, 0, 6209, 6207, 1, 0, 0, 0, 6210, 6211, 5, 2, 0,
		0, 6211, 6215, 3, 796, 398, 0, 6212, 6214, 3, 812, 406, 0, 6213, 6212,
		1, 0, 0, 0, 6214, 6217, 1, 0, 0, 0, 6215, 6213, 1, 0, 0, 0, 6215, 6216,
		1, 0, 0, 0, 6216, 6218, 1, 0, 0, 0, 6217, 6215, 1, 0, 0, 0, 6218, 6219,
		5, 4, 0, 0, 6219, 6221, 1, 0, 0, 0, 6220, 6203, 1, 0, 0, 0, 6220, 6210,
		1, 0, 0, 0, 6221, 795, 1, 0, 0, 0, 6222, 6224, 3, 1012, 506, 0, 6223, 6225,
		3, 760, 380, 0, 6224, 6223, 1, 0, 0, 0, 6224, 6225, 1, 0, 0, 0, 6225, 6227,
		1, 0, 0, 0, 6226, 6228, 3, 826, 413, 0, 6227, 6226, 1, 0, 0, 0, 6227, 6228,
		1, 0, 0, 0, 6228, 6230, 1, 0, 0, 0, 6229, 6231, 3, 830, 415, 0, 6230, 6229,
		1, 0, 0, 0, 6230, 6231, 1, 0, 0, 0, 6231, 6233, 1, 0, 0, 0, 6232, 6234,
		3, 840, 420, 0, 6233, 6232, 1, 0, 0, 0, 6233, 6234, 1, 0, 0, 0, 6234, 6236,
		1, 0, 0, 0, 6235, 6237, 3, 804, 402, 0, 6236, 6235, 1, 0, 0, 0, 6236, 6237,
		1, 0, 0, 0, 6237, 6242, 1, 0, 0, 0, 6238, 6240, 5, 27, 0, 0, 6239, 6238,
		1, 0, 0, 0, 6239, 6240, 1, 0, 0, 0, 6240, 6241, 1, 0, 0, 0, 6241, 6243,
		3, 1018, 509, 0, 6242, 6239, 1, 0, 0, 0, 6242, 6243, 1, 0, 0, 0, 6243,
		6245, 1, 0, 0, 0, 6244, 6246, 3, 818, 409, 0, 6245, 6244, 1, 0, 0, 0, 6245,
		6246, 1, 0, 0, 0, 6246, 6249, 1, 0, 0, 0, 6247, 6248, 5, 488, 0, 0, 6248,
		6250, 3, 976, 488, 0, 6249, 6247, 1, 0, 0, 0, 6249, 6250, 1, 0, 0, 0, 6250,
		6326, 1, 0, 0, 0, 6251, 6252, 5, 2, 0, 0, 6252, 6253, 5, 462, 0, 0, 6253,
		6258, 3, 768, 384, 0, 6254, 6255, 5, 3, 0, 0, 6255, 6257, 3, 768, 384,
		0, 6256, 6254, 1, 0, 0, 0, 6257, 6260, 1, 0, 0, 0, 6258, 6256, 1, 0, 0,
		0, 6258, 6259, 1, 0, 0, 0, 6259, 6261, 1, 0, 0, 0, 6260, 6258, 1, 0, 0,
		0, 6261, 6269, 5, 4, 0, 0, 6262, 6264, 5, 27, 0, 0, 6263, 6262, 1, 0, 0,
		0, 6263, 6264, 1, 0, 0, 0, 6264, 6265, 1, 0, 0, 0, 6265, 6267, 3, 1018,
		509, 0, 6266, 6268, 3, 824, 412, 0, 6267, 6266, 1, 0, 0, 0, 6267, 6268,
		1, 0, 0, 0, 6268, 6270, 1, 0, 0, 0, 6269, 6263, 1, 0, 0, 0, 6269, 6270,
		1, 0, 0, 0, 6270, 6326, 1, 0, 0, 0, 6271, 6279, 3, 766, 383, 0, 6272, 6274,
		5, 27, 0, 0, 6273, 6272, 1, 0, 0, 0, 6273, 6274, 1, 0, 0, 0, 6274, 6275,
		1, 0, 0, 0, 6275, 6277, 3, 1018, 509, 0, 6276, 6278, 3, 824, 412, 0, 6277,
		6276, 1, 0, 0, 0, 6277, 6278, 1, 0, 0, 0, 6278, 6280, 1, 0, 0, 0, 6279,
		6273, 1, 0, 0, 0, 6279, 6280, 1, 0, 0, 0, 6280, 6326, 1, 0, 0, 0, 6281,
		6282, 3, 1012, 506, 0, 6282, 6283, 5, 2, 0, 0, 6283, 6284, 3, 854, 427,
		0, 6284, 6292, 5, 4, 0, 0, 6285, 6287, 5, 27, 0, 0, 6286, 6285, 1, 0, 0,
		0, 6286, 6287, 1, 0, 0, 0, 6287, 6288, 1, 0, 0, 0, 6288, 6290, 3, 1018,
		509, 0, 6289, 6291, 3, 824, 412, 0, 6290, 6289, 1, 0, 0, 0, 6290, 6291,
		1, 0, 0, 0, 6291, 6293, 1, 0, 0, 0, 6292, 6286, 1, 0, 0, 0, 6292, 6293,
		1, 0, 0, 0, 6293, 6326, 1, 0, 0, 0, 6294, 6295, 5, 422, 0, 0, 6295, 6296,
		5, 2, 0, 0, 6296, 6297, 3, 1012, 506, 0, 6297, 6298, 5, 2, 0, 0, 6298,
		6299, 3, 806, 403, 0, 6299, 6300, 5, 4, 0, 0, 6300, 6308, 5, 4, 0, 0, 6301,
		6303, 5, 27, 0, 0, 6302, 6301, 1, 0, 0, 0, 6302, 6303, 1, 0, 0, 0, 6303,
		6304, 1, 0, 0, 0, 6304, 6306, 3, 1018, 509, 0, 6305, 6307, 3, 824, 412,
		0, 6306, 6305, 1, 0, 0, 0, 6306, 6307, 1, 0, 0, 0, 6307, 6309, 1, 0, 0,
		0, 6308, 6302, 1, 0, 0, 0, 6308, 6309, 1, 0, 0, 0, 6309, 6326, 1, 0, 0,
		0, 6310, 6311, 5, 159, 0, 0, 6311, 6319, 3, 958, 479, 0, 6312, 6314, 5,
		27, 0, 0, 6313, 6312, 1, 0, 0, 0, 6313, 6314, 1, 0, 0, 0, 6314, 6315, 1,
		0, 0, 0, 6315, 6317, 3, 1018, 509, 0, 6316, 6318, 3, 824, 412, 0, 6317,
		6316, 1, 0, 0, 0, 6317, 6318, 1, 0, 0, 0, 6318, 6320, 1, 0, 0, 0, 6319,
		6313, 1, 0, 0, 0, 6319, 6320, 1, 0, 0, 0, 6320, 6326, 1, 0, 0, 0, 6321,
		6322, 5, 2, 0, 0, 6322, 6323, 3, 792, 396, 0, 6323, 6324, 5, 4, 0, 0, 6324,
		6326, 1, 0, 0, 0, 6325, 6222, 1, 0, 0, 0, 6325, 6251, 1, 0, 0, 0, 6325,
		6271, 1, 0, 0, 0, 6325, 6281, 1, 0, 0, 0, 6325, 6294, 1, 0, 0, 0, 6325,
		6310, 1, 0, 0, 0, 6325, 6321, 1, 0, 0, 0, 6326, 797, 1, 0, 0, 0, 6327,
		6328, 5, 317, 0, 0, 6328, 6329, 5, 2, 0, 0, 6329, 6334, 3, 800, 400, 0,
		6330, 6331, 5, 3, 0, 0, 6331, 6333, 3, 800, 400, 0, 6332, 6330, 1, 0, 0,
		0, 6333, 6336, 1, 0, 0, 0, 6334, 6332, 1, 0, 0, 0, 6334, 6335, 1, 0, 0,
		0, 6335, 6337, 1, 0, 0, 0, 6336, 6334, 1, 0, 0, 0, 6337, 6340, 5, 168,
		0, 0, 6338, 6341, 3, 1018, 509, 0, 6339, 6341, 3, 1024, 512, 0, 6340, 6338,
		1, 0, 0, 0, 6340, 6339, 1, 0, 0, 0, 6341, 6342, 1, 0, 0, 0, 6342, 6343,
		5, 202, 0, 0, 6343, 6344, 5, 2, 0, 0, 6344, 6349, 3, 802, 401, 0, 6345,
		6346, 5, 3, 0, 0, 6346, 6348, 3, 802, 401, 0, 6347, 6345, 1, 0, 0, 0, 6348,
		6351, 1, 0, 0, 0, 6349, 6347, 1, 0, 0, 0, 6349, 6350, 1, 0, 0, 0, 6350,
		6352, 1, 0, 0, 0, 6351, 6349, 1, 0, 0, 0, 6352, 6353, 5, 4, 0, 0, 6353,
		6354, 5, 4, 0, 0, 6354, 799, 1, 0, 0, 0, 6355, 6363, 3, 870, 435, 0, 6356,
		6358, 5, 27, 0, 0, 6357, 6356, 1, 0, 0, 0, 6357, 6358, 1, 0, 0, 0, 6358,
		6361, 1, 0, 0, 0, 6359, 6362, 3, 1018, 509, 0, 6360, 6362, 3, 976, 488,
		0, 6361, 6359, 1, 0, 0, 0, 6361, 6360, 1, 0, 0, 0, 6362, 6364, 1, 0, 0,
		0, 6363, 6357, 1, 0, 0, 0, 6363, 6364, 1, 0, 0, 0, 6364, 801, 1, 0, 0,
		0, 6365, 6368, 3, 868, 434, 0, 6366, 6368, 3, 928, 464, 0, 6367, 6365,
		1, 0, 0, 0, 6367, 6366, 1, 0, 0, 0, 6368, 6376, 1, 0, 0, 0, 6369, 6371,
		5, 27, 0, 0, 6370, 6369, 1, 0, 0, 0, 6370, 6371, 1, 0, 0, 0, 6371, 6374,
		1, 0, 0, 0, 6372, 6375, 3, 1018, 509, 0, 6373, 6375, 3, 976, 488, 0, 6374,
		6372, 1, 0, 0, 0, 6374, 6373, 1, 0, 0, 0, 6375, 6377, 1, 0, 0, 0, 6376,
		6370, 1, 0, 0, 0, 6376, 6377, 1, 0, 0, 0, 6377, 803, 1, 0, 0, 0, 6378,
		6380, 5, 384, 0, 0, 6379, 6381, 3, 958, 479, 0, 6380, 6379, 1, 0, 0, 0,
		6380, 6381, 1, 0, 0, 0, 6381, 805, 1, 0, 0, 0, 6382, 6385, 3, 854, 427,
		0, 6383, 6385, 3, 808, 404, 0, 6384, 6382, 1, 0, 0, 0, 6384, 6383, 1, 0,
		0, 0, 6385, 807, 1, 0, 0, 0, 6386, 6391, 3, 810, 405, 0, 6387, 6388, 5,
		3, 0, 0, 6388, 6390, 3, 810, 405, 0, 6389, 6387, 1, 0, 0, 0, 6390, 6393,
		1, 0, 0, 0, 6391, 6389, 1, 0, 0, 0, 6391, 6392, 1, 0, 0, 0, 6392, 809,
		1, 0, 0, 0, 6393, 6391, 1, 0, 0, 0, 6394, 6395, 3, 1018, 509, 0, 6395,
		6396, 5, 5, 0, 0, 6396, 6397, 3, 852, 426, 0, 6397, 811, 1, 0, 0, 0, 6398,
		6400, 3, 814, 407, 0, 6399, 6401, 3, 818, 409, 0, 6400, 6399, 1, 0, 0,
		0, 6400, 6401, 1, 0, 0, 0, 6401, 6403, 1, 0, 0, 0, 6402, 6404, 5, 235,
		0, 0, 6403, 6402, 1, 0, 0, 0, 6403, 6404, 1, 0, 0, 0, 6404, 6405, 1, 0,
		0, 0, 6405, 6407, 3, 796, 398, 0, 6406, 6408, 3, 822, 411, 0, 6407, 6406,
		1, 0, 0, 0, 6407, 6408, 1, 0, 0, 0, 6408, 6420, 1, 0, 0, 0, 6409, 6411,
		3, 816, 408, 0, 6410, 6412, 3, 818, 409, 0, 6411, 6410, 1, 0, 0, 0, 6411,
		6412, 1, 0, 0, 0, 6412, 6414, 1, 0, 0, 0, 6413, 6415, 5, 235, 0, 0, 6414,
		6413, 1, 0, 0, 0, 6414, 6415, 1, 0, 0, 0, 6415, 6416, 1, 0, 0, 0, 6416,
		6417, 3, 796, 398, 0, 6417, 6418, 3, 822, 411, 0, 6418, 6420, 1, 0, 0,
		0, 6419, 6398, 1, 0, 0, 0, 6419, 6409, 1, 0, 0, 0, 6420, 813, 1, 0, 0,
		0, 6421, 6428, 5, 225, 0, 0, 6422, 6423, 5, 208, 0, 0, 6423, 6428, 5, 225,
		0, 0, 6424, 6428, 5, 91, 0, 0, 6425, 6426, 5, 91, 0, 0, 6426, 6428, 5,
		225, 0, 0, 6427, 6421, 1, 0, 0, 0, 6427, 6422, 1, 0, 0, 0, 6427, 6424,
		1, 0, 0, 0, 6427, 6425, 1, 0, 0, 0, 6428, 815, 1, 0, 0, 0, 6429, 6430,
		5, 237, 0, 0, 6430, 6457, 5, 225, 0, 0, 6431, 6432, 5, 371, 0, 0, 6432,
		6457, 5, 225, 0, 0, 6433, 6434, 5, 175, 0, 0, 6434, 6457, 5, 225, 0, 0,
		6435, 6436, 5, 237, 0, 0, 6436, 6437, 5, 299, 0, 0, 6437, 6457, 5, 225,
		0, 0, 6438, 6439, 5, 371, 0, 0, 6439, 6440, 5, 299, 0, 0, 6440, 6457, 5,
		225, 0, 0, 6441, 6442, 5, 175, 0, 0, 6442, 6443, 5, 299, 0, 0, 6443, 6457,
		5, 225, 0, 0, 6444, 6445, 5, 237, 0, 0, 6445, 6446, 5, 392, 0, 0, 6446,
		6457, 5, 225, 0, 0, 6447, 6448, 5, 371, 0, 0, 6448, 6449, 5, 392, 0, 0,
		6449, 6457, 5, 225, 0, 0, 6450, 6451, 5, 237, 0, 0, 6451, 6452, 5, 22,
		0, 0, 6452, 6457, 5, 225, 0, 0, 6453, 6454, 5, 371, 0, 0, 6454, 6455, 5,
		22, 0, 0, 6455, 6457, 5, 225, 0, 0, 6456, 6429, 1, 0, 0, 0, 6456, 6431,
		1, 0, 0, 0, 6456, 6433, 1, 0, 0, 0, 6456, 6435, 1, 0, 0, 0, 6456, 6438,
		1, 0, 0, 0, 6456, 6441, 1, 0, 0, 0, 6456, 6444, 1, 0, 0, 0, 6456, 6447,
		1, 0, 0, 0, 6456, 6450, 1, 0, 0, 0, 6456, 6453, 1, 0, 0, 0, 6457, 817,
		1, 0, 0, 0, 6458, 6459, 5, 6, 0, 0, 6459, 6464, 3, 1018, 509, 0, 6460,
		6461, 5, 3, 0, 0, 6461, 6463, 3, 1018, 509, 0, 6462, 6460, 1, 0, 0, 0,
		6463, 6466, 1, 0, 0, 0, 6464, 6462, 1, 0, 0, 0, 6464, 6465, 1, 0, 0, 0,
		6465, 6467, 1, 0, 0, 0, 6466, 6464, 1, 0, 0, 0, 6467, 6468, 5, 7, 0, 0,
		6468, 6477, 1, 0, 0, 0, 6469, 6470, 5, 6, 0, 0, 6470, 6471, 3, 1018, 509,
		0, 6471, 6472, 5, 510, 0, 0, 6472, 6473, 3, 866, 433, 0, 6473, 6474, 3,
		928, 464, 0, 6474, 6475, 5, 7, 0, 0, 6475, 6477, 1, 0, 0, 0, 6476, 6458,
		1, 0, 0, 0, 6476, 6469, 1, 0, 0, 0, 6477, 819, 1, 0, 0, 0, 6478, 6479,
		3, 1026, 513, 0, 6479, 6480, 5, 492, 0, 0, 6480, 6481, 3, 868, 434, 0,
		6481, 821, 1, 0, 0, 0, 6482, 6483, 5, 290, 0, 0, 6483, 6497, 3, 852, 426,
		0, 6484, 6485, 5, 460, 0, 0, 6485, 6486, 5, 2, 0, 0, 6486, 6491, 3, 1018,
		509, 0, 6487, 6488, 5, 3, 0, 0, 6488, 6490, 3, 1018, 509, 0, 6489, 6487,
		1, 0, 0, 0, 6490, 6493, 1, 0, 0, 0, 6491, 6489, 1, 0, 0, 0, 6491, 6492,
		1, 0, 0, 0, 6492, 6494, 1, 0, 0, 0, 6493, 6491, 1, 0, 0, 0, 6494, 6495,
		5, 4, 0, 0, 6495, 6497, 1, 0, 0, 0, 6496, 6482, 1, 0, 0, 0, 6496, 6484,
		1, 0, 0, 0, 6497, 823, 1, 0, 0, 0, 6498, 6499, 5, 2, 0, 0, 6499, 6504,
		3, 1018, 509, 0, 6500, 6501, 5, 3, 0, 0, 6501, 6503, 3, 1018, 509, 0, 6502,
		6500, 1, 0, 0, 0, 6503, 6506, 1, 0, 0, 0, 6504, 6502, 1, 0, 0, 0, 6504,
		6505, 1, 0, 0, 0, 6505, 6507, 1, 0, 0, 0, 6506, 6504, 1, 0, 0, 0, 6507,
		6508, 5, 4, 0, 0, 6508, 825, 1, 0, 0, 0, 6509, 6511, 5, 428, 0, 0, 6510,
		6509, 1, 0, 0, 0, 6510, 6511, 1, 0, 0, 0, 6511, 6512, 1, 0, 0, 0, 6512,
		6513, 7, 37, 0, 0, 6513, 6514, 5, 2, 0, 0, 6514, 6519, 3, 1026, 513, 0,
		6515, 6516, 5, 3, 0, 0, 6516, 6518, 3, 1026, 513, 0, 6517, 6515, 1, 0,
		0, 0, 6518, 6521, 1, 0, 0, 0, 6519, 6517, 1, 0, 0, 0, 6519, 6520, 1, 0,
		0, 0, 6520, 6522, 1, 0, 0, 0, 6521, 6519, 1, 0, 0, 0, 6522, 6523, 5, 4,
		0, 0, 6523, 6531, 1, 0, 0, 0, 6524, 6526, 5, 428, 0, 0, 6525, 6524, 1,
		0, 0, 0, 6525, 6526, 1, 0, 0, 0, 6526, 6527, 1, 0, 0, 0, 6527, 6528, 7,
		37, 0, 0, 6528, 6531, 3, 1026, 513, 0, 6529, 6531, 3, 828, 414, 0, 6530,
		6510, 1, 0, 0, 0, 6530, 6525, 1, 0, 0, 0, 6530, 6529, 1, 0, 0, 0, 6531,
		827, 1, 0, 0, 0, 6532, 6533, 5, 303, 0, 0, 6533, 6534, 5, 2, 0, 0, 6534,
		6539, 3, 942, 471, 0, 6535, 6536, 5, 3, 0, 0, 6536, 6538, 3, 942, 471,
		0, 6537, 6535, 1, 0, 0, 0, 6538, 6541, 1, 0, 0, 0, 6539, 6537, 1, 0, 0,
		0, 6539, 6540, 1, 0, 0, 0, 6540, 6542, 1, 0, 0, 0, 6541, 6539, 1, 0, 0,
		0, 6542, 6543, 5, 4, 0, 0, 6543, 829, 1, 0, 0, 0, 6544, 6545, 5, 424, 0,
		0, 6545, 6546, 5, 2, 0, 0, 6546, 6551, 5, 518, 0, 0, 6547, 6548, 5, 3,
		0, 0, 6548, 6550, 5, 518, 0, 0, 6549, 6547, 1, 0, 0, 0, 6550, 6553, 1,
		0, 0, 0, 6551, 6549, 1, 0, 0, 0, 6551, 6552, 1, 0, 0, 0, 6552, 6554, 1,
		0, 0, 0, 6553, 6551, 1, 0, 0, 0, 6554, 6555, 5, 4, 0, 0, 6555, 831, 1,
		0, 0, 0, 6556, 6557, 5, 322, 0, 0, 6557, 6558, 3, 1018, 509, 0, 6558, 6559,
		5, 172, 0, 0, 6559, 6560, 3, 834, 417, 0, 6560, 833, 1, 0, 0, 0, 6561,
		6564, 3, 6, 3, 0, 6562, 6564, 5, 521, 0, 0, 6563, 6561, 1, 0, 0, 0, 6563,
		6562, 1, 0, 0, 0, 6564, 835, 1, 0, 0, 0, 6565, 6566, 5, 147, 0, 0, 6566,
		6578, 3, 1018, 509, 0, 6567, 6568, 5, 460, 0, 0, 6568, 6569, 5, 517, 0,
		0, 6569, 6575, 3, 1026, 513, 0, 6570, 6571, 5, 3, 0, 0, 6571, 6572, 5,
		517, 0, 0, 6572, 6574, 3, 1026, 513, 0, 6573, 6570, 1, 0, 0, 0, 6574, 6577,
		1, 0, 0, 0, 6575, 6573, 1, 0, 0, 0, 6575, 6576, 1, 0, 0, 0, 6576, 6579,
		1, 0, 0, 0, 6577, 6575, 1, 0, 0, 0, 6578, 6567, 1, 0, 0, 0, 6578, 6579,
		1, 0, 0, 0, 6579, 837, 1, 0, 0, 0, 6580, 6581, 7, 38, 0, 0, 6581, 6582,
		5, 322, 0, 0, 6582, 6583, 3, 1018, 509, 0, 6583, 839, 1, 0, 0, 0, 6584,
		6585, 5, 358, 0, 0, 6585, 6586, 5, 2, 0, 0, 6586, 6591, 5, 518, 0, 0, 6587,
		6588, 5, 3, 0, 0, 6588, 6590, 5, 518, 0, 0, 6589, 6587, 1, 0, 0, 0, 6590,
		6593, 1, 0, 0, 0, 6591, 6589, 1, 0, 0, 0, 6591, 6592, 1, 0, 0, 0, 6592,
		6594, 1, 0, 0, 0, 6593, 6591, 1, 0, 0, 0, 6594, 6595, 5, 4, 0, 0, 6595,
		841, 1, 0, 0, 0, 6596, 6597, 5, 2, 0, 0, 6597, 6602, 3, 844, 422, 0, 6598,
		6599, 5, 3, 0, 0, 6599, 6601, 3, 844, 422, 0, 6600, 6598, 1, 0, 0, 0, 6601,
		6604, 1, 0, 0, 0, 6602, 6600, 1, 0, 0, 0, 6602, 6603, 1, 0, 0, 0, 6603,
		6605, 1, 0, 0, 0, 6604, 6602, 1, 0, 0, 0, 6605, 6606, 5, 4, 0, 0, 6606,
		843, 1, 0, 0, 0, 6607, 6610, 3, 852, 426, 0, 6608, 6610, 5, 117, 0, 0,
		6609, 6607, 1, 0, 0, 0, 6609, 6608, 1, 0, 0, 0, 6610, 845, 1, 0, 0, 0,
		6611, 6616, 3, 848, 424, 0, 6612, 6613, 5, 3, 0, 0, 6613, 6615, 3, 848,
		424, 0, 6614, 6612, 1, 0, 0, 0, 6615, 6618, 1, 0, 0, 0, 6616, 6614, 1,
		0, 0, 0, 6616, 6617, 1, 0, 0, 0, 6617, 847, 1, 0, 0, 0, 6618, 6616, 1,
		0, 0, 0, 6619, 6620, 3, 852, 426, 0, 6620, 6621, 5, 8, 0, 0, 6621, 6622,
		3, 852, 426, 0, 6622, 849, 1, 0, 0, 0, 6623, 6624, 3, 852, 426, 0, 6624,
		6625, 5, 0, 0, 1, 6625, 851, 1, 0, 0, 0, 6626, 6628, 6, 426, -1, 0, 6627,
		6629, 5, 43, 0, 0, 6628, 6627, 1, 0, 0, 0, 6628, 6629, 1, 0, 0, 0, 6629,
		6630, 1, 0, 0, 0, 6630, 6634, 3, 856, 428, 0, 6631, 6632, 5, 281, 0, 0,
		6632, 6634, 3, 852, 426, 3, 6633, 6626, 1, 0, 0, 0, 6633, 6631, 1, 0, 0,
		0, 6634, 6643, 1, 0, 0, 0, 6635, 6636, 10, 2, 0, 0, 6636, 6637, 7, 39,
		0, 0, 6637, 6642, 3, 852, 426, 3, 6638, 6639, 10, 1, 0, 0, 6639, 6640,
		7, 40, 0, 0, 6640, 6642, 3, 852, 426, 2, 6641, 6635, 1, 0, 0, 0, 6641,
		6638, 1, 0, 0, 0, 6642, 6645, 1, 0, 0, 0, 6643, 6641, 1, 0, 0, 0, 6643,
		6644, 1, 0, 0, 0, 6644, 853, 1, 0, 0, 0, 6645, 6643, 1, 0, 0, 0, 6646,
		6651, 3, 852, 426, 0, 6647, 6648, 5, 3, 0, 0, 6648, 6650, 3, 852, 426,
		0, 6649, 6647, 1, 0, 0, 0, 6650, 6653, 1, 0, 0, 0, 6651, 6649, 1, 0, 0,
		0, 6651, 6652, 1, 0, 0, 0, 6652, 855, 1, 0, 0, 0, 6653, 6651, 1, 0, 0,
		0, 6654, 6655, 6, 428, -1, 0, 6655, 6656, 3, 858, 429, 0, 6656, 6675, 1,
		0, 0, 0, 6657, 6658, 10, 3, 0, 0, 6658, 6660, 5, 222, 0, 0, 6659, 6661,
		5, 281, 0, 0, 6660, 6659, 1, 0, 0, 0, 6660, 6661, 1, 0, 0, 0, 6661, 6662,
		1, 0, 0, 0, 6662, 6674, 5, 282, 0, 0, 6663, 6664, 10, 2, 0, 0, 6664, 6665,
		3, 980, 490, 0, 6665, 6666, 3, 858, 429, 0, 6666, 6674, 1, 0, 0, 0, 6667,
		6668, 10, 1, 0, 0, 6668, 6669, 3, 980, 490, 0, 6669, 6670, 5, 2, 0, 0,
		6670, 6671, 3, 754, 377, 0, 6671, 6672, 5, 4, 0, 0, 6672, 6674, 1, 0, 0,
		0, 6673, 6657, 1, 0, 0, 0, 6673, 6663, 1, 0, 0, 0, 6673, 6667, 1, 0, 0,
		0, 6674, 6677, 1, 0, 0, 0, 6675, 6673, 1, 0, 0, 0, 6675, 6676, 1, 0, 0,
		0, 6676, 857, 1, 0, 0, 0, 6677, 6675, 1, 0, 0, 0, 6678, 6680, 3, 864, 432,
		0, 6679, 6681, 3, 862, 431, 0, 6680, 6679, 1, 0, 0, 0, 6680, 6681, 1, 0,
		0, 0, 6681, 6684, 1, 0, 0, 0, 6682, 6684, 3, 860, 430, 0, 6683, 6678, 1,
		0, 0, 0, 6683, 6682, 1, 0, 0, 0, 6684, 859, 1, 0, 0, 0, 6685, 6686, 5,
		2, 0, 0, 6686, 6689, 3, 852, 426, 0, 6687, 6688, 5, 3, 0, 0, 6688, 6690,
		3, 852, 426, 0, 6689, 6687, 1, 0, 0, 0, 6690, 6691, 1, 0, 0, 0, 6691, 6689,
		1, 0, 0, 0, 6691, 6692, 1, 0, 0, 0, 6692, 6693, 1, 0, 0, 0, 6693, 6695,
		5, 4, 0, 0, 6694, 6696, 5, 281, 0, 0, 6695, 6694, 1, 0, 0, 0, 6695, 6696,
		1, 0, 0, 0, 6696, 6697, 1, 0, 0, 0, 6697, 6698, 5, 202, 0, 0, 6698, 6699,
		5, 2, 0, 0, 6699, 6700, 3, 754, 377, 0, 6700, 6701, 5, 4, 0, 0, 6701, 861,
		1, 0, 0, 0, 6702, 6704, 5, 281, 0, 0, 6703, 6702, 1, 0, 0, 0, 6703, 6704,
		1, 0, 0, 0, 6704, 6705, 1, 0, 0, 0, 6705, 6706, 5, 202, 0, 0, 6706, 6707,
		5, 2, 0, 0, 6707, 6708, 3, 754, 377, 0, 6708, 6709, 5, 4, 0, 0, 6709, 6732,
		1, 0, 0, 0, 6710, 6712, 5, 281, 0, 0, 6711, 6710, 1, 0, 0, 0, 6711, 6712,
		1, 0, 0, 0, 6712, 6713, 1, 0, 0, 0, 6713, 6714, 5, 202, 0, 0, 6714, 6715,
		5, 2, 0, 0, 6715, 6716, 3, 854, 427, 0, 6716, 6717, 5, 4, 0, 0, 6717, 6732,
		1, 0, 0, 0, 6718, 6720, 5, 281, 0, 0, 6719, 6718, 1, 0, 0, 0, 6719, 6720,
		1, 0, 0, 0, 6720, 6721, 1, 0, 0, 0, 6721, 6722, 5, 41, 0, 0, 6722, 6723,
		3, 864, 432, 0, 6723, 6724, 5, 21, 0, 0, 6724, 6725, 3, 858, 429, 0, 6725,
		6732, 1, 0, 0, 0, 6726, 6728, 5, 281, 0, 0, 6727, 6726, 1, 0, 0, 0, 6727,
		6728, 1, 0, 0, 0, 6728, 6729, 1, 0, 0, 0, 6729, 6730, 7, 41, 0, 0, 6730,
		6732, 3, 864, 432, 0, 6731, 6703, 1, 0, 0, 0, 6731, 6711, 1, 0, 0, 0, 6731,
		6719, 1, 0, 0, 0, 6731, 6727, 1, 0, 0, 0, 6732, 863, 1, 0, 0, 0, 6733,
		6734, 6, 432, -1, 0, 6734, 6735, 3, 866, 433, 0, 6735, 6762, 1, 0, 0, 0,
		6736, 6737, 10, 8, 0, 0, 6737, 6738, 5, 511, 0, 0, 6738, 6761, 3, 864,
		432, 9, 6739, 6740, 10, 7, 0, 0, 6740, 6741, 7, 42, 0, 0, 6741, 6761, 3,
		864, 432, 8, 6742, 6743, 10, 6, 0, 0, 6743, 6744, 7, 43, 0, 0, 6744, 6761,
		3, 864, 432, 7, 6745, 6746, 10, 5, 0, 0, 6746, 6747, 5, 509, 0, 0, 6747,
		6761, 3, 864, 432, 6, 6748, 6749, 10, 4, 0, 0, 6749, 6750, 5, 510, 0, 0,
		6750, 6761, 3, 864, 432, 5, 6751, 6752, 10, 3, 0, 0, 6752, 6753, 5, 513,
		0, 0, 6753, 6761, 3, 864, 432, 4, 6754, 6755, 10, 2, 0, 0, 6755, 6756,
		5, 514, 0, 0, 6756, 6761, 3, 864, 432, 3, 6757, 6758, 10, 1, 0, 0, 6758,
		6759, 5, 515, 0, 0, 6759, 6761, 3, 864, 432, 2, 6760, 6736, 1, 0, 0, 0,
		6760, 6739, 1, 0, 0, 0, 6760, 6742, 1, 0, 0, 0, 6760, 6745, 1, 0, 0, 0,
		6760, 6748, 1, 0, 0, 0, 6760, 6751, 1, 0, 0, 0, 6760, 6754, 1, 0, 0, 0,
		6760, 6757, 1, 0, 0, 0, 6761, 6764, 1, 0, 0, 0, 6762, 6760, 1, 0, 0, 0,
		6762, 6763, 1, 0, 0, 0, 6763, 865, 1, 0, 0, 0, 6764, 6762, 1, 0, 0, 0,
		6765, 6766, 6, 433, -1, 0, 6766, 6871, 3, 874, 437, 0, 6767, 6871, 3, 876,
		438, 0, 6768, 6769, 5, 123, 0, 0, 6769, 6770, 5, 2, 0, 0, 6770, 6771, 3,
		854, 427, 0, 6771, 6772, 5, 4, 0, 0, 6772, 6871, 1, 0, 0, 0, 6773, 6871,
		3, 870, 435, 0, 6774, 6775, 5, 9, 0, 0, 6775, 6776, 5, 165, 0, 0, 6776,
		6777, 3, 870, 435, 0, 6777, 6778, 5, 10, 0, 0, 6778, 6871, 1, 0, 0, 0,
		6779, 6871, 3, 868, 434, 0, 6780, 6871, 3, 878, 439, 0, 6781, 6782, 7,
		44, 0, 0, 6782, 6871, 3, 866, 433, 18, 6783, 6784, 5, 507, 0, 0, 6784,
		6871, 3, 866, 433, 17, 6785, 6786, 5, 2, 0, 0, 6786, 6787, 3, 852, 426,
		0, 6787, 6788, 5, 4, 0, 0, 6788, 6871, 1, 0, 0, 0, 6789, 6790, 5, 148,
		0, 0, 6790, 6791, 5, 2, 0, 0, 6791, 6792, 3, 754, 377, 0, 6792, 6793, 5,
		4, 0, 0, 6793, 6871, 1, 0, 0, 0, 6794, 6871, 3, 766, 383, 0, 6795, 6796,
		5, 59, 0, 0, 6796, 6797, 5, 2, 0, 0, 6797, 6798, 3, 852, 426, 0, 6798,
		6799, 5, 27, 0, 0, 6799, 6800, 3, 994, 497, 0, 6800, 6801, 5, 4, 0, 0,
		6801, 6871, 1, 0, 0, 0, 6802, 6803, 5, 87, 0, 0, 6803, 6804, 5, 2, 0, 0,
		6804, 6805, 3, 852, 426, 0, 6805, 6806, 5, 3, 0, 0, 6806, 6807, 3, 994,
		497, 0, 6807, 6808, 5, 4, 0, 0, 6808, 6871, 1, 0, 0, 0, 6809, 6810, 5,
		58, 0, 0, 6810, 6812, 3, 852, 426, 0, 6811, 6813, 3, 888, 444, 0, 6812,
		6811, 1, 0, 0, 0, 6813, 6814, 1, 0, 0, 0, 6814, 6812, 1, 0, 0, 0, 6814,
		6815, 1, 0, 0, 0, 6815, 6818, 1, 0, 0, 0, 6816, 6817, 5, 136, 0, 0, 6817,
		6819, 3, 852, 426, 0, 6818, 6816, 1, 0, 0, 0, 6818, 6819, 1, 0, 0, 0, 6819,
		6820, 1, 0, 0, 0, 6820, 6821, 5, 139, 0, 0, 6821, 6871, 1, 0, 0, 0, 6822,
		6824, 5, 58, 0, 0, 6823, 6825, 3, 888, 444, 0, 6824, 6823, 1, 0, 0, 0,
		6825, 6826, 1, 0, 0, 0, 6826, 6824, 1, 0, 0, 0, 6826, 6827, 1, 0, 0, 0,
		6827, 6830, 1, 0, 0, 0, 6828, 6829, 5, 136, 0, 0, 6829, 6831, 3, 852, 426,
		0, 6830, 6828, 1, 0, 0, 0, 6830, 6831, 1, 0, 0, 0, 6831, 6832, 1, 0, 0,
		0, 6832, 6833, 5, 139, 0, 0, 6833, 6871, 1, 0, 0, 0, 6834, 6836, 3, 996,
		498, 0, 6835, 6834, 1, 0, 0, 0, 6835, 6836, 1, 0, 0, 0, 6836, 6837, 1,
		0, 0, 0, 6837, 6839, 5, 6, 0, 0, 6838, 6840, 3, 854, 427, 0, 6839, 6838,
		1, 0, 0, 0, 6839, 6840, 1, 0, 0, 0, 6840, 6841, 1, 0, 0, 0, 6841, 6871,
		5, 7, 0, 0, 6842, 6843, 3, 998, 499, 0, 6843, 6845, 5, 9, 0, 0, 6844, 6846,
		3, 846, 423, 0, 6845, 6844, 1, 0, 0, 0, 6845, 6846, 1, 0, 0, 0, 6846, 6847,
		1, 0, 0, 0, 6847, 6848, 5, 10, 0, 0, 6848, 6871, 1, 0, 0, 0, 6849, 6850,
		5, 252, 0, 0, 6850, 6852, 5, 9, 0, 0, 6851, 6853, 3, 846, 423, 0, 6852,
		6851, 1, 0, 0, 0, 6852, 6853, 1, 0, 0, 0, 6853, 6854, 1, 0, 0, 0, 6854,
		6871, 5, 10, 0, 0, 6855, 6858, 3, 1018, 509, 0, 6856, 6858, 3, 1024, 512,
		0, 6857, 6855, 1, 0, 0, 0, 6857, 6856, 1, 0, 0, 0, 6858, 6859, 1, 0, 0,
		0, 6859, 6860, 5, 516, 0, 0, 6860, 6861, 3, 852, 426, 0, 6861, 6871, 1,
		0, 0, 0, 6862, 6863, 3, 1024, 512, 0, 6863, 6864, 5, 516, 0, 0, 6864, 6866,
		5, 2, 0, 0, 6865, 6867, 3, 854, 427, 0, 6866, 6865, 1, 0, 0, 0, 6866, 6867,
		1, 0, 0, 0, 6867, 6868, 1, 0, 0, 0, 6868, 6869, 5, 4, 0, 0, 6869, 6871,
		1, 0, 0, 0, 6870, 6765, 1, 0, 0, 0, 6870, 6767, 1, 0, 0, 0, 6870, 6768,
		1, 0, 0, 0, 6870, 6773, 1, 0, 0, 0, 6870, 6774, 1, 0, 0, 0, 6870, 6779,
		1, 0, 0, 0, 6870, 6780, 1, 0, 0, 0, 6870, 6781, 1, 0, 0, 0, 6870, 6783,
		1, 0, 0, 0, 6870, 6785, 1, 0, 0, 0, 6870, 6789, 1, 0, 0, 0, 6870, 6794,
		1, 0, 0, 0, 6870, 6795, 1, 0, 0, 0, 6870, 6802, 1, 0, 0, 0, 6870, 6809,
		1, 0, 0, 0, 6870, 6822, 1, 0, 0, 0, 6870, 6835, 1, 0, 0, 0, 6870, 6842,
		1, 0, 0, 0, 6870, 6849, 1, 0, 0, 0, 6870, 6857, 1, 0, 0, 0, 6870, 6862,
		1, 0, 0, 0, 6871, 6913, 1, 0, 0, 0, 6872, 6873, 10, 19, 0, 0, 6873, 6874,
		5, 536, 0, 0, 6874, 6912, 3, 866, 433, 20, 6875, 6877, 10, 1, 0, 0, 6876,
		6878, 5, 281, 0, 0, 6877, 6876, 1, 0, 0, 0, 6877, 6878, 1, 0, 0, 0, 6878,
		6879, 1, 0, 0, 0, 6879, 6880, 5, 256, 0, 0, 6880, 6912, 3, 866, 433, 2,
		6881, 6882, 10, 23, 0, 0, 6882, 6885, 5, 74, 0, 0, 6883, 6886, 3, 1018,
		509, 0, 6884, 6886, 3, 976, 488, 0, 6885, 6883, 1, 0, 0, 0, 6885, 6884,
		1, 0, 0, 0, 6886, 6912, 1, 0, 0, 0, 6887, 6891, 10, 20, 0, 0, 6888, 6892,
		5, 528, 0, 0, 6889, 6890, 5, 1, 0, 0, 6890, 6892, 3, 1018, 509, 0, 6891,
		6888, 1, 0, 0, 0, 6891, 6889, 1, 0, 0, 0, 6892, 6912, 1, 0, 0, 0, 6893,
		6894, 10, 6, 0, 0, 6894, 6895, 5, 6, 0, 0, 6895, 6896, 3, 864, 432, 0,
		6896, 6897, 5, 7, 0, 0, 6897, 6912, 1, 0, 0, 0, 6898, 6899, 10, 5, 0, 0,
		6899, 6901, 5, 6, 0, 0, 6900, 6902, 5, 518, 0, 0, 6901, 6900, 1, 0, 0,
		0, 6901, 6902, 1, 0, 0, 0, 6902, 6903, 1, 0, 0, 0, 6903, 6905, 5, 8, 0,
		0, 6904, 6906, 5, 518, 0, 0, 6905, 6904, 1, 0, 0, 0, 6905, 6906, 1, 0,
		0, 0, 6906, 6907, 1, 0, 0, 0, 6907, 6912, 5, 7, 0, 0, 6908, 6909, 10, 4,
		0, 0, 6909, 6910, 5, 516, 0, 0, 6910, 6912, 3, 976, 488, 0, 6911, 6872,
		1, 0, 0, 0, 6911, 6875, 1, 0, 0, 0, 6911, 6881, 1, 0, 0, 0, 6911, 6887,
		1, 0, 0, 0, 6911, 6893, 1, 0, 0, 0, 6911, 6898, 1, 0, 0, 0, 6911, 6908,
		1, 0, 0, 0, 6912, 6915, 1, 0, 0, 0, 6913, 6911, 1, 0, 0, 0, 6913, 6914,
		1, 0, 0, 0, 6914, 867, 1, 0, 0, 0, 6915, 6913, 1, 0, 0, 0, 6916, 6927,
		5, 282, 0, 0, 6917, 6927, 3, 982, 491, 0, 6918, 6927, 3, 1038, 519, 0,
		6919, 6920, 7, 45, 0, 0, 6920, 6927, 3, 976, 488, 0, 6921, 6927, 3, 976,
		488, 0, 6922, 6927, 3, 984, 492, 0, 6923, 6927, 3, 992, 496, 0, 6924, 6927,
		3, 978, 489, 0, 6925, 6927, 5, 302, 0, 0, 6926, 6916, 1, 0, 0, 0, 6926,
		6917, 1, 0, 0, 0, 6926, 6918, 1, 0, 0, 0, 6926, 6919, 1, 0, 0, 0, 6926,
		6921, 1, 0, 0, 0, 6926, 6922, 1, 0, 0, 0, 6926, 6923, 1, 0, 0, 0, 6926,
		6924, 1, 0, 0, 0, 6926, 6925, 1, 0, 0, 0, 6927, 869, 1, 0, 0, 0, 6928,
		6929, 5, 152, 0, 0, 6929, 6930, 5, 2, 0, 0, 6930, 6931, 3, 1018, 509, 0,
		6931, 6932, 5, 172, 0, 0, 6932, 6933, 3, 864, 432, 0, 6933, 6934, 5, 4,
		0, 0, 6934, 7001, 1, 0, 0, 0, 6935, 6936, 5, 183, 0, 0, 6936, 6945, 5,
		2, 0, 0, 6937, 6942, 3, 852, 426, 0, 6938, 6939, 5, 3, 0, 0, 6939, 6941,
		3, 852, 426, 0, 6940, 6938, 1, 0, 0, 0, 6941, 6944, 1, 0, 0, 0, 6942, 6940,
		1, 0, 0, 0, 6942, 6943, 1, 0, 0, 0, 6943, 6946, 1, 0, 0, 0, 6944, 6942,
		1, 0, 0, 0, 6945, 6937, 1, 0, 0, 0, 6945, 6946, 1, 0, 0, 0, 6946, 6947,
		1, 0, 0, 0, 6947, 7001, 5, 4, 0, 0, 6948, 6949, 5, 184, 0, 0, 6949, 6958,
		5, 2, 0, 0, 6950, 6955, 3, 852, 426, 0, 6951, 6952, 5, 3, 0, 0, 6952, 6954,
		3, 852, 426, 0, 6953, 6951, 1, 0, 0, 0, 6954, 6957, 1, 0, 0, 0, 6955, 6953,
		1, 0, 0, 0, 6955, 6956, 1, 0, 0, 0, 6956, 6959, 1, 0, 0, 0, 6957, 6955,
		1, 0, 0, 0, 6958, 6950, 1, 0, 0, 0, 6958, 6959, 1, 0, 0, 0, 6959, 6960,
		1, 0, 0, 0, 6960, 7001, 5, 4, 0, 0, 6961, 7001, 3, 880, 440, 0, 6962, 7001,
		3, 882, 441, 0, 6963, 7001, 3, 884, 442, 0, 6964, 6966, 3, 872, 436, 0,
		6965, 6967, 3, 890, 445, 0, 6966, 6965, 1, 0, 0, 0, 6966, 6967, 1, 0, 0,
		0, 6967, 7001, 1, 0, 0, 0, 6968, 6969, 3, 886, 443, 0, 6969, 6970, 3, 890,
		445, 0, 6970, 7001, 1, 0, 0, 0, 6971, 6972, 5, 439, 0, 0, 6972, 6981, 5,
		2, 0, 0, 6973, 6978, 3, 852, 426, 0, 6974, 6975, 5, 3, 0, 0, 6975, 6977,
		3, 852, 426, 0, 6976, 6974, 1, 0, 0, 0, 6977, 6980, 1, 0, 0, 0, 6978, 6976,
		1, 0, 0, 0, 6978, 6979, 1, 0, 0, 0, 6979, 6982, 1, 0, 0, 0, 6980, 6978,
		1, 0, 0, 0, 6981, 6973, 1, 0, 0, 0, 6981, 6982, 1, 0, 0, 0, 6982, 6983,
		1, 0, 0, 0, 6983, 7001, 5, 4, 0, 0, 6984, 6985, 3, 1012, 506, 0, 6985,
		6994, 5, 2, 0, 0, 6986, 6991, 3, 852, 426, 0, 6987, 6988, 5, 3, 0, 0, 6988,
		6990, 3, 852, 426, 0, 6989, 6987, 1, 0, 0, 0, 6990, 6993, 1, 0, 0, 0, 6991,
		6989, 1, 0, 0, 0, 6991, 6992, 1, 0, 0, 0, 6992, 6995, 1, 0, 0, 0, 6993,
		6991, 1, 0, 0, 0, 6994, 6986, 1, 0, 0, 0, 6994, 6995, 1, 0, 0, 0, 6995,
		6996, 1, 0, 0, 0, 6996, 6998, 5, 4, 0, 0, 6997, 6999, 3, 890, 445, 0, 6998,
		6997, 1, 0, 0, 0, 6998, 6999, 1, 0, 0, 0, 6999, 7001, 1, 0, 0, 0, 7000,
		6928, 1, 0, 0, 0, 7000, 6935, 1, 0, 0, 0, 7000, 6948, 1, 0, 0, 0, 7000,
		6961, 1, 0, 0, 0, 7000, 6962, 1, 0, 0, 0, 7000, 6963, 1, 0, 0, 0, 7000,
		6964, 1, 0, 0, 0, 7000, 6968, 1, 0, 0, 0, 7000, 6971, 1, 0, 0, 0, 7000,
		6984, 1, 0, 0, 0, 7001, 871, 1, 0, 0, 0, 7002, 7003, 5, 34, 0, 0, 7003,
		7005, 5, 2, 0, 0, 7004, 7006, 3, 786, 393, 0, 7005, 7004, 1, 0, 0, 0, 7005,
		7006, 1, 0, 0, 0, 7006, 7007, 1, 0, 0, 0, 7007, 7008, 3, 852, 426, 0, 7008,
		7009, 5, 4, 0, 0, 7009, 7128, 1, 0, 0, 0, 7010, 7011, 5, 89, 0, 0, 7011,
		7013, 5, 2, 0, 0, 7012, 7014, 5, 502, 0, 0, 7013, 7012, 1, 0, 0, 0, 7013,
		7014, 1, 0, 0, 0, 7014, 7015, 1, 0, 0, 0, 7015, 7128, 5, 4, 0, 0, 7016,
		7017, 5, 89, 0, 0, 7017, 7022, 5, 2, 0, 0, 7018, 7020, 3, 786, 393, 0,
		7019, 7021, 3, 818, 409, 0, 7020, 7019, 1, 0, 0, 0, 7020, 7021, 1, 0, 0,
		0, 7021, 7023, 1, 0, 0, 0, 7022, 7018, 1, 0, 0, 0, 7022, 7023, 1, 0, 0,
		0, 7023, 7032, 1, 0, 0, 0, 7024, 7029, 3, 852, 426, 0, 7025, 7026, 5, 3,
		0, 0, 7026, 7028, 3, 852, 426, 0, 7027, 7025, 1, 0, 0, 0, 7028, 7031, 1,
		0, 0, 0, 7029, 7027, 1, 0, 0, 0, 7029, 7030, 1, 0, 0, 0, 7030, 7033, 1,
		0, 0, 0, 7031, 7029, 1, 0, 0, 0, 7032, 7024, 1, 0, 0, 0, 7032, 7033, 1,
		0, 0, 0, 7033, 7034, 1, 0, 0, 0, 7034, 7128, 5, 4, 0, 0, 7035, 7036, 5,
		258, 0, 0, 7036, 7038, 5, 2, 0, 0, 7037, 7039, 3, 786, 393, 0, 7038, 7037,
		1, 0, 0, 0, 7038, 7039, 1, 0, 0, 0, 7039, 7040, 1, 0, 0, 0, 7040, 7041,
		3, 852, 426, 0, 7041, 7042, 5, 4, 0, 0, 7042, 7128, 1, 0, 0, 0, 7043, 7044,
		5, 263, 0, 0, 7044, 7046, 5, 2, 0, 0, 7045, 7047, 3, 786, 393, 0, 7046,
		7045, 1, 0, 0, 0, 7046, 7047, 1, 0, 0, 0, 7047, 7048, 1, 0, 0, 0, 7048,
		7049, 3, 852, 426, 0, 7049, 7050, 5, 4, 0, 0, 7050, 7128, 1, 0, 0, 0, 7051,
		7052, 5, 415, 0, 0, 7052, 7054, 5, 2, 0, 0, 7053, 7055, 3, 786, 393, 0,
		7054, 7053, 1, 0, 0, 0, 7054, 7055, 1, 0, 0, 0, 7055, 7056, 1, 0, 0, 0,
		7056, 7057, 3, 852, 426, 0, 7057, 7058, 5, 4, 0, 0, 7058, 7128, 1, 0, 0,
		0, 7059, 7060, 5, 25, 0, 0, 7060, 7062, 5, 2, 0, 0, 7061, 7063, 3, 786,
		393, 0, 7062, 7061, 1, 0, 0, 0, 7062, 7063, 1, 0, 0, 0, 7063, 7064, 1,
		0, 0, 0, 7064, 7075, 3, 852, 426, 0, 7065, 7066, 5, 298, 0, 0, 7066, 7067,
		5, 55, 0, 0, 7067, 7072, 3, 770, 385, 0, 7068, 7069, 5, 3, 0, 0, 7069,
		7071, 3, 770, 385, 0, 7070, 7068, 1, 0, 0, 0, 7071, 7074, 1, 0, 0, 0, 7072,
		7070, 1, 0, 0, 0, 7072, 7073, 1, 0, 0, 0, 7073, 7076, 1, 0, 0, 0, 7074,
		7072, 1, 0, 0, 0, 7075, 7065, 1, 0, 0, 0, 7075, 7076, 1, 0, 0, 0, 7076,
		7077, 1, 0, 0, 0, 7077, 7078, 5, 4, 0, 0, 7078, 7128, 1, 0, 0, 0, 7079,
		7080, 5, 26, 0, 0, 7080, 7081, 5, 2, 0, 0, 7081, 7092, 3, 852, 426, 0,
		7082, 7083, 5, 298, 0, 0, 7083, 7084, 5, 55, 0, 0, 7084, 7089, 3, 770,
		385, 0, 7085, 7086, 5, 3, 0, 0, 7086, 7088, 3, 770, 385, 0, 7087, 7085,
		1, 0, 0, 0, 7088, 7091, 1, 0, 0, 0, 7089, 7087, 1, 0, 0, 0, 7089, 7090,
		1, 0, 0, 0, 7090, 7093, 1, 0, 0, 0, 7091, 7089, 1, 0, 0, 0, 7092, 7082,
		1, 0, 0, 0, 7092, 7093, 1, 0, 0, 0, 7093, 7094, 1, 0, 0, 0, 7094, 7095,
		5, 4, 0, 0, 7095, 7128, 1, 0, 0, 0, 7096, 7097, 5, 185, 0, 0, 7097, 7099,
		5, 2, 0, 0, 7098, 7100, 3, 786, 393, 0, 7099, 7098, 1, 0, 0, 0, 7099, 7100,
		1, 0, 0, 0, 7100, 7101, 1, 0, 0, 0, 7101, 7106, 3, 852, 426, 0, 7102, 7103,
		5, 3, 0, 0, 7103, 7105, 3, 852, 426, 0, 7104, 7102, 1, 0, 0, 0, 7105, 7108,
		1, 0, 0, 0, 7106, 7104, 1, 0, 0, 0, 7106, 7107, 1, 0, 0, 0, 7107, 7119,
		1, 0, 0, 0, 7108, 7106, 1, 0, 0, 0, 7109, 7110, 5, 298, 0, 0, 7110, 7111,
		5, 55, 0, 0, 7111, 7116, 3, 770, 385, 0, 7112, 7113, 5, 3, 0, 0, 7113,
		7115, 3, 770, 385, 0, 7114, 7112, 1, 0, 0, 0, 7115, 7118, 1, 0, 0, 0, 7116,
		7114, 1, 0, 0, 0, 7116, 7117, 1, 0, 0, 0, 7117, 7120, 1, 0, 0, 0, 7118,
		7116, 1, 0, 0, 0, 7119, 7109, 1, 0, 0, 0, 7119, 7120, 1, 0, 0, 0, 7120,
		7123, 1, 0, 0, 0, 7121, 7122, 5, 393, 0, 0, 7122, 7124, 3, 852, 426, 0,
		7123, 7121, 1, 0, 0, 0, 7123, 7124, 1, 0, 0, 0, 7124, 7125, 1, 0, 0, 0,
		7125, 7126, 5, 4, 0, 0, 7126, 7128, 1, 0, 0, 0, 7127, 7002, 1, 0, 0, 0,
		7127, 7010, 1, 0, 0, 0, 7127, 7016, 1, 0, 0, 0, 7127, 7035, 1, 0, 0, 0,
		7127, 7043, 1, 0, 0, 0, 7127, 7051, 1, 0, 0, 0, 7127, 7059, 1, 0, 0, 0,
		7127, 7079, 1, 0, 0, 0, 7127, 7096, 1, 0, 0, 0, 7128, 873, 1, 0, 0, 0,
		7129, 7130, 5, 517, 0, 0, 7130, 7131, 3, 1026, 513, 0, 7131, 875, 1, 0,
		0, 0, 7132, 7133, 5, 517, 0, 0, 7133, 7137, 5, 517, 0, 0, 7134, 7135, 3,
		968, 484, 0, 7135, 7136, 5, 1, 0, 0, 7136, 7138, 1, 0, 0, 0, 7137, 7134,
		1, 0, 0, 0, 7137, 7138, 1, 0, 0, 0, 7138, 7139, 1, 0, 0, 0, 7139, 7140,
		3, 1018, 509, 0, 7140, 877, 1, 0, 0, 0, 7141, 7142, 3, 1018, 509, 0, 7142,
		879, 1, 0, 0, 0, 7143, 7144, 5, 60, 0, 0, 7144, 7145, 5, 2, 0, 0, 7145,
		7171, 5, 4, 0, 0, 7146, 7147, 5, 104, 0, 0, 7147, 7148, 5, 2, 0, 0, 7148,
		7171, 5, 4, 0, 0, 7149, 7150, 5, 387, 0, 0, 7150, 7151, 5, 2, 0, 0, 7151,
		7171, 5, 4, 0, 0, 7152, 7153, 5, 458, 0, 0, 7153, 7154, 5, 2, 0, 0, 7154,
		7171, 5, 4, 0, 0, 7155, 7158, 5, 101, 0, 0, 7156, 7157, 5, 2, 0, 0, 7157,
		7159, 5, 4, 0, 0, 7158, 7156, 1, 0, 0, 0, 7158, 7159, 1, 0, 0, 0, 7159,
		7171, 1, 0, 0, 0, 7160, 7163, 5, 98, 0, 0, 7161, 7162, 5, 2, 0, 0, 7162,
		7164, 5, 4, 0, 0, 7163, 7161, 1, 0, 0, 0, 7163, 7164, 1, 0, 0, 0, 7164,
		7171, 1, 0, 0, 0, 7165, 7168, 5, 97, 0, 0, 7166, 7167, 5, 2, 0, 0, 7167,
		7169, 5, 4, 0, 0, 7168, 7166, 1, 0, 0, 0, 7168, 7169, 1, 0, 0, 0, 7169,
		7171, 1, 0, 0, 0, 7170, 7143, 1, 0, 0, 0, 7170, 7146, 1, 0, 0, 0, 7170,
		7149, 1, 0, 0, 0, 7170, 7152, 1, 0, 0, 0, 7170, 7155, 1, 0, 0, 0, 7170,
		7160, 1, 0, 0, 0, 7170, 7165, 1, 0, 0, 0, 7171, 881, 1, 0, 0, 0, 7172,
		7175, 5, 96, 0, 0, 7173, 7174, 5, 2, 0, 0, 7174, 7176, 5, 4, 0, 0, 7175,
		7173, 1, 0, 0, 0, 7175, 7176, 1, 0, 0, 0, 7176, 7201, 1, 0, 0, 0, 7177,
		7180, 5, 99, 0, 0, 7178, 7179, 5, 2, 0, 0, 7179, 7181, 5, 4, 0, 0, 7180,
		7178, 1, 0, 0, 0, 7180, 7181, 1, 0, 0, 0, 7181, 7201, 1, 0, 0, 0, 7182,
		7188, 5, 100, 0, 0, 7183, 7185, 5, 2, 0, 0, 7184, 7186, 5, 518, 0, 0, 7185,
		7184, 1, 0, 0, 0, 7185, 7186, 1, 0, 0, 0, 7186, 7187, 1, 0, 0, 0, 7187,
		7189, 5, 4, 0, 0, 7188, 7183, 1, 0, 0, 0, 7188, 7189, 1, 0, 0, 0, 7189,
		7201, 1, 0, 0, 0, 7190, 7193, 5, 245, 0, 0, 7191, 7192, 5, 2, 0, 0, 7192,
		7194, 5, 4, 0, 0, 7193, 7191, 1, 0, 0, 0, 7193, 7194, 1, 0, 0, 0, 7194,
		7201, 1, 0, 0, 0, 7195, 7198, 5, 246, 0, 0, 7196, 7197, 5, 2, 0, 0, 7197,
		7199, 5, 4, 0, 0, 7198, 7196, 1, 0, 0, 0, 7198, 7199, 1, 0, 0, 0, 7199,
		7201, 1, 0, 0, 0, 7200, 7172, 1, 0, 0, 0, 7200, 7177, 1, 0, 0, 0, 7200,
		7182, 1, 0, 0, 0, 7200, 7190, 1, 0, 0, 0, 7200, 7195, 1, 0, 0, 0, 7201,
		883, 1, 0, 0, 0, 7202, 7203, 5, 64, 0, 0, 7203, 7204, 5, 2, 0, 0, 7204,
		7205, 3, 852, 426, 0, 7205, 7206, 5, 4, 0, 0, 7206, 7344, 1, 0, 0, 0, 7207,
		7208, 5, 108, 0, 0, 7208, 7209, 5, 2, 0, 0, 7209, 7210, 3, 852, 426, 0,
		7210, 7211, 5, 4, 0, 0, 7211, 7344, 1, 0, 0, 0, 7212, 7213, 5, 193, 0,
		0, 7213, 7214, 5, 2, 0, 0, 7214, 7215, 3, 852, 426, 0, 7215, 7216, 5, 4,
		0, 0, 7216, 7344, 1, 0, 0, 0, 7217, 7218, 5, 197, 0, 0, 7218, 7227, 5,
		2, 0, 0, 7219, 7224, 3, 852, 426, 0, 7220, 7221, 5, 3, 0, 0, 7221, 7223,
		3, 852, 426, 0, 7222, 7220, 1, 0, 0, 0, 7223, 7226, 1, 0, 0, 0, 7224, 7222,
		1, 0, 0, 0, 7224, 7225, 1, 0, 0, 0, 7225, 7228, 1, 0, 0, 0, 7226, 7224,
		1, 0, 0, 0, 7227, 7219, 1, 0, 0, 0, 7227, 7228, 1, 0, 0, 0, 7228, 7229,
		1, 0, 0, 0, 7229, 7344, 5, 4, 0, 0, 7230, 7231, 5, 237, 0, 0, 7231, 7232,
		5, 2, 0, 0, 7232, 7233, 3, 852, 426, 0, 7233, 7234, 5, 3, 0, 0, 7234, 7235,
		3, 852, 426, 0, 7235, 7236, 5, 4, 0, 0, 7236, 7344, 1, 0, 0, 0, 7237, 7238,
		5, 240, 0, 0, 7238, 7239, 5, 2, 0, 0, 7239, 7240, 3, 852, 426, 0, 7240,
		7241, 5, 3, 0, 0, 7241, 7242, 3, 852, 426, 0, 7242, 7243, 5, 4, 0, 0, 7243,
		7344, 1, 0, 0, 0, 7244, 7245, 5, 264, 0, 0, 7245, 7246, 5, 2, 0, 0, 7246,
		7247, 3, 852, 426, 0, 7247, 7248, 5, 4, 0, 0, 7248, 7344, 1, 0, 0, 0, 7249,
		7250, 5, 268, 0, 0, 7250, 7251, 5, 2, 0, 0, 7251, 7252, 3, 852, 426, 0,
		7252, 7253, 5, 3, 0, 0, 7253, 7254, 3, 852, 426, 0, 7254, 7255, 5, 4, 0,
		0, 7255, 7344, 1, 0, 0, 0, 7256, 7257, 5, 271, 0, 0, 7257, 7258, 5, 2,
		0, 0, 7258, 7259, 3, 852, 426, 0, 7259, 7260, 5, 4, 0, 0, 7260, 7344, 1,
		0, 0, 0, 7261, 7262, 5, 337, 0, 0, 7262, 7263, 5, 2, 0, 0, 7263, 7264,
		3, 852, 426, 0, 7264, 7265, 5, 4, 0, 0, 7265, 7344, 1, 0, 0, 0, 7266, 7267,
		5, 350, 0, 0, 7267, 7268, 5, 2, 0, 0, 7268, 7269, 3, 852, 426, 0, 7269,
		7270, 5, 3, 0, 0, 7270, 7271, 3, 852, 426, 0, 7271, 7272, 5, 4, 0, 0, 7272,
		7344, 1, 0, 0, 0, 7273, 7274, 5, 356, 0, 0, 7274, 7283, 5, 2, 0, 0, 7275,
		7280, 3, 852, 426, 0, 7276, 7277, 5, 3, 0, 0, 7277, 7279, 3, 852, 426,
		0, 7278, 7276, 1, 0, 0, 0, 7279, 7282, 1, 0, 0, 0, 7280, 7278, 1, 0, 0,
		0, 7280, 7281, 1, 0, 0, 0, 7281, 7284, 1, 0, 0, 0, 7282, 7280, 1, 0, 0,
		0, 7283, 7275, 1, 0, 0, 0, 7283, 7284, 1, 0, 0, 0, 7284, 7285, 1, 0, 0,
		0, 7285, 7344, 5, 4, 0, 0, 7286, 7287, 5, 371, 0, 0, 7287, 7288, 5, 2,
		0, 0, 7288, 7289, 3, 852, 426, 0, 7289, 7290, 5, 3, 0, 0, 7290, 7291, 3,
		852, 426, 0, 7291, 7292, 5, 4, 0, 0, 7292, 7344, 1, 0, 0, 0, 7293, 7294,
		5, 372, 0, 0, 7294, 7295, 5, 2, 0, 0, 7295, 7296, 3, 852, 426, 0, 7296,
		7297, 5, 3, 0, 0, 7297, 7298, 3, 852, 426, 0, 7298, 7299, 5, 4, 0, 0, 7299,
		7344, 1, 0, 0, 0, 7300, 7301, 5, 389, 0, 0, 7301, 7302, 5, 2, 0, 0, 7302,
		7303, 3, 852, 426, 0, 7303, 7304, 5, 4, 0, 0, 7304, 7344, 1, 0, 0, 0, 7305,
		7306, 5, 435, 0, 0, 7306, 7307, 5, 2, 0, 0, 7307, 7308, 3, 990, 495, 0,
		7308, 7309, 5, 3, 0, 0, 7309, 7310, 3, 852, 426, 0, 7310, 7311, 5, 3, 0,
		0, 7311, 7312, 3, 852, 426, 0, 7312, 7313, 5, 4, 0, 0, 7313, 7344, 1, 0,
		0, 0, 7314, 7315, 5, 436, 0, 0, 7315, 7316, 5, 2, 0, 0, 7316, 7317, 3,
		990, 495, 0, 7317, 7318, 5, 3, 0, 0, 7318, 7319, 3, 852, 426, 0, 7319,
		7320, 5, 3, 0, 0, 7320, 7321, 3, 852, 426, 0, 7321, 7322, 5, 4, 0, 0, 7322,
		7344, 1, 0, 0, 0, 7323, 7324, 5, 483, 0, 0, 7324, 7325, 5, 2, 0, 0, 7325,
		7326, 3, 852, 426, 0, 7326, 7327, 5, 4, 0, 0, 7327, 7344, 1, 0, 0, 0, 7328,
		7329, 5, 305, 0, 0, 7329, 7330, 5, 2, 0, 0, 7330, 7331, 3, 976, 488, 0,
		7331, 7332, 5, 4, 0, 0, 7332, 7344, 1, 0, 0, 0, 7333, 7334, 5, 164, 0,
		0, 7334, 7335, 5, 2, 0, 0, 7335, 7336, 3, 852, 426, 0, 7336, 7337, 5, 4,
		0, 0, 7337, 7344, 1, 0, 0, 0, 7338, 7339, 5, 62, 0, 0, 7339, 7340, 5, 2,
		0, 0, 7340, 7341, 3, 852, 426, 0, 7341, 7342, 5, 4, 0, 0, 7342, 7344, 1,
		0, 0, 0, 7343, 7202, 1, 0, 0, 0, 7343, 7207, 1, 0, 0, 0, 7343, 7212, 1,
		0, 0, 0, 7343, 7217, 1, 0, 0, 0, 7343, 7230, 1, 0, 0, 0, 7343, 7237, 1,
		0, 0, 0, 7343, 7244, 1, 0, 0, 0, 7343, 7249, 1, 0, 0, 0, 7343, 7256, 1,
		0, 0, 0, 7343, 7261, 1, 0, 0, 0, 7343, 7266, 1, 0, 0, 0, 7343, 7273, 1,
		0, 0, 0, 7343, 7286, 1, 0, 0, 0, 7343, 7293, 1, 0, 0, 0, 7343, 7300, 1,
		0, 0, 0, 7343, 7305, 1, 0, 0, 0, 7343, 7314, 1, 0, 0, 0, 7343, 7323, 1,
		0, 0, 0, 7343, 7328, 1, 0, 0, 0, 7343, 7333, 1, 0, 0, 0, 7343, 7338, 1,
		0, 0, 0, 7344, 885, 1, 0, 0, 0, 7345, 7346, 5, 380, 0, 0, 7346, 7347, 5,
		2, 0, 0, 7347, 7443, 5, 4, 0, 0, 7348, 7349, 5, 344, 0, 0, 7349, 7350,
		5, 2, 0, 0, 7350, 7443, 5, 4, 0, 0, 7351, 7352, 5, 119, 0, 0, 7352, 7353,
		5, 2, 0, 0, 7353, 7443, 5, 4, 0, 0, 7354, 7355, 5, 93, 0, 0, 7355, 7356,
		5, 2, 0, 0, 7356, 7443, 5, 4, 0, 0, 7357, 7358, 5, 309, 0, 0, 7358, 7359,
		5, 2, 0, 0, 7359, 7443, 5, 4, 0, 0, 7360, 7361, 5, 124, 0, 0, 7361, 7363,
		5, 2, 0, 0, 7362, 7364, 3, 852, 426, 0, 7363, 7362, 1, 0, 0, 0, 7363, 7364,
		1, 0, 0, 0, 7364, 7365, 1, 0, 0, 0, 7365, 7443, 5, 4, 0, 0, 7366, 7367,
		5, 236, 0, 0, 7367, 7379, 5, 2, 0, 0, 7368, 7370, 3, 852, 426, 0, 7369,
		7371, 3, 892, 446, 0, 7370, 7369, 1, 0, 0, 0, 7370, 7371, 1, 0, 0, 0, 7371,
		7376, 1, 0, 0, 0, 7372, 7373, 5, 3, 0, 0, 7373, 7375, 3, 852, 426, 0, 7374,
		7372, 1, 0, 0, 0, 7375, 7378, 1, 0, 0, 0, 7376, 7374, 1, 0, 0, 0, 7376,
		7377, 1, 0, 0, 0, 7377, 7380, 1, 0, 0, 0, 7378, 7376, 1, 0, 0, 0, 7379,
		7368, 1, 0, 0, 0, 7379, 7380, 1, 0, 0, 0, 7380, 7381, 1, 0, 0, 0, 7381,
		7383, 5, 4, 0, 0, 7382, 7384, 3, 892, 446, 0, 7383, 7382, 1, 0, 0, 0, 7383,
		7384, 1, 0, 0, 0, 7384, 7443, 1, 0, 0, 0, 7385, 7386, 5, 231, 0, 0, 7386,
		7398, 5, 2, 0, 0, 7387, 7389, 3, 852, 426, 0, 7388, 7390, 3, 892, 446,
		0, 7389, 7388, 1, 0, 0, 0, 7389, 7390, 1, 0, 0, 0, 7390, 7395, 1, 0, 0,
		0, 7391, 7392, 5, 3, 0, 0, 7392, 7394, 3, 852, 426, 0, 7393, 7391, 1, 0,
		0, 0, 7394, 7397, 1, 0, 0, 0, 7395, 7393, 1, 0, 0, 0, 7395, 7396, 1, 0,
		0, 0, 7396, 7399, 1, 0, 0, 0, 7397, 7395, 1, 0, 0, 0, 7398, 7387, 1, 0,
		0, 0, 7398, 7399, 1, 0, 0, 0, 7399, 7400, 1, 0, 0, 0, 7400, 7402, 5, 4,
		0, 0, 7401, 7403, 3, 892, 446, 0, 7402, 7401, 1, 0, 0, 0, 7402, 7403, 1,
		0, 0, 0, 7403, 7443, 1, 0, 0, 0, 7404, 7405, 5, 162, 0, 0, 7405, 7417,
		5, 2, 0, 0, 7406, 7408, 3, 852, 426, 0, 7407, 7409, 3, 892, 446, 0, 7408,
		7407, 1, 0, 0, 0, 7408, 7409, 1, 0, 0, 0, 7409, 7414, 1, 0, 0, 0, 7410,
		7411, 5, 3, 0, 0, 7411, 7413, 3, 852, 426, 0, 7412, 7410, 1, 0, 0, 0, 7413,
		7416, 1, 0, 0, 0, 7414, 7412, 1, 0, 0, 0, 7414, 7415, 1, 0, 0, 0, 7415,
		7418, 1, 0, 0, 0, 7416, 7414, 1, 0, 0, 0, 7417, 7406, 1, 0, 0, 0, 7417,
		7418, 1, 0, 0, 0, 7418, 7419, 1, 0, 0, 0, 7419, 7421, 5, 4, 0, 0, 7420,
		7422, 3, 892, 446, 0, 7421, 7420, 1, 0, 0, 0, 7421, 7422, 1, 0, 0, 0, 7422,
		7443, 1, 0, 0, 0, 7423, 7424, 5, 234, 0, 0, 7424, 7436, 5, 2, 0, 0, 7425,
		7427, 3, 852, 426, 0, 7426, 7428, 3, 892, 446, 0, 7427, 7426, 1, 0, 0,
		0, 7427, 7428, 1, 0, 0, 0, 7428, 7433, 1, 0, 0, 0, 7429, 7430, 5, 3, 0,
		0, 7430, 7432, 3, 852, 426, 0, 7431, 7429, 1, 0, 0, 0, 7432, 7435, 1, 0,
		0, 0, 7433, 7431, 1, 0, 0, 0, 7433, 7434, 1, 0, 0, 0, 7434, 7437, 1, 0,
		0, 0, 7435, 7433, 1, 0, 0, 0, 7436, 7425, 1, 0, 0, 0, 7436, 7437, 1, 0,
		0, 0, 7437, 7438, 1, 0, 0, 0, 7438, 7440, 5, 4, 0, 0, 7439, 7441, 3, 892,
		446, 0, 7440, 7439, 1, 0, 0, 0, 7440, 7441, 1, 0, 0, 0, 7441, 7443, 1,
		0, 0, 0, 7442, 7345, 1, 0, 0, 0, 7442, 7348, 1, 0, 0, 0, 7442, 7351, 1,
		0, 0, 0, 7442, 7354, 1, 0, 0, 0, 7442, 7357, 1, 0, 0, 0, 7442, 7360, 1,
		0, 0, 0, 7442, 7366, 1, 0, 0, 0, 7442, 7385, 1, 0, 0, 0, 7442, 7404, 1,
		0, 0, 0, 7442, 7423, 1, 0, 0, 0, 7443, 887, 1, 0, 0, 0, 7444, 7445, 5,
		477, 0, 0, 7445, 7446, 3, 852, 426, 0, 7446, 7447, 5, 431, 0, 0, 7447,
		7448, 3, 852, 426, 0, 7448, 889, 1, 0, 0, 0, 7449, 7450, 5, 301, 0, 0,
		7450, 7464, 5, 2, 0, 0, 7451, 7453, 3, 818, 409, 0, 7452, 7451, 1, 0, 0,
		0, 7452, 7453, 1, 0, 0, 0, 7453, 7454, 1, 0, 0, 0, 7454, 7455, 5, 303,
		0, 0, 7455, 7456, 5, 55, 0, 0, 7456, 7461, 3, 852, 426, 0, 7457, 7458,
		5, 3, 0, 0, 7458, 7460, 3, 852, 426, 0, 7459, 7457, 1, 0, 0, 0, 7460, 7463,
		1, 0, 0, 0, 7461, 7459, 1, 0, 0, 0, 7461, 7462, 1, 0, 0, 0, 7462, 7465,
		1, 0, 0, 0, 7463, 7461, 1, 0, 0, 0, 7464, 7452, 1, 0, 0, 0, 7464, 7465,
		1, 0, 0, 0, 7465, 7476, 1, 0, 0, 0, 7466, 7467, 5, 298, 0, 0, 7467, 7468,
		5, 55, 0, 0, 7468, 7473, 3, 770, 385, 0, 7469, 7470, 5, 3, 0, 0, 7470,
		7472, 3, 770, 385, 0, 7471, 7469, 1, 0, 0, 0, 7472, 7475, 1, 0, 0, 0, 7473,
		7471, 1, 0, 0, 0, 7473, 7474, 1, 0, 0, 0, 7474, 7477, 1, 0, 0, 0, 7475,
		7473, 1, 0, 0, 0, 7476, 7466, 1, 0, 0, 0, 7476, 7477, 1, 0, 0, 0, 7477,
		7479, 1, 0, 0, 0, 7478, 7480, 3, 894, 447, 0, 7479, 7478, 1, 0, 0, 0, 7479,
		7480, 1, 0, 0, 0, 7480, 7481, 1, 0, 0, 0, 7481, 7482, 5, 4, 0, 0, 7482,
		891, 1, 0, 0, 0, 7483, 7484, 5, 200, 0, 0, 7484, 7485, 5, 283, 0, 0, 7485,
		893, 1, 0, 0, 0, 7486, 7487, 5, 343, 0, 0, 7487, 7503, 3, 896, 448, 0,
		7488, 7489, 5, 379, 0, 0, 7489, 7503, 3, 896, 448, 0, 7490, 7491, 5, 343,
		0, 0, 7491, 7492, 5, 41, 0, 0, 7492, 7493, 3, 896, 448, 0, 7493, 7494,
		5, 21, 0, 0, 7494, 7495, 3, 896, 448, 0, 7495, 7503, 1, 0, 0, 0, 7496,
		7497, 5, 379, 0, 0, 7497, 7498, 5, 41, 0, 0, 7498, 7499, 3, 896, 448, 0,
		7499, 7500, 5, 21, 0, 0, 7500, 7501, 3, 896, 448, 0, 7501, 7503, 1, 0,
		0, 0, 7502, 7486, 1, 0, 0, 0, 7502, 7488, 1, 0, 0, 0, 7502, 7490, 1, 0,
		0, 0, 7502, 7496, 1, 0, 0, 0, 7503, 895, 1, 0, 0, 0, 7504, 7505, 5, 448,
		0, 0, 7505, 7514, 5, 320, 0, 0, 7506, 7507, 5, 448, 0, 0, 7507, 7514, 5,
		166, 0, 0, 7508, 7509, 5, 95, 0, 0, 7509, 7514, 5, 378, 0, 0, 7510, 7511,
		3, 852, 426, 0, 7511, 7512, 7, 46, 0, 0, 7512, 7514, 1, 0, 0, 0, 7513,
		7504, 1, 0, 0, 0, 7513, 7506, 1, 0, 0, 0, 7513, 7508, 1, 0, 0, 0, 7513,
		7510, 1, 0, 0, 0, 7514, 897, 1, 0, 0, 0, 7515, 7555, 3, 902, 451, 0, 7516,
		7517, 5, 18, 0, 0, 7517, 7525, 7, 47, 0, 0, 7518, 7519, 7, 47, 0, 0, 7519,
		7522, 3, 1012, 506, 0, 7520, 7521, 5, 27, 0, 0, 7521, 7523, 3, 1018, 509,
		0, 7522, 7520, 1, 0, 0, 0, 7522, 7523, 1, 0, 0, 0, 7523, 7525, 1, 0, 0,
		0, 7524, 7516, 1, 0, 0, 0, 7524, 7518, 1, 0, 0, 0, 7525, 7555, 1, 0, 0,
		0, 7526, 7527, 5, 18, 0, 0, 7527, 7531, 7, 48, 0, 0, 7528, 7529, 7, 48,
		0, 0, 7529, 7531, 3, 902, 451, 0, 7530, 7526, 1, 0, 0, 0, 7530, 7528, 1,
		0, 0, 0, 7531, 7555, 1, 0, 0, 0, 7532, 7533, 5, 18, 0, 0, 7533, 7534, 5,
		257, 0, 0, 7534, 7543, 7, 49, 0, 0, 7535, 7536, 5, 257, 0, 0, 7536, 7537,
		7, 49, 0, 0, 7537, 7540, 3, 1012, 506, 0, 7538, 7539, 5, 27, 0, 0, 7539,
		7541, 3, 1018, 509, 0, 7540, 7538, 1, 0, 0, 0, 7540, 7541, 1, 0, 0, 0,
		7541, 7543, 1, 0, 0, 0, 7542, 7532, 1, 0, 0, 0, 7542, 7535, 1, 0, 0, 0,
		7543, 7555, 1, 0, 0, 0, 7544, 7545, 5, 18, 0, 0, 7545, 7553, 7, 49, 0,
		0, 7546, 7547, 7, 49, 0, 0, 7547, 7550, 3, 1012, 506, 0, 7548, 7549, 5,
		27, 0, 0, 7549, 7551, 3, 1018, 509, 0, 7550, 7548, 1, 0, 0, 0, 7550, 7551,
		1, 0, 0, 0, 7551, 7553, 1, 0, 0, 0, 7552, 7544, 1, 0, 0, 0, 7552, 7546,
		1, 0, 0, 0, 7553, 7555, 1, 0, 0, 0, 7554, 7515, 1, 0, 0, 0, 7554, 7524,
		1, 0, 0, 0, 7554, 7530, 1, 0, 0, 0, 7554, 7542, 1, 0, 0, 0, 7554, 7552,
		1, 0, 0, 0, 7555, 899, 1, 0, 0, 0, 7556, 7558, 3, 1012, 506, 0, 7557, 7559,
		3, 826, 413, 0, 7558, 7557, 1, 0, 0, 0, 7558, 7559, 1, 0, 0, 0, 7559, 901,
		1, 0, 0, 0, 7560, 7562, 3, 1012, 506, 0, 7561, 7563, 3, 826, 413, 0, 7562,
		7561, 1, 0, 0, 0, 7562, 7563, 1, 0, 0, 0, 7563, 7566, 1, 0, 0, 0, 7564,
		7565, 5, 27, 0, 0, 7565, 7567, 3, 1018, 509, 0, 7566, 7564, 1, 0, 0, 0,
		7566, 7567, 1, 0, 0, 0, 7567, 903, 1, 0, 0, 0, 7568, 7570, 7, 50, 0, 0,
		7569, 7571, 7, 51, 0, 0, 7570, 7569, 1, 0, 0, 0, 7570, 7571, 1, 0, 0, 0,
		7571, 905, 1, 0, 0, 0, 7572, 7573, 5, 441, 0, 0, 7573, 7575, 7, 52, 0,
		0, 7574, 7576, 3, 1018, 509, 0, 7575, 7574, 1, 0, 0, 0, 7575, 7576, 1,
		0, 0, 0, 7576, 907, 1, 0, 0, 0, 7577, 7580, 3, 1018, 509, 0, 7578, 7580,
		3, 870, 435, 0, 7579, 7577, 1, 0, 0, 0, 7579, 7578, 1, 0, 0, 0, 7580, 909,
		1, 0, 0, 0, 7581, 7582, 5, 303, 0, 0, 7582, 7583, 5, 55, 0, 0, 7583, 7584,
		5, 343, 0, 0, 7584, 7585, 3, 1024, 512, 0, 7585, 7594, 5, 2, 0, 0, 7586,
		7591, 3, 930, 465, 0, 7587, 7588, 5, 3, 0, 0, 7588, 7590, 3, 930, 465,
		0, 7589, 7587, 1, 0, 0, 0, 7590, 7593, 1, 0, 0, 0, 7591, 7589, 1, 0, 0,
		0, 7591, 7592, 1, 0, 0, 0, 7592, 7595, 1, 0, 0, 0, 7593, 7591, 1, 0, 0,
		0, 7594, 7586, 1, 0, 0, 0, 7594, 7595, 1, 0, 0, 0, 7595, 7596, 1, 0, 0,
		0, 7596, 7597, 5, 4, 0, 0, 7597, 7670, 1, 0, 0, 0, 7598, 7599, 5, 303,
		0, 0, 7599, 7600, 5, 55, 0, 0, 7600, 7601, 5, 343, 0, 0, 7601, 7602, 3,
		866, 433, 0, 7602, 7611, 5, 2, 0, 0, 7603, 7608, 3, 930, 465, 0, 7604,
		7605, 5, 3, 0, 0, 7605, 7607, 3, 930, 465, 0, 7606, 7604, 1, 0, 0, 0, 7607,
		7610, 1, 0, 0, 0, 7608, 7606, 1, 0, 0, 0, 7608, 7609, 1, 0, 0, 0, 7609,
		7612, 1, 0, 0, 0, 7610, 7608, 1, 0, 0, 0, 7611, 7603, 1, 0, 0, 0, 7611,
		7612, 1, 0, 0, 0, 7612, 7613, 1, 0, 0, 0, 7613, 7614, 5, 4, 0, 0, 7614,
		7670, 1, 0, 0, 0, 7615, 7616, 5, 303, 0, 0, 7616, 7618, 5, 55, 0, 0, 7617,
		7619, 5, 242, 0, 0, 7618, 7617, 1, 0, 0, 0, 7618, 7619, 1, 0, 0, 0, 7619,
		7620, 1, 0, 0, 0, 7620, 7621, 3, 1024, 512, 0, 7621, 7630, 5, 2, 0, 0,
		7622, 7627, 3, 912, 456, 0, 7623, 7624, 5, 3, 0, 0, 7624, 7626, 3, 912,
		456, 0, 7625, 7623, 1, 0, 0, 0, 7626, 7629, 1, 0, 0, 0, 7627, 7625, 1,
		0, 0, 0, 7627, 7628, 1, 0, 0, 0, 7628, 7631, 1, 0, 0, 0, 7629, 7627, 1,
		0, 0, 0, 7630, 7622, 1, 0, 0, 0, 7630, 7631, 1, 0, 0, 0, 7631, 7632, 1,
		0, 0, 0, 7632, 7633, 5, 4, 0, 0, 7633, 7670, 1, 0, 0, 0, 7634, 7635, 5,
		303, 0, 0, 7635, 7637, 5, 55, 0, 0, 7636, 7638, 5, 242, 0, 0, 7637, 7636,
		1, 0, 0, 0, 7637, 7638, 1, 0, 0, 0, 7638, 7639, 1, 0, 0, 0, 7639, 7670,
		3, 1024, 512, 0, 7640, 7641, 5, 303, 0, 0, 7641, 7642, 5, 55, 0, 0, 7642,
		7643, 3, 870, 435, 0, 7643, 7652, 5, 2, 0, 0, 7644, 7649, 3, 930, 465,
		0, 7645, 7646, 5, 3, 0, 0, 7646, 7648, 3, 930, 465, 0, 7647, 7645, 1, 0,
		0, 0, 7648, 7651, 1, 0, 0, 0, 7649, 7647, 1, 0, 0, 0, 7649, 7650, 1, 0,
		0, 0, 7650, 7653, 1, 0, 0, 0, 7651, 7649, 1, 0, 0, 0, 7652, 7644, 1, 0,
		0, 0, 7652, 7653, 1, 0, 0, 0, 7653, 7654, 1, 0, 0, 0, 7654, 7655, 5, 4,
		0, 0, 7655, 7670, 1, 0, 0, 0, 7656, 7657, 5, 303, 0, 0, 7657, 7658, 5,
		55, 0, 0, 7658, 7670, 3, 870, 435, 0, 7659, 7660, 5, 303, 0, 0, 7660, 7661,
		5, 55, 0, 0, 7661, 7666, 3, 908, 454, 0, 7662, 7663, 5, 3, 0, 0, 7663,
		7665, 3, 908, 454, 0, 7664, 7662, 1, 0, 0, 0, 7665, 7668, 1, 0, 0, 0, 7666,
		7664, 1, 0, 0, 0, 7666, 7667, 1, 0, 0, 0, 7667, 7670, 1, 0, 0, 0, 7668,
		7666, 1, 0, 0, 0, 7669, 7581, 1, 0, 0, 0, 7669, 7598, 1, 0, 0, 0, 7669,
		7615, 1, 0, 0, 0, 7669, 7634, 1, 0, 0, 0, 7669, 7640, 1, 0, 0, 0, 7669,
		7656, 1, 0, 0, 0, 7669, 7659, 1, 0, 0, 0, 7670, 911, 1, 0, 0, 0, 7671,
		7674, 3, 914, 457, 0, 7672, 7674, 3, 916, 458, 0, 7673, 7671, 1, 0, 0,
		0, 7673, 7672, 1, 0, 0, 0, 7674, 913, 1, 0, 0, 0, 7675, 7679, 5, 303, 0,
		0, 7676, 7677, 5, 197, 0, 0, 7677, 7678, 5, 281, 0, 0, 7678, 7680, 5, 148,
		0, 0, 7679, 7676, 1, 0, 0, 0, 7679, 7680, 1, 0, 0, 0, 7680, 7681, 1, 0,
		0, 0, 7681, 7682, 3, 1018, 509, 0, 7682, 7683, 5, 462, 0, 0, 7683, 7684,
		5, 202, 0, 0, 7684, 7686, 3, 920, 460, 0, 7685, 7687, 3, 958, 479, 0, 7686,
		7685, 1, 0, 0, 0, 7686, 7687, 1, 0, 0, 0, 7687, 915, 1, 0, 0, 0, 7688,
		7692, 5, 303, 0, 0, 7689, 7690, 5, 197, 0, 0, 7690, 7691, 5, 281, 0, 0,
		7691, 7693, 5, 148, 0, 0, 7692, 7689, 1, 0, 0, 0, 7692, 7693, 1, 0, 0,
		0, 7693, 7694, 1, 0, 0, 0, 7694, 7695, 3, 1018, 509, 0, 7695, 7696, 5,
		462, 0, 0, 7696, 7697, 5, 202, 0, 0, 7697, 7699, 3, 918, 459, 0, 7698,
		7700, 3, 958, 479, 0, 7699, 7698, 1, 0, 0, 0, 7699, 7700, 1, 0, 0, 0, 7700,
		917, 1, 0, 0, 0, 7701, 7702, 5, 2, 0, 0, 7702, 7707, 3, 920, 460, 0, 7703,
		7704, 5, 3, 0, 0, 7704, 7706, 3, 920, 460, 0, 7705, 7703, 1, 0, 0, 0, 7706,
		7709, 1, 0, 0, 0, 7707, 7705, 1, 0, 0, 0, 7707, 7708, 1, 0, 0, 0, 7708,
		7710, 1, 0, 0, 0, 7709, 7707, 1, 0, 0, 0, 7710, 7711, 5, 4, 0, 0, 7711,
		919, 1, 0, 0, 0, 7712, 7713, 5, 2, 0, 0, 7713, 7718, 3, 924, 462, 0, 7714,
		7715, 5, 3, 0, 0, 7715, 7717, 3, 924, 462, 0, 7716, 7714, 1, 0, 0, 0, 7717,
		7720, 1, 0, 0, 0, 7718, 7716, 1, 0, 0, 0, 7718, 7719, 1, 0, 0, 0, 7719,
		7721, 1, 0, 0, 0, 7720, 7718, 1, 0, 0, 0, 7721, 7722, 5, 4, 0, 0, 7722,
		921, 1, 0, 0, 0, 7723, 7726, 3, 920, 460, 0, 7724, 7726, 3, 918, 459, 0,
		7725, 7723, 1, 0, 0, 0, 7725, 7724, 1, 0, 0, 0, 7726, 923, 1, 0, 0, 0,
		7727, 7730, 5, 282, 0, 0, 7728, 7730, 3, 976, 488, 0, 7729, 7727, 1, 0,
		0, 0, 7729, 7728, 1, 0, 0, 0, 7730, 925, 1, 0, 0, 0, 7731, 7732, 5, 2,
		0, 0, 7732, 7737, 3, 976, 488, 0, 7733, 7734, 5, 3, 0, 0, 7734, 7736, 3,
		976, 488, 0, 7735, 7733, 1, 0, 0, 0, 7736, 7739, 1, 0, 0, 0, 7737, 7735,
		1, 0, 0, 0, 7737, 7738, 1, 0, 0, 0, 7738, 7740, 1, 0, 0, 0, 7739, 7737,
		1, 0, 0, 0, 7740, 7741, 5, 4, 0, 0, 7741, 927, 1, 0, 0, 0, 7742, 7743,
		5, 2, 0, 0, 7743, 7748, 3, 868, 434, 0, 7744, 7745, 5, 3, 0, 0, 7745, 7747,
		3, 868, 434, 0, 7746, 7744, 1, 0, 0, 0, 7747, 7750, 1, 0, 0, 0, 7748, 7746,
		1, 0, 0, 0, 7748, 7749, 1, 0, 0, 0, 7749, 7751, 1, 0, 0, 0, 7750, 7748,
		1, 0, 0, 0, 7751, 7752, 5, 4, 0, 0, 7752, 929, 1, 0, 0, 0, 7753, 7756,
		3, 932, 466, 0, 7754, 7756, 3, 934, 467, 0, 7755, 7753, 1, 0, 0, 0, 7755,
		7754, 1, 0, 0, 0, 7756, 931, 1, 0, 0, 0, 7757, 7761, 5, 303, 0, 0, 7758,
		7759, 5, 197, 0, 0, 7759, 7760, 5, 281, 0, 0, 7760, 7762, 5, 148, 0, 0,
		7761, 7758, 1, 0, 0, 0, 7761, 7762, 1, 0, 0, 0, 7762, 7763, 1, 0, 0, 0,
		7763, 7764, 3, 1018, 509, 0, 7764, 7765, 5, 462, 0, 0, 7765, 7767, 3, 938,
		469, 0, 7766, 7768, 3, 958, 479, 0, 7767, 7766, 1, 0, 0, 0, 7767, 7768,
		1, 0, 0, 0, 7768, 933, 1, 0, 0, 0, 7769, 7770, 5, 406, 0, 0, 7770, 7771,
		5, 2, 0, 0, 7771, 7772, 3, 976, 488, 0, 7772, 7773, 5, 4, 0, 0, 7773, 7774,
		5, 139, 0, 0, 7774, 7775, 5, 2, 0, 0, 7775, 7776, 3, 976, 488, 0, 7776,
		7777, 5, 4, 0, 0, 7777, 7778, 5, 153, 0, 0, 7778, 7779, 5, 2, 0, 0, 7779,
		7780, 3, 984, 492, 0, 7780, 7781, 5, 4, 0, 0, 7781, 7796, 1, 0, 0, 0, 7782,
		7783, 5, 406, 0, 0, 7783, 7784, 5, 2, 0, 0, 7784, 7785, 3, 976, 488, 0,
		7785, 7786, 5, 4, 0, 0, 7786, 7787, 5, 139, 0, 0, 7787, 7788, 5, 2, 0,
		0, 7788, 7789, 3, 976, 488, 0, 7789, 7790, 5, 4, 0, 0, 7790, 7791, 5, 153,
		0, 0, 7791, 7792, 5, 2, 0, 0, 7792, 7793, 5, 518, 0, 0, 7793, 7794, 5,
		4, 0, 0, 7794, 7796, 1, 0, 0, 0, 7795, 7769, 1, 0, 0, 0, 7795, 7782, 1,
		0, 0, 0, 7796, 935, 1, 0, 0, 0, 7797, 7798, 5, 406, 0, 0, 7798, 7799, 5,
		2, 0, 0, 7799, 7800, 3, 976, 488, 0, 7800, 7801, 5, 4, 0, 0, 7801, 7802,
		5, 139, 0, 0, 7802, 7803, 5, 2, 0, 0, 7803, 7804, 3, 976, 488, 0, 7804,
		7805, 5, 4, 0, 0, 7805, 937, 1, 0, 0, 0, 7806, 7807, 5, 238, 0, 0, 7807,
		7810, 5, 430, 0, 0, 7808, 7811, 5, 259, 0, 0, 7809, 7811, 3, 940, 470,
		0, 7810, 7808, 1, 0, 0, 0, 7810, 7809, 1, 0, 0, 0, 7811, 7819, 1, 0, 0,
		0, 7812, 7813, 5, 6, 0, 0, 7813, 7814, 3, 940, 470, 0, 7814, 7815, 5, 3,
		0, 0, 7815, 7816, 3, 940, 470, 0, 7816, 7817, 5, 4, 0, 0, 7817, 7819, 1,
		0, 0, 0, 7818, 7806, 1, 0, 0, 0, 7818, 7812, 1, 0, 0, 0, 7819, 939, 1,
		0, 0, 0, 7820, 7821, 5, 2, 0, 0, 7821, 7826, 3, 944, 472, 0, 7822, 7823,
		5, 3, 0, 0, 7823, 7825, 3, 944, 472, 0, 7824, 7822, 1, 0, 0, 0, 7825, 7828,
		1, 0, 0, 0, 7826, 7824, 1, 0, 0, 0, 7826, 7827, 1, 0, 0, 0, 7827, 7829,
		1, 0, 0, 0, 7828, 7826, 1, 0, 0, 0, 7829, 7830, 5, 4, 0, 0, 7830, 941,
		1, 0, 0, 0, 7831, 7832, 3, 1018, 509, 0, 7832, 7833, 5, 492, 0, 0, 7833,
		7834, 3, 868, 434, 0, 7834, 943, 1, 0, 0, 0, 7835, 7838, 5, 259, 0, 0,
		7836, 7838, 3, 976, 488, 0, 7837, 7835, 1, 0, 0, 0, 7837, 7836, 1, 0, 0,
		0, 7838, 945, 1, 0, 0, 0, 7839, 7840, 5, 129, 0, 0, 7840, 7841, 5, 55,
		0, 0, 7841, 7842, 5, 186, 0, 0, 7842, 7845, 3, 1024, 512, 0, 7843, 7844,
		5, 53, 0, 0, 7844, 7846, 5, 518, 0, 0, 7845, 7843, 1, 0, 0, 0, 7845, 7846,
		1, 0, 0, 0, 7846, 7852, 1, 0, 0, 0, 7847, 7848, 5, 129, 0, 0, 7848, 7849,
		5, 55, 0, 0, 7849, 7850, 5, 186, 0, 0, 7850, 7852, 3, 1024, 512, 0, 7851,
		7839, 1, 0, 0, 0, 7851, 7847, 1, 0, 0, 0, 7852, 947, 1, 0, 0, 0, 7853,
		7854, 5, 129, 0, 0, 7854, 7855, 5, 55, 0, 0, 7855, 7856, 5, 186, 0, 0,
		7856, 7859, 3, 1024, 512, 0, 7857, 7858, 5, 53, 0, 0, 7858, 7860, 5, 518,
		0, 0, 7859, 7857, 1, 0, 0, 0, 7859, 7860, 1, 0, 0, 0, 7860, 7873, 1, 0,
		0, 0, 7861, 7862, 5, 129, 0, 0, 7862, 7863, 5, 55, 0, 0, 7863, 7864, 5,
		186, 0, 0, 7864, 7873, 3, 1024, 512, 0, 7865, 7866, 5, 129, 0, 0, 7866,
		7867, 5, 55, 0, 0, 7867, 7870, 5, 342, 0, 0, 7868, 7869, 5, 53, 0, 0, 7869,
		7871, 5, 518, 0, 0, 7870, 7868, 1, 0, 0, 0, 7870, 7871, 1, 0, 0, 0, 7871,
		7873, 1, 0, 0, 0, 7872, 7853, 1, 0, 0, 0, 7872, 7861, 1, 0, 0, 0, 7872,
		7865, 1, 0, 0, 0, 7873, 949, 1, 0, 0, 0, 7874, 7876, 5, 348, 0, 0, 7875,
		7877, 7, 53, 0, 0, 7876, 7875, 1, 0, 0, 0, 7876, 7877, 1, 0, 0, 0, 7877,
		7894, 1, 0, 0, 0, 7878, 7895, 5, 29, 0, 0, 7879, 7885, 5, 29, 0, 0, 7880,
		7881, 5, 406, 0, 0, 7881, 7882, 5, 2, 0, 0, 7882, 7883, 3, 976, 488, 0,
		7883, 7884, 5, 4, 0, 0, 7884, 7886, 1, 0, 0, 0, 7885, 7880, 1, 0, 0, 0,
		7885, 7886, 1, 0, 0, 0, 7886, 7887, 1, 0, 0, 0, 7887, 7888, 5, 153, 0,
		0, 7888, 7889, 5, 2, 0, 0, 7889, 7890, 3, 984, 492, 0, 7890, 7891, 5, 4,
		0, 0, 7891, 7895, 1, 0, 0, 0, 7892, 7895, 5, 204, 0, 0, 7893, 7895, 5,
		251, 0, 0, 7894, 7878, 1, 0, 0, 0, 7894, 7879, 1, 0, 0, 0, 7894, 7892,
		1, 0, 0, 0, 7894, 7893, 1, 0, 0, 0, 7895, 951, 1, 0, 0, 0, 7896, 7897,
		7, 54, 0, 0, 7897, 953, 1, 0, 0, 0, 7898, 7899, 5, 332, 0, 0, 7899, 7900,
		5, 2, 0, 0, 7900, 7905, 3, 962, 481, 0, 7901, 7902, 5, 3, 0, 0, 7902, 7904,
		3, 962, 481, 0, 7903, 7901, 1, 0, 0, 0, 7904, 7907, 1, 0, 0, 0, 7905, 7903,
		1, 0, 0, 0, 7905, 7906, 1, 0, 0, 0, 7906, 7908, 1, 0, 0, 0, 7907, 7905,
		1, 0, 0, 0, 7908, 7909, 5, 4, 0, 0, 7909, 955, 1, 0, 0, 0, 7910, 7911,
		5, 52, 0, 0, 7911, 7912, 3, 954, 477, 0, 7912, 957, 1, 0, 0, 0, 7913, 7914,
		5, 2, 0, 0, 7914, 7919, 3, 962, 481, 0, 7915, 7916, 5, 3, 0, 0, 7916, 7918,
		3, 962, 481, 0, 7917, 7915, 1, 0, 0, 0, 7918, 7921, 1, 0, 0, 0, 7919, 7917,
		1, 0, 0, 0, 7919, 7920, 1, 0, 0, 0, 7920, 7922, 1, 0, 0, 0, 7921, 7919,
		1, 0, 0, 0, 7922, 7923, 5, 4, 0, 0, 7923, 959, 1, 0, 0, 0, 7924, 7929,
		3, 962, 481, 0, 7925, 7926, 5, 3, 0, 0, 7926, 7928, 3, 962, 481, 0, 7927,
		7925, 1, 0, 0, 0, 7928, 7931, 1, 0, 0, 0, 7929, 7927, 1, 0, 0, 0, 7929,
		7930, 1, 0, 0, 0, 7930, 961, 1, 0, 0, 0, 7931, 7929, 1, 0, 0, 0, 7932,
		7933, 3, 976, 488, 0, 7933, 7934, 5, 492, 0, 0, 7934, 7935, 3, 976, 488,
		0, 7935, 963, 1, 0, 0, 0, 7936, 7940, 3, 966, 483, 0, 7937, 7939, 3, 966,
		483, 0, 7938, 7937, 1, 0, 0, 0, 7939, 7942, 1, 0, 0, 0, 7940, 7938, 1,
		0, 0, 0, 7940, 7941, 1, 0, 0, 0, 7941, 965, 1, 0, 0, 0, 7942, 7940, 1,
		0, 0, 0, 7943, 7944, 3, 1018, 509, 0, 7944, 7945, 5, 492, 0, 0, 7945, 7946,
		3, 976, 488, 0, 7946, 967, 1, 0, 0, 0, 7947, 7948, 7, 55, 0, 0, 7948, 969,
		1, 0, 0, 0, 7949, 7950, 5, 78, 0, 0, 7950, 7951, 3, 976, 488, 0, 7951,
		971, 1, 0, 0, 0, 7952, 7953, 5, 218, 0, 0, 7953, 7954, 5, 300, 0, 0, 7954,
		7956, 3, 976, 488, 0, 7955, 7957, 3, 974, 487, 0, 7956, 7955, 1, 0, 0,
		0, 7956, 7957, 1, 0, 0, 0, 7957, 7959, 1, 0, 0, 0, 7958, 7960, 3, 954,
		477, 0, 7959, 7958, 1, 0, 0, 0, 7959, 7960, 1, 0, 0, 0, 7960, 973, 1, 0,
		0, 0, 7961, 7962, 5, 170, 0, 0, 7962, 7965, 5, 27, 0, 0, 7963, 7966, 3,
		1018, 509, 0, 7964, 7966, 3, 976, 488, 0, 7965, 7963, 1, 0, 0, 0, 7965,
		7964, 1, 0, 0, 0, 7966, 975, 1, 0, 0, 0, 7967, 7968, 7, 56, 0, 0, 7968,
		977, 1, 0, 0, 0, 7969, 7970, 7, 57, 0, 0, 7970, 979, 1, 0, 0, 0, 7971,
		7972, 7, 58, 0, 0, 7972, 981, 1, 0, 0, 0, 7973, 7974, 7, 59, 0, 0, 7974,
		983, 1, 0, 0, 0, 7975, 7976, 5, 217, 0, 0, 7976, 7977, 3, 852, 426, 0,
		7977, 7978, 3, 990, 495, 0, 7978, 985, 1, 0, 0, 0, 7979, 7980, 5, 217,
		0, 0, 7980, 7981, 3, 852, 426, 0, 7981, 7982, 3, 988, 494, 0, 7982, 987,
		1, 0, 0, 0, 7983, 7984, 7, 60, 0, 0, 7984, 989, 1, 0, 0, 0, 7985, 7986,
		7, 61, 0, 0, 7986, 991, 1, 0, 0, 0, 7987, 7988, 7, 62, 0, 0, 7988, 993,
		1, 0, 0, 0, 7989, 7995, 3, 1008, 504, 0, 7990, 7995, 3, 1010, 505, 0, 7991,
		7995, 3, 996, 498, 0, 7992, 7995, 3, 1004, 502, 0, 7993, 7995, 3, 998,
		499, 0, 7994, 7989, 1, 0, 0, 0, 7994, 7990, 1, 0, 0, 0, 7994, 7991, 1,
		0, 0, 0, 7994, 7992, 1, 0, 0, 0, 7994, 7993, 1, 0, 0, 0, 7995, 995, 1,
		0, 0, 0, 7996, 7997, 5, 24, 0, 0, 7997, 7998, 5, 494, 0, 0, 7998, 7999,
		3, 994, 497, 0, 7999, 8000, 5, 496, 0, 0, 8000, 997, 1, 0, 0, 0, 8001,
		8002, 5, 252, 0, 0, 8002, 8003, 5, 494, 0, 0, 8003, 8004, 3, 994, 497,
		0, 8004, 8005, 5, 3, 0, 0, 8005, 8006, 3, 994, 497, 0, 8006, 8007, 5, 496,
		0, 0, 8007, 999, 1, 0, 0, 0, 8008, 8011, 3, 1018, 509, 0, 8009, 8011, 3,
		304, 152, 0, 8010, 8008, 1, 0, 0, 0, 8010, 8009, 1, 0, 0, 0, 8011, 8012,
		1, 0, 0, 0, 8012, 8013, 3, 994, 497, 0, 8013, 1001, 1, 0, 0, 0, 8014, 8019,
		3, 1000, 500, 0, 8015, 8016, 5, 3, 0, 0, 8016, 8018, 3, 1000, 500, 0, 8017,
		8015, 1, 0, 0, 0, 8018, 8021, 1, 0, 0, 0, 8019, 8017, 1, 0, 0, 0, 8019,
		8020, 1, 0, 0, 0, 8020, 1003, 1, 0, 0, 0, 8021, 8019, 1, 0, 0, 0, 8022,
		8023, 5, 421, 0, 0, 8023, 8024, 5, 494, 0, 0, 8024, 8025, 3, 1002, 501,
		0, 8025, 8026, 5, 496, 0, 0, 8026, 1005, 1, 0, 0, 0, 8027, 8028, 5, 2,
		0, 0, 8028, 8029, 5, 518, 0, 0, 8029, 8030, 5, 4, 0, 0, 8030, 1007, 1,
		0, 0, 0, 8031, 8100, 5, 49, 0, 0, 8032, 8034, 5, 437, 0, 0, 8033, 8035,
		3, 1006, 503, 0, 8034, 8033, 1, 0, 0, 0, 8034, 8035, 1, 0, 0, 0, 8035,
		8100, 1, 0, 0, 0, 8036, 8038, 5, 402, 0, 0, 8037, 8039, 3, 1006, 503, 0,
		8038, 8037, 1, 0, 0, 0, 8038, 8039, 1, 0, 0, 0, 8039, 8100, 1, 0, 0, 0,
		8040, 8042, 5, 399, 0, 0, 8041, 8043, 5, 211, 0, 0, 8042, 8041, 1, 0, 0,
		0, 8042, 8043, 1, 0, 0, 0, 8043, 8100, 1, 0, 0, 0, 8044, 8046, 5, 399,
		0, 0, 8045, 8047, 5, 212, 0, 0, 8046, 8045, 1, 0, 0, 0, 8046, 8047, 1,
		0, 0, 0, 8047, 8100, 1, 0, 0, 0, 8048, 8050, 5, 454, 0, 0, 8049, 8051,
		5, 211, 0, 0, 8050, 8049, 1, 0, 0, 0, 8050, 8051, 1, 0, 0, 0, 8051, 8100,
		1, 0, 0, 0, 8052, 8054, 5, 454, 0, 0, 8053, 8055, 5, 212, 0, 0, 8054, 8053,
		1, 0, 0, 0, 8054, 8055, 1, 0, 0, 0, 8055, 8100, 1, 0, 0, 0, 8056, 8058,
		5, 211, 0, 0, 8057, 8059, 3, 1006, 503, 0, 8058, 8057, 1, 0, 0, 0, 8058,
		8059, 1, 0, 0, 0, 8059, 8100, 1, 0, 0, 0, 8060, 8062, 5, 212, 0, 0, 8061,
		8063, 3, 1006, 503, 0, 8062, 8061, 1, 0, 0, 0, 8062, 8063, 1, 0, 0, 0,
		8063, 8100, 1, 0, 0, 0, 8064, 8066, 5, 42, 0, 0, 8065, 8067, 3, 1006, 503,
		0, 8066, 8065, 1, 0, 0, 0, 8066, 8067, 1, 0, 0, 0, 8067, 8100, 1, 0, 0,
		0, 8068, 8070, 5, 232, 0, 0, 8069, 8071, 3, 1006, 503, 0, 8070, 8069, 1,
		0, 0, 0, 8070, 8071, 1, 0, 0, 0, 8071, 8100, 1, 0, 0, 0, 8072, 8100, 5,
		163, 0, 0, 8073, 8100, 5, 131, 0, 0, 8074, 8100, 5, 106, 0, 0, 8075, 8100,
		5, 107, 0, 0, 8076, 8100, 5, 432, 0, 0, 8077, 8079, 5, 64, 0, 0, 8078,
		8080, 3, 1006, 503, 0, 8079, 8078, 1, 0, 0, 0, 8079, 8080, 1, 0, 0, 0,
		8080, 8100, 1, 0, 0, 0, 8081, 8083, 5, 464, 0, 0, 8082, 8084, 3, 1006,
		503, 0, 8083, 8082, 1, 0, 0, 0, 8083, 8084, 1, 0, 0, 0, 8084, 8100, 1,
		0, 0, 0, 8085, 8100, 5, 412, 0, 0, 8086, 8100, 5, 413, 0, 0, 8087, 8100,
		5, 44, 0, 0, 8088, 8100, 5, 190, 0, 0, 8089, 8100, 5, 310, 0, 0, 8090,
		8100, 5, 226, 0, 0, 8091, 8093, 5, 463, 0, 0, 8092, 8094, 3, 1006, 503,
		0, 8093, 8092, 1, 0, 0, 0, 8093, 8094, 1, 0, 0, 0, 8094, 8100, 1, 0, 0,
		0, 8095, 8097, 5, 43, 0, 0, 8096, 8098, 3, 1006, 503, 0, 8097, 8096, 1,
		0, 0, 0, 8097, 8098, 1, 0, 0, 0, 8098, 8100, 1, 0, 0, 0, 8099, 8031, 1,
		0, 0, 0, 8099, 8032, 1, 0, 0, 0, 8099, 8036, 1, 0, 0, 0, 8099, 8040, 1,
		0, 0, 0, 8099, 8044, 1, 0, 0, 0, 8099, 8048, 1, 0, 0, 0, 8099, 8052, 1,
		0, 0, 0, 8099, 8056, 1, 0, 0, 0, 8099, 8060, 1, 0, 0, 0, 8099, 8064, 1,
		0, 0, 0, 8099, 8068, 1, 0, 0, 0, 8099, 8072, 1, 0, 0, 0, 8099, 8073, 1,
		0, 0, 0, 8099, 8074, 1, 0, 0, 0, 8099, 8075, 1, 0, 0, 0, 8099, 8076, 1,
		0, 0, 0, 8099, 8077, 1, 0, 0, 0, 8099, 8081, 1, 0, 0, 0, 8099, 8085, 1,
		0, 0, 0, 8099, 8086, 1, 0, 0, 0, 8099, 8087, 1, 0, 0, 0, 8099, 8088, 1,
		0, 0, 0, 8099, 8089, 1, 0, 0, 0, 8099, 8090, 1, 0, 0, 0, 8099, 8091, 1,
		0, 0, 0, 8099, 8095, 1, 0, 0, 0, 8100, 1009, 1, 0, 0, 0, 8101, 8109, 7,
		63, 0, 0, 8102, 8103, 5, 2, 0, 0, 8103, 8106, 5, 518, 0, 0, 8104, 8105,
		5, 3, 0, 0, 8105, 8107, 5, 518, 0, 0, 8106, 8104, 1, 0, 0, 0, 8106, 8107,
		1, 0, 0, 0, 8107, 8108, 1, 0, 0, 0, 8108, 8110, 5, 4, 0, 0, 8109, 8102,
		1, 0, 0, 0, 8109, 8110, 1, 0, 0, 0, 8110, 1011, 1, 0, 0, 0, 8111, 8117,
		3, 1018, 509, 0, 8112, 8116, 5, 528, 0, 0, 8113, 8114, 5, 1, 0, 0, 8114,
		8116, 3, 1018, 509, 0, 8115, 8112, 1, 0, 0, 0, 8115, 8113, 1, 0, 0, 0,
		8116, 8119, 1, 0, 0, 0, 8117, 8115, 1, 0, 0, 0, 8117, 8118, 1, 0, 0, 0,
		8118, 1013, 1, 0, 0, 0, 8119, 8117, 1, 0, 0, 0, 8120, 8121, 3, 1012, 506,
		0, 8121, 1015, 1, 0, 0, 0, 8122, 8124, 5, 168, 0, 0, 8123, 8122, 1, 0,
		0, 0, 8123, 8124, 1, 0, 0, 0, 8124, 8125, 1, 0, 0, 0, 8125, 8126, 5, 468,
		0, 0, 8126, 8127, 5, 27, 0, 0, 8127, 8128, 5, 287, 0, 0, 8128, 8129, 3,
		1018, 509, 0, 8129, 1017, 1, 0, 0, 0, 8130, 8135, 5, 525, 0, 0, 8131, 8135,
		3, 1040, 520, 0, 8132, 8135, 5, 526, 0, 0, 8133, 8135, 5, 527, 0, 0, 8134,
		8130, 1, 0, 0, 0, 8134, 8131, 1, 0, 0, 0, 8134, 8132, 1, 0, 0, 0, 8134,
		8133, 1, 0, 0, 0, 8135, 1019, 1, 0, 0, 0, 8136, 8139, 3, 1018, 509, 0,
		8137, 8138, 5, 27, 0, 0, 8138, 8140, 3, 1018, 509, 0, 8139, 8137, 1, 0,
		0, 0, 8139, 8140, 1, 0, 0, 0, 8140, 1021, 1, 0, 0, 0, 8141, 8142, 5, 2,
		0, 0, 8142, 8147, 3, 1020, 510, 0, 8143, 8144, 5, 3, 0, 0, 8144, 8146,
		3, 1020, 510, 0, 8145, 8143, 1, 0, 0, 0, 8146, 8149, 1, 0, 0, 0, 8147,
		8145, 1, 0, 0, 0, 8147, 8148, 1, 0, 0, 0, 8148, 8150, 1, 0, 0, 0, 8149,
		8147, 1, 0, 0, 0, 8150, 8151, 5, 4, 0, 0, 8151, 1023, 1, 0, 0, 0, 8152,
		8153, 5, 2, 0, 0, 8153, 8158, 3, 1018, 509, 0, 8154, 8155, 5, 3, 0, 0,
		8155, 8157, 3, 1018, 509, 0, 8156, 8154, 1, 0, 0, 0, 8157, 8160, 1, 0,
		0, 0, 8158, 8156, 1, 0, 0, 0, 8158, 8159, 1, 0, 0, 0, 8159, 8161, 1, 0,
		0, 0, 8160, 8158, 1, 0, 0, 0, 8161, 8162, 5, 4, 0, 0, 8162, 1025, 1, 0,
		0, 0, 8163, 8166, 3, 1018, 509, 0, 8164, 8166, 3, 976, 488, 0, 8165, 8163,
		1, 0, 0, 0, 8165, 8164, 1, 0, 0, 0, 8166, 1027, 1, 0, 0, 0, 8167, 8172,
		3, 1026, 513, 0, 8168, 8169, 5, 3, 0, 0, 8169, 8171, 3, 1026, 513, 0, 8170,
		8168, 1, 0, 0, 0, 8171, 8174, 1, 0, 0, 0, 8172, 8170, 1, 0, 0, 0, 8172,
		8173, 1, 0, 0, 0, 8173, 1029, 1, 0, 0, 0, 8174, 8172, 1, 0, 0, 0, 8175,
		8179, 5, 502, 0, 0, 8176, 8179, 3, 1018, 509, 0, 8177, 8179, 3, 976, 488,
		0, 8178, 8175, 1, 0, 0, 0, 8178, 8176, 1, 0, 0, 0, 8178, 8177, 1, 0, 0,
		0, 8179, 1031, 1, 0, 0, 0, 8180, 8192, 3, 1026, 513, 0, 8181, 8182, 3,
		1026, 513, 0, 8182, 8183, 5, 517, 0, 0, 8183, 8184, 3, 1026, 513, 0, 8184,
		8192, 1, 0, 0, 0, 8185, 8186, 3, 1026, 513, 0, 8186, 8187, 5, 517, 0, 0,
		8187, 8188, 5, 6, 0, 0, 8188, 8189, 3, 1026, 513, 0, 8189, 8190, 5, 7,
		0, 0, 8190, 8192, 1, 0, 0, 0, 8191, 8180, 1, 0, 0, 0, 8191, 8181, 1, 0,
		0, 0, 8191, 8185, 1, 0, 0, 0, 8192, 1033, 1, 0, 0, 0, 8193, 8194, 3, 1018,
		509, 0, 8194, 8195, 5, 492, 0, 0, 8195, 8196, 3, 844, 422, 0, 8196, 1035,
		1, 0, 0, 0, 8197, 8202, 3, 1034, 517, 0, 8198, 8199, 5, 3, 0, 0, 8199,
		8201, 3, 1034, 517, 0, 8200, 8198, 1, 0, 0, 0, 8201, 8204, 1, 0, 0, 0,
		8202, 8200, 1, 0, 0, 0, 8202, 8203, 1, 0, 0, 0, 8203, 1037, 1, 0, 0, 0,
		8204, 8202, 1, 0, 0, 0, 8205, 8209, 5, 519, 0, 0, 8206, 8209, 5, 520, 0,
		0, 8207, 8209, 5, 518, 0, 0, 8208, 8205, 1, 0, 0, 0, 8208, 8206, 1, 0,
		0, 0, 8208, 8207, 1, 0, 0, 0, 8209, 1039, 1, 0, 0, 0, 8210, 8211, 7, 64,
		0, 0, 8211, 1041, 1, 0, 0, 0, 975, 1045, 1053, 1297, 1313, 1319, 1327,
		1329, 1347, 1354, 1359, 1363, 1366, 1369, 1375, 1380, 1384, 1407, 1415,
		1419, 1425, 1434, 1441, 1446, 1449, 1452, 1455, 1458, 1461, 1464, 1467,
		1470, 1473, 1477, 1480, 1483, 1486, 1489, 1494, 1497, 1507, 1519, 1529,
		1531, 1534, 1541, 1548, 1551, 1556, 1560, 1575, 1579, 1588, 1602, 1611,
		1619, 1622, 1625, 1636, 1641, 1645, 1651, 1660, 1667, 1675, 1678, 1682,
		1685, 1688, 1691, 1694, 1697, 1700, 1707, 1712, 1716, 1733, 1746, 1759,
		1762, 1772, 1774, 1777, 1790, 1795, 1801, 1808, 1814, 1822, 1828, 1836,
		1842, 1849, 1855, 1868, 1873, 1881, 1885, 1894, 1897, 1900, 1908, 1912,
		1921, 1924, 1927, 1929, 1934, 1938, 1942, 1948, 1952, 1955, 1958, 1970,
		1980, 1986, 1996, 2000, 2008, 2012, 2019, 2028, 2031, 2034, 2045, 2051,
		2060, 2065, 2068, 2072, 2086, 2091, 2116, 2122, 2128, 2133, 2138, 2145,
		2149, 2155, 2163, 2176, 2185, 2192, 2197, 2200, 2205, 2218, 2223, 2232,
		2239, 2245, 2252, 2264, 2272, 2281, 2283, 2286, 2291, 2296, 2304, 2315,
		2329, 2338, 2347, 2351, 2358, 2366, 2384, 2393, 2396, 2400, 2413, 2434,
		2447, 2451, 2464, 2472, 2485, 2491, 2494, 2509, 2516, 2529, 2534, 2564,
		2566, 2572, 2574, 2580, 2585, 2598, 2603, 2609, 2618, 2631, 2683, 2707,
		2715, 2717, 2726, 2734, 2736, 2739, 2748, 2764, 2774, 2782, 2784, 2794,
		2802, 2804, 2814, 2825, 2832, 2839, 2856, 2871, 2885, 2900, 2913, 2915,
		2918, 2944, 2947, 2950, 2953, 2956, 2959, 2967, 2971, 2974, 2984, 2990,
		2993, 3000, 3003, 3011, 3015, 3018, 3036, 3039, 3047, 3052, 3056, 3062,
		3064, 3076, 3079, 3088, 3092, 3104, 3109, 3113, 3125, 3130, 3136, 3144,
		3155, 3158, 3164, 3167, 3170, 3186, 3208, 3222, 3227, 3230, 3233, 3237,
		3241, 3244, 3247, 3249, 3253, 3258, 3264, 3267, 3270, 3274, 3279, 3283,
		3287, 3292, 3297, 3304, 3306, 3318, 3325, 3332, 3340, 3346, 3349, 3356,
		3361, 3365, 3374, 3377, 3383, 3388, 3391, 3394, 3403, 3406, 3409, 3415,
		3419, 3423, 3431, 3441, 3444, 3447, 3452, 3461, 3469, 3472, 3475, 3478,
		3490, 3508, 3513, 3517, 3533, 3544, 3555, 3561, 3569, 3572, 3576, 3580,
		3589, 3592, 3595, 3603, 3615, 3621, 3629, 3632, 3636, 3640, 3649, 3652,
		3655, 3659, 3664, 3667, 3672, 3675, 3683, 3693, 3708, 3713, 3718, 3733,
		3736, 3742, 3755, 3761, 3765, 3770, 3775, 3780, 3790, 3795, 3798, 3802,
		3811, 3816, 3820, 3829, 3832, 3835, 3840, 3846, 3855, 3858, 3861, 3868,
		3877, 3880, 3883, 3903, 3906, 3910, 3915, 3920, 3929, 3941, 3945, 3954,
		3957, 3966, 3986, 4000, 4023, 4028, 4032, 4039, 4044, 4046, 4057, 4061,
		4066, 4087, 4090, 4095, 4101, 4105, 4110, 4120, 4123, 4135, 4138, 4144,
		4150, 4155, 4161, 4164, 4168, 4172, 4178, 4183, 4185, 4190, 4200, 4209,
		4215, 4221, 4227, 4230, 4233, 4236, 4243, 4247, 4251, 4258, 4264, 4268,
		4272, 4274, 4280, 4285, 4290, 4295, 4302, 4308, 4310, 4316, 4321, 4325,
		4329, 4338, 4341, 4344, 4351, 4355, 4358, 4365, 4371, 4375, 4383, 4387,
		4409, 4415, 4423, 4429, 4437, 4443, 4449, 4477, 4485, 4490, 4496, 4503,
		4507, 4514, 4524, 4528, 4537, 4540, 4543, 4545, 4551, 4555, 4559, 4564,
		4570, 4576, 4580, 4586, 4590, 4592, 4596, 4603, 4608, 4618, 4622, 4627,
		4630, 4636, 4644, 4653, 4661, 4667, 4673, 4685, 4687, 4695, 4702, 4706,
		4712, 4724, 4735, 4745, 4751, 4761, 4774, 4779, 4787, 4793, 4798, 4809,
		4817, 4828, 4834, 4843, 4854, 4866, 4879, 4886, 4888, 4899, 4916, 4949,
		4954, 4962, 4970, 4975, 4983, 4985, 4990, 4997, 5012, 5020, 5025, 5049,
		5066, 5082, 5102, 5160, 5164, 5177, 5182, 5186, 5195, 5201, 5214, 5220,
		5222, 5231, 5236, 5240, 5249, 5255, 5259, 5267, 5272, 5279, 5286, 5303,
		5320, 5331, 5350, 5355, 5359, 5381, 5388, 5391, 5397, 5404, 5407, 5410,
		5416, 5422, 5428, 5434, 5443, 5446, 5449, 5456, 5467, 5476, 5484, 5492,
		5501, 5514, 5533, 5542, 5545, 5548, 5556, 5564, 5568, 5573, 5578, 5580,
		5590, 5602, 5609, 5620, 5624, 5636, 5642, 5655, 5661, 5667, 5676, 5692,
		5697, 5701, 5704, 5710, 5713, 5716, 5743, 5747, 5750, 5756, 5764, 5772,
		5778, 5782, 5790, 5804, 5813, 5815, 5830, 5834, 5837, 5846, 5850, 5879,
		5883, 5885, 5889, 5893, 5896, 5899, 5902, 5906, 5910, 5913, 5916, 5919,
		5930, 5934, 5938, 5941, 5951, 5962, 5965, 5968, 5971, 5980, 5989, 5995,
		6002, 6009, 6014, 6020, 6023, 6025, 6038, 6042, 6047, 6053, 6060, 6064,
		6071, 6077, 6082, 6086, 6093, 6098, 6100, 6104, 6109, 6115, 6126, 6132,
		6136, 6142, 6149, 6160, 6164, 6166, 6172, 6176, 6178, 6187, 6195, 6200,
		6207, 6215, 6220, 6224, 6227, 6230, 6233, 6236, 6239, 6242, 6245, 6249,
		6258, 6263, 6267, 6269, 6273, 6277, 6279, 6286, 6290, 6292, 6302, 6306,
		6308, 6313, 6317, 6319, 6325, 6334, 6340, 6349, 6357, 6361, 6363, 6367,
		6370, 6374, 6376, 6380, 6384, 6391, 6400, 6403, 6407, 6411, 6414, 6419,
		6427, 6456, 6464, 6476, 6491, 6496, 6504, 6510, 6519, 6525, 6530, 6539,
		6551, 6563, 6575, 6578, 6591, 6602, 6609, 6616, 6628, 6633, 6641, 6643,
		6651, 6660, 6673, 6675, 6680, 6683, 6691, 6695, 6703, 6711, 6719, 6727,
		6731, 6760, 6762, 6814, 6818, 6826, 6830, 6835, 6839, 6845, 6852, 6857,
		6866, 6870, 6877, 6885, 6891, 6901, 6905, 6911, 6913, 6926, 6942, 6945,
		6955, 6958, 6966, 6978, 6981, 6991, 6994, 6998, 7000, 7005, 7013, 7020,
		7022, 7029, 7032, 7038, 7046, 7054, 7062, 7072, 7075, 7089, 7092, 7099,
		7106, 7116, 7119, 7123, 7127, 7137, 7158, 7163, 7168, 7170, 7175, 7180,
		7185, 7188, 7193, 7198, 7200, 7224, 7227, 7280, 7283, 7343, 7363, 7370,
		7376, 7379, 7383, 7389, 7395, 7398, 7402, 7408, 7414, 7417, 7421, 7427,
		7433, 7436, 7440, 7442, 7452, 7461, 7464, 7473, 7476, 7479, 7502, 7513,
		7522, 7524, 7530, 7540, 7542, 7550, 7552, 7554, 7558, 7562, 7566, 7570,
		7575, 7579, 7591, 7594, 7608, 7611, 7618, 7627, 7630, 7637, 7649, 7652,
		7666, 7669, 7673, 7679, 7686, 7692, 7699, 7707, 7718, 7725, 7729, 7737,
		7748, 7755, 7761, 7767, 7795, 7810, 7818, 7826, 7837, 7845, 7851, 7859,
		7870, 7872, 7876, 7885, 7894, 7905, 7919, 7929, 7940, 7956, 7959, 7965,
		7994, 8010, 8019, 8034, 8038, 8042, 8046, 8050, 8054, 8058, 8062, 8066,
		8070, 8079, 8083, 8093, 8097, 8099, 8106, 8109, 8115, 8117, 8123, 8134,
		8139, 8147, 8158, 8165, 8172, 8178, 8191, 8202, 8208,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// DorisSQLParserParserInit initializes any static state used to implement DorisSQLParserParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewDorisSQLParserParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func DorisSQLParserParserInit() {
	staticData := &DorisSQLParserParserStaticData
	staticData.once.Do(dorissqlparserParserInit)
}

// NewDorisSQLParserParser produces a new parser instance for the optional input antlr.TokenStream.
func NewDorisSQLParserParser(input antlr.TokenStream) *DorisSQLParserParser {
	DorisSQLParserParserInit()
	this := new(DorisSQLParserParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &DorisSQLParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "DorisSQLParser.g4"

	return this
}

// DorisSQLParserParser tokens.
const (
	DorisSQLParserParserEOF                       = antlr.TokenEOF
	DorisSQLParserParserT__0                      = 1
	DorisSQLParserParserT__1                      = 2
	DorisSQLParserParserT__2                      = 3
	DorisSQLParserParserT__3                      = 4
	DorisSQLParserParserT__4                      = 5
	DorisSQLParserParserT__5                      = 6
	DorisSQLParserParserT__6                      = 7
	DorisSQLParserParserT__7                      = 8
	DorisSQLParserParserT__8                      = 9
	DorisSQLParserParserT__9                      = 10
	DorisSQLParserParserACCESS                    = 11
	DorisSQLParserParserACTIVE                    = 12
	DorisSQLParserParserADD                       = 13
	DorisSQLParserParserADMIN                     = 14
	DorisSQLParserParserADVISOR                   = 15
	DorisSQLParserParserAFTER                     = 16
	DorisSQLParserParserAGGREGATE                 = 17
	DorisSQLParserParserALL                       = 18
	DorisSQLParserParserALTER                     = 19
	DorisSQLParserParserANALYZE                   = 20
	DorisSQLParserParserAND                       = 21
	DorisSQLParserParserANTI                      = 22
	DorisSQLParserParserAPPLY                     = 23
	DorisSQLParserParserARRAY                     = 24
	DorisSQLParserParserARRAY_AGG                 = 25
	DorisSQLParserParserARRAY_AGG_DISTINCT        = 26
	DorisSQLParserParserAS                        = 27
	DorisSQLParserParserASC                       = 28
	DorisSQLParserParserASYNC                     = 29
	DorisSQLParserParserAUTHORS                   = 30
	DorisSQLParserParserAUTHENTICATION            = 31
	DorisSQLParserParserAUTOMATED                 = 32
	DorisSQLParserParserAUTO_INCREMENT            = 33
	DorisSQLParserParserAVG                       = 34
	DorisSQLParserParserBACKEND                   = 35
	DorisSQLParserParserBACKENDS                  = 36
	DorisSQLParserParserBACKUP                    = 37
	DorisSQLParserParserBASE                      = 38
	DorisSQLParserParserBASELINE                  = 39
	DorisSQLParserParserBEGIN                     = 40
	DorisSQLParserParserBETWEEN                   = 41
	DorisSQLParserParserBIGINT                    = 42
	DorisSQLParserParserBINARY                    = 43
	DorisSQLParserParserBITMAP                    = 44
	DorisSQLParserParserBITMAP_UNION              = 45
	DorisSQLParserParserBLACKHOLE                 = 46
	DorisSQLParserParserBLACKLIST                 = 47
	DorisSQLParserParserBODY                      = 48
	DorisSQLParserParserBOOLEAN                   = 49
	DorisSQLParserParserBOTH                      = 50
	DorisSQLParserParserBRANCH                    = 51
	DorisSQLParserParserBROKER                    = 52
	DorisSQLParserParserBUCKETS                   = 53
	DorisSQLParserParserBUILTIN                   = 54
	DorisSQLParserParserBY                        = 55
	DorisSQLParserParserCACHE                     = 56
	DorisSQLParserParserCANCEL                    = 57
	DorisSQLParserParserCASE                      = 58
	DorisSQLParserParserCAST                      = 59
	DorisSQLParserParserCATALOG                   = 60
	DorisSQLParserParserCATALOGS                  = 61
	DorisSQLParserParserCEIL                      = 62
	DorisSQLParserParserCHAIN                     = 63
	DorisSQLParserParserCHAR                      = 64
	DorisSQLParserParserCHARACTER                 = 65
	DorisSQLParserParserCHARSET                   = 66
	DorisSQLParserParserCHECK                     = 67
	DorisSQLParserParserCLEAN                     = 68
	DorisSQLParserParserCLEAR                     = 69
	DorisSQLParserParserCLUSTER                   = 70
	DorisSQLParserParserCLUSTERS                  = 71
	DorisSQLParserParserCNGROUP                   = 72
	DorisSQLParserParserCNGROUPS                  = 73
	DorisSQLParserParserCOLLATE                   = 74
	DorisSQLParserParserCOLLATION                 = 75
	DorisSQLParserParserCOLUMN                    = 76
	DorisSQLParserParserCOLUMNS                   = 77
	DorisSQLParserParserCOMMENT                   = 78
	DorisSQLParserParserCOMMIT                    = 79
	DorisSQLParserParserCOMMITTED                 = 80
	DorisSQLParserParserCOMPACT                   = 81
	DorisSQLParserParserCOMPACTION                = 82
	DorisSQLParserParserCOMPUTE                   = 83
	DorisSQLParserParserCONFIG                    = 84
	DorisSQLParserParserCONNECTION                = 85
	DorisSQLParserParserCONSISTENT                = 86
	DorisSQLParserParserCONVERT                   = 87
	DorisSQLParserParserCOSTS                     = 88
	DorisSQLParserParserCOUNT                     = 89
	DorisSQLParserParserCREATE                    = 90
	DorisSQLParserParserCROSS                     = 91
	DorisSQLParserParserCUBE                      = 92
	DorisSQLParserParserCUME_DIST                 = 93
	DorisSQLParserParserCUMULATIVE                = 94
	DorisSQLParserParserCURRENT                   = 95
	DorisSQLParserParserCURRENT_DATE              = 96
	DorisSQLParserParserCURRENT_GROUP             = 97
	DorisSQLParserParserCURRENT_ROLE              = 98
	DorisSQLParserParserCURRENT_TIME              = 99
	DorisSQLParserParserCURRENT_TIMESTAMP         = 100
	DorisSQLParserParserCURRENT_USER              = 101
	DorisSQLParserParserDATA                      = 102
	DorisSQLParserParserDATACACHE                 = 103
	DorisSQLParserParserDATABASE                  = 104
	DorisSQLParserParserDATABASES                 = 105
	DorisSQLParserParserDATE                      = 106
	DorisSQLParserParserDATETIME                  = 107
	DorisSQLParserParserDAY                       = 108
	DorisSQLParserParserDAYS                      = 109
	DorisSQLParserParserDEALLOCATE                = 110
	DorisSQLParserParserDECIMAL                   = 111
	DorisSQLParserParserDECIMALV2                 = 112
	DorisSQLParserParserDECIMAL32                 = 113
	DorisSQLParserParserDECIMAL64                 = 114
	DorisSQLParserParserDECIMAL128                = 115
	DorisSQLParserParserDECOMMISSION              = 116
	DorisSQLParserParserDEFAULT                   = 117
	DorisSQLParserParserDELETE                    = 118
	DorisSQLParserParserDENSE_RANK                = 119
	DorisSQLParserParserDEFERRED                  = 120
	DorisSQLParserParserDIALECT                   = 121
	DorisSQLParserParserDICTIONARY                = 122
	DorisSQLParserParserDICTIONARY_GET            = 123
	DorisSQLParserParserNTILE                     = 124
	DorisSQLParserParserDESC                      = 125
	DorisSQLParserParserDESCRIBE                  = 126
	DorisSQLParserParserDISABLE                   = 127
	DorisSQLParserParserDISTINCT                  = 128
	DorisSQLParserParserDISTRIBUTED               = 129
	DorisSQLParserParserDISTRIBUTION              = 130
	DorisSQLParserParserDOUBLE                    = 131
	DorisSQLParserParserDROP                      = 132
	DorisSQLParserParserDUAL                      = 133
	DorisSQLParserParserDUPLICATE                 = 134
	DorisSQLParserParserDYNAMIC                   = 135
	DorisSQLParserParserELSE                      = 136
	DorisSQLParserParserENABLE                    = 137
	DorisSQLParserParserENCLOSE                   = 138
	DorisSQLParserParserEND                       = 139
	DorisSQLParserParserENGINE                    = 140
	DorisSQLParserParserENGINES                   = 141
	DorisSQLParserParserERRORS                    = 142
	DorisSQLParserParserESCAPE                    = 143
	DorisSQLParserParserEVENTS                    = 144
	DorisSQLParserParserEXCEPT                    = 145
	DorisSQLParserParserEXCLUDE                   = 146
	DorisSQLParserParserEXECUTE                   = 147
	DorisSQLParserParserEXISTS                    = 148
	DorisSQLParserParserEXPLAIN                   = 149
	DorisSQLParserParserEXPORT                    = 150
	DorisSQLParserParserEXTERNAL                  = 151
	DorisSQLParserParserEXTRACT                   = 152
	DorisSQLParserParserEVERY                     = 153
	DorisSQLParserParserFAILPOINT                 = 154
	DorisSQLParserParserFAILPOINTS                = 155
	DorisSQLParserParserFALSE                     = 156
	DorisSQLParserParserFIELDS                    = 157
	DorisSQLParserParserFILE                      = 158
	DorisSQLParserParserFILES                     = 159
	DorisSQLParserParserFILTER                    = 160
	DorisSQLParserParserFIRST                     = 161
	DorisSQLParserParserFIRST_VALUE               = 162
	DorisSQLParserParserFLOAT                     = 163
	DorisSQLParserParserFLOOR                     = 164
	DorisSQLParserParserFN                        = 165
	DorisSQLParserParserFOLLOWING                 = 166
	DorisSQLParserParserFOLLOWER                  = 167
	DorisSQLParserParserFOR                       = 168
	DorisSQLParserParserFORCE                     = 169
	DorisSQLParserParserFORMAT                    = 170
	DorisSQLParserParserFREE                      = 171
	DorisSQLParserParserFROM                      = 172
	DorisSQLParserParserFRONTEND                  = 173
	DorisSQLParserParserFRONTENDS                 = 174
	DorisSQLParserParserFULL                      = 175
	DorisSQLParserParserFUNCTION                  = 176
	DorisSQLParserParserFUNCTIONS                 = 177
	DorisSQLParserParserGLOBAL                    = 178
	DorisSQLParserParserGRANT                     = 179
	DorisSQLParserParserGRANTS                    = 180
	DorisSQLParserParserGROUP                     = 181
	DorisSQLParserParserGROUPS                    = 182
	DorisSQLParserParserGROUPING                  = 183
	DorisSQLParserParserGROUPING_ID               = 184
	DorisSQLParserParserGROUP_CONCAT              = 185
	DorisSQLParserParserHASH                      = 186
	DorisSQLParserParserHAVING                    = 187
	DorisSQLParserParserHELP                      = 188
	DorisSQLParserParserHISTOGRAM                 = 189
	DorisSQLParserParserHLL                       = 190
	DorisSQLParserParserHLL_UNION                 = 191
	DorisSQLParserParserHOST                      = 192
	DorisSQLParserParserHOUR                      = 193
	DorisSQLParserParserHOURS                     = 194
	DorisSQLParserParserHUB                       = 195
	DorisSQLParserParserIDENTIFIED                = 196
	DorisSQLParserParserIF                        = 197
	DorisSQLParserParserIMPERSONATE               = 198
	DorisSQLParserParserIMMEDIATE                 = 199
	DorisSQLParserParserIGNORE                    = 200
	DorisSQLParserParserIMAGE                     = 201
	DorisSQLParserParserIN                        = 202
	DorisSQLParserParserINACTIVE                  = 203
	DorisSQLParserParserINCREMENTAL               = 204
	DorisSQLParserParserINDEX                     = 205
	DorisSQLParserParserINDEXES                   = 206
	DorisSQLParserParserINFILE                    = 207
	DorisSQLParserParserINNER                     = 208
	DorisSQLParserParserINSTALL                   = 209
	DorisSQLParserParserINSERT                    = 210
	DorisSQLParserParserINT                       = 211
	DorisSQLParserParserINTEGER                   = 212
	DorisSQLParserParserINTEGRATION               = 213
	DorisSQLParserParserINTEGRATIONS              = 214
	DorisSQLParserParserINTERMEDIATE              = 215
	DorisSQLParserParserINTERSECT                 = 216
	DorisSQLParserParserINTERVAL                  = 217
	DorisSQLParserParserINTO                      = 218
	DorisSQLParserParserINVOKER                   = 219
	DorisSQLParserParserGIN                       = 220
	DorisSQLParserParserOVERWRITE                 = 221
	DorisSQLParserParserIS                        = 222
	DorisSQLParserParserISOLATION                 = 223
	DorisSQLParserParserJOB                       = 224
	DorisSQLParserParserJOIN                      = 225
	DorisSQLParserParserJSON                      = 226
	DorisSQLParserParserKEY                       = 227
	DorisSQLParserParserKEYS                      = 228
	DorisSQLParserParserKILL                      = 229
	DorisSQLParserParserLABEL                     = 230
	DorisSQLParserParserLAG                       = 231
	DorisSQLParserParserLARGEINT                  = 232
	DorisSQLParserParserLAST                      = 233
	DorisSQLParserParserLAST_VALUE                = 234
	DorisSQLParserParserLATERAL                   = 235
	DorisSQLParserParserLEAD                      = 236
	DorisSQLParserParserLEFT                      = 237
	DorisSQLParserParserLESS                      = 238
	DorisSQLParserParserLEVEL                     = 239
	DorisSQLParserParserLIKE                      = 240
	DorisSQLParserParserLIMIT                     = 241
	DorisSQLParserParserLIST                      = 242
	DorisSQLParserParserLOAD                      = 243
	DorisSQLParserParserLOCAL                     = 244
	DorisSQLParserParserLOCALTIME                 = 245
	DorisSQLParserParserLOCALTIMESTAMP            = 246
	DorisSQLParserParserLOCATION                  = 247
	DorisSQLParserParserLOCATIONS                 = 248
	DorisSQLParserParserLOGS                      = 249
	DorisSQLParserParserLOGICAL                   = 250
	DorisSQLParserParserMANUAL                    = 251
	DorisSQLParserParserMAP                       = 252
	DorisSQLParserParserMAPPING                   = 253
	DorisSQLParserParserMAPPINGS                  = 254
	DorisSQLParserParserMASKING                   = 255
	DorisSQLParserParserMATCH                     = 256
	DorisSQLParserParserMATERIALIZED              = 257
	DorisSQLParserParserMAX                       = 258
	DorisSQLParserParserMAXVALUE                  = 259
	DorisSQLParserParserMERGE                     = 260
	DorisSQLParserParserMICROSECOND               = 261
	DorisSQLParserParserMILLISECOND               = 262
	DorisSQLParserParserMIN                       = 263
	DorisSQLParserParserMINUTE                    = 264
	DorisSQLParserParserMINUTES                   = 265
	DorisSQLParserParserMINUS                     = 266
	DorisSQLParserParserMETA                      = 267
	DorisSQLParserParserMOD                       = 268
	DorisSQLParserParserMODE                      = 269
	DorisSQLParserParserMODIFY                    = 270
	DorisSQLParserParserMONTH                     = 271
	DorisSQLParserParserMULTIPLE                  = 272
	DorisSQLParserParserNAME                      = 273
	DorisSQLParserParserNAMES                     = 274
	DorisSQLParserParserNEGATIVE                  = 275
	DorisSQLParserParserNGRAMBF                   = 276
	DorisSQLParserParserNO                        = 277
	DorisSQLParserParserNODE                      = 278
	DorisSQLParserParserNODES                     = 279
	DorisSQLParserParserNONE                      = 280
	DorisSQLParserParserNOT                       = 281
	DorisSQLParserParserNULL                      = 282
	DorisSQLParserParserNULLS                     = 283
	DorisSQLParserParserNUMBER                    = 284
	DorisSQLParserParserNUMERIC                   = 285
	DorisSQLParserParserOBSERVER                  = 286
	DorisSQLParserParserOF                        = 287
	DorisSQLParserParserOFF                       = 288
	DorisSQLParserParserOFFSET                    = 289
	DorisSQLParserParserON                        = 290
	DorisSQLParserParserONLY                      = 291
	DorisSQLParserParserOPEN                      = 292
	DorisSQLParserParserOPERATE                   = 293
	DorisSQLParserParserOPTIMIZE                  = 294
	DorisSQLParserParserOPTIMIZER                 = 295
	DorisSQLParserParserOPTION                    = 296
	DorisSQLParserParserOR                        = 297
	DorisSQLParserParserORDER                     = 298
	DorisSQLParserParserOUTER                     = 299
	DorisSQLParserParserOUTFILE                   = 300
	DorisSQLParserParserOVER                      = 301
	DorisSQLParserParserPARAMETER                 = 302
	DorisSQLParserParserPARTITION                 = 303
	DorisSQLParserParserPARTITIONS                = 304
	DorisSQLParserParserPASSWORD                  = 305
	DorisSQLParserParserPATH                      = 306
	DorisSQLParserParserPAUSE                     = 307
	DorisSQLParserParserPENDING                   = 308
	DorisSQLParserParserPERCENT_RANK              = 309
	DorisSQLParserParserPERCENTILE                = 310
	DorisSQLParserParserPERCENTILE_UNION          = 311
	DorisSQLParserParserPLAN                      = 312
	DorisSQLParserParserPLUGIN                    = 313
	DorisSQLParserParserPLUGINS                   = 314
	DorisSQLParserParserPIPE                      = 315
	DorisSQLParserParserPIPES                     = 316
	DorisSQLParserParserPIVOT                     = 317
	DorisSQLParserParserPOLICY                    = 318
	DorisSQLParserParserPOLICIES                  = 319
	DorisSQLParserParserPRECEDING                 = 320
	DorisSQLParserParserPREDICATE                 = 321
	DorisSQLParserParserPREPARE                   = 322
	DorisSQLParserParserPRIMARY                   = 323
	DorisSQLParserParserPRIORITY                  = 324
	DorisSQLParserParserPRIVILEGES                = 325
	DorisSQLParserParserPROBABILITY               = 326
	DorisSQLParserParserPROC                      = 327
	DorisSQLParserParserPROCEDURE                 = 328
	DorisSQLParserParserPROCESSLIST               = 329
	DorisSQLParserParserPROFILE                   = 330
	DorisSQLParserParserPROFILELIST               = 331
	DorisSQLParserParserPROPERTIES                = 332
	DorisSQLParserParserPROPERTY                  = 333
	DorisSQLParserParserPROVIDER                  = 334
	DorisSQLParserParserPROVIDERS                 = 335
	DorisSQLParserParserQUALIFY                   = 336
	DorisSQLParserParserQUARTER                   = 337
	DorisSQLParserParserQUERY                     = 338
	DorisSQLParserParserQUERIES                   = 339
	DorisSQLParserParserQUEUE                     = 340
	DorisSQLParserParserQUOTA                     = 341
	DorisSQLParserParserRANDOM                    = 342
	DorisSQLParserParserRANGE                     = 343
	DorisSQLParserParserRANK                      = 344
	DorisSQLParserParserREAD                      = 345
	DorisSQLParserParserREASON                    = 346
	DorisSQLParserParserRECOVER                   = 347
	DorisSQLParserParserREFRESH                   = 348
	DorisSQLParserParserREWRITE                   = 349
	DorisSQLParserParserREGEXP                    = 350
	DorisSQLParserParserRELEASE                   = 351
	DorisSQLParserParserREMOVE                    = 352
	DorisSQLParserParserRENAME                    = 353
	DorisSQLParserParserREPAIR                    = 354
	DorisSQLParserParserREPEATABLE                = 355
	DorisSQLParserParserREPLACE                   = 356
	DorisSQLParserParserREPLACE_IF_NOT_NULL       = 357
	DorisSQLParserParserREPLICA                   = 358
	DorisSQLParserParserREPOSITORY                = 359
	DorisSQLParserParserREPOSITORIES              = 360
	DorisSQLParserParserRESOURCE                  = 361
	DorisSQLParserParserRESOURCES                 = 362
	DorisSQLParserParserRESTORE                   = 363
	DorisSQLParserParserRESUME                    = 364
	DorisSQLParserParserRETAIN                    = 365
	DorisSQLParserParserRETENTION                 = 366
	DorisSQLParserParserRETURNS                   = 367
	DorisSQLParserParserRETRY                     = 368
	DorisSQLParserParserREVOKE                    = 369
	DorisSQLParserParserREVERT                    = 370
	DorisSQLParserParserRIGHT                     = 371
	DorisSQLParserParserRLIKE                     = 372
	DorisSQLParserParserROLE                      = 373
	DorisSQLParserParserROLES                     = 374
	DorisSQLParserParserROLLBACK                  = 375
	DorisSQLParserParserROLLUP                    = 376
	DorisSQLParserParserROUTINE                   = 377
	DorisSQLParserParserROW                       = 378
	DorisSQLParserParserROWS                      = 379
	DorisSQLParserParserROW_NUMBER                = 380
	DorisSQLParserParserRULE                      = 381
	DorisSQLParserParserRULES                     = 382
	DorisSQLParserParserRUNNING                   = 383
	DorisSQLParserParserSAMPLE                    = 384
	DorisSQLParserParserSCHEDULE                  = 385
	DorisSQLParserParserSCHEDULER                 = 386
	DorisSQLParserParserSCHEMA                    = 387
	DorisSQLParserParserSCHEMAS                   = 388
	DorisSQLParserParserSECOND                    = 389
	DorisSQLParserParserSECURITY                  = 390
	DorisSQLParserParserSELECT                    = 391
	DorisSQLParserParserSEMI                      = 392
	DorisSQLParserParserSEPARATOR                 = 393
	DorisSQLParserParserSERIALIZABLE              = 394
	DorisSQLParserParserSESSION                   = 395
	DorisSQLParserParserSET                       = 396
	DorisSQLParserParserSETS                      = 397
	DorisSQLParserParserSET_VAR                   = 398
	DorisSQLParserParserSIGNED                    = 399
	DorisSQLParserParserSKIP_HEADER               = 400
	DorisSQLParserParserSHOW                      = 401
	DorisSQLParserParserSMALLINT                  = 402
	DorisSQLParserParserSNAPSHOT                  = 403
	DorisSQLParserParserSNAPSHOTS                 = 404
	DorisSQLParserParserSQLBLACKLIST              = 405
	DorisSQLParserParserSTART                     = 406
	DorisSQLParserParserSTATS                     = 407
	DorisSQLParserParserSTATUS                    = 408
	DorisSQLParserParserSTOP                      = 409
	DorisSQLParserParserSTORAGE                   = 410
	DorisSQLParserParserSTREAM                    = 411
	DorisSQLParserParserSTRING                    = 412
	DorisSQLParserParserTEXT                      = 413
	DorisSQLParserParserSUBMIT                    = 414
	DorisSQLParserParserSUM                       = 415
	DorisSQLParserParserSUSPEND                   = 416
	DorisSQLParserParserSYNC                      = 417
	DorisSQLParserParserSYSTEM                    = 418
	DorisSQLParserParserSYSTEM_TIME               = 419
	DorisSQLParserParserSWAP                      = 420
	DorisSQLParserParserSTRUCT                    = 421
	DorisSQLParserParserTABLE                     = 422
	DorisSQLParserParserTABLES                    = 423
	DorisSQLParserParserTABLET                    = 424
	DorisSQLParserParserTABLETS                   = 425
	DorisSQLParserParserTAG                       = 426
	DorisSQLParserParserTASK                      = 427
	DorisSQLParserParserTEMPORARY                 = 428
	DorisSQLParserParserTERMINATED                = 429
	DorisSQLParserParserTHAN                      = 430
	DorisSQLParserParserTHEN                      = 431
	DorisSQLParserParserTIME                      = 432
	DorisSQLParserParserTIMES                     = 433
	DorisSQLParserParserTIMESTAMP                 = 434
	DorisSQLParserParserTIMESTAMPADD              = 435
	DorisSQLParserParserTIMESTAMPDIFF             = 436
	DorisSQLParserParserTINYINT                   = 437
	DorisSQLParserParserTRANSACTION               = 438
	DorisSQLParserParserTRANSLATE                 = 439
	DorisSQLParserParserTO                        = 440
	DorisSQLParserParserTRACE                     = 441
	DorisSQLParserParserTRIGGERS                  = 442
	DorisSQLParserParserTRIM_SPACE                = 443
	DorisSQLParserParserTRUE                      = 444
	DorisSQLParserParserTRUNCATE                  = 445
	DorisSQLParserParserTYPE                      = 446
	DorisSQLParserParserTYPES                     = 447
	DorisSQLParserParserUNBOUNDED                 = 448
	DorisSQLParserParserUNCOMMITTED               = 449
	DorisSQLParserParserUNION                     = 450
	DorisSQLParserParserUNIQUE                    = 451
	DorisSQLParserParserUNINSTALL                 = 452
	DorisSQLParserParserUNSET                     = 453
	DorisSQLParserParserUNSIGNED                  = 454
	DorisSQLParserParserUPDATE                    = 455
	DorisSQLParserParserUSAGE                     = 456
	DorisSQLParserParserUSE                       = 457
	DorisSQLParserParserUSER                      = 458
	DorisSQLParserParserUSERS                     = 459
	DorisSQLParserParserUSING                     = 460
	DorisSQLParserParserVALUE                     = 461
	DorisSQLParserParserVALUES                    = 462
	DorisSQLParserParserVARBINARY                 = 463
	DorisSQLParserParserVARCHAR                   = 464
	DorisSQLParserParserVARIABLES                 = 465
	DorisSQLParserParserVECTOR                    = 466
	DorisSQLParserParserVERBOSE                   = 467
	DorisSQLParserParserVERSION                   = 468
	DorisSQLParserParserVIEW                      = 469
	DorisSQLParserParserVIEWS                     = 470
	DorisSQLParserParserVOLUME                    = 471
	DorisSQLParserParserVOLUMES                   = 472
	DorisSQLParserParserWAREHOUSE                 = 473
	DorisSQLParserParserWAREHOUSES                = 474
	DorisSQLParserParserWARNINGS                  = 475
	DorisSQLParserParserWEEK                      = 476
	DorisSQLParserParserWHEN                      = 477
	DorisSQLParserParserWHERE                     = 478
	DorisSQLParserParserWHITELIST                 = 479
	DorisSQLParserParserWITH                      = 480
	DorisSQLParserParserWORK                      = 481
	DorisSQLParserParserWRITE                     = 482
	DorisSQLParserParserYEAR                      = 483
	DorisSQLParserParserLOCK                      = 484
	DorisSQLParserParserUNLOCK                    = 485
	DorisSQLParserParserLOW_PRIORITY              = 486
	DorisSQLParserParserDISK                      = 487
	DorisSQLParserParserBEFORE                    = 488
	DorisSQLParserParserDOUBLE_DOLLAR             = 489
	DorisSQLParserParserFIELD                     = 490
	DorisSQLParserParserPERSISTENT                = 491
	DorisSQLParserParserEQ                        = 492
	DorisSQLParserParserNEQ                       = 493
	DorisSQLParserParserLT                        = 494
	DorisSQLParserParserLTE                       = 495
	DorisSQLParserParserGT                        = 496
	DorisSQLParserParserGTE                       = 497
	DorisSQLParserParserEQ_FOR_NULL               = 498
	DorisSQLParserParserARRAY_ELEMENT             = 499
	DorisSQLParserParserPLUS_SYMBOL               = 500
	DorisSQLParserParserMINUS_SYMBOL              = 501
	DorisSQLParserParserASTERISK_SYMBOL           = 502
	DorisSQLParserParserSLASH_SYMBOL              = 503
	DorisSQLParserParserPERCENT_SYMBOL            = 504
	DorisSQLParserParserLOGICAL_OR                = 505
	DorisSQLParserParserLOGICAL_AND               = 506
	DorisSQLParserParserLOGICAL_NOT               = 507
	DorisSQLParserParserINT_DIV                   = 508
	DorisSQLParserParserBITAND                    = 509
	DorisSQLParserParserBITOR                     = 510
	DorisSQLParserParserBITXOR                    = 511
	DorisSQLParserParserBITNOT                    = 512
	DorisSQLParserParserBIT_SHIFT_LEFT            = 513
	DorisSQLParserParserBIT_SHIFT_RIGHT           = 514
	DorisSQLParserParserBIT_SHIFT_RIGHT_LOGICAL   = 515
	DorisSQLParserParserARROW                     = 516
	DorisSQLParserParserAT                        = 517
	DorisSQLParserParserINTEGER_VALUE             = 518
	DorisSQLParserParserDECIMAL_VALUE             = 519
	DorisSQLParserParserDOUBLE_VALUE              = 520
	DorisSQLParserParserSINGLE_QUOTED_TEXT        = 521
	DorisSQLParserParserDOUBLE_QUOTED_TEXT        = 522
	DorisSQLParserParserBINARY_SINGLE_QUOTED_TEXT = 523
	DorisSQLParserParserBINARY_DOUBLE_QUOTED_TEXT = 524
	DorisSQLParserParserLETTER_IDENTIFIER         = 525
	DorisSQLParserParserDIGIT_IDENTIFIER          = 526
	DorisSQLParserParserBACKQUOTED_IDENTIFIER     = 527
	DorisSQLParserParserDOT_IDENTIFIER            = 528
	DorisSQLParserParserSIMPLE_COMMENT            = 529
	DorisSQLParserParserBRACKETED_COMMENT         = 530
	DorisSQLParserParserOPTIMIZER_HINT            = 531
	DorisSQLParserParserSEMICOLON                 = 532
	DorisSQLParserParserDOTDOTDOT                 = 533
	DorisSQLParserParserWS                        = 534
	DorisSQLParserParserATTACHMENT                = 535
	DorisSQLParserParserCONCAT                    = 536
)

// DorisSQLParserParser rules.
const (
	DorisSQLParserParserRULE_sqlStatements                          = 0
	DorisSQLParserParserRULE_singleStatement                        = 1
	DorisSQLParserParserRULE_emptyStatement                         = 2
	DorisSQLParserParserRULE_statement                              = 3
	DorisSQLParserParserRULE_useDatabaseStatement                   = 4
	DorisSQLParserParserRULE_useCatalogStatement                    = 5
	DorisSQLParserParserRULE_setCatalogStatement                    = 6
	DorisSQLParserParserRULE_showDatabasesStatement                 = 7
	DorisSQLParserParserRULE_alterDbQuotaStatement                  = 8
	DorisSQLParserParserRULE_createDbStatement                      = 9
	DorisSQLParserParserRULE_dropDbStatement                        = 10
	DorisSQLParserParserRULE_showCreateDbStatement                  = 11
	DorisSQLParserParserRULE_alterDatabaseRenameStatement           = 12
	DorisSQLParserParserRULE_recoverDbStmt                          = 13
	DorisSQLParserParserRULE_showDataStmt                           = 14
	DorisSQLParserParserRULE_showDataDistributionStmt               = 15
	DorisSQLParserParserRULE_createTableStatement                   = 16
	DorisSQLParserParserRULE_columnDesc                             = 17
	DorisSQLParserParserRULE_charsetName                            = 18
	DorisSQLParserParserRULE_defaultDesc                            = 19
	DorisSQLParserParserRULE_generatedColumnDesc                    = 20
	DorisSQLParserParserRULE_indexDesc                              = 21
	DorisSQLParserParserRULE_engineDesc                             = 22
	DorisSQLParserParserRULE_charsetDesc                            = 23
	DorisSQLParserParserRULE_collateDesc                            = 24
	DorisSQLParserParserRULE_keyDesc                                = 25
	DorisSQLParserParserRULE_orderByDesc                            = 26
	DorisSQLParserParserRULE_columnNullable                         = 27
	DorisSQLParserParserRULE_typeWithNullable                       = 28
	DorisSQLParserParserRULE_aggStateDesc                           = 29
	DorisSQLParserParserRULE_aggDesc                                = 30
	DorisSQLParserParserRULE_rollupDesc                             = 31
	DorisSQLParserParserRULE_rollupItem                             = 32
	DorisSQLParserParserRULE_dupKeys                                = 33
	DorisSQLParserParserRULE_fromRollup                             = 34
	DorisSQLParserParserRULE_orReplace                              = 35
	DorisSQLParserParserRULE_ifNotExists                            = 36
	DorisSQLParserParserRULE_createTableAsSelectStatement           = 37
	DorisSQLParserParserRULE_dropTableStatement                     = 38
	DorisSQLParserParserRULE_cleanTemporaryTableStatement           = 39
	DorisSQLParserParserRULE_alterTableStatement                    = 40
	DorisSQLParserParserRULE_createIndexStatement                   = 41
	DorisSQLParserParserRULE_dropIndexStatement                     = 42
	DorisSQLParserParserRULE_indexType                              = 43
	DorisSQLParserParserRULE_showTableStatement                     = 44
	DorisSQLParserParserRULE_showTemporaryTablesStatement           = 45
	DorisSQLParserParserRULE_showCreateTableStatement               = 46
	DorisSQLParserParserRULE_showColumnStatement                    = 47
	DorisSQLParserParserRULE_showTableStatusStatement               = 48
	DorisSQLParserParserRULE_refreshTableStatement                  = 49
	DorisSQLParserParserRULE_showAlterStatement                     = 50
	DorisSQLParserParserRULE_descTableStatement                     = 51
	DorisSQLParserParserRULE_createTableLikeStatement               = 52
	DorisSQLParserParserRULE_showIndexStatement                     = 53
	DorisSQLParserParserRULE_recoverTableStatement                  = 54
	DorisSQLParserParserRULE_truncateTableStatement                 = 55
	DorisSQLParserParserRULE_cancelAlterTableStatement              = 56
	DorisSQLParserParserRULE_showPartitionsStatement                = 57
	DorisSQLParserParserRULE_recoverPartitionStatement              = 58
	DorisSQLParserParserRULE_createViewStatement                    = 59
	DorisSQLParserParserRULE_alterViewStatement                     = 60
	DorisSQLParserParserRULE_dropViewStatement                      = 61
	DorisSQLParserParserRULE_columnNameWithComment                  = 62
	DorisSQLParserParserRULE_submitTaskStatement                    = 63
	DorisSQLParserParserRULE_taskClause                             = 64
	DorisSQLParserParserRULE_dropTaskStatement                      = 65
	DorisSQLParserParserRULE_taskScheduleDesc                       = 66
	DorisSQLParserParserRULE_createMaterializedViewStatement        = 67
	DorisSQLParserParserRULE_mvPartitionExprs                       = 68
	DorisSQLParserParserRULE_materializedViewDesc                   = 69
	DorisSQLParserParserRULE_showMaterializedViewsStatement         = 70
	DorisSQLParserParserRULE_dropMaterializedViewStatement          = 71
	DorisSQLParserParserRULE_alterMaterializedViewStatement         = 72
	DorisSQLParserParserRULE_refreshMaterializedViewStatement       = 73
	DorisSQLParserParserRULE_cancelRefreshMaterializedViewStatement = 74
	DorisSQLParserParserRULE_adminSetConfigStatement                = 75
	DorisSQLParserParserRULE_adminSetReplicaStatusStatement         = 76
	DorisSQLParserParserRULE_adminShowConfigStatement               = 77
	DorisSQLParserParserRULE_adminShowReplicaDistributionStatement  = 78
	DorisSQLParserParserRULE_adminShowReplicaStatusStatement        = 79
	DorisSQLParserParserRULE_adminRepairTableStatement              = 80
	DorisSQLParserParserRULE_adminCancelRepairTableStatement        = 81
	DorisSQLParserParserRULE_adminCheckTabletsStatement             = 82
	DorisSQLParserParserRULE_adminSetPartitionVersion               = 83
	DorisSQLParserParserRULE_killStatement                          = 84
	DorisSQLParserParserRULE_syncStatement                          = 85
	DorisSQLParserParserRULE_adminSetAutomatedSnapshotOnStatement   = 86
	DorisSQLParserParserRULE_adminSetAutomatedSnapshotOffStatement  = 87
	DorisSQLParserParserRULE_alterSystemStatement                   = 88
	DorisSQLParserParserRULE_cancelAlterSystemStatement             = 89
	DorisSQLParserParserRULE_showComputeNodesStatement              = 90
	DorisSQLParserParserRULE_createExternalCatalogStatement         = 91
	DorisSQLParserParserRULE_showCreateExternalCatalogStatement     = 92
	DorisSQLParserParserRULE_dropExternalCatalogStatement           = 93
	DorisSQLParserParserRULE_showCatalogsStatement                  = 94
	DorisSQLParserParserRULE_alterCatalogStatement                  = 95
	DorisSQLParserParserRULE_createStorageVolumeStatement           = 96
	DorisSQLParserParserRULE_typeDesc                               = 97
	DorisSQLParserParserRULE_locationsDesc                          = 98
	DorisSQLParserParserRULE_showStorageVolumesStatement            = 99
	DorisSQLParserParserRULE_dropStorageVolumeStatement             = 100
	DorisSQLParserParserRULE_alterStorageVolumeStatement            = 101
	DorisSQLParserParserRULE_alterStorageVolumeClause               = 102
	DorisSQLParserParserRULE_modifyStorageVolumePropertiesClause    = 103
	DorisSQLParserParserRULE_modifyStorageVolumeCommentClause       = 104
	DorisSQLParserParserRULE_descStorageVolumeStatement             = 105
	DorisSQLParserParserRULE_setDefaultStorageVolumeStatement       = 106
	DorisSQLParserParserRULE_updateFailPointStatusStatement         = 107
	DorisSQLParserParserRULE_showFailPointStatement                 = 108
	DorisSQLParserParserRULE_createDictionaryStatement              = 109
	DorisSQLParserParserRULE_dropDictionaryStatement                = 110
	DorisSQLParserParserRULE_refreshDictionaryStatement             = 111
	DorisSQLParserParserRULE_showDictionaryStatement                = 112
	DorisSQLParserParserRULE_cancelRefreshDictionaryStatement       = 113
	DorisSQLParserParserRULE_dictionaryColumnDesc                   = 114
	DorisSQLParserParserRULE_dictionaryName                         = 115
	DorisSQLParserParserRULE_alterClause                            = 116
	DorisSQLParserParserRULE_addFrontendClause                      = 117
	DorisSQLParserParserRULE_dropFrontendClause                     = 118
	DorisSQLParserParserRULE_modifyFrontendHostClause               = 119
	DorisSQLParserParserRULE_addBackendClause                       = 120
	DorisSQLParserParserRULE_dropBackendClause                      = 121
	DorisSQLParserParserRULE_decommissionBackendClause              = 122
	DorisSQLParserParserRULE_modifyBackendClause                    = 123
	DorisSQLParserParserRULE_addComputeNodeClause                   = 124
	DorisSQLParserParserRULE_dropComputeNodeClause                  = 125
	DorisSQLParserParserRULE_modifyBrokerClause                     = 126
	DorisSQLParserParserRULE_alterLoadErrorUrlClause                = 127
	DorisSQLParserParserRULE_createImageClause                      = 128
	DorisSQLParserParserRULE_cleanTabletSchedQClause                = 129
	DorisSQLParserParserRULE_decommissionDiskClause                 = 130
	DorisSQLParserParserRULE_cancelDecommissionDiskClause           = 131
	DorisSQLParserParserRULE_disableDiskClause                      = 132
	DorisSQLParserParserRULE_cancelDisableDiskClause                = 133
	DorisSQLParserParserRULE_createIndexClause                      = 134
	DorisSQLParserParserRULE_dropIndexClause                        = 135
	DorisSQLParserParserRULE_tableRenameClause                      = 136
	DorisSQLParserParserRULE_swapTableClause                        = 137
	DorisSQLParserParserRULE_modifyPropertiesClause                 = 138
	DorisSQLParserParserRULE_modifyCommentClause                    = 139
	DorisSQLParserParserRULE_optimizeRange                          = 140
	DorisSQLParserParserRULE_optimizeClause                         = 141
	DorisSQLParserParserRULE_addColumnClause                        = 142
	DorisSQLParserParserRULE_addColumnsClause                       = 143
	DorisSQLParserParserRULE_dropColumnClause                       = 144
	DorisSQLParserParserRULE_modifyColumnClause                     = 145
	DorisSQLParserParserRULE_modifyColumnCommentClause              = 146
	DorisSQLParserParserRULE_columnRenameClause                     = 147
	DorisSQLParserParserRULE_reorderColumnsClause                   = 148
	DorisSQLParserParserRULE_rollupRenameClause                     = 149
	DorisSQLParserParserRULE_compactionClause                       = 150
	DorisSQLParserParserRULE_subfieldName                           = 151
	DorisSQLParserParserRULE_nestedFieldName                        = 152
	DorisSQLParserParserRULE_addFieldClause                         = 153
	DorisSQLParserParserRULE_dropFieldClause                        = 154
	DorisSQLParserParserRULE_createOrReplaceTagClause               = 155
	DorisSQLParserParserRULE_createOrReplaceBranchClause            = 156
	DorisSQLParserParserRULE_dropBranchClause                       = 157
	DorisSQLParserParserRULE_dropTagClause                          = 158
	DorisSQLParserParserRULE_tableOperationClause                   = 159
	DorisSQLParserParserRULE_tagOptions                             = 160
	DorisSQLParserParserRULE_branchOptions                          = 161
	DorisSQLParserParserRULE_snapshotRetention                      = 162
	DorisSQLParserParserRULE_refRetain                              = 163
	DorisSQLParserParserRULE_maxSnapshotAge                         = 164
	DorisSQLParserParserRULE_minSnapshotsToKeep                     = 165
	DorisSQLParserParserRULE_snapshotId                             = 166
	DorisSQLParserParserRULE_timeUnit                               = 167
	DorisSQLParserParserRULE_integer_list                           = 168
	DorisSQLParserParserRULE_dropPersistentIndexClause              = 169
	DorisSQLParserParserRULE_addPartitionClause                     = 170
	DorisSQLParserParserRULE_dropPartitionClause                    = 171
	DorisSQLParserParserRULE_truncatePartitionClause                = 172
	DorisSQLParserParserRULE_modifyPartitionClause                  = 173
	DorisSQLParserParserRULE_replacePartitionClause                 = 174
	DorisSQLParserParserRULE_partitionRenameClause                  = 175
	DorisSQLParserParserRULE_insertStatement                        = 176
	DorisSQLParserParserRULE_insertLabelOrColumnAliases             = 177
	DorisSQLParserParserRULE_columnAliasesOrByName                  = 178
	DorisSQLParserParserRULE_updateStatement                        = 179
	DorisSQLParserParserRULE_deleteStatement                        = 180
	DorisSQLParserParserRULE_createRoutineLoadStatement             = 181
	DorisSQLParserParserRULE_alterRoutineLoadStatement              = 182
	DorisSQLParserParserRULE_dataSource                             = 183
	DorisSQLParserParserRULE_loadProperties                         = 184
	DorisSQLParserParserRULE_colSeparatorProperty                   = 185
	DorisSQLParserParserRULE_rowDelimiterProperty                   = 186
	DorisSQLParserParserRULE_importColumns                          = 187
	DorisSQLParserParserRULE_columnProperties                       = 188
	DorisSQLParserParserRULE_jobProperties                          = 189
	DorisSQLParserParserRULE_dataSourceProperties                   = 190
	DorisSQLParserParserRULE_stopRoutineLoadStatement               = 191
	DorisSQLParserParserRULE_resumeRoutineLoadStatement             = 192
	DorisSQLParserParserRULE_pauseRoutineLoadStatement              = 193
	DorisSQLParserParserRULE_showRoutineLoadStatement               = 194
	DorisSQLParserParserRULE_showRoutineLoadTaskStatement           = 195
	DorisSQLParserParserRULE_showCreateRoutineLoadStatement         = 196
	DorisSQLParserParserRULE_showStreamLoadStatement                = 197
	DorisSQLParserParserRULE_analyzeStatement                       = 198
	DorisSQLParserParserRULE_analyzeColumnClause                    = 199
	DorisSQLParserParserRULE_dropStatsStatement                     = 200
	DorisSQLParserParserRULE_histogramStatement                     = 201
	DorisSQLParserParserRULE_analyzeHistogramStatement              = 202
	DorisSQLParserParserRULE_dropHistogramStatement                 = 203
	DorisSQLParserParserRULE_createAnalyzeStatement                 = 204
	DorisSQLParserParserRULE_dropAnalyzeJobStatement                = 205
	DorisSQLParserParserRULE_showAnalyzeStatement                   = 206
	DorisSQLParserParserRULE_showStatsMetaStatement                 = 207
	DorisSQLParserParserRULE_showHistogramMetaStatement             = 208
	DorisSQLParserParserRULE_killAnalyzeStatement                   = 209
	DorisSQLParserParserRULE_analyzeProfileStatement                = 210
	DorisSQLParserParserRULE_createBaselinePlanStatement            = 211
	DorisSQLParserParserRULE_dropBaselinePlanStatement              = 212
	DorisSQLParserParserRULE_showBaselinePlanStatement              = 213
	DorisSQLParserParserRULE_createResourceGroupStatement           = 214
	DorisSQLParserParserRULE_dropResourceGroupStatement             = 215
	DorisSQLParserParserRULE_alterResourceGroupStatement            = 216
	DorisSQLParserParserRULE_showResourceGroupStatement             = 217
	DorisSQLParserParserRULE_showResourceGroupUsageStatement        = 218
	DorisSQLParserParserRULE_createResourceStatement                = 219
	DorisSQLParserParserRULE_alterResourceStatement                 = 220
	DorisSQLParserParserRULE_dropResourceStatement                  = 221
	DorisSQLParserParserRULE_showResourceStatement                  = 222
	DorisSQLParserParserRULE_classifier                             = 223
	DorisSQLParserParserRULE_showFunctionsStatement                 = 224
	DorisSQLParserParserRULE_dropFunctionStatement                  = 225
	DorisSQLParserParserRULE_createFunctionStatement                = 226
	DorisSQLParserParserRULE_inlineFunction                         = 227
	DorisSQLParserParserRULE_typeList                               = 228
	DorisSQLParserParserRULE_loadStatement                          = 229
	DorisSQLParserParserRULE_labelName                              = 230
	DorisSQLParserParserRULE_dataDescList                           = 231
	DorisSQLParserParserRULE_dataDesc                               = 232
	DorisSQLParserParserRULE_formatProps                            = 233
	DorisSQLParserParserRULE_brokerDesc                             = 234
	DorisSQLParserParserRULE_resourceDesc                           = 235
	DorisSQLParserParserRULE_showLoadStatement                      = 236
	DorisSQLParserParserRULE_showLoadWarningsStatement              = 237
	DorisSQLParserParserRULE_cancelLoadStatement                    = 238
	DorisSQLParserParserRULE_alterLoadStatement                     = 239
	DorisSQLParserParserRULE_cancelCompactionStatement              = 240
	DorisSQLParserParserRULE_showAuthorStatement                    = 241
	DorisSQLParserParserRULE_showBackendsStatement                  = 242
	DorisSQLParserParserRULE_showBrokerStatement                    = 243
	DorisSQLParserParserRULE_showCharsetStatement                   = 244
	DorisSQLParserParserRULE_showCollationStatement                 = 245
	DorisSQLParserParserRULE_showDeleteStatement                    = 246
	DorisSQLParserParserRULE_showDynamicPartitionStatement          = 247
	DorisSQLParserParserRULE_showEventsStatement                    = 248
	DorisSQLParserParserRULE_showEnginesStatement                   = 249
	DorisSQLParserParserRULE_showFrontendsStatement                 = 250
	DorisSQLParserParserRULE_showPluginsStatement                   = 251
	DorisSQLParserParserRULE_showRepositoriesStatement              = 252
	DorisSQLParserParserRULE_showOpenTableStatement                 = 253
	DorisSQLParserParserRULE_showPrivilegesStatement                = 254
	DorisSQLParserParserRULE_showProcedureStatement                 = 255
	DorisSQLParserParserRULE_showProcStatement                      = 256
	DorisSQLParserParserRULE_showProcesslistStatement               = 257
	DorisSQLParserParserRULE_showProfilelistStatement               = 258
	DorisSQLParserParserRULE_showRunningQueriesStatement            = 259
	DorisSQLParserParserRULE_showStatusStatement                    = 260
	DorisSQLParserParserRULE_showTabletStatement                    = 261
	DorisSQLParserParserRULE_showTransactionStatement               = 262
	DorisSQLParserParserRULE_showTriggersStatement                  = 263
	DorisSQLParserParserRULE_showUserPropertyStatement              = 264
	DorisSQLParserParserRULE_showVariablesStatement                 = 265
	DorisSQLParserParserRULE_showWarningStatement                   = 266
	DorisSQLParserParserRULE_helpStatement                          = 267
	DorisSQLParserParserRULE_createUserStatement                    = 268
	DorisSQLParserParserRULE_dropUserStatement                      = 269
	DorisSQLParserParserRULE_alterUserStatement                     = 270
	DorisSQLParserParserRULE_showUserStatement                      = 271
	DorisSQLParserParserRULE_showAuthenticationStatement            = 272
	DorisSQLParserParserRULE_executeAsStatement                     = 273
	DorisSQLParserParserRULE_createRoleStatement                    = 274
	DorisSQLParserParserRULE_alterRoleStatement                     = 275
	DorisSQLParserParserRULE_dropRoleStatement                      = 276
	DorisSQLParserParserRULE_showRolesStatement                     = 277
	DorisSQLParserParserRULE_grantRoleStatement                     = 278
	DorisSQLParserParserRULE_revokeRoleStatement                    = 279
	DorisSQLParserParserRULE_setRoleStatement                       = 280
	DorisSQLParserParserRULE_setDefaultRoleStatement                = 281
	DorisSQLParserParserRULE_grantRevokeClause                      = 282
	DorisSQLParserParserRULE_grantPrivilegeStatement                = 283
	DorisSQLParserParserRULE_revokePrivilegeStatement               = 284
	DorisSQLParserParserRULE_showGrantsStatement                    = 285
	DorisSQLParserParserRULE_authOption                             = 286
	DorisSQLParserParserRULE_privObjectName                         = 287
	DorisSQLParserParserRULE_privObjectNameList                     = 288
	DorisSQLParserParserRULE_privFunctionObjectNameList             = 289
	DorisSQLParserParserRULE_privilegeTypeList                      = 290
	DorisSQLParserParserRULE_privilegeType                          = 291
	DorisSQLParserParserRULE_privObjectType                         = 292
	DorisSQLParserParserRULE_privObjectTypePlural                   = 293
	DorisSQLParserParserRULE_createSecurityIntegrationStatement     = 294
	DorisSQLParserParserRULE_alterSecurityIntegrationStatement      = 295
	DorisSQLParserParserRULE_dropSecurityIntegrationStatement       = 296
	DorisSQLParserParserRULE_showSecurityIntegrationStatement       = 297
	DorisSQLParserParserRULE_showCreateSecurityIntegrationStatement = 298
	DorisSQLParserParserRULE_createGroupProviderStatement           = 299
	DorisSQLParserParserRULE_dropGroupProviderStatement             = 300
	DorisSQLParserParserRULE_showGroupProvidersStatement            = 301
	DorisSQLParserParserRULE_showCreateGroupProviderStatement       = 302
	DorisSQLParserParserRULE_backupStatement                        = 303
	DorisSQLParserParserRULE_cancelBackupStatement                  = 304
	DorisSQLParserParserRULE_showBackupStatement                    = 305
	DorisSQLParserParserRULE_restoreStatement                       = 306
	DorisSQLParserParserRULE_cancelRestoreStatement                 = 307
	DorisSQLParserParserRULE_showRestoreStatement                   = 308
	DorisSQLParserParserRULE_showSnapshotStatement                  = 309
	DorisSQLParserParserRULE_createRepositoryStatement              = 310
	DorisSQLParserParserRULE_dropRepositoryStatement                = 311
	DorisSQLParserParserRULE_addSqlBlackListStatement               = 312
	DorisSQLParserParserRULE_delSqlBlackListStatement               = 313
	DorisSQLParserParserRULE_showSqlBlackListStatement              = 314
	DorisSQLParserParserRULE_showWhiteListStatement                 = 315
	DorisSQLParserParserRULE_addBackendBlackListStatement           = 316
	DorisSQLParserParserRULE_delBackendBlackListStatement           = 317
	DorisSQLParserParserRULE_showBackendBlackListStatement          = 318
	DorisSQLParserParserRULE_dataCacheTarget                        = 319
	DorisSQLParserParserRULE_createDataCacheRuleStatement           = 320
	DorisSQLParserParserRULE_showDataCacheRulesStatement            = 321
	DorisSQLParserParserRULE_dropDataCacheRuleStatement             = 322
	DorisSQLParserParserRULE_clearDataCacheRulesStatement           = 323
	DorisSQLParserParserRULE_dataCacheSelectStatement               = 324
	DorisSQLParserParserRULE_exportStatement                        = 325
	DorisSQLParserParserRULE_cancelExportStatement                  = 326
	DorisSQLParserParserRULE_showExportStatement                    = 327
	DorisSQLParserParserRULE_installPluginStatement                 = 328
	DorisSQLParserParserRULE_uninstallPluginStatement               = 329
	DorisSQLParserParserRULE_createFileStatement                    = 330
	DorisSQLParserParserRULE_dropFileStatement                      = 331
	DorisSQLParserParserRULE_showSmallFilesStatement                = 332
	DorisSQLParserParserRULE_createPipeStatement                    = 333
	DorisSQLParserParserRULE_dropPipeStatement                      = 334
	DorisSQLParserParserRULE_alterPipeClause                        = 335
	DorisSQLParserParserRULE_alterPipeStatement                     = 336
	DorisSQLParserParserRULE_descPipeStatement                      = 337
	DorisSQLParserParserRULE_showPipeStatement                      = 338
	DorisSQLParserParserRULE_setStatement                           = 339
	DorisSQLParserParserRULE_setVar                                 = 340
	DorisSQLParserParserRULE_transaction_characteristics            = 341
	DorisSQLParserParserRULE_transaction_access_mode                = 342
	DorisSQLParserParserRULE_isolation_level                        = 343
	DorisSQLParserParserRULE_isolation_types                        = 344
	DorisSQLParserParserRULE_setExprOrDefault                       = 345
	DorisSQLParserParserRULE_setUserPropertyStatement               = 346
	DorisSQLParserParserRULE_roleList                               = 347
	DorisSQLParserParserRULE_executeScriptStatement                 = 348
	DorisSQLParserParserRULE_unsupportedStatement                   = 349
	DorisSQLParserParserRULE_lock_item                              = 350
	DorisSQLParserParserRULE_lock_type                              = 351
	DorisSQLParserParserRULE_alterPlanAdvisorAddStatement           = 352
	DorisSQLParserParserRULE_truncatePlanAdvisorStatement           = 353
	DorisSQLParserParserRULE_alterPlanAdvisorDropStatement          = 354
	DorisSQLParserParserRULE_showPlanAdvisorStatement               = 355
	DorisSQLParserParserRULE_createWarehouseStatement               = 356
	DorisSQLParserParserRULE_dropWarehouseStatement                 = 357
	DorisSQLParserParserRULE_suspendWarehouseStatement              = 358
	DorisSQLParserParserRULE_resumeWarehouseStatement               = 359
	DorisSQLParserParserRULE_setWarehouseStatement                  = 360
	DorisSQLParserParserRULE_showWarehousesStatement                = 361
	DorisSQLParserParserRULE_showClustersStatement                  = 362
	DorisSQLParserParserRULE_showNodesStatement                     = 363
	DorisSQLParserParserRULE_alterWarehouseStatement                = 364
	DorisSQLParserParserRULE_createCNGroupStatement                 = 365
	DorisSQLParserParserRULE_dropCNGroupStatement                   = 366
	DorisSQLParserParserRULE_enableCNGroupStatement                 = 367
	DorisSQLParserParserRULE_disableCNGroupStatement                = 368
	DorisSQLParserParserRULE_alterCNGroupStatement                  = 369
	DorisSQLParserParserRULE_beginStatement                         = 370
	DorisSQLParserParserRULE_commitStatement                        = 371
	DorisSQLParserParserRULE_rollbackStatement                      = 372
	DorisSQLParserParserRULE_translateStatement                     = 373
	DorisSQLParserParserRULE_dialect                                = 374
	DorisSQLParserParserRULE_translateSQL                           = 375
	DorisSQLParserParserRULE_queryStatement                         = 376
	DorisSQLParserParserRULE_queryRelation                          = 377
	DorisSQLParserParserRULE_withClause                             = 378
	DorisSQLParserParserRULE_queryNoWith                            = 379
	DorisSQLParserParserRULE_queryPeriod                            = 380
	DorisSQLParserParserRULE_periodType                             = 381
	DorisSQLParserParserRULE_queryPrimary                           = 382
	DorisSQLParserParserRULE_subquery                               = 383
	DorisSQLParserParserRULE_rowConstructor                         = 384
	DorisSQLParserParserRULE_sortItem                               = 385
	DorisSQLParserParserRULE_limitConstExpr                         = 386
	DorisSQLParserParserRULE_limitElement                           = 387
	DorisSQLParserParserRULE_querySpecification                     = 388
	DorisSQLParserParserRULE_fromClause                             = 389
	DorisSQLParserParserRULE_groupingElement                        = 390
	DorisSQLParserParserRULE_groupingSet                            = 391
	DorisSQLParserParserRULE_commonTableExpression                  = 392
	DorisSQLParserParserRULE_setQuantifier                          = 393
	DorisSQLParserParserRULE_selectItem                             = 394
	DorisSQLParserParserRULE_excludeClause                          = 395
	DorisSQLParserParserRULE_relations                              = 396
	DorisSQLParserParserRULE_relation                               = 397
	DorisSQLParserParserRULE_relationPrimary                        = 398
	DorisSQLParserParserRULE_pivotClause                            = 399
	DorisSQLParserParserRULE_pivotAggregationExpression             = 400
	DorisSQLParserParserRULE_pivotValue                             = 401
	DorisSQLParserParserRULE_sampleClause                           = 402
	DorisSQLParserParserRULE_argumentList                           = 403
	DorisSQLParserParserRULE_namedArgumentList                      = 404
	DorisSQLParserParserRULE_namedArgument                          = 405
	DorisSQLParserParserRULE_joinRelation                           = 406
	DorisSQLParserParserRULE_crossOrInnerJoinType                   = 407
	DorisSQLParserParserRULE_outerAndSemiJoinType                   = 408
	DorisSQLParserParserRULE_bracketHint                            = 409
	DorisSQLParserParserRULE_hintMap                                = 410
	DorisSQLParserParserRULE_joinCriteria                           = 411
	DorisSQLParserParserRULE_columnAliases                          = 412
	DorisSQLParserParserRULE_partitionNames                         = 413
	DorisSQLParserParserRULE_keyPartitions                          = 414
	DorisSQLParserParserRULE_tabletList                             = 415
	DorisSQLParserParserRULE_prepareStatement                       = 416
	DorisSQLParserParserRULE_prepareSql                             = 417
	DorisSQLParserParserRULE_executeStatement                       = 418
	DorisSQLParserParserRULE_deallocateStatement                    = 419
	DorisSQLParserParserRULE_replicaList                            = 420
	DorisSQLParserParserRULE_expressionsWithDefault                 = 421
	DorisSQLParserParserRULE_expressionOrDefault                    = 422
	DorisSQLParserParserRULE_mapExpressionList                      = 423
	DorisSQLParserParserRULE_mapExpression                          = 424
	DorisSQLParserParserRULE_expressionSingleton                    = 425
	DorisSQLParserParserRULE_expression                             = 426
	DorisSQLParserParserRULE_expressionList                         = 427
	DorisSQLParserParserRULE_booleanExpression                      = 428
	DorisSQLParserParserRULE_predicate                              = 429
	DorisSQLParserParserRULE_tupleInSubquery                        = 430
	DorisSQLParserParserRULE_predicateOperations                    = 431
	DorisSQLParserParserRULE_valueExpression                        = 432
	DorisSQLParserParserRULE_primaryExpression                      = 433
	DorisSQLParserParserRULE_literalExpression                      = 434
	DorisSQLParserParserRULE_functionCall                           = 435
	DorisSQLParserParserRULE_aggregationFunction                    = 436
	DorisSQLParserParserRULE_userVariable                           = 437
	DorisSQLParserParserRULE_systemVariable                         = 438
	DorisSQLParserParserRULE_columnReference                        = 439
	DorisSQLParserParserRULE_informationFunctionExpression          = 440
	DorisSQLParserParserRULE_specialDateTimeExpression              = 441
	DorisSQLParserParserRULE_specialFunctionExpression              = 442
	DorisSQLParserParserRULE_windowFunction                         = 443
	DorisSQLParserParserRULE_whenClause                             = 444
	DorisSQLParserParserRULE_over                                   = 445
	DorisSQLParserParserRULE_ignoreNulls                            = 446
	DorisSQLParserParserRULE_windowFrame                            = 447
	DorisSQLParserParserRULE_frameBound                             = 448
	DorisSQLParserParserRULE_backupRestoreObjectDesc                = 449
	DorisSQLParserParserRULE_tableDesc                              = 450
	DorisSQLParserParserRULE_backupRestoreTableDesc                 = 451
	DorisSQLParserParserRULE_explainDesc                            = 452
	DorisSQLParserParserRULE_optimizerTrace                         = 453
	DorisSQLParserParserRULE_partitionExpr                          = 454
	DorisSQLParserParserRULE_partitionDesc                          = 455
	DorisSQLParserParserRULE_listPartitionDesc                      = 456
	DorisSQLParserParserRULE_singleItemListPartitionDesc            = 457
	DorisSQLParserParserRULE_multiItemListPartitionDesc             = 458
	DorisSQLParserParserRULE_multiListPartitionValues               = 459
	DorisSQLParserParserRULE_singleListPartitionValues              = 460
	DorisSQLParserParserRULE_listPartitionValues                    = 461
	DorisSQLParserParserRULE_listPartitionValue                     = 462
	DorisSQLParserParserRULE_stringList                             = 463
	DorisSQLParserParserRULE_literalExpressionList                  = 464
	DorisSQLParserParserRULE_rangePartitionDesc                     = 465
	DorisSQLParserParserRULE_singleRangePartition                   = 466
	DorisSQLParserParserRULE_multiRangePartition                    = 467
	DorisSQLParserParserRULE_partitionRangeDesc                     = 468
	DorisSQLParserParserRULE_partitionKeyDesc                       = 469
	DorisSQLParserParserRULE_partitionValueList                     = 470
	DorisSQLParserParserRULE_keyPartition                           = 471
	DorisSQLParserParserRULE_partitionValue                         = 472
	DorisSQLParserParserRULE_distributionClause                     = 473
	DorisSQLParserParserRULE_distributionDesc                       = 474
	DorisSQLParserParserRULE_refreshSchemeDesc                      = 475
	DorisSQLParserParserRULE_statusDesc                             = 476
	DorisSQLParserParserRULE_properties                             = 477
	DorisSQLParserParserRULE_extProperties                          = 478
	DorisSQLParserParserRULE_propertyList                           = 479
	DorisSQLParserParserRULE_userPropertyList                       = 480
	DorisSQLParserParserRULE_property                               = 481
	DorisSQLParserParserRULE_inlineProperties                       = 482
	DorisSQLParserParserRULE_inlineProperty                         = 483
	DorisSQLParserParserRULE_varType                                = 484
	DorisSQLParserParserRULE_comment                                = 485
	DorisSQLParserParserRULE_outfile                                = 486
	DorisSQLParserParserRULE_fileFormat                             = 487
	DorisSQLParserParserRULE_string                                 = 488
	DorisSQLParserParserRULE_binary                                 = 489
	DorisSQLParserParserRULE_comparisonOperator                     = 490
	DorisSQLParserParserRULE_booleanValue                           = 491
	DorisSQLParserParserRULE_interval                               = 492
	DorisSQLParserParserRULE_taskInterval                           = 493
	DorisSQLParserParserRULE_taskUnitIdentifier                     = 494
	DorisSQLParserParserRULE_unitIdentifier                         = 495
	DorisSQLParserParserRULE_unitBoundary                           = 496
	DorisSQLParserParserRULE_type                                   = 497
	DorisSQLParserParserRULE_arrayType                              = 498
	DorisSQLParserParserRULE_mapType                                = 499
	DorisSQLParserParserRULE_subfieldDesc                           = 500
	DorisSQLParserParserRULE_subfieldDescs                          = 501
	DorisSQLParserParserRULE_structType                             = 502
	DorisSQLParserParserRULE_typeParameter                          = 503
	DorisSQLParserParserRULE_baseType                               = 504
	DorisSQLParserParserRULE_decimalType                            = 505
	DorisSQLParserParserRULE_qualifiedName                          = 506
	DorisSQLParserParserRULE_tableName                              = 507
	DorisSQLParserParserRULE_writeBranch                            = 508
	DorisSQLParserParserRULE_identifier                             = 509
	DorisSQLParserParserRULE_identifierWithAlias                    = 510
	DorisSQLParserParserRULE_identifierWithAliasList                = 511
	DorisSQLParserParserRULE_identifierList                         = 512
	DorisSQLParserParserRULE_identifierOrString                     = 513
	DorisSQLParserParserRULE_identifierOrStringList                 = 514
	DorisSQLParserParserRULE_identifierOrStringOrStar               = 515
	DorisSQLParserParserRULE_user                                   = 516
	DorisSQLParserParserRULE_assignment                             = 517
	DorisSQLParserParserRULE_assignmentList                         = 518
	DorisSQLParserParserRULE_number                                 = 519
	DorisSQLParserParserRULE_nonReserved                            = 520
)

// ISqlStatementsContext is an interface to support dynamic dispatch.
type ISqlStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllSingleStatement() []ISingleStatementContext
	SingleStatement(i int) ISingleStatementContext

	// IsSqlStatementsContext differentiates from other interfaces.
	IsSqlStatementsContext()
}

type SqlStatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlStatementsContext() *SqlStatementsContext {
	var p = new(SqlStatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_sqlStatements
	return p
}

func InitEmptySqlStatementsContext(p *SqlStatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_sqlStatements
}

func (*SqlStatementsContext) IsSqlStatementsContext() {}

func NewSqlStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlStatementsContext {
	var p = new(SqlStatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_sqlStatements

	return p
}

func (s *SqlStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlStatementsContext) EOF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEOF, 0)
}

func (s *SqlStatementsContext) AllSingleStatement() []ISingleStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleStatementContext); ok {
			len++
		}
	}

	tst := make([]ISingleStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleStatementContext); ok {
			tst[i] = t.(ISingleStatementContext)
			i++
		}
	}

	return tst
}

func (s *SqlStatementsContext) SingleStatement(i int) ISingleStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleStatementContext)
}

func (s *SqlStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSqlStatements(s)
	}
}

func (s *SqlStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSqlStatements(s)
	}
}

func (s *SqlStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSqlStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SqlStatements() (localctx ISqlStatementsContext) {
	localctx = NewSqlStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, DorisSQLParserParserRULE_sqlStatements)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1043)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&216174019065962500) != 0) || ((int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&433475862185117699) != 0) || ((int64((_la-132)) & ^0x3f) == 0 && ((int64(1)<<(_la-132))&72198331526709249) != 0) || ((int64((_la-209)) & ^0x3f) == 0 && ((int64(1)<<(_la-209))&17180917763) != 0) || ((int64((_la-307)) & ^0x3f) == 0 && ((int64(1)<<(_la-307))&4827862099076087809) != 0) || ((int64((_la-375)) & ^0x3f) == 0 && ((int64(1)<<(_la-375))&7166222204929) != 0) || ((int64((_la-439)) & ^0x3f) == 0 && ((int64(1)<<(_la-439))&107752139857989) != 0) || _la == DorisSQLParserParserSEMICOLON {
		{
			p.SetState(1042)
			p.SingleStatement()
		}

		p.SetState(1045)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1047)
		p.Match(DorisSQLParserParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleStatementContext is an interface to support dynamic dispatch.
type ISingleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Statement() IStatementContext
	SEMICOLON() antlr.TerminalNode
	EOF() antlr.TerminalNode
	EmptyStatement() IEmptyStatementContext

	// IsSingleStatementContext differentiates from other interfaces.
	IsSingleStatementContext()
}

type SingleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleStatementContext() *SingleStatementContext {
	var p = new(SingleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_singleStatement
	return p
}

func InitEmptySingleStatementContext(p *SingleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_singleStatement
}

func (*SingleStatementContext) IsSingleStatementContext() {}

func NewSingleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleStatementContext {
	var p = new(SingleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_singleStatement

	return p
}

func (s *SingleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SingleStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSEMICOLON, 0)
}

func (s *SingleStatementContext) EOF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEOF, 0)
}

func (s *SingleStatementContext) EmptyStatement() IEmptyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatementContext)
}

func (s *SingleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSingleStatement(s)
	}
}

func (s *SingleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSingleStatement(s)
	}
}

func (s *SingleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSingleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SingleStatement() (localctx ISingleStatementContext) {
	localctx = NewSingleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, DorisSQLParserParserRULE_singleStatement)
	var _la int

	p.SetState(1053)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserT__1, DorisSQLParserParserADD, DorisSQLParserParserADMIN, DorisSQLParserParserALTER, DorisSQLParserParserANALYZE, DorisSQLParserParserBACKUP, DorisSQLParserParserBEGIN, DorisSQLParserParserCACHE, DorisSQLParserParserCANCEL, DorisSQLParserParserCLEAN, DorisSQLParserParserCLEAR, DorisSQLParserParserCOMMIT, DorisSQLParserParserCREATE, DorisSQLParserParserDEALLOCATE, DorisSQLParserParserDELETE, DorisSQLParserParserDESC, DorisSQLParserParserDESCRIBE, DorisSQLParserParserDROP, DorisSQLParserParserEXECUTE, DorisSQLParserParserEXPLAIN, DorisSQLParserParserEXPORT, DorisSQLParserParserGRANT, DorisSQLParserParserHELP, DorisSQLParserParserINSTALL, DorisSQLParserParserINSERT, DorisSQLParserParserKILL, DorisSQLParserParserLOAD, DorisSQLParserParserPAUSE, DorisSQLParserParserPREPARE, DorisSQLParserParserRECOVER, DorisSQLParserParserREFRESH, DorisSQLParserParserRESTORE, DorisSQLParserParserRESUME, DorisSQLParserParserREVOKE, DorisSQLParserParserROLLBACK, DorisSQLParserParserSELECT, DorisSQLParserParserSET, DorisSQLParserParserSHOW, DorisSQLParserParserSTART, DorisSQLParserParserSTOP, DorisSQLParserParserSUBMIT, DorisSQLParserParserSUSPEND, DorisSQLParserParserSYNC, DorisSQLParserParserTRANSLATE, DorisSQLParserParserTRACE, DorisSQLParserParserTRUNCATE, DorisSQLParserParserUNINSTALL, DorisSQLParserParserUPDATE, DorisSQLParserParserUSE, DorisSQLParserParserWITH, DorisSQLParserParserLOCK, DorisSQLParserParserUNLOCK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1049)
			p.Statement()
		}
		{
			p.SetState(1050)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserEOF || _la == DorisSQLParserParserSEMICOLON) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case DorisSQLParserParserSEMICOLON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1052)
			p.EmptyStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmptyStatementContext is an interface to support dynamic dispatch.
type IEmptyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMICOLON() antlr.TerminalNode

	// IsEmptyStatementContext differentiates from other interfaces.
	IsEmptyStatementContext()
}

type EmptyStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatementContext() *EmptyStatementContext {
	var p = new(EmptyStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_emptyStatement
	return p
}

func InitEmptyEmptyStatementContext(p *EmptyStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_emptyStatement
}

func (*EmptyStatementContext) IsEmptyStatementContext() {}

func NewEmptyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatementContext {
	var p = new(EmptyStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_emptyStatement

	return p
}

func (s *EmptyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EmptyStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSEMICOLON, 0)
}

func (s *EmptyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterEmptyStatement(s)
	}
}

func (s *EmptyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitEmptyStatement(s)
	}
}

func (s *EmptyStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitEmptyStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) EmptyStatement() (localctx IEmptyStatementContext) {
	localctx = NewEmptyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, DorisSQLParserParserRULE_emptyStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1055)
		p.Match(DorisSQLParserParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryStatement() IQueryStatementContext
	UseDatabaseStatement() IUseDatabaseStatementContext
	UseCatalogStatement() IUseCatalogStatementContext
	SetCatalogStatement() ISetCatalogStatementContext
	ShowDatabasesStatement() IShowDatabasesStatementContext
	AlterDbQuotaStatement() IAlterDbQuotaStatementContext
	CreateDbStatement() ICreateDbStatementContext
	DropDbStatement() IDropDbStatementContext
	ShowCreateDbStatement() IShowCreateDbStatementContext
	AlterDatabaseRenameStatement() IAlterDatabaseRenameStatementContext
	RecoverDbStmt() IRecoverDbStmtContext
	ShowDataStmt() IShowDataStmtContext
	ShowDataDistributionStmt() IShowDataDistributionStmtContext
	CreateTableStatement() ICreateTableStatementContext
	CreateTableAsSelectStatement() ICreateTableAsSelectStatementContext
	CreateTableLikeStatement() ICreateTableLikeStatementContext
	ShowCreateTableStatement() IShowCreateTableStatementContext
	DropTableStatement() IDropTableStatementContext
	CleanTemporaryTableStatement() ICleanTemporaryTableStatementContext
	RecoverTableStatement() IRecoverTableStatementContext
	TruncateTableStatement() ITruncateTableStatementContext
	ShowTableStatement() IShowTableStatementContext
	DescTableStatement() IDescTableStatementContext
	ShowTableStatusStatement() IShowTableStatusStatementContext
	ShowColumnStatement() IShowColumnStatementContext
	RefreshTableStatement() IRefreshTableStatementContext
	AlterTableStatement() IAlterTableStatementContext
	CancelAlterTableStatement() ICancelAlterTableStatementContext
	ShowAlterStatement() IShowAlterStatementContext
	ShowTemporaryTablesStatement() IShowTemporaryTablesStatementContext
	CreateViewStatement() ICreateViewStatementContext
	AlterViewStatement() IAlterViewStatementContext
	DropViewStatement() IDropViewStatementContext
	ShowPartitionsStatement() IShowPartitionsStatementContext
	RecoverPartitionStatement() IRecoverPartitionStatementContext
	CreateIndexStatement() ICreateIndexStatementContext
	DropIndexStatement() IDropIndexStatementContext
	ShowIndexStatement() IShowIndexStatementContext
	SubmitTaskStatement() ISubmitTaskStatementContext
	DropTaskStatement() IDropTaskStatementContext
	CreateMaterializedViewStatement() ICreateMaterializedViewStatementContext
	ShowMaterializedViewsStatement() IShowMaterializedViewsStatementContext
	DropMaterializedViewStatement() IDropMaterializedViewStatementContext
	AlterMaterializedViewStatement() IAlterMaterializedViewStatementContext
	RefreshMaterializedViewStatement() IRefreshMaterializedViewStatementContext
	CancelRefreshMaterializedViewStatement() ICancelRefreshMaterializedViewStatementContext
	CreateExternalCatalogStatement() ICreateExternalCatalogStatementContext
	DropExternalCatalogStatement() IDropExternalCatalogStatementContext
	ShowCatalogsStatement() IShowCatalogsStatementContext
	ShowCreateExternalCatalogStatement() IShowCreateExternalCatalogStatementContext
	AlterCatalogStatement() IAlterCatalogStatementContext
	InsertStatement() IInsertStatementContext
	UpdateStatement() IUpdateStatementContext
	DeleteStatement() IDeleteStatementContext
	CreateRoutineLoadStatement() ICreateRoutineLoadStatementContext
	AlterRoutineLoadStatement() IAlterRoutineLoadStatementContext
	StopRoutineLoadStatement() IStopRoutineLoadStatementContext
	ResumeRoutineLoadStatement() IResumeRoutineLoadStatementContext
	PauseRoutineLoadStatement() IPauseRoutineLoadStatementContext
	ShowRoutineLoadStatement() IShowRoutineLoadStatementContext
	ShowRoutineLoadTaskStatement() IShowRoutineLoadTaskStatementContext
	ShowCreateRoutineLoadStatement() IShowCreateRoutineLoadStatementContext
	ShowStreamLoadStatement() IShowStreamLoadStatementContext
	AdminSetConfigStatement() IAdminSetConfigStatementContext
	AdminSetReplicaStatusStatement() IAdminSetReplicaStatusStatementContext
	AdminShowConfigStatement() IAdminShowConfigStatementContext
	AdminShowReplicaDistributionStatement() IAdminShowReplicaDistributionStatementContext
	AdminShowReplicaStatusStatement() IAdminShowReplicaStatusStatementContext
	AdminRepairTableStatement() IAdminRepairTableStatementContext
	AdminCancelRepairTableStatement() IAdminCancelRepairTableStatementContext
	AdminCheckTabletsStatement() IAdminCheckTabletsStatementContext
	AdminSetPartitionVersion() IAdminSetPartitionVersionContext
	KillStatement() IKillStatementContext
	SyncStatement() ISyncStatementContext
	ExecuteScriptStatement() IExecuteScriptStatementContext
	AdminSetAutomatedSnapshotOnStatement() IAdminSetAutomatedSnapshotOnStatementContext
	AdminSetAutomatedSnapshotOffStatement() IAdminSetAutomatedSnapshotOffStatementContext
	AlterSystemStatement() IAlterSystemStatementContext
	CancelAlterSystemStatement() ICancelAlterSystemStatementContext
	ShowComputeNodesStatement() IShowComputeNodesStatementContext
	AnalyzeStatement() IAnalyzeStatementContext
	DropStatsStatement() IDropStatsStatementContext
	CreateAnalyzeStatement() ICreateAnalyzeStatementContext
	DropAnalyzeJobStatement() IDropAnalyzeJobStatementContext
	AnalyzeHistogramStatement() IAnalyzeHistogramStatementContext
	DropHistogramStatement() IDropHistogramStatementContext
	ShowAnalyzeStatement() IShowAnalyzeStatementContext
	ShowStatsMetaStatement() IShowStatsMetaStatementContext
	ShowHistogramMetaStatement() IShowHistogramMetaStatementContext
	KillAnalyzeStatement() IKillAnalyzeStatementContext
	AnalyzeProfileStatement() IAnalyzeProfileStatementContext
	CreateResourceGroupStatement() ICreateResourceGroupStatementContext
	DropResourceGroupStatement() IDropResourceGroupStatementContext
	AlterResourceGroupStatement() IAlterResourceGroupStatementContext
	ShowResourceGroupStatement() IShowResourceGroupStatementContext
	ShowResourceGroupUsageStatement() IShowResourceGroupUsageStatementContext
	CreateResourceStatement() ICreateResourceStatementContext
	AlterResourceStatement() IAlterResourceStatementContext
	DropResourceStatement() IDropResourceStatementContext
	ShowResourceStatement() IShowResourceStatementContext
	ShowFunctionsStatement() IShowFunctionsStatementContext
	DropFunctionStatement() IDropFunctionStatementContext
	CreateFunctionStatement() ICreateFunctionStatementContext
	LoadStatement() ILoadStatementContext
	ShowLoadStatement() IShowLoadStatementContext
	ShowLoadWarningsStatement() IShowLoadWarningsStatementContext
	CancelLoadStatement() ICancelLoadStatementContext
	AlterLoadStatement() IAlterLoadStatementContext
	ShowAuthorStatement() IShowAuthorStatementContext
	ShowBackendsStatement() IShowBackendsStatementContext
	ShowBrokerStatement() IShowBrokerStatementContext
	ShowCharsetStatement() IShowCharsetStatementContext
	ShowCollationStatement() IShowCollationStatementContext
	ShowDeleteStatement() IShowDeleteStatementContext
	ShowDynamicPartitionStatement() IShowDynamicPartitionStatementContext
	ShowEventsStatement() IShowEventsStatementContext
	ShowEnginesStatement() IShowEnginesStatementContext
	ShowFrontendsStatement() IShowFrontendsStatementContext
	ShowPluginsStatement() IShowPluginsStatementContext
	ShowRepositoriesStatement() IShowRepositoriesStatementContext
	ShowOpenTableStatement() IShowOpenTableStatementContext
	ShowPrivilegesStatement() IShowPrivilegesStatementContext
	ShowProcedureStatement() IShowProcedureStatementContext
	ShowProcStatement() IShowProcStatementContext
	ShowProcesslistStatement() IShowProcesslistStatementContext
	ShowProfilelistStatement() IShowProfilelistStatementContext
	ShowRunningQueriesStatement() IShowRunningQueriesStatementContext
	ShowStatusStatement() IShowStatusStatementContext
	ShowTabletStatement() IShowTabletStatementContext
	ShowTransactionStatement() IShowTransactionStatementContext
	ShowTriggersStatement() IShowTriggersStatementContext
	ShowUserPropertyStatement() IShowUserPropertyStatementContext
	ShowVariablesStatement() IShowVariablesStatementContext
	ShowWarningStatement() IShowWarningStatementContext
	HelpStatement() IHelpStatementContext
	CreateUserStatement() ICreateUserStatementContext
	DropUserStatement() IDropUserStatementContext
	AlterUserStatement() IAlterUserStatementContext
	ShowUserStatement() IShowUserStatementContext
	ShowAuthenticationStatement() IShowAuthenticationStatementContext
	ExecuteAsStatement() IExecuteAsStatementContext
	CreateRoleStatement() ICreateRoleStatementContext
	AlterRoleStatement() IAlterRoleStatementContext
	DropRoleStatement() IDropRoleStatementContext
	ShowRolesStatement() IShowRolesStatementContext
	GrantRoleStatement() IGrantRoleStatementContext
	RevokeRoleStatement() IRevokeRoleStatementContext
	SetRoleStatement() ISetRoleStatementContext
	SetDefaultRoleStatement() ISetDefaultRoleStatementContext
	GrantPrivilegeStatement() IGrantPrivilegeStatementContext
	RevokePrivilegeStatement() IRevokePrivilegeStatementContext
	ShowGrantsStatement() IShowGrantsStatementContext
	CreateSecurityIntegrationStatement() ICreateSecurityIntegrationStatementContext
	AlterSecurityIntegrationStatement() IAlterSecurityIntegrationStatementContext
	DropSecurityIntegrationStatement() IDropSecurityIntegrationStatementContext
	ShowSecurityIntegrationStatement() IShowSecurityIntegrationStatementContext
	ShowCreateSecurityIntegrationStatement() IShowCreateSecurityIntegrationStatementContext
	CreateGroupProviderStatement() ICreateGroupProviderStatementContext
	DropGroupProviderStatement() IDropGroupProviderStatementContext
	ShowGroupProvidersStatement() IShowGroupProvidersStatementContext
	ShowCreateGroupProviderStatement() IShowCreateGroupProviderStatementContext
	BackupStatement() IBackupStatementContext
	CancelBackupStatement() ICancelBackupStatementContext
	ShowBackupStatement() IShowBackupStatementContext
	RestoreStatement() IRestoreStatementContext
	CancelRestoreStatement() ICancelRestoreStatementContext
	ShowRestoreStatement() IShowRestoreStatementContext
	ShowSnapshotStatement() IShowSnapshotStatementContext
	CreateRepositoryStatement() ICreateRepositoryStatementContext
	DropRepositoryStatement() IDropRepositoryStatementContext
	AddSqlBlackListStatement() IAddSqlBlackListStatementContext
	DelSqlBlackListStatement() IDelSqlBlackListStatementContext
	ShowSqlBlackListStatement() IShowSqlBlackListStatementContext
	ShowWhiteListStatement() IShowWhiteListStatementContext
	AddBackendBlackListStatement() IAddBackendBlackListStatementContext
	DelBackendBlackListStatement() IDelBackendBlackListStatementContext
	ShowBackendBlackListStatement() IShowBackendBlackListStatementContext
	CreateDataCacheRuleStatement() ICreateDataCacheRuleStatementContext
	ShowDataCacheRulesStatement() IShowDataCacheRulesStatementContext
	DropDataCacheRuleStatement() IDropDataCacheRuleStatementContext
	ClearDataCacheRulesStatement() IClearDataCacheRulesStatementContext
	DataCacheSelectStatement() IDataCacheSelectStatementContext
	ExportStatement() IExportStatementContext
	CancelExportStatement() ICancelExportStatementContext
	ShowExportStatement() IShowExportStatementContext
	InstallPluginStatement() IInstallPluginStatementContext
	UninstallPluginStatement() IUninstallPluginStatementContext
	CreateFileStatement() ICreateFileStatementContext
	DropFileStatement() IDropFileStatementContext
	ShowSmallFilesStatement() IShowSmallFilesStatementContext
	SetStatement() ISetStatementContext
	SetUserPropertyStatement() ISetUserPropertyStatementContext
	CreateStorageVolumeStatement() ICreateStorageVolumeStatementContext
	AlterStorageVolumeStatement() IAlterStorageVolumeStatementContext
	DropStorageVolumeStatement() IDropStorageVolumeStatementContext
	ShowStorageVolumesStatement() IShowStorageVolumesStatementContext
	DescStorageVolumeStatement() IDescStorageVolumeStatementContext
	SetDefaultStorageVolumeStatement() ISetDefaultStorageVolumeStatementContext
	CreatePipeStatement() ICreatePipeStatementContext
	DropPipeStatement() IDropPipeStatementContext
	AlterPipeStatement() IAlterPipeStatementContext
	ShowPipeStatement() IShowPipeStatementContext
	DescPipeStatement() IDescPipeStatementContext
	CancelCompactionStatement() ICancelCompactionStatementContext
	UpdateFailPointStatusStatement() IUpdateFailPointStatusStatementContext
	ShowFailPointStatement() IShowFailPointStatementContext
	PrepareStatement() IPrepareStatementContext
	ExecuteStatement() IExecuteStatementContext
	DeallocateStatement() IDeallocateStatementContext
	CreateDictionaryStatement() ICreateDictionaryStatementContext
	DropDictionaryStatement() IDropDictionaryStatementContext
	RefreshDictionaryStatement() IRefreshDictionaryStatementContext
	ShowDictionaryStatement() IShowDictionaryStatementContext
	CancelRefreshDictionaryStatement() ICancelRefreshDictionaryStatementContext
	AlterPlanAdvisorAddStatement() IAlterPlanAdvisorAddStatementContext
	TruncatePlanAdvisorStatement() ITruncatePlanAdvisorStatementContext
	AlterPlanAdvisorDropStatement() IAlterPlanAdvisorDropStatementContext
	ShowPlanAdvisorStatement() IShowPlanAdvisorStatementContext
	CreateWarehouseStatement() ICreateWarehouseStatementContext
	DropWarehouseStatement() IDropWarehouseStatementContext
	SuspendWarehouseStatement() ISuspendWarehouseStatementContext
	ResumeWarehouseStatement() IResumeWarehouseStatementContext
	SetWarehouseStatement() ISetWarehouseStatementContext
	ShowWarehousesStatement() IShowWarehousesStatementContext
	ShowClustersStatement() IShowClustersStatementContext
	ShowNodesStatement() IShowNodesStatementContext
	AlterWarehouseStatement() IAlterWarehouseStatementContext
	CreateCNGroupStatement() ICreateCNGroupStatementContext
	DropCNGroupStatement() IDropCNGroupStatementContext
	EnableCNGroupStatement() IEnableCNGroupStatementContext
	DisableCNGroupStatement() IDisableCNGroupStatementContext
	AlterCNGroupStatement() IAlterCNGroupStatementContext
	BeginStatement() IBeginStatementContext
	CommitStatement() ICommitStatementContext
	RollbackStatement() IRollbackStatementContext
	TranslateStatement() ITranslateStatementContext
	CreateBaselinePlanStatement() ICreateBaselinePlanStatementContext
	DropBaselinePlanStatement() IDropBaselinePlanStatementContext
	ShowBaselinePlanStatement() IShowBaselinePlanStatementContext
	UnsupportedStatement() IUnsupportedStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *StatementContext) UseDatabaseStatement() IUseDatabaseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseDatabaseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseDatabaseStatementContext)
}

func (s *StatementContext) UseCatalogStatement() IUseCatalogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseCatalogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseCatalogStatementContext)
}

func (s *StatementContext) SetCatalogStatement() ISetCatalogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetCatalogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetCatalogStatementContext)
}

func (s *StatementContext) ShowDatabasesStatement() IShowDatabasesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDatabasesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDatabasesStatementContext)
}

func (s *StatementContext) AlterDbQuotaStatement() IAlterDbQuotaStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterDbQuotaStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterDbQuotaStatementContext)
}

func (s *StatementContext) CreateDbStatement() ICreateDbStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDbStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDbStatementContext)
}

func (s *StatementContext) DropDbStatement() IDropDbStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropDbStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropDbStatementContext)
}

func (s *StatementContext) ShowCreateDbStatement() IShowCreateDbStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCreateDbStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCreateDbStatementContext)
}

func (s *StatementContext) AlterDatabaseRenameStatement() IAlterDatabaseRenameStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterDatabaseRenameStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterDatabaseRenameStatementContext)
}

func (s *StatementContext) RecoverDbStmt() IRecoverDbStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecoverDbStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecoverDbStmtContext)
}

func (s *StatementContext) ShowDataStmt() IShowDataStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDataStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDataStmtContext)
}

func (s *StatementContext) ShowDataDistributionStmt() IShowDataDistributionStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDataDistributionStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDataDistributionStmtContext)
}

func (s *StatementContext) CreateTableStatement() ICreateTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableStatementContext)
}

func (s *StatementContext) CreateTableAsSelectStatement() ICreateTableAsSelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableAsSelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableAsSelectStatementContext)
}

func (s *StatementContext) CreateTableLikeStatement() ICreateTableLikeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableLikeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableLikeStatementContext)
}

func (s *StatementContext) ShowCreateTableStatement() IShowCreateTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCreateTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCreateTableStatementContext)
}

func (s *StatementContext) DropTableStatement() IDropTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTableStatementContext)
}

func (s *StatementContext) CleanTemporaryTableStatement() ICleanTemporaryTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICleanTemporaryTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICleanTemporaryTableStatementContext)
}

func (s *StatementContext) RecoverTableStatement() IRecoverTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecoverTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecoverTableStatementContext)
}

func (s *StatementContext) TruncateTableStatement() ITruncateTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncateTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncateTableStatementContext)
}

func (s *StatementContext) ShowTableStatement() IShowTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTableStatementContext)
}

func (s *StatementContext) DescTableStatement() IDescTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescTableStatementContext)
}

func (s *StatementContext) ShowTableStatusStatement() IShowTableStatusStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTableStatusStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTableStatusStatementContext)
}

func (s *StatementContext) ShowColumnStatement() IShowColumnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowColumnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowColumnStatementContext)
}

func (s *StatementContext) RefreshTableStatement() IRefreshTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshTableStatementContext)
}

func (s *StatementContext) AlterTableStatement() IAlterTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableStatementContext)
}

func (s *StatementContext) CancelAlterTableStatement() ICancelAlterTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelAlterTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelAlterTableStatementContext)
}

func (s *StatementContext) ShowAlterStatement() IShowAlterStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowAlterStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowAlterStatementContext)
}

func (s *StatementContext) ShowTemporaryTablesStatement() IShowTemporaryTablesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTemporaryTablesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTemporaryTablesStatementContext)
}

func (s *StatementContext) CreateViewStatement() ICreateViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateViewStatementContext)
}

func (s *StatementContext) AlterViewStatement() IAlterViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterViewStatementContext)
}

func (s *StatementContext) DropViewStatement() IDropViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropViewStatementContext)
}

func (s *StatementContext) ShowPartitionsStatement() IShowPartitionsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowPartitionsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowPartitionsStatementContext)
}

func (s *StatementContext) RecoverPartitionStatement() IRecoverPartitionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecoverPartitionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecoverPartitionStatementContext)
}

func (s *StatementContext) CreateIndexStatement() ICreateIndexStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateIndexStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateIndexStatementContext)
}

func (s *StatementContext) DropIndexStatement() IDropIndexStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropIndexStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropIndexStatementContext)
}

func (s *StatementContext) ShowIndexStatement() IShowIndexStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowIndexStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowIndexStatementContext)
}

func (s *StatementContext) SubmitTaskStatement() ISubmitTaskStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubmitTaskStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubmitTaskStatementContext)
}

func (s *StatementContext) DropTaskStatement() IDropTaskStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTaskStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTaskStatementContext)
}

func (s *StatementContext) CreateMaterializedViewStatement() ICreateMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateMaterializedViewStatementContext)
}

func (s *StatementContext) ShowMaterializedViewsStatement() IShowMaterializedViewsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowMaterializedViewsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowMaterializedViewsStatementContext)
}

func (s *StatementContext) DropMaterializedViewStatement() IDropMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropMaterializedViewStatementContext)
}

func (s *StatementContext) AlterMaterializedViewStatement() IAlterMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterMaterializedViewStatementContext)
}

func (s *StatementContext) RefreshMaterializedViewStatement() IRefreshMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshMaterializedViewStatementContext)
}

func (s *StatementContext) CancelRefreshMaterializedViewStatement() ICancelRefreshMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelRefreshMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelRefreshMaterializedViewStatementContext)
}

func (s *StatementContext) CreateExternalCatalogStatement() ICreateExternalCatalogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateExternalCatalogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateExternalCatalogStatementContext)
}

func (s *StatementContext) DropExternalCatalogStatement() IDropExternalCatalogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropExternalCatalogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropExternalCatalogStatementContext)
}

func (s *StatementContext) ShowCatalogsStatement() IShowCatalogsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCatalogsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCatalogsStatementContext)
}

func (s *StatementContext) ShowCreateExternalCatalogStatement() IShowCreateExternalCatalogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCreateExternalCatalogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCreateExternalCatalogStatementContext)
}

func (s *StatementContext) AlterCatalogStatement() IAlterCatalogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterCatalogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterCatalogStatementContext)
}

func (s *StatementContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *StatementContext) UpdateStatement() IUpdateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateStatementContext)
}

func (s *StatementContext) DeleteStatement() IDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteStatementContext)
}

func (s *StatementContext) CreateRoutineLoadStatement() ICreateRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRoutineLoadStatementContext)
}

func (s *StatementContext) AlterRoutineLoadStatement() IAlterRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterRoutineLoadStatementContext)
}

func (s *StatementContext) StopRoutineLoadStatement() IStopRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStopRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStopRoutineLoadStatementContext)
}

func (s *StatementContext) ResumeRoutineLoadStatement() IResumeRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResumeRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResumeRoutineLoadStatementContext)
}

func (s *StatementContext) PauseRoutineLoadStatement() IPauseRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPauseRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPauseRoutineLoadStatementContext)
}

func (s *StatementContext) ShowRoutineLoadStatement() IShowRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRoutineLoadStatementContext)
}

func (s *StatementContext) ShowRoutineLoadTaskStatement() IShowRoutineLoadTaskStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRoutineLoadTaskStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRoutineLoadTaskStatementContext)
}

func (s *StatementContext) ShowCreateRoutineLoadStatement() IShowCreateRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCreateRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCreateRoutineLoadStatementContext)
}

func (s *StatementContext) ShowStreamLoadStatement() IShowStreamLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStreamLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStreamLoadStatementContext)
}

func (s *StatementContext) AdminSetConfigStatement() IAdminSetConfigStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminSetConfigStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminSetConfigStatementContext)
}

func (s *StatementContext) AdminSetReplicaStatusStatement() IAdminSetReplicaStatusStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminSetReplicaStatusStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminSetReplicaStatusStatementContext)
}

func (s *StatementContext) AdminShowConfigStatement() IAdminShowConfigStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminShowConfigStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminShowConfigStatementContext)
}

func (s *StatementContext) AdminShowReplicaDistributionStatement() IAdminShowReplicaDistributionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminShowReplicaDistributionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminShowReplicaDistributionStatementContext)
}

func (s *StatementContext) AdminShowReplicaStatusStatement() IAdminShowReplicaStatusStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminShowReplicaStatusStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminShowReplicaStatusStatementContext)
}

func (s *StatementContext) AdminRepairTableStatement() IAdminRepairTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminRepairTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminRepairTableStatementContext)
}

func (s *StatementContext) AdminCancelRepairTableStatement() IAdminCancelRepairTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminCancelRepairTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminCancelRepairTableStatementContext)
}

func (s *StatementContext) AdminCheckTabletsStatement() IAdminCheckTabletsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminCheckTabletsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminCheckTabletsStatementContext)
}

func (s *StatementContext) AdminSetPartitionVersion() IAdminSetPartitionVersionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminSetPartitionVersionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminSetPartitionVersionContext)
}

func (s *StatementContext) KillStatement() IKillStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKillStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKillStatementContext)
}

func (s *StatementContext) SyncStatement() ISyncStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyncStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyncStatementContext)
}

func (s *StatementContext) ExecuteScriptStatement() IExecuteScriptStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteScriptStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteScriptStatementContext)
}

func (s *StatementContext) AdminSetAutomatedSnapshotOnStatement() IAdminSetAutomatedSnapshotOnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminSetAutomatedSnapshotOnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminSetAutomatedSnapshotOnStatementContext)
}

func (s *StatementContext) AdminSetAutomatedSnapshotOffStatement() IAdminSetAutomatedSnapshotOffStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminSetAutomatedSnapshotOffStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminSetAutomatedSnapshotOffStatementContext)
}

func (s *StatementContext) AlterSystemStatement() IAlterSystemStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterSystemStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterSystemStatementContext)
}

func (s *StatementContext) CancelAlterSystemStatement() ICancelAlterSystemStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelAlterSystemStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelAlterSystemStatementContext)
}

func (s *StatementContext) ShowComputeNodesStatement() IShowComputeNodesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowComputeNodesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowComputeNodesStatementContext)
}

func (s *StatementContext) AnalyzeStatement() IAnalyzeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeStatementContext)
}

func (s *StatementContext) DropStatsStatement() IDropStatsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropStatsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropStatsStatementContext)
}

func (s *StatementContext) CreateAnalyzeStatement() ICreateAnalyzeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateAnalyzeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateAnalyzeStatementContext)
}

func (s *StatementContext) DropAnalyzeJobStatement() IDropAnalyzeJobStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropAnalyzeJobStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropAnalyzeJobStatementContext)
}

func (s *StatementContext) AnalyzeHistogramStatement() IAnalyzeHistogramStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeHistogramStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeHistogramStatementContext)
}

func (s *StatementContext) DropHistogramStatement() IDropHistogramStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropHistogramStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropHistogramStatementContext)
}

func (s *StatementContext) ShowAnalyzeStatement() IShowAnalyzeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowAnalyzeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowAnalyzeStatementContext)
}

func (s *StatementContext) ShowStatsMetaStatement() IShowStatsMetaStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStatsMetaStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStatsMetaStatementContext)
}

func (s *StatementContext) ShowHistogramMetaStatement() IShowHistogramMetaStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowHistogramMetaStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowHistogramMetaStatementContext)
}

func (s *StatementContext) KillAnalyzeStatement() IKillAnalyzeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKillAnalyzeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKillAnalyzeStatementContext)
}

func (s *StatementContext) AnalyzeProfileStatement() IAnalyzeProfileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeProfileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeProfileStatementContext)
}

func (s *StatementContext) CreateResourceGroupStatement() ICreateResourceGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateResourceGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateResourceGroupStatementContext)
}

func (s *StatementContext) DropResourceGroupStatement() IDropResourceGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropResourceGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropResourceGroupStatementContext)
}

func (s *StatementContext) AlterResourceGroupStatement() IAlterResourceGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterResourceGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterResourceGroupStatementContext)
}

func (s *StatementContext) ShowResourceGroupStatement() IShowResourceGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowResourceGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowResourceGroupStatementContext)
}

func (s *StatementContext) ShowResourceGroupUsageStatement() IShowResourceGroupUsageStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowResourceGroupUsageStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowResourceGroupUsageStatementContext)
}

func (s *StatementContext) CreateResourceStatement() ICreateResourceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateResourceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateResourceStatementContext)
}

func (s *StatementContext) AlterResourceStatement() IAlterResourceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterResourceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterResourceStatementContext)
}

func (s *StatementContext) DropResourceStatement() IDropResourceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropResourceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropResourceStatementContext)
}

func (s *StatementContext) ShowResourceStatement() IShowResourceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowResourceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowResourceStatementContext)
}

func (s *StatementContext) ShowFunctionsStatement() IShowFunctionsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFunctionsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFunctionsStatementContext)
}

func (s *StatementContext) DropFunctionStatement() IDropFunctionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFunctionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFunctionStatementContext)
}

func (s *StatementContext) CreateFunctionStatement() ICreateFunctionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateFunctionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateFunctionStatementContext)
}

func (s *StatementContext) LoadStatement() ILoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadStatementContext)
}

func (s *StatementContext) ShowLoadStatement() IShowLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowLoadStatementContext)
}

func (s *StatementContext) ShowLoadWarningsStatement() IShowLoadWarningsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowLoadWarningsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowLoadWarningsStatementContext)
}

func (s *StatementContext) CancelLoadStatement() ICancelLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelLoadStatementContext)
}

func (s *StatementContext) AlterLoadStatement() IAlterLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterLoadStatementContext)
}

func (s *StatementContext) ShowAuthorStatement() IShowAuthorStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowAuthorStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowAuthorStatementContext)
}

func (s *StatementContext) ShowBackendsStatement() IShowBackendsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowBackendsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowBackendsStatementContext)
}

func (s *StatementContext) ShowBrokerStatement() IShowBrokerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowBrokerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowBrokerStatementContext)
}

func (s *StatementContext) ShowCharsetStatement() IShowCharsetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCharsetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCharsetStatementContext)
}

func (s *StatementContext) ShowCollationStatement() IShowCollationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCollationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCollationStatementContext)
}

func (s *StatementContext) ShowDeleteStatement() IShowDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDeleteStatementContext)
}

func (s *StatementContext) ShowDynamicPartitionStatement() IShowDynamicPartitionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDynamicPartitionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDynamicPartitionStatementContext)
}

func (s *StatementContext) ShowEventsStatement() IShowEventsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowEventsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowEventsStatementContext)
}

func (s *StatementContext) ShowEnginesStatement() IShowEnginesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowEnginesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowEnginesStatementContext)
}

func (s *StatementContext) ShowFrontendsStatement() IShowFrontendsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFrontendsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFrontendsStatementContext)
}

func (s *StatementContext) ShowPluginsStatement() IShowPluginsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowPluginsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowPluginsStatementContext)
}

func (s *StatementContext) ShowRepositoriesStatement() IShowRepositoriesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRepositoriesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRepositoriesStatementContext)
}

func (s *StatementContext) ShowOpenTableStatement() IShowOpenTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowOpenTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowOpenTableStatementContext)
}

func (s *StatementContext) ShowPrivilegesStatement() IShowPrivilegesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowPrivilegesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowPrivilegesStatementContext)
}

func (s *StatementContext) ShowProcedureStatement() IShowProcedureStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowProcedureStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowProcedureStatementContext)
}

func (s *StatementContext) ShowProcStatement() IShowProcStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowProcStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowProcStatementContext)
}

func (s *StatementContext) ShowProcesslistStatement() IShowProcesslistStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowProcesslistStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowProcesslistStatementContext)
}

func (s *StatementContext) ShowProfilelistStatement() IShowProfilelistStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowProfilelistStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowProfilelistStatementContext)
}

func (s *StatementContext) ShowRunningQueriesStatement() IShowRunningQueriesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRunningQueriesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRunningQueriesStatementContext)
}

func (s *StatementContext) ShowStatusStatement() IShowStatusStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStatusStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStatusStatementContext)
}

func (s *StatementContext) ShowTabletStatement() IShowTabletStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTabletStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTabletStatementContext)
}

func (s *StatementContext) ShowTransactionStatement() IShowTransactionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTransactionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTransactionStatementContext)
}

func (s *StatementContext) ShowTriggersStatement() IShowTriggersStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTriggersStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTriggersStatementContext)
}

func (s *StatementContext) ShowUserPropertyStatement() IShowUserPropertyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowUserPropertyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowUserPropertyStatementContext)
}

func (s *StatementContext) ShowVariablesStatement() IShowVariablesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowVariablesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowVariablesStatementContext)
}

func (s *StatementContext) ShowWarningStatement() IShowWarningStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowWarningStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowWarningStatementContext)
}

func (s *StatementContext) HelpStatement() IHelpStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelpStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelpStatementContext)
}

func (s *StatementContext) CreateUserStatement() ICreateUserStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserStatementContext)
}

func (s *StatementContext) DropUserStatement() IDropUserStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropUserStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropUserStatementContext)
}

func (s *StatementContext) AlterUserStatement() IAlterUserStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterUserStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterUserStatementContext)
}

func (s *StatementContext) ShowUserStatement() IShowUserStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowUserStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowUserStatementContext)
}

func (s *StatementContext) ShowAuthenticationStatement() IShowAuthenticationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowAuthenticationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowAuthenticationStatementContext)
}

func (s *StatementContext) ExecuteAsStatement() IExecuteAsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteAsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteAsStatementContext)
}

func (s *StatementContext) CreateRoleStatement() ICreateRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRoleStatementContext)
}

func (s *StatementContext) AlterRoleStatement() IAlterRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterRoleStatementContext)
}

func (s *StatementContext) DropRoleStatement() IDropRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropRoleStatementContext)
}

func (s *StatementContext) ShowRolesStatement() IShowRolesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRolesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRolesStatementContext)
}

func (s *StatementContext) GrantRoleStatement() IGrantRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRoleStatementContext)
}

func (s *StatementContext) RevokeRoleStatement() IRevokeRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokeRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokeRoleStatementContext)
}

func (s *StatementContext) SetRoleStatement() ISetRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetRoleStatementContext)
}

func (s *StatementContext) SetDefaultRoleStatement() ISetDefaultRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetDefaultRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetDefaultRoleStatementContext)
}

func (s *StatementContext) GrantPrivilegeStatement() IGrantPrivilegeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantPrivilegeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantPrivilegeStatementContext)
}

func (s *StatementContext) RevokePrivilegeStatement() IRevokePrivilegeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokePrivilegeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokePrivilegeStatementContext)
}

func (s *StatementContext) ShowGrantsStatement() IShowGrantsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowGrantsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowGrantsStatementContext)
}

func (s *StatementContext) CreateSecurityIntegrationStatement() ICreateSecurityIntegrationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateSecurityIntegrationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateSecurityIntegrationStatementContext)
}

func (s *StatementContext) AlterSecurityIntegrationStatement() IAlterSecurityIntegrationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterSecurityIntegrationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterSecurityIntegrationStatementContext)
}

func (s *StatementContext) DropSecurityIntegrationStatement() IDropSecurityIntegrationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropSecurityIntegrationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropSecurityIntegrationStatementContext)
}

func (s *StatementContext) ShowSecurityIntegrationStatement() IShowSecurityIntegrationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowSecurityIntegrationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowSecurityIntegrationStatementContext)
}

func (s *StatementContext) ShowCreateSecurityIntegrationStatement() IShowCreateSecurityIntegrationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCreateSecurityIntegrationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCreateSecurityIntegrationStatementContext)
}

func (s *StatementContext) CreateGroupProviderStatement() ICreateGroupProviderStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateGroupProviderStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateGroupProviderStatementContext)
}

func (s *StatementContext) DropGroupProviderStatement() IDropGroupProviderStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropGroupProviderStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropGroupProviderStatementContext)
}

func (s *StatementContext) ShowGroupProvidersStatement() IShowGroupProvidersStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowGroupProvidersStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowGroupProvidersStatementContext)
}

func (s *StatementContext) ShowCreateGroupProviderStatement() IShowCreateGroupProviderStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCreateGroupProviderStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCreateGroupProviderStatementContext)
}

func (s *StatementContext) BackupStatement() IBackupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackupStatementContext)
}

func (s *StatementContext) CancelBackupStatement() ICancelBackupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelBackupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelBackupStatementContext)
}

func (s *StatementContext) ShowBackupStatement() IShowBackupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowBackupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowBackupStatementContext)
}

func (s *StatementContext) RestoreStatement() IRestoreStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRestoreStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRestoreStatementContext)
}

func (s *StatementContext) CancelRestoreStatement() ICancelRestoreStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelRestoreStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelRestoreStatementContext)
}

func (s *StatementContext) ShowRestoreStatement() IShowRestoreStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRestoreStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRestoreStatementContext)
}

func (s *StatementContext) ShowSnapshotStatement() IShowSnapshotStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowSnapshotStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowSnapshotStatementContext)
}

func (s *StatementContext) CreateRepositoryStatement() ICreateRepositoryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRepositoryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRepositoryStatementContext)
}

func (s *StatementContext) DropRepositoryStatement() IDropRepositoryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropRepositoryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropRepositoryStatementContext)
}

func (s *StatementContext) AddSqlBlackListStatement() IAddSqlBlackListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddSqlBlackListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddSqlBlackListStatementContext)
}

func (s *StatementContext) DelSqlBlackListStatement() IDelSqlBlackListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelSqlBlackListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelSqlBlackListStatementContext)
}

func (s *StatementContext) ShowSqlBlackListStatement() IShowSqlBlackListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowSqlBlackListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowSqlBlackListStatementContext)
}

func (s *StatementContext) ShowWhiteListStatement() IShowWhiteListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowWhiteListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowWhiteListStatementContext)
}

func (s *StatementContext) AddBackendBlackListStatement() IAddBackendBlackListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddBackendBlackListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddBackendBlackListStatementContext)
}

func (s *StatementContext) DelBackendBlackListStatement() IDelBackendBlackListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelBackendBlackListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelBackendBlackListStatementContext)
}

func (s *StatementContext) ShowBackendBlackListStatement() IShowBackendBlackListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowBackendBlackListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowBackendBlackListStatementContext)
}

func (s *StatementContext) CreateDataCacheRuleStatement() ICreateDataCacheRuleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDataCacheRuleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDataCacheRuleStatementContext)
}

func (s *StatementContext) ShowDataCacheRulesStatement() IShowDataCacheRulesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDataCacheRulesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDataCacheRulesStatementContext)
}

func (s *StatementContext) DropDataCacheRuleStatement() IDropDataCacheRuleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropDataCacheRuleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropDataCacheRuleStatementContext)
}

func (s *StatementContext) ClearDataCacheRulesStatement() IClearDataCacheRulesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClearDataCacheRulesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClearDataCacheRulesStatementContext)
}

func (s *StatementContext) DataCacheSelectStatement() IDataCacheSelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataCacheSelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataCacheSelectStatementContext)
}

func (s *StatementContext) ExportStatement() IExportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportStatementContext)
}

func (s *StatementContext) CancelExportStatement() ICancelExportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelExportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelExportStatementContext)
}

func (s *StatementContext) ShowExportStatement() IShowExportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowExportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowExportStatementContext)
}

func (s *StatementContext) InstallPluginStatement() IInstallPluginStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstallPluginStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstallPluginStatementContext)
}

func (s *StatementContext) UninstallPluginStatement() IUninstallPluginStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUninstallPluginStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUninstallPluginStatementContext)
}

func (s *StatementContext) CreateFileStatement() ICreateFileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateFileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateFileStatementContext)
}

func (s *StatementContext) DropFileStatement() IDropFileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFileStatementContext)
}

func (s *StatementContext) ShowSmallFilesStatement() IShowSmallFilesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowSmallFilesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowSmallFilesStatementContext)
}

func (s *StatementContext) SetStatement() ISetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetStatementContext)
}

func (s *StatementContext) SetUserPropertyStatement() ISetUserPropertyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetUserPropertyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetUserPropertyStatementContext)
}

func (s *StatementContext) CreateStorageVolumeStatement() ICreateStorageVolumeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateStorageVolumeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateStorageVolumeStatementContext)
}

func (s *StatementContext) AlterStorageVolumeStatement() IAlterStorageVolumeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStorageVolumeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStorageVolumeStatementContext)
}

func (s *StatementContext) DropStorageVolumeStatement() IDropStorageVolumeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropStorageVolumeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropStorageVolumeStatementContext)
}

func (s *StatementContext) ShowStorageVolumesStatement() IShowStorageVolumesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStorageVolumesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStorageVolumesStatementContext)
}

func (s *StatementContext) DescStorageVolumeStatement() IDescStorageVolumeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescStorageVolumeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescStorageVolumeStatementContext)
}

func (s *StatementContext) SetDefaultStorageVolumeStatement() ISetDefaultStorageVolumeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetDefaultStorageVolumeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetDefaultStorageVolumeStatementContext)
}

func (s *StatementContext) CreatePipeStatement() ICreatePipeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreatePipeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreatePipeStatementContext)
}

func (s *StatementContext) DropPipeStatement() IDropPipeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropPipeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropPipeStatementContext)
}

func (s *StatementContext) AlterPipeStatement() IAlterPipeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterPipeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterPipeStatementContext)
}

func (s *StatementContext) ShowPipeStatement() IShowPipeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowPipeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowPipeStatementContext)
}

func (s *StatementContext) DescPipeStatement() IDescPipeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescPipeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescPipeStatementContext)
}

func (s *StatementContext) CancelCompactionStatement() ICancelCompactionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelCompactionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelCompactionStatementContext)
}

func (s *StatementContext) UpdateFailPointStatusStatement() IUpdateFailPointStatusStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateFailPointStatusStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateFailPointStatusStatementContext)
}

func (s *StatementContext) ShowFailPointStatement() IShowFailPointStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFailPointStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFailPointStatementContext)
}

func (s *StatementContext) PrepareStatement() IPrepareStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrepareStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrepareStatementContext)
}

func (s *StatementContext) ExecuteStatement() IExecuteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteStatementContext)
}

func (s *StatementContext) DeallocateStatement() IDeallocateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeallocateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeallocateStatementContext)
}

func (s *StatementContext) CreateDictionaryStatement() ICreateDictionaryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDictionaryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDictionaryStatementContext)
}

func (s *StatementContext) DropDictionaryStatement() IDropDictionaryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropDictionaryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropDictionaryStatementContext)
}

func (s *StatementContext) RefreshDictionaryStatement() IRefreshDictionaryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshDictionaryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshDictionaryStatementContext)
}

func (s *StatementContext) ShowDictionaryStatement() IShowDictionaryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDictionaryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDictionaryStatementContext)
}

func (s *StatementContext) CancelRefreshDictionaryStatement() ICancelRefreshDictionaryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelRefreshDictionaryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelRefreshDictionaryStatementContext)
}

func (s *StatementContext) AlterPlanAdvisorAddStatement() IAlterPlanAdvisorAddStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterPlanAdvisorAddStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterPlanAdvisorAddStatementContext)
}

func (s *StatementContext) TruncatePlanAdvisorStatement() ITruncatePlanAdvisorStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncatePlanAdvisorStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncatePlanAdvisorStatementContext)
}

func (s *StatementContext) AlterPlanAdvisorDropStatement() IAlterPlanAdvisorDropStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterPlanAdvisorDropStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterPlanAdvisorDropStatementContext)
}

func (s *StatementContext) ShowPlanAdvisorStatement() IShowPlanAdvisorStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowPlanAdvisorStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowPlanAdvisorStatementContext)
}

func (s *StatementContext) CreateWarehouseStatement() ICreateWarehouseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateWarehouseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateWarehouseStatementContext)
}

func (s *StatementContext) DropWarehouseStatement() IDropWarehouseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropWarehouseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropWarehouseStatementContext)
}

func (s *StatementContext) SuspendWarehouseStatement() ISuspendWarehouseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuspendWarehouseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuspendWarehouseStatementContext)
}

func (s *StatementContext) ResumeWarehouseStatement() IResumeWarehouseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResumeWarehouseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResumeWarehouseStatementContext)
}

func (s *StatementContext) SetWarehouseStatement() ISetWarehouseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetWarehouseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetWarehouseStatementContext)
}

func (s *StatementContext) ShowWarehousesStatement() IShowWarehousesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowWarehousesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowWarehousesStatementContext)
}

func (s *StatementContext) ShowClustersStatement() IShowClustersStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowClustersStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowClustersStatementContext)
}

func (s *StatementContext) ShowNodesStatement() IShowNodesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowNodesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowNodesStatementContext)
}

func (s *StatementContext) AlterWarehouseStatement() IAlterWarehouseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterWarehouseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterWarehouseStatementContext)
}

func (s *StatementContext) CreateCNGroupStatement() ICreateCNGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateCNGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateCNGroupStatementContext)
}

func (s *StatementContext) DropCNGroupStatement() IDropCNGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropCNGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropCNGroupStatementContext)
}

func (s *StatementContext) EnableCNGroupStatement() IEnableCNGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnableCNGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnableCNGroupStatementContext)
}

func (s *StatementContext) DisableCNGroupStatement() IDisableCNGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisableCNGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisableCNGroupStatementContext)
}

func (s *StatementContext) AlterCNGroupStatement() IAlterCNGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterCNGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterCNGroupStatementContext)
}

func (s *StatementContext) BeginStatement() IBeginStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBeginStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBeginStatementContext)
}

func (s *StatementContext) CommitStatement() ICommitStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommitStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommitStatementContext)
}

func (s *StatementContext) RollbackStatement() IRollbackStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollbackStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollbackStatementContext)
}

func (s *StatementContext) TranslateStatement() ITranslateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITranslateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITranslateStatementContext)
}

func (s *StatementContext) CreateBaselinePlanStatement() ICreateBaselinePlanStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateBaselinePlanStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateBaselinePlanStatementContext)
}

func (s *StatementContext) DropBaselinePlanStatement() IDropBaselinePlanStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropBaselinePlanStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropBaselinePlanStatementContext)
}

func (s *StatementContext) ShowBaselinePlanStatement() IShowBaselinePlanStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowBaselinePlanStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowBaselinePlanStatementContext)
}

func (s *StatementContext) UnsupportedStatement() IUnsupportedStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, DorisSQLParserParserRULE_statement)
	p.SetState(1297)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1057)
			p.QueryStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1058)
			p.UseDatabaseStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1059)
			p.UseCatalogStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1060)
			p.SetCatalogStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1061)
			p.ShowDatabasesStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1062)
			p.AlterDbQuotaStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1063)
			p.CreateDbStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1064)
			p.DropDbStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1065)
			p.ShowCreateDbStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1066)
			p.AlterDatabaseRenameStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1067)
			p.RecoverDbStmt()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1068)
			p.ShowDataStmt()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1069)
			p.ShowDataDistributionStmt()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1070)
			p.CreateTableStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1071)
			p.CreateTableAsSelectStatement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1072)
			p.CreateTableLikeStatement()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1073)
			p.ShowCreateTableStatement()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1074)
			p.DropTableStatement()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1075)
			p.CleanTemporaryTableStatement()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1076)
			p.RecoverTableStatement()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1077)
			p.TruncateTableStatement()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1078)
			p.ShowTableStatement()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1079)
			p.DescTableStatement()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1080)
			p.ShowTableStatusStatement()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1081)
			p.ShowColumnStatement()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1082)
			p.RefreshTableStatement()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1083)
			p.AlterTableStatement()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1084)
			p.CancelAlterTableStatement()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1085)
			p.ShowAlterStatement()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1086)
			p.ShowTemporaryTablesStatement()
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(1087)
			p.CreateViewStatement()
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(1088)
			p.AlterViewStatement()
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(1089)
			p.DropViewStatement()
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(1090)
			p.ShowPartitionsStatement()
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(1091)
			p.RecoverPartitionStatement()
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(1092)
			p.CreateIndexStatement()
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(1093)
			p.DropIndexStatement()
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(1094)
			p.ShowIndexStatement()
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(1095)
			p.SubmitTaskStatement()
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(1096)
			p.DropTaskStatement()
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(1097)
			p.CreateMaterializedViewStatement()
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(1098)
			p.ShowMaterializedViewsStatement()
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(1099)
			p.DropMaterializedViewStatement()
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(1100)
			p.AlterMaterializedViewStatement()
		}

	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(1101)
			p.RefreshMaterializedViewStatement()
		}

	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(1102)
			p.CancelRefreshMaterializedViewStatement()
		}

	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(1103)
			p.CreateExternalCatalogStatement()
		}

	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(1104)
			p.DropExternalCatalogStatement()
		}

	case 49:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(1105)
			p.ShowCatalogsStatement()
		}

	case 50:
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(1106)
			p.ShowCreateExternalCatalogStatement()
		}

	case 51:
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(1107)
			p.AlterCatalogStatement()
		}

	case 52:
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(1108)
			p.InsertStatement()
		}

	case 53:
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(1109)
			p.UpdateStatement()
		}

	case 54:
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(1110)
			p.DeleteStatement()
		}

	case 55:
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(1111)
			p.CreateRoutineLoadStatement()
		}

	case 56:
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(1112)
			p.AlterRoutineLoadStatement()
		}

	case 57:
		p.EnterOuterAlt(localctx, 57)
		{
			p.SetState(1113)
			p.StopRoutineLoadStatement()
		}

	case 58:
		p.EnterOuterAlt(localctx, 58)
		{
			p.SetState(1114)
			p.ResumeRoutineLoadStatement()
		}

	case 59:
		p.EnterOuterAlt(localctx, 59)
		{
			p.SetState(1115)
			p.PauseRoutineLoadStatement()
		}

	case 60:
		p.EnterOuterAlt(localctx, 60)
		{
			p.SetState(1116)
			p.ShowRoutineLoadStatement()
		}

	case 61:
		p.EnterOuterAlt(localctx, 61)
		{
			p.SetState(1117)
			p.ShowRoutineLoadTaskStatement()
		}

	case 62:
		p.EnterOuterAlt(localctx, 62)
		{
			p.SetState(1118)
			p.ShowCreateRoutineLoadStatement()
		}

	case 63:
		p.EnterOuterAlt(localctx, 63)
		{
			p.SetState(1119)
			p.ShowStreamLoadStatement()
		}

	case 64:
		p.EnterOuterAlt(localctx, 64)
		{
			p.SetState(1120)
			p.AdminSetConfigStatement()
		}

	case 65:
		p.EnterOuterAlt(localctx, 65)
		{
			p.SetState(1121)
			p.AdminSetReplicaStatusStatement()
		}

	case 66:
		p.EnterOuterAlt(localctx, 66)
		{
			p.SetState(1122)
			p.AdminShowConfigStatement()
		}

	case 67:
		p.EnterOuterAlt(localctx, 67)
		{
			p.SetState(1123)
			p.AdminShowReplicaDistributionStatement()
		}

	case 68:
		p.EnterOuterAlt(localctx, 68)
		{
			p.SetState(1124)
			p.AdminShowReplicaStatusStatement()
		}

	case 69:
		p.EnterOuterAlt(localctx, 69)
		{
			p.SetState(1125)
			p.AdminRepairTableStatement()
		}

	case 70:
		p.EnterOuterAlt(localctx, 70)
		{
			p.SetState(1126)
			p.AdminCancelRepairTableStatement()
		}

	case 71:
		p.EnterOuterAlt(localctx, 71)
		{
			p.SetState(1127)
			p.AdminCheckTabletsStatement()
		}

	case 72:
		p.EnterOuterAlt(localctx, 72)
		{
			p.SetState(1128)
			p.AdminSetPartitionVersion()
		}

	case 73:
		p.EnterOuterAlt(localctx, 73)
		{
			p.SetState(1129)
			p.KillStatement()
		}

	case 74:
		p.EnterOuterAlt(localctx, 74)
		{
			p.SetState(1130)
			p.SyncStatement()
		}

	case 75:
		p.EnterOuterAlt(localctx, 75)
		{
			p.SetState(1131)
			p.ExecuteScriptStatement()
		}

	case 76:
		p.EnterOuterAlt(localctx, 76)
		{
			p.SetState(1132)
			p.AdminSetAutomatedSnapshotOnStatement()
		}

	case 77:
		p.EnterOuterAlt(localctx, 77)
		{
			p.SetState(1133)
			p.AdminSetAutomatedSnapshotOffStatement()
		}

	case 78:
		p.EnterOuterAlt(localctx, 78)
		{
			p.SetState(1134)
			p.AlterSystemStatement()
		}

	case 79:
		p.EnterOuterAlt(localctx, 79)
		{
			p.SetState(1135)
			p.CancelAlterSystemStatement()
		}

	case 80:
		p.EnterOuterAlt(localctx, 80)
		{
			p.SetState(1136)
			p.ShowComputeNodesStatement()
		}

	case 81:
		p.EnterOuterAlt(localctx, 81)
		{
			p.SetState(1137)
			p.AnalyzeStatement()
		}

	case 82:
		p.EnterOuterAlt(localctx, 82)
		{
			p.SetState(1138)
			p.DropStatsStatement()
		}

	case 83:
		p.EnterOuterAlt(localctx, 83)
		{
			p.SetState(1139)
			p.CreateAnalyzeStatement()
		}

	case 84:
		p.EnterOuterAlt(localctx, 84)
		{
			p.SetState(1140)
			p.DropAnalyzeJobStatement()
		}

	case 85:
		p.EnterOuterAlt(localctx, 85)
		{
			p.SetState(1141)
			p.AnalyzeHistogramStatement()
		}

	case 86:
		p.EnterOuterAlt(localctx, 86)
		{
			p.SetState(1142)
			p.DropHistogramStatement()
		}

	case 87:
		p.EnterOuterAlt(localctx, 87)
		{
			p.SetState(1143)
			p.ShowAnalyzeStatement()
		}

	case 88:
		p.EnterOuterAlt(localctx, 88)
		{
			p.SetState(1144)
			p.ShowStatsMetaStatement()
		}

	case 89:
		p.EnterOuterAlt(localctx, 89)
		{
			p.SetState(1145)
			p.ShowHistogramMetaStatement()
		}

	case 90:
		p.EnterOuterAlt(localctx, 90)
		{
			p.SetState(1146)
			p.KillAnalyzeStatement()
		}

	case 91:
		p.EnterOuterAlt(localctx, 91)
		{
			p.SetState(1147)
			p.AnalyzeProfileStatement()
		}

	case 92:
		p.EnterOuterAlt(localctx, 92)
		{
			p.SetState(1148)
			p.CreateResourceGroupStatement()
		}

	case 93:
		p.EnterOuterAlt(localctx, 93)
		{
			p.SetState(1149)
			p.DropResourceGroupStatement()
		}

	case 94:
		p.EnterOuterAlt(localctx, 94)
		{
			p.SetState(1150)
			p.AlterResourceGroupStatement()
		}

	case 95:
		p.EnterOuterAlt(localctx, 95)
		{
			p.SetState(1151)
			p.ShowResourceGroupStatement()
		}

	case 96:
		p.EnterOuterAlt(localctx, 96)
		{
			p.SetState(1152)
			p.ShowResourceGroupUsageStatement()
		}

	case 97:
		p.EnterOuterAlt(localctx, 97)
		{
			p.SetState(1153)
			p.CreateResourceStatement()
		}

	case 98:
		p.EnterOuterAlt(localctx, 98)
		{
			p.SetState(1154)
			p.AlterResourceStatement()
		}

	case 99:
		p.EnterOuterAlt(localctx, 99)
		{
			p.SetState(1155)
			p.DropResourceStatement()
		}

	case 100:
		p.EnterOuterAlt(localctx, 100)
		{
			p.SetState(1156)
			p.ShowResourceStatement()
		}

	case 101:
		p.EnterOuterAlt(localctx, 101)
		{
			p.SetState(1157)
			p.ShowFunctionsStatement()
		}

	case 102:
		p.EnterOuterAlt(localctx, 102)
		{
			p.SetState(1158)
			p.DropFunctionStatement()
		}

	case 103:
		p.EnterOuterAlt(localctx, 103)
		{
			p.SetState(1159)
			p.CreateFunctionStatement()
		}

	case 104:
		p.EnterOuterAlt(localctx, 104)
		{
			p.SetState(1160)
			p.LoadStatement()
		}

	case 105:
		p.EnterOuterAlt(localctx, 105)
		{
			p.SetState(1161)
			p.ShowLoadStatement()
		}

	case 106:
		p.EnterOuterAlt(localctx, 106)
		{
			p.SetState(1162)
			p.ShowLoadWarningsStatement()
		}

	case 107:
		p.EnterOuterAlt(localctx, 107)
		{
			p.SetState(1163)
			p.CancelLoadStatement()
		}

	case 108:
		p.EnterOuterAlt(localctx, 108)
		{
			p.SetState(1164)
			p.AlterLoadStatement()
		}

	case 109:
		p.EnterOuterAlt(localctx, 109)
		{
			p.SetState(1165)
			p.ShowAuthorStatement()
		}

	case 110:
		p.EnterOuterAlt(localctx, 110)
		{
			p.SetState(1166)
			p.ShowBackendsStatement()
		}

	case 111:
		p.EnterOuterAlt(localctx, 111)
		{
			p.SetState(1167)
			p.ShowBrokerStatement()
		}

	case 112:
		p.EnterOuterAlt(localctx, 112)
		{
			p.SetState(1168)
			p.ShowCharsetStatement()
		}

	case 113:
		p.EnterOuterAlt(localctx, 113)
		{
			p.SetState(1169)
			p.ShowCollationStatement()
		}

	case 114:
		p.EnterOuterAlt(localctx, 114)
		{
			p.SetState(1170)
			p.ShowDeleteStatement()
		}

	case 115:
		p.EnterOuterAlt(localctx, 115)
		{
			p.SetState(1171)
			p.ShowDynamicPartitionStatement()
		}

	case 116:
		p.EnterOuterAlt(localctx, 116)
		{
			p.SetState(1172)
			p.ShowEventsStatement()
		}

	case 117:
		p.EnterOuterAlt(localctx, 117)
		{
			p.SetState(1173)
			p.ShowEnginesStatement()
		}

	case 118:
		p.EnterOuterAlt(localctx, 118)
		{
			p.SetState(1174)
			p.ShowFrontendsStatement()
		}

	case 119:
		p.EnterOuterAlt(localctx, 119)
		{
			p.SetState(1175)
			p.ShowPluginsStatement()
		}

	case 120:
		p.EnterOuterAlt(localctx, 120)
		{
			p.SetState(1176)
			p.ShowRepositoriesStatement()
		}

	case 121:
		p.EnterOuterAlt(localctx, 121)
		{
			p.SetState(1177)
			p.ShowOpenTableStatement()
		}

	case 122:
		p.EnterOuterAlt(localctx, 122)
		{
			p.SetState(1178)
			p.ShowPrivilegesStatement()
		}

	case 123:
		p.EnterOuterAlt(localctx, 123)
		{
			p.SetState(1179)
			p.ShowProcedureStatement()
		}

	case 124:
		p.EnterOuterAlt(localctx, 124)
		{
			p.SetState(1180)
			p.ShowProcStatement()
		}

	case 125:
		p.EnterOuterAlt(localctx, 125)
		{
			p.SetState(1181)
			p.ShowProcesslistStatement()
		}

	case 126:
		p.EnterOuterAlt(localctx, 126)
		{
			p.SetState(1182)
			p.ShowProfilelistStatement()
		}

	case 127:
		p.EnterOuterAlt(localctx, 127)
		{
			p.SetState(1183)
			p.ShowRunningQueriesStatement()
		}

	case 128:
		p.EnterOuterAlt(localctx, 128)
		{
			p.SetState(1184)
			p.ShowStatusStatement()
		}

	case 129:
		p.EnterOuterAlt(localctx, 129)
		{
			p.SetState(1185)
			p.ShowTabletStatement()
		}

	case 130:
		p.EnterOuterAlt(localctx, 130)
		{
			p.SetState(1186)
			p.ShowTransactionStatement()
		}

	case 131:
		p.EnterOuterAlt(localctx, 131)
		{
			p.SetState(1187)
			p.ShowTriggersStatement()
		}

	case 132:
		p.EnterOuterAlt(localctx, 132)
		{
			p.SetState(1188)
			p.ShowUserPropertyStatement()
		}

	case 133:
		p.EnterOuterAlt(localctx, 133)
		{
			p.SetState(1189)
			p.ShowVariablesStatement()
		}

	case 134:
		p.EnterOuterAlt(localctx, 134)
		{
			p.SetState(1190)
			p.ShowWarningStatement()
		}

	case 135:
		p.EnterOuterAlt(localctx, 135)
		{
			p.SetState(1191)
			p.HelpStatement()
		}

	case 136:
		p.EnterOuterAlt(localctx, 136)
		{
			p.SetState(1192)
			p.CreateUserStatement()
		}

	case 137:
		p.EnterOuterAlt(localctx, 137)
		{
			p.SetState(1193)
			p.DropUserStatement()
		}

	case 138:
		p.EnterOuterAlt(localctx, 138)
		{
			p.SetState(1194)
			p.AlterUserStatement()
		}

	case 139:
		p.EnterOuterAlt(localctx, 139)
		{
			p.SetState(1195)
			p.ShowUserStatement()
		}

	case 140:
		p.EnterOuterAlt(localctx, 140)
		{
			p.SetState(1196)
			p.ShowAuthenticationStatement()
		}

	case 141:
		p.EnterOuterAlt(localctx, 141)
		{
			p.SetState(1197)
			p.ExecuteAsStatement()
		}

	case 142:
		p.EnterOuterAlt(localctx, 142)
		{
			p.SetState(1198)
			p.CreateRoleStatement()
		}

	case 143:
		p.EnterOuterAlt(localctx, 143)
		{
			p.SetState(1199)
			p.AlterRoleStatement()
		}

	case 144:
		p.EnterOuterAlt(localctx, 144)
		{
			p.SetState(1200)
			p.DropRoleStatement()
		}

	case 145:
		p.EnterOuterAlt(localctx, 145)
		{
			p.SetState(1201)
			p.ShowRolesStatement()
		}

	case 146:
		p.EnterOuterAlt(localctx, 146)
		{
			p.SetState(1202)
			p.GrantRoleStatement()
		}

	case 147:
		p.EnterOuterAlt(localctx, 147)
		{
			p.SetState(1203)
			p.RevokeRoleStatement()
		}

	case 148:
		p.EnterOuterAlt(localctx, 148)
		{
			p.SetState(1204)
			p.SetRoleStatement()
		}

	case 149:
		p.EnterOuterAlt(localctx, 149)
		{
			p.SetState(1205)
			p.SetDefaultRoleStatement()
		}

	case 150:
		p.EnterOuterAlt(localctx, 150)
		{
			p.SetState(1206)
			p.GrantPrivilegeStatement()
		}

	case 151:
		p.EnterOuterAlt(localctx, 151)
		{
			p.SetState(1207)
			p.RevokePrivilegeStatement()
		}

	case 152:
		p.EnterOuterAlt(localctx, 152)
		{
			p.SetState(1208)
			p.ShowGrantsStatement()
		}

	case 153:
		p.EnterOuterAlt(localctx, 153)
		{
			p.SetState(1209)
			p.CreateSecurityIntegrationStatement()
		}

	case 154:
		p.EnterOuterAlt(localctx, 154)
		{
			p.SetState(1210)
			p.AlterSecurityIntegrationStatement()
		}

	case 155:
		p.EnterOuterAlt(localctx, 155)
		{
			p.SetState(1211)
			p.DropSecurityIntegrationStatement()
		}

	case 156:
		p.EnterOuterAlt(localctx, 156)
		{
			p.SetState(1212)
			p.ShowSecurityIntegrationStatement()
		}

	case 157:
		p.EnterOuterAlt(localctx, 157)
		{
			p.SetState(1213)
			p.ShowCreateSecurityIntegrationStatement()
		}

	case 158:
		p.EnterOuterAlt(localctx, 158)
		{
			p.SetState(1214)
			p.CreateGroupProviderStatement()
		}

	case 159:
		p.EnterOuterAlt(localctx, 159)
		{
			p.SetState(1215)
			p.DropGroupProviderStatement()
		}

	case 160:
		p.EnterOuterAlt(localctx, 160)
		{
			p.SetState(1216)
			p.ShowGroupProvidersStatement()
		}

	case 161:
		p.EnterOuterAlt(localctx, 161)
		{
			p.SetState(1217)
			p.ShowCreateGroupProviderStatement()
		}

	case 162:
		p.EnterOuterAlt(localctx, 162)
		{
			p.SetState(1218)
			p.BackupStatement()
		}

	case 163:
		p.EnterOuterAlt(localctx, 163)
		{
			p.SetState(1219)
			p.CancelBackupStatement()
		}

	case 164:
		p.EnterOuterAlt(localctx, 164)
		{
			p.SetState(1220)
			p.ShowBackupStatement()
		}

	case 165:
		p.EnterOuterAlt(localctx, 165)
		{
			p.SetState(1221)
			p.RestoreStatement()
		}

	case 166:
		p.EnterOuterAlt(localctx, 166)
		{
			p.SetState(1222)
			p.CancelRestoreStatement()
		}

	case 167:
		p.EnterOuterAlt(localctx, 167)
		{
			p.SetState(1223)
			p.ShowRestoreStatement()
		}

	case 168:
		p.EnterOuterAlt(localctx, 168)
		{
			p.SetState(1224)
			p.ShowSnapshotStatement()
		}

	case 169:
		p.EnterOuterAlt(localctx, 169)
		{
			p.SetState(1225)
			p.CreateRepositoryStatement()
		}

	case 170:
		p.EnterOuterAlt(localctx, 170)
		{
			p.SetState(1226)
			p.DropRepositoryStatement()
		}

	case 171:
		p.EnterOuterAlt(localctx, 171)
		{
			p.SetState(1227)
			p.AddSqlBlackListStatement()
		}

	case 172:
		p.EnterOuterAlt(localctx, 172)
		{
			p.SetState(1228)
			p.DelSqlBlackListStatement()
		}

	case 173:
		p.EnterOuterAlt(localctx, 173)
		{
			p.SetState(1229)
			p.ShowSqlBlackListStatement()
		}

	case 174:
		p.EnterOuterAlt(localctx, 174)
		{
			p.SetState(1230)
			p.ShowWhiteListStatement()
		}

	case 175:
		p.EnterOuterAlt(localctx, 175)
		{
			p.SetState(1231)
			p.AddBackendBlackListStatement()
		}

	case 176:
		p.EnterOuterAlt(localctx, 176)
		{
			p.SetState(1232)
			p.DelBackendBlackListStatement()
		}

	case 177:
		p.EnterOuterAlt(localctx, 177)
		{
			p.SetState(1233)
			p.ShowBackendBlackListStatement()
		}

	case 178:
		p.EnterOuterAlt(localctx, 178)
		{
			p.SetState(1234)
			p.CreateDataCacheRuleStatement()
		}

	case 179:
		p.EnterOuterAlt(localctx, 179)
		{
			p.SetState(1235)
			p.ShowDataCacheRulesStatement()
		}

	case 180:
		p.EnterOuterAlt(localctx, 180)
		{
			p.SetState(1236)
			p.DropDataCacheRuleStatement()
		}

	case 181:
		p.EnterOuterAlt(localctx, 181)
		{
			p.SetState(1237)
			p.ClearDataCacheRulesStatement()
		}

	case 182:
		p.EnterOuterAlt(localctx, 182)
		{
			p.SetState(1238)
			p.DataCacheSelectStatement()
		}

	case 183:
		p.EnterOuterAlt(localctx, 183)
		{
			p.SetState(1239)
			p.ExportStatement()
		}

	case 184:
		p.EnterOuterAlt(localctx, 184)
		{
			p.SetState(1240)
			p.CancelExportStatement()
		}

	case 185:
		p.EnterOuterAlt(localctx, 185)
		{
			p.SetState(1241)
			p.ShowExportStatement()
		}

	case 186:
		p.EnterOuterAlt(localctx, 186)
		{
			p.SetState(1242)
			p.InstallPluginStatement()
		}

	case 187:
		p.EnterOuterAlt(localctx, 187)
		{
			p.SetState(1243)
			p.UninstallPluginStatement()
		}

	case 188:
		p.EnterOuterAlt(localctx, 188)
		{
			p.SetState(1244)
			p.CreateFileStatement()
		}

	case 189:
		p.EnterOuterAlt(localctx, 189)
		{
			p.SetState(1245)
			p.DropFileStatement()
		}

	case 190:
		p.EnterOuterAlt(localctx, 190)
		{
			p.SetState(1246)
			p.ShowSmallFilesStatement()
		}

	case 191:
		p.EnterOuterAlt(localctx, 191)
		{
			p.SetState(1247)
			p.SetStatement()
		}

	case 192:
		p.EnterOuterAlt(localctx, 192)
		{
			p.SetState(1248)
			p.SetUserPropertyStatement()
		}

	case 193:
		p.EnterOuterAlt(localctx, 193)
		{
			p.SetState(1249)
			p.CreateStorageVolumeStatement()
		}

	case 194:
		p.EnterOuterAlt(localctx, 194)
		{
			p.SetState(1250)
			p.AlterStorageVolumeStatement()
		}

	case 195:
		p.EnterOuterAlt(localctx, 195)
		{
			p.SetState(1251)
			p.DropStorageVolumeStatement()
		}

	case 196:
		p.EnterOuterAlt(localctx, 196)
		{
			p.SetState(1252)
			p.ShowStorageVolumesStatement()
		}

	case 197:
		p.EnterOuterAlt(localctx, 197)
		{
			p.SetState(1253)
			p.DescStorageVolumeStatement()
		}

	case 198:
		p.EnterOuterAlt(localctx, 198)
		{
			p.SetState(1254)
			p.SetDefaultStorageVolumeStatement()
		}

	case 199:
		p.EnterOuterAlt(localctx, 199)
		{
			p.SetState(1255)
			p.CreatePipeStatement()
		}

	case 200:
		p.EnterOuterAlt(localctx, 200)
		{
			p.SetState(1256)
			p.DropPipeStatement()
		}

	case 201:
		p.EnterOuterAlt(localctx, 201)
		{
			p.SetState(1257)
			p.AlterPipeStatement()
		}

	case 202:
		p.EnterOuterAlt(localctx, 202)
		{
			p.SetState(1258)
			p.ShowPipeStatement()
		}

	case 203:
		p.EnterOuterAlt(localctx, 203)
		{
			p.SetState(1259)
			p.DescPipeStatement()
		}

	case 204:
		p.EnterOuterAlt(localctx, 204)
		{
			p.SetState(1260)
			p.CancelCompactionStatement()
		}

	case 205:
		p.EnterOuterAlt(localctx, 205)
		{
			p.SetState(1261)
			p.UpdateFailPointStatusStatement()
		}

	case 206:
		p.EnterOuterAlt(localctx, 206)
		{
			p.SetState(1262)
			p.ShowFailPointStatement()
		}

	case 207:
		p.EnterOuterAlt(localctx, 207)
		{
			p.SetState(1263)
			p.PrepareStatement()
		}

	case 208:
		p.EnterOuterAlt(localctx, 208)
		{
			p.SetState(1264)
			p.ExecuteStatement()
		}

	case 209:
		p.EnterOuterAlt(localctx, 209)
		{
			p.SetState(1265)
			p.DeallocateStatement()
		}

	case 210:
		p.EnterOuterAlt(localctx, 210)
		{
			p.SetState(1266)
			p.CreateDictionaryStatement()
		}

	case 211:
		p.EnterOuterAlt(localctx, 211)
		{
			p.SetState(1267)
			p.DropDictionaryStatement()
		}

	case 212:
		p.EnterOuterAlt(localctx, 212)
		{
			p.SetState(1268)
			p.RefreshDictionaryStatement()
		}

	case 213:
		p.EnterOuterAlt(localctx, 213)
		{
			p.SetState(1269)
			p.ShowDictionaryStatement()
		}

	case 214:
		p.EnterOuterAlt(localctx, 214)
		{
			p.SetState(1270)
			p.CancelRefreshDictionaryStatement()
		}

	case 215:
		p.EnterOuterAlt(localctx, 215)
		{
			p.SetState(1271)
			p.AlterPlanAdvisorAddStatement()
		}

	case 216:
		p.EnterOuterAlt(localctx, 216)
		{
			p.SetState(1272)
			p.TruncatePlanAdvisorStatement()
		}

	case 217:
		p.EnterOuterAlt(localctx, 217)
		{
			p.SetState(1273)
			p.AlterPlanAdvisorDropStatement()
		}

	case 218:
		p.EnterOuterAlt(localctx, 218)
		{
			p.SetState(1274)
			p.ShowPlanAdvisorStatement()
		}

	case 219:
		p.EnterOuterAlt(localctx, 219)
		{
			p.SetState(1275)
			p.CreateWarehouseStatement()
		}

	case 220:
		p.EnterOuterAlt(localctx, 220)
		{
			p.SetState(1276)
			p.DropWarehouseStatement()
		}

	case 221:
		p.EnterOuterAlt(localctx, 221)
		{
			p.SetState(1277)
			p.SuspendWarehouseStatement()
		}

	case 222:
		p.EnterOuterAlt(localctx, 222)
		{
			p.SetState(1278)
			p.ResumeWarehouseStatement()
		}

	case 223:
		p.EnterOuterAlt(localctx, 223)
		{
			p.SetState(1279)
			p.SetWarehouseStatement()
		}

	case 224:
		p.EnterOuterAlt(localctx, 224)
		{
			p.SetState(1280)
			p.ShowWarehousesStatement()
		}

	case 225:
		p.EnterOuterAlt(localctx, 225)
		{
			p.SetState(1281)
			p.ShowClustersStatement()
		}

	case 226:
		p.EnterOuterAlt(localctx, 226)
		{
			p.SetState(1282)
			p.ShowNodesStatement()
		}

	case 227:
		p.EnterOuterAlt(localctx, 227)
		{
			p.SetState(1283)
			p.AlterWarehouseStatement()
		}

	case 228:
		p.EnterOuterAlt(localctx, 228)
		{
			p.SetState(1284)
			p.CreateCNGroupStatement()
		}

	case 229:
		p.EnterOuterAlt(localctx, 229)
		{
			p.SetState(1285)
			p.DropCNGroupStatement()
		}

	case 230:
		p.EnterOuterAlt(localctx, 230)
		{
			p.SetState(1286)
			p.EnableCNGroupStatement()
		}

	case 231:
		p.EnterOuterAlt(localctx, 231)
		{
			p.SetState(1287)
			p.DisableCNGroupStatement()
		}

	case 232:
		p.EnterOuterAlt(localctx, 232)
		{
			p.SetState(1288)
			p.AlterCNGroupStatement()
		}

	case 233:
		p.EnterOuterAlt(localctx, 233)
		{
			p.SetState(1289)
			p.BeginStatement()
		}

	case 234:
		p.EnterOuterAlt(localctx, 234)
		{
			p.SetState(1290)
			p.CommitStatement()
		}

	case 235:
		p.EnterOuterAlt(localctx, 235)
		{
			p.SetState(1291)
			p.RollbackStatement()
		}

	case 236:
		p.EnterOuterAlt(localctx, 236)
		{
			p.SetState(1292)
			p.TranslateStatement()
		}

	case 237:
		p.EnterOuterAlt(localctx, 237)
		{
			p.SetState(1293)
			p.CreateBaselinePlanStatement()
		}

	case 238:
		p.EnterOuterAlt(localctx, 238)
		{
			p.SetState(1294)
			p.DropBaselinePlanStatement()
		}

	case 239:
		p.EnterOuterAlt(localctx, 239)
		{
			p.SetState(1295)
			p.ShowBaselinePlanStatement()
		}

	case 240:
		p.EnterOuterAlt(localctx, 240)
		{
			p.SetState(1296)
			p.UnsupportedStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUseDatabaseStatementContext is an interface to support dynamic dispatch.
type IUseDatabaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsUseDatabaseStatementContext differentiates from other interfaces.
	IsUseDatabaseStatementContext()
}

type UseDatabaseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseDatabaseStatementContext() *UseDatabaseStatementContext {
	var p = new(UseDatabaseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_useDatabaseStatement
	return p
}

func InitEmptyUseDatabaseStatementContext(p *UseDatabaseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_useDatabaseStatement
}

func (*UseDatabaseStatementContext) IsUseDatabaseStatementContext() {}

func NewUseDatabaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseDatabaseStatementContext {
	var p = new(UseDatabaseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_useDatabaseStatement

	return p
}

func (s *UseDatabaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UseDatabaseStatementContext) USE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSE, 0)
}

func (s *UseDatabaseStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *UseDatabaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseDatabaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseDatabaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterUseDatabaseStatement(s)
	}
}

func (s *UseDatabaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitUseDatabaseStatement(s)
	}
}

func (s *UseDatabaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitUseDatabaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) UseDatabaseStatement() (localctx IUseDatabaseStatementContext) {
	localctx = NewUseDatabaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, DorisSQLParserParserRULE_useDatabaseStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1299)
		p.Match(DorisSQLParserParserUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1300)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUseCatalogStatementContext is an interface to support dynamic dispatch.
type IUseCatalogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USE() antlr.TerminalNode
	String_() IStringContext

	// IsUseCatalogStatementContext differentiates from other interfaces.
	IsUseCatalogStatementContext()
}

type UseCatalogStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseCatalogStatementContext() *UseCatalogStatementContext {
	var p = new(UseCatalogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_useCatalogStatement
	return p
}

func InitEmptyUseCatalogStatementContext(p *UseCatalogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_useCatalogStatement
}

func (*UseCatalogStatementContext) IsUseCatalogStatementContext() {}

func NewUseCatalogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseCatalogStatementContext {
	var p = new(UseCatalogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_useCatalogStatement

	return p
}

func (s *UseCatalogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UseCatalogStatementContext) USE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSE, 0)
}

func (s *UseCatalogStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *UseCatalogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseCatalogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseCatalogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterUseCatalogStatement(s)
	}
}

func (s *UseCatalogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitUseCatalogStatement(s)
	}
}

func (s *UseCatalogStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitUseCatalogStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) UseCatalogStatement() (localctx IUseCatalogStatementContext) {
	localctx = NewUseCatalogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, DorisSQLParserParserRULE_useCatalogStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1302)
		p.Match(DorisSQLParserParserUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1303)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetCatalogStatementContext is an interface to support dynamic dispatch.
type ISetCatalogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsSetCatalogStatementContext differentiates from other interfaces.
	IsSetCatalogStatementContext()
}

type SetCatalogStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetCatalogStatementContext() *SetCatalogStatementContext {
	var p = new(SetCatalogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_setCatalogStatement
	return p
}

func InitEmptySetCatalogStatementContext(p *SetCatalogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_setCatalogStatement
}

func (*SetCatalogStatementContext) IsSetCatalogStatementContext() {}

func NewSetCatalogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetCatalogStatementContext {
	var p = new(SetCatalogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_setCatalogStatement

	return p
}

func (s *SetCatalogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetCatalogStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *SetCatalogStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCATALOG, 0)
}

func (s *SetCatalogStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *SetCatalogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetCatalogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetCatalogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSetCatalogStatement(s)
	}
}

func (s *SetCatalogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSetCatalogStatement(s)
	}
}

func (s *SetCatalogStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSetCatalogStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SetCatalogStatement() (localctx ISetCatalogStatementContext) {
	localctx = NewSetCatalogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, DorisSQLParserParserRULE_setCatalogStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1305)
		p.Match(DorisSQLParserParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1306)
		p.Match(DorisSQLParserParserCATALOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1307)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDatabasesStatementContext is an interface to support dynamic dispatch.
type IShowDatabasesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	DATABASES() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext
	SCHEMAS() antlr.TerminalNode

	// IsShowDatabasesStatementContext differentiates from other interfaces.
	IsShowDatabasesStatementContext()
}

type ShowDatabasesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowDatabasesStatementContext() *ShowDatabasesStatementContext {
	var p = new(ShowDatabasesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showDatabasesStatement
	return p
}

func InitEmptyShowDatabasesStatementContext(p *ShowDatabasesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showDatabasesStatement
}

func (*ShowDatabasesStatementContext) IsShowDatabasesStatementContext() {}

func NewShowDatabasesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDatabasesStatementContext {
	var p = new(ShowDatabasesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showDatabasesStatement

	return p
}

func (s *ShowDatabasesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDatabasesStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *ShowDatabasesStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowDatabasesStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *ShowDatabasesStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowDatabasesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowDatabasesStatementContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATABASES, 0)
}

func (s *ShowDatabasesStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowDatabasesStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *ShowDatabasesStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowDatabasesStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *ShowDatabasesStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowDatabasesStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowDatabasesStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowDatabasesStatementContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSCHEMAS, 0)
}

func (s *ShowDatabasesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDatabasesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDatabasesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowDatabasesStatement(s)
	}
}

func (s *ShowDatabasesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowDatabasesStatement(s)
	}
}

func (s *ShowDatabasesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowDatabasesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowDatabasesStatement() (localctx IShowDatabasesStatementContext) {
	localctx = NewShowDatabasesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, DorisSQLParserParserRULE_showDatabasesStatement)
	var _la int

	p.SetState(1329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1309)
			p.Match(DorisSQLParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1310)
			p.Match(DorisSQLParserParserDATABASES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1313)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN {
			{
				p.SetState(1311)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1312)

				var _x = p.QualifiedName()

				localctx.(*ShowDatabasesStatementContext).catalog = _x
			}

		}
		p.SetState(1319)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserParserLIKE:
			{
				p.SetState(1315)
				p.Match(DorisSQLParserParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1316)

				var _x = p.String_()

				localctx.(*ShowDatabasesStatementContext).pattern = _x
			}

		case DorisSQLParserParserWHERE:
			{
				p.SetState(1317)
				p.Match(DorisSQLParserParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1318)
				p.expression(0)
			}

		case DorisSQLParserParserEOF, DorisSQLParserParserSEMICOLON:

		default:
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1321)
			p.Match(DorisSQLParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1322)
			p.Match(DorisSQLParserParserSCHEMAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1327)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserParserLIKE:
			{
				p.SetState(1323)
				p.Match(DorisSQLParserParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1324)

				var _x = p.String_()

				localctx.(*ShowDatabasesStatementContext).pattern = _x
			}

		case DorisSQLParserParserWHERE:
			{
				p.SetState(1325)
				p.Match(DorisSQLParserParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1326)
				p.expression(0)
			}

		case DorisSQLParserParserEOF, DorisSQLParserParserSEMICOLON:

		default:
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterDbQuotaStatementContext is an interface to support dynamic dispatch.
type IAlterDbQuotaStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	SET() antlr.TerminalNode
	DATA() antlr.TerminalNode
	QUOTA() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsAlterDbQuotaStatementContext differentiates from other interfaces.
	IsAlterDbQuotaStatementContext()
}

type AlterDbQuotaStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterDbQuotaStatementContext() *AlterDbQuotaStatementContext {
	var p = new(AlterDbQuotaStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterDbQuotaStatement
	return p
}

func InitEmptyAlterDbQuotaStatementContext(p *AlterDbQuotaStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterDbQuotaStatement
}

func (*AlterDbQuotaStatementContext) IsAlterDbQuotaStatementContext() {}

func NewAlterDbQuotaStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDbQuotaStatementContext {
	var p = new(AlterDbQuotaStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_alterDbQuotaStatement

	return p
}

func (s *AlterDbQuotaStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDbQuotaStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *AlterDbQuotaStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATABASE, 0)
}

func (s *AlterDbQuotaStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterDbQuotaStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterDbQuotaStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *AlterDbQuotaStatementContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATA, 0)
}

func (s *AlterDbQuotaStatementContext) QUOTA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserQUOTA, 0)
}

func (s *AlterDbQuotaStatementContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPLICA, 0)
}

func (s *AlterDbQuotaStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, 0)
}

func (s *AlterDbQuotaStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDbQuotaStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterDbQuotaStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAlterDbQuotaStatement(s)
	}
}

func (s *AlterDbQuotaStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAlterDbQuotaStatement(s)
	}
}

func (s *AlterDbQuotaStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAlterDbQuotaStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AlterDbQuotaStatement() (localctx IAlterDbQuotaStatementContext) {
	localctx = NewAlterDbQuotaStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, DorisSQLParserParserRULE_alterDbQuotaStatement)
	p.SetState(1347)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1331)
			p.Match(DorisSQLParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1332)
			p.Match(DorisSQLParserParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1333)
			p.Identifier()
		}
		{
			p.SetState(1334)
			p.Match(DorisSQLParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1335)
			p.Match(DorisSQLParserParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1336)
			p.Match(DorisSQLParserParserQUOTA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1337)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1339)
			p.Match(DorisSQLParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1340)
			p.Match(DorisSQLParserParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1341)
			p.Identifier()
		}
		{
			p.SetState(1342)
			p.Match(DorisSQLParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1343)
			p.Match(DorisSQLParserParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1344)
			p.Match(DorisSQLParserParserQUOTA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1345)
			p.Match(DorisSQLParserParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDbStatementContext is an interface to support dynamic dispatch.
type ICreateDbStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IIdentifierContext

	// GetDatabase returns the database rule contexts.
	GetDatabase() IQualifiedNameContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IIdentifierContext)

	// SetDatabase sets the database rule contexts.
	SetDatabase(IQualifiedNameContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	CharsetDesc() ICharsetDescContext
	CollateDesc() ICollateDescContext
	Properties() IPropertiesContext
	Identifier() IIdentifierContext

	// IsCreateDbStatementContext differentiates from other interfaces.
	IsCreateDbStatementContext()
}

type CreateDbStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	catalog  IIdentifierContext
	database IQualifiedNameContext
}

func NewEmptyCreateDbStatementContext() *CreateDbStatementContext {
	var p = new(CreateDbStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createDbStatement
	return p
}

func InitEmptyCreateDbStatementContext(p *CreateDbStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createDbStatement
}

func (*CreateDbStatementContext) IsCreateDbStatementContext() {}

func NewCreateDbStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDbStatementContext {
	var p = new(CreateDbStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createDbStatement

	return p
}

func (s *CreateDbStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDbStatementContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *CreateDbStatementContext) GetDatabase() IQualifiedNameContext { return s.database }

func (s *CreateDbStatementContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *CreateDbStatementContext) SetDatabase(v IQualifiedNameContext) { s.database = v }

func (s *CreateDbStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateDbStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATABASE, 0)
}

func (s *CreateDbStatementContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSCHEMA, 0)
}

func (s *CreateDbStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateDbStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *CreateDbStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *CreateDbStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *CreateDbStatementContext) CharsetDesc() ICharsetDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetDescContext)
}

func (s *CreateDbStatementContext) CollateDesc() ICollateDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollateDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollateDescContext)
}

func (s *CreateDbStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateDbStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateDbStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDbStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDbStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateDbStatement(s)
	}
}

func (s *CreateDbStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateDbStatement(s)
	}
}

func (s *CreateDbStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateDbStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateDbStatement() (localctx ICreateDbStatementContext) {
	localctx = NewCreateDbStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, DorisSQLParserParserRULE_createDbStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1349)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1350)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserDATABASE || _la == DorisSQLParserParserSCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1354)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(1351)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1352)
			p.Match(DorisSQLParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1353)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1359)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1356)

			var _x = p.Identifier()

			localctx.(*CreateDbStatementContext).catalog = _x
		}
		{
			p.SetState(1357)
			p.Match(DorisSQLParserParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1361)

		var _x = p.QualifiedName()

		localctx.(*CreateDbStatementContext).database = _x
	}
	p.SetState(1363)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1362)
			p.CharsetDesc()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1366)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserCOLLATE || _la == DorisSQLParserParserDEFAULT {
		{
			p.SetState(1365)
			p.CollateDesc()
		}

	}
	p.SetState(1369)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(1368)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropDbStatementContext is an interface to support dynamic dispatch.
type IDropDbStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IIdentifierContext

	// GetDatabase returns the database rule contexts.
	GetDatabase() IQualifiedNameContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IIdentifierContext)

	// SetDatabase sets the database rule contexts.
	SetDatabase(IQualifiedNameContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	FORCE() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDropDbStatementContext differentiates from other interfaces.
	IsDropDbStatementContext()
}

type DropDbStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	catalog  IIdentifierContext
	database IQualifiedNameContext
}

func NewEmptyDropDbStatementContext() *DropDbStatementContext {
	var p = new(DropDbStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropDbStatement
	return p
}

func InitEmptyDropDbStatementContext(p *DropDbStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropDbStatement
}

func (*DropDbStatementContext) IsDropDbStatementContext() {}

func NewDropDbStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropDbStatementContext {
	var p = new(DropDbStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropDbStatement

	return p
}

func (s *DropDbStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropDbStatementContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *DropDbStatementContext) GetDatabase() IQualifiedNameContext { return s.database }

func (s *DropDbStatementContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *DropDbStatementContext) SetDatabase(v IQualifiedNameContext) { s.database = v }

func (s *DropDbStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropDbStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATABASE, 0)
}

func (s *DropDbStatementContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSCHEMA, 0)
}

func (s *DropDbStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropDbStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *DropDbStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *DropDbStatementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFORCE, 0)
}

func (s *DropDbStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropDbStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDbStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropDbStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropDbStatement(s)
	}
}

func (s *DropDbStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropDbStatement(s)
	}
}

func (s *DropDbStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropDbStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropDbStatement() (localctx IDropDbStatementContext) {
	localctx = NewDropDbStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, DorisSQLParserParserRULE_dropDbStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1371)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1372)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserDATABASE || _la == DorisSQLParserParserSCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1375)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(1373)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1374)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1380)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1377)

			var _x = p.Identifier()

			localctx.(*DropDbStatementContext).catalog = _x
		}
		{
			p.SetState(1378)
			p.Match(DorisSQLParserParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1382)

		var _x = p.QualifiedName()

		localctx.(*DropDbStatementContext).database = _x
	}
	p.SetState(1384)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFORCE {
		{
			p.SetState(1383)
			p.Match(DorisSQLParserParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCreateDbStatementContext is an interface to support dynamic dispatch.
type IShowCreateDbStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	Identifier() IIdentifierContext
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode

	// IsShowCreateDbStatementContext differentiates from other interfaces.
	IsShowCreateDbStatementContext()
}

type ShowCreateDbStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowCreateDbStatementContext() *ShowCreateDbStatementContext {
	var p = new(ShowCreateDbStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showCreateDbStatement
	return p
}

func InitEmptyShowCreateDbStatementContext(p *ShowCreateDbStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showCreateDbStatement
}

func (*ShowCreateDbStatementContext) IsShowCreateDbStatementContext() {}

func NewShowCreateDbStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCreateDbStatementContext {
	var p = new(ShowCreateDbStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showCreateDbStatement

	return p
}

func (s *ShowCreateDbStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCreateDbStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowCreateDbStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *ShowCreateDbStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateDbStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATABASE, 0)
}

func (s *ShowCreateDbStatementContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSCHEMA, 0)
}

func (s *ShowCreateDbStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateDbStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCreateDbStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowCreateDbStatement(s)
	}
}

func (s *ShowCreateDbStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowCreateDbStatement(s)
	}
}

func (s *ShowCreateDbStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowCreateDbStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowCreateDbStatement() (localctx IShowCreateDbStatementContext) {
	localctx = NewShowCreateDbStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, DorisSQLParserParserRULE_showCreateDbStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1386)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1387)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1388)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserDATABASE || _la == DorisSQLParserParserSCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1389)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterDatabaseRenameStatementContext is an interface to support dynamic dispatch.
type IAlterDatabaseRenameStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	RENAME() antlr.TerminalNode

	// IsAlterDatabaseRenameStatementContext differentiates from other interfaces.
	IsAlterDatabaseRenameStatementContext()
}

type AlterDatabaseRenameStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterDatabaseRenameStatementContext() *AlterDatabaseRenameStatementContext {
	var p = new(AlterDatabaseRenameStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterDatabaseRenameStatement
	return p
}

func InitEmptyAlterDatabaseRenameStatementContext(p *AlterDatabaseRenameStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterDatabaseRenameStatement
}

func (*AlterDatabaseRenameStatementContext) IsAlterDatabaseRenameStatementContext() {}

func NewAlterDatabaseRenameStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDatabaseRenameStatementContext {
	var p = new(AlterDatabaseRenameStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_alterDatabaseRenameStatement

	return p
}

func (s *AlterDatabaseRenameStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDatabaseRenameStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *AlterDatabaseRenameStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATABASE, 0)
}

func (s *AlterDatabaseRenameStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterDatabaseRenameStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterDatabaseRenameStatementContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRENAME, 0)
}

func (s *AlterDatabaseRenameStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseRenameStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterDatabaseRenameStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAlterDatabaseRenameStatement(s)
	}
}

func (s *AlterDatabaseRenameStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAlterDatabaseRenameStatement(s)
	}
}

func (s *AlterDatabaseRenameStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAlterDatabaseRenameStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AlterDatabaseRenameStatement() (localctx IAlterDatabaseRenameStatementContext) {
	localctx = NewAlterDatabaseRenameStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, DorisSQLParserParserRULE_alterDatabaseRenameStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1391)
		p.Match(DorisSQLParserParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1392)
		p.Match(DorisSQLParserParserDATABASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1393)
		p.Identifier()
	}
	{
		p.SetState(1394)
		p.Match(DorisSQLParserParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1395)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecoverDbStmtContext is an interface to support dynamic dispatch.
type IRecoverDbStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RECOVER() antlr.TerminalNode
	Identifier() IIdentifierContext
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode

	// IsRecoverDbStmtContext differentiates from other interfaces.
	IsRecoverDbStmtContext()
}

type RecoverDbStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecoverDbStmtContext() *RecoverDbStmtContext {
	var p = new(RecoverDbStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_recoverDbStmt
	return p
}

func InitEmptyRecoverDbStmtContext(p *RecoverDbStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_recoverDbStmt
}

func (*RecoverDbStmtContext) IsRecoverDbStmtContext() {}

func NewRecoverDbStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecoverDbStmtContext {
	var p = new(RecoverDbStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_recoverDbStmt

	return p
}

func (s *RecoverDbStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *RecoverDbStmtContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRECOVER, 0)
}

func (s *RecoverDbStmtContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RecoverDbStmtContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATABASE, 0)
}

func (s *RecoverDbStmtContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSCHEMA, 0)
}

func (s *RecoverDbStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecoverDbStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecoverDbStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRecoverDbStmt(s)
	}
}

func (s *RecoverDbStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRecoverDbStmt(s)
	}
}

func (s *RecoverDbStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRecoverDbStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) RecoverDbStmt() (localctx IRecoverDbStmtContext) {
	localctx = NewRecoverDbStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, DorisSQLParserParserRULE_recoverDbStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1397)
		p.Match(DorisSQLParserParserRECOVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1398)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserDATABASE || _la == DorisSQLParserParserSCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1399)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDataStmtContext is an interface to support dynamic dispatch.
type IShowDataStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	DATA() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowDataStmtContext differentiates from other interfaces.
	IsShowDataStmtContext()
}

type ShowDataStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowDataStmtContext() *ShowDataStmtContext {
	var p = new(ShowDataStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showDataStmt
	return p
}

func InitEmptyShowDataStmtContext(p *ShowDataStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showDataStmt
}

func (*ShowDataStmtContext) IsShowDataStmtContext() {}

func NewShowDataStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDataStmtContext {
	var p = new(ShowDataStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showDataStmt

	return p
}

func (s *ShowDataStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDataStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowDataStmtContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATA, 0)
}

func (s *ShowDataStmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowDataStmtContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowDataStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDataStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDataStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowDataStmt(s)
	}
}

func (s *ShowDataStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowDataStmt(s)
	}
}

func (s *ShowDataStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowDataStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowDataStmt() (localctx IShowDataStmtContext) {
	localctx = NewShowDataStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, DorisSQLParserParserRULE_showDataStmt)
	p.SetState(1407)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1401)
			p.Match(DorisSQLParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1402)
			p.Match(DorisSQLParserParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1403)
			p.Match(DorisSQLParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1404)
			p.Match(DorisSQLParserParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1405)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1406)
			p.QualifiedName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDataDistributionStmtContext is an interface to support dynamic dispatch.
type IShowDataDistributionStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DISTRIBUTION() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext

	// IsShowDataDistributionStmtContext differentiates from other interfaces.
	IsShowDataDistributionStmtContext()
}

type ShowDataDistributionStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowDataDistributionStmtContext() *ShowDataDistributionStmtContext {
	var p = new(ShowDataDistributionStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showDataDistributionStmt
	return p
}

func InitEmptyShowDataDistributionStmtContext(p *ShowDataDistributionStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showDataDistributionStmt
}

func (*ShowDataDistributionStmtContext) IsShowDataDistributionStmtContext() {}

func NewShowDataDistributionStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDataDistributionStmtContext {
	var p = new(ShowDataDistributionStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showDataDistributionStmt

	return p
}

func (s *ShowDataDistributionStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDataDistributionStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowDataDistributionStmtContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATA, 0)
}

func (s *ShowDataDistributionStmtContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDISTRIBUTION, 0)
}

func (s *ShowDataDistributionStmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowDataDistributionStmtContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowDataDistributionStmtContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *ShowDataDistributionStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDataDistributionStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDataDistributionStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowDataDistributionStmt(s)
	}
}

func (s *ShowDataDistributionStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowDataDistributionStmt(s)
	}
}

func (s *ShowDataDistributionStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowDataDistributionStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowDataDistributionStmt() (localctx IShowDataDistributionStmtContext) {
	localctx = NewShowDataDistributionStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, DorisSQLParserParserRULE_showDataDistributionStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1409)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1410)
		p.Match(DorisSQLParserParserDATA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1411)
		p.Match(DorisSQLParserParserDISTRIBUTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1412)
		p.Match(DorisSQLParserParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1413)
		p.QualifiedName()
	}
	p.SetState(1415)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPARTITION || _la == DorisSQLParserParserPARTITIONS || _la == DorisSQLParserParserTEMPORARY {
		{
			p.SetState(1414)
			p.PartitionNames()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableStatementContext is an interface to support dynamic dispatch.
type ICreateTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AllColumnDesc() []IColumnDescContext
	ColumnDesc(i int) IColumnDescContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AllIndexDesc() []IIndexDescContext
	IndexDesc(i int) IIndexDescContext
	EngineDesc() IEngineDescContext
	CharsetDesc() ICharsetDescContext
	KeyDesc() IKeyDescContext
	Comment() ICommentContext
	PartitionDesc() IPartitionDescContext
	DistributionDesc() IDistributionDescContext
	OrderByDesc() IOrderByDescContext
	RollupDesc() IRollupDescContext
	Properties() IPropertiesContext
	ExtProperties() IExtPropertiesContext
	TEMPORARY() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode

	// IsCreateTableStatementContext differentiates from other interfaces.
	IsCreateTableStatementContext()
}

type CreateTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableStatementContext() *CreateTableStatementContext {
	var p = new(CreateTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createTableStatement
	return p
}

func InitEmptyCreateTableStatementContext(p *CreateTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createTableStatement
}

func (*CreateTableStatementContext) IsCreateTableStatementContext() {}

func NewCreateTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableStatementContext {
	var p = new(CreateTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createTableStatement

	return p
}

func (s *CreateTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *CreateTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateTableStatementContext) AllColumnDesc() []IColumnDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnDescContext); ok {
			len++
		}
	}

	tst := make([]IColumnDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnDescContext); ok {
			tst[i] = t.(IColumnDescContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableStatementContext) ColumnDesc(i int) IColumnDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDescContext)
}

func (s *CreateTableStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *CreateTableStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *CreateTableStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *CreateTableStatementContext) AllIndexDesc() []IIndexDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexDescContext); ok {
			len++
		}
	}

	tst := make([]IIndexDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexDescContext); ok {
			tst[i] = t.(IIndexDescContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableStatementContext) IndexDesc(i int) IIndexDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexDescContext)
}

func (s *CreateTableStatementContext) EngineDesc() IEngineDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineDescContext)
}

func (s *CreateTableStatementContext) CharsetDesc() ICharsetDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetDescContext)
}

func (s *CreateTableStatementContext) KeyDesc() IKeyDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyDescContext)
}

func (s *CreateTableStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateTableStatementContext) PartitionDesc() IPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDescContext)
}

func (s *CreateTableStatementContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *CreateTableStatementContext) OrderByDesc() IOrderByDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByDescContext)
}

func (s *CreateTableStatementContext) RollupDesc() IRollupDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupDescContext)
}

func (s *CreateTableStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateTableStatementContext) ExtProperties() IExtPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtPropertiesContext)
}

func (s *CreateTableStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTEMPORARY, 0)
}

func (s *CreateTableStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXTERNAL, 0)
}

func (s *CreateTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateTableStatement(s)
	}
}

func (s *CreateTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateTableStatement(s)
	}
}

func (s *CreateTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateTableStatement() (localctx ICreateTableStatementContext) {
	localctx = NewCreateTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, DorisSQLParserParserRULE_createTableStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1417)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserEXTERNAL || _la == DorisSQLParserParserTEMPORARY {
		{
			p.SetState(1418)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserEXTERNAL || _la == DorisSQLParserParserTEMPORARY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1421)
		p.Match(DorisSQLParserParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1425)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(1422)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1423)
			p.Match(DorisSQLParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1424)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1427)
		p.QualifiedName()
	}
	{
		p.SetState(1428)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1429)
		p.ColumnDesc()
	}
	p.SetState(1434)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1430)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1431)
				p.ColumnDesc()
			}

		}
		p.SetState(1436)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1441)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(1437)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1438)
			p.IndexDesc()
		}

		p.SetState(1443)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1444)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1446)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserENGINE {
		{
			p.SetState(1445)
			p.EngineDesc()
		}

	}
	p.SetState(1449)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&9007199254740999) != 0 {
		{
			p.SetState(1448)
			p.CharsetDesc()
		}

	}
	p.SetState(1452)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserAGGREGATE || _la == DorisSQLParserParserDUPLICATE || _la == DorisSQLParserParserPRIMARY || _la == DorisSQLParserParserUNIQUE {
		{
			p.SetState(1451)
			p.KeyDesc()
		}

	}
	p.SetState(1455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserCOMMENT {
		{
			p.SetState(1454)
			p.Comment()
		}

	}
	p.SetState(1458)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPARTITION {
		{
			p.SetState(1457)
			p.PartitionDesc()
		}

	}
	p.SetState(1461)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserDISTRIBUTED {
		{
			p.SetState(1460)
			p.DistributionDesc()
		}

	}
	p.SetState(1464)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserORDER {
		{
			p.SetState(1463)
			p.OrderByDesc()
		}

	}
	p.SetState(1467)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserROLLUP {
		{
			p.SetState(1466)
			p.RollupDesc()
		}

	}
	p.SetState(1470)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(1469)
			p.Properties()
		}

	}
	p.SetState(1473)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserBROKER {
		{
			p.SetState(1472)
			p.ExtProperties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDescContext is an interface to support dynamic dispatch.
type IColumnDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Type_() ITypeContext
	CharsetName() ICharsetNameContext
	KEY() antlr.TerminalNode
	AggDesc() IAggDescContext
	ColumnNullable() IColumnNullableContext
	DefaultDesc() IDefaultDescContext
	AUTO_INCREMENT() antlr.TerminalNode
	GeneratedColumnDesc() IGeneratedColumnDescContext
	Comment() ICommentContext

	// IsColumnDescContext differentiates from other interfaces.
	IsColumnDescContext()
}

type ColumnDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDescContext() *ColumnDescContext {
	var p = new(ColumnDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_columnDesc
	return p
}

func InitEmptyColumnDescContext(p *ColumnDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_columnDesc
}

func (*ColumnDescContext) IsColumnDescContext() {}

func NewColumnDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDescContext {
	var p = new(ColumnDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_columnDesc

	return p
}

func (s *ColumnDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnDescContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ColumnDescContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *ColumnDescContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserKEY, 0)
}

func (s *ColumnDescContext) AggDesc() IAggDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggDescContext)
}

func (s *ColumnDescContext) ColumnNullable() IColumnNullableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNullableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNullableContext)
}

func (s *ColumnDescContext) DefaultDesc() IDefaultDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultDescContext)
}

func (s *ColumnDescContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAUTO_INCREMENT, 0)
}

func (s *ColumnDescContext) GeneratedColumnDesc() IGeneratedColumnDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneratedColumnDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneratedColumnDescContext)
}

func (s *ColumnDescContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *ColumnDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterColumnDesc(s)
	}
}

func (s *ColumnDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitColumnDesc(s)
	}
}

func (s *ColumnDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitColumnDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ColumnDesc() (localctx IColumnDescContext) {
	localctx = NewColumnDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, DorisSQLParserParserRULE_columnDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1475)
		p.Identifier()
	}
	p.SetState(1477)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1476)
			p.Type_()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1480)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1479)
			p.CharsetName()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1483)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserKEY {
		{
			p.SetState(1482)
			p.Match(DorisSQLParserParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1486)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1485)
			p.AggDesc()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1489)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserNOT || _la == DorisSQLParserParserNULL {
		{
			p.SetState(1488)
			p.ColumnNullable()
		}

	}
	p.SetState(1494)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserDEFAULT:
		{
			p.SetState(1491)
			p.DefaultDesc()
		}

	case DorisSQLParserParserAUTO_INCREMENT:
		{
			p.SetState(1492)
			p.Match(DorisSQLParserParserAUTO_INCREMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserAS:
		{
			p.SetState(1493)
			p.GeneratedColumnDesc()
		}

	case DorisSQLParserParserEOF, DorisSQLParserParserT__2, DorisSQLParserParserT__3, DorisSQLParserParserAFTER, DorisSQLParserParserCOMMENT, DorisSQLParserParserFIRST, DorisSQLParserParserFROM, DorisSQLParserParserIN, DorisSQLParserParserPROPERTIES, DorisSQLParserParserTO, DorisSQLParserParserSEMICOLON:

	default:
	}
	p.SetState(1497)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserCOMMENT {
		{
			p.SetState(1496)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharsetNameContext is an interface to support dynamic dispatch.
type ICharsetNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHAR() antlr.TerminalNode
	SET() antlr.TerminalNode
	Identifier() IIdentifierContext
	CHARSET() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode

	// IsCharsetNameContext differentiates from other interfaces.
	IsCharsetNameContext()
}

type CharsetNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetNameContext() *CharsetNameContext {
	var p = new(CharsetNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_charsetName
	return p
}

func InitEmptyCharsetNameContext(p *CharsetNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_charsetName
}

func (*CharsetNameContext) IsCharsetNameContext() {}

func NewCharsetNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetNameContext {
	var p = new(CharsetNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_charsetName

	return p
}

func (s *CharsetNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetNameContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCHAR, 0)
}

func (s *CharsetNameContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *CharsetNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CharsetNameContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCHARSET, 0)
}

func (s *CharsetNameContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCHARACTER, 0)
}

func (s *CharsetNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCharsetName(s)
	}
}

func (s *CharsetNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCharsetName(s)
	}
}

func (s *CharsetNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCharsetName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CharsetName() (localctx ICharsetNameContext) {
	localctx = NewCharsetNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, DorisSQLParserParserRULE_charsetName)
	p.SetState(1507)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserCHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1499)
			p.Match(DorisSQLParserParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1500)
			p.Match(DorisSQLParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1501)
			p.Identifier()
		}

	case DorisSQLParserParserCHARSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1502)
			p.Match(DorisSQLParserParserCHARSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1503)
			p.Identifier()
		}

	case DorisSQLParserParserCHARACTER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1504)
			p.Match(DorisSQLParserParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1505)
			p.Match(DorisSQLParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1506)
			p.Identifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultDescContext is an interface to support dynamic dispatch.
type IDefaultDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	String_() IStringContext
	NULL() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsDefaultDescContext differentiates from other interfaces.
	IsDefaultDescContext()
}

type DefaultDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultDescContext() *DefaultDescContext {
	var p = new(DefaultDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_defaultDesc
	return p
}

func InitEmptyDefaultDescContext(p *DefaultDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_defaultDesc
}

func (*DefaultDescContext) IsDefaultDescContext() {}

func NewDefaultDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultDescContext {
	var p = new(DefaultDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_defaultDesc

	return p
}

func (s *DefaultDescContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultDescContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDEFAULT, 0)
}

func (s *DefaultDescContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DefaultDescContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNULL, 0)
}

func (s *DefaultDescContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCURRENT_TIMESTAMP, 0)
}

func (s *DefaultDescContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DefaultDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDefaultDesc(s)
	}
}

func (s *DefaultDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDefaultDesc(s)
	}
}

func (s *DefaultDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDefaultDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DefaultDesc() (localctx IDefaultDescContext) {
	localctx = NewDefaultDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, DorisSQLParserParserRULE_defaultDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1509)
		p.Match(DorisSQLParserParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1519)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserSINGLE_QUOTED_TEXT, DorisSQLParserParserDOUBLE_QUOTED_TEXT:
		{
			p.SetState(1510)
			p.String_()
		}

	case DorisSQLParserParserNULL:
		{
			p.SetState(1511)
			p.Match(DorisSQLParserParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserCURRENT_TIMESTAMP:
		{
			p.SetState(1512)
			p.Match(DorisSQLParserParserCURRENT_TIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserT__1:
		{
			p.SetState(1513)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1514)
			p.QualifiedName()
		}
		{
			p.SetState(1515)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1516)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1517)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeneratedColumnDescContext is an interface to support dynamic dispatch.
type IGeneratedColumnDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	Expression() IExpressionContext

	// IsGeneratedColumnDescContext differentiates from other interfaces.
	IsGeneratedColumnDescContext()
}

type GeneratedColumnDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneratedColumnDescContext() *GeneratedColumnDescContext {
	var p = new(GeneratedColumnDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_generatedColumnDesc
	return p
}

func InitEmptyGeneratedColumnDescContext(p *GeneratedColumnDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_generatedColumnDesc
}

func (*GeneratedColumnDescContext) IsGeneratedColumnDescContext() {}

func NewGeneratedColumnDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneratedColumnDescContext {
	var p = new(GeneratedColumnDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_generatedColumnDesc

	return p
}

func (s *GeneratedColumnDescContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneratedColumnDescContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *GeneratedColumnDescContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GeneratedColumnDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratedColumnDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneratedColumnDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterGeneratedColumnDesc(s)
	}
}

func (s *GeneratedColumnDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitGeneratedColumnDesc(s)
	}
}

func (s *GeneratedColumnDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitGeneratedColumnDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) GeneratedColumnDesc() (localctx IGeneratedColumnDescContext) {
	localctx = NewGeneratedColumnDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, DorisSQLParserParserRULE_generatedColumnDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1521)
		p.Match(DorisSQLParserParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1522)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexDescContext is an interface to support dynamic dispatch.
type IIndexDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// Getter signatures
	INDEX() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	Identifier() IIdentifierContext
	IndexType() IIndexTypeContext
	Comment() ICommentContext
	PropertyList() IPropertyListContext

	// IsIndexDescContext differentiates from other interfaces.
	IsIndexDescContext()
}

type IndexDescContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	indexName IIdentifierContext
}

func NewEmptyIndexDescContext() *IndexDescContext {
	var p = new(IndexDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_indexDesc
	return p
}

func InitEmptyIndexDescContext(p *IndexDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_indexDesc
}

func (*IndexDescContext) IsIndexDescContext() {}

func NewIndexDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexDescContext {
	var p = new(IndexDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_indexDesc

	return p
}

func (s *IndexDescContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexDescContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *IndexDescContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *IndexDescContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINDEX, 0)
}

func (s *IndexDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *IndexDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IndexDescContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *IndexDescContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *IndexDescContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *IndexDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterIndexDesc(s)
	}
}

func (s *IndexDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitIndexDesc(s)
	}
}

func (s *IndexDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitIndexDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) IndexDesc() (localctx IIndexDescContext) {
	localctx = NewIndexDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, DorisSQLParserParserRULE_indexDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1524)
		p.Match(DorisSQLParserParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1525)

		var _x = p.Identifier()

		localctx.(*IndexDescContext).indexName = _x
	}
	{
		p.SetState(1526)
		p.IdentifierList()
	}
	p.SetState(1531)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserUSING {
		{
			p.SetState(1527)
			p.IndexType()
		}
		p.SetState(1529)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__1 {
			{
				p.SetState(1528)
				p.PropertyList()
			}

		}

	}
	p.SetState(1534)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserCOMMENT {
		{
			p.SetState(1533)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEngineDescContext is an interface to support dynamic dispatch.
type IEngineDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENGINE() antlr.TerminalNode
	EQ() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsEngineDescContext differentiates from other interfaces.
	IsEngineDescContext()
}

type EngineDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEngineDescContext() *EngineDescContext {
	var p = new(EngineDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_engineDesc
	return p
}

func InitEmptyEngineDescContext(p *EngineDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_engineDesc
}

func (*EngineDescContext) IsEngineDescContext() {}

func NewEngineDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EngineDescContext {
	var p = new(EngineDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_engineDesc

	return p
}

func (s *EngineDescContext) GetParser() antlr.Parser { return s.parser }

func (s *EngineDescContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserENGINE, 0)
}

func (s *EngineDescContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEQ, 0)
}

func (s *EngineDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EngineDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EngineDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EngineDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterEngineDesc(s)
	}
}

func (s *EngineDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitEngineDesc(s)
	}
}

func (s *EngineDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitEngineDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) EngineDesc() (localctx IEngineDescContext) {
	localctx = NewEngineDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, DorisSQLParserParserRULE_engineDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1536)
		p.Match(DorisSQLParserParserENGINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1537)
		p.Match(DorisSQLParserParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1538)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharsetDescContext is an interface to support dynamic dispatch.
type ICharsetDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierOrString() IIdentifierOrStringContext
	CHAR() antlr.TerminalNode
	SET() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	EQ() antlr.TerminalNode

	// IsCharsetDescContext differentiates from other interfaces.
	IsCharsetDescContext()
}

type CharsetDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetDescContext() *CharsetDescContext {
	var p = new(CharsetDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_charsetDesc
	return p
}

func InitEmptyCharsetDescContext(p *CharsetDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_charsetDesc
}

func (*CharsetDescContext) IsCharsetDescContext() {}

func NewCharsetDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetDescContext {
	var p = new(CharsetDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_charsetDesc

	return p
}

func (s *CharsetDescContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetDescContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CharsetDescContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCHAR, 0)
}

func (s *CharsetDescContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *CharsetDescContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCHARSET, 0)
}

func (s *CharsetDescContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCHARACTER, 0)
}

func (s *CharsetDescContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDEFAULT, 0)
}

func (s *CharsetDescContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEQ, 0)
}

func (s *CharsetDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCharsetDesc(s)
	}
}

func (s *CharsetDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCharsetDesc(s)
	}
}

func (s *CharsetDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCharsetDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CharsetDesc() (localctx ICharsetDescContext) {
	localctx = NewCharsetDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, DorisSQLParserParserRULE_charsetDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1541)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserDEFAULT {
		{
			p.SetState(1540)
			p.Match(DorisSQLParserParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1548)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserCHAR:
		{
			p.SetState(1543)
			p.Match(DorisSQLParserParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1544)
			p.Match(DorisSQLParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserCHARSET:
		{
			p.SetState(1545)
			p.Match(DorisSQLParserParserCHARSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserCHARACTER:
		{
			p.SetState(1546)
			p.Match(DorisSQLParserParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1547)
			p.Match(DorisSQLParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1551)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserEQ {
		{
			p.SetState(1550)
			p.Match(DorisSQLParserParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1553)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollateDescContext is an interface to support dynamic dispatch.
type ICollateDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLLATE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	DEFAULT() antlr.TerminalNode
	EQ() antlr.TerminalNode

	// IsCollateDescContext differentiates from other interfaces.
	IsCollateDescContext()
}

type CollateDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollateDescContext() *CollateDescContext {
	var p = new(CollateDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_collateDesc
	return p
}

func InitEmptyCollateDescContext(p *CollateDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_collateDesc
}

func (*CollateDescContext) IsCollateDescContext() {}

func NewCollateDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollateDescContext {
	var p = new(CollateDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_collateDesc

	return p
}

func (s *CollateDescContext) GetParser() antlr.Parser { return s.parser }

func (s *CollateDescContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLLATE, 0)
}

func (s *CollateDescContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CollateDescContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDEFAULT, 0)
}

func (s *CollateDescContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEQ, 0)
}

func (s *CollateDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollateDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCollateDesc(s)
	}
}

func (s *CollateDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCollateDesc(s)
	}
}

func (s *CollateDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCollateDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CollateDesc() (localctx ICollateDescContext) {
	localctx = NewCollateDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, DorisSQLParserParserRULE_collateDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserDEFAULT {
		{
			p.SetState(1555)
			p.Match(DorisSQLParserParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1558)
		p.Match(DorisSQLParserParserCOLLATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1560)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserEQ {
		{
			p.SetState(1559)
			p.Match(DorisSQLParserParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1562)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyDescContext is an interface to support dynamic dispatch.
type IKeyDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEY() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	AGGREGATE() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	DUPLICATE() antlr.TerminalNode

	// IsKeyDescContext differentiates from other interfaces.
	IsKeyDescContext()
}

type KeyDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyDescContext() *KeyDescContext {
	var p = new(KeyDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_keyDesc
	return p
}

func InitEmptyKeyDescContext(p *KeyDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_keyDesc
}

func (*KeyDescContext) IsKeyDescContext() {}

func NewKeyDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyDescContext {
	var p = new(KeyDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_keyDesc

	return p
}

func (s *KeyDescContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyDescContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserKEY, 0)
}

func (s *KeyDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *KeyDescContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAGGREGATE, 0)
}

func (s *KeyDescContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUNIQUE, 0)
}

func (s *KeyDescContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPRIMARY, 0)
}

func (s *KeyDescContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDUPLICATE, 0)
}

func (s *KeyDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterKeyDesc(s)
	}
}

func (s *KeyDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitKeyDesc(s)
	}
}

func (s *KeyDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitKeyDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) KeyDesc() (localctx IKeyDescContext) {
	localctx = NewKeyDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, DorisSQLParserParserRULE_keyDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1564)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserAGGREGATE || _la == DorisSQLParserParserDUPLICATE || _la == DorisSQLParserParserPRIMARY || _la == DorisSQLParserParserUNIQUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1565)
		p.Match(DorisSQLParserParserKEY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1566)
		p.IdentifierList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderByDescContext is an interface to support dynamic dispatch.
type IOrderByDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsOrderByDescContext differentiates from other interfaces.
	IsOrderByDescContext()
}

type OrderByDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByDescContext() *OrderByDescContext {
	var p = new(OrderByDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_orderByDesc
	return p
}

func InitEmptyOrderByDescContext(p *OrderByDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_orderByDesc
}

func (*OrderByDescContext) IsOrderByDescContext() {}

func NewOrderByDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByDescContext {
	var p = new(OrderByDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_orderByDesc

	return p
}

func (s *OrderByDescContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByDescContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserORDER, 0)
}

func (s *OrderByDescContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *OrderByDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *OrderByDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterOrderByDesc(s)
	}
}

func (s *OrderByDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitOrderByDesc(s)
	}
}

func (s *OrderByDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitOrderByDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) OrderByDesc() (localctx IOrderByDescContext) {
	localctx = NewOrderByDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, DorisSQLParserParserRULE_orderByDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1568)
		p.Match(DorisSQLParserParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1569)
		p.Match(DorisSQLParserParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1570)
		p.IdentifierList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnNullableContext is an interface to support dynamic dispatch.
type IColumnNullableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsColumnNullableContext differentiates from other interfaces.
	IsColumnNullableContext()
}

type ColumnNullableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNullableContext() *ColumnNullableContext {
	var p = new(ColumnNullableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_columnNullable
	return p
}

func InitEmptyColumnNullableContext(p *ColumnNullableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_columnNullable
}

func (*ColumnNullableContext) IsColumnNullableContext() {}

func NewColumnNullableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNullableContext {
	var p = new(ColumnNullableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_columnNullable

	return p
}

func (s *ColumnNullableContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNullableContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNULL, 0)
}

func (s *ColumnNullableContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *ColumnNullableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNullableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNullableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterColumnNullable(s)
	}
}

func (s *ColumnNullableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitColumnNullable(s)
	}
}

func (s *ColumnNullableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitColumnNullable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ColumnNullable() (localctx IColumnNullableContext) {
	localctx = NewColumnNullableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, DorisSQLParserParserRULE_columnNullable)
	p.SetState(1575)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserNULL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1572)
			p.Match(DorisSQLParserParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserNOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1573)
			p.Match(DorisSQLParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1574)
			p.Match(DorisSQLParserParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeWithNullableContext is an interface to support dynamic dispatch.
type ITypeWithNullableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext
	ColumnNullable() IColumnNullableContext

	// IsTypeWithNullableContext differentiates from other interfaces.
	IsTypeWithNullableContext()
}

type TypeWithNullableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeWithNullableContext() *TypeWithNullableContext {
	var p = new(TypeWithNullableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_typeWithNullable
	return p
}

func InitEmptyTypeWithNullableContext(p *TypeWithNullableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_typeWithNullable
}

func (*TypeWithNullableContext) IsTypeWithNullableContext() {}

func NewTypeWithNullableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeWithNullableContext {
	var p = new(TypeWithNullableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_typeWithNullable

	return p
}

func (s *TypeWithNullableContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeWithNullableContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeWithNullableContext) ColumnNullable() IColumnNullableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNullableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNullableContext)
}

func (s *TypeWithNullableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeWithNullableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeWithNullableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTypeWithNullable(s)
	}
}

func (s *TypeWithNullableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTypeWithNullable(s)
	}
}

func (s *TypeWithNullableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTypeWithNullable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) TypeWithNullable() (localctx ITypeWithNullableContext) {
	localctx = NewTypeWithNullableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, DorisSQLParserParserRULE_typeWithNullable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1577)
		p.Type_()
	}
	p.SetState(1579)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserNOT || _la == DorisSQLParserParserNULL {
		{
			p.SetState(1578)
			p.ColumnNullable()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggStateDescContext is an interface to support dynamic dispatch.
type IAggStateDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AllTypeWithNullable() []ITypeWithNullableContext
	TypeWithNullable(i int) ITypeWithNullableContext

	// IsAggStateDescContext differentiates from other interfaces.
	IsAggStateDescContext()
}

type AggStateDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggStateDescContext() *AggStateDescContext {
	var p = new(AggStateDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_aggStateDesc
	return p
}

func InitEmptyAggStateDescContext(p *AggStateDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_aggStateDesc
}

func (*AggStateDescContext) IsAggStateDescContext() {}

func NewAggStateDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggStateDescContext {
	var p = new(AggStateDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_aggStateDesc

	return p
}

func (s *AggStateDescContext) GetParser() antlr.Parser { return s.parser }

func (s *AggStateDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AggStateDescContext) AllTypeWithNullable() []ITypeWithNullableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeWithNullableContext); ok {
			len++
		}
	}

	tst := make([]ITypeWithNullableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeWithNullableContext); ok {
			tst[i] = t.(ITypeWithNullableContext)
			i++
		}
	}

	return tst
}

func (s *AggStateDescContext) TypeWithNullable(i int) ITypeWithNullableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeWithNullableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeWithNullableContext)
}

func (s *AggStateDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggStateDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggStateDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAggStateDesc(s)
	}
}

func (s *AggStateDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAggStateDesc(s)
	}
}

func (s *AggStateDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAggStateDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AggStateDesc() (localctx IAggStateDescContext) {
	localctx = NewAggStateDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, DorisSQLParserParserRULE_aggStateDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1581)
		p.Identifier()
	}
	{
		p.SetState(1582)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1583)
		p.TypeWithNullable()
	}
	p.SetState(1588)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(1584)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1585)
			p.TypeWithNullable()
		}

		p.SetState(1590)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1591)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggDescContext is an interface to support dynamic dispatch.
type IAggDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUM() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MIN() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	HLL_UNION() antlr.TerminalNode
	BITMAP_UNION() antlr.TerminalNode
	PERCENTILE_UNION() antlr.TerminalNode
	REPLACE_IF_NOT_NULL() antlr.TerminalNode
	AggStateDesc() IAggStateDescContext

	// IsAggDescContext differentiates from other interfaces.
	IsAggDescContext()
}

type AggDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggDescContext() *AggDescContext {
	var p = new(AggDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_aggDesc
	return p
}

func InitEmptyAggDescContext(p *AggDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_aggDesc
}

func (*AggDescContext) IsAggDescContext() {}

func NewAggDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggDescContext {
	var p = new(AggDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_aggDesc

	return p
}

func (s *AggDescContext) GetParser() antlr.Parser { return s.parser }

func (s *AggDescContext) SUM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSUM, 0)
}

func (s *AggDescContext) MAX() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMAX, 0)
}

func (s *AggDescContext) MIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMIN, 0)
}

func (s *AggDescContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPLACE, 0)
}

func (s *AggDescContext) HLL_UNION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserHLL_UNION, 0)
}

func (s *AggDescContext) BITMAP_UNION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBITMAP_UNION, 0)
}

func (s *AggDescContext) PERCENTILE_UNION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPERCENTILE_UNION, 0)
}

func (s *AggDescContext) REPLACE_IF_NOT_NULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPLACE_IF_NOT_NULL, 0)
}

func (s *AggDescContext) AggStateDesc() IAggStateDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggStateDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggStateDescContext)
}

func (s *AggDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAggDesc(s)
	}
}

func (s *AggDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAggDesc(s)
	}
}

func (s *AggDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAggDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AggDesc() (localctx IAggDescContext) {
	localctx = NewAggDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, DorisSQLParserParserRULE_aggDesc)
	p.SetState(1602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1593)
			p.Match(DorisSQLParserParserSUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1594)
			p.Match(DorisSQLParserParserMAX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1595)
			p.Match(DorisSQLParserParserMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1596)
			p.Match(DorisSQLParserParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1597)
			p.Match(DorisSQLParserParserHLL_UNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1598)
			p.Match(DorisSQLParserParserBITMAP_UNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1599)
			p.Match(DorisSQLParserParserPERCENTILE_UNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1600)
			p.Match(DorisSQLParserParserREPLACE_IF_NOT_NULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1601)
			p.AggStateDesc()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollupDescContext is an interface to support dynamic dispatch.
type IRollupDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLLUP() antlr.TerminalNode
	AllRollupItem() []IRollupItemContext
	RollupItem(i int) IRollupItemContext

	// IsRollupDescContext differentiates from other interfaces.
	IsRollupDescContext()
}

type RollupDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollupDescContext() *RollupDescContext {
	var p = new(RollupDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_rollupDesc
	return p
}

func InitEmptyRollupDescContext(p *RollupDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_rollupDesc
}

func (*RollupDescContext) IsRollupDescContext() {}

func NewRollupDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollupDescContext {
	var p = new(RollupDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_rollupDesc

	return p
}

func (s *RollupDescContext) GetParser() antlr.Parser { return s.parser }

func (s *RollupDescContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROLLUP, 0)
}

func (s *RollupDescContext) AllRollupItem() []IRollupItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRollupItemContext); ok {
			len++
		}
	}

	tst := make([]IRollupItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRollupItemContext); ok {
			tst[i] = t.(IRollupItemContext)
			i++
		}
	}

	return tst
}

func (s *RollupDescContext) RollupItem(i int) IRollupItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupItemContext)
}

func (s *RollupDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollupDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRollupDesc(s)
	}
}

func (s *RollupDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRollupDesc(s)
	}
}

func (s *RollupDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRollupDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) RollupDesc() (localctx IRollupDescContext) {
	localctx = NewRollupDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, DorisSQLParserParserRULE_rollupDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1604)
		p.Match(DorisSQLParserParserROLLUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1605)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1606)
		p.RollupItem()
	}
	p.SetState(1611)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(1607)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1608)
			p.RollupItem()
		}

		p.SetState(1613)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1614)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollupItemContext is an interface to support dynamic dispatch.
type IRollupItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// Getter signatures
	IdentifierList() IIdentifierListContext
	Identifier() IIdentifierContext
	DupKeys() IDupKeysContext
	FromRollup() IFromRollupContext
	Properties() IPropertiesContext

	// IsRollupItemContext differentiates from other interfaces.
	IsRollupItemContext()
}

type RollupItemContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
}

func NewEmptyRollupItemContext() *RollupItemContext {
	var p = new(RollupItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_rollupItem
	return p
}

func InitEmptyRollupItemContext(p *RollupItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_rollupItem
}

func (*RollupItemContext) IsRollupItemContext() {}

func NewRollupItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollupItemContext {
	var p = new(RollupItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_rollupItem

	return p
}

func (s *RollupItemContext) GetParser() antlr.Parser { return s.parser }

func (s *RollupItemContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *RollupItemContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *RollupItemContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *RollupItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RollupItemContext) DupKeys() IDupKeysContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDupKeysContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDupKeysContext)
}

func (s *RollupItemContext) FromRollup() IFromRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromRollupContext)
}

func (s *RollupItemContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *RollupItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollupItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRollupItem(s)
	}
}

func (s *RollupItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRollupItem(s)
	}
}

func (s *RollupItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRollupItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) RollupItem() (localctx IRollupItemContext) {
	localctx = NewRollupItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, DorisSQLParserParserRULE_rollupItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1616)

		var _x = p.Identifier()

		localctx.(*RollupItemContext).rollupName = _x
	}
	{
		p.SetState(1617)
		p.IdentifierList()
	}
	p.SetState(1619)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserDUPLICATE {
		{
			p.SetState(1618)
			p.DupKeys()
		}

	}
	p.SetState(1622)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM {
		{
			p.SetState(1621)
			p.FromRollup()
		}

	}
	p.SetState(1625)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(1624)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDupKeysContext is an interface to support dynamic dispatch.
type IDupKeysContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DUPLICATE() antlr.TerminalNode
	KEY() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsDupKeysContext differentiates from other interfaces.
	IsDupKeysContext()
}

type DupKeysContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDupKeysContext() *DupKeysContext {
	var p = new(DupKeysContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dupKeys
	return p
}

func InitEmptyDupKeysContext(p *DupKeysContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dupKeys
}

func (*DupKeysContext) IsDupKeysContext() {}

func NewDupKeysContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DupKeysContext {
	var p = new(DupKeysContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dupKeys

	return p
}

func (s *DupKeysContext) GetParser() antlr.Parser { return s.parser }

func (s *DupKeysContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDUPLICATE, 0)
}

func (s *DupKeysContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserKEY, 0)
}

func (s *DupKeysContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DupKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DupKeysContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DupKeysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDupKeys(s)
	}
}

func (s *DupKeysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDupKeys(s)
	}
}

func (s *DupKeysContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDupKeys(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DupKeys() (localctx IDupKeysContext) {
	localctx = NewDupKeysContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, DorisSQLParserParserRULE_dupKeys)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1627)
		p.Match(DorisSQLParserParserDUPLICATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1628)
		p.Match(DorisSQLParserParserKEY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1629)
		p.IdentifierList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromRollupContext is an interface to support dynamic dispatch.
type IFromRollupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsFromRollupContext differentiates from other interfaces.
	IsFromRollupContext()
}

type FromRollupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromRollupContext() *FromRollupContext {
	var p = new(FromRollupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_fromRollup
	return p
}

func InitEmptyFromRollupContext(p *FromRollupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_fromRollup
}

func (*FromRollupContext) IsFromRollupContext() {}

func NewFromRollupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromRollupContext {
	var p = new(FromRollupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_fromRollup

	return p
}

func (s *FromRollupContext) GetParser() antlr.Parser { return s.parser }

func (s *FromRollupContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *FromRollupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FromRollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromRollupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromRollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterFromRollup(s)
	}
}

func (s *FromRollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitFromRollup(s)
	}
}

func (s *FromRollupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitFromRollup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) FromRollup() (localctx IFromRollupContext) {
	localctx = NewFromRollupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, DorisSQLParserParserRULE_fromRollup)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1631)
		p.Match(DorisSQLParserParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1632)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrReplaceContext is an interface to support dynamic dispatch.
type IOrReplaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode

	// IsOrReplaceContext differentiates from other interfaces.
	IsOrReplaceContext()
}

type OrReplaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrReplaceContext() *OrReplaceContext {
	var p = new(OrReplaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_orReplace
	return p
}

func InitEmptyOrReplaceContext(p *OrReplaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_orReplace
}

func (*OrReplaceContext) IsOrReplaceContext() {}

func NewOrReplaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrReplaceContext {
	var p = new(OrReplaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_orReplace

	return p
}

func (s *OrReplaceContext) GetParser() antlr.Parser { return s.parser }

func (s *OrReplaceContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOR, 0)
}

func (s *OrReplaceContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPLACE, 0)
}

func (s *OrReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrReplaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrReplaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterOrReplace(s)
	}
}

func (s *OrReplaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitOrReplace(s)
	}
}

func (s *OrReplaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitOrReplace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) OrReplace() (localctx IOrReplaceContext) {
	localctx = NewOrReplaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, DorisSQLParserParserRULE_orReplace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1636)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserOR {
		{
			p.SetState(1634)
			p.Match(DorisSQLParserParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1635)
			p.Match(DorisSQLParserParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfNotExistsContext is an interface to support dynamic dispatch.
type IIfNotExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsIfNotExistsContext differentiates from other interfaces.
	IsIfNotExistsContext()
}

type IfNotExistsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfNotExistsContext() *IfNotExistsContext {
	var p = new(IfNotExistsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_ifNotExists
	return p
}

func InitEmptyIfNotExistsContext(p *IfNotExistsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_ifNotExists
}

func (*IfNotExistsContext) IsIfNotExistsContext() {}

func NewIfNotExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfNotExistsContext {
	var p = new(IfNotExistsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_ifNotExists

	return p
}

func (s *IfNotExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfNotExistsContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *IfNotExistsContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *IfNotExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *IfNotExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfNotExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfNotExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterIfNotExists(s)
	}
}

func (s *IfNotExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitIfNotExists(s)
	}
}

func (s *IfNotExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitIfNotExists(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) IfNotExists() (localctx IIfNotExistsContext) {
	localctx = NewIfNotExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, DorisSQLParserParserRULE_ifNotExists)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1641)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(1638)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1639)
			p.Match(DorisSQLParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1640)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableAsSelectStatementContext is an interface to support dynamic dispatch.
type ICreateTableAsSelectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AS() antlr.TerminalNode
	QueryStatement() IQueryStatementContext
	TEMPORARY() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	KeyDesc() IKeyDescContext
	Comment() ICommentContext
	PartitionDesc() IPartitionDescContext
	DistributionDesc() IDistributionDescContext
	OrderByDesc() IOrderByDescContext
	Properties() IPropertiesContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllIndexDesc() []IIndexDescContext
	IndexDesc(i int) IIndexDescContext

	// IsCreateTableAsSelectStatementContext differentiates from other interfaces.
	IsCreateTableAsSelectStatementContext()
}

type CreateTableAsSelectStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableAsSelectStatementContext() *CreateTableAsSelectStatementContext {
	var p = new(CreateTableAsSelectStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createTableAsSelectStatement
	return p
}

func InitEmptyCreateTableAsSelectStatementContext(p *CreateTableAsSelectStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createTableAsSelectStatement
}

func (*CreateTableAsSelectStatementContext) IsCreateTableAsSelectStatementContext() {}

func NewCreateTableAsSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableAsSelectStatementContext {
	var p = new(CreateTableAsSelectStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createTableAsSelectStatement

	return p
}

func (s *CreateTableAsSelectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableAsSelectStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateTableAsSelectStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *CreateTableAsSelectStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateTableAsSelectStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *CreateTableAsSelectStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *CreateTableAsSelectStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTEMPORARY, 0)
}

func (s *CreateTableAsSelectStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *CreateTableAsSelectStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *CreateTableAsSelectStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *CreateTableAsSelectStatementContext) KeyDesc() IKeyDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyDescContext)
}

func (s *CreateTableAsSelectStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateTableAsSelectStatementContext) PartitionDesc() IPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDescContext)
}

func (s *CreateTableAsSelectStatementContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *CreateTableAsSelectStatementContext) OrderByDesc() IOrderByDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByDescContext)
}

func (s *CreateTableAsSelectStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateTableAsSelectStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableAsSelectStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateTableAsSelectStatementContext) AllIndexDesc() []IIndexDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexDescContext); ok {
			len++
		}
	}

	tst := make([]IIndexDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexDescContext); ok {
			tst[i] = t.(IIndexDescContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableAsSelectStatementContext) IndexDesc(i int) IIndexDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexDescContext)
}

func (s *CreateTableAsSelectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableAsSelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableAsSelectStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateTableAsSelectStatement(s)
	}
}

func (s *CreateTableAsSelectStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateTableAsSelectStatement(s)
	}
}

func (s *CreateTableAsSelectStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateTableAsSelectStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateTableAsSelectStatement() (localctx ICreateTableAsSelectStatementContext) {
	localctx = NewCreateTableAsSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, DorisSQLParserParserRULE_createTableAsSelectStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1643)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1645)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserTEMPORARY {
		{
			p.SetState(1644)
			p.Match(DorisSQLParserParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1647)
		p.Match(DorisSQLParserParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1651)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(1648)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1649)
			p.Match(DorisSQLParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1650)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1653)
		p.QualifiedName()
	}
	p.SetState(1682)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserT__1 {
		{
			p.SetState(1654)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1678)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserParserACCESS, DorisSQLParserParserACTIVE, DorisSQLParserParserADMIN, DorisSQLParserParserADVISOR, DorisSQLParserParserAFTER, DorisSQLParserParserAGGREGATE, DorisSQLParserParserANTI, DorisSQLParserParserAPPLY, DorisSQLParserParserARRAY_AGG, DorisSQLParserParserARRAY_AGG_DISTINCT, DorisSQLParserParserASYNC, DorisSQLParserParserAUTHORS, DorisSQLParserParserAUTHENTICATION, DorisSQLParserParserAUTOMATED, DorisSQLParserParserAUTO_INCREMENT, DorisSQLParserParserAVG, DorisSQLParserParserBACKEND, DorisSQLParserParserBACKENDS, DorisSQLParserParserBACKUP, DorisSQLParserParserBASE, DorisSQLParserParserBASELINE, DorisSQLParserParserBEGIN, DorisSQLParserParserBINARY, DorisSQLParserParserBITMAP_UNION, DorisSQLParserParserBLACKHOLE, DorisSQLParserParserBLACKLIST, DorisSQLParserParserBODY, DorisSQLParserParserBOOLEAN, DorisSQLParserParserBRANCH, DorisSQLParserParserBROKER, DorisSQLParserParserBUCKETS, DorisSQLParserParserBUILTIN, DorisSQLParserParserCACHE, DorisSQLParserParserCANCEL, DorisSQLParserParserCAST, DorisSQLParserParserCATALOG, DorisSQLParserParserCATALOGS, DorisSQLParserParserCEIL, DorisSQLParserParserCHAIN, DorisSQLParserParserCHARSET, DorisSQLParserParserCLEAN, DorisSQLParserParserCLEAR, DorisSQLParserParserCLUSTER, DorisSQLParserParserCLUSTERS, DorisSQLParserParserCNGROUP, DorisSQLParserParserCNGROUPS, DorisSQLParserParserCOLLATION, DorisSQLParserParserCOLUMNS, DorisSQLParserParserCOMMENT, DorisSQLParserParserCOMMIT, DorisSQLParserParserCOMMITTED, DorisSQLParserParserCOMPACT, DorisSQLParserParserCOMPUTE, DorisSQLParserParserCONFIG, DorisSQLParserParserCONNECTION, DorisSQLParserParserCONSISTENT, DorisSQLParserParserCOSTS, DorisSQLParserParserCOUNT, DorisSQLParserParserCUME_DIST, DorisSQLParserParserCUMULATIVE, DorisSQLParserParserCURRENT, DorisSQLParserParserDATA, DorisSQLParserParserDATACACHE, DorisSQLParserParserDATE, DorisSQLParserParserDATETIME, DorisSQLParserParserDAY, DorisSQLParserParserDAYS, DorisSQLParserParserDEALLOCATE, DorisSQLParserParserDECOMMISSION, DorisSQLParserParserDIALECT, DorisSQLParserParserDICTIONARY, DorisSQLParserParserDICTIONARY_GET, DorisSQLParserParserDISABLE, DorisSQLParserParserDISTRIBUTED, DorisSQLParserParserDISTRIBUTION, DorisSQLParserParserDUPLICATE, DorisSQLParserParserDYNAMIC, DorisSQLParserParserENABLE, DorisSQLParserParserENCLOSE, DorisSQLParserParserEND, DorisSQLParserParserENGINE, DorisSQLParserParserENGINES, DorisSQLParserParserERRORS, DorisSQLParserParserESCAPE, DorisSQLParserParserEVENTS, DorisSQLParserParserEXCEPT, DorisSQLParserParserEXCLUDE, DorisSQLParserParserEXECUTE, DorisSQLParserParserEXPORT, DorisSQLParserParserEXTERNAL, DorisSQLParserParserEXTRACT, DorisSQLParserParserEVERY, DorisSQLParserParserFAILPOINT, DorisSQLParserParserFAILPOINTS, DorisSQLParserParserFIELDS, DorisSQLParserParserFILE, DorisSQLParserParserFILTER, DorisSQLParserParserFIRST, DorisSQLParserParserFLOOR, DorisSQLParserParserFN, DorisSQLParserParserFOLLOWING, DorisSQLParserParserFOLLOWER, DorisSQLParserParserFORMAT, DorisSQLParserParserFREE, DorisSQLParserParserFRONTEND, DorisSQLParserParserFRONTENDS, DorisSQLParserParserFUNCTIONS, DorisSQLParserParserGLOBAL, DorisSQLParserParserGRANTS, DorisSQLParserParserGROUP_CONCAT, DorisSQLParserParserHASH, DorisSQLParserParserHELP, DorisSQLParserParserHISTOGRAM, DorisSQLParserParserHLL_UNION, DorisSQLParserParserHOST, DorisSQLParserParserHOUR, DorisSQLParserParserHOURS, DorisSQLParserParserHUB, DorisSQLParserParserIDENTIFIED, DorisSQLParserParserIMPERSONATE, DorisSQLParserParserIMAGE, DorisSQLParserParserINACTIVE, DorisSQLParserParserINCREMENTAL, DorisSQLParserParserINDEXES, DorisSQLParserParserINSTALL, DorisSQLParserParserINTEGRATION, DorisSQLParserParserINTEGRATIONS, DorisSQLParserParserINTERMEDIATE, DorisSQLParserParserINTERVAL, DorisSQLParserParserOVERWRITE, DorisSQLParserParserISOLATION, DorisSQLParserParserJOB, DorisSQLParserParserLABEL, DorisSQLParserParserLAST, DorisSQLParserParserLESS, DorisSQLParserParserLEVEL, DorisSQLParserParserLIST, DorisSQLParserParserLOCAL, DorisSQLParserParserLOCATION, DorisSQLParserParserLOCATIONS, DorisSQLParserParserLOGS, DorisSQLParserParserLOGICAL, DorisSQLParserParserMANUAL, DorisSQLParserParserMAP, DorisSQLParserParserMAPPING, DorisSQLParserParserMAPPINGS, DorisSQLParserParserMASKING, DorisSQLParserParserMATCH, DorisSQLParserParserMATERIALIZED, DorisSQLParserParserMAX, DorisSQLParserParserMERGE, DorisSQLParserParserMIN, DorisSQLParserParserMINUTE, DorisSQLParserParserMINUTES, DorisSQLParserParserMINUS, DorisSQLParserParserMETA, DorisSQLParserParserMODE, DorisSQLParserParserMODIFY, DorisSQLParserParserMONTH, DorisSQLParserParserMULTIPLE, DorisSQLParserParserNAME, DorisSQLParserParserNAMES, DorisSQLParserParserNEGATIVE, DorisSQLParserParserNGRAMBF, DorisSQLParserParserNO, DorisSQLParserParserNODE, DorisSQLParserParserNODES, DorisSQLParserParserNONE, DorisSQLParserParserNULLS, DorisSQLParserParserNUMBER, DorisSQLParserParserNUMERIC, DorisSQLParserParserOBSERVER, DorisSQLParserParserOF, DorisSQLParserParserOFF, DorisSQLParserParserOFFSET, DorisSQLParserParserONLY, DorisSQLParserParserOPEN, DorisSQLParserParserOPERATE, DorisSQLParserParserOPTIMIZER, DorisSQLParserParserOPTION, DorisSQLParserParserPARTITIONS, DorisSQLParserParserPASSWORD, DorisSQLParserParserPATH, DorisSQLParserParserPAUSE, DorisSQLParserParserPENDING, DorisSQLParserParserPERCENT_RANK, DorisSQLParserParserPERCENTILE_UNION, DorisSQLParserParserPLAN, DorisSQLParserParserPLUGIN, DorisSQLParserParserPLUGINS, DorisSQLParserParserPIPE, DorisSQLParserParserPIPES, DorisSQLParserParserPIVOT, DorisSQLParserParserPOLICY, DorisSQLParserParserPOLICIES, DorisSQLParserParserPRECEDING, DorisSQLParserParserPREDICATE, DorisSQLParserParserPRIORITY, DorisSQLParserParserPRIVILEGES, DorisSQLParserParserPROBABILITY, DorisSQLParserParserPROC, DorisSQLParserParserPROCESSLIST, DorisSQLParserParserPROFILE, DorisSQLParserParserPROFILELIST, DorisSQLParserParserPROPERTIES, DorisSQLParserParserPROPERTY, DorisSQLParserParserPROVIDER, DorisSQLParserParserPROVIDERS, DorisSQLParserParserQUALIFY, DorisSQLParserParserQUARTER, DorisSQLParserParserQUERY, DorisSQLParserParserQUERIES, DorisSQLParserParserQUEUE, DorisSQLParserParserQUOTA, DorisSQLParserParserRANDOM, DorisSQLParserParserRANK, DorisSQLParserParserREASON, DorisSQLParserParserRECOVER, DorisSQLParserParserREFRESH, DorisSQLParserParserREWRITE, DorisSQLParserParserREMOVE, DorisSQLParserParserREPAIR, DorisSQLParserParserREPEATABLE, DorisSQLParserParserREPLACE_IF_NOT_NULL, DorisSQLParserParserREPLICA, DorisSQLParserParserREPOSITORY, DorisSQLParserParserREPOSITORIES, DorisSQLParserParserRESOURCE, DorisSQLParserParserRESOURCES, DorisSQLParserParserRESTORE, DorisSQLParserParserRESUME, DorisSQLParserParserRETAIN, DorisSQLParserParserRETENTION, DorisSQLParserParserRETURNS, DorisSQLParserParserRETRY, DorisSQLParserParserREVERT, DorisSQLParserParserROLE, DorisSQLParserParserROLES, DorisSQLParserParserROLLBACK, DorisSQLParserParserROLLUP, DorisSQLParserParserROUTINE, DorisSQLParserParserROW, DorisSQLParserParserRULE, DorisSQLParserParserRULES, DorisSQLParserParserRUNNING, DorisSQLParserParserSAMPLE, DorisSQLParserParserSCHEDULE, DorisSQLParserParserSCHEDULER, DorisSQLParserParserSECOND, DorisSQLParserParserSECURITY, DorisSQLParserParserSEMI, DorisSQLParserParserSEPARATOR, DorisSQLParserParserSERIALIZABLE, DorisSQLParserParserSESSION, DorisSQLParserParserSETS, DorisSQLParserParserSIGNED, DorisSQLParserParserSKIP_HEADER, DorisSQLParserParserSNAPSHOT, DorisSQLParserParserSNAPSHOTS, DorisSQLParserParserSQLBLACKLIST, DorisSQLParserParserSTART, DorisSQLParserParserSTATS, DorisSQLParserParserSTATUS, DorisSQLParserParserSTOP, DorisSQLParserParserSTORAGE, DorisSQLParserParserSTREAM, DorisSQLParserParserSTRING, DorisSQLParserParserSUBMIT, DorisSQLParserParserSUM, DorisSQLParserParserSUSPEND, DorisSQLParserParserSYNC, DorisSQLParserParserSYSTEM_TIME, DorisSQLParserParserSWAP, DorisSQLParserParserSTRUCT, DorisSQLParserParserTABLES, DorisSQLParserParserTABLET, DorisSQLParserParserTABLETS, DorisSQLParserParserTAG, DorisSQLParserParserTASK, DorisSQLParserParserTEMPORARY, DorisSQLParserParserTHAN, DorisSQLParserParserTIME, DorisSQLParserParserTIMES, DorisSQLParserParserTIMESTAMP, DorisSQLParserParserTIMESTAMPADD, DorisSQLParserParserTIMESTAMPDIFF, DorisSQLParserParserTRANSACTION, DorisSQLParserParserTRANSLATE, DorisSQLParserParserTRACE, DorisSQLParserParserTRIGGERS, DorisSQLParserParserTRIM_SPACE, DorisSQLParserParserTRUNCATE, DorisSQLParserParserTYPE, DorisSQLParserParserTYPES, DorisSQLParserParserUNBOUNDED, DorisSQLParserParserUNCOMMITTED, DorisSQLParserParserUNINSTALL, DorisSQLParserParserUNSET, DorisSQLParserParserUSAGE, DorisSQLParserParserUSER, DorisSQLParserParserUSERS, DorisSQLParserParserVALUE, DorisSQLParserParserVARBINARY, DorisSQLParserParserVARIABLES, DorisSQLParserParserVECTOR, DorisSQLParserParserVERBOSE, DorisSQLParserParserVERSION, DorisSQLParserParserVIEW, DorisSQLParserParserVIEWS, DorisSQLParserParserVOLUME, DorisSQLParserParserVOLUMES, DorisSQLParserParserWAREHOUSE, DorisSQLParserParserWAREHOUSES, DorisSQLParserParserWARNINGS, DorisSQLParserParserWEEK, DorisSQLParserParserWHITELIST, DorisSQLParserParserWORK, DorisSQLParserParserWRITE, DorisSQLParserParserYEAR, DorisSQLParserParserLOCK, DorisSQLParserParserUNLOCK, DorisSQLParserParserLOW_PRIORITY, DorisSQLParserParserDISK, DorisSQLParserParserBEFORE, DorisSQLParserParserFIELD, DorisSQLParserParserPERSISTENT, DorisSQLParserParserARRAY_ELEMENT, DorisSQLParserParserLETTER_IDENTIFIER, DorisSQLParserParserDIGIT_IDENTIFIER, DorisSQLParserParserBACKQUOTED_IDENTIFIER, DorisSQLParserParserDOTDOTDOT:
			{
				p.SetState(1655)
				p.Identifier()
			}
			p.SetState(1660)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1656)
						p.Match(DorisSQLParserParserT__2)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1657)
						p.Identifier()
					}

				}
				p.SetState(1662)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(1667)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(1663)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1664)
					p.IndexDesc()
				}

				p.SetState(1669)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		case DorisSQLParserParserINDEX:
			{
				p.SetState(1670)
				p.IndexDesc()
			}
			p.SetState(1675)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(1671)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1672)
					p.IndexDesc()
				}

				p.SetState(1677)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(1680)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1685)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserAGGREGATE || _la == DorisSQLParserParserDUPLICATE || _la == DorisSQLParserParserPRIMARY || _la == DorisSQLParserParserUNIQUE {
		{
			p.SetState(1684)
			p.KeyDesc()
		}

	}
	p.SetState(1688)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserCOMMENT {
		{
			p.SetState(1687)
			p.Comment()
		}

	}
	p.SetState(1691)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPARTITION {
		{
			p.SetState(1690)
			p.PartitionDesc()
		}

	}
	p.SetState(1694)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserDISTRIBUTED {
		{
			p.SetState(1693)
			p.DistributionDesc()
		}

	}
	p.SetState(1697)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserORDER {
		{
			p.SetState(1696)
			p.OrderByDesc()
		}

	}
	p.SetState(1700)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(1699)
			p.Properties()
		}

	}
	{
		p.SetState(1702)
		p.Match(DorisSQLParserParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1703)
		p.QueryStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTableStatementContext is an interface to support dynamic dispatch.
type IDropTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	TEMPORARY() antlr.TerminalNode
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	FORCE() antlr.TerminalNode

	// IsDropTableStatementContext differentiates from other interfaces.
	IsDropTableStatementContext()
}

type DropTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTableStatementContext() *DropTableStatementContext {
	var p = new(DropTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropTableStatement
	return p
}

func InitEmptyDropTableStatementContext(p *DropTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropTableStatement
}

func (*DropTableStatementContext) IsDropTableStatementContext() {}

func NewDropTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTableStatementContext {
	var p = new(DropTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropTableStatement

	return p
}

func (s *DropTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTableStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *DropTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropTableStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTEMPORARY, 0)
}

func (s *DropTableStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *DropTableStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *DropTableStatementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFORCE, 0)
}

func (s *DropTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropTableStatement(s)
	}
}

func (s *DropTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropTableStatement(s)
	}
}

func (s *DropTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropTableStatement() (localctx IDropTableStatementContext) {
	localctx = NewDropTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, DorisSQLParserParserRULE_dropTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1705)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1707)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserTEMPORARY {
		{
			p.SetState(1706)
			p.Match(DorisSQLParserParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1709)
		p.Match(DorisSQLParserParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1712)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(1710)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1711)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1714)
		p.QualifiedName()
	}
	p.SetState(1716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFORCE {
		{
			p.SetState(1715)
			p.Match(DorisSQLParserParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICleanTemporaryTableStatementContext is an interface to support dynamic dispatch.
type ICleanTemporaryTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLEAN() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	ON() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	String_() IStringContext

	// IsCleanTemporaryTableStatementContext differentiates from other interfaces.
	IsCleanTemporaryTableStatementContext()
}

type CleanTemporaryTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCleanTemporaryTableStatementContext() *CleanTemporaryTableStatementContext {
	var p = new(CleanTemporaryTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cleanTemporaryTableStatement
	return p
}

func InitEmptyCleanTemporaryTableStatementContext(p *CleanTemporaryTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cleanTemporaryTableStatement
}

func (*CleanTemporaryTableStatementContext) IsCleanTemporaryTableStatementContext() {}

func NewCleanTemporaryTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CleanTemporaryTableStatementContext {
	var p = new(CleanTemporaryTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_cleanTemporaryTableStatement

	return p
}

func (s *CleanTemporaryTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CleanTemporaryTableStatementContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCLEAN, 0)
}

func (s *CleanTemporaryTableStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTEMPORARY, 0)
}

func (s *CleanTemporaryTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *CleanTemporaryTableStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *CleanTemporaryTableStatementContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSESSION, 0)
}

func (s *CleanTemporaryTableStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CleanTemporaryTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CleanTemporaryTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CleanTemporaryTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCleanTemporaryTableStatement(s)
	}
}

func (s *CleanTemporaryTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCleanTemporaryTableStatement(s)
	}
}

func (s *CleanTemporaryTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCleanTemporaryTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CleanTemporaryTableStatement() (localctx ICleanTemporaryTableStatementContext) {
	localctx = NewCleanTemporaryTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, DorisSQLParserParserRULE_cleanTemporaryTableStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1718)
		p.Match(DorisSQLParserParserCLEAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1719)
		p.Match(DorisSQLParserParserTEMPORARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1720)
		p.Match(DorisSQLParserParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1721)
		p.Match(DorisSQLParserParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1722)
		p.Match(DorisSQLParserParserSESSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1723)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableStatementContext is an interface to support dynamic dispatch.
type IAlterTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AllAlterClause() []IAlterClauseContext
	AlterClause(i int) IAlterClauseContext
	ADD() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	AllRollupItem() []IRollupItemContext
	RollupItem(i int) IRollupItemContext
	DROP() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsAlterTableStatementContext differentiates from other interfaces.
	IsAlterTableStatementContext()
}

type AlterTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableStatementContext() *AlterTableStatementContext {
	var p = new(AlterTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterTableStatement
	return p
}

func InitEmptyAlterTableStatementContext(p *AlterTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterTableStatement
}

func (*AlterTableStatementContext) IsAlterTableStatementContext() {}

func NewAlterTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableStatementContext {
	var p = new(AlterTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_alterTableStatement

	return p
}

func (s *AlterTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *AlterTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *AlterTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterTableStatementContext) AllAlterClause() []IAlterClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterClauseContext); ok {
			len++
		}
	}

	tst := make([]IAlterClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterClauseContext); ok {
			tst[i] = t.(IAlterClauseContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableStatementContext) AlterClause(i int) IAlterClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterClauseContext)
}

func (s *AlterTableStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADD, 0)
}

func (s *AlterTableStatementContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROLLUP, 0)
}

func (s *AlterTableStatementContext) AllRollupItem() []IRollupItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRollupItemContext); ok {
			len++
		}
	}

	tst := make([]IRollupItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRollupItemContext); ok {
			tst[i] = t.(IRollupItemContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableStatementContext) RollupItem(i int) IRollupItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupItemContext)
}

func (s *AlterTableStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *AlterTableStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAlterTableStatement(s)
	}
}

func (s *AlterTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAlterTableStatement(s)
	}
}

func (s *AlterTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAlterTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AlterTableStatement() (localctx IAlterTableStatementContext) {
	localctx = NewAlterTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, DorisSQLParserParserRULE_alterTableStatement)
	var _la int

	p.SetState(1762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1725)
			p.Match(DorisSQLParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1726)
			p.Match(DorisSQLParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1727)
			p.QualifiedName()
		}
		{
			p.SetState(1728)
			p.AlterClause()
		}
		p.SetState(1733)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(1729)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1730)
				p.AlterClause()
			}

			p.SetState(1735)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1736)
			p.Match(DorisSQLParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1737)
			p.Match(DorisSQLParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1738)
			p.QualifiedName()
		}
		{
			p.SetState(1739)
			p.Match(DorisSQLParserParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1740)
			p.Match(DorisSQLParserParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1741)
			p.RollupItem()
		}
		p.SetState(1746)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(1742)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1743)
				p.RollupItem()
			}

			p.SetState(1748)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1749)
			p.Match(DorisSQLParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1750)
			p.Match(DorisSQLParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1751)
			p.QualifiedName()
		}
		{
			p.SetState(1752)
			p.Match(DorisSQLParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1753)
			p.Match(DorisSQLParserParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1754)
			p.Identifier()
		}
		p.SetState(1759)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(1755)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1756)
				p.Identifier()
			}

			p.SetState(1761)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateIndexStatementContext is an interface to support dynamic dispatch.
type ICreateIndexStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	ON() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IdentifierList() IIdentifierListContext
	Identifier() IIdentifierContext
	IndexType() IIndexTypeContext
	Comment() ICommentContext
	PropertyList() IPropertyListContext

	// IsCreateIndexStatementContext differentiates from other interfaces.
	IsCreateIndexStatementContext()
}

type CreateIndexStatementContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	indexName IIdentifierContext
}

func NewEmptyCreateIndexStatementContext() *CreateIndexStatementContext {
	var p = new(CreateIndexStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createIndexStatement
	return p
}

func InitEmptyCreateIndexStatementContext(p *CreateIndexStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createIndexStatement
}

func (*CreateIndexStatementContext) IsCreateIndexStatementContext() {}

func NewCreateIndexStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateIndexStatementContext {
	var p = new(CreateIndexStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createIndexStatement

	return p
}

func (s *CreateIndexStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateIndexStatementContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *CreateIndexStatementContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *CreateIndexStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateIndexStatementContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINDEX, 0)
}

func (s *CreateIndexStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *CreateIndexStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateIndexStatementContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateIndexStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateIndexStatementContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *CreateIndexStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateIndexStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *CreateIndexStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateIndexStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateIndexStatement(s)
	}
}

func (s *CreateIndexStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateIndexStatement(s)
	}
}

func (s *CreateIndexStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateIndexStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateIndexStatement() (localctx ICreateIndexStatementContext) {
	localctx = NewCreateIndexStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, DorisSQLParserParserRULE_createIndexStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1764)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1765)
		p.Match(DorisSQLParserParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1766)

		var _x = p.Identifier()

		localctx.(*CreateIndexStatementContext).indexName = _x
	}
	{
		p.SetState(1767)
		p.Match(DorisSQLParserParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1768)
		p.QualifiedName()
	}
	{
		p.SetState(1769)
		p.IdentifierList()
	}
	p.SetState(1774)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserUSING {
		{
			p.SetState(1770)
			p.IndexType()
		}
		p.SetState(1772)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__1 {
			{
				p.SetState(1771)
				p.PropertyList()
			}

		}

	}
	p.SetState(1777)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserCOMMENT {
		{
			p.SetState(1776)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropIndexStatementContext is an interface to support dynamic dispatch.
type IDropIndexStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	ON() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	Identifier() IIdentifierContext

	// IsDropIndexStatementContext differentiates from other interfaces.
	IsDropIndexStatementContext()
}

type DropIndexStatementContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	indexName IIdentifierContext
}

func NewEmptyDropIndexStatementContext() *DropIndexStatementContext {
	var p = new(DropIndexStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropIndexStatement
	return p
}

func InitEmptyDropIndexStatementContext(p *DropIndexStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropIndexStatement
}

func (*DropIndexStatementContext) IsDropIndexStatementContext() {}

func NewDropIndexStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropIndexStatementContext {
	var p = new(DropIndexStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropIndexStatement

	return p
}

func (s *DropIndexStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropIndexStatementContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *DropIndexStatementContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *DropIndexStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropIndexStatementContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINDEX, 0)
}

func (s *DropIndexStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *DropIndexStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropIndexStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropIndexStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropIndexStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropIndexStatement(s)
	}
}

func (s *DropIndexStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropIndexStatement(s)
	}
}

func (s *DropIndexStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropIndexStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropIndexStatement() (localctx IDropIndexStatementContext) {
	localctx = NewDropIndexStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, DorisSQLParserParserRULE_dropIndexStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1779)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1780)
		p.Match(DorisSQLParserParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1781)

		var _x = p.Identifier()

		localctx.(*DropIndexStatementContext).indexName = _x
	}
	{
		p.SetState(1782)
		p.Match(DorisSQLParserParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1783)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexTypeContext is an interface to support dynamic dispatch.
type IIndexTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USING() antlr.TerminalNode
	BITMAP() antlr.TerminalNode
	GIN() antlr.TerminalNode
	NGRAMBF() antlr.TerminalNode
	VECTOR() antlr.TerminalNode

	// IsIndexTypeContext differentiates from other interfaces.
	IsIndexTypeContext()
}

type IndexTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexTypeContext() *IndexTypeContext {
	var p = new(IndexTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_indexType
	return p
}

func InitEmptyIndexTypeContext(p *IndexTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_indexType
}

func (*IndexTypeContext) IsIndexTypeContext() {}

func NewIndexTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexTypeContext {
	var p = new(IndexTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_indexType

	return p
}

func (s *IndexTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexTypeContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSING, 0)
}

func (s *IndexTypeContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBITMAP, 0)
}

func (s *IndexTypeContext) GIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGIN, 0)
}

func (s *IndexTypeContext) NGRAMBF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNGRAMBF, 0)
}

func (s *IndexTypeContext) VECTOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVECTOR, 0)
}

func (s *IndexTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterIndexType(s)
	}
}

func (s *IndexTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitIndexType(s)
	}
}

func (s *IndexTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitIndexType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) IndexType() (localctx IIndexTypeContext) {
	localctx = NewIndexTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, DorisSQLParserParserRULE_indexType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1785)
		p.Match(DorisSQLParserParserUSING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1786)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserBITMAP || _la == DorisSQLParserParserGIN || _la == DorisSQLParserParserNGRAMBF || _la == DorisSQLParserParserVECTOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowTableStatementContext is an interface to support dynamic dispatch.
type IShowTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	FULL() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowTableStatementContext differentiates from other interfaces.
	IsShowTableStatementContext()
}

type ShowTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	db      IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowTableStatementContext() *ShowTableStatementContext {
	var p = new(ShowTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showTableStatement
	return p
}

func InitEmptyShowTableStatementContext(p *ShowTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showTableStatement
}

func (*ShowTableStatementContext) IsShowTableStatementContext() {}

func NewShowTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTableStatementContext {
	var p = new(ShowTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showTableStatement

	return p
}

func (s *ShowTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTableStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowTableStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowTableStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowTableStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowTableStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowTableStatementContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLES, 0)
}

func (s *ShowTableStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFULL, 0)
}

func (s *ShowTableStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowTableStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *ShowTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTableStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *ShowTableStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowTableStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowTableStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowTableStatement(s)
	}
}

func (s *ShowTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowTableStatement(s)
	}
}

func (s *ShowTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowTableStatement() (localctx IShowTableStatementContext) {
	localctx = NewShowTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, DorisSQLParserParserRULE_showTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1788)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1790)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFULL {
		{
			p.SetState(1789)
			p.Match(DorisSQLParserParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1792)
		p.Match(DorisSQLParserParserTABLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1795)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN {
		{
			p.SetState(1793)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1794)

			var _x = p.QualifiedName()

			localctx.(*ShowTableStatementContext).db = _x
		}

	}
	p.SetState(1801)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserLIKE:
		{
			p.SetState(1797)
			p.Match(DorisSQLParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1798)

			var _x = p.String_()

			localctx.(*ShowTableStatementContext).pattern = _x
		}

	case DorisSQLParserParserWHERE:
		{
			p.SetState(1799)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1800)
			p.expression(0)
		}

	case DorisSQLParserParserEOF, DorisSQLParserParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowTemporaryTablesStatementContext is an interface to support dynamic dispatch.
type IShowTemporaryTablesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowTemporaryTablesStatementContext differentiates from other interfaces.
	IsShowTemporaryTablesStatementContext()
}

type ShowTemporaryTablesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	db      IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowTemporaryTablesStatementContext() *ShowTemporaryTablesStatementContext {
	var p = new(ShowTemporaryTablesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showTemporaryTablesStatement
	return p
}

func InitEmptyShowTemporaryTablesStatementContext(p *ShowTemporaryTablesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showTemporaryTablesStatement
}

func (*ShowTemporaryTablesStatementContext) IsShowTemporaryTablesStatementContext() {}

func NewShowTemporaryTablesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTemporaryTablesStatementContext {
	var p = new(ShowTemporaryTablesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showTemporaryTablesStatement

	return p
}

func (s *ShowTemporaryTablesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTemporaryTablesStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowTemporaryTablesStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowTemporaryTablesStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowTemporaryTablesStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowTemporaryTablesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowTemporaryTablesStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTEMPORARY, 0)
}

func (s *ShowTemporaryTablesStatementContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLES, 0)
}

func (s *ShowTemporaryTablesStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowTemporaryTablesStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *ShowTemporaryTablesStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTemporaryTablesStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *ShowTemporaryTablesStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowTemporaryTablesStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowTemporaryTablesStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowTemporaryTablesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTemporaryTablesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowTemporaryTablesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowTemporaryTablesStatement(s)
	}
}

func (s *ShowTemporaryTablesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowTemporaryTablesStatement(s)
	}
}

func (s *ShowTemporaryTablesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowTemporaryTablesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowTemporaryTablesStatement() (localctx IShowTemporaryTablesStatementContext) {
	localctx = NewShowTemporaryTablesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, DorisSQLParserParserRULE_showTemporaryTablesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1803)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1804)
		p.Match(DorisSQLParserParserTEMPORARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1805)
		p.Match(DorisSQLParserParserTABLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1808)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN {
		{
			p.SetState(1806)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1807)

			var _x = p.QualifiedName()

			localctx.(*ShowTemporaryTablesStatementContext).db = _x
		}

	}
	p.SetState(1814)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserLIKE:
		{
			p.SetState(1810)
			p.Match(DorisSQLParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1811)

			var _x = p.String_()

			localctx.(*ShowTemporaryTablesStatementContext).pattern = _x
		}

	case DorisSQLParserParserWHERE:
		{
			p.SetState(1812)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1813)
			p.expression(0)
		}

	case DorisSQLParserParserEOF, DorisSQLParserParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCreateTableStatementContext is an interface to support dynamic dispatch.
type IShowCreateTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	TABLE() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode

	// IsShowCreateTableStatementContext differentiates from other interfaces.
	IsShowCreateTableStatementContext()
}

type ShowCreateTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	table  IQualifiedNameContext
}

func NewEmptyShowCreateTableStatementContext() *ShowCreateTableStatementContext {
	var p = new(ShowCreateTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showCreateTableStatement
	return p
}

func InitEmptyShowCreateTableStatementContext(p *ShowCreateTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showCreateTableStatement
}

func (*ShowCreateTableStatementContext) IsShowCreateTableStatementContext() {}

func NewShowCreateTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCreateTableStatementContext {
	var p = new(ShowCreateTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showCreateTableStatement

	return p
}

func (s *ShowCreateTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCreateTableStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *ShowCreateTableStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *ShowCreateTableStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowCreateTableStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *ShowCreateTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCreateTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *ShowCreateTableStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVIEW, 0)
}

func (s *ShowCreateTableStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMATERIALIZED, 0)
}

func (s *ShowCreateTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCreateTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowCreateTableStatement(s)
	}
}

func (s *ShowCreateTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowCreateTableStatement(s)
	}
}

func (s *ShowCreateTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowCreateTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowCreateTableStatement() (localctx IShowCreateTableStatementContext) {
	localctx = NewShowCreateTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, DorisSQLParserParserRULE_showCreateTableStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1816)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1817)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1822)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserTABLE:
		{
			p.SetState(1818)
			p.Match(DorisSQLParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserVIEW:
		{
			p.SetState(1819)
			p.Match(DorisSQLParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserMATERIALIZED:
		{
			p.SetState(1820)
			p.Match(DorisSQLParserParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1821)
			p.Match(DorisSQLParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1824)

		var _x = p.QualifiedName()

		localctx.(*ShowCreateTableStatementContext).table = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowColumnStatementContext is an interface to support dynamic dispatch.
type IShowColumnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	FULL() antlr.TerminalNode
	AllFROM() []antlr.TerminalNode
	FROM(i int) antlr.TerminalNode
	AllIN() []antlr.TerminalNode
	IN(i int) antlr.TerminalNode
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowColumnStatementContext differentiates from other interfaces.
	IsShowColumnStatementContext()
}

type ShowColumnStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	table   IQualifiedNameContext
	db      IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowColumnStatementContext() *ShowColumnStatementContext {
	var p = new(ShowColumnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showColumnStatement
	return p
}

func InitEmptyShowColumnStatementContext(p *ShowColumnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showColumnStatement
}

func (*ShowColumnStatementContext) IsShowColumnStatementContext() {}

func NewShowColumnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowColumnStatementContext {
	var p = new(ShowColumnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showColumnStatement

	return p
}

func (s *ShowColumnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowColumnStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *ShowColumnStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowColumnStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowColumnStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *ShowColumnStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowColumnStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowColumnStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowColumnStatementContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLUMNS, 0)
}

func (s *ShowColumnStatementContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFIELDS, 0)
}

func (s *ShowColumnStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFULL, 0)
}

func (s *ShowColumnStatementContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserFROM)
}

func (s *ShowColumnStatementContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, i)
}

func (s *ShowColumnStatementContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserIN)
}

func (s *ShowColumnStatementContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, i)
}

func (s *ShowColumnStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *ShowColumnStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowColumnStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *ShowColumnStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowColumnStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowColumnStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowColumnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowColumnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowColumnStatement(s)
	}
}

func (s *ShowColumnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowColumnStatement(s)
	}
}

func (s *ShowColumnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowColumnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowColumnStatement() (localctx IShowColumnStatementContext) {
	localctx = NewShowColumnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, DorisSQLParserParserRULE_showColumnStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1826)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1828)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFULL {
		{
			p.SetState(1827)
			p.Match(DorisSQLParserParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1830)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserCOLUMNS || _la == DorisSQLParserParserFIELDS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	{
		p.SetState(1831)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1832)

		var _x = p.QualifiedName()

		localctx.(*ShowColumnStatementContext).table = _x
	}

	p.SetState(1836)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN {
		{
			p.SetState(1834)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1835)

			var _x = p.QualifiedName()

			localctx.(*ShowColumnStatementContext).db = _x
		}

	}
	p.SetState(1842)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserLIKE:
		{
			p.SetState(1838)
			p.Match(DorisSQLParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1839)

			var _x = p.String_()

			localctx.(*ShowColumnStatementContext).pattern = _x
		}

	case DorisSQLParserParserWHERE:
		{
			p.SetState(1840)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1841)
			p.expression(0)
		}

	case DorisSQLParserParserEOF, DorisSQLParserParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowTableStatusStatementContext is an interface to support dynamic dispatch.
type IShowTableStatusStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowTableStatusStatementContext differentiates from other interfaces.
	IsShowTableStatusStatementContext()
}

type ShowTableStatusStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	db      IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowTableStatusStatementContext() *ShowTableStatusStatementContext {
	var p = new(ShowTableStatusStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showTableStatusStatement
	return p
}

func InitEmptyShowTableStatusStatementContext(p *ShowTableStatusStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showTableStatusStatement
}

func (*ShowTableStatusStatementContext) IsShowTableStatusStatementContext() {}

func NewShowTableStatusStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTableStatusStatementContext {
	var p = new(ShowTableStatusStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showTableStatusStatement

	return p
}

func (s *ShowTableStatusStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTableStatusStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowTableStatusStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowTableStatusStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowTableStatusStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowTableStatusStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowTableStatusStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *ShowTableStatusStatementContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTATUS, 0)
}

func (s *ShowTableStatusStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowTableStatusStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *ShowTableStatusStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTableStatusStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *ShowTableStatusStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowTableStatusStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowTableStatusStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowTableStatusStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTableStatusStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowTableStatusStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowTableStatusStatement(s)
	}
}

func (s *ShowTableStatusStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowTableStatusStatement(s)
	}
}

func (s *ShowTableStatusStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowTableStatusStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowTableStatusStatement() (localctx IShowTableStatusStatementContext) {
	localctx = NewShowTableStatusStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, DorisSQLParserParserRULE_showTableStatusStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1844)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1845)
		p.Match(DorisSQLParserParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1846)
		p.Match(DorisSQLParserParserSTATUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1849)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN {
		{
			p.SetState(1847)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1848)

			var _x = p.QualifiedName()

			localctx.(*ShowTableStatusStatementContext).db = _x
		}

	}
	p.SetState(1855)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserLIKE:
		{
			p.SetState(1851)
			p.Match(DorisSQLParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1852)

			var _x = p.String_()

			localctx.(*ShowTableStatusStatementContext).pattern = _x
		}

	case DorisSQLParserParserWHERE:
		{
			p.SetState(1853)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1854)
			p.expression(0)
		}

	case DorisSQLParserParserEOF, DorisSQLParserParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshTableStatementContext is an interface to support dynamic dispatch.
type IRefreshTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REFRESH() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PARTITION() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsRefreshTableStatementContext differentiates from other interfaces.
	IsRefreshTableStatementContext()
}

type RefreshTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefreshTableStatementContext() *RefreshTableStatementContext {
	var p = new(RefreshTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_refreshTableStatement
	return p
}

func InitEmptyRefreshTableStatementContext(p *RefreshTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_refreshTableStatement
}

func (*RefreshTableStatementContext) IsRefreshTableStatementContext() {}

func NewRefreshTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshTableStatementContext {
	var p = new(RefreshTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_refreshTableStatement

	return p
}

func (s *RefreshTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshTableStatementContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREFRESH, 0)
}

func (s *RefreshTableStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXTERNAL, 0)
}

func (s *RefreshTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *RefreshTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RefreshTableStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPARTITION, 0)
}

func (s *RefreshTableStatementContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *RefreshTableStatementContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *RefreshTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRefreshTableStatement(s)
	}
}

func (s *RefreshTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRefreshTableStatement(s)
	}
}

func (s *RefreshTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRefreshTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) RefreshTableStatement() (localctx IRefreshTableStatementContext) {
	localctx = NewRefreshTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, DorisSQLParserParserRULE_refreshTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1857)
		p.Match(DorisSQLParserParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1858)
		p.Match(DorisSQLParserParserEXTERNAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1859)
		p.Match(DorisSQLParserParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1860)
		p.QualifiedName()
	}
	p.SetState(1873)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPARTITION {
		{
			p.SetState(1861)
			p.Match(DorisSQLParserParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1862)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1863)
			p.String_()
		}
		p.SetState(1868)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(1864)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1865)
				p.String_()
			}

			p.SetState(1870)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1871)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowAlterStatementContext is an interface to support dynamic dispatch.
type IShowAlterStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	OPTIMIZE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode

	// IsShowAlterStatementContext differentiates from other interfaces.
	IsShowAlterStatementContext()
}

type ShowAlterStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
}

func NewEmptyShowAlterStatementContext() *ShowAlterStatementContext {
	var p = new(ShowAlterStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showAlterStatement
	return p
}

func InitEmptyShowAlterStatementContext(p *ShowAlterStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showAlterStatement
}

func (*ShowAlterStatementContext) IsShowAlterStatementContext() {}

func NewShowAlterStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowAlterStatementContext {
	var p = new(ShowAlterStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showAlterStatement

	return p
}

func (s *ShowAlterStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowAlterStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowAlterStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowAlterStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowAlterStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *ShowAlterStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *ShowAlterStatementContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLUMN, 0)
}

func (s *ShowAlterStatementContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROLLUP, 0)
}

func (s *ShowAlterStatementContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOPTIMIZE, 0)
}

func (s *ShowAlterStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowAlterStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowAlterStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserORDER, 0)
}

func (s *ShowAlterStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *ShowAlterStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowAlterStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowAlterStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowAlterStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowAlterStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *ShowAlterStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowAlterStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMATERIALIZED, 0)
}

func (s *ShowAlterStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVIEW, 0)
}

func (s *ShowAlterStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAlterStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowAlterStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowAlterStatement(s)
	}
}

func (s *ShowAlterStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowAlterStatement(s)
	}
}

func (s *ShowAlterStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowAlterStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowAlterStatement() (localctx IShowAlterStatementContext) {
	localctx = NewShowAlterStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, DorisSQLParserParserRULE_showAlterStatement)
	var _la int

	p.SetState(1929)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1875)
			p.Match(DorisSQLParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1876)
			p.Match(DorisSQLParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1877)
			p.Match(DorisSQLParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1878)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserCOLUMN || _la == DorisSQLParserParserOPTIMIZE || _la == DorisSQLParserParserROLLUP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1881)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN {
			{
				p.SetState(1879)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1880)

				var _x = p.QualifiedName()

				localctx.(*ShowAlterStatementContext).db = _x
			}

		}
		p.SetState(1885)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserWHERE {
			{
				p.SetState(1883)
				p.Match(DorisSQLParserParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1884)
				p.expression(0)
			}

		}
		p.SetState(1897)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserORDER {
			{
				p.SetState(1887)
				p.Match(DorisSQLParserParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1888)
				p.Match(DorisSQLParserParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1889)
				p.SortItem()
			}
			p.SetState(1894)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(1890)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1891)
					p.SortItem()
				}

				p.SetState(1896)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(1900)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserLIMIT {
			{
				p.SetState(1899)
				p.LimitElement()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1902)
			p.Match(DorisSQLParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1903)
			p.Match(DorisSQLParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1904)
			p.Match(DorisSQLParserParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1905)
			p.Match(DorisSQLParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1908)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN {
			{
				p.SetState(1906)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1907)

				var _x = p.QualifiedName()

				localctx.(*ShowAlterStatementContext).db = _x
			}

		}
		p.SetState(1912)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserWHERE {
			{
				p.SetState(1910)
				p.Match(DorisSQLParserParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1911)
				p.expression(0)
			}

		}
		p.SetState(1924)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserORDER {
			{
				p.SetState(1914)
				p.Match(DorisSQLParserParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1915)
				p.Match(DorisSQLParserParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1916)
				p.SortItem()
			}
			p.SetState(1921)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(1917)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1918)
					p.SortItem()
				}

				p.SetState(1923)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(1927)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserLIMIT {
			{
				p.SetState(1926)
				p.LimitElement()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescTableStatementContext is an interface to support dynamic dispatch.
type IDescTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// Getter signatures
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	FILES() antlr.TerminalNode
	PropertyList() IPropertyListContext
	QualifiedName() IQualifiedNameContext
	ALL() antlr.TerminalNode

	// IsDescTableStatementContext differentiates from other interfaces.
	IsDescTableStatementContext()
}

type DescTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	table  IQualifiedNameContext
}

func NewEmptyDescTableStatementContext() *DescTableStatementContext {
	var p = new(DescTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_descTableStatement
	return p
}

func InitEmptyDescTableStatementContext(p *DescTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_descTableStatement
}

func (*DescTableStatementContext) IsDescTableStatementContext() {}

func NewDescTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescTableStatementContext {
	var p = new(DescTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_descTableStatement

	return p
}

func (s *DescTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DescTableStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *DescTableStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *DescTableStatementContext) DESC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDESC, 0)
}

func (s *DescTableStatementContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDESCRIBE, 0)
}

func (s *DescTableStatementContext) FILES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFILES, 0)
}

func (s *DescTableStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *DescTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DescTableStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, 0)
}

func (s *DescTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDescTableStatement(s)
	}
}

func (s *DescTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDescTableStatement(s)
	}
}

func (s *DescTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDescTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DescTableStatement() (localctx IDescTableStatementContext) {
	localctx = NewDescTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, DorisSQLParserParserRULE_descTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1931)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserDESC || _la == DorisSQLParserParserDESCRIBE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1938)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserACCESS, DorisSQLParserParserACTIVE, DorisSQLParserParserADMIN, DorisSQLParserParserADVISOR, DorisSQLParserParserAFTER, DorisSQLParserParserAGGREGATE, DorisSQLParserParserANTI, DorisSQLParserParserAPPLY, DorisSQLParserParserARRAY_AGG, DorisSQLParserParserARRAY_AGG_DISTINCT, DorisSQLParserParserASYNC, DorisSQLParserParserAUTHORS, DorisSQLParserParserAUTHENTICATION, DorisSQLParserParserAUTOMATED, DorisSQLParserParserAUTO_INCREMENT, DorisSQLParserParserAVG, DorisSQLParserParserBACKEND, DorisSQLParserParserBACKENDS, DorisSQLParserParserBACKUP, DorisSQLParserParserBASE, DorisSQLParserParserBASELINE, DorisSQLParserParserBEGIN, DorisSQLParserParserBINARY, DorisSQLParserParserBITMAP_UNION, DorisSQLParserParserBLACKHOLE, DorisSQLParserParserBLACKLIST, DorisSQLParserParserBODY, DorisSQLParserParserBOOLEAN, DorisSQLParserParserBRANCH, DorisSQLParserParserBROKER, DorisSQLParserParserBUCKETS, DorisSQLParserParserBUILTIN, DorisSQLParserParserCACHE, DorisSQLParserParserCANCEL, DorisSQLParserParserCAST, DorisSQLParserParserCATALOG, DorisSQLParserParserCATALOGS, DorisSQLParserParserCEIL, DorisSQLParserParserCHAIN, DorisSQLParserParserCHARSET, DorisSQLParserParserCLEAN, DorisSQLParserParserCLEAR, DorisSQLParserParserCLUSTER, DorisSQLParserParserCLUSTERS, DorisSQLParserParserCNGROUP, DorisSQLParserParserCNGROUPS, DorisSQLParserParserCOLLATION, DorisSQLParserParserCOLUMNS, DorisSQLParserParserCOMMENT, DorisSQLParserParserCOMMIT, DorisSQLParserParserCOMMITTED, DorisSQLParserParserCOMPACT, DorisSQLParserParserCOMPUTE, DorisSQLParserParserCONFIG, DorisSQLParserParserCONNECTION, DorisSQLParserParserCONSISTENT, DorisSQLParserParserCOSTS, DorisSQLParserParserCOUNT, DorisSQLParserParserCUME_DIST, DorisSQLParserParserCUMULATIVE, DorisSQLParserParserCURRENT, DorisSQLParserParserDATA, DorisSQLParserParserDATACACHE, DorisSQLParserParserDATE, DorisSQLParserParserDATETIME, DorisSQLParserParserDAY, DorisSQLParserParserDAYS, DorisSQLParserParserDEALLOCATE, DorisSQLParserParserDECOMMISSION, DorisSQLParserParserDIALECT, DorisSQLParserParserDICTIONARY, DorisSQLParserParserDICTIONARY_GET, DorisSQLParserParserDISABLE, DorisSQLParserParserDISTRIBUTED, DorisSQLParserParserDISTRIBUTION, DorisSQLParserParserDUPLICATE, DorisSQLParserParserDYNAMIC, DorisSQLParserParserENABLE, DorisSQLParserParserENCLOSE, DorisSQLParserParserEND, DorisSQLParserParserENGINE, DorisSQLParserParserENGINES, DorisSQLParserParserERRORS, DorisSQLParserParserESCAPE, DorisSQLParserParserEVENTS, DorisSQLParserParserEXCEPT, DorisSQLParserParserEXCLUDE, DorisSQLParserParserEXECUTE, DorisSQLParserParserEXPORT, DorisSQLParserParserEXTERNAL, DorisSQLParserParserEXTRACT, DorisSQLParserParserEVERY, DorisSQLParserParserFAILPOINT, DorisSQLParserParserFAILPOINTS, DorisSQLParserParserFIELDS, DorisSQLParserParserFILE, DorisSQLParserParserFILTER, DorisSQLParserParserFIRST, DorisSQLParserParserFLOOR, DorisSQLParserParserFN, DorisSQLParserParserFOLLOWING, DorisSQLParserParserFOLLOWER, DorisSQLParserParserFORMAT, DorisSQLParserParserFREE, DorisSQLParserParserFRONTEND, DorisSQLParserParserFRONTENDS, DorisSQLParserParserFUNCTIONS, DorisSQLParserParserGLOBAL, DorisSQLParserParserGRANTS, DorisSQLParserParserGROUP_CONCAT, DorisSQLParserParserHASH, DorisSQLParserParserHELP, DorisSQLParserParserHISTOGRAM, DorisSQLParserParserHLL_UNION, DorisSQLParserParserHOST, DorisSQLParserParserHOUR, DorisSQLParserParserHOURS, DorisSQLParserParserHUB, DorisSQLParserParserIDENTIFIED, DorisSQLParserParserIMPERSONATE, DorisSQLParserParserIMAGE, DorisSQLParserParserINACTIVE, DorisSQLParserParserINCREMENTAL, DorisSQLParserParserINDEXES, DorisSQLParserParserINSTALL, DorisSQLParserParserINTEGRATION, DorisSQLParserParserINTEGRATIONS, DorisSQLParserParserINTERMEDIATE, DorisSQLParserParserINTERVAL, DorisSQLParserParserOVERWRITE, DorisSQLParserParserISOLATION, DorisSQLParserParserJOB, DorisSQLParserParserLABEL, DorisSQLParserParserLAST, DorisSQLParserParserLESS, DorisSQLParserParserLEVEL, DorisSQLParserParserLIST, DorisSQLParserParserLOCAL, DorisSQLParserParserLOCATION, DorisSQLParserParserLOCATIONS, DorisSQLParserParserLOGS, DorisSQLParserParserLOGICAL, DorisSQLParserParserMANUAL, DorisSQLParserParserMAP, DorisSQLParserParserMAPPING, DorisSQLParserParserMAPPINGS, DorisSQLParserParserMASKING, DorisSQLParserParserMATCH, DorisSQLParserParserMATERIALIZED, DorisSQLParserParserMAX, DorisSQLParserParserMERGE, DorisSQLParserParserMIN, DorisSQLParserParserMINUTE, DorisSQLParserParserMINUTES, DorisSQLParserParserMINUS, DorisSQLParserParserMETA, DorisSQLParserParserMODE, DorisSQLParserParserMODIFY, DorisSQLParserParserMONTH, DorisSQLParserParserMULTIPLE, DorisSQLParserParserNAME, DorisSQLParserParserNAMES, DorisSQLParserParserNEGATIVE, DorisSQLParserParserNGRAMBF, DorisSQLParserParserNO, DorisSQLParserParserNODE, DorisSQLParserParserNODES, DorisSQLParserParserNONE, DorisSQLParserParserNULLS, DorisSQLParserParserNUMBER, DorisSQLParserParserNUMERIC, DorisSQLParserParserOBSERVER, DorisSQLParserParserOF, DorisSQLParserParserOFF, DorisSQLParserParserOFFSET, DorisSQLParserParserONLY, DorisSQLParserParserOPEN, DorisSQLParserParserOPERATE, DorisSQLParserParserOPTIMIZER, DorisSQLParserParserOPTION, DorisSQLParserParserPARTITIONS, DorisSQLParserParserPASSWORD, DorisSQLParserParserPATH, DorisSQLParserParserPAUSE, DorisSQLParserParserPENDING, DorisSQLParserParserPERCENT_RANK, DorisSQLParserParserPERCENTILE_UNION, DorisSQLParserParserPLAN, DorisSQLParserParserPLUGIN, DorisSQLParserParserPLUGINS, DorisSQLParserParserPIPE, DorisSQLParserParserPIPES, DorisSQLParserParserPIVOT, DorisSQLParserParserPOLICY, DorisSQLParserParserPOLICIES, DorisSQLParserParserPRECEDING, DorisSQLParserParserPREDICATE, DorisSQLParserParserPRIORITY, DorisSQLParserParserPRIVILEGES, DorisSQLParserParserPROBABILITY, DorisSQLParserParserPROC, DorisSQLParserParserPROCESSLIST, DorisSQLParserParserPROFILE, DorisSQLParserParserPROFILELIST, DorisSQLParserParserPROPERTIES, DorisSQLParserParserPROPERTY, DorisSQLParserParserPROVIDER, DorisSQLParserParserPROVIDERS, DorisSQLParserParserQUALIFY, DorisSQLParserParserQUARTER, DorisSQLParserParserQUERY, DorisSQLParserParserQUERIES, DorisSQLParserParserQUEUE, DorisSQLParserParserQUOTA, DorisSQLParserParserRANDOM, DorisSQLParserParserRANK, DorisSQLParserParserREASON, DorisSQLParserParserRECOVER, DorisSQLParserParserREFRESH, DorisSQLParserParserREWRITE, DorisSQLParserParserREMOVE, DorisSQLParserParserREPAIR, DorisSQLParserParserREPEATABLE, DorisSQLParserParserREPLACE_IF_NOT_NULL, DorisSQLParserParserREPLICA, DorisSQLParserParserREPOSITORY, DorisSQLParserParserREPOSITORIES, DorisSQLParserParserRESOURCE, DorisSQLParserParserRESOURCES, DorisSQLParserParserRESTORE, DorisSQLParserParserRESUME, DorisSQLParserParserRETAIN, DorisSQLParserParserRETENTION, DorisSQLParserParserRETURNS, DorisSQLParserParserRETRY, DorisSQLParserParserREVERT, DorisSQLParserParserROLE, DorisSQLParserParserROLES, DorisSQLParserParserROLLBACK, DorisSQLParserParserROLLUP, DorisSQLParserParserROUTINE, DorisSQLParserParserROW, DorisSQLParserParserRULE, DorisSQLParserParserRULES, DorisSQLParserParserRUNNING, DorisSQLParserParserSAMPLE, DorisSQLParserParserSCHEDULE, DorisSQLParserParserSCHEDULER, DorisSQLParserParserSECOND, DorisSQLParserParserSECURITY, DorisSQLParserParserSEMI, DorisSQLParserParserSEPARATOR, DorisSQLParserParserSERIALIZABLE, DorisSQLParserParserSESSION, DorisSQLParserParserSETS, DorisSQLParserParserSIGNED, DorisSQLParserParserSKIP_HEADER, DorisSQLParserParserSNAPSHOT, DorisSQLParserParserSNAPSHOTS, DorisSQLParserParserSQLBLACKLIST, DorisSQLParserParserSTART, DorisSQLParserParserSTATS, DorisSQLParserParserSTATUS, DorisSQLParserParserSTOP, DorisSQLParserParserSTORAGE, DorisSQLParserParserSTREAM, DorisSQLParserParserSTRING, DorisSQLParserParserSUBMIT, DorisSQLParserParserSUM, DorisSQLParserParserSUSPEND, DorisSQLParserParserSYNC, DorisSQLParserParserSYSTEM_TIME, DorisSQLParserParserSWAP, DorisSQLParserParserSTRUCT, DorisSQLParserParserTABLES, DorisSQLParserParserTABLET, DorisSQLParserParserTABLETS, DorisSQLParserParserTAG, DorisSQLParserParserTASK, DorisSQLParserParserTEMPORARY, DorisSQLParserParserTHAN, DorisSQLParserParserTIME, DorisSQLParserParserTIMES, DorisSQLParserParserTIMESTAMP, DorisSQLParserParserTIMESTAMPADD, DorisSQLParserParserTIMESTAMPDIFF, DorisSQLParserParserTRANSACTION, DorisSQLParserParserTRANSLATE, DorisSQLParserParserTRACE, DorisSQLParserParserTRIGGERS, DorisSQLParserParserTRIM_SPACE, DorisSQLParserParserTRUNCATE, DorisSQLParserParserTYPE, DorisSQLParserParserTYPES, DorisSQLParserParserUNBOUNDED, DorisSQLParserParserUNCOMMITTED, DorisSQLParserParserUNINSTALL, DorisSQLParserParserUNSET, DorisSQLParserParserUSAGE, DorisSQLParserParserUSER, DorisSQLParserParserUSERS, DorisSQLParserParserVALUE, DorisSQLParserParserVARBINARY, DorisSQLParserParserVARIABLES, DorisSQLParserParserVECTOR, DorisSQLParserParserVERBOSE, DorisSQLParserParserVERSION, DorisSQLParserParserVIEW, DorisSQLParserParserVIEWS, DorisSQLParserParserVOLUME, DorisSQLParserParserVOLUMES, DorisSQLParserParserWAREHOUSE, DorisSQLParserParserWAREHOUSES, DorisSQLParserParserWARNINGS, DorisSQLParserParserWEEK, DorisSQLParserParserWHITELIST, DorisSQLParserParserWORK, DorisSQLParserParserWRITE, DorisSQLParserParserYEAR, DorisSQLParserParserLOCK, DorisSQLParserParserUNLOCK, DorisSQLParserParserLOW_PRIORITY, DorisSQLParserParserDISK, DorisSQLParserParserBEFORE, DorisSQLParserParserFIELD, DorisSQLParserParserPERSISTENT, DorisSQLParserParserARRAY_ELEMENT, DorisSQLParserParserLETTER_IDENTIFIER, DorisSQLParserParserDIGIT_IDENTIFIER, DorisSQLParserParserBACKQUOTED_IDENTIFIER, DorisSQLParserParserDOTDOTDOT:
		{
			p.SetState(1932)

			var _x = p.QualifiedName()

			localctx.(*DescTableStatementContext).table = _x
		}
		p.SetState(1934)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserALL {
			{
				p.SetState(1933)
				p.Match(DorisSQLParserParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DorisSQLParserParserFILES:
		{
			p.SetState(1936)
			p.Match(DorisSQLParserParserFILES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1937)
			p.PropertyList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableLikeStatementContext is an interface to support dynamic dispatch.
type ICreateTableLikeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	LIKE() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	PartitionDesc() IPartitionDescContext
	DistributionDesc() IDistributionDescContext
	Properties() IPropertiesContext
	TEMPORARY() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode

	// IsCreateTableLikeStatementContext differentiates from other interfaces.
	IsCreateTableLikeStatementContext()
}

type CreateTableLikeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableLikeStatementContext() *CreateTableLikeStatementContext {
	var p = new(CreateTableLikeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createTableLikeStatement
	return p
}

func InitEmptyCreateTableLikeStatementContext(p *CreateTableLikeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createTableLikeStatement
}

func (*CreateTableLikeStatementContext) IsCreateTableLikeStatementContext() {}

func NewCreateTableLikeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableLikeStatementContext {
	var p = new(CreateTableLikeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createTableLikeStatement

	return p
}

func (s *CreateTableLikeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableLikeStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateTableLikeStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *CreateTableLikeStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableLikeStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateTableLikeStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *CreateTableLikeStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *CreateTableLikeStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *CreateTableLikeStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *CreateTableLikeStatementContext) PartitionDesc() IPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDescContext)
}

func (s *CreateTableLikeStatementContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *CreateTableLikeStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateTableLikeStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTEMPORARY, 0)
}

func (s *CreateTableLikeStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXTERNAL, 0)
}

func (s *CreateTableLikeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableLikeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableLikeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateTableLikeStatement(s)
	}
}

func (s *CreateTableLikeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateTableLikeStatement(s)
	}
}

func (s *CreateTableLikeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateTableLikeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateTableLikeStatement() (localctx ICreateTableLikeStatementContext) {
	localctx = NewCreateTableLikeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, DorisSQLParserParserRULE_createTableLikeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1940)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1942)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserEXTERNAL || _la == DorisSQLParserParserTEMPORARY {
		{
			p.SetState(1941)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserEXTERNAL || _la == DorisSQLParserParserTEMPORARY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1944)
		p.Match(DorisSQLParserParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1948)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(1945)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1946)
			p.Match(DorisSQLParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1947)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1950)
		p.QualifiedName()
	}
	p.SetState(1952)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPARTITION {
		{
			p.SetState(1951)
			p.PartitionDesc()
		}

	}
	p.SetState(1955)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserDISTRIBUTED {
		{
			p.SetState(1954)
			p.DistributionDesc()
		}

	}
	p.SetState(1958)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(1957)
			p.Properties()
		}

	}
	{
		p.SetState(1960)
		p.Match(DorisSQLParserParserLIKE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1961)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowIndexStatementContext is an interface to support dynamic dispatch.
type IShowIndexStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	INDEXES() antlr.TerminalNode
	KEY() antlr.TerminalNode
	KEYS() antlr.TerminalNode
	AllFROM() []antlr.TerminalNode
	FROM(i int) antlr.TerminalNode
	AllIN() []antlr.TerminalNode
	IN(i int) antlr.TerminalNode
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext

	// IsShowIndexStatementContext differentiates from other interfaces.
	IsShowIndexStatementContext()
}

type ShowIndexStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	table  IQualifiedNameContext
	db     IQualifiedNameContext
}

func NewEmptyShowIndexStatementContext() *ShowIndexStatementContext {
	var p = new(ShowIndexStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showIndexStatement
	return p
}

func InitEmptyShowIndexStatementContext(p *ShowIndexStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showIndexStatement
}

func (*ShowIndexStatementContext) IsShowIndexStatementContext() {}

func NewShowIndexStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowIndexStatementContext {
	var p = new(ShowIndexStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showIndexStatement

	return p
}

func (s *ShowIndexStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowIndexStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *ShowIndexStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowIndexStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *ShowIndexStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowIndexStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowIndexStatementContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINDEX, 0)
}

func (s *ShowIndexStatementContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINDEXES, 0)
}

func (s *ShowIndexStatementContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserKEY, 0)
}

func (s *ShowIndexStatementContext) KEYS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserKEYS, 0)
}

func (s *ShowIndexStatementContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserFROM)
}

func (s *ShowIndexStatementContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, i)
}

func (s *ShowIndexStatementContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserIN)
}

func (s *ShowIndexStatementContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, i)
}

func (s *ShowIndexStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *ShowIndexStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowIndexStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowIndexStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowIndexStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowIndexStatement(s)
	}
}

func (s *ShowIndexStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowIndexStatement(s)
	}
}

func (s *ShowIndexStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowIndexStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowIndexStatement() (localctx IShowIndexStatementContext) {
	localctx = NewShowIndexStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, DorisSQLParserParserRULE_showIndexStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1963)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1964)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-205)) & ^0x3f) == 0 && ((int64(1)<<(_la-205))&12582915) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	{
		p.SetState(1965)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1966)

		var _x = p.QualifiedName()

		localctx.(*ShowIndexStatementContext).table = _x
	}

	p.SetState(1970)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN {
		{
			p.SetState(1968)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1969)

			var _x = p.QualifiedName()

			localctx.(*ShowIndexStatementContext).db = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecoverTableStatementContext is an interface to support dynamic dispatch.
type IRecoverTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RECOVER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsRecoverTableStatementContext differentiates from other interfaces.
	IsRecoverTableStatementContext()
}

type RecoverTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecoverTableStatementContext() *RecoverTableStatementContext {
	var p = new(RecoverTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_recoverTableStatement
	return p
}

func InitEmptyRecoverTableStatementContext(p *RecoverTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_recoverTableStatement
}

func (*RecoverTableStatementContext) IsRecoverTableStatementContext() {}

func NewRecoverTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecoverTableStatementContext {
	var p = new(RecoverTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_recoverTableStatement

	return p
}

func (s *RecoverTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RecoverTableStatementContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRECOVER, 0)
}

func (s *RecoverTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *RecoverTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RecoverTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecoverTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecoverTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRecoverTableStatement(s)
	}
}

func (s *RecoverTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRecoverTableStatement(s)
	}
}

func (s *RecoverTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRecoverTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) RecoverTableStatement() (localctx IRecoverTableStatementContext) {
	localctx = NewRecoverTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, DorisSQLParserParserRULE_recoverTableStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1972)
		p.Match(DorisSQLParserParserRECOVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1973)
		p.Match(DorisSQLParserParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1974)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITruncateTableStatementContext is an interface to support dynamic dispatch.
type ITruncateTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUNCATE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext

	// IsTruncateTableStatementContext differentiates from other interfaces.
	IsTruncateTableStatementContext()
}

type TruncateTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncateTableStatementContext() *TruncateTableStatementContext {
	var p = new(TruncateTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_truncateTableStatement
	return p
}

func InitEmptyTruncateTableStatementContext(p *TruncateTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_truncateTableStatement
}

func (*TruncateTableStatementContext) IsTruncateTableStatementContext() {}

func NewTruncateTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncateTableStatementContext {
	var p = new(TruncateTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_truncateTableStatement

	return p
}

func (s *TruncateTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncateTableStatementContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTRUNCATE, 0)
}

func (s *TruncateTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *TruncateTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TruncateTableStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *TruncateTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncateTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TruncateTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTruncateTableStatement(s)
	}
}

func (s *TruncateTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTruncateTableStatement(s)
	}
}

func (s *TruncateTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTruncateTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) TruncateTableStatement() (localctx ITruncateTableStatementContext) {
	localctx = NewTruncateTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, DorisSQLParserParserRULE_truncateTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1976)
		p.Match(DorisSQLParserParserTRUNCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1977)
		p.Match(DorisSQLParserParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1978)
		p.QualifiedName()
	}
	p.SetState(1980)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPARTITION || _la == DorisSQLParserParserPARTITIONS || _la == DorisSQLParserParserTEMPORARY {
		{
			p.SetState(1979)
			p.PartitionNames()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelAlterTableStatementContext is an interface to support dynamic dispatch.
type ICancelAlterTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	OPTIMIZE() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode

	// IsCancelAlterTableStatementContext differentiates from other interfaces.
	IsCancelAlterTableStatementContext()
}

type CancelAlterTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelAlterTableStatementContext() *CancelAlterTableStatementContext {
	var p = new(CancelAlterTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cancelAlterTableStatement
	return p
}

func InitEmptyCancelAlterTableStatementContext(p *CancelAlterTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cancelAlterTableStatement
}

func (*CancelAlterTableStatementContext) IsCancelAlterTableStatementContext() {}

func NewCancelAlterTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelAlterTableStatementContext {
	var p = new(CancelAlterTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_cancelAlterTableStatement

	return p
}

func (s *CancelAlterTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelAlterTableStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCANCEL, 0)
}

func (s *CancelAlterTableStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *CancelAlterTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *CancelAlterTableStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *CancelAlterTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CancelAlterTableStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserINTEGER_VALUE)
}

func (s *CancelAlterTableStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, i)
}

func (s *CancelAlterTableStatementContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLUMN, 0)
}

func (s *CancelAlterTableStatementContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROLLUP, 0)
}

func (s *CancelAlterTableStatementContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOPTIMIZE, 0)
}

func (s *CancelAlterTableStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMATERIALIZED, 0)
}

func (s *CancelAlterTableStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVIEW, 0)
}

func (s *CancelAlterTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelAlterTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelAlterTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCancelAlterTableStatement(s)
	}
}

func (s *CancelAlterTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCancelAlterTableStatement(s)
	}
}

func (s *CancelAlterTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCancelAlterTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CancelAlterTableStatement() (localctx ICancelAlterTableStatementContext) {
	localctx = NewCancelAlterTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, DorisSQLParserParserRULE_cancelAlterTableStatement)
	var _la int

	p.SetState(2008)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1982)
			p.Match(DorisSQLParserParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1983)
			p.Match(DorisSQLParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1984)
			p.Match(DorisSQLParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1986)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserCOLUMN || _la == DorisSQLParserParserOPTIMIZE || _la == DorisSQLParserParserROLLUP {
			{
				p.SetState(1985)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserParserCOLUMN || _la == DorisSQLParserParserOPTIMIZE || _la == DorisSQLParserParserROLLUP) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1988)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1989)
			p.QualifiedName()
		}
		p.SetState(2000)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__1 {
			{
				p.SetState(1990)
				p.Match(DorisSQLParserParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1991)
				p.Match(DorisSQLParserParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1996)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(1992)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1993)
					p.Match(DorisSQLParserParserINTEGER_VALUE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1998)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1999)
				p.Match(DorisSQLParserParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2002)
			p.Match(DorisSQLParserParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2003)
			p.Match(DorisSQLParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2004)
			p.Match(DorisSQLParserParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2005)
			p.Match(DorisSQLParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2006)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2007)
			p.QualifiedName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowPartitionsStatementContext is an interface to support dynamic dispatch.
type IShowPartitionsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	TEMPORARY() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext

	// IsShowPartitionsStatementContext differentiates from other interfaces.
	IsShowPartitionsStatementContext()
}

type ShowPartitionsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	table  IQualifiedNameContext
}

func NewEmptyShowPartitionsStatementContext() *ShowPartitionsStatementContext {
	var p = new(ShowPartitionsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showPartitionsStatement
	return p
}

func InitEmptyShowPartitionsStatementContext(p *ShowPartitionsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showPartitionsStatement
}

func (*ShowPartitionsStatementContext) IsShowPartitionsStatementContext() {}

func NewShowPartitionsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowPartitionsStatementContext {
	var p = new(ShowPartitionsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showPartitionsStatement

	return p
}

func (s *ShowPartitionsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowPartitionsStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *ShowPartitionsStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *ShowPartitionsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowPartitionsStatementContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPARTITIONS, 0)
}

func (s *ShowPartitionsStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowPartitionsStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowPartitionsStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTEMPORARY, 0)
}

func (s *ShowPartitionsStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowPartitionsStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowPartitionsStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserORDER, 0)
}

func (s *ShowPartitionsStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *ShowPartitionsStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowPartitionsStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowPartitionsStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowPartitionsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPartitionsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowPartitionsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowPartitionsStatement(s)
	}
}

func (s *ShowPartitionsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowPartitionsStatement(s)
	}
}

func (s *ShowPartitionsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowPartitionsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowPartitionsStatement() (localctx IShowPartitionsStatementContext) {
	localctx = NewShowPartitionsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, DorisSQLParserParserRULE_showPartitionsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2010)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2012)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserTEMPORARY {
		{
			p.SetState(2011)
			p.Match(DorisSQLParserParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2014)
		p.Match(DorisSQLParserParserPARTITIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2015)
		p.Match(DorisSQLParserParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2016)

		var _x = p.QualifiedName()

		localctx.(*ShowPartitionsStatementContext).table = _x
	}
	p.SetState(2019)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWHERE {
		{
			p.SetState(2017)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2018)
			p.expression(0)
		}

	}
	p.SetState(2031)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserORDER {
		{
			p.SetState(2021)
			p.Match(DorisSQLParserParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2022)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2023)
			p.SortItem()
		}
		p.SetState(2028)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(2024)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2025)
				p.SortItem()
			}

			p.SetState(2030)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(2034)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserLIMIT {
		{
			p.SetState(2033)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecoverPartitionStatementContext is an interface to support dynamic dispatch.
type IRecoverPartitionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// Getter signatures
	RECOVER() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsRecoverPartitionStatementContext differentiates from other interfaces.
	IsRecoverPartitionStatementContext()
}

type RecoverPartitionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	table  IQualifiedNameContext
}

func NewEmptyRecoverPartitionStatementContext() *RecoverPartitionStatementContext {
	var p = new(RecoverPartitionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_recoverPartitionStatement
	return p
}

func InitEmptyRecoverPartitionStatementContext(p *RecoverPartitionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_recoverPartitionStatement
}

func (*RecoverPartitionStatementContext) IsRecoverPartitionStatementContext() {}

func NewRecoverPartitionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecoverPartitionStatementContext {
	var p = new(RecoverPartitionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_recoverPartitionStatement

	return p
}

func (s *RecoverPartitionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RecoverPartitionStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *RecoverPartitionStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *RecoverPartitionStatementContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRECOVER, 0)
}

func (s *RecoverPartitionStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPARTITION, 0)
}

func (s *RecoverPartitionStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RecoverPartitionStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *RecoverPartitionStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RecoverPartitionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecoverPartitionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecoverPartitionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRecoverPartitionStatement(s)
	}
}

func (s *RecoverPartitionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRecoverPartitionStatement(s)
	}
}

func (s *RecoverPartitionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRecoverPartitionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) RecoverPartitionStatement() (localctx IRecoverPartitionStatementContext) {
	localctx = NewRecoverPartitionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, DorisSQLParserParserRULE_recoverPartitionStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2036)
		p.Match(DorisSQLParserParserRECOVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2037)
		p.Match(DorisSQLParserParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2038)
		p.Identifier()
	}
	{
		p.SetState(2039)
		p.Match(DorisSQLParserParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2040)

		var _x = p.QualifiedName()

		localctx.(*RecoverPartitionStatementContext).table = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateViewStatementContext is an interface to support dynamic dispatch.
type ICreateViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AS() antlr.TerminalNode
	QueryStatement() IQueryStatementContext
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AllColumnNameWithComment() []IColumnNameWithCommentContext
	ColumnNameWithComment(i int) IColumnNameWithCommentContext
	Comment() ICommentContext
	SECURITY() antlr.TerminalNode
	NONE() antlr.TerminalNode
	INVOKER() antlr.TerminalNode

	// IsCreateViewStatementContext differentiates from other interfaces.
	IsCreateViewStatementContext()
}

type CreateViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateViewStatementContext() *CreateViewStatementContext {
	var p = new(CreateViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createViewStatement
	return p
}

func InitEmptyCreateViewStatementContext(p *CreateViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createViewStatement
}

func (*CreateViewStatementContext) IsCreateViewStatementContext() {}

func NewCreateViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateViewStatementContext {
	var p = new(CreateViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createViewStatement

	return p
}

func (s *CreateViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateViewStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVIEW, 0)
}

func (s *CreateViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateViewStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *CreateViewStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *CreateViewStatementContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOR, 0)
}

func (s *CreateViewStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPLACE, 0)
}

func (s *CreateViewStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *CreateViewStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *CreateViewStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *CreateViewStatementContext) AllColumnNameWithComment() []IColumnNameWithCommentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameWithCommentContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameWithCommentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameWithCommentContext); ok {
			tst[i] = t.(IColumnNameWithCommentContext)
			i++
		}
	}

	return tst
}

func (s *CreateViewStatementContext) ColumnNameWithComment(i int) IColumnNameWithCommentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameWithCommentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameWithCommentContext)
}

func (s *CreateViewStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateViewStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSECURITY, 0)
}

func (s *CreateViewStatementContext) NONE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNONE, 0)
}

func (s *CreateViewStatementContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINVOKER, 0)
}

func (s *CreateViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateViewStatement(s)
	}
}

func (s *CreateViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateViewStatement(s)
	}
}

func (s *CreateViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateViewStatement() (localctx ICreateViewStatementContext) {
	localctx = NewCreateViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, DorisSQLParserParserRULE_createViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2042)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2045)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserOR {
		{
			p.SetState(2043)
			p.Match(DorisSQLParserParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2044)
			p.Match(DorisSQLParserParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2047)
		p.Match(DorisSQLParserParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2051)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(2048)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2049)
			p.Match(DorisSQLParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2050)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2053)
		p.QualifiedName()
	}
	p.SetState(2065)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserT__1 {
		{
			p.SetState(2054)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2055)
			p.ColumnNameWithComment()
		}
		p.SetState(2060)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(2056)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2057)
				p.ColumnNameWithComment()
			}

			p.SetState(2062)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2063)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2068)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserCOMMENT {
		{
			p.SetState(2067)
			p.Comment()
		}

	}
	p.SetState(2072)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserSECURITY {
		{
			p.SetState(2070)
			p.Match(DorisSQLParserParserSECURITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2071)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserINVOKER || _la == DorisSQLParserParserNONE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(2074)
		p.Match(DorisSQLParserParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2075)
		p.QueryStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterViewStatementContext is an interface to support dynamic dispatch.
type IAlterViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AS() antlr.TerminalNode
	QueryStatement() IQueryStatementContext
	AllColumnNameWithComment() []IColumnNameWithCommentContext
	ColumnNameWithComment(i int) IColumnNameWithCommentContext
	SET() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	NONE() antlr.TerminalNode
	INVOKER() antlr.TerminalNode
	Properties() IPropertiesContext
	DIALECT() antlr.TerminalNode
	ADD() antlr.TerminalNode
	MODIFY() antlr.TerminalNode

	// IsAlterViewStatementContext differentiates from other interfaces.
	IsAlterViewStatementContext()
}

type AlterViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterViewStatementContext() *AlterViewStatementContext {
	var p = new(AlterViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterViewStatement
	return p
}

func InitEmptyAlterViewStatementContext(p *AlterViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterViewStatement
}

func (*AlterViewStatementContext) IsAlterViewStatementContext() {}

func NewAlterViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterViewStatementContext {
	var p = new(AlterViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_alterViewStatement

	return p
}

func (s *AlterViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterViewStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *AlterViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVIEW, 0)
}

func (s *AlterViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterViewStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *AlterViewStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *AlterViewStatementContext) AllColumnNameWithComment() []IColumnNameWithCommentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameWithCommentContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameWithCommentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameWithCommentContext); ok {
			tst[i] = t.(IColumnNameWithCommentContext)
			i++
		}
	}

	return tst
}

func (s *AlterViewStatementContext) ColumnNameWithComment(i int) IColumnNameWithCommentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameWithCommentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameWithCommentContext)
}

func (s *AlterViewStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *AlterViewStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSECURITY, 0)
}

func (s *AlterViewStatementContext) NONE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNONE, 0)
}

func (s *AlterViewStatementContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINVOKER, 0)
}

func (s *AlterViewStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AlterViewStatementContext) DIALECT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDIALECT, 0)
}

func (s *AlterViewStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADD, 0)
}

func (s *AlterViewStatementContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMODIFY, 0)
}

func (s *AlterViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAlterViewStatement(s)
	}
}

func (s *AlterViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAlterViewStatement(s)
	}
}

func (s *AlterViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAlterViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AlterViewStatement() (localctx IAlterViewStatementContext) {
	localctx = NewAlterViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, DorisSQLParserParserRULE_alterViewStatement)
	var _la int

	p.SetState(2116)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 132, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2077)
			p.Match(DorisSQLParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2078)
			p.Match(DorisSQLParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2079)
			p.QualifiedName()
		}
		p.SetState(2091)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__1 {
			{
				p.SetState(2080)
				p.Match(DorisSQLParserParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2081)
				p.ColumnNameWithComment()
			}
			p.SetState(2086)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(2082)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2083)
					p.ColumnNameWithComment()
				}

				p.SetState(2088)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2089)
				p.Match(DorisSQLParserParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2093)
			p.Match(DorisSQLParserParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2094)
			p.QueryStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2096)
			p.Match(DorisSQLParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2097)
			p.Match(DorisSQLParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2098)
			p.QualifiedName()
		}
		{
			p.SetState(2099)
			p.Match(DorisSQLParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2100)
			p.Match(DorisSQLParserParserSECURITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2101)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserINVOKER || _la == DorisSQLParserParserNONE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2103)
			p.Match(DorisSQLParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2104)
			p.Match(DorisSQLParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2105)
			p.QualifiedName()
		}
		{
			p.SetState(2106)
			p.Match(DorisSQLParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2107)
			p.Properties()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2109)
			p.Match(DorisSQLParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2110)
			p.Match(DorisSQLParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2111)
			p.QualifiedName()
		}
		{
			p.SetState(2112)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserADD || _la == DorisSQLParserParserMODIFY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2113)
			p.Match(DorisSQLParserParserDIALECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2114)
			p.QueryStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropViewStatementContext is an interface to support dynamic dispatch.
type IDropViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropViewStatementContext differentiates from other interfaces.
	IsDropViewStatementContext()
}

type DropViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropViewStatementContext() *DropViewStatementContext {
	var p = new(DropViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropViewStatement
	return p
}

func InitEmptyDropViewStatementContext(p *DropViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropViewStatement
}

func (*DropViewStatementContext) IsDropViewStatementContext() {}

func NewDropViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropViewStatementContext {
	var p = new(DropViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropViewStatement

	return p
}

func (s *DropViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropViewStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVIEW, 0)
}

func (s *DropViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropViewStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *DropViewStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *DropViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropViewStatement(s)
	}
}

func (s *DropViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropViewStatement(s)
	}
}

func (s *DropViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropViewStatement() (localctx IDropViewStatementContext) {
	localctx = NewDropViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, DorisSQLParserParserRULE_dropViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2118)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2119)
		p.Match(DorisSQLParserParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2122)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(2120)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2121)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2124)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnNameWithCommentContext is an interface to support dynamic dispatch.
type IColumnNameWithCommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetColumnName returns the columnName rule contexts.
	GetColumnName() IIdentifierContext

	// SetColumnName sets the columnName rule contexts.
	SetColumnName(IIdentifierContext)

	// Getter signatures
	Identifier() IIdentifierContext
	Comment() ICommentContext

	// IsColumnNameWithCommentContext differentiates from other interfaces.
	IsColumnNameWithCommentContext()
}

type ColumnNameWithCommentContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	columnName IIdentifierContext
}

func NewEmptyColumnNameWithCommentContext() *ColumnNameWithCommentContext {
	var p = new(ColumnNameWithCommentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_columnNameWithComment
	return p
}

func InitEmptyColumnNameWithCommentContext(p *ColumnNameWithCommentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_columnNameWithComment
}

func (*ColumnNameWithCommentContext) IsColumnNameWithCommentContext() {}

func NewColumnNameWithCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameWithCommentContext {
	var p = new(ColumnNameWithCommentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_columnNameWithComment

	return p
}

func (s *ColumnNameWithCommentContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameWithCommentContext) GetColumnName() IIdentifierContext { return s.columnName }

func (s *ColumnNameWithCommentContext) SetColumnName(v IIdentifierContext) { s.columnName = v }

func (s *ColumnNameWithCommentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnNameWithCommentContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *ColumnNameWithCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameWithCommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNameWithCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterColumnNameWithComment(s)
	}
}

func (s *ColumnNameWithCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitColumnNameWithComment(s)
	}
}

func (s *ColumnNameWithCommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitColumnNameWithComment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ColumnNameWithComment() (localctx IColumnNameWithCommentContext) {
	localctx = NewColumnNameWithCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, DorisSQLParserParserRULE_columnNameWithComment)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2126)

		var _x = p.Identifier()

		localctx.(*ColumnNameWithCommentContext).columnName = _x
	}
	p.SetState(2128)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserCOMMENT {
		{
			p.SetState(2127)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubmitTaskStatementContext is an interface to support dynamic dispatch.
type ISubmitTaskStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBMIT() antlr.TerminalNode
	TASK() antlr.TerminalNode
	AS() antlr.TerminalNode
	CreateTableAsSelectStatement() ICreateTableAsSelectStatementContext
	InsertStatement() IInsertStatementContext
	DataCacheSelectStatement() IDataCacheSelectStatementContext
	QualifiedName() IQualifiedNameContext
	AllTaskClause() []ITaskClauseContext
	TaskClause(i int) ITaskClauseContext

	// IsSubmitTaskStatementContext differentiates from other interfaces.
	IsSubmitTaskStatementContext()
}

type SubmitTaskStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubmitTaskStatementContext() *SubmitTaskStatementContext {
	var p = new(SubmitTaskStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_submitTaskStatement
	return p
}

func InitEmptySubmitTaskStatementContext(p *SubmitTaskStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_submitTaskStatement
}

func (*SubmitTaskStatementContext) IsSubmitTaskStatementContext() {}

func NewSubmitTaskStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubmitTaskStatementContext {
	var p = new(SubmitTaskStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_submitTaskStatement

	return p
}

func (s *SubmitTaskStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SubmitTaskStatementContext) SUBMIT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSUBMIT, 0)
}

func (s *SubmitTaskStatementContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTASK, 0)
}

func (s *SubmitTaskStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *SubmitTaskStatementContext) CreateTableAsSelectStatement() ICreateTableAsSelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableAsSelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableAsSelectStatementContext)
}

func (s *SubmitTaskStatementContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *SubmitTaskStatementContext) DataCacheSelectStatement() IDataCacheSelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataCacheSelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataCacheSelectStatementContext)
}

func (s *SubmitTaskStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SubmitTaskStatementContext) AllTaskClause() []ITaskClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITaskClauseContext); ok {
			len++
		}
	}

	tst := make([]ITaskClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITaskClauseContext); ok {
			tst[i] = t.(ITaskClauseContext)
			i++
		}
	}

	return tst
}

func (s *SubmitTaskStatementContext) TaskClause(i int) ITaskClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITaskClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITaskClauseContext)
}

func (s *SubmitTaskStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubmitTaskStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubmitTaskStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSubmitTaskStatement(s)
	}
}

func (s *SubmitTaskStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSubmitTaskStatement(s)
	}
}

func (s *SubmitTaskStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSubmitTaskStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SubmitTaskStatement() (localctx ISubmitTaskStatementContext) {
	localctx = NewSubmitTaskStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, DorisSQLParserParserRULE_submitTaskStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2130)
		p.Match(DorisSQLParserParserSUBMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2131)
		p.Match(DorisSQLParserParserTASK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2133)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2132)
			p.QualifiedName()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2138)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserPROPERTIES || _la == DorisSQLParserParserSCHEDULE {
		{
			p.SetState(2135)
			p.TaskClause()
		}

		p.SetState(2140)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2141)
		p.Match(DorisSQLParserParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2145)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserCREATE:
		{
			p.SetState(2142)
			p.CreateTableAsSelectStatement()
		}

	case DorisSQLParserParserDESC, DorisSQLParserParserDESCRIBE, DorisSQLParserParserEXPLAIN, DorisSQLParserParserINSERT:
		{
			p.SetState(2143)
			p.InsertStatement()
		}

	case DorisSQLParserParserCACHE:
		{
			p.SetState(2144)
			p.DataCacheSelectStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITaskClauseContext is an interface to support dynamic dispatch.
type ITaskClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Properties() IPropertiesContext
	TaskScheduleDesc() ITaskScheduleDescContext

	// IsTaskClauseContext differentiates from other interfaces.
	IsTaskClauseContext()
}

type TaskClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTaskClauseContext() *TaskClauseContext {
	var p = new(TaskClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_taskClause
	return p
}

func InitEmptyTaskClauseContext(p *TaskClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_taskClause
}

func (*TaskClauseContext) IsTaskClauseContext() {}

func NewTaskClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TaskClauseContext {
	var p = new(TaskClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_taskClause

	return p
}

func (s *TaskClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TaskClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *TaskClauseContext) TaskScheduleDesc() ITaskScheduleDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITaskScheduleDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITaskScheduleDescContext)
}

func (s *TaskClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TaskClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TaskClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTaskClause(s)
	}
}

func (s *TaskClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTaskClause(s)
	}
}

func (s *TaskClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTaskClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) TaskClause() (localctx ITaskClauseContext) {
	localctx = NewTaskClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, DorisSQLParserParserRULE_taskClause)
	p.SetState(2149)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserPROPERTIES:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2147)
			p.Properties()
		}

	case DorisSQLParserParserSCHEDULE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2148)
			p.TaskScheduleDesc()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTaskStatementContext is an interface to support dynamic dispatch.
type IDropTaskStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TASK() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	FORCE() antlr.TerminalNode

	// IsDropTaskStatementContext differentiates from other interfaces.
	IsDropTaskStatementContext()
}

type DropTaskStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTaskStatementContext() *DropTaskStatementContext {
	var p = new(DropTaskStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropTaskStatement
	return p
}

func InitEmptyDropTaskStatementContext(p *DropTaskStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropTaskStatement
}

func (*DropTaskStatementContext) IsDropTaskStatementContext() {}

func NewDropTaskStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTaskStatementContext {
	var p = new(DropTaskStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropTaskStatement

	return p
}

func (s *DropTaskStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTaskStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropTaskStatementContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTASK, 0)
}

func (s *DropTaskStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropTaskStatementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFORCE, 0)
}

func (s *DropTaskStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTaskStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTaskStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropTaskStatement(s)
	}
}

func (s *DropTaskStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropTaskStatement(s)
	}
}

func (s *DropTaskStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropTaskStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropTaskStatement() (localctx IDropTaskStatementContext) {
	localctx = NewDropTaskStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, DorisSQLParserParserRULE_dropTaskStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2151)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2152)
		p.Match(DorisSQLParserParserTASK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2153)
		p.QualifiedName()
	}
	p.SetState(2155)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFORCE {
		{
			p.SetState(2154)
			p.Match(DorisSQLParserParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITaskScheduleDescContext is an interface to support dynamic dispatch.
type ITaskScheduleDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SCHEDULE() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	TaskInterval() ITaskIntervalContext
	START() antlr.TerminalNode
	String_() IStringContext

	// IsTaskScheduleDescContext differentiates from other interfaces.
	IsTaskScheduleDescContext()
}

type TaskScheduleDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTaskScheduleDescContext() *TaskScheduleDescContext {
	var p = new(TaskScheduleDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_taskScheduleDesc
	return p
}

func InitEmptyTaskScheduleDescContext(p *TaskScheduleDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_taskScheduleDesc
}

func (*TaskScheduleDescContext) IsTaskScheduleDescContext() {}

func NewTaskScheduleDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TaskScheduleDescContext {
	var p = new(TaskScheduleDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_taskScheduleDesc

	return p
}

func (s *TaskScheduleDescContext) GetParser() antlr.Parser { return s.parser }

func (s *TaskScheduleDescContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSCHEDULE, 0)
}

func (s *TaskScheduleDescContext) EVERY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEVERY, 0)
}

func (s *TaskScheduleDescContext) TaskInterval() ITaskIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITaskIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITaskIntervalContext)
}

func (s *TaskScheduleDescContext) START() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTART, 0)
}

func (s *TaskScheduleDescContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *TaskScheduleDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TaskScheduleDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TaskScheduleDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTaskScheduleDesc(s)
	}
}

func (s *TaskScheduleDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTaskScheduleDesc(s)
	}
}

func (s *TaskScheduleDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTaskScheduleDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) TaskScheduleDesc() (localctx ITaskScheduleDescContext) {
	localctx = NewTaskScheduleDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, DorisSQLParserParserRULE_taskScheduleDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2157)
		p.Match(DorisSQLParserParserSCHEDULE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2163)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserSTART {
		{
			p.SetState(2158)
			p.Match(DorisSQLParserParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2159)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2160)
			p.String_()
		}
		{
			p.SetState(2161)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2165)
		p.Match(DorisSQLParserParserEVERY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2166)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2167)
		p.TaskInterval()
	}
	{
		p.SetState(2168)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateMaterializedViewStatementContext is an interface to support dynamic dispatch.
type ICreateMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMvName returns the mvName rule contexts.
	GetMvName() IQualifiedNameContext

	// SetMvName sets the mvName rule contexts.
	SetMvName(IQualifiedNameContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	AS() antlr.TerminalNode
	QueryStatement() IQueryStatementContext
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AllColumnNameWithComment() []IColumnNameWithCommentContext
	ColumnNameWithComment(i int) IColumnNameWithCommentContext
	Comment() ICommentContext
	AllMaterializedViewDesc() []IMaterializedViewDescContext
	MaterializedViewDesc(i int) IMaterializedViewDescContext
	AllIndexDesc() []IIndexDescContext
	IndexDesc(i int) IIndexDescContext

	// IsCreateMaterializedViewStatementContext differentiates from other interfaces.
	IsCreateMaterializedViewStatementContext()
}

type CreateMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	mvName IQualifiedNameContext
}

func NewEmptyCreateMaterializedViewStatementContext() *CreateMaterializedViewStatementContext {
	var p = new(CreateMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createMaterializedViewStatement
	return p
}

func InitEmptyCreateMaterializedViewStatementContext(p *CreateMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createMaterializedViewStatement
}

func (*CreateMaterializedViewStatementContext) IsCreateMaterializedViewStatementContext() {}

func NewCreateMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateMaterializedViewStatementContext {
	var p = new(CreateMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createMaterializedViewStatement

	return p
}

func (s *CreateMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateMaterializedViewStatementContext) GetMvName() IQualifiedNameContext { return s.mvName }

func (s *CreateMaterializedViewStatementContext) SetMvName(v IQualifiedNameContext) { s.mvName = v }

func (s *CreateMaterializedViewStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateMaterializedViewStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMATERIALIZED, 0)
}

func (s *CreateMaterializedViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVIEW, 0)
}

func (s *CreateMaterializedViewStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *CreateMaterializedViewStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *CreateMaterializedViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateMaterializedViewStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *CreateMaterializedViewStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *CreateMaterializedViewStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *CreateMaterializedViewStatementContext) AllColumnNameWithComment() []IColumnNameWithCommentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameWithCommentContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameWithCommentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameWithCommentContext); ok {
			tst[i] = t.(IColumnNameWithCommentContext)
			i++
		}
	}

	return tst
}

func (s *CreateMaterializedViewStatementContext) ColumnNameWithComment(i int) IColumnNameWithCommentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameWithCommentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameWithCommentContext)
}

func (s *CreateMaterializedViewStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateMaterializedViewStatementContext) AllMaterializedViewDesc() []IMaterializedViewDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMaterializedViewDescContext); ok {
			len++
		}
	}

	tst := make([]IMaterializedViewDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMaterializedViewDescContext); ok {
			tst[i] = t.(IMaterializedViewDescContext)
			i++
		}
	}

	return tst
}

func (s *CreateMaterializedViewStatementContext) MaterializedViewDesc(i int) IMaterializedViewDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaterializedViewDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaterializedViewDescContext)
}

func (s *CreateMaterializedViewStatementContext) AllIndexDesc() []IIndexDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexDescContext); ok {
			len++
		}
	}

	tst := make([]IIndexDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexDescContext); ok {
			tst[i] = t.(IIndexDescContext)
			i++
		}
	}

	return tst
}

func (s *CreateMaterializedViewStatementContext) IndexDesc(i int) IIndexDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexDescContext)
}

func (s *CreateMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateMaterializedViewStatement(s)
	}
}

func (s *CreateMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateMaterializedViewStatement(s)
	}
}

func (s *CreateMaterializedViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateMaterializedViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateMaterializedViewStatement() (localctx ICreateMaterializedViewStatementContext) {
	localctx = NewCreateMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, DorisSQLParserParserRULE_createMaterializedViewStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2170)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2171)
		p.Match(DorisSQLParserParserMATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2172)
		p.Match(DorisSQLParserParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2176)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(2173)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2174)
			p.Match(DorisSQLParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2175)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2178)

		var _x = p.QualifiedName()

		localctx.(*CreateMaterializedViewStatementContext).mvName = _x
	}
	p.SetState(2197)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserT__1 {
		{
			p.SetState(2179)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2180)
			p.ColumnNameWithComment()
		}
		p.SetState(2185)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2181)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2182)
					p.ColumnNameWithComment()
				}

			}
			p.SetState(2187)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(2192)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(2188)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2189)
				p.IndexDesc()
			}

			p.SetState(2194)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2195)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2200)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserCOMMENT {
		{
			p.SetState(2199)
			p.Comment()
		}

	}
	p.SetState(2205)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserDISTRIBUTED || ((int64((_la-298)) & ^0x3f) == 0 && ((int64(1)<<(_la-298))&1125917086711841) != 0) {
		{
			p.SetState(2202)
			p.MaterializedViewDesc()
		}

		p.SetState(2207)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2208)
		p.Match(DorisSQLParserParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2209)
		p.QueryStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMvPartitionExprsContext is an interface to support dynamic dispatch.
type IMvPartitionExprsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrimaryExpression() []IPrimaryExpressionContext
	PrimaryExpression(i int) IPrimaryExpressionContext

	// IsMvPartitionExprsContext differentiates from other interfaces.
	IsMvPartitionExprsContext()
}

type MvPartitionExprsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMvPartitionExprsContext() *MvPartitionExprsContext {
	var p = new(MvPartitionExprsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_mvPartitionExprs
	return p
}

func InitEmptyMvPartitionExprsContext(p *MvPartitionExprsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_mvPartitionExprs
}

func (*MvPartitionExprsContext) IsMvPartitionExprsContext() {}

func NewMvPartitionExprsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MvPartitionExprsContext {
	var p = new(MvPartitionExprsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_mvPartitionExprs

	return p
}

func (s *MvPartitionExprsContext) GetParser() antlr.Parser { return s.parser }

func (s *MvPartitionExprsContext) AllPrimaryExpression() []IPrimaryExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrimaryExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrimaryExpressionContext); ok {
			tst[i] = t.(IPrimaryExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MvPartitionExprsContext) PrimaryExpression(i int) IPrimaryExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *MvPartitionExprsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MvPartitionExprsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MvPartitionExprsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterMvPartitionExprs(s)
	}
}

func (s *MvPartitionExprsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitMvPartitionExprs(s)
	}
}

func (s *MvPartitionExprsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitMvPartitionExprs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) MvPartitionExprs() (localctx IMvPartitionExprsContext) {
	localctx = NewMvPartitionExprsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, DorisSQLParserParserRULE_mvPartitionExprs)
	var _la int

	p.SetState(2223)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2211)
			p.primaryExpression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2212)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2213)
			p.primaryExpression(0)
		}
		p.SetState(2218)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(2214)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2215)
				p.primaryExpression(0)
			}

			p.SetState(2220)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2221)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaterializedViewDescContext is an interface to support dynamic dispatch.
type IMaterializedViewDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	MvPartitionExprs() IMvPartitionExprsContext
	DistributionDesc() IDistributionDescContext
	OrderByDesc() IOrderByDescContext
	RefreshSchemeDesc() IRefreshSchemeDescContext
	Properties() IPropertiesContext

	// IsMaterializedViewDescContext differentiates from other interfaces.
	IsMaterializedViewDescContext()
}

type MaterializedViewDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaterializedViewDescContext() *MaterializedViewDescContext {
	var p = new(MaterializedViewDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_materializedViewDesc
	return p
}

func InitEmptyMaterializedViewDescContext(p *MaterializedViewDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_materializedViewDesc
}

func (*MaterializedViewDescContext) IsMaterializedViewDescContext() {}

func NewMaterializedViewDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaterializedViewDescContext {
	var p = new(MaterializedViewDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_materializedViewDesc

	return p
}

func (s *MaterializedViewDescContext) GetParser() antlr.Parser { return s.parser }

func (s *MaterializedViewDescContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPARTITION, 0)
}

func (s *MaterializedViewDescContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *MaterializedViewDescContext) MvPartitionExprs() IMvPartitionExprsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMvPartitionExprsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMvPartitionExprsContext)
}

func (s *MaterializedViewDescContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *MaterializedViewDescContext) OrderByDesc() IOrderByDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByDescContext)
}

func (s *MaterializedViewDescContext) RefreshSchemeDesc() IRefreshSchemeDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshSchemeDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshSchemeDescContext)
}

func (s *MaterializedViewDescContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *MaterializedViewDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaterializedViewDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaterializedViewDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterMaterializedViewDesc(s)
	}
}

func (s *MaterializedViewDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitMaterializedViewDesc(s)
	}
}

func (s *MaterializedViewDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitMaterializedViewDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) MaterializedViewDesc() (localctx IMaterializedViewDescContext) {
	localctx = NewMaterializedViewDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, DorisSQLParserParserRULE_materializedViewDesc)
	p.SetState(2232)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserPARTITION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2225)
			p.Match(DorisSQLParserParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2226)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2227)
			p.MvPartitionExprs()
		}

	case DorisSQLParserParserDISTRIBUTED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2228)
			p.DistributionDesc()
		}

	case DorisSQLParserParserORDER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2229)
			p.OrderByDesc()
		}

	case DorisSQLParserParserREFRESH:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2230)
			p.RefreshSchemeDesc()
		}

	case DorisSQLParserParserPROPERTIES:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2231)
			p.Properties()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowMaterializedViewsStatementContext is an interface to support dynamic dispatch.
type IShowMaterializedViewsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEWS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowMaterializedViewsStatementContext differentiates from other interfaces.
	IsShowMaterializedViewsStatementContext()
}

type ShowMaterializedViewsStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	db      IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowMaterializedViewsStatementContext() *ShowMaterializedViewsStatementContext {
	var p = new(ShowMaterializedViewsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showMaterializedViewsStatement
	return p
}

func InitEmptyShowMaterializedViewsStatementContext(p *ShowMaterializedViewsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showMaterializedViewsStatement
}

func (*ShowMaterializedViewsStatementContext) IsShowMaterializedViewsStatementContext() {}

func NewShowMaterializedViewsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowMaterializedViewsStatementContext {
	var p = new(ShowMaterializedViewsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showMaterializedViewsStatement

	return p
}

func (s *ShowMaterializedViewsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowMaterializedViewsStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowMaterializedViewsStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowMaterializedViewsStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowMaterializedViewsStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowMaterializedViewsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowMaterializedViewsStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMATERIALIZED, 0)
}

func (s *ShowMaterializedViewsStatementContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVIEWS, 0)
}

func (s *ShowMaterializedViewsStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowMaterializedViewsStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *ShowMaterializedViewsStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowMaterializedViewsStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *ShowMaterializedViewsStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowMaterializedViewsStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowMaterializedViewsStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowMaterializedViewsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowMaterializedViewsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowMaterializedViewsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowMaterializedViewsStatement(s)
	}
}

func (s *ShowMaterializedViewsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowMaterializedViewsStatement(s)
	}
}

func (s *ShowMaterializedViewsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowMaterializedViewsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowMaterializedViewsStatement() (localctx IShowMaterializedViewsStatementContext) {
	localctx = NewShowMaterializedViewsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, DorisSQLParserParserRULE_showMaterializedViewsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2234)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2235)
		p.Match(DorisSQLParserParserMATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2236)
		p.Match(DorisSQLParserParserVIEWS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2239)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN {
		{
			p.SetState(2237)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2238)

			var _x = p.QualifiedName()

			localctx.(*ShowMaterializedViewsStatementContext).db = _x
		}

	}
	p.SetState(2245)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserLIKE:
		{
			p.SetState(2241)
			p.Match(DorisSQLParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2242)

			var _x = p.String_()

			localctx.(*ShowMaterializedViewsStatementContext).pattern = _x
		}

	case DorisSQLParserParserWHERE:
		{
			p.SetState(2243)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2244)
			p.expression(0)
		}

	case DorisSQLParserParserEOF, DorisSQLParserParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropMaterializedViewStatementContext is an interface to support dynamic dispatch.
type IDropMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMvName returns the mvName rule contexts.
	GetMvName() IQualifiedNameContext

	// SetMvName sets the mvName rule contexts.
	SetMvName(IQualifiedNameContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropMaterializedViewStatementContext differentiates from other interfaces.
	IsDropMaterializedViewStatementContext()
}

type DropMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	mvName IQualifiedNameContext
}

func NewEmptyDropMaterializedViewStatementContext() *DropMaterializedViewStatementContext {
	var p = new(DropMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropMaterializedViewStatement
	return p
}

func InitEmptyDropMaterializedViewStatementContext(p *DropMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropMaterializedViewStatement
}

func (*DropMaterializedViewStatementContext) IsDropMaterializedViewStatementContext() {}

func NewDropMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropMaterializedViewStatementContext {
	var p = new(DropMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropMaterializedViewStatement

	return p
}

func (s *DropMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropMaterializedViewStatementContext) GetMvName() IQualifiedNameContext { return s.mvName }

func (s *DropMaterializedViewStatementContext) SetMvName(v IQualifiedNameContext) { s.mvName = v }

func (s *DropMaterializedViewStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropMaterializedViewStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMATERIALIZED, 0)
}

func (s *DropMaterializedViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVIEW, 0)
}

func (s *DropMaterializedViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropMaterializedViewStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *DropMaterializedViewStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *DropMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropMaterializedViewStatement(s)
	}
}

func (s *DropMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropMaterializedViewStatement(s)
	}
}

func (s *DropMaterializedViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropMaterializedViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropMaterializedViewStatement() (localctx IDropMaterializedViewStatementContext) {
	localctx = NewDropMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, DorisSQLParserParserRULE_dropMaterializedViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2247)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2248)
		p.Match(DorisSQLParserParserMATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2249)
		p.Match(DorisSQLParserParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2252)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(2250)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2251)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2254)

		var _x = p.QualifiedName()

		localctx.(*DropMaterializedViewStatementContext).mvName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterMaterializedViewStatementContext is an interface to support dynamic dispatch.
type IAlterMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMvName returns the mvName rule contexts.
	GetMvName() IQualifiedNameContext

	// SetMvName sets the mvName rule contexts.
	SetMvName(IQualifiedNameContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	RefreshSchemeDesc() IRefreshSchemeDescContext
	TableRenameClause() ITableRenameClauseContext
	ModifyPropertiesClause() IModifyPropertiesClauseContext
	SwapTableClause() ISwapTableClauseContext
	StatusDesc() IStatusDescContext

	// IsAlterMaterializedViewStatementContext differentiates from other interfaces.
	IsAlterMaterializedViewStatementContext()
}

type AlterMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	mvName IQualifiedNameContext
}

func NewEmptyAlterMaterializedViewStatementContext() *AlterMaterializedViewStatementContext {
	var p = new(AlterMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterMaterializedViewStatement
	return p
}

func InitEmptyAlterMaterializedViewStatementContext(p *AlterMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterMaterializedViewStatement
}

func (*AlterMaterializedViewStatementContext) IsAlterMaterializedViewStatementContext() {}

func NewAlterMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterMaterializedViewStatementContext {
	var p = new(AlterMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_alterMaterializedViewStatement

	return p
}

func (s *AlterMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterMaterializedViewStatementContext) GetMvName() IQualifiedNameContext { return s.mvName }

func (s *AlterMaterializedViewStatementContext) SetMvName(v IQualifiedNameContext) { s.mvName = v }

func (s *AlterMaterializedViewStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *AlterMaterializedViewStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMATERIALIZED, 0)
}

func (s *AlterMaterializedViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVIEW, 0)
}

func (s *AlterMaterializedViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterMaterializedViewStatementContext) RefreshSchemeDesc() IRefreshSchemeDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshSchemeDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshSchemeDescContext)
}

func (s *AlterMaterializedViewStatementContext) TableRenameClause() ITableRenameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRenameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRenameClauseContext)
}

func (s *AlterMaterializedViewStatementContext) ModifyPropertiesClause() IModifyPropertiesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyPropertiesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyPropertiesClauseContext)
}

func (s *AlterMaterializedViewStatementContext) SwapTableClause() ISwapTableClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwapTableClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwapTableClauseContext)
}

func (s *AlterMaterializedViewStatementContext) StatusDesc() IStatusDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatusDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatusDescContext)
}

func (s *AlterMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAlterMaterializedViewStatement(s)
	}
}

func (s *AlterMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAlterMaterializedViewStatement(s)
	}
}

func (s *AlterMaterializedViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAlterMaterializedViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AlterMaterializedViewStatement() (localctx IAlterMaterializedViewStatementContext) {
	localctx = NewAlterMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, DorisSQLParserParserRULE_alterMaterializedViewStatement)
	p.SetState(2272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 154, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2256)
			p.Match(DorisSQLParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2257)
			p.Match(DorisSQLParserParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2258)
			p.Match(DorisSQLParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2259)

			var _x = p.QualifiedName()

			localctx.(*AlterMaterializedViewStatementContext).mvName = _x
		}
		p.SetState(2264)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserParserREFRESH:
			{
				p.SetState(2260)
				p.RefreshSchemeDesc()
			}

		case DorisSQLParserParserRENAME:
			{
				p.SetState(2261)
				p.TableRenameClause()
			}

		case DorisSQLParserParserSET:
			{
				p.SetState(2262)
				p.ModifyPropertiesClause()
			}

		case DorisSQLParserParserSWAP:
			{
				p.SetState(2263)
				p.SwapTableClause()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2266)
			p.Match(DorisSQLParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2267)
			p.Match(DorisSQLParserParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2268)
			p.Match(DorisSQLParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2269)

			var _x = p.QualifiedName()

			localctx.(*AlterMaterializedViewStatementContext).mvName = _x
		}
		{
			p.SetState(2270)
			p.StatusDesc()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshMaterializedViewStatementContext is an interface to support dynamic dispatch.
type IRefreshMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// GetMvName returns the mvName rule contexts.
	GetMvName() IQualifiedNameContext

	// SetMvName sets the mvName rule contexts.
	SetMvName(IQualifiedNameContext)

	// Getter signatures
	REFRESH() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PARTITION() antlr.TerminalNode
	FORCE() antlr.TerminalNode
	AllWITH() []antlr.TerminalNode
	WITH(i int) antlr.TerminalNode
	MODE() antlr.TerminalNode
	PRIORITY() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	PartitionRangeDesc() IPartitionRangeDescContext
	ListPartitionValues() IListPartitionValuesContext

	// IsRefreshMaterializedViewStatementContext differentiates from other interfaces.
	IsRefreshMaterializedViewStatementContext()
}

type RefreshMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	mvName   IQualifiedNameContext
	priority antlr.Token
}

func NewEmptyRefreshMaterializedViewStatementContext() *RefreshMaterializedViewStatementContext {
	var p = new(RefreshMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_refreshMaterializedViewStatement
	return p
}

func InitEmptyRefreshMaterializedViewStatementContext(p *RefreshMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_refreshMaterializedViewStatement
}

func (*RefreshMaterializedViewStatementContext) IsRefreshMaterializedViewStatementContext() {}

func NewRefreshMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshMaterializedViewStatementContext {
	var p = new(RefreshMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_refreshMaterializedViewStatement

	return p
}

func (s *RefreshMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshMaterializedViewStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *RefreshMaterializedViewStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *RefreshMaterializedViewStatementContext) GetMvName() IQualifiedNameContext { return s.mvName }

func (s *RefreshMaterializedViewStatementContext) SetMvName(v IQualifiedNameContext) { s.mvName = v }

func (s *RefreshMaterializedViewStatementContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREFRESH, 0)
}

func (s *RefreshMaterializedViewStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMATERIALIZED, 0)
}

func (s *RefreshMaterializedViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVIEW, 0)
}

func (s *RefreshMaterializedViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RefreshMaterializedViewStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPARTITION, 0)
}

func (s *RefreshMaterializedViewStatementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFORCE, 0)
}

func (s *RefreshMaterializedViewStatementContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserWITH)
}

func (s *RefreshMaterializedViewStatementContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, i)
}

func (s *RefreshMaterializedViewStatementContext) MODE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMODE, 0)
}

func (s *RefreshMaterializedViewStatementContext) PRIORITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPRIORITY, 0)
}

func (s *RefreshMaterializedViewStatementContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSYNC, 0)
}

func (s *RefreshMaterializedViewStatementContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserASYNC, 0)
}

func (s *RefreshMaterializedViewStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, 0)
}

func (s *RefreshMaterializedViewStatementContext) PartitionRangeDesc() IPartitionRangeDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionRangeDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionRangeDescContext)
}

func (s *RefreshMaterializedViewStatementContext) ListPartitionValues() IListPartitionValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListPartitionValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListPartitionValuesContext)
}

func (s *RefreshMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRefreshMaterializedViewStatement(s)
	}
}

func (s *RefreshMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRefreshMaterializedViewStatement(s)
	}
}

func (s *RefreshMaterializedViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRefreshMaterializedViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) RefreshMaterializedViewStatement() (localctx IRefreshMaterializedViewStatementContext) {
	localctx = NewRefreshMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, DorisSQLParserParserRULE_refreshMaterializedViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2274)
		p.Match(DorisSQLParserParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2275)
		p.Match(DorisSQLParserParserMATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2276)
		p.Match(DorisSQLParserParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2277)

		var _x = p.QualifiedName()

		localctx.(*RefreshMaterializedViewStatementContext).mvName = _x
	}
	p.SetState(2283)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPARTITION {
		{
			p.SetState(2278)
			p.Match(DorisSQLParserParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2281)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserParserSTART:
			{
				p.SetState(2279)
				p.PartitionRangeDesc()
			}

		case DorisSQLParserParserT__1:
			{
				p.SetState(2280)
				p.ListPartitionValues()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(2286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFORCE {
		{
			p.SetState(2285)
			p.Match(DorisSQLParserParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2291)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 158, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2288)
			p.Match(DorisSQLParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2289)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserASYNC || _la == DorisSQLParserParserSYNC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2290)
			p.Match(DorisSQLParserParserMODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2296)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWITH {
		{
			p.SetState(2293)
			p.Match(DorisSQLParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2294)
			p.Match(DorisSQLParserParserPRIORITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2295)

			var _m = p.Match(DorisSQLParserParserINTEGER_VALUE)

			localctx.(*RefreshMaterializedViewStatementContext).priority = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelRefreshMaterializedViewStatementContext is an interface to support dynamic dispatch.
type ICancelRefreshMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMvName returns the mvName rule contexts.
	GetMvName() IQualifiedNameContext

	// SetMvName sets the mvName rule contexts.
	SetMvName(IQualifiedNameContext)

	// Getter signatures
	CANCEL() antlr.TerminalNode
	REFRESH() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	FORCE() antlr.TerminalNode

	// IsCancelRefreshMaterializedViewStatementContext differentiates from other interfaces.
	IsCancelRefreshMaterializedViewStatementContext()
}

type CancelRefreshMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	mvName IQualifiedNameContext
}

func NewEmptyCancelRefreshMaterializedViewStatementContext() *CancelRefreshMaterializedViewStatementContext {
	var p = new(CancelRefreshMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cancelRefreshMaterializedViewStatement
	return p
}

func InitEmptyCancelRefreshMaterializedViewStatementContext(p *CancelRefreshMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cancelRefreshMaterializedViewStatement
}

func (*CancelRefreshMaterializedViewStatementContext) IsCancelRefreshMaterializedViewStatementContext() {
}

func NewCancelRefreshMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelRefreshMaterializedViewStatementContext {
	var p = new(CancelRefreshMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_cancelRefreshMaterializedViewStatement

	return p
}

func (s *CancelRefreshMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelRefreshMaterializedViewStatementContext) GetMvName() IQualifiedNameContext {
	return s.mvName
}

func (s *CancelRefreshMaterializedViewStatementContext) SetMvName(v IQualifiedNameContext) {
	s.mvName = v
}

func (s *CancelRefreshMaterializedViewStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCANCEL, 0)
}

func (s *CancelRefreshMaterializedViewStatementContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREFRESH, 0)
}

func (s *CancelRefreshMaterializedViewStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMATERIALIZED, 0)
}

func (s *CancelRefreshMaterializedViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVIEW, 0)
}

func (s *CancelRefreshMaterializedViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CancelRefreshMaterializedViewStatementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFORCE, 0)
}

func (s *CancelRefreshMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelRefreshMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelRefreshMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCancelRefreshMaterializedViewStatement(s)
	}
}

func (s *CancelRefreshMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCancelRefreshMaterializedViewStatement(s)
	}
}

func (s *CancelRefreshMaterializedViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCancelRefreshMaterializedViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CancelRefreshMaterializedViewStatement() (localctx ICancelRefreshMaterializedViewStatementContext) {
	localctx = NewCancelRefreshMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, DorisSQLParserParserRULE_cancelRefreshMaterializedViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2298)
		p.Match(DorisSQLParserParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2299)
		p.Match(DorisSQLParserParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2300)
		p.Match(DorisSQLParserParserMATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2301)
		p.Match(DorisSQLParserParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2302)

		var _x = p.QualifiedName()

		localctx.(*CancelRefreshMaterializedViewStatementContext).mvName = _x
	}
	p.SetState(2304)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFORCE {
		{
			p.SetState(2303)
			p.Match(DorisSQLParserParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminSetConfigStatementContext is an interface to support dynamic dispatch.
type IAdminSetConfigStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SET() antlr.TerminalNode
	FRONTEND() antlr.TerminalNode
	CONFIG() antlr.TerminalNode
	Property() IPropertyContext
	WITH() antlr.TerminalNode
	PERSISTENT() antlr.TerminalNode

	// IsAdminSetConfigStatementContext differentiates from other interfaces.
	IsAdminSetConfigStatementContext()
}

type AdminSetConfigStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminSetConfigStatementContext() *AdminSetConfigStatementContext {
	var p = new(AdminSetConfigStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_adminSetConfigStatement
	return p
}

func InitEmptyAdminSetConfigStatementContext(p *AdminSetConfigStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_adminSetConfigStatement
}

func (*AdminSetConfigStatementContext) IsAdminSetConfigStatementContext() {}

func NewAdminSetConfigStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminSetConfigStatementContext {
	var p = new(AdminSetConfigStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_adminSetConfigStatement

	return p
}

func (s *AdminSetConfigStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminSetConfigStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADMIN, 0)
}

func (s *AdminSetConfigStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *AdminSetConfigStatementContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFRONTEND, 0)
}

func (s *AdminSetConfigStatementContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCONFIG, 0)
}

func (s *AdminSetConfigStatementContext) Property() IPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *AdminSetConfigStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *AdminSetConfigStatementContext) PERSISTENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPERSISTENT, 0)
}

func (s *AdminSetConfigStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetConfigStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminSetConfigStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAdminSetConfigStatement(s)
	}
}

func (s *AdminSetConfigStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAdminSetConfigStatement(s)
	}
}

func (s *AdminSetConfigStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAdminSetConfigStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AdminSetConfigStatement() (localctx IAdminSetConfigStatementContext) {
	localctx = NewAdminSetConfigStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, DorisSQLParserParserRULE_adminSetConfigStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2306)
		p.Match(DorisSQLParserParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2307)
		p.Match(DorisSQLParserParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2308)
		p.Match(DorisSQLParserParserFRONTEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2309)
		p.Match(DorisSQLParserParserCONFIG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2310)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2311)
		p.Property()
	}
	{
		p.SetState(2312)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2315)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWITH {
		{
			p.SetState(2313)
			p.Match(DorisSQLParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2314)
			p.Match(DorisSQLParserParserPERSISTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminSetReplicaStatusStatementContext is an interface to support dynamic dispatch.
type IAdminSetReplicaStatusStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SET() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsAdminSetReplicaStatusStatementContext differentiates from other interfaces.
	IsAdminSetReplicaStatusStatementContext()
}

type AdminSetReplicaStatusStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminSetReplicaStatusStatementContext() *AdminSetReplicaStatusStatementContext {
	var p = new(AdminSetReplicaStatusStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_adminSetReplicaStatusStatement
	return p
}

func InitEmptyAdminSetReplicaStatusStatementContext(p *AdminSetReplicaStatusStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_adminSetReplicaStatusStatement
}

func (*AdminSetReplicaStatusStatementContext) IsAdminSetReplicaStatusStatementContext() {}

func NewAdminSetReplicaStatusStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminSetReplicaStatusStatementContext {
	var p = new(AdminSetReplicaStatusStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_adminSetReplicaStatusStatement

	return p
}

func (s *AdminSetReplicaStatusStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminSetReplicaStatusStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADMIN, 0)
}

func (s *AdminSetReplicaStatusStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *AdminSetReplicaStatusStatementContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPLICA, 0)
}

func (s *AdminSetReplicaStatusStatementContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTATUS, 0)
}

func (s *AdminSetReplicaStatusStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AdminSetReplicaStatusStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetReplicaStatusStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminSetReplicaStatusStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAdminSetReplicaStatusStatement(s)
	}
}

func (s *AdminSetReplicaStatusStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAdminSetReplicaStatusStatement(s)
	}
}

func (s *AdminSetReplicaStatusStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAdminSetReplicaStatusStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AdminSetReplicaStatusStatement() (localctx IAdminSetReplicaStatusStatementContext) {
	localctx = NewAdminSetReplicaStatusStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, DorisSQLParserParserRULE_adminSetReplicaStatusStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2317)
		p.Match(DorisSQLParserParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2318)
		p.Match(DorisSQLParserParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2319)
		p.Match(DorisSQLParserParserREPLICA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2320)
		p.Match(DorisSQLParserParserSTATUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2321)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminShowConfigStatementContext is an interface to support dynamic dispatch.
type IAdminShowConfigStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	FRONTEND() antlr.TerminalNode
	CONFIG() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	String_() IStringContext

	// IsAdminShowConfigStatementContext differentiates from other interfaces.
	IsAdminShowConfigStatementContext()
}

type AdminShowConfigStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyAdminShowConfigStatementContext() *AdminShowConfigStatementContext {
	var p = new(AdminShowConfigStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_adminShowConfigStatement
	return p
}

func InitEmptyAdminShowConfigStatementContext(p *AdminShowConfigStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_adminShowConfigStatement
}

func (*AdminShowConfigStatementContext) IsAdminShowConfigStatementContext() {}

func NewAdminShowConfigStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminShowConfigStatementContext {
	var p = new(AdminShowConfigStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_adminShowConfigStatement

	return p
}

func (s *AdminShowConfigStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminShowConfigStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *AdminShowConfigStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *AdminShowConfigStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADMIN, 0)
}

func (s *AdminShowConfigStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *AdminShowConfigStatementContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFRONTEND, 0)
}

func (s *AdminShowConfigStatementContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCONFIG, 0)
}

func (s *AdminShowConfigStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *AdminShowConfigStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AdminShowConfigStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminShowConfigStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminShowConfigStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAdminShowConfigStatement(s)
	}
}

func (s *AdminShowConfigStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAdminShowConfigStatement(s)
	}
}

func (s *AdminShowConfigStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAdminShowConfigStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AdminShowConfigStatement() (localctx IAdminShowConfigStatementContext) {
	localctx = NewAdminShowConfigStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, DorisSQLParserParserRULE_adminShowConfigStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2323)
		p.Match(DorisSQLParserParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2324)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2325)
		p.Match(DorisSQLParserParserFRONTEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2326)
		p.Match(DorisSQLParserParserCONFIG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserLIKE {
		{
			p.SetState(2327)
			p.Match(DorisSQLParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2328)

			var _x = p.String_()

			localctx.(*AdminShowConfigStatementContext).pattern = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminShowReplicaDistributionStatementContext is an interface to support dynamic dispatch.
type IAdminShowReplicaDistributionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	DISTRIBUTION() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext

	// IsAdminShowReplicaDistributionStatementContext differentiates from other interfaces.
	IsAdminShowReplicaDistributionStatementContext()
}

type AdminShowReplicaDistributionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminShowReplicaDistributionStatementContext() *AdminShowReplicaDistributionStatementContext {
	var p = new(AdminShowReplicaDistributionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_adminShowReplicaDistributionStatement
	return p
}

func InitEmptyAdminShowReplicaDistributionStatementContext(p *AdminShowReplicaDistributionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_adminShowReplicaDistributionStatement
}

func (*AdminShowReplicaDistributionStatementContext) IsAdminShowReplicaDistributionStatementContext() {
}

func NewAdminShowReplicaDistributionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminShowReplicaDistributionStatementContext {
	var p = new(AdminShowReplicaDistributionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_adminShowReplicaDistributionStatement

	return p
}

func (s *AdminShowReplicaDistributionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminShowReplicaDistributionStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADMIN, 0)
}

func (s *AdminShowReplicaDistributionStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *AdminShowReplicaDistributionStatementContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPLICA, 0)
}

func (s *AdminShowReplicaDistributionStatementContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDISTRIBUTION, 0)
}

func (s *AdminShowReplicaDistributionStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *AdminShowReplicaDistributionStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AdminShowReplicaDistributionStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *AdminShowReplicaDistributionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminShowReplicaDistributionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminShowReplicaDistributionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAdminShowReplicaDistributionStatement(s)
	}
}

func (s *AdminShowReplicaDistributionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAdminShowReplicaDistributionStatement(s)
	}
}

func (s *AdminShowReplicaDistributionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAdminShowReplicaDistributionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AdminShowReplicaDistributionStatement() (localctx IAdminShowReplicaDistributionStatementContext) {
	localctx = NewAdminShowReplicaDistributionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, DorisSQLParserParserRULE_adminShowReplicaDistributionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2331)
		p.Match(DorisSQLParserParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2332)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2333)
		p.Match(DorisSQLParserParserREPLICA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2334)
		p.Match(DorisSQLParserParserDISTRIBUTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2335)
		p.Match(DorisSQLParserParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2336)
		p.QualifiedName()
	}
	p.SetState(2338)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPARTITION || _la == DorisSQLParserParserPARTITIONS || _la == DorisSQLParserParserTEMPORARY {
		{
			p.SetState(2337)
			p.PartitionNames()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminShowReplicaStatusStatementContext is an interface to support dynamic dispatch.
type IAdminShowReplicaStatusStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsAdminShowReplicaStatusStatementContext differentiates from other interfaces.
	IsAdminShowReplicaStatusStatementContext()
}

type AdminShowReplicaStatusStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IExpressionContext
}

func NewEmptyAdminShowReplicaStatusStatementContext() *AdminShowReplicaStatusStatementContext {
	var p = new(AdminShowReplicaStatusStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_adminShowReplicaStatusStatement
	return p
}

func InitEmptyAdminShowReplicaStatusStatementContext(p *AdminShowReplicaStatusStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_adminShowReplicaStatusStatement
}

func (*AdminShowReplicaStatusStatementContext) IsAdminShowReplicaStatusStatementContext() {}

func NewAdminShowReplicaStatusStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminShowReplicaStatusStatementContext {
	var p = new(AdminShowReplicaStatusStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_adminShowReplicaStatusStatement

	return p
}

func (s *AdminShowReplicaStatusStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminShowReplicaStatusStatementContext) GetWhere() IExpressionContext { return s.where }

func (s *AdminShowReplicaStatusStatementContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *AdminShowReplicaStatusStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADMIN, 0)
}

func (s *AdminShowReplicaStatusStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *AdminShowReplicaStatusStatementContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPLICA, 0)
}

func (s *AdminShowReplicaStatusStatementContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTATUS, 0)
}

func (s *AdminShowReplicaStatusStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *AdminShowReplicaStatusStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AdminShowReplicaStatusStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *AdminShowReplicaStatusStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *AdminShowReplicaStatusStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AdminShowReplicaStatusStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminShowReplicaStatusStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminShowReplicaStatusStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAdminShowReplicaStatusStatement(s)
	}
}

func (s *AdminShowReplicaStatusStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAdminShowReplicaStatusStatement(s)
	}
}

func (s *AdminShowReplicaStatusStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAdminShowReplicaStatusStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AdminShowReplicaStatusStatement() (localctx IAdminShowReplicaStatusStatementContext) {
	localctx = NewAdminShowReplicaStatusStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, DorisSQLParserParserRULE_adminShowReplicaStatusStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2340)
		p.Match(DorisSQLParserParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2341)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2342)
		p.Match(DorisSQLParserParserREPLICA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2343)
		p.Match(DorisSQLParserParserSTATUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2344)
		p.Match(DorisSQLParserParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2345)
		p.QualifiedName()
	}
	p.SetState(2347)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPARTITION || _la == DorisSQLParserParserPARTITIONS || _la == DorisSQLParserParserTEMPORARY {
		{
			p.SetState(2346)
			p.PartitionNames()
		}

	}
	p.SetState(2351)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWHERE {
		{
			p.SetState(2349)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2350)

			var _x = p.expression(0)

			localctx.(*AdminShowReplicaStatusStatementContext).where = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminRepairTableStatementContext is an interface to support dynamic dispatch.
type IAdminRepairTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	REPAIR() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext

	// IsAdminRepairTableStatementContext differentiates from other interfaces.
	IsAdminRepairTableStatementContext()
}

type AdminRepairTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminRepairTableStatementContext() *AdminRepairTableStatementContext {
	var p = new(AdminRepairTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_adminRepairTableStatement
	return p
}

func InitEmptyAdminRepairTableStatementContext(p *AdminRepairTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_adminRepairTableStatement
}

func (*AdminRepairTableStatementContext) IsAdminRepairTableStatementContext() {}

func NewAdminRepairTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminRepairTableStatementContext {
	var p = new(AdminRepairTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_adminRepairTableStatement

	return p
}

func (s *AdminRepairTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminRepairTableStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADMIN, 0)
}

func (s *AdminRepairTableStatementContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPAIR, 0)
}

func (s *AdminRepairTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *AdminRepairTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AdminRepairTableStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *AdminRepairTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminRepairTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminRepairTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAdminRepairTableStatement(s)
	}
}

func (s *AdminRepairTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAdminRepairTableStatement(s)
	}
}

func (s *AdminRepairTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAdminRepairTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AdminRepairTableStatement() (localctx IAdminRepairTableStatementContext) {
	localctx = NewAdminRepairTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, DorisSQLParserParserRULE_adminRepairTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2353)
		p.Match(DorisSQLParserParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2354)
		p.Match(DorisSQLParserParserREPAIR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2355)
		p.Match(DorisSQLParserParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2356)
		p.QualifiedName()
	}
	p.SetState(2358)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPARTITION || _la == DorisSQLParserParserPARTITIONS || _la == DorisSQLParserParserTEMPORARY {
		{
			p.SetState(2357)
			p.PartitionNames()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminCancelRepairTableStatementContext is an interface to support dynamic dispatch.
type IAdminCancelRepairTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	CANCEL() antlr.TerminalNode
	REPAIR() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext

	// IsAdminCancelRepairTableStatementContext differentiates from other interfaces.
	IsAdminCancelRepairTableStatementContext()
}

type AdminCancelRepairTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminCancelRepairTableStatementContext() *AdminCancelRepairTableStatementContext {
	var p = new(AdminCancelRepairTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_adminCancelRepairTableStatement
	return p
}

func InitEmptyAdminCancelRepairTableStatementContext(p *AdminCancelRepairTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_adminCancelRepairTableStatement
}

func (*AdminCancelRepairTableStatementContext) IsAdminCancelRepairTableStatementContext() {}

func NewAdminCancelRepairTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminCancelRepairTableStatementContext {
	var p = new(AdminCancelRepairTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_adminCancelRepairTableStatement

	return p
}

func (s *AdminCancelRepairTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminCancelRepairTableStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADMIN, 0)
}

func (s *AdminCancelRepairTableStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCANCEL, 0)
}

func (s *AdminCancelRepairTableStatementContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPAIR, 0)
}

func (s *AdminCancelRepairTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *AdminCancelRepairTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AdminCancelRepairTableStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *AdminCancelRepairTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCancelRepairTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminCancelRepairTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAdminCancelRepairTableStatement(s)
	}
}

func (s *AdminCancelRepairTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAdminCancelRepairTableStatement(s)
	}
}

func (s *AdminCancelRepairTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAdminCancelRepairTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AdminCancelRepairTableStatement() (localctx IAdminCancelRepairTableStatementContext) {
	localctx = NewAdminCancelRepairTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, DorisSQLParserParserRULE_adminCancelRepairTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2360)
		p.Match(DorisSQLParserParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2361)
		p.Match(DorisSQLParserParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2362)
		p.Match(DorisSQLParserParserREPAIR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2363)
		p.Match(DorisSQLParserParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2364)
		p.QualifiedName()
	}
	p.SetState(2366)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPARTITION || _la == DorisSQLParserParserPARTITIONS || _la == DorisSQLParserParserTEMPORARY {
		{
			p.SetState(2365)
			p.PartitionNames()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminCheckTabletsStatementContext is an interface to support dynamic dispatch.
type IAdminCheckTabletsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	TabletList() ITabletListContext
	PROPERTIES() antlr.TerminalNode
	Property() IPropertyContext

	// IsAdminCheckTabletsStatementContext differentiates from other interfaces.
	IsAdminCheckTabletsStatementContext()
}

type AdminCheckTabletsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminCheckTabletsStatementContext() *AdminCheckTabletsStatementContext {
	var p = new(AdminCheckTabletsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_adminCheckTabletsStatement
	return p
}

func InitEmptyAdminCheckTabletsStatementContext(p *AdminCheckTabletsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_adminCheckTabletsStatement
}

func (*AdminCheckTabletsStatementContext) IsAdminCheckTabletsStatementContext() {}

func NewAdminCheckTabletsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminCheckTabletsStatementContext {
	var p = new(AdminCheckTabletsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_adminCheckTabletsStatement

	return p
}

func (s *AdminCheckTabletsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminCheckTabletsStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADMIN, 0)
}

func (s *AdminCheckTabletsStatementContext) CHECK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCHECK, 0)
}

func (s *AdminCheckTabletsStatementContext) TabletList() ITabletListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabletListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabletListContext)
}

func (s *AdminCheckTabletsStatementContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROPERTIES, 0)
}

func (s *AdminCheckTabletsStatementContext) Property() IPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *AdminCheckTabletsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCheckTabletsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminCheckTabletsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAdminCheckTabletsStatement(s)
	}
}

func (s *AdminCheckTabletsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAdminCheckTabletsStatement(s)
	}
}

func (s *AdminCheckTabletsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAdminCheckTabletsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AdminCheckTabletsStatement() (localctx IAdminCheckTabletsStatementContext) {
	localctx = NewAdminCheckTabletsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, DorisSQLParserParserRULE_adminCheckTabletsStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2368)
		p.Match(DorisSQLParserParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2369)
		p.Match(DorisSQLParserParserCHECK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2370)
		p.TabletList()
	}
	{
		p.SetState(2371)
		p.Match(DorisSQLParserParserPROPERTIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2372)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2373)
		p.Property()
	}
	{
		p.SetState(2374)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminSetPartitionVersionContext is an interface to support dynamic dispatch.
type IAdminSetPartitionVersionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionId returns the partitionId token.
	GetPartitionId() antlr.Token

	// GetVersion returns the version token.
	GetVersion() antlr.Token

	// SetPartitionId sets the partitionId token.
	SetPartitionId(antlr.Token)

	// SetVersion sets the version token.
	SetVersion(antlr.Token)

	// GetPartitionName returns the partitionName rule contexts.
	GetPartitionName() IIdentifierOrStringContext

	// SetPartitionName sets the partitionName rule contexts.
	SetPartitionName(IIdentifierOrStringContext)

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SET() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PARTITION() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	TO() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsAdminSetPartitionVersionContext differentiates from other interfaces.
	IsAdminSetPartitionVersionContext()
}

type AdminSetPartitionVersionContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	partitionName IIdentifierOrStringContext
	partitionId   antlr.Token
	version       antlr.Token
}

func NewEmptyAdminSetPartitionVersionContext() *AdminSetPartitionVersionContext {
	var p = new(AdminSetPartitionVersionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_adminSetPartitionVersion
	return p
}

func InitEmptyAdminSetPartitionVersionContext(p *AdminSetPartitionVersionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_adminSetPartitionVersion
}

func (*AdminSetPartitionVersionContext) IsAdminSetPartitionVersionContext() {}

func NewAdminSetPartitionVersionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminSetPartitionVersionContext {
	var p = new(AdminSetPartitionVersionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_adminSetPartitionVersion

	return p
}

func (s *AdminSetPartitionVersionContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminSetPartitionVersionContext) GetPartitionId() antlr.Token { return s.partitionId }

func (s *AdminSetPartitionVersionContext) GetVersion() antlr.Token { return s.version }

func (s *AdminSetPartitionVersionContext) SetPartitionId(v antlr.Token) { s.partitionId = v }

func (s *AdminSetPartitionVersionContext) SetVersion(v antlr.Token) { s.version = v }

func (s *AdminSetPartitionVersionContext) GetPartitionName() IIdentifierOrStringContext {
	return s.partitionName
}

func (s *AdminSetPartitionVersionContext) SetPartitionName(v IIdentifierOrStringContext) {
	s.partitionName = v
}

func (s *AdminSetPartitionVersionContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADMIN, 0)
}

func (s *AdminSetPartitionVersionContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *AdminSetPartitionVersionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *AdminSetPartitionVersionContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AdminSetPartitionVersionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPARTITION, 0)
}

func (s *AdminSetPartitionVersionContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVERSION, 0)
}

func (s *AdminSetPartitionVersionContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTO, 0)
}

func (s *AdminSetPartitionVersionContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserINTEGER_VALUE)
}

func (s *AdminSetPartitionVersionContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, i)
}

func (s *AdminSetPartitionVersionContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AdminSetPartitionVersionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetPartitionVersionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminSetPartitionVersionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAdminSetPartitionVersion(s)
	}
}

func (s *AdminSetPartitionVersionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAdminSetPartitionVersion(s)
	}
}

func (s *AdminSetPartitionVersionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAdminSetPartitionVersion(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AdminSetPartitionVersion() (localctx IAdminSetPartitionVersionContext) {
	localctx = NewAdminSetPartitionVersionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, DorisSQLParserParserRULE_adminSetPartitionVersion)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2376)
		p.Match(DorisSQLParserParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2377)
		p.Match(DorisSQLParserParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2378)
		p.Match(DorisSQLParserParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2379)
		p.QualifiedName()
	}
	{
		p.SetState(2380)
		p.Match(DorisSQLParserParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2381)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2384)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserACCESS, DorisSQLParserParserACTIVE, DorisSQLParserParserADMIN, DorisSQLParserParserADVISOR, DorisSQLParserParserAFTER, DorisSQLParserParserAGGREGATE, DorisSQLParserParserANTI, DorisSQLParserParserAPPLY, DorisSQLParserParserARRAY_AGG, DorisSQLParserParserARRAY_AGG_DISTINCT, DorisSQLParserParserASYNC, DorisSQLParserParserAUTHORS, DorisSQLParserParserAUTHENTICATION, DorisSQLParserParserAUTOMATED, DorisSQLParserParserAUTO_INCREMENT, DorisSQLParserParserAVG, DorisSQLParserParserBACKEND, DorisSQLParserParserBACKENDS, DorisSQLParserParserBACKUP, DorisSQLParserParserBASE, DorisSQLParserParserBASELINE, DorisSQLParserParserBEGIN, DorisSQLParserParserBINARY, DorisSQLParserParserBITMAP_UNION, DorisSQLParserParserBLACKHOLE, DorisSQLParserParserBLACKLIST, DorisSQLParserParserBODY, DorisSQLParserParserBOOLEAN, DorisSQLParserParserBRANCH, DorisSQLParserParserBROKER, DorisSQLParserParserBUCKETS, DorisSQLParserParserBUILTIN, DorisSQLParserParserCACHE, DorisSQLParserParserCANCEL, DorisSQLParserParserCAST, DorisSQLParserParserCATALOG, DorisSQLParserParserCATALOGS, DorisSQLParserParserCEIL, DorisSQLParserParserCHAIN, DorisSQLParserParserCHARSET, DorisSQLParserParserCLEAN, DorisSQLParserParserCLEAR, DorisSQLParserParserCLUSTER, DorisSQLParserParserCLUSTERS, DorisSQLParserParserCNGROUP, DorisSQLParserParserCNGROUPS, DorisSQLParserParserCOLLATION, DorisSQLParserParserCOLUMNS, DorisSQLParserParserCOMMENT, DorisSQLParserParserCOMMIT, DorisSQLParserParserCOMMITTED, DorisSQLParserParserCOMPACT, DorisSQLParserParserCOMPUTE, DorisSQLParserParserCONFIG, DorisSQLParserParserCONNECTION, DorisSQLParserParserCONSISTENT, DorisSQLParserParserCOSTS, DorisSQLParserParserCOUNT, DorisSQLParserParserCUME_DIST, DorisSQLParserParserCUMULATIVE, DorisSQLParserParserCURRENT, DorisSQLParserParserDATA, DorisSQLParserParserDATACACHE, DorisSQLParserParserDATE, DorisSQLParserParserDATETIME, DorisSQLParserParserDAY, DorisSQLParserParserDAYS, DorisSQLParserParserDEALLOCATE, DorisSQLParserParserDECOMMISSION, DorisSQLParserParserDIALECT, DorisSQLParserParserDICTIONARY, DorisSQLParserParserDICTIONARY_GET, DorisSQLParserParserDISABLE, DorisSQLParserParserDISTRIBUTED, DorisSQLParserParserDISTRIBUTION, DorisSQLParserParserDUPLICATE, DorisSQLParserParserDYNAMIC, DorisSQLParserParserENABLE, DorisSQLParserParserENCLOSE, DorisSQLParserParserEND, DorisSQLParserParserENGINE, DorisSQLParserParserENGINES, DorisSQLParserParserERRORS, DorisSQLParserParserESCAPE, DorisSQLParserParserEVENTS, DorisSQLParserParserEXCEPT, DorisSQLParserParserEXCLUDE, DorisSQLParserParserEXECUTE, DorisSQLParserParserEXPORT, DorisSQLParserParserEXTERNAL, DorisSQLParserParserEXTRACT, DorisSQLParserParserEVERY, DorisSQLParserParserFAILPOINT, DorisSQLParserParserFAILPOINTS, DorisSQLParserParserFIELDS, DorisSQLParserParserFILE, DorisSQLParserParserFILTER, DorisSQLParserParserFIRST, DorisSQLParserParserFLOOR, DorisSQLParserParserFN, DorisSQLParserParserFOLLOWING, DorisSQLParserParserFOLLOWER, DorisSQLParserParserFORMAT, DorisSQLParserParserFREE, DorisSQLParserParserFRONTEND, DorisSQLParserParserFRONTENDS, DorisSQLParserParserFUNCTIONS, DorisSQLParserParserGLOBAL, DorisSQLParserParserGRANTS, DorisSQLParserParserGROUP_CONCAT, DorisSQLParserParserHASH, DorisSQLParserParserHELP, DorisSQLParserParserHISTOGRAM, DorisSQLParserParserHLL_UNION, DorisSQLParserParserHOST, DorisSQLParserParserHOUR, DorisSQLParserParserHOURS, DorisSQLParserParserHUB, DorisSQLParserParserIDENTIFIED, DorisSQLParserParserIMPERSONATE, DorisSQLParserParserIMAGE, DorisSQLParserParserINACTIVE, DorisSQLParserParserINCREMENTAL, DorisSQLParserParserINDEXES, DorisSQLParserParserINSTALL, DorisSQLParserParserINTEGRATION, DorisSQLParserParserINTEGRATIONS, DorisSQLParserParserINTERMEDIATE, DorisSQLParserParserINTERVAL, DorisSQLParserParserOVERWRITE, DorisSQLParserParserISOLATION, DorisSQLParserParserJOB, DorisSQLParserParserLABEL, DorisSQLParserParserLAST, DorisSQLParserParserLESS, DorisSQLParserParserLEVEL, DorisSQLParserParserLIST, DorisSQLParserParserLOCAL, DorisSQLParserParserLOCATION, DorisSQLParserParserLOCATIONS, DorisSQLParserParserLOGS, DorisSQLParserParserLOGICAL, DorisSQLParserParserMANUAL, DorisSQLParserParserMAP, DorisSQLParserParserMAPPING, DorisSQLParserParserMAPPINGS, DorisSQLParserParserMASKING, DorisSQLParserParserMATCH, DorisSQLParserParserMATERIALIZED, DorisSQLParserParserMAX, DorisSQLParserParserMERGE, DorisSQLParserParserMIN, DorisSQLParserParserMINUTE, DorisSQLParserParserMINUTES, DorisSQLParserParserMINUS, DorisSQLParserParserMETA, DorisSQLParserParserMODE, DorisSQLParserParserMODIFY, DorisSQLParserParserMONTH, DorisSQLParserParserMULTIPLE, DorisSQLParserParserNAME, DorisSQLParserParserNAMES, DorisSQLParserParserNEGATIVE, DorisSQLParserParserNGRAMBF, DorisSQLParserParserNO, DorisSQLParserParserNODE, DorisSQLParserParserNODES, DorisSQLParserParserNONE, DorisSQLParserParserNULLS, DorisSQLParserParserNUMBER, DorisSQLParserParserNUMERIC, DorisSQLParserParserOBSERVER, DorisSQLParserParserOF, DorisSQLParserParserOFF, DorisSQLParserParserOFFSET, DorisSQLParserParserONLY, DorisSQLParserParserOPEN, DorisSQLParserParserOPERATE, DorisSQLParserParserOPTIMIZER, DorisSQLParserParserOPTION, DorisSQLParserParserPARTITIONS, DorisSQLParserParserPASSWORD, DorisSQLParserParserPATH, DorisSQLParserParserPAUSE, DorisSQLParserParserPENDING, DorisSQLParserParserPERCENT_RANK, DorisSQLParserParserPERCENTILE_UNION, DorisSQLParserParserPLAN, DorisSQLParserParserPLUGIN, DorisSQLParserParserPLUGINS, DorisSQLParserParserPIPE, DorisSQLParserParserPIPES, DorisSQLParserParserPIVOT, DorisSQLParserParserPOLICY, DorisSQLParserParserPOLICIES, DorisSQLParserParserPRECEDING, DorisSQLParserParserPREDICATE, DorisSQLParserParserPRIORITY, DorisSQLParserParserPRIVILEGES, DorisSQLParserParserPROBABILITY, DorisSQLParserParserPROC, DorisSQLParserParserPROCESSLIST, DorisSQLParserParserPROFILE, DorisSQLParserParserPROFILELIST, DorisSQLParserParserPROPERTIES, DorisSQLParserParserPROPERTY, DorisSQLParserParserPROVIDER, DorisSQLParserParserPROVIDERS, DorisSQLParserParserQUALIFY, DorisSQLParserParserQUARTER, DorisSQLParserParserQUERY, DorisSQLParserParserQUERIES, DorisSQLParserParserQUEUE, DorisSQLParserParserQUOTA, DorisSQLParserParserRANDOM, DorisSQLParserParserRANK, DorisSQLParserParserREASON, DorisSQLParserParserRECOVER, DorisSQLParserParserREFRESH, DorisSQLParserParserREWRITE, DorisSQLParserParserREMOVE, DorisSQLParserParserREPAIR, DorisSQLParserParserREPEATABLE, DorisSQLParserParserREPLACE_IF_NOT_NULL, DorisSQLParserParserREPLICA, DorisSQLParserParserREPOSITORY, DorisSQLParserParserREPOSITORIES, DorisSQLParserParserRESOURCE, DorisSQLParserParserRESOURCES, DorisSQLParserParserRESTORE, DorisSQLParserParserRESUME, DorisSQLParserParserRETAIN, DorisSQLParserParserRETENTION, DorisSQLParserParserRETURNS, DorisSQLParserParserRETRY, DorisSQLParserParserREVERT, DorisSQLParserParserROLE, DorisSQLParserParserROLES, DorisSQLParserParserROLLBACK, DorisSQLParserParserROLLUP, DorisSQLParserParserROUTINE, DorisSQLParserParserROW, DorisSQLParserParserRULE, DorisSQLParserParserRULES, DorisSQLParserParserRUNNING, DorisSQLParserParserSAMPLE, DorisSQLParserParserSCHEDULE, DorisSQLParserParserSCHEDULER, DorisSQLParserParserSECOND, DorisSQLParserParserSECURITY, DorisSQLParserParserSEMI, DorisSQLParserParserSEPARATOR, DorisSQLParserParserSERIALIZABLE, DorisSQLParserParserSESSION, DorisSQLParserParserSETS, DorisSQLParserParserSIGNED, DorisSQLParserParserSKIP_HEADER, DorisSQLParserParserSNAPSHOT, DorisSQLParserParserSNAPSHOTS, DorisSQLParserParserSQLBLACKLIST, DorisSQLParserParserSTART, DorisSQLParserParserSTATS, DorisSQLParserParserSTATUS, DorisSQLParserParserSTOP, DorisSQLParserParserSTORAGE, DorisSQLParserParserSTREAM, DorisSQLParserParserSTRING, DorisSQLParserParserSUBMIT, DorisSQLParserParserSUM, DorisSQLParserParserSUSPEND, DorisSQLParserParserSYNC, DorisSQLParserParserSYSTEM_TIME, DorisSQLParserParserSWAP, DorisSQLParserParserSTRUCT, DorisSQLParserParserTABLES, DorisSQLParserParserTABLET, DorisSQLParserParserTABLETS, DorisSQLParserParserTAG, DorisSQLParserParserTASK, DorisSQLParserParserTEMPORARY, DorisSQLParserParserTHAN, DorisSQLParserParserTIME, DorisSQLParserParserTIMES, DorisSQLParserParserTIMESTAMP, DorisSQLParserParserTIMESTAMPADD, DorisSQLParserParserTIMESTAMPDIFF, DorisSQLParserParserTRANSACTION, DorisSQLParserParserTRANSLATE, DorisSQLParserParserTRACE, DorisSQLParserParserTRIGGERS, DorisSQLParserParserTRIM_SPACE, DorisSQLParserParserTRUNCATE, DorisSQLParserParserTYPE, DorisSQLParserParserTYPES, DorisSQLParserParserUNBOUNDED, DorisSQLParserParserUNCOMMITTED, DorisSQLParserParserUNINSTALL, DorisSQLParserParserUNSET, DorisSQLParserParserUSAGE, DorisSQLParserParserUSER, DorisSQLParserParserUSERS, DorisSQLParserParserVALUE, DorisSQLParserParserVARBINARY, DorisSQLParserParserVARIABLES, DorisSQLParserParserVECTOR, DorisSQLParserParserVERBOSE, DorisSQLParserParserVERSION, DorisSQLParserParserVIEW, DorisSQLParserParserVIEWS, DorisSQLParserParserVOLUME, DorisSQLParserParserVOLUMES, DorisSQLParserParserWAREHOUSE, DorisSQLParserParserWAREHOUSES, DorisSQLParserParserWARNINGS, DorisSQLParserParserWEEK, DorisSQLParserParserWHITELIST, DorisSQLParserParserWORK, DorisSQLParserParserWRITE, DorisSQLParserParserYEAR, DorisSQLParserParserLOCK, DorisSQLParserParserUNLOCK, DorisSQLParserParserLOW_PRIORITY, DorisSQLParserParserDISK, DorisSQLParserParserBEFORE, DorisSQLParserParserFIELD, DorisSQLParserParserPERSISTENT, DorisSQLParserParserARRAY_ELEMENT, DorisSQLParserParserSINGLE_QUOTED_TEXT, DorisSQLParserParserDOUBLE_QUOTED_TEXT, DorisSQLParserParserLETTER_IDENTIFIER, DorisSQLParserParserDIGIT_IDENTIFIER, DorisSQLParserParserBACKQUOTED_IDENTIFIER, DorisSQLParserParserDOTDOTDOT:
		{
			p.SetState(2382)

			var _x = p.IdentifierOrString()

			localctx.(*AdminSetPartitionVersionContext).partitionName = _x
		}

	case DorisSQLParserParserINTEGER_VALUE:
		{
			p.SetState(2383)

			var _m = p.Match(DorisSQLParserParserINTEGER_VALUE)

			localctx.(*AdminSetPartitionVersionContext).partitionId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(2386)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2387)
		p.Match(DorisSQLParserParserVERSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2388)
		p.Match(DorisSQLParserParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2389)

		var _m = p.Match(DorisSQLParserParserINTEGER_VALUE)

		localctx.(*AdminSetPartitionVersionContext).version = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKillStatementContext is an interface to support dynamic dispatch.
type IKillStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetConnId returns the connId token.
	GetConnId() antlr.Token

	// SetConnId sets the connId token.
	SetConnId(antlr.Token)

	// GetQueryId returns the queryId rule contexts.
	GetQueryId() IStringContext

	// SetQueryId sets the queryId rule contexts.
	SetQueryId(IStringContext)

	// Getter signatures
	KILL() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	String_() IStringContext
	CONNECTION() antlr.TerminalNode

	// IsKillStatementContext differentiates from other interfaces.
	IsKillStatementContext()
}

type KillStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	connId  antlr.Token
	queryId IStringContext
}

func NewEmptyKillStatementContext() *KillStatementContext {
	var p = new(KillStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_killStatement
	return p
}

func InitEmptyKillStatementContext(p *KillStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_killStatement
}

func (*KillStatementContext) IsKillStatementContext() {}

func NewKillStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KillStatementContext {
	var p = new(KillStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_killStatement

	return p
}

func (s *KillStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *KillStatementContext) GetConnId() antlr.Token { return s.connId }

func (s *KillStatementContext) SetConnId(v antlr.Token) { s.connId = v }

func (s *KillStatementContext) GetQueryId() IStringContext { return s.queryId }

func (s *KillStatementContext) SetQueryId(v IStringContext) { s.queryId = v }

func (s *KillStatementContext) KILL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserKILL, 0)
}

func (s *KillStatementContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserQUERY, 0)
}

func (s *KillStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, 0)
}

func (s *KillStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *KillStatementContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCONNECTION, 0)
}

func (s *KillStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KillStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterKillStatement(s)
	}
}

func (s *KillStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitKillStatement(s)
	}
}

func (s *KillStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitKillStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) KillStatement() (localctx IKillStatementContext) {
	localctx = NewKillStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, DorisSQLParserParserRULE_killStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2391)
		p.Match(DorisSQLParserParserKILL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2396)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserCONNECTION, DorisSQLParserParserINTEGER_VALUE, DorisSQLParserParserSINGLE_QUOTED_TEXT, DorisSQLParserParserDOUBLE_QUOTED_TEXT:
		p.SetState(2393)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserCONNECTION {
			{
				p.SetState(2392)
				p.Match(DorisSQLParserParserCONNECTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DorisSQLParserParserQUERY:
		{
			p.SetState(2395)
			p.Match(DorisSQLParserParserQUERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(2400)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserINTEGER_VALUE:
		{
			p.SetState(2398)

			var _m = p.Match(DorisSQLParserParserINTEGER_VALUE)

			localctx.(*KillStatementContext).connId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserSINGLE_QUOTED_TEXT, DorisSQLParserParserDOUBLE_QUOTED_TEXT:
		{
			p.SetState(2399)

			var _x = p.String_()

			localctx.(*KillStatementContext).queryId = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISyncStatementContext is an interface to support dynamic dispatch.
type ISyncStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SYNC() antlr.TerminalNode

	// IsSyncStatementContext differentiates from other interfaces.
	IsSyncStatementContext()
}

type SyncStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyncStatementContext() *SyncStatementContext {
	var p = new(SyncStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_syncStatement
	return p
}

func InitEmptySyncStatementContext(p *SyncStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_syncStatement
}

func (*SyncStatementContext) IsSyncStatementContext() {}

func NewSyncStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyncStatementContext {
	var p = new(SyncStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_syncStatement

	return p
}

func (s *SyncStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SyncStatementContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSYNC, 0)
}

func (s *SyncStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyncStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyncStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSyncStatement(s)
	}
}

func (s *SyncStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSyncStatement(s)
	}
}

func (s *SyncStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSyncStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SyncStatement() (localctx ISyncStatementContext) {
	localctx = NewSyncStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, DorisSQLParserParserRULE_syncStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2402)
		p.Match(DorisSQLParserParserSYNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminSetAutomatedSnapshotOnStatementContext is an interface to support dynamic dispatch.
type IAdminSetAutomatedSnapshotOnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSvName returns the svName rule contexts.
	GetSvName() IIdentifierContext

	// SetSvName sets the svName rule contexts.
	SetSvName(IIdentifierContext)

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SET() antlr.TerminalNode
	AUTOMATED() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	ON() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsAdminSetAutomatedSnapshotOnStatementContext differentiates from other interfaces.
	IsAdminSetAutomatedSnapshotOnStatementContext()
}

type AdminSetAutomatedSnapshotOnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	svName IIdentifierContext
}

func NewEmptyAdminSetAutomatedSnapshotOnStatementContext() *AdminSetAutomatedSnapshotOnStatementContext {
	var p = new(AdminSetAutomatedSnapshotOnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_adminSetAutomatedSnapshotOnStatement
	return p
}

func InitEmptyAdminSetAutomatedSnapshotOnStatementContext(p *AdminSetAutomatedSnapshotOnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_adminSetAutomatedSnapshotOnStatement
}

func (*AdminSetAutomatedSnapshotOnStatementContext) IsAdminSetAutomatedSnapshotOnStatementContext() {}

func NewAdminSetAutomatedSnapshotOnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminSetAutomatedSnapshotOnStatementContext {
	var p = new(AdminSetAutomatedSnapshotOnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_adminSetAutomatedSnapshotOnStatement

	return p
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminSetAutomatedSnapshotOnStatementContext) GetSvName() IIdentifierContext { return s.svName }

func (s *AdminSetAutomatedSnapshotOnStatementContext) SetSvName(v IIdentifierContext) { s.svName = v }

func (s *AdminSetAutomatedSnapshotOnStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADMIN, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) AUTOMATED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAUTOMATED, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCLUSTER, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSNAPSHOT, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTORAGE, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVOLUME, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAdminSetAutomatedSnapshotOnStatement(s)
	}
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAdminSetAutomatedSnapshotOnStatement(s)
	}
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAdminSetAutomatedSnapshotOnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AdminSetAutomatedSnapshotOnStatement() (localctx IAdminSetAutomatedSnapshotOnStatementContext) {
	localctx = NewAdminSetAutomatedSnapshotOnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, DorisSQLParserParserRULE_adminSetAutomatedSnapshotOnStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2404)
		p.Match(DorisSQLParserParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2405)
		p.Match(DorisSQLParserParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2406)
		p.Match(DorisSQLParserParserAUTOMATED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2407)
		p.Match(DorisSQLParserParserCLUSTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2408)
		p.Match(DorisSQLParserParserSNAPSHOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2409)
		p.Match(DorisSQLParserParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2413)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserSTORAGE {
		{
			p.SetState(2410)
			p.Match(DorisSQLParserParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2411)
			p.Match(DorisSQLParserParserVOLUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2412)

			var _x = p.Identifier()

			localctx.(*AdminSetAutomatedSnapshotOnStatementContext).svName = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminSetAutomatedSnapshotOffStatementContext is an interface to support dynamic dispatch.
type IAdminSetAutomatedSnapshotOffStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SET() antlr.TerminalNode
	AUTOMATED() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	OFF() antlr.TerminalNode

	// IsAdminSetAutomatedSnapshotOffStatementContext differentiates from other interfaces.
	IsAdminSetAutomatedSnapshotOffStatementContext()
}

type AdminSetAutomatedSnapshotOffStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminSetAutomatedSnapshotOffStatementContext() *AdminSetAutomatedSnapshotOffStatementContext {
	var p = new(AdminSetAutomatedSnapshotOffStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_adminSetAutomatedSnapshotOffStatement
	return p
}

func InitEmptyAdminSetAutomatedSnapshotOffStatementContext(p *AdminSetAutomatedSnapshotOffStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_adminSetAutomatedSnapshotOffStatement
}

func (*AdminSetAutomatedSnapshotOffStatementContext) IsAdminSetAutomatedSnapshotOffStatementContext() {
}

func NewAdminSetAutomatedSnapshotOffStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminSetAutomatedSnapshotOffStatementContext {
	var p = new(AdminSetAutomatedSnapshotOffStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_adminSetAutomatedSnapshotOffStatement

	return p
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminSetAutomatedSnapshotOffStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADMIN, 0)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) AUTOMATED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAUTOMATED, 0)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCLUSTER, 0)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSNAPSHOT, 0)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) OFF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOFF, 0)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAdminSetAutomatedSnapshotOffStatement(s)
	}
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAdminSetAutomatedSnapshotOffStatement(s)
	}
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAdminSetAutomatedSnapshotOffStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AdminSetAutomatedSnapshotOffStatement() (localctx IAdminSetAutomatedSnapshotOffStatementContext) {
	localctx = NewAdminSetAutomatedSnapshotOffStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, DorisSQLParserParserRULE_adminSetAutomatedSnapshotOffStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2415)
		p.Match(DorisSQLParserParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2416)
		p.Match(DorisSQLParserParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2417)
		p.Match(DorisSQLParserParserAUTOMATED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2418)
		p.Match(DorisSQLParserParserCLUSTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2419)
		p.Match(DorisSQLParserParserSNAPSHOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2420)
		p.Match(DorisSQLParserParserOFF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterSystemStatementContext is an interface to support dynamic dispatch.
type IAlterSystemStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	AlterClause() IAlterClauseContext

	// IsAlterSystemStatementContext differentiates from other interfaces.
	IsAlterSystemStatementContext()
}

type AlterSystemStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterSystemStatementContext() *AlterSystemStatementContext {
	var p = new(AlterSystemStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterSystemStatement
	return p
}

func InitEmptyAlterSystemStatementContext(p *AlterSystemStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterSystemStatement
}

func (*AlterSystemStatementContext) IsAlterSystemStatementContext() {}

func NewAlterSystemStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterSystemStatementContext {
	var p = new(AlterSystemStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_alterSystemStatement

	return p
}

func (s *AlterSystemStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterSystemStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *AlterSystemStatementContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSYSTEM, 0)
}

func (s *AlterSystemStatementContext) AlterClause() IAlterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterClauseContext)
}

func (s *AlterSystemStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSystemStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterSystemStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAlterSystemStatement(s)
	}
}

func (s *AlterSystemStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAlterSystemStatement(s)
	}
}

func (s *AlterSystemStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAlterSystemStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AlterSystemStatement() (localctx IAlterSystemStatementContext) {
	localctx = NewAlterSystemStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, DorisSQLParserParserRULE_alterSystemStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2422)
		p.Match(DorisSQLParserParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2423)
		p.Match(DorisSQLParserParserSYSTEM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2424)
		p.AlterClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelAlterSystemStatementContext is an interface to support dynamic dispatch.
type ICancelAlterSystemStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	DECOMMISSION() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsCancelAlterSystemStatementContext differentiates from other interfaces.
	IsCancelAlterSystemStatementContext()
}

type CancelAlterSystemStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelAlterSystemStatementContext() *CancelAlterSystemStatementContext {
	var p = new(CancelAlterSystemStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cancelAlterSystemStatement
	return p
}

func InitEmptyCancelAlterSystemStatementContext(p *CancelAlterSystemStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cancelAlterSystemStatement
}

func (*CancelAlterSystemStatementContext) IsCancelAlterSystemStatementContext() {}

func NewCancelAlterSystemStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelAlterSystemStatementContext {
	var p = new(CancelAlterSystemStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_cancelAlterSystemStatement

	return p
}

func (s *CancelAlterSystemStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelAlterSystemStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCANCEL, 0)
}

func (s *CancelAlterSystemStatementContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDECOMMISSION, 0)
}

func (s *CancelAlterSystemStatementContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBACKEND, 0)
}

func (s *CancelAlterSystemStatementContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *CancelAlterSystemStatementContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CancelAlterSystemStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelAlterSystemStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelAlterSystemStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCancelAlterSystemStatement(s)
	}
}

func (s *CancelAlterSystemStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCancelAlterSystemStatement(s)
	}
}

func (s *CancelAlterSystemStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCancelAlterSystemStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CancelAlterSystemStatement() (localctx ICancelAlterSystemStatementContext) {
	localctx = NewCancelAlterSystemStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, DorisSQLParserParserRULE_cancelAlterSystemStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2426)
		p.Match(DorisSQLParserParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2427)
		p.Match(DorisSQLParserParserDECOMMISSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2428)
		p.Match(DorisSQLParserParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2429)
		p.String_()
	}
	p.SetState(2434)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(2430)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2431)
			p.String_()
		}

		p.SetState(2436)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowComputeNodesStatementContext is an interface to support dynamic dispatch.
type IShowComputeNodesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	COMPUTE() antlr.TerminalNode
	NODES() antlr.TerminalNode

	// IsShowComputeNodesStatementContext differentiates from other interfaces.
	IsShowComputeNodesStatementContext()
}

type ShowComputeNodesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowComputeNodesStatementContext() *ShowComputeNodesStatementContext {
	var p = new(ShowComputeNodesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showComputeNodesStatement
	return p
}

func InitEmptyShowComputeNodesStatementContext(p *ShowComputeNodesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showComputeNodesStatement
}

func (*ShowComputeNodesStatementContext) IsShowComputeNodesStatementContext() {}

func NewShowComputeNodesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowComputeNodesStatementContext {
	var p = new(ShowComputeNodesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showComputeNodesStatement

	return p
}

func (s *ShowComputeNodesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowComputeNodesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowComputeNodesStatementContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOMPUTE, 0)
}

func (s *ShowComputeNodesStatementContext) NODES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNODES, 0)
}

func (s *ShowComputeNodesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowComputeNodesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowComputeNodesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowComputeNodesStatement(s)
	}
}

func (s *ShowComputeNodesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowComputeNodesStatement(s)
	}
}

func (s *ShowComputeNodesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowComputeNodesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowComputeNodesStatement() (localctx IShowComputeNodesStatementContext) {
	localctx = NewShowComputeNodesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, DorisSQLParserParserRULE_showComputeNodesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2437)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2438)
		p.Match(DorisSQLParserParserCOMPUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2439)
		p.Match(DorisSQLParserParserNODES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateExternalCatalogStatementContext is an interface to support dynamic dispatch.
type ICreateExternalCatalogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalogName returns the catalogName rule contexts.
	GetCatalogName() IIdentifierOrStringContext

	// SetCatalogName sets the catalogName rule contexts.
	SetCatalogName(IIdentifierOrStringContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	Properties() IPropertiesContext
	IdentifierOrString() IIdentifierOrStringContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Comment() ICommentContext

	// IsCreateExternalCatalogStatementContext differentiates from other interfaces.
	IsCreateExternalCatalogStatementContext()
}

type CreateExternalCatalogStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	catalogName IIdentifierOrStringContext
}

func NewEmptyCreateExternalCatalogStatementContext() *CreateExternalCatalogStatementContext {
	var p = new(CreateExternalCatalogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createExternalCatalogStatement
	return p
}

func InitEmptyCreateExternalCatalogStatementContext(p *CreateExternalCatalogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createExternalCatalogStatement
}

func (*CreateExternalCatalogStatementContext) IsCreateExternalCatalogStatementContext() {}

func NewCreateExternalCatalogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateExternalCatalogStatementContext {
	var p = new(CreateExternalCatalogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createExternalCatalogStatement

	return p
}

func (s *CreateExternalCatalogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateExternalCatalogStatementContext) GetCatalogName() IIdentifierOrStringContext {
	return s.catalogName
}

func (s *CreateExternalCatalogStatementContext) SetCatalogName(v IIdentifierOrStringContext) {
	s.catalogName = v
}

func (s *CreateExternalCatalogStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateExternalCatalogStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXTERNAL, 0)
}

func (s *CreateExternalCatalogStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCATALOG, 0)
}

func (s *CreateExternalCatalogStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateExternalCatalogStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CreateExternalCatalogStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *CreateExternalCatalogStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *CreateExternalCatalogStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *CreateExternalCatalogStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateExternalCatalogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateExternalCatalogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateExternalCatalogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateExternalCatalogStatement(s)
	}
}

func (s *CreateExternalCatalogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateExternalCatalogStatement(s)
	}
}

func (s *CreateExternalCatalogStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateExternalCatalogStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateExternalCatalogStatement() (localctx ICreateExternalCatalogStatementContext) {
	localctx = NewCreateExternalCatalogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, DorisSQLParserParserRULE_createExternalCatalogStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2441)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2442)
		p.Match(DorisSQLParserParserEXTERNAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2443)
		p.Match(DorisSQLParserParserCATALOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(2444)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2445)
			p.Match(DorisSQLParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2446)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2449)

		var _x = p.IdentifierOrString()

		localctx.(*CreateExternalCatalogStatementContext).catalogName = _x
	}
	p.SetState(2451)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserCOMMENT {
		{
			p.SetState(2450)
			p.Comment()
		}

	}
	{
		p.SetState(2453)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCreateExternalCatalogStatementContext is an interface to support dynamic dispatch.
type IShowCreateExternalCatalogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalogName returns the catalogName rule contexts.
	GetCatalogName() IIdentifierOrStringContext

	// SetCatalogName sets the catalogName rule contexts.
	SetCatalogName(IIdentifierOrStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsShowCreateExternalCatalogStatementContext differentiates from other interfaces.
	IsShowCreateExternalCatalogStatementContext()
}

type ShowCreateExternalCatalogStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	catalogName IIdentifierOrStringContext
}

func NewEmptyShowCreateExternalCatalogStatementContext() *ShowCreateExternalCatalogStatementContext {
	var p = new(ShowCreateExternalCatalogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showCreateExternalCatalogStatement
	return p
}

func InitEmptyShowCreateExternalCatalogStatementContext(p *ShowCreateExternalCatalogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showCreateExternalCatalogStatement
}

func (*ShowCreateExternalCatalogStatementContext) IsShowCreateExternalCatalogStatementContext() {}

func NewShowCreateExternalCatalogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCreateExternalCatalogStatementContext {
	var p = new(ShowCreateExternalCatalogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showCreateExternalCatalogStatement

	return p
}

func (s *ShowCreateExternalCatalogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCreateExternalCatalogStatementContext) GetCatalogName() IIdentifierOrStringContext {
	return s.catalogName
}

func (s *ShowCreateExternalCatalogStatementContext) SetCatalogName(v IIdentifierOrStringContext) {
	s.catalogName = v
}

func (s *ShowCreateExternalCatalogStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowCreateExternalCatalogStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *ShowCreateExternalCatalogStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCATALOG, 0)
}

func (s *ShowCreateExternalCatalogStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *ShowCreateExternalCatalogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateExternalCatalogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCreateExternalCatalogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowCreateExternalCatalogStatement(s)
	}
}

func (s *ShowCreateExternalCatalogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowCreateExternalCatalogStatement(s)
	}
}

func (s *ShowCreateExternalCatalogStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowCreateExternalCatalogStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowCreateExternalCatalogStatement() (localctx IShowCreateExternalCatalogStatementContext) {
	localctx = NewShowCreateExternalCatalogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, DorisSQLParserParserRULE_showCreateExternalCatalogStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2455)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2456)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2457)
		p.Match(DorisSQLParserParserCATALOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2458)

		var _x = p.IdentifierOrString()

		localctx.(*ShowCreateExternalCatalogStatementContext).catalogName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropExternalCatalogStatementContext is an interface to support dynamic dispatch.
type IDropExternalCatalogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalogName returns the catalogName rule contexts.
	GetCatalogName() IIdentifierOrStringContext

	// SetCatalogName sets the catalogName rule contexts.
	SetCatalogName(IIdentifierOrStringContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropExternalCatalogStatementContext differentiates from other interfaces.
	IsDropExternalCatalogStatementContext()
}

type DropExternalCatalogStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	catalogName IIdentifierOrStringContext
}

func NewEmptyDropExternalCatalogStatementContext() *DropExternalCatalogStatementContext {
	var p = new(DropExternalCatalogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropExternalCatalogStatement
	return p
}

func InitEmptyDropExternalCatalogStatementContext(p *DropExternalCatalogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropExternalCatalogStatement
}

func (*DropExternalCatalogStatementContext) IsDropExternalCatalogStatementContext() {}

func NewDropExternalCatalogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropExternalCatalogStatementContext {
	var p = new(DropExternalCatalogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropExternalCatalogStatement

	return p
}

func (s *DropExternalCatalogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropExternalCatalogStatementContext) GetCatalogName() IIdentifierOrStringContext {
	return s.catalogName
}

func (s *DropExternalCatalogStatementContext) SetCatalogName(v IIdentifierOrStringContext) {
	s.catalogName = v
}

func (s *DropExternalCatalogStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropExternalCatalogStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCATALOG, 0)
}

func (s *DropExternalCatalogStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropExternalCatalogStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *DropExternalCatalogStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *DropExternalCatalogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropExternalCatalogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropExternalCatalogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropExternalCatalogStatement(s)
	}
}

func (s *DropExternalCatalogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropExternalCatalogStatement(s)
	}
}

func (s *DropExternalCatalogStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropExternalCatalogStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropExternalCatalogStatement() (localctx IDropExternalCatalogStatementContext) {
	localctx = NewDropExternalCatalogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, DorisSQLParserParserRULE_dropExternalCatalogStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2460)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2461)
		p.Match(DorisSQLParserParserCATALOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2464)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(2462)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2463)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2466)

		var _x = p.IdentifierOrString()

		localctx.(*DropExternalCatalogStatementContext).catalogName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCatalogsStatementContext is an interface to support dynamic dispatch.
type IShowCatalogsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	CATALOGS() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	String_() IStringContext

	// IsShowCatalogsStatementContext differentiates from other interfaces.
	IsShowCatalogsStatementContext()
}

type ShowCatalogsStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowCatalogsStatementContext() *ShowCatalogsStatementContext {
	var p = new(ShowCatalogsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showCatalogsStatement
	return p
}

func InitEmptyShowCatalogsStatementContext(p *ShowCatalogsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showCatalogsStatement
}

func (*ShowCatalogsStatementContext) IsShowCatalogsStatementContext() {}

func NewShowCatalogsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCatalogsStatementContext {
	var p = new(ShowCatalogsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showCatalogsStatement

	return p
}

func (s *ShowCatalogsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCatalogsStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowCatalogsStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowCatalogsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowCatalogsStatementContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCATALOGS, 0)
}

func (s *ShowCatalogsStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *ShowCatalogsStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowCatalogsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCatalogsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCatalogsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowCatalogsStatement(s)
	}
}

func (s *ShowCatalogsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowCatalogsStatement(s)
	}
}

func (s *ShowCatalogsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowCatalogsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowCatalogsStatement() (localctx IShowCatalogsStatementContext) {
	localctx = NewShowCatalogsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, DorisSQLParserParserRULE_showCatalogsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2468)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2469)
		p.Match(DorisSQLParserParserCATALOGS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserLIKE {
		{
			p.SetState(2470)
			p.Match(DorisSQLParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2471)

			var _x = p.String_()

			localctx.(*ShowCatalogsStatementContext).pattern = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterCatalogStatementContext is an interface to support dynamic dispatch.
type IAlterCatalogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalogName returns the catalogName rule contexts.
	GetCatalogName() IIdentifierOrStringContext

	// SetCatalogName sets the catalogName rule contexts.
	SetCatalogName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	ModifyPropertiesClause() IModifyPropertiesClauseContext
	IdentifierOrString() IIdentifierOrStringContext

	// IsAlterCatalogStatementContext differentiates from other interfaces.
	IsAlterCatalogStatementContext()
}

type AlterCatalogStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	catalogName IIdentifierOrStringContext
}

func NewEmptyAlterCatalogStatementContext() *AlterCatalogStatementContext {
	var p = new(AlterCatalogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterCatalogStatement
	return p
}

func InitEmptyAlterCatalogStatementContext(p *AlterCatalogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterCatalogStatement
}

func (*AlterCatalogStatementContext) IsAlterCatalogStatementContext() {}

func NewAlterCatalogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterCatalogStatementContext {
	var p = new(AlterCatalogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_alterCatalogStatement

	return p
}

func (s *AlterCatalogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterCatalogStatementContext) GetCatalogName() IIdentifierOrStringContext {
	return s.catalogName
}

func (s *AlterCatalogStatementContext) SetCatalogName(v IIdentifierOrStringContext) {
	s.catalogName = v
}

func (s *AlterCatalogStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *AlterCatalogStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCATALOG, 0)
}

func (s *AlterCatalogStatementContext) ModifyPropertiesClause() IModifyPropertiesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyPropertiesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyPropertiesClauseContext)
}

func (s *AlterCatalogStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AlterCatalogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterCatalogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterCatalogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAlterCatalogStatement(s)
	}
}

func (s *AlterCatalogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAlterCatalogStatement(s)
	}
}

func (s *AlterCatalogStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAlterCatalogStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AlterCatalogStatement() (localctx IAlterCatalogStatementContext) {
	localctx = NewAlterCatalogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, DorisSQLParserParserRULE_alterCatalogStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2474)
		p.Match(DorisSQLParserParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2475)
		p.Match(DorisSQLParserParserCATALOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2476)

		var _x = p.IdentifierOrString()

		localctx.(*AlterCatalogStatementContext).catalogName = _x
	}
	{
		p.SetState(2477)
		p.ModifyPropertiesClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateStorageVolumeStatementContext is an interface to support dynamic dispatch.
type ICreateStorageVolumeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStorageVolumeName returns the storageVolumeName rule contexts.
	GetStorageVolumeName() IIdentifierOrStringContext

	// SetStorageVolumeName sets the storageVolumeName rule contexts.
	SetStorageVolumeName(IIdentifierOrStringContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	TypeDesc() ITypeDescContext
	LocationsDesc() ILocationsDescContext
	IdentifierOrString() IIdentifierOrStringContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Comment() ICommentContext
	Properties() IPropertiesContext

	// IsCreateStorageVolumeStatementContext differentiates from other interfaces.
	IsCreateStorageVolumeStatementContext()
}

type CreateStorageVolumeStatementContext struct {
	antlr.BaseParserRuleContext
	parser            antlr.Parser
	storageVolumeName IIdentifierOrStringContext
}

func NewEmptyCreateStorageVolumeStatementContext() *CreateStorageVolumeStatementContext {
	var p = new(CreateStorageVolumeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createStorageVolumeStatement
	return p
}

func InitEmptyCreateStorageVolumeStatementContext(p *CreateStorageVolumeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createStorageVolumeStatement
}

func (*CreateStorageVolumeStatementContext) IsCreateStorageVolumeStatementContext() {}

func NewCreateStorageVolumeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateStorageVolumeStatementContext {
	var p = new(CreateStorageVolumeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createStorageVolumeStatement

	return p
}

func (s *CreateStorageVolumeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateStorageVolumeStatementContext) GetStorageVolumeName() IIdentifierOrStringContext {
	return s.storageVolumeName
}

func (s *CreateStorageVolumeStatementContext) SetStorageVolumeName(v IIdentifierOrStringContext) {
	s.storageVolumeName = v
}

func (s *CreateStorageVolumeStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateStorageVolumeStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTORAGE, 0)
}

func (s *CreateStorageVolumeStatementContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVOLUME, 0)
}

func (s *CreateStorageVolumeStatementContext) TypeDesc() ITypeDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDescContext)
}

func (s *CreateStorageVolumeStatementContext) LocationsDesc() ILocationsDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocationsDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocationsDescContext)
}

func (s *CreateStorageVolumeStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CreateStorageVolumeStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *CreateStorageVolumeStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *CreateStorageVolumeStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *CreateStorageVolumeStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateStorageVolumeStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateStorageVolumeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStorageVolumeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateStorageVolumeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateStorageVolumeStatement(s)
	}
}

func (s *CreateStorageVolumeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateStorageVolumeStatement(s)
	}
}

func (s *CreateStorageVolumeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateStorageVolumeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateStorageVolumeStatement() (localctx ICreateStorageVolumeStatementContext) {
	localctx = NewCreateStorageVolumeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, DorisSQLParserParserRULE_createStorageVolumeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2479)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2480)
		p.Match(DorisSQLParserParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2481)
		p.Match(DorisSQLParserParserVOLUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2485)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(2482)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2483)
			p.Match(DorisSQLParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2484)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2487)

		var _x = p.IdentifierOrString()

		localctx.(*CreateStorageVolumeStatementContext).storageVolumeName = _x
	}
	{
		p.SetState(2488)
		p.TypeDesc()
	}
	{
		p.SetState(2489)
		p.LocationsDesc()
	}
	p.SetState(2491)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserCOMMENT {
		{
			p.SetState(2490)
			p.Comment()
		}

	}
	p.SetState(2494)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(2493)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDescContext is an interface to support dynamic dispatch.
type ITypeDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE() antlr.TerminalNode
	EQ() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsTypeDescContext differentiates from other interfaces.
	IsTypeDescContext()
}

type TypeDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDescContext() *TypeDescContext {
	var p = new(TypeDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_typeDesc
	return p
}

func InitEmptyTypeDescContext(p *TypeDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_typeDesc
}

func (*TypeDescContext) IsTypeDescContext() {}

func NewTypeDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDescContext {
	var p = new(TypeDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_typeDesc

	return p
}

func (s *TypeDescContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDescContext) TYPE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTYPE, 0)
}

func (s *TypeDescContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEQ, 0)
}

func (s *TypeDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTypeDesc(s)
	}
}

func (s *TypeDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTypeDesc(s)
	}
}

func (s *TypeDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTypeDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) TypeDesc() (localctx ITypeDescContext) {
	localctx = NewTypeDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, DorisSQLParserParserRULE_typeDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2496)
		p.Match(DorisSQLParserParserTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2497)
		p.Match(DorisSQLParserParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2498)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILocationsDescContext is an interface to support dynamic dispatch.
type ILocationsDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCATIONS() antlr.TerminalNode
	EQ() antlr.TerminalNode
	StringList() IStringListContext

	// IsLocationsDescContext differentiates from other interfaces.
	IsLocationsDescContext()
}

type LocationsDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocationsDescContext() *LocationsDescContext {
	var p = new(LocationsDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_locationsDesc
	return p
}

func InitEmptyLocationsDescContext(p *LocationsDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_locationsDesc
}

func (*LocationsDescContext) IsLocationsDescContext() {}

func NewLocationsDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocationsDescContext {
	var p = new(LocationsDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_locationsDesc

	return p
}

func (s *LocationsDescContext) GetParser() antlr.Parser { return s.parser }

func (s *LocationsDescContext) LOCATIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOCATIONS, 0)
}

func (s *LocationsDescContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEQ, 0)
}

func (s *LocationsDescContext) StringList() IStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringListContext)
}

func (s *LocationsDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocationsDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocationsDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterLocationsDesc(s)
	}
}

func (s *LocationsDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitLocationsDesc(s)
	}
}

func (s *LocationsDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitLocationsDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) LocationsDesc() (localctx ILocationsDescContext) {
	localctx = NewLocationsDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, DorisSQLParserParserRULE_locationsDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2500)
		p.Match(DorisSQLParserParserLOCATIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2501)
		p.Match(DorisSQLParserParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2502)
		p.StringList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowStorageVolumesStatementContext is an interface to support dynamic dispatch.
type IShowStorageVolumesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUMES() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	String_() IStringContext

	// IsShowStorageVolumesStatementContext differentiates from other interfaces.
	IsShowStorageVolumesStatementContext()
}

type ShowStorageVolumesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowStorageVolumesStatementContext() *ShowStorageVolumesStatementContext {
	var p = new(ShowStorageVolumesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showStorageVolumesStatement
	return p
}

func InitEmptyShowStorageVolumesStatementContext(p *ShowStorageVolumesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showStorageVolumesStatement
}

func (*ShowStorageVolumesStatementContext) IsShowStorageVolumesStatementContext() {}

func NewShowStorageVolumesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStorageVolumesStatementContext {
	var p = new(ShowStorageVolumesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showStorageVolumesStatement

	return p
}

func (s *ShowStorageVolumesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStorageVolumesStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowStorageVolumesStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowStorageVolumesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowStorageVolumesStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTORAGE, 0)
}

func (s *ShowStorageVolumesStatementContext) VOLUMES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVOLUMES, 0)
}

func (s *ShowStorageVolumesStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *ShowStorageVolumesStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowStorageVolumesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStorageVolumesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowStorageVolumesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowStorageVolumesStatement(s)
	}
}

func (s *ShowStorageVolumesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowStorageVolumesStatement(s)
	}
}

func (s *ShowStorageVolumesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowStorageVolumesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowStorageVolumesStatement() (localctx IShowStorageVolumesStatementContext) {
	localctx = NewShowStorageVolumesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, DorisSQLParserParserRULE_showStorageVolumesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2504)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2505)
		p.Match(DorisSQLParserParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2506)
		p.Match(DorisSQLParserParserVOLUMES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2509)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserLIKE {
		{
			p.SetState(2507)
			p.Match(DorisSQLParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2508)

			var _x = p.String_()

			localctx.(*ShowStorageVolumesStatementContext).pattern = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropStorageVolumeStatementContext is an interface to support dynamic dispatch.
type IDropStorageVolumeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStorageVolumeName returns the storageVolumeName rule contexts.
	GetStorageVolumeName() IIdentifierOrStringContext

	// SetStorageVolumeName sets the storageVolumeName rule contexts.
	SetStorageVolumeName(IIdentifierOrStringContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropStorageVolumeStatementContext differentiates from other interfaces.
	IsDropStorageVolumeStatementContext()
}

type DropStorageVolumeStatementContext struct {
	antlr.BaseParserRuleContext
	parser            antlr.Parser
	storageVolumeName IIdentifierOrStringContext
}

func NewEmptyDropStorageVolumeStatementContext() *DropStorageVolumeStatementContext {
	var p = new(DropStorageVolumeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropStorageVolumeStatement
	return p
}

func InitEmptyDropStorageVolumeStatementContext(p *DropStorageVolumeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropStorageVolumeStatement
}

func (*DropStorageVolumeStatementContext) IsDropStorageVolumeStatementContext() {}

func NewDropStorageVolumeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropStorageVolumeStatementContext {
	var p = new(DropStorageVolumeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropStorageVolumeStatement

	return p
}

func (s *DropStorageVolumeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropStorageVolumeStatementContext) GetStorageVolumeName() IIdentifierOrStringContext {
	return s.storageVolumeName
}

func (s *DropStorageVolumeStatementContext) SetStorageVolumeName(v IIdentifierOrStringContext) {
	s.storageVolumeName = v
}

func (s *DropStorageVolumeStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropStorageVolumeStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTORAGE, 0)
}

func (s *DropStorageVolumeStatementContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVOLUME, 0)
}

func (s *DropStorageVolumeStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropStorageVolumeStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *DropStorageVolumeStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *DropStorageVolumeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStorageVolumeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropStorageVolumeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropStorageVolumeStatement(s)
	}
}

func (s *DropStorageVolumeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropStorageVolumeStatement(s)
	}
}

func (s *DropStorageVolumeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropStorageVolumeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropStorageVolumeStatement() (localctx IDropStorageVolumeStatementContext) {
	localctx = NewDropStorageVolumeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, DorisSQLParserParserRULE_dropStorageVolumeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2511)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2512)
		p.Match(DorisSQLParserParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2513)
		p.Match(DorisSQLParserParserVOLUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2516)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(2514)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2515)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2518)

		var _x = p.IdentifierOrString()

		localctx.(*DropStorageVolumeStatementContext).storageVolumeName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterStorageVolumeStatementContext is an interface to support dynamic dispatch.
type IAlterStorageVolumeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	AllAlterStorageVolumeClause() []IAlterStorageVolumeClauseContext
	AlterStorageVolumeClause(i int) IAlterStorageVolumeClauseContext

	// IsAlterStorageVolumeStatementContext differentiates from other interfaces.
	IsAlterStorageVolumeStatementContext()
}

type AlterStorageVolumeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStorageVolumeStatementContext() *AlterStorageVolumeStatementContext {
	var p = new(AlterStorageVolumeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterStorageVolumeStatement
	return p
}

func InitEmptyAlterStorageVolumeStatementContext(p *AlterStorageVolumeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterStorageVolumeStatement
}

func (*AlterStorageVolumeStatementContext) IsAlterStorageVolumeStatementContext() {}

func NewAlterStorageVolumeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStorageVolumeStatementContext {
	var p = new(AlterStorageVolumeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_alterStorageVolumeStatement

	return p
}

func (s *AlterStorageVolumeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStorageVolumeStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *AlterStorageVolumeStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTORAGE, 0)
}

func (s *AlterStorageVolumeStatementContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVOLUME, 0)
}

func (s *AlterStorageVolumeStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AlterStorageVolumeStatementContext) AllAlterStorageVolumeClause() []IAlterStorageVolumeClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterStorageVolumeClauseContext); ok {
			len++
		}
	}

	tst := make([]IAlterStorageVolumeClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterStorageVolumeClauseContext); ok {
			tst[i] = t.(IAlterStorageVolumeClauseContext)
			i++
		}
	}

	return tst
}

func (s *AlterStorageVolumeStatementContext) AlterStorageVolumeClause(i int) IAlterStorageVolumeClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStorageVolumeClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStorageVolumeClauseContext)
}

func (s *AlterStorageVolumeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStorageVolumeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterStorageVolumeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAlterStorageVolumeStatement(s)
	}
}

func (s *AlterStorageVolumeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAlterStorageVolumeStatement(s)
	}
}

func (s *AlterStorageVolumeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAlterStorageVolumeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AlterStorageVolumeStatement() (localctx IAlterStorageVolumeStatementContext) {
	localctx = NewAlterStorageVolumeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, DorisSQLParserParserRULE_alterStorageVolumeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2520)
		p.Match(DorisSQLParserParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2521)
		p.Match(DorisSQLParserParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2522)
		p.Match(DorisSQLParserParserVOLUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2523)
		p.IdentifierOrString()
	}
	{
		p.SetState(2524)
		p.AlterStorageVolumeClause()
	}
	p.SetState(2529)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(2525)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2526)
			p.AlterStorageVolumeClause()
		}

		p.SetState(2531)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterStorageVolumeClauseContext is an interface to support dynamic dispatch.
type IAlterStorageVolumeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ModifyStorageVolumeCommentClause() IModifyStorageVolumeCommentClauseContext
	ModifyStorageVolumePropertiesClause() IModifyStorageVolumePropertiesClauseContext

	// IsAlterStorageVolumeClauseContext differentiates from other interfaces.
	IsAlterStorageVolumeClauseContext()
}

type AlterStorageVolumeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStorageVolumeClauseContext() *AlterStorageVolumeClauseContext {
	var p = new(AlterStorageVolumeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterStorageVolumeClause
	return p
}

func InitEmptyAlterStorageVolumeClauseContext(p *AlterStorageVolumeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterStorageVolumeClause
}

func (*AlterStorageVolumeClauseContext) IsAlterStorageVolumeClauseContext() {}

func NewAlterStorageVolumeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStorageVolumeClauseContext {
	var p = new(AlterStorageVolumeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_alterStorageVolumeClause

	return p
}

func (s *AlterStorageVolumeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStorageVolumeClauseContext) ModifyStorageVolumeCommentClause() IModifyStorageVolumeCommentClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyStorageVolumeCommentClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyStorageVolumeCommentClauseContext)
}

func (s *AlterStorageVolumeClauseContext) ModifyStorageVolumePropertiesClause() IModifyStorageVolumePropertiesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyStorageVolumePropertiesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyStorageVolumePropertiesClauseContext)
}

func (s *AlterStorageVolumeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStorageVolumeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterStorageVolumeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAlterStorageVolumeClause(s)
	}
}

func (s *AlterStorageVolumeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAlterStorageVolumeClause(s)
	}
}

func (s *AlterStorageVolumeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAlterStorageVolumeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AlterStorageVolumeClause() (localctx IAlterStorageVolumeClauseContext) {
	localctx = NewAlterStorageVolumeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, DorisSQLParserParserRULE_alterStorageVolumeClause)
	p.SetState(2534)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserCOMMENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2532)
			p.ModifyStorageVolumeCommentClause()
		}

	case DorisSQLParserParserSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2533)
			p.ModifyStorageVolumePropertiesClause()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyStorageVolumePropertiesClauseContext is an interface to support dynamic dispatch.
type IModifyStorageVolumePropertiesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsModifyStorageVolumePropertiesClauseContext differentiates from other interfaces.
	IsModifyStorageVolumePropertiesClauseContext()
}

type ModifyStorageVolumePropertiesClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyStorageVolumePropertiesClauseContext() *ModifyStorageVolumePropertiesClauseContext {
	var p = new(ModifyStorageVolumePropertiesClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_modifyStorageVolumePropertiesClause
	return p
}

func InitEmptyModifyStorageVolumePropertiesClauseContext(p *ModifyStorageVolumePropertiesClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_modifyStorageVolumePropertiesClause
}

func (*ModifyStorageVolumePropertiesClauseContext) IsModifyStorageVolumePropertiesClauseContext() {}

func NewModifyStorageVolumePropertiesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyStorageVolumePropertiesClauseContext {
	var p = new(ModifyStorageVolumePropertiesClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_modifyStorageVolumePropertiesClause

	return p
}

func (s *ModifyStorageVolumePropertiesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyStorageVolumePropertiesClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *ModifyStorageVolumePropertiesClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *ModifyStorageVolumePropertiesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyStorageVolumePropertiesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyStorageVolumePropertiesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterModifyStorageVolumePropertiesClause(s)
	}
}

func (s *ModifyStorageVolumePropertiesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitModifyStorageVolumePropertiesClause(s)
	}
}

func (s *ModifyStorageVolumePropertiesClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitModifyStorageVolumePropertiesClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ModifyStorageVolumePropertiesClause() (localctx IModifyStorageVolumePropertiesClauseContext) {
	localctx = NewModifyStorageVolumePropertiesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, DorisSQLParserParserRULE_modifyStorageVolumePropertiesClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2536)
		p.Match(DorisSQLParserParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2537)
		p.PropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyStorageVolumeCommentClauseContext is an interface to support dynamic dispatch.
type IModifyStorageVolumeCommentClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMENT() antlr.TerminalNode
	EQ() antlr.TerminalNode
	String_() IStringContext

	// IsModifyStorageVolumeCommentClauseContext differentiates from other interfaces.
	IsModifyStorageVolumeCommentClauseContext()
}

type ModifyStorageVolumeCommentClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyStorageVolumeCommentClauseContext() *ModifyStorageVolumeCommentClauseContext {
	var p = new(ModifyStorageVolumeCommentClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_modifyStorageVolumeCommentClause
	return p
}

func InitEmptyModifyStorageVolumeCommentClauseContext(p *ModifyStorageVolumeCommentClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_modifyStorageVolumeCommentClause
}

func (*ModifyStorageVolumeCommentClauseContext) IsModifyStorageVolumeCommentClauseContext() {}

func NewModifyStorageVolumeCommentClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyStorageVolumeCommentClauseContext {
	var p = new(ModifyStorageVolumeCommentClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_modifyStorageVolumeCommentClause

	return p
}

func (s *ModifyStorageVolumeCommentClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyStorageVolumeCommentClauseContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOMMENT, 0)
}

func (s *ModifyStorageVolumeCommentClauseContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEQ, 0)
}

func (s *ModifyStorageVolumeCommentClauseContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ModifyStorageVolumeCommentClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyStorageVolumeCommentClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyStorageVolumeCommentClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterModifyStorageVolumeCommentClause(s)
	}
}

func (s *ModifyStorageVolumeCommentClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitModifyStorageVolumeCommentClause(s)
	}
}

func (s *ModifyStorageVolumeCommentClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitModifyStorageVolumeCommentClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ModifyStorageVolumeCommentClause() (localctx IModifyStorageVolumeCommentClauseContext) {
	localctx = NewModifyStorageVolumeCommentClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, DorisSQLParserParserRULE_modifyStorageVolumeCommentClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2539)
		p.Match(DorisSQLParserParserCOMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2540)
		p.Match(DorisSQLParserParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2541)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescStorageVolumeStatementContext is an interface to support dynamic dispatch.
type IDescStorageVolumeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode

	// IsDescStorageVolumeStatementContext differentiates from other interfaces.
	IsDescStorageVolumeStatementContext()
}

type DescStorageVolumeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescStorageVolumeStatementContext() *DescStorageVolumeStatementContext {
	var p = new(DescStorageVolumeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_descStorageVolumeStatement
	return p
}

func InitEmptyDescStorageVolumeStatementContext(p *DescStorageVolumeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_descStorageVolumeStatement
}

func (*DescStorageVolumeStatementContext) IsDescStorageVolumeStatementContext() {}

func NewDescStorageVolumeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescStorageVolumeStatementContext {
	var p = new(DescStorageVolumeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_descStorageVolumeStatement

	return p
}

func (s *DescStorageVolumeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DescStorageVolumeStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTORAGE, 0)
}

func (s *DescStorageVolumeStatementContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVOLUME, 0)
}

func (s *DescStorageVolumeStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DescStorageVolumeStatementContext) DESC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDESC, 0)
}

func (s *DescStorageVolumeStatementContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDESCRIBE, 0)
}

func (s *DescStorageVolumeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescStorageVolumeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescStorageVolumeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDescStorageVolumeStatement(s)
	}
}

func (s *DescStorageVolumeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDescStorageVolumeStatement(s)
	}
}

func (s *DescStorageVolumeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDescStorageVolumeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DescStorageVolumeStatement() (localctx IDescStorageVolumeStatementContext) {
	localctx = NewDescStorageVolumeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, DorisSQLParserParserRULE_descStorageVolumeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2543)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserDESC || _la == DorisSQLParserParserDESCRIBE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2544)
		p.Match(DorisSQLParserParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2545)
		p.Match(DorisSQLParserParserVOLUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2546)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetDefaultStorageVolumeStatementContext is an interface to support dynamic dispatch.
type ISetDefaultStorageVolumeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	AS() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode

	// IsSetDefaultStorageVolumeStatementContext differentiates from other interfaces.
	IsSetDefaultStorageVolumeStatementContext()
}

type SetDefaultStorageVolumeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetDefaultStorageVolumeStatementContext() *SetDefaultStorageVolumeStatementContext {
	var p = new(SetDefaultStorageVolumeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_setDefaultStorageVolumeStatement
	return p
}

func InitEmptySetDefaultStorageVolumeStatementContext(p *SetDefaultStorageVolumeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_setDefaultStorageVolumeStatement
}

func (*SetDefaultStorageVolumeStatementContext) IsSetDefaultStorageVolumeStatementContext() {}

func NewSetDefaultStorageVolumeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetDefaultStorageVolumeStatementContext {
	var p = new(SetDefaultStorageVolumeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_setDefaultStorageVolumeStatement

	return p
}

func (s *SetDefaultStorageVolumeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetDefaultStorageVolumeStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *SetDefaultStorageVolumeStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *SetDefaultStorageVolumeStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *SetDefaultStorageVolumeStatementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDEFAULT, 0)
}

func (s *SetDefaultStorageVolumeStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTORAGE, 0)
}

func (s *SetDefaultStorageVolumeStatementContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVOLUME, 0)
}

func (s *SetDefaultStorageVolumeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetDefaultStorageVolumeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetDefaultStorageVolumeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSetDefaultStorageVolumeStatement(s)
	}
}

func (s *SetDefaultStorageVolumeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSetDefaultStorageVolumeStatement(s)
	}
}

func (s *SetDefaultStorageVolumeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSetDefaultStorageVolumeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SetDefaultStorageVolumeStatement() (localctx ISetDefaultStorageVolumeStatementContext) {
	localctx = NewSetDefaultStorageVolumeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, DorisSQLParserParserRULE_setDefaultStorageVolumeStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2548)
		p.Match(DorisSQLParserParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2549)
		p.IdentifierOrString()
	}
	{
		p.SetState(2550)
		p.Match(DorisSQLParserParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2551)
		p.Match(DorisSQLParserParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2552)
		p.Match(DorisSQLParserParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2553)
		p.Match(DorisSQLParserParserVOLUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateFailPointStatusStatementContext is an interface to support dynamic dispatch.
type IUpdateFailPointStatusStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTimes returns the times token.
	GetTimes() antlr.Token

	// GetProb returns the prob token.
	GetProb() antlr.Token

	// SetTimes sets the times token.
	SetTimes(antlr.Token)

	// SetProb sets the prob token.
	SetProb(antlr.Token)

	// Getter signatures
	ADMIN() antlr.TerminalNode
	FAILPOINT() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	DISABLE() antlr.TerminalNode
	ENABLE() antlr.TerminalNode
	WITH() antlr.TerminalNode
	ON() antlr.TerminalNode
	TIMES() antlr.TerminalNode
	PROBABILITY() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	FRONTEND() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	DECIMAL_VALUE() antlr.TerminalNode

	// IsUpdateFailPointStatusStatementContext differentiates from other interfaces.
	IsUpdateFailPointStatusStatementContext()
}

type UpdateFailPointStatusStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	times  antlr.Token
	prob   antlr.Token
}

func NewEmptyUpdateFailPointStatusStatementContext() *UpdateFailPointStatusStatementContext {
	var p = new(UpdateFailPointStatusStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_updateFailPointStatusStatement
	return p
}

func InitEmptyUpdateFailPointStatusStatementContext(p *UpdateFailPointStatusStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_updateFailPointStatusStatement
}

func (*UpdateFailPointStatusStatementContext) IsUpdateFailPointStatusStatementContext() {}

func NewUpdateFailPointStatusStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateFailPointStatusStatementContext {
	var p = new(UpdateFailPointStatusStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_updateFailPointStatusStatement

	return p
}

func (s *UpdateFailPointStatusStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateFailPointStatusStatementContext) GetTimes() antlr.Token { return s.times }

func (s *UpdateFailPointStatusStatementContext) GetProb() antlr.Token { return s.prob }

func (s *UpdateFailPointStatusStatementContext) SetTimes(v antlr.Token) { s.times = v }

func (s *UpdateFailPointStatusStatementContext) SetProb(v antlr.Token) { s.prob = v }

func (s *UpdateFailPointStatusStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADMIN, 0)
}

func (s *UpdateFailPointStatusStatementContext) FAILPOINT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFAILPOINT, 0)
}

func (s *UpdateFailPointStatusStatementContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *UpdateFailPointStatusStatementContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *UpdateFailPointStatusStatementContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDISABLE, 0)
}

func (s *UpdateFailPointStatusStatementContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserENABLE, 0)
}

func (s *UpdateFailPointStatusStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *UpdateFailPointStatusStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *UpdateFailPointStatusStatementContext) TIMES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTIMES, 0)
}

func (s *UpdateFailPointStatusStatementContext) PROBABILITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROBABILITY, 0)
}

func (s *UpdateFailPointStatusStatementContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBACKEND, 0)
}

func (s *UpdateFailPointStatusStatementContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFRONTEND, 0)
}

func (s *UpdateFailPointStatusStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, 0)
}

func (s *UpdateFailPointStatusStatementContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDECIMAL_VALUE, 0)
}

func (s *UpdateFailPointStatusStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateFailPointStatusStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateFailPointStatusStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterUpdateFailPointStatusStatement(s)
	}
}

func (s *UpdateFailPointStatusStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitUpdateFailPointStatusStatement(s)
	}
}

func (s *UpdateFailPointStatusStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitUpdateFailPointStatusStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) UpdateFailPointStatusStatement() (localctx IUpdateFailPointStatusStatementContext) {
	localctx = NewUpdateFailPointStatusStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, DorisSQLParserParserRULE_updateFailPointStatusStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2555)
		p.Match(DorisSQLParserParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2556)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserDISABLE || _la == DorisSQLParserParserENABLE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2557)
		p.Match(DorisSQLParserParserFAILPOINT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2558)
		p.String_()
	}
	p.SetState(2566)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWITH {
		{
			p.SetState(2559)
			p.Match(DorisSQLParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2564)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserParserINTEGER_VALUE:
			{
				p.SetState(2560)

				var _m = p.Match(DorisSQLParserParserINTEGER_VALUE)

				localctx.(*UpdateFailPointStatusStatementContext).times = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2561)
				p.Match(DorisSQLParserParserTIMES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisSQLParserParserDECIMAL_VALUE:
			{
				p.SetState(2562)

				var _m = p.Match(DorisSQLParserParserDECIMAL_VALUE)

				localctx.(*UpdateFailPointStatusStatementContext).prob = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2563)
				p.Match(DorisSQLParserParserPROBABILITY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(2574)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserON {
		{
			p.SetState(2568)
			p.Match(DorisSQLParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2572)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserParserBACKEND:
			{
				p.SetState(2569)
				p.Match(DorisSQLParserParserBACKEND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2570)
				p.String_()
			}

		case DorisSQLParserParserFRONTEND:
			{
				p.SetState(2571)
				p.Match(DorisSQLParserParserFRONTEND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowFailPointStatementContext is an interface to support dynamic dispatch.
type IShowFailPointStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	FAILPOINTS() antlr.TerminalNode
	ON() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	LIKE() antlr.TerminalNode

	// IsShowFailPointStatementContext differentiates from other interfaces.
	IsShowFailPointStatementContext()
}

type ShowFailPointStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowFailPointStatementContext() *ShowFailPointStatementContext {
	var p = new(ShowFailPointStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showFailPointStatement
	return p
}

func InitEmptyShowFailPointStatementContext(p *ShowFailPointStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showFailPointStatement
}

func (*ShowFailPointStatementContext) IsShowFailPointStatementContext() {}

func NewShowFailPointStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowFailPointStatementContext {
	var p = new(ShowFailPointStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showFailPointStatement

	return p
}

func (s *ShowFailPointStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowFailPointStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowFailPointStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowFailPointStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowFailPointStatementContext) FAILPOINTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFAILPOINTS, 0)
}

func (s *ShowFailPointStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *ShowFailPointStatementContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBACKEND, 0)
}

func (s *ShowFailPointStatementContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ShowFailPointStatementContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowFailPointStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *ShowFailPointStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFailPointStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowFailPointStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowFailPointStatement(s)
	}
}

func (s *ShowFailPointStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowFailPointStatement(s)
	}
}

func (s *ShowFailPointStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowFailPointStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowFailPointStatement() (localctx IShowFailPointStatementContext) {
	localctx = NewShowFailPointStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, DorisSQLParserParserRULE_showFailPointStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2576)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2577)
		p.Match(DorisSQLParserParserFAILPOINTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2580)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserLIKE {
		{
			p.SetState(2578)
			p.Match(DorisSQLParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2579)

			var _x = p.String_()

			localctx.(*ShowFailPointStatementContext).pattern = _x
		}

	}
	p.SetState(2585)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserON {
		{
			p.SetState(2582)
			p.Match(DorisSQLParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2583)
			p.Match(DorisSQLParserParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2584)
			p.String_()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDictionaryStatementContext is an interface to support dynamic dispatch.
type ICreateDictionaryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	DictionaryName() IDictionaryNameContext
	USING() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AllDictionaryColumnDesc() []IDictionaryColumnDescContext
	DictionaryColumnDesc(i int) IDictionaryColumnDescContext
	Properties() IPropertiesContext

	// IsCreateDictionaryStatementContext differentiates from other interfaces.
	IsCreateDictionaryStatementContext()
}

type CreateDictionaryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDictionaryStatementContext() *CreateDictionaryStatementContext {
	var p = new(CreateDictionaryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createDictionaryStatement
	return p
}

func InitEmptyCreateDictionaryStatementContext(p *CreateDictionaryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createDictionaryStatement
}

func (*CreateDictionaryStatementContext) IsCreateDictionaryStatementContext() {}

func NewCreateDictionaryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDictionaryStatementContext {
	var p = new(CreateDictionaryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createDictionaryStatement

	return p
}

func (s *CreateDictionaryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDictionaryStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateDictionaryStatementContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDICTIONARY, 0)
}

func (s *CreateDictionaryStatementContext) DictionaryName() IDictionaryNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDictionaryNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDictionaryNameContext)
}

func (s *CreateDictionaryStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSING, 0)
}

func (s *CreateDictionaryStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateDictionaryStatementContext) AllDictionaryColumnDesc() []IDictionaryColumnDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDictionaryColumnDescContext); ok {
			len++
		}
	}

	tst := make([]IDictionaryColumnDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDictionaryColumnDescContext); ok {
			tst[i] = t.(IDictionaryColumnDescContext)
			i++
		}
	}

	return tst
}

func (s *CreateDictionaryStatementContext) DictionaryColumnDesc(i int) IDictionaryColumnDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDictionaryColumnDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDictionaryColumnDescContext)
}

func (s *CreateDictionaryStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateDictionaryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDictionaryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDictionaryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateDictionaryStatement(s)
	}
}

func (s *CreateDictionaryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateDictionaryStatement(s)
	}
}

func (s *CreateDictionaryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateDictionaryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateDictionaryStatement() (localctx ICreateDictionaryStatementContext) {
	localctx = NewCreateDictionaryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, DorisSQLParserParserRULE_createDictionaryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2587)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2588)
		p.Match(DorisSQLParserParserDICTIONARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2589)
		p.DictionaryName()
	}
	{
		p.SetState(2590)
		p.Match(DorisSQLParserParserUSING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2591)
		p.QualifiedName()
	}
	{
		p.SetState(2592)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2593)
		p.DictionaryColumnDesc()
	}
	p.SetState(2598)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(2594)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2595)
			p.DictionaryColumnDesc()
		}

		p.SetState(2600)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2601)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2603)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(2602)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropDictionaryStatementContext is an interface to support dynamic dispatch.
type IDropDictionaryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	CACHE() antlr.TerminalNode

	// IsDropDictionaryStatementContext differentiates from other interfaces.
	IsDropDictionaryStatementContext()
}

type DropDictionaryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropDictionaryStatementContext() *DropDictionaryStatementContext {
	var p = new(DropDictionaryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropDictionaryStatement
	return p
}

func InitEmptyDropDictionaryStatementContext(p *DropDictionaryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropDictionaryStatement
}

func (*DropDictionaryStatementContext) IsDropDictionaryStatementContext() {}

func NewDropDictionaryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropDictionaryStatementContext {
	var p = new(DropDictionaryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropDictionaryStatement

	return p
}

func (s *DropDictionaryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropDictionaryStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropDictionaryStatementContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDICTIONARY, 0)
}

func (s *DropDictionaryStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropDictionaryStatementContext) CACHE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCACHE, 0)
}

func (s *DropDictionaryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDictionaryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropDictionaryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropDictionaryStatement(s)
	}
}

func (s *DropDictionaryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropDictionaryStatement(s)
	}
}

func (s *DropDictionaryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropDictionaryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropDictionaryStatement() (localctx IDropDictionaryStatementContext) {
	localctx = NewDropDictionaryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, DorisSQLParserParserRULE_dropDictionaryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2605)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2606)
		p.Match(DorisSQLParserParserDICTIONARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2607)
		p.QualifiedName()
	}
	p.SetState(2609)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserCACHE {
		{
			p.SetState(2608)
			p.Match(DorisSQLParserParserCACHE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshDictionaryStatementContext is an interface to support dynamic dispatch.
type IRefreshDictionaryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REFRESH() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsRefreshDictionaryStatementContext differentiates from other interfaces.
	IsRefreshDictionaryStatementContext()
}

type RefreshDictionaryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefreshDictionaryStatementContext() *RefreshDictionaryStatementContext {
	var p = new(RefreshDictionaryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_refreshDictionaryStatement
	return p
}

func InitEmptyRefreshDictionaryStatementContext(p *RefreshDictionaryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_refreshDictionaryStatement
}

func (*RefreshDictionaryStatementContext) IsRefreshDictionaryStatementContext() {}

func NewRefreshDictionaryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshDictionaryStatementContext {
	var p = new(RefreshDictionaryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_refreshDictionaryStatement

	return p
}

func (s *RefreshDictionaryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshDictionaryStatementContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREFRESH, 0)
}

func (s *RefreshDictionaryStatementContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDICTIONARY, 0)
}

func (s *RefreshDictionaryStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RefreshDictionaryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshDictionaryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshDictionaryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRefreshDictionaryStatement(s)
	}
}

func (s *RefreshDictionaryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRefreshDictionaryStatement(s)
	}
}

func (s *RefreshDictionaryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRefreshDictionaryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) RefreshDictionaryStatement() (localctx IRefreshDictionaryStatementContext) {
	localctx = NewRefreshDictionaryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, DorisSQLParserParserRULE_refreshDictionaryStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2611)
		p.Match(DorisSQLParserParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2612)
		p.Match(DorisSQLParserParserDICTIONARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2613)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDictionaryStatementContext is an interface to support dynamic dispatch.
type IShowDictionaryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowDictionaryStatementContext differentiates from other interfaces.
	IsShowDictionaryStatementContext()
}

type ShowDictionaryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowDictionaryStatementContext() *ShowDictionaryStatementContext {
	var p = new(ShowDictionaryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showDictionaryStatement
	return p
}

func InitEmptyShowDictionaryStatementContext(p *ShowDictionaryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showDictionaryStatement
}

func (*ShowDictionaryStatementContext) IsShowDictionaryStatementContext() {}

func NewShowDictionaryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDictionaryStatementContext {
	var p = new(ShowDictionaryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showDictionaryStatement

	return p
}

func (s *ShowDictionaryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDictionaryStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowDictionaryStatementContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDICTIONARY, 0)
}

func (s *ShowDictionaryStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowDictionaryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDictionaryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDictionaryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowDictionaryStatement(s)
	}
}

func (s *ShowDictionaryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowDictionaryStatement(s)
	}
}

func (s *ShowDictionaryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowDictionaryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowDictionaryStatement() (localctx IShowDictionaryStatementContext) {
	localctx = NewShowDictionaryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, DorisSQLParserParserRULE_showDictionaryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2615)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2616)
		p.Match(DorisSQLParserParserDICTIONARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2618)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262756702208) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-6664167256628462851) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-1331487429127569487) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&-7546427580836201) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-4573491655345179) != 0) || ((int64((_la-324)) & ^0x3f) == 0 && ((int64(1)<<(_la-324))&9114828243924942831) != 0) || ((int64((_la-389)) & ^0x3f) == 0 && ((int64(1)<<(_la-389))&-6956096606152176261) != 0) || ((int64((_la-453)) & ^0x3f) == 0 && ((int64(1)<<(_la-453))&70849595962729) != 0) || ((int64((_la-525)) & ^0x3f) == 0 && ((int64(1)<<(_la-525))&263) != 0) {
		{
			p.SetState(2617)
			p.QualifiedName()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelRefreshDictionaryStatementContext is an interface to support dynamic dispatch.
type ICancelRefreshDictionaryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	REFRESH() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsCancelRefreshDictionaryStatementContext differentiates from other interfaces.
	IsCancelRefreshDictionaryStatementContext()
}

type CancelRefreshDictionaryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelRefreshDictionaryStatementContext() *CancelRefreshDictionaryStatementContext {
	var p = new(CancelRefreshDictionaryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cancelRefreshDictionaryStatement
	return p
}

func InitEmptyCancelRefreshDictionaryStatementContext(p *CancelRefreshDictionaryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cancelRefreshDictionaryStatement
}

func (*CancelRefreshDictionaryStatementContext) IsCancelRefreshDictionaryStatementContext() {}

func NewCancelRefreshDictionaryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelRefreshDictionaryStatementContext {
	var p = new(CancelRefreshDictionaryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_cancelRefreshDictionaryStatement

	return p
}

func (s *CancelRefreshDictionaryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelRefreshDictionaryStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCANCEL, 0)
}

func (s *CancelRefreshDictionaryStatementContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREFRESH, 0)
}

func (s *CancelRefreshDictionaryStatementContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDICTIONARY, 0)
}

func (s *CancelRefreshDictionaryStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CancelRefreshDictionaryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelRefreshDictionaryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelRefreshDictionaryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCancelRefreshDictionaryStatement(s)
	}
}

func (s *CancelRefreshDictionaryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCancelRefreshDictionaryStatement(s)
	}
}

func (s *CancelRefreshDictionaryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCancelRefreshDictionaryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CancelRefreshDictionaryStatement() (localctx ICancelRefreshDictionaryStatementContext) {
	localctx = NewCancelRefreshDictionaryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, DorisSQLParserParserRULE_cancelRefreshDictionaryStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2620)
		p.Match(DorisSQLParserParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2621)
		p.Match(DorisSQLParserParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2622)
		p.Match(DorisSQLParserParserDICTIONARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2623)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDictionaryColumnDescContext is an interface to support dynamic dispatch.
type IDictionaryColumnDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext
	KEY() antlr.TerminalNode
	VALUE() antlr.TerminalNode

	// IsDictionaryColumnDescContext differentiates from other interfaces.
	IsDictionaryColumnDescContext()
}

type DictionaryColumnDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryColumnDescContext() *DictionaryColumnDescContext {
	var p = new(DictionaryColumnDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dictionaryColumnDesc
	return p
}

func InitEmptyDictionaryColumnDescContext(p *DictionaryColumnDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dictionaryColumnDesc
}

func (*DictionaryColumnDescContext) IsDictionaryColumnDescContext() {}

func NewDictionaryColumnDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryColumnDescContext {
	var p = new(DictionaryColumnDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dictionaryColumnDesc

	return p
}

func (s *DictionaryColumnDescContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryColumnDescContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DictionaryColumnDescContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserKEY, 0)
}

func (s *DictionaryColumnDescContext) VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVALUE, 0)
}

func (s *DictionaryColumnDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryColumnDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryColumnDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDictionaryColumnDesc(s)
	}
}

func (s *DictionaryColumnDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDictionaryColumnDesc(s)
	}
}

func (s *DictionaryColumnDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDictionaryColumnDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DictionaryColumnDesc() (localctx IDictionaryColumnDescContext) {
	localctx = NewDictionaryColumnDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, DorisSQLParserParserRULE_dictionaryColumnDesc)
	p.SetState(2631)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 195, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2625)
			p.QualifiedName()
		}
		{
			p.SetState(2626)
			p.Match(DorisSQLParserParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2628)
			p.QualifiedName()
		}
		{
			p.SetState(2629)
			p.Match(DorisSQLParserParserVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDictionaryNameContext is an interface to support dynamic dispatch.
type IDictionaryNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext

	// IsDictionaryNameContext differentiates from other interfaces.
	IsDictionaryNameContext()
}

type DictionaryNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryNameContext() *DictionaryNameContext {
	var p = new(DictionaryNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dictionaryName
	return p
}

func InitEmptyDictionaryNameContext(p *DictionaryNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dictionaryName
}

func (*DictionaryNameContext) IsDictionaryNameContext() {}

func NewDictionaryNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryNameContext {
	var p = new(DictionaryNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dictionaryName

	return p
}

func (s *DictionaryNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryNameContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DictionaryNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDictionaryName(s)
	}
}

func (s *DictionaryNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDictionaryName(s)
	}
}

func (s *DictionaryNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDictionaryName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DictionaryName() (localctx IDictionaryNameContext) {
	localctx = NewDictionaryNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, DorisSQLParserParserRULE_dictionaryName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2633)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterClauseContext is an interface to support dynamic dispatch.
type IAlterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AddFrontendClause() IAddFrontendClauseContext
	DropFrontendClause() IDropFrontendClauseContext
	ModifyFrontendHostClause() IModifyFrontendHostClauseContext
	AddBackendClause() IAddBackendClauseContext
	DropBackendClause() IDropBackendClauseContext
	DecommissionBackendClause() IDecommissionBackendClauseContext
	ModifyBackendClause() IModifyBackendClauseContext
	AddComputeNodeClause() IAddComputeNodeClauseContext
	DropComputeNodeClause() IDropComputeNodeClauseContext
	ModifyBrokerClause() IModifyBrokerClauseContext
	AlterLoadErrorUrlClause() IAlterLoadErrorUrlClauseContext
	CreateImageClause() ICreateImageClauseContext
	CleanTabletSchedQClause() ICleanTabletSchedQClauseContext
	DecommissionDiskClause() IDecommissionDiskClauseContext
	CancelDecommissionDiskClause() ICancelDecommissionDiskClauseContext
	DisableDiskClause() IDisableDiskClauseContext
	CancelDisableDiskClause() ICancelDisableDiskClauseContext
	CreateIndexClause() ICreateIndexClauseContext
	DropIndexClause() IDropIndexClauseContext
	TableRenameClause() ITableRenameClauseContext
	SwapTableClause() ISwapTableClauseContext
	ModifyPropertiesClause() IModifyPropertiesClauseContext
	AddColumnClause() IAddColumnClauseContext
	AddColumnsClause() IAddColumnsClauseContext
	DropColumnClause() IDropColumnClauseContext
	ModifyColumnCommentClause() IModifyColumnCommentClauseContext
	ModifyColumnClause() IModifyColumnClauseContext
	ColumnRenameClause() IColumnRenameClauseContext
	ReorderColumnsClause() IReorderColumnsClauseContext
	RollupRenameClause() IRollupRenameClauseContext
	CompactionClause() ICompactionClauseContext
	ModifyCommentClause() IModifyCommentClauseContext
	OptimizeClause() IOptimizeClauseContext
	AddFieldClause() IAddFieldClauseContext
	DropFieldClause() IDropFieldClauseContext
	CreateOrReplaceBranchClause() ICreateOrReplaceBranchClauseContext
	CreateOrReplaceTagClause() ICreateOrReplaceTagClauseContext
	DropBranchClause() IDropBranchClauseContext
	DropTagClause() IDropTagClauseContext
	TableOperationClause() ITableOperationClauseContext
	DropPersistentIndexClause() IDropPersistentIndexClauseContext
	AddPartitionClause() IAddPartitionClauseContext
	DropPartitionClause() IDropPartitionClauseContext
	DistributionClause() IDistributionClauseContext
	TruncatePartitionClause() ITruncatePartitionClauseContext
	ModifyPartitionClause() IModifyPartitionClauseContext
	ReplacePartitionClause() IReplacePartitionClauseContext
	PartitionRenameClause() IPartitionRenameClauseContext

	// IsAlterClauseContext differentiates from other interfaces.
	IsAlterClauseContext()
}

type AlterClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterClauseContext() *AlterClauseContext {
	var p = new(AlterClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterClause
	return p
}

func InitEmptyAlterClauseContext(p *AlterClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterClause
}

func (*AlterClauseContext) IsAlterClauseContext() {}

func NewAlterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterClauseContext {
	var p = new(AlterClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_alterClause

	return p
}

func (s *AlterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterClauseContext) AddFrontendClause() IAddFrontendClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddFrontendClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddFrontendClauseContext)
}

func (s *AlterClauseContext) DropFrontendClause() IDropFrontendClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFrontendClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFrontendClauseContext)
}

func (s *AlterClauseContext) ModifyFrontendHostClause() IModifyFrontendHostClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyFrontendHostClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyFrontendHostClauseContext)
}

func (s *AlterClauseContext) AddBackendClause() IAddBackendClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddBackendClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddBackendClauseContext)
}

func (s *AlterClauseContext) DropBackendClause() IDropBackendClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropBackendClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropBackendClauseContext)
}

func (s *AlterClauseContext) DecommissionBackendClause() IDecommissionBackendClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecommissionBackendClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecommissionBackendClauseContext)
}

func (s *AlterClauseContext) ModifyBackendClause() IModifyBackendClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyBackendClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyBackendClauseContext)
}

func (s *AlterClauseContext) AddComputeNodeClause() IAddComputeNodeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddComputeNodeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddComputeNodeClauseContext)
}

func (s *AlterClauseContext) DropComputeNodeClause() IDropComputeNodeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropComputeNodeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropComputeNodeClauseContext)
}

func (s *AlterClauseContext) ModifyBrokerClause() IModifyBrokerClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyBrokerClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyBrokerClauseContext)
}

func (s *AlterClauseContext) AlterLoadErrorUrlClause() IAlterLoadErrorUrlClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterLoadErrorUrlClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterLoadErrorUrlClauseContext)
}

func (s *AlterClauseContext) CreateImageClause() ICreateImageClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateImageClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateImageClauseContext)
}

func (s *AlterClauseContext) CleanTabletSchedQClause() ICleanTabletSchedQClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICleanTabletSchedQClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICleanTabletSchedQClauseContext)
}

func (s *AlterClauseContext) DecommissionDiskClause() IDecommissionDiskClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecommissionDiskClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecommissionDiskClauseContext)
}

func (s *AlterClauseContext) CancelDecommissionDiskClause() ICancelDecommissionDiskClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelDecommissionDiskClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelDecommissionDiskClauseContext)
}

func (s *AlterClauseContext) DisableDiskClause() IDisableDiskClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisableDiskClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisableDiskClauseContext)
}

func (s *AlterClauseContext) CancelDisableDiskClause() ICancelDisableDiskClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelDisableDiskClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelDisableDiskClauseContext)
}

func (s *AlterClauseContext) CreateIndexClause() ICreateIndexClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateIndexClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateIndexClauseContext)
}

func (s *AlterClauseContext) DropIndexClause() IDropIndexClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropIndexClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropIndexClauseContext)
}

func (s *AlterClauseContext) TableRenameClause() ITableRenameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRenameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRenameClauseContext)
}

func (s *AlterClauseContext) SwapTableClause() ISwapTableClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwapTableClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwapTableClauseContext)
}

func (s *AlterClauseContext) ModifyPropertiesClause() IModifyPropertiesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyPropertiesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyPropertiesClauseContext)
}

func (s *AlterClauseContext) AddColumnClause() IAddColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddColumnClauseContext)
}

func (s *AlterClauseContext) AddColumnsClause() IAddColumnsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddColumnsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddColumnsClauseContext)
}

func (s *AlterClauseContext) DropColumnClause() IDropColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropColumnClauseContext)
}

func (s *AlterClauseContext) ModifyColumnCommentClause() IModifyColumnCommentClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyColumnCommentClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyColumnCommentClauseContext)
}

func (s *AlterClauseContext) ModifyColumnClause() IModifyColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyColumnClauseContext)
}

func (s *AlterClauseContext) ColumnRenameClause() IColumnRenameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRenameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRenameClauseContext)
}

func (s *AlterClauseContext) ReorderColumnsClause() IReorderColumnsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReorderColumnsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReorderColumnsClauseContext)
}

func (s *AlterClauseContext) RollupRenameClause() IRollupRenameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupRenameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupRenameClauseContext)
}

func (s *AlterClauseContext) CompactionClause() ICompactionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompactionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompactionClauseContext)
}

func (s *AlterClauseContext) ModifyCommentClause() IModifyCommentClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyCommentClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyCommentClauseContext)
}

func (s *AlterClauseContext) OptimizeClause() IOptimizeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptimizeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptimizeClauseContext)
}

func (s *AlterClauseContext) AddFieldClause() IAddFieldClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddFieldClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddFieldClauseContext)
}

func (s *AlterClauseContext) DropFieldClause() IDropFieldClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFieldClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFieldClauseContext)
}

func (s *AlterClauseContext) CreateOrReplaceBranchClause() ICreateOrReplaceBranchClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateOrReplaceBranchClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateOrReplaceBranchClauseContext)
}

func (s *AlterClauseContext) CreateOrReplaceTagClause() ICreateOrReplaceTagClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateOrReplaceTagClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateOrReplaceTagClauseContext)
}

func (s *AlterClauseContext) DropBranchClause() IDropBranchClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropBranchClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropBranchClauseContext)
}

func (s *AlterClauseContext) DropTagClause() IDropTagClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTagClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTagClauseContext)
}

func (s *AlterClauseContext) TableOperationClause() ITableOperationClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOperationClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOperationClauseContext)
}

func (s *AlterClauseContext) DropPersistentIndexClause() IDropPersistentIndexClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropPersistentIndexClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropPersistentIndexClauseContext)
}

func (s *AlterClauseContext) AddPartitionClause() IAddPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddPartitionClauseContext)
}

func (s *AlterClauseContext) DropPartitionClause() IDropPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropPartitionClauseContext)
}

func (s *AlterClauseContext) DistributionClause() IDistributionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionClauseContext)
}

func (s *AlterClauseContext) TruncatePartitionClause() ITruncatePartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncatePartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncatePartitionClauseContext)
}

func (s *AlterClauseContext) ModifyPartitionClause() IModifyPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyPartitionClauseContext)
}

func (s *AlterClauseContext) ReplacePartitionClause() IReplacePartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplacePartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplacePartitionClauseContext)
}

func (s *AlterClauseContext) PartitionRenameClause() IPartitionRenameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionRenameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionRenameClauseContext)
}

func (s *AlterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAlterClause(s)
	}
}

func (s *AlterClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAlterClause(s)
	}
}

func (s *AlterClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAlterClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AlterClause() (localctx IAlterClauseContext) {
	localctx = NewAlterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, DorisSQLParserParserRULE_alterClause)
	p.SetState(2683)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 196, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2635)
			p.AddFrontendClause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2636)
			p.DropFrontendClause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2637)
			p.ModifyFrontendHostClause()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2638)
			p.AddBackendClause()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2639)
			p.DropBackendClause()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2640)
			p.DecommissionBackendClause()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2641)
			p.ModifyBackendClause()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2642)
			p.AddComputeNodeClause()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2643)
			p.DropComputeNodeClause()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2644)
			p.ModifyBrokerClause()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2645)
			p.AlterLoadErrorUrlClause()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2646)
			p.CreateImageClause()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2647)
			p.CleanTabletSchedQClause()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2648)
			p.DecommissionDiskClause()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(2649)
			p.CancelDecommissionDiskClause()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(2650)
			p.DisableDiskClause()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(2651)
			p.CancelDisableDiskClause()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(2652)
			p.CreateIndexClause()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(2653)
			p.DropIndexClause()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(2654)
			p.TableRenameClause()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(2655)
			p.SwapTableClause()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(2656)
			p.ModifyPropertiesClause()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(2657)
			p.AddColumnClause()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(2658)
			p.AddColumnsClause()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(2659)
			p.DropColumnClause()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(2660)
			p.ModifyColumnCommentClause()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(2661)
			p.ModifyColumnClause()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(2662)
			p.ColumnRenameClause()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(2663)
			p.ReorderColumnsClause()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(2664)
			p.RollupRenameClause()
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(2665)
			p.CompactionClause()
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(2666)
			p.ModifyCommentClause()
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(2667)
			p.OptimizeClause()
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(2668)
			p.AddFieldClause()
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(2669)
			p.DropFieldClause()
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(2670)
			p.CreateOrReplaceBranchClause()
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(2671)
			p.CreateOrReplaceTagClause()
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(2672)
			p.DropBranchClause()
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(2673)
			p.DropTagClause()
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(2674)
			p.TableOperationClause()
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(2675)
			p.DropPersistentIndexClause()
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(2676)
			p.AddPartitionClause()
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(2677)
			p.DropPartitionClause()
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(2678)
			p.DistributionClause()
		}

	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(2679)
			p.TruncatePartitionClause()
		}

	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(2680)
			p.ModifyPartitionClause()
		}

	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(2681)
			p.ReplacePartitionClause()
		}

	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(2682)
			p.PartitionRenameClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddFrontendClauseContext is an interface to support dynamic dispatch.
type IAddFrontendClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	String_() IStringContext
	FOLLOWER() antlr.TerminalNode
	OBSERVER() antlr.TerminalNode

	// IsAddFrontendClauseContext differentiates from other interfaces.
	IsAddFrontendClauseContext()
}

type AddFrontendClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddFrontendClauseContext() *AddFrontendClauseContext {
	var p = new(AddFrontendClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_addFrontendClause
	return p
}

func InitEmptyAddFrontendClauseContext(p *AddFrontendClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_addFrontendClause
}

func (*AddFrontendClauseContext) IsAddFrontendClauseContext() {}

func NewAddFrontendClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddFrontendClauseContext {
	var p = new(AddFrontendClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_addFrontendClause

	return p
}

func (s *AddFrontendClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddFrontendClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADD, 0)
}

func (s *AddFrontendClauseContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AddFrontendClauseContext) FOLLOWER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFOLLOWER, 0)
}

func (s *AddFrontendClauseContext) OBSERVER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOBSERVER, 0)
}

func (s *AddFrontendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddFrontendClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddFrontendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAddFrontendClause(s)
	}
}

func (s *AddFrontendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAddFrontendClause(s)
	}
}

func (s *AddFrontendClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAddFrontendClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AddFrontendClause() (localctx IAddFrontendClauseContext) {
	localctx = NewAddFrontendClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, DorisSQLParserParserRULE_addFrontendClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2685)
		p.Match(DorisSQLParserParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2686)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserFOLLOWER || _la == DorisSQLParserParserOBSERVER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2687)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropFrontendClauseContext is an interface to support dynamic dispatch.
type IDropFrontendClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	String_() IStringContext
	FOLLOWER() antlr.TerminalNode
	OBSERVER() antlr.TerminalNode

	// IsDropFrontendClauseContext differentiates from other interfaces.
	IsDropFrontendClauseContext()
}

type DropFrontendClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropFrontendClauseContext() *DropFrontendClauseContext {
	var p = new(DropFrontendClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropFrontendClause
	return p
}

func InitEmptyDropFrontendClauseContext(p *DropFrontendClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropFrontendClause
}

func (*DropFrontendClauseContext) IsDropFrontendClauseContext() {}

func NewDropFrontendClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFrontendClauseContext {
	var p = new(DropFrontendClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropFrontendClause

	return p
}

func (s *DropFrontendClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFrontendClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropFrontendClauseContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DropFrontendClauseContext) FOLLOWER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFOLLOWER, 0)
}

func (s *DropFrontendClauseContext) OBSERVER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOBSERVER, 0)
}

func (s *DropFrontendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFrontendClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropFrontendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropFrontendClause(s)
	}
}

func (s *DropFrontendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropFrontendClause(s)
	}
}

func (s *DropFrontendClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropFrontendClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropFrontendClause() (localctx IDropFrontendClauseContext) {
	localctx = NewDropFrontendClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, DorisSQLParserParserRULE_dropFrontendClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2689)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2690)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserFOLLOWER || _la == DorisSQLParserParserOBSERVER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2691)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyFrontendHostClauseContext is an interface to support dynamic dispatch.
type IModifyFrontendHostClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODIFY() antlr.TerminalNode
	FRONTEND() antlr.TerminalNode
	HOST() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	TO() antlr.TerminalNode

	// IsModifyFrontendHostClauseContext differentiates from other interfaces.
	IsModifyFrontendHostClauseContext()
}

type ModifyFrontendHostClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyFrontendHostClauseContext() *ModifyFrontendHostClauseContext {
	var p = new(ModifyFrontendHostClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_modifyFrontendHostClause
	return p
}

func InitEmptyModifyFrontendHostClauseContext(p *ModifyFrontendHostClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_modifyFrontendHostClause
}

func (*ModifyFrontendHostClauseContext) IsModifyFrontendHostClauseContext() {}

func NewModifyFrontendHostClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyFrontendHostClauseContext {
	var p = new(ModifyFrontendHostClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_modifyFrontendHostClause

	return p
}

func (s *ModifyFrontendHostClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyFrontendHostClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMODIFY, 0)
}

func (s *ModifyFrontendHostClauseContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFRONTEND, 0)
}

func (s *ModifyFrontendHostClauseContext) HOST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserHOST, 0)
}

func (s *ModifyFrontendHostClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ModifyFrontendHostClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ModifyFrontendHostClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTO, 0)
}

func (s *ModifyFrontendHostClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyFrontendHostClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyFrontendHostClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterModifyFrontendHostClause(s)
	}
}

func (s *ModifyFrontendHostClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitModifyFrontendHostClause(s)
	}
}

func (s *ModifyFrontendHostClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitModifyFrontendHostClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ModifyFrontendHostClause() (localctx IModifyFrontendHostClauseContext) {
	localctx = NewModifyFrontendHostClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, DorisSQLParserParserRULE_modifyFrontendHostClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2693)
		p.Match(DorisSQLParserParserMODIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2694)
		p.Match(DorisSQLParserParserFRONTEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2695)
		p.Match(DorisSQLParserParserHOST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2696)
		p.String_()
	}
	{
		p.SetState(2697)
		p.Match(DorisSQLParserParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2698)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddBackendClauseContext is an interface to support dynamic dispatch.
type IAddBackendClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	ADD() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	INTO() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext
	CNGROUP() antlr.TerminalNode

	// IsAddBackendClauseContext differentiates from other interfaces.
	IsAddBackendClauseContext()
}

type AddBackendClauseContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyAddBackendClauseContext() *AddBackendClauseContext {
	var p = new(AddBackendClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_addBackendClause
	return p
}

func InitEmptyAddBackendClauseContext(p *AddBackendClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_addBackendClause
}

func (*AddBackendClauseContext) IsAddBackendClauseContext() {}

func NewAddBackendClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddBackendClauseContext {
	var p = new(AddBackendClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_addBackendClause

	return p
}

func (s *AddBackendClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddBackendClauseContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *AddBackendClauseContext) GetCngroupName() IIdentifierOrStringContext { return s.cngroupName }

func (s *AddBackendClauseContext) SetWarehouseName(v IIdentifierOrStringContext) { s.warehouseName = v }

func (s *AddBackendClauseContext) SetCngroupName(v IIdentifierOrStringContext) { s.cngroupName = v }

func (s *AddBackendClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADD, 0)
}

func (s *AddBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBACKEND, 0)
}

func (s *AddBackendClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *AddBackendClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AddBackendClauseContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTO, 0)
}

func (s *AddBackendClauseContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWAREHOUSE, 0)
}

func (s *AddBackendClauseContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *AddBackendClauseContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AddBackendClauseContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCNGROUP, 0)
}

func (s *AddBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddBackendClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAddBackendClause(s)
	}
}

func (s *AddBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAddBackendClause(s)
	}
}

func (s *AddBackendClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAddBackendClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AddBackendClause() (localctx IAddBackendClauseContext) {
	localctx = NewAddBackendClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, DorisSQLParserParserRULE_addBackendClause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2700)
		p.Match(DorisSQLParserParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2701)
		p.Match(DorisSQLParserParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2702)
		p.String_()
	}
	p.SetState(2707)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 197, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2703)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2704)
				p.String_()
			}

		}
		p.SetState(2709)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 197, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2717)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserINTO {
		{
			p.SetState(2710)
			p.Match(DorisSQLParserParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2711)
			p.Match(DorisSQLParserParserWAREHOUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2712)

			var _x = p.IdentifierOrString()

			localctx.(*AddBackendClauseContext).warehouseName = _x
		}
		p.SetState(2715)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserCNGROUP {
			{
				p.SetState(2713)
				p.Match(DorisSQLParserParserCNGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2714)

				var _x = p.IdentifierOrString()

				localctx.(*AddBackendClauseContext).cngroupName = _x
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropBackendClauseContext is an interface to support dynamic dispatch.
type IDropBackendClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	FROM() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	FORCE() antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext
	CNGROUP() antlr.TerminalNode

	// IsDropBackendClauseContext differentiates from other interfaces.
	IsDropBackendClauseContext()
}

type DropBackendClauseContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyDropBackendClauseContext() *DropBackendClauseContext {
	var p = new(DropBackendClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropBackendClause
	return p
}

func InitEmptyDropBackendClauseContext(p *DropBackendClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropBackendClause
}

func (*DropBackendClauseContext) IsDropBackendClauseContext() {}

func NewDropBackendClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropBackendClauseContext {
	var p = new(DropBackendClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropBackendClause

	return p
}

func (s *DropBackendClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropBackendClauseContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *DropBackendClauseContext) GetCngroupName() IIdentifierOrStringContext { return s.cngroupName }

func (s *DropBackendClauseContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *DropBackendClauseContext) SetCngroupName(v IIdentifierOrStringContext) { s.cngroupName = v }

func (s *DropBackendClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBACKEND, 0)
}

func (s *DropBackendClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *DropBackendClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DropBackendClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *DropBackendClauseContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWAREHOUSE, 0)
}

func (s *DropBackendClauseContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFORCE, 0)
}

func (s *DropBackendClauseContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *DropBackendClauseContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropBackendClauseContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCNGROUP, 0)
}

func (s *DropBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropBackendClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropBackendClause(s)
	}
}

func (s *DropBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropBackendClause(s)
	}
}

func (s *DropBackendClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropBackendClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropBackendClause() (localctx IDropBackendClauseContext) {
	localctx = NewDropBackendClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, DorisSQLParserParserRULE_dropBackendClause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2719)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2720)
		p.Match(DorisSQLParserParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2721)
		p.String_()
	}
	p.SetState(2726)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 200, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2722)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2723)
				p.String_()
			}

		}
		p.SetState(2728)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 200, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2736)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM {
		{
			p.SetState(2729)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2730)
			p.Match(DorisSQLParserParserWAREHOUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2731)

			var _x = p.IdentifierOrString()

			localctx.(*DropBackendClauseContext).warehouseName = _x
		}
		p.SetState(2734)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserCNGROUP {
			{
				p.SetState(2732)
				p.Match(DorisSQLParserParserCNGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2733)

				var _x = p.IdentifierOrString()

				localctx.(*DropBackendClauseContext).cngroupName = _x
			}

		}

	}
	p.SetState(2739)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFORCE {
		{
			p.SetState(2738)
			p.Match(DorisSQLParserParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecommissionBackendClauseContext is an interface to support dynamic dispatch.
type IDecommissionBackendClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECOMMISSION() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsDecommissionBackendClauseContext differentiates from other interfaces.
	IsDecommissionBackendClauseContext()
}

type DecommissionBackendClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecommissionBackendClauseContext() *DecommissionBackendClauseContext {
	var p = new(DecommissionBackendClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_decommissionBackendClause
	return p
}

func InitEmptyDecommissionBackendClauseContext(p *DecommissionBackendClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_decommissionBackendClause
}

func (*DecommissionBackendClauseContext) IsDecommissionBackendClauseContext() {}

func NewDecommissionBackendClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecommissionBackendClauseContext {
	var p = new(DecommissionBackendClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_decommissionBackendClause

	return p
}

func (s *DecommissionBackendClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DecommissionBackendClauseContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDECOMMISSION, 0)
}

func (s *DecommissionBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBACKEND, 0)
}

func (s *DecommissionBackendClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *DecommissionBackendClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DecommissionBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecommissionBackendClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecommissionBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDecommissionBackendClause(s)
	}
}

func (s *DecommissionBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDecommissionBackendClause(s)
	}
}

func (s *DecommissionBackendClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDecommissionBackendClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DecommissionBackendClause() (localctx IDecommissionBackendClauseContext) {
	localctx = NewDecommissionBackendClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, DorisSQLParserParserRULE_decommissionBackendClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2741)
		p.Match(DorisSQLParserParserDECOMMISSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2742)
		p.Match(DorisSQLParserParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2743)
		p.String_()
	}
	p.SetState(2748)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 204, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2744)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2745)
				p.String_()
			}

		}
		p.SetState(2750)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 204, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyBackendClauseContext is an interface to support dynamic dispatch.
type IModifyBackendClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODIFY() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	HOST() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	TO() antlr.TerminalNode
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsModifyBackendClauseContext differentiates from other interfaces.
	IsModifyBackendClauseContext()
}

type ModifyBackendClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyBackendClauseContext() *ModifyBackendClauseContext {
	var p = new(ModifyBackendClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_modifyBackendClause
	return p
}

func InitEmptyModifyBackendClauseContext(p *ModifyBackendClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_modifyBackendClause
}

func (*ModifyBackendClauseContext) IsModifyBackendClauseContext() {}

func NewModifyBackendClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyBackendClauseContext {
	var p = new(ModifyBackendClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_modifyBackendClause

	return p
}

func (s *ModifyBackendClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyBackendClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMODIFY, 0)
}

func (s *ModifyBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBACKEND, 0)
}

func (s *ModifyBackendClauseContext) HOST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserHOST, 0)
}

func (s *ModifyBackendClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ModifyBackendClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ModifyBackendClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTO, 0)
}

func (s *ModifyBackendClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *ModifyBackendClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *ModifyBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyBackendClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterModifyBackendClause(s)
	}
}

func (s *ModifyBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitModifyBackendClause(s)
	}
}

func (s *ModifyBackendClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitModifyBackendClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ModifyBackendClause() (localctx IModifyBackendClauseContext) {
	localctx = NewModifyBackendClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, DorisSQLParserParserRULE_modifyBackendClause)
	p.SetState(2764)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 205, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2751)
			p.Match(DorisSQLParserParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2752)
			p.Match(DorisSQLParserParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2753)
			p.Match(DorisSQLParserParserHOST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2754)
			p.String_()
		}
		{
			p.SetState(2755)
			p.Match(DorisSQLParserParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2756)
			p.String_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2758)
			p.Match(DorisSQLParserParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2759)
			p.Match(DorisSQLParserParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2760)
			p.String_()
		}
		{
			p.SetState(2761)
			p.Match(DorisSQLParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2762)
			p.PropertyList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddComputeNodeClauseContext is an interface to support dynamic dispatch.
type IAddComputeNodeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	ADD() antlr.TerminalNode
	COMPUTE() antlr.TerminalNode
	NODE() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	INTO() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext
	CNGROUP() antlr.TerminalNode

	// IsAddComputeNodeClauseContext differentiates from other interfaces.
	IsAddComputeNodeClauseContext()
}

type AddComputeNodeClauseContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyAddComputeNodeClauseContext() *AddComputeNodeClauseContext {
	var p = new(AddComputeNodeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_addComputeNodeClause
	return p
}

func InitEmptyAddComputeNodeClauseContext(p *AddComputeNodeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_addComputeNodeClause
}

func (*AddComputeNodeClauseContext) IsAddComputeNodeClauseContext() {}

func NewAddComputeNodeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddComputeNodeClauseContext {
	var p = new(AddComputeNodeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_addComputeNodeClause

	return p
}

func (s *AddComputeNodeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddComputeNodeClauseContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *AddComputeNodeClauseContext) GetCngroupName() IIdentifierOrStringContext {
	return s.cngroupName
}

func (s *AddComputeNodeClauseContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *AddComputeNodeClauseContext) SetCngroupName(v IIdentifierOrStringContext) { s.cngroupName = v }

func (s *AddComputeNodeClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADD, 0)
}

func (s *AddComputeNodeClauseContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOMPUTE, 0)
}

func (s *AddComputeNodeClauseContext) NODE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNODE, 0)
}

func (s *AddComputeNodeClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *AddComputeNodeClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AddComputeNodeClauseContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTO, 0)
}

func (s *AddComputeNodeClauseContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWAREHOUSE, 0)
}

func (s *AddComputeNodeClauseContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *AddComputeNodeClauseContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AddComputeNodeClauseContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCNGROUP, 0)
}

func (s *AddComputeNodeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddComputeNodeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddComputeNodeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAddComputeNodeClause(s)
	}
}

func (s *AddComputeNodeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAddComputeNodeClause(s)
	}
}

func (s *AddComputeNodeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAddComputeNodeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AddComputeNodeClause() (localctx IAddComputeNodeClauseContext) {
	localctx = NewAddComputeNodeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, DorisSQLParserParserRULE_addComputeNodeClause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2766)
		p.Match(DorisSQLParserParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2767)
		p.Match(DorisSQLParserParserCOMPUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2768)
		p.Match(DorisSQLParserParserNODE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2769)
		p.String_()
	}
	p.SetState(2774)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2770)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2771)
				p.String_()
			}

		}
		p.SetState(2776)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2784)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserINTO {
		{
			p.SetState(2777)
			p.Match(DorisSQLParserParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2778)
			p.Match(DorisSQLParserParserWAREHOUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2779)

			var _x = p.IdentifierOrString()

			localctx.(*AddComputeNodeClauseContext).warehouseName = _x
		}
		p.SetState(2782)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserCNGROUP {
			{
				p.SetState(2780)
				p.Match(DorisSQLParserParserCNGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2781)

				var _x = p.IdentifierOrString()

				localctx.(*AddComputeNodeClauseContext).cngroupName = _x
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropComputeNodeClauseContext is an interface to support dynamic dispatch.
type IDropComputeNodeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	COMPUTE() antlr.TerminalNode
	NODE() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	FROM() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext
	CNGROUP() antlr.TerminalNode

	// IsDropComputeNodeClauseContext differentiates from other interfaces.
	IsDropComputeNodeClauseContext()
}

type DropComputeNodeClauseContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyDropComputeNodeClauseContext() *DropComputeNodeClauseContext {
	var p = new(DropComputeNodeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropComputeNodeClause
	return p
}

func InitEmptyDropComputeNodeClauseContext(p *DropComputeNodeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropComputeNodeClause
}

func (*DropComputeNodeClauseContext) IsDropComputeNodeClauseContext() {}

func NewDropComputeNodeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropComputeNodeClauseContext {
	var p = new(DropComputeNodeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropComputeNodeClause

	return p
}

func (s *DropComputeNodeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropComputeNodeClauseContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *DropComputeNodeClauseContext) GetCngroupName() IIdentifierOrStringContext {
	return s.cngroupName
}

func (s *DropComputeNodeClauseContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *DropComputeNodeClauseContext) SetCngroupName(v IIdentifierOrStringContext) {
	s.cngroupName = v
}

func (s *DropComputeNodeClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropComputeNodeClauseContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOMPUTE, 0)
}

func (s *DropComputeNodeClauseContext) NODE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNODE, 0)
}

func (s *DropComputeNodeClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *DropComputeNodeClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DropComputeNodeClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *DropComputeNodeClauseContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWAREHOUSE, 0)
}

func (s *DropComputeNodeClauseContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *DropComputeNodeClauseContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropComputeNodeClauseContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCNGROUP, 0)
}

func (s *DropComputeNodeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropComputeNodeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropComputeNodeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropComputeNodeClause(s)
	}
}

func (s *DropComputeNodeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropComputeNodeClause(s)
	}
}

func (s *DropComputeNodeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropComputeNodeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropComputeNodeClause() (localctx IDropComputeNodeClauseContext) {
	localctx = NewDropComputeNodeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, DorisSQLParserParserRULE_dropComputeNodeClause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2786)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2787)
		p.Match(DorisSQLParserParserCOMPUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2788)
		p.Match(DorisSQLParserParserNODE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2789)
		p.String_()
	}
	p.SetState(2794)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 209, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2790)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2791)
				p.String_()
			}

		}
		p.SetState(2796)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 209, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2804)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM {
		{
			p.SetState(2797)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2798)
			p.Match(DorisSQLParserParserWAREHOUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2799)

			var _x = p.IdentifierOrString()

			localctx.(*DropComputeNodeClauseContext).warehouseName = _x
		}
		p.SetState(2802)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserCNGROUP {
			{
				p.SetState(2800)
				p.Match(DorisSQLParserParserCNGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2801)

				var _x = p.IdentifierOrString()

				localctx.(*DropComputeNodeClauseContext).cngroupName = _x
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyBrokerClauseContext is an interface to support dynamic dispatch.
type IModifyBrokerClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	AllString_() []IStringContext
	String_(i int) IStringContext
	DROP() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsModifyBrokerClauseContext differentiates from other interfaces.
	IsModifyBrokerClauseContext()
}

type ModifyBrokerClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyBrokerClauseContext() *ModifyBrokerClauseContext {
	var p = new(ModifyBrokerClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_modifyBrokerClause
	return p
}

func InitEmptyModifyBrokerClauseContext(p *ModifyBrokerClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_modifyBrokerClause
}

func (*ModifyBrokerClauseContext) IsModifyBrokerClauseContext() {}

func NewModifyBrokerClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyBrokerClauseContext {
	var p = new(ModifyBrokerClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_modifyBrokerClause

	return p
}

func (s *ModifyBrokerClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyBrokerClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADD, 0)
}

func (s *ModifyBrokerClauseContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBROKER, 0)
}

func (s *ModifyBrokerClauseContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *ModifyBrokerClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ModifyBrokerClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ModifyBrokerClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *ModifyBrokerClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, 0)
}

func (s *ModifyBrokerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyBrokerClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyBrokerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterModifyBrokerClause(s)
	}
}

func (s *ModifyBrokerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitModifyBrokerClause(s)
	}
}

func (s *ModifyBrokerClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitModifyBrokerClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ModifyBrokerClause() (localctx IModifyBrokerClauseContext) {
	localctx = NewModifyBrokerClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, DorisSQLParserParserRULE_modifyBrokerClause)
	var _alt int

	p.SetState(2832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 214, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2806)
			p.Match(DorisSQLParserParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2807)
			p.Match(DorisSQLParserParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2808)
			p.IdentifierOrString()
		}
		{
			p.SetState(2809)
			p.String_()
		}
		p.SetState(2814)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2810)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2811)
					p.String_()
				}

			}
			p.SetState(2816)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2817)
			p.Match(DorisSQLParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2818)
			p.Match(DorisSQLParserParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2819)
			p.IdentifierOrString()
		}
		{
			p.SetState(2820)
			p.String_()
		}
		p.SetState(2825)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 213, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2821)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2822)
					p.String_()
				}

			}
			p.SetState(2827)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 213, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2828)
			p.Match(DorisSQLParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2829)
			p.Match(DorisSQLParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2830)
			p.Match(DorisSQLParserParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2831)
			p.IdentifierOrString()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterLoadErrorUrlClauseContext is an interface to support dynamic dispatch.
type IAlterLoadErrorUrlClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	ERRORS() antlr.TerminalNode
	HUB() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsAlterLoadErrorUrlClauseContext differentiates from other interfaces.
	IsAlterLoadErrorUrlClauseContext()
}

type AlterLoadErrorUrlClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterLoadErrorUrlClauseContext() *AlterLoadErrorUrlClauseContext {
	var p = new(AlterLoadErrorUrlClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterLoadErrorUrlClause
	return p
}

func InitEmptyAlterLoadErrorUrlClauseContext(p *AlterLoadErrorUrlClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterLoadErrorUrlClause
}

func (*AlterLoadErrorUrlClauseContext) IsAlterLoadErrorUrlClauseContext() {}

func NewAlterLoadErrorUrlClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterLoadErrorUrlClauseContext {
	var p = new(AlterLoadErrorUrlClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_alterLoadErrorUrlClause

	return p
}

func (s *AlterLoadErrorUrlClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterLoadErrorUrlClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *AlterLoadErrorUrlClauseContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOAD, 0)
}

func (s *AlterLoadErrorUrlClauseContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserERRORS, 0)
}

func (s *AlterLoadErrorUrlClauseContext) HUB() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserHUB, 0)
}

func (s *AlterLoadErrorUrlClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AlterLoadErrorUrlClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterLoadErrorUrlClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterLoadErrorUrlClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAlterLoadErrorUrlClause(s)
	}
}

func (s *AlterLoadErrorUrlClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAlterLoadErrorUrlClause(s)
	}
}

func (s *AlterLoadErrorUrlClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAlterLoadErrorUrlClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AlterLoadErrorUrlClause() (localctx IAlterLoadErrorUrlClauseContext) {
	localctx = NewAlterLoadErrorUrlClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, DorisSQLParserParserRULE_alterLoadErrorUrlClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2834)
		p.Match(DorisSQLParserParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2835)
		p.Match(DorisSQLParserParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2836)
		p.Match(DorisSQLParserParserERRORS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2837)
		p.Match(DorisSQLParserParserHUB)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(2838)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateImageClauseContext is an interface to support dynamic dispatch.
type ICreateImageClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	IMAGE() antlr.TerminalNode

	// IsCreateImageClauseContext differentiates from other interfaces.
	IsCreateImageClauseContext()
}

type CreateImageClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateImageClauseContext() *CreateImageClauseContext {
	var p = new(CreateImageClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createImageClause
	return p
}

func InitEmptyCreateImageClauseContext(p *CreateImageClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createImageClause
}

func (*CreateImageClauseContext) IsCreateImageClauseContext() {}

func NewCreateImageClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateImageClauseContext {
	var p = new(CreateImageClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createImageClause

	return p
}

func (s *CreateImageClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateImageClauseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateImageClauseContext) IMAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIMAGE, 0)
}

func (s *CreateImageClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateImageClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateImageClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateImageClause(s)
	}
}

func (s *CreateImageClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateImageClause(s)
	}
}

func (s *CreateImageClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateImageClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateImageClause() (localctx ICreateImageClauseContext) {
	localctx = NewCreateImageClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, DorisSQLParserParserRULE_createImageClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2841)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2842)
		p.Match(DorisSQLParserParserIMAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICleanTabletSchedQClauseContext is an interface to support dynamic dispatch.
type ICleanTabletSchedQClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLEAN() antlr.TerminalNode
	TABLET() antlr.TerminalNode
	SCHEDULER() antlr.TerminalNode
	QUEUE() antlr.TerminalNode

	// IsCleanTabletSchedQClauseContext differentiates from other interfaces.
	IsCleanTabletSchedQClauseContext()
}

type CleanTabletSchedQClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCleanTabletSchedQClauseContext() *CleanTabletSchedQClauseContext {
	var p = new(CleanTabletSchedQClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cleanTabletSchedQClause
	return p
}

func InitEmptyCleanTabletSchedQClauseContext(p *CleanTabletSchedQClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cleanTabletSchedQClause
}

func (*CleanTabletSchedQClauseContext) IsCleanTabletSchedQClauseContext() {}

func NewCleanTabletSchedQClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CleanTabletSchedQClauseContext {
	var p = new(CleanTabletSchedQClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_cleanTabletSchedQClause

	return p
}

func (s *CleanTabletSchedQClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CleanTabletSchedQClauseContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCLEAN, 0)
}

func (s *CleanTabletSchedQClauseContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLET, 0)
}

func (s *CleanTabletSchedQClauseContext) SCHEDULER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSCHEDULER, 0)
}

func (s *CleanTabletSchedQClauseContext) QUEUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserQUEUE, 0)
}

func (s *CleanTabletSchedQClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CleanTabletSchedQClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CleanTabletSchedQClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCleanTabletSchedQClause(s)
	}
}

func (s *CleanTabletSchedQClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCleanTabletSchedQClause(s)
	}
}

func (s *CleanTabletSchedQClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCleanTabletSchedQClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CleanTabletSchedQClause() (localctx ICleanTabletSchedQClauseContext) {
	localctx = NewCleanTabletSchedQClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, DorisSQLParserParserRULE_cleanTabletSchedQClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2844)
		p.Match(DorisSQLParserParserCLEAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2845)
		p.Match(DorisSQLParserParserTABLET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2846)
		p.Match(DorisSQLParserParserSCHEDULER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2847)
		p.Match(DorisSQLParserParserQUEUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecommissionDiskClauseContext is an interface to support dynamic dispatch.
type IDecommissionDiskClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECOMMISSION() antlr.TerminalNode
	DISK() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	ON() antlr.TerminalNode
	BACKEND() antlr.TerminalNode

	// IsDecommissionDiskClauseContext differentiates from other interfaces.
	IsDecommissionDiskClauseContext()
}

type DecommissionDiskClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecommissionDiskClauseContext() *DecommissionDiskClauseContext {
	var p = new(DecommissionDiskClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_decommissionDiskClause
	return p
}

func InitEmptyDecommissionDiskClauseContext(p *DecommissionDiskClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_decommissionDiskClause
}

func (*DecommissionDiskClauseContext) IsDecommissionDiskClauseContext() {}

func NewDecommissionDiskClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecommissionDiskClauseContext {
	var p = new(DecommissionDiskClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_decommissionDiskClause

	return p
}

func (s *DecommissionDiskClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DecommissionDiskClauseContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDECOMMISSION, 0)
}

func (s *DecommissionDiskClauseContext) DISK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDISK, 0)
}

func (s *DecommissionDiskClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *DecommissionDiskClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DecommissionDiskClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *DecommissionDiskClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBACKEND, 0)
}

func (s *DecommissionDiskClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecommissionDiskClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecommissionDiskClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDecommissionDiskClause(s)
	}
}

func (s *DecommissionDiskClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDecommissionDiskClause(s)
	}
}

func (s *DecommissionDiskClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDecommissionDiskClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DecommissionDiskClause() (localctx IDecommissionDiskClauseContext) {
	localctx = NewDecommissionDiskClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, DorisSQLParserParserRULE_decommissionDiskClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2849)
		p.Match(DorisSQLParserParserDECOMMISSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2850)
		p.Match(DorisSQLParserParserDISK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2851)
		p.String_()
	}
	p.SetState(2856)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(2852)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2853)
			p.String_()
		}

		p.SetState(2858)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2859)
		p.Match(DorisSQLParserParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2860)
		p.Match(DorisSQLParserParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2861)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelDecommissionDiskClauseContext is an interface to support dynamic dispatch.
type ICancelDecommissionDiskClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	DECOMMISSION() antlr.TerminalNode
	DISK() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	ON() antlr.TerminalNode
	BACKEND() antlr.TerminalNode

	// IsCancelDecommissionDiskClauseContext differentiates from other interfaces.
	IsCancelDecommissionDiskClauseContext()
}

type CancelDecommissionDiskClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelDecommissionDiskClauseContext() *CancelDecommissionDiskClauseContext {
	var p = new(CancelDecommissionDiskClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cancelDecommissionDiskClause
	return p
}

func InitEmptyCancelDecommissionDiskClauseContext(p *CancelDecommissionDiskClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cancelDecommissionDiskClause
}

func (*CancelDecommissionDiskClauseContext) IsCancelDecommissionDiskClauseContext() {}

func NewCancelDecommissionDiskClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelDecommissionDiskClauseContext {
	var p = new(CancelDecommissionDiskClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_cancelDecommissionDiskClause

	return p
}

func (s *CancelDecommissionDiskClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelDecommissionDiskClauseContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCANCEL, 0)
}

func (s *CancelDecommissionDiskClauseContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDECOMMISSION, 0)
}

func (s *CancelDecommissionDiskClauseContext) DISK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDISK, 0)
}

func (s *CancelDecommissionDiskClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *CancelDecommissionDiskClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CancelDecommissionDiskClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *CancelDecommissionDiskClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBACKEND, 0)
}

func (s *CancelDecommissionDiskClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelDecommissionDiskClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelDecommissionDiskClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCancelDecommissionDiskClause(s)
	}
}

func (s *CancelDecommissionDiskClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCancelDecommissionDiskClause(s)
	}
}

func (s *CancelDecommissionDiskClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCancelDecommissionDiskClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CancelDecommissionDiskClause() (localctx ICancelDecommissionDiskClauseContext) {
	localctx = NewCancelDecommissionDiskClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, DorisSQLParserParserRULE_cancelDecommissionDiskClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2863)
		p.Match(DorisSQLParserParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2864)
		p.Match(DorisSQLParserParserDECOMMISSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2865)
		p.Match(DorisSQLParserParserDISK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2866)
		p.String_()
	}
	p.SetState(2871)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(2867)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2868)
			p.String_()
		}

		p.SetState(2873)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2874)
		p.Match(DorisSQLParserParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2875)
		p.Match(DorisSQLParserParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2876)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDisableDiskClauseContext is an interface to support dynamic dispatch.
type IDisableDiskClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISABLE() antlr.TerminalNode
	DISK() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	ON() antlr.TerminalNode
	BACKEND() antlr.TerminalNode

	// IsDisableDiskClauseContext differentiates from other interfaces.
	IsDisableDiskClauseContext()
}

type DisableDiskClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisableDiskClauseContext() *DisableDiskClauseContext {
	var p = new(DisableDiskClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_disableDiskClause
	return p
}

func InitEmptyDisableDiskClauseContext(p *DisableDiskClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_disableDiskClause
}

func (*DisableDiskClauseContext) IsDisableDiskClauseContext() {}

func NewDisableDiskClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisableDiskClauseContext {
	var p = new(DisableDiskClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_disableDiskClause

	return p
}

func (s *DisableDiskClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DisableDiskClauseContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDISABLE, 0)
}

func (s *DisableDiskClauseContext) DISK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDISK, 0)
}

func (s *DisableDiskClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *DisableDiskClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DisableDiskClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *DisableDiskClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBACKEND, 0)
}

func (s *DisableDiskClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisableDiskClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisableDiskClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDisableDiskClause(s)
	}
}

func (s *DisableDiskClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDisableDiskClause(s)
	}
}

func (s *DisableDiskClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDisableDiskClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DisableDiskClause() (localctx IDisableDiskClauseContext) {
	localctx = NewDisableDiskClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, DorisSQLParserParserRULE_disableDiskClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2878)
		p.Match(DorisSQLParserParserDISABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2879)
		p.Match(DorisSQLParserParserDISK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2880)
		p.String_()
	}
	p.SetState(2885)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(2881)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2882)
			p.String_()
		}

		p.SetState(2887)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2888)
		p.Match(DorisSQLParserParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2889)
		p.Match(DorisSQLParserParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2890)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelDisableDiskClauseContext is an interface to support dynamic dispatch.
type ICancelDisableDiskClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	DISK() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	ON() antlr.TerminalNode
	BACKEND() antlr.TerminalNode

	// IsCancelDisableDiskClauseContext differentiates from other interfaces.
	IsCancelDisableDiskClauseContext()
}

type CancelDisableDiskClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelDisableDiskClauseContext() *CancelDisableDiskClauseContext {
	var p = new(CancelDisableDiskClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cancelDisableDiskClause
	return p
}

func InitEmptyCancelDisableDiskClauseContext(p *CancelDisableDiskClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cancelDisableDiskClause
}

func (*CancelDisableDiskClauseContext) IsCancelDisableDiskClauseContext() {}

func NewCancelDisableDiskClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelDisableDiskClauseContext {
	var p = new(CancelDisableDiskClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_cancelDisableDiskClause

	return p
}

func (s *CancelDisableDiskClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelDisableDiskClauseContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCANCEL, 0)
}

func (s *CancelDisableDiskClauseContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDISABLE, 0)
}

func (s *CancelDisableDiskClauseContext) DISK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDISK, 0)
}

func (s *CancelDisableDiskClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *CancelDisableDiskClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CancelDisableDiskClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *CancelDisableDiskClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBACKEND, 0)
}

func (s *CancelDisableDiskClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelDisableDiskClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelDisableDiskClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCancelDisableDiskClause(s)
	}
}

func (s *CancelDisableDiskClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCancelDisableDiskClause(s)
	}
}

func (s *CancelDisableDiskClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCancelDisableDiskClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CancelDisableDiskClause() (localctx ICancelDisableDiskClauseContext) {
	localctx = NewCancelDisableDiskClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, DorisSQLParserParserRULE_cancelDisableDiskClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2892)
		p.Match(DorisSQLParserParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2893)
		p.Match(DorisSQLParserParserDISABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2894)
		p.Match(DorisSQLParserParserDISK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2895)
		p.String_()
	}
	p.SetState(2900)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(2896)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2897)
			p.String_()
		}

		p.SetState(2902)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2903)
		p.Match(DorisSQLParserParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2904)
		p.Match(DorisSQLParserParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2905)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateIndexClauseContext is an interface to support dynamic dispatch.
type ICreateIndexClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// Getter signatures
	ADD() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	Identifier() IIdentifierContext
	IndexType() IIndexTypeContext
	Comment() ICommentContext
	PropertyList() IPropertyListContext

	// IsCreateIndexClauseContext differentiates from other interfaces.
	IsCreateIndexClauseContext()
}

type CreateIndexClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	indexName IIdentifierContext
}

func NewEmptyCreateIndexClauseContext() *CreateIndexClauseContext {
	var p = new(CreateIndexClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createIndexClause
	return p
}

func InitEmptyCreateIndexClauseContext(p *CreateIndexClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createIndexClause
}

func (*CreateIndexClauseContext) IsCreateIndexClauseContext() {}

func NewCreateIndexClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateIndexClauseContext {
	var p = new(CreateIndexClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createIndexClause

	return p
}

func (s *CreateIndexClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateIndexClauseContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *CreateIndexClauseContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *CreateIndexClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADD, 0)
}

func (s *CreateIndexClauseContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINDEX, 0)
}

func (s *CreateIndexClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateIndexClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateIndexClauseContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *CreateIndexClauseContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateIndexClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *CreateIndexClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateIndexClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateIndexClause(s)
	}
}

func (s *CreateIndexClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateIndexClause(s)
	}
}

func (s *CreateIndexClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateIndexClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateIndexClause() (localctx ICreateIndexClauseContext) {
	localctx = NewCreateIndexClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, DorisSQLParserParserRULE_createIndexClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2907)
		p.Match(DorisSQLParserParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2908)
		p.Match(DorisSQLParserParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2909)

		var _x = p.Identifier()

		localctx.(*CreateIndexClauseContext).indexName = _x
	}
	{
		p.SetState(2910)
		p.IdentifierList()
	}
	p.SetState(2915)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserUSING {
		{
			p.SetState(2911)
			p.IndexType()
		}
		p.SetState(2913)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__1 {
			{
				p.SetState(2912)
				p.PropertyList()
			}

		}

	}
	p.SetState(2918)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserCOMMENT {
		{
			p.SetState(2917)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropIndexClauseContext is an interface to support dynamic dispatch.
type IDropIndexClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDropIndexClauseContext differentiates from other interfaces.
	IsDropIndexClauseContext()
}

type DropIndexClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	indexName IIdentifierContext
}

func NewEmptyDropIndexClauseContext() *DropIndexClauseContext {
	var p = new(DropIndexClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropIndexClause
	return p
}

func InitEmptyDropIndexClauseContext(p *DropIndexClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropIndexClause
}

func (*DropIndexClauseContext) IsDropIndexClauseContext() {}

func NewDropIndexClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropIndexClauseContext {
	var p = new(DropIndexClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropIndexClause

	return p
}

func (s *DropIndexClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropIndexClauseContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *DropIndexClauseContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *DropIndexClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropIndexClauseContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINDEX, 0)
}

func (s *DropIndexClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropIndexClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropIndexClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropIndexClause(s)
	}
}

func (s *DropIndexClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropIndexClause(s)
	}
}

func (s *DropIndexClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropIndexClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropIndexClause() (localctx IDropIndexClauseContext) {
	localctx = NewDropIndexClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, DorisSQLParserParserRULE_dropIndexClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2920)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2921)
		p.Match(DorisSQLParserParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2922)

		var _x = p.Identifier()

		localctx.(*DropIndexClauseContext).indexName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableRenameClauseContext is an interface to support dynamic dispatch.
type ITableRenameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RENAME() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsTableRenameClauseContext differentiates from other interfaces.
	IsTableRenameClauseContext()
}

type TableRenameClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableRenameClauseContext() *TableRenameClauseContext {
	var p = new(TableRenameClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_tableRenameClause
	return p
}

func InitEmptyTableRenameClauseContext(p *TableRenameClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_tableRenameClause
}

func (*TableRenameClauseContext) IsTableRenameClauseContext() {}

func NewTableRenameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableRenameClauseContext {
	var p = new(TableRenameClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_tableRenameClause

	return p
}

func (s *TableRenameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TableRenameClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRENAME, 0)
}

func (s *TableRenameClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableRenameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableRenameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableRenameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTableRenameClause(s)
	}
}

func (s *TableRenameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTableRenameClause(s)
	}
}

func (s *TableRenameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTableRenameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) TableRenameClause() (localctx ITableRenameClauseContext) {
	localctx = NewTableRenameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, DorisSQLParserParserRULE_tableRenameClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2924)
		p.Match(DorisSQLParserParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2925)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwapTableClauseContext is an interface to support dynamic dispatch.
type ISwapTableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SWAP() antlr.TerminalNode
	WITH() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsSwapTableClauseContext differentiates from other interfaces.
	IsSwapTableClauseContext()
}

type SwapTableClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwapTableClauseContext() *SwapTableClauseContext {
	var p = new(SwapTableClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_swapTableClause
	return p
}

func InitEmptySwapTableClauseContext(p *SwapTableClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_swapTableClause
}

func (*SwapTableClauseContext) IsSwapTableClauseContext() {}

func NewSwapTableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwapTableClauseContext {
	var p = new(SwapTableClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_swapTableClause

	return p
}

func (s *SwapTableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SwapTableClauseContext) SWAP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSWAP, 0)
}

func (s *SwapTableClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *SwapTableClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SwapTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwapTableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwapTableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSwapTableClause(s)
	}
}

func (s *SwapTableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSwapTableClause(s)
	}
}

func (s *SwapTableClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSwapTableClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SwapTableClause() (localctx ISwapTableClauseContext) {
	localctx = NewSwapTableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, DorisSQLParserParserRULE_swapTableClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2927)
		p.Match(DorisSQLParserParserSWAP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2928)
		p.Match(DorisSQLParserParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2929)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyPropertiesClauseContext is an interface to support dynamic dispatch.
type IModifyPropertiesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsModifyPropertiesClauseContext differentiates from other interfaces.
	IsModifyPropertiesClauseContext()
}

type ModifyPropertiesClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyPropertiesClauseContext() *ModifyPropertiesClauseContext {
	var p = new(ModifyPropertiesClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_modifyPropertiesClause
	return p
}

func InitEmptyModifyPropertiesClauseContext(p *ModifyPropertiesClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_modifyPropertiesClause
}

func (*ModifyPropertiesClauseContext) IsModifyPropertiesClauseContext() {}

func NewModifyPropertiesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyPropertiesClauseContext {
	var p = new(ModifyPropertiesClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_modifyPropertiesClause

	return p
}

func (s *ModifyPropertiesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyPropertiesClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *ModifyPropertiesClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *ModifyPropertiesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyPropertiesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyPropertiesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterModifyPropertiesClause(s)
	}
}

func (s *ModifyPropertiesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitModifyPropertiesClause(s)
	}
}

func (s *ModifyPropertiesClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitModifyPropertiesClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ModifyPropertiesClause() (localctx IModifyPropertiesClauseContext) {
	localctx = NewModifyPropertiesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, DorisSQLParserParserRULE_modifyPropertiesClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2931)
		p.Match(DorisSQLParserParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2932)
		p.PropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyCommentClauseContext is an interface to support dynamic dispatch.
type IModifyCommentClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMENT() antlr.TerminalNode
	EQ() antlr.TerminalNode
	String_() IStringContext

	// IsModifyCommentClauseContext differentiates from other interfaces.
	IsModifyCommentClauseContext()
}

type ModifyCommentClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyCommentClauseContext() *ModifyCommentClauseContext {
	var p = new(ModifyCommentClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_modifyCommentClause
	return p
}

func InitEmptyModifyCommentClauseContext(p *ModifyCommentClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_modifyCommentClause
}

func (*ModifyCommentClauseContext) IsModifyCommentClauseContext() {}

func NewModifyCommentClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyCommentClauseContext {
	var p = new(ModifyCommentClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_modifyCommentClause

	return p
}

func (s *ModifyCommentClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyCommentClauseContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOMMENT, 0)
}

func (s *ModifyCommentClauseContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEQ, 0)
}

func (s *ModifyCommentClauseContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ModifyCommentClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyCommentClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyCommentClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterModifyCommentClause(s)
	}
}

func (s *ModifyCommentClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitModifyCommentClause(s)
	}
}

func (s *ModifyCommentClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitModifyCommentClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ModifyCommentClause() (localctx IModifyCommentClauseContext) {
	localctx = NewModifyCommentClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, DorisSQLParserParserRULE_modifyCommentClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2934)
		p.Match(DorisSQLParserParserCOMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2935)
		p.Match(DorisSQLParserParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2936)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptimizeRangeContext is an interface to support dynamic dispatch.
type IOptimizeRangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStart_ returns the start_ rule contexts.
	GetStart_() IStringContext

	// GetEnd returns the end rule contexts.
	GetEnd() IStringContext

	// SetStart_ sets the start_ rule contexts.
	SetStart_(IStringContext)

	// SetEnd sets the end rule contexts.
	SetEnd(IStringContext)

	// Getter signatures
	BETWEEN() antlr.TerminalNode
	AND() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsOptimizeRangeContext differentiates from other interfaces.
	IsOptimizeRangeContext()
}

type OptimizeRangeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	start_ IStringContext
	end    IStringContext
}

func NewEmptyOptimizeRangeContext() *OptimizeRangeContext {
	var p = new(OptimizeRangeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_optimizeRange
	return p
}

func InitEmptyOptimizeRangeContext(p *OptimizeRangeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_optimizeRange
}

func (*OptimizeRangeContext) IsOptimizeRangeContext() {}

func NewOptimizeRangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptimizeRangeContext {
	var p = new(OptimizeRangeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_optimizeRange

	return p
}

func (s *OptimizeRangeContext) GetParser() antlr.Parser { return s.parser }

func (s *OptimizeRangeContext) GetStart_() IStringContext { return s.start_ }

func (s *OptimizeRangeContext) GetEnd() IStringContext { return s.end }

func (s *OptimizeRangeContext) SetStart_(v IStringContext) { s.start_ = v }

func (s *OptimizeRangeContext) SetEnd(v IStringContext) { s.end = v }

func (s *OptimizeRangeContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBETWEEN, 0)
}

func (s *OptimizeRangeContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAND, 0)
}

func (s *OptimizeRangeContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *OptimizeRangeContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *OptimizeRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptimizeRangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptimizeRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterOptimizeRange(s)
	}
}

func (s *OptimizeRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitOptimizeRange(s)
	}
}

func (s *OptimizeRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitOptimizeRange(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) OptimizeRange() (localctx IOptimizeRangeContext) {
	localctx = NewOptimizeRangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, DorisSQLParserParserRULE_optimizeRange)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2938)
		p.Match(DorisSQLParserParserBETWEEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2939)

		var _x = p.String_()

		localctx.(*OptimizeRangeContext).start_ = _x
	}
	{
		p.SetState(2940)
		p.Match(DorisSQLParserParserAND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2941)

		var _x = p.String_()

		localctx.(*OptimizeRangeContext).end = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptimizeClauseContext is an interface to support dynamic dispatch.
type IOptimizeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PartitionNames() IPartitionNamesContext
	KeyDesc() IKeyDescContext
	PartitionDesc() IPartitionDescContext
	OrderByDesc() IOrderByDescContext
	DistributionDesc() IDistributionDescContext
	OptimizeRange() IOptimizeRangeContext

	// IsOptimizeClauseContext differentiates from other interfaces.
	IsOptimizeClauseContext()
}

type OptimizeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptimizeClauseContext() *OptimizeClauseContext {
	var p = new(OptimizeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_optimizeClause
	return p
}

func InitEmptyOptimizeClauseContext(p *OptimizeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_optimizeClause
}

func (*OptimizeClauseContext) IsOptimizeClauseContext() {}

func NewOptimizeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptimizeClauseContext {
	var p = new(OptimizeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_optimizeClause

	return p
}

func (s *OptimizeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OptimizeClauseContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *OptimizeClauseContext) KeyDesc() IKeyDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyDescContext)
}

func (s *OptimizeClauseContext) PartitionDesc() IPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDescContext)
}

func (s *OptimizeClauseContext) OrderByDesc() IOrderByDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByDescContext)
}

func (s *OptimizeClauseContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *OptimizeClauseContext) OptimizeRange() IOptimizeRangeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptimizeRangeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptimizeRangeContext)
}

func (s *OptimizeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptimizeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptimizeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterOptimizeClause(s)
	}
}

func (s *OptimizeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitOptimizeClause(s)
	}
}

func (s *OptimizeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitOptimizeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) OptimizeClause() (localctx IOptimizeClauseContext) {
	localctx = NewOptimizeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, DorisSQLParserParserRULE_optimizeClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2944)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 223, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2943)
			p.PartitionNames()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2947)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserAGGREGATE || _la == DorisSQLParserParserDUPLICATE || _la == DorisSQLParserParserPRIMARY || _la == DorisSQLParserParserUNIQUE {
		{
			p.SetState(2946)
			p.KeyDesc()
		}

	}
	p.SetState(2950)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPARTITION {
		{
			p.SetState(2949)
			p.PartitionDesc()
		}

	}
	p.SetState(2953)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserORDER {
		{
			p.SetState(2952)
			p.OrderByDesc()
		}

	}
	p.SetState(2956)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserDISTRIBUTED {
		{
			p.SetState(2955)
			p.DistributionDesc()
		}

	}
	p.SetState(2959)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserBETWEEN {
		{
			p.SetState(2958)
			p.OptimizeRange()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddColumnClauseContext is an interface to support dynamic dispatch.
type IAddColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// Getter signatures
	ADD() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	ColumnDesc() IColumnDescContext
	FIRST() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	Properties() IPropertiesContext
	TO() antlr.TerminalNode
	IN() antlr.TerminalNode

	// IsAddColumnClauseContext differentiates from other interfaces.
	IsAddColumnClauseContext()
}

type AddColumnClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
}

func NewEmptyAddColumnClauseContext() *AddColumnClauseContext {
	var p = new(AddColumnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_addColumnClause
	return p
}

func InitEmptyAddColumnClauseContext(p *AddColumnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_addColumnClause
}

func (*AddColumnClauseContext) IsAddColumnClauseContext() {}

func NewAddColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddColumnClauseContext {
	var p = new(AddColumnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_addColumnClause

	return p
}

func (s *AddColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddColumnClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *AddColumnClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *AddColumnClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADD, 0)
}

func (s *AddColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLUMN, 0)
}

func (s *AddColumnClauseContext) ColumnDesc() IColumnDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDescContext)
}

func (s *AddColumnClauseContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFIRST, 0)
}

func (s *AddColumnClauseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAFTER, 0)
}

func (s *AddColumnClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AddColumnClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddColumnClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AddColumnClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTO, 0)
}

func (s *AddColumnClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *AddColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAddColumnClause(s)
	}
}

func (s *AddColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAddColumnClause(s)
	}
}

func (s *AddColumnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAddColumnClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AddColumnClause() (localctx IAddColumnClauseContext) {
	localctx = NewAddColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, DorisSQLParserParserRULE_addColumnClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2961)
		p.Match(DorisSQLParserParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2962)
		p.Match(DorisSQLParserParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2963)
		p.ColumnDesc()
	}
	p.SetState(2967)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserFIRST:
		{
			p.SetState(2964)
			p.Match(DorisSQLParserParserFIRST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserAFTER:
		{
			p.SetState(2965)
			p.Match(DorisSQLParserParserAFTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2966)
			p.Identifier()
		}

	case DorisSQLParserParserEOF, DorisSQLParserParserT__2, DorisSQLParserParserIN, DorisSQLParserParserPROPERTIES, DorisSQLParserParserTO, DorisSQLParserParserSEMICOLON:

	default:
	}
	p.SetState(2971)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIN || _la == DorisSQLParserParserTO {
		{
			p.SetState(2969)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserIN || _la == DorisSQLParserParserTO) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2970)

			var _x = p.Identifier()

			localctx.(*AddColumnClauseContext).rollupName = _x
		}

	}
	p.SetState(2974)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(2973)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddColumnsClauseContext is an interface to support dynamic dispatch.
type IAddColumnsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// Getter signatures
	ADD() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	AllColumnDesc() []IColumnDescContext
	ColumnDesc(i int) IColumnDescContext
	Properties() IPropertiesContext
	TO() antlr.TerminalNode
	IN() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsAddColumnsClauseContext differentiates from other interfaces.
	IsAddColumnsClauseContext()
}

type AddColumnsClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
}

func NewEmptyAddColumnsClauseContext() *AddColumnsClauseContext {
	var p = new(AddColumnsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_addColumnsClause
	return p
}

func InitEmptyAddColumnsClauseContext(p *AddColumnsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_addColumnsClause
}

func (*AddColumnsClauseContext) IsAddColumnsClauseContext() {}

func NewAddColumnsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddColumnsClauseContext {
	var p = new(AddColumnsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_addColumnsClause

	return p
}

func (s *AddColumnsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddColumnsClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *AddColumnsClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *AddColumnsClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADD, 0)
}

func (s *AddColumnsClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLUMN, 0)
}

func (s *AddColumnsClauseContext) AllColumnDesc() []IColumnDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnDescContext); ok {
			len++
		}
	}

	tst := make([]IColumnDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnDescContext); ok {
			tst[i] = t.(IColumnDescContext)
			i++
		}
	}

	return tst
}

func (s *AddColumnsClauseContext) ColumnDesc(i int) IColumnDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDescContext)
}

func (s *AddColumnsClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AddColumnsClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTO, 0)
}

func (s *AddColumnsClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *AddColumnsClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddColumnsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddColumnsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddColumnsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAddColumnsClause(s)
	}
}

func (s *AddColumnsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAddColumnsClause(s)
	}
}

func (s *AddColumnsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAddColumnsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AddColumnsClause() (localctx IAddColumnsClauseContext) {
	localctx = NewAddColumnsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, DorisSQLParserParserRULE_addColumnsClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2976)
		p.Match(DorisSQLParserParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2977)
		p.Match(DorisSQLParserParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2978)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2979)
		p.ColumnDesc()
	}
	p.SetState(2984)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(2980)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2981)
			p.ColumnDesc()
		}

		p.SetState(2986)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2987)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2990)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIN || _la == DorisSQLParserParserTO {
		{
			p.SetState(2988)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserIN || _la == DorisSQLParserParserTO) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2989)

			var _x = p.Identifier()

			localctx.(*AddColumnsClauseContext).rollupName = _x
		}

	}
	p.SetState(2993)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(2992)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropColumnClauseContext is an interface to support dynamic dispatch.
type IDropColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	FROM() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsDropColumnClauseContext differentiates from other interfaces.
	IsDropColumnClauseContext()
}

type DropColumnClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
}

func NewEmptyDropColumnClauseContext() *DropColumnClauseContext {
	var p = new(DropColumnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropColumnClause
	return p
}

func InitEmptyDropColumnClauseContext(p *DropColumnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropColumnClause
}

func (*DropColumnClauseContext) IsDropColumnClauseContext() {}

func NewDropColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropColumnClauseContext {
	var p = new(DropColumnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropColumnClause

	return p
}

func (s *DropColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropColumnClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *DropColumnClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *DropColumnClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLUMN, 0)
}

func (s *DropColumnClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DropColumnClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropColumnClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *DropColumnClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *DropColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropColumnClause(s)
	}
}

func (s *DropColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropColumnClause(s)
	}
}

func (s *DropColumnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropColumnClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropColumnClause() (localctx IDropColumnClauseContext) {
	localctx = NewDropColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, DorisSQLParserParserRULE_dropColumnClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2995)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2996)
		p.Match(DorisSQLParserParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2997)
		p.Identifier()
	}
	p.SetState(3000)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM {
		{
			p.SetState(2998)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2999)

			var _x = p.Identifier()

			localctx.(*DropColumnClauseContext).rollupName = _x
		}

	}
	p.SetState(3003)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(3002)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyColumnClauseContext is an interface to support dynamic dispatch.
type IModifyColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// Getter signatures
	MODIFY() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	ColumnDesc() IColumnDescContext
	FIRST() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	FROM() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsModifyColumnClauseContext differentiates from other interfaces.
	IsModifyColumnClauseContext()
}

type ModifyColumnClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
}

func NewEmptyModifyColumnClauseContext() *ModifyColumnClauseContext {
	var p = new(ModifyColumnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_modifyColumnClause
	return p
}

func InitEmptyModifyColumnClauseContext(p *ModifyColumnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_modifyColumnClause
}

func (*ModifyColumnClauseContext) IsModifyColumnClauseContext() {}

func NewModifyColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyColumnClauseContext {
	var p = new(ModifyColumnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_modifyColumnClause

	return p
}

func (s *ModifyColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyColumnClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *ModifyColumnClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *ModifyColumnClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMODIFY, 0)
}

func (s *ModifyColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLUMN, 0)
}

func (s *ModifyColumnClauseContext) ColumnDesc() IColumnDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDescContext)
}

func (s *ModifyColumnClauseContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFIRST, 0)
}

func (s *ModifyColumnClauseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAFTER, 0)
}

func (s *ModifyColumnClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ModifyColumnClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifyColumnClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ModifyColumnClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *ModifyColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterModifyColumnClause(s)
	}
}

func (s *ModifyColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitModifyColumnClause(s)
	}
}

func (s *ModifyColumnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitModifyColumnClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ModifyColumnClause() (localctx IModifyColumnClauseContext) {
	localctx = NewModifyColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, DorisSQLParserParserRULE_modifyColumnClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3005)
		p.Match(DorisSQLParserParserMODIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3006)
		p.Match(DorisSQLParserParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3007)
		p.ColumnDesc()
	}
	p.SetState(3011)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserFIRST:
		{
			p.SetState(3008)
			p.Match(DorisSQLParserParserFIRST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserAFTER:
		{
			p.SetState(3009)
			p.Match(DorisSQLParserParserAFTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3010)
			p.Identifier()
		}

	case DorisSQLParserParserEOF, DorisSQLParserParserT__2, DorisSQLParserParserFROM, DorisSQLParserParserPROPERTIES, DorisSQLParserParserSEMICOLON:

	default:
	}
	p.SetState(3015)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM {
		{
			p.SetState(3013)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3014)

			var _x = p.Identifier()

			localctx.(*ModifyColumnClauseContext).rollupName = _x
		}

	}
	p.SetState(3018)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(3017)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyColumnCommentClauseContext is an interface to support dynamic dispatch.
type IModifyColumnCommentClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODIFY() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	Identifier() IIdentifierContext
	Comment() ICommentContext

	// IsModifyColumnCommentClauseContext differentiates from other interfaces.
	IsModifyColumnCommentClauseContext()
}

type ModifyColumnCommentClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyColumnCommentClauseContext() *ModifyColumnCommentClauseContext {
	var p = new(ModifyColumnCommentClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_modifyColumnCommentClause
	return p
}

func InitEmptyModifyColumnCommentClauseContext(p *ModifyColumnCommentClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_modifyColumnCommentClause
}

func (*ModifyColumnCommentClauseContext) IsModifyColumnCommentClauseContext() {}

func NewModifyColumnCommentClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyColumnCommentClauseContext {
	var p = new(ModifyColumnCommentClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_modifyColumnCommentClause

	return p
}

func (s *ModifyColumnCommentClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyColumnCommentClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMODIFY, 0)
}

func (s *ModifyColumnCommentClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLUMN, 0)
}

func (s *ModifyColumnCommentClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifyColumnCommentClauseContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *ModifyColumnCommentClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyColumnCommentClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyColumnCommentClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterModifyColumnCommentClause(s)
	}
}

func (s *ModifyColumnCommentClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitModifyColumnCommentClause(s)
	}
}

func (s *ModifyColumnCommentClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitModifyColumnCommentClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ModifyColumnCommentClause() (localctx IModifyColumnCommentClauseContext) {
	localctx = NewModifyColumnCommentClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, DorisSQLParserParserRULE_modifyColumnCommentClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3020)
		p.Match(DorisSQLParserParserMODIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3021)
		p.Match(DorisSQLParserParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3022)
		p.Identifier()
	}
	{
		p.SetState(3023)
		p.Comment()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnRenameClauseContext is an interface to support dynamic dispatch.
type IColumnRenameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOldColumn returns the oldColumn rule contexts.
	GetOldColumn() IIdentifierContext

	// GetNewColumn returns the newColumn rule contexts.
	GetNewColumn() IIdentifierContext

	// SetOldColumn sets the oldColumn rule contexts.
	SetOldColumn(IIdentifierContext)

	// SetNewColumn sets the newColumn rule contexts.
	SetNewColumn(IIdentifierContext)

	// Getter signatures
	RENAME() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	TO() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsColumnRenameClauseContext differentiates from other interfaces.
	IsColumnRenameClauseContext()
}

type ColumnRenameClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	oldColumn IIdentifierContext
	newColumn IIdentifierContext
}

func NewEmptyColumnRenameClauseContext() *ColumnRenameClauseContext {
	var p = new(ColumnRenameClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_columnRenameClause
	return p
}

func InitEmptyColumnRenameClauseContext(p *ColumnRenameClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_columnRenameClause
}

func (*ColumnRenameClauseContext) IsColumnRenameClauseContext() {}

func NewColumnRenameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnRenameClauseContext {
	var p = new(ColumnRenameClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_columnRenameClause

	return p
}

func (s *ColumnRenameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnRenameClauseContext) GetOldColumn() IIdentifierContext { return s.oldColumn }

func (s *ColumnRenameClauseContext) GetNewColumn() IIdentifierContext { return s.newColumn }

func (s *ColumnRenameClauseContext) SetOldColumn(v IIdentifierContext) { s.oldColumn = v }

func (s *ColumnRenameClauseContext) SetNewColumn(v IIdentifierContext) { s.newColumn = v }

func (s *ColumnRenameClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRENAME, 0)
}

func (s *ColumnRenameClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLUMN, 0)
}

func (s *ColumnRenameClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTO, 0)
}

func (s *ColumnRenameClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnRenameClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnRenameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnRenameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnRenameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterColumnRenameClause(s)
	}
}

func (s *ColumnRenameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitColumnRenameClause(s)
	}
}

func (s *ColumnRenameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitColumnRenameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ColumnRenameClause() (localctx IColumnRenameClauseContext) {
	localctx = NewColumnRenameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, DorisSQLParserParserRULE_columnRenameClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3025)
		p.Match(DorisSQLParserParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3026)
		p.Match(DorisSQLParserParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3027)

		var _x = p.Identifier()

		localctx.(*ColumnRenameClauseContext).oldColumn = _x
	}
	{
		p.SetState(3028)
		p.Match(DorisSQLParserParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3029)

		var _x = p.Identifier()

		localctx.(*ColumnRenameClauseContext).newColumn = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReorderColumnsClauseContext is an interface to support dynamic dispatch.
type IReorderColumnsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	FROM() antlr.TerminalNode
	Properties() IPropertiesContext
	Identifier() IIdentifierContext

	// IsReorderColumnsClauseContext differentiates from other interfaces.
	IsReorderColumnsClauseContext()
}

type ReorderColumnsClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
}

func NewEmptyReorderColumnsClauseContext() *ReorderColumnsClauseContext {
	var p = new(ReorderColumnsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_reorderColumnsClause
	return p
}

func InitEmptyReorderColumnsClauseContext(p *ReorderColumnsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_reorderColumnsClause
}

func (*ReorderColumnsClauseContext) IsReorderColumnsClauseContext() {}

func NewReorderColumnsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReorderColumnsClauseContext {
	var p = new(ReorderColumnsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_reorderColumnsClause

	return p
}

func (s *ReorderColumnsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReorderColumnsClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *ReorderColumnsClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *ReorderColumnsClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserORDER, 0)
}

func (s *ReorderColumnsClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *ReorderColumnsClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ReorderColumnsClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ReorderColumnsClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *ReorderColumnsClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReorderColumnsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReorderColumnsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReorderColumnsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterReorderColumnsClause(s)
	}
}

func (s *ReorderColumnsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitReorderColumnsClause(s)
	}
}

func (s *ReorderColumnsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitReorderColumnsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ReorderColumnsClause() (localctx IReorderColumnsClauseContext) {
	localctx = NewReorderColumnsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, DorisSQLParserParserRULE_reorderColumnsClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3031)
		p.Match(DorisSQLParserParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3032)
		p.Match(DorisSQLParserParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3033)
		p.IdentifierList()
	}
	p.SetState(3036)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM {
		{
			p.SetState(3034)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3035)

			var _x = p.Identifier()

			localctx.(*ReorderColumnsClauseContext).rollupName = _x
		}

	}
	p.SetState(3039)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(3038)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollupRenameClauseContext is an interface to support dynamic dispatch.
type IRollupRenameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// GetNewRollupName returns the newRollupName rule contexts.
	GetNewRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// SetNewRollupName sets the newRollupName rule contexts.
	SetNewRollupName(IIdentifierContext)

	// Getter signatures
	RENAME() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsRollupRenameClauseContext differentiates from other interfaces.
	IsRollupRenameClauseContext()
}

type RollupRenameClauseContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	rollupName    IIdentifierContext
	newRollupName IIdentifierContext
}

func NewEmptyRollupRenameClauseContext() *RollupRenameClauseContext {
	var p = new(RollupRenameClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_rollupRenameClause
	return p
}

func InitEmptyRollupRenameClauseContext(p *RollupRenameClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_rollupRenameClause
}

func (*RollupRenameClauseContext) IsRollupRenameClauseContext() {}

func NewRollupRenameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollupRenameClauseContext {
	var p = new(RollupRenameClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_rollupRenameClause

	return p
}

func (s *RollupRenameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RollupRenameClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *RollupRenameClauseContext) GetNewRollupName() IIdentifierContext { return s.newRollupName }

func (s *RollupRenameClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *RollupRenameClauseContext) SetNewRollupName(v IIdentifierContext) { s.newRollupName = v }

func (s *RollupRenameClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRENAME, 0)
}

func (s *RollupRenameClauseContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROLLUP, 0)
}

func (s *RollupRenameClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RollupRenameClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RollupRenameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupRenameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollupRenameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRollupRenameClause(s)
	}
}

func (s *RollupRenameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRollupRenameClause(s)
	}
}

func (s *RollupRenameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRollupRenameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) RollupRenameClause() (localctx IRollupRenameClauseContext) {
	localctx = NewRollupRenameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, DorisSQLParserParserRULE_rollupRenameClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3041)
		p.Match(DorisSQLParserParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3042)
		p.Match(DorisSQLParserParserROLLUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3043)

		var _x = p.Identifier()

		localctx.(*RollupRenameClauseContext).rollupName = _x
	}
	{
		p.SetState(3044)

		var _x = p.Identifier()

		localctx.(*RollupRenameClauseContext).newRollupName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompactionClauseContext is an interface to support dynamic dispatch.
type ICompactionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMPACT() antlr.TerminalNode
	Identifier() IIdentifierContext
	IdentifierList() IIdentifierListContext
	BASE() antlr.TerminalNode
	CUMULATIVE() antlr.TerminalNode

	// IsCompactionClauseContext differentiates from other interfaces.
	IsCompactionClauseContext()
}

type CompactionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompactionClauseContext() *CompactionClauseContext {
	var p = new(CompactionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_compactionClause
	return p
}

func InitEmptyCompactionClauseContext(p *CompactionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_compactionClause
}

func (*CompactionClauseContext) IsCompactionClauseContext() {}

func NewCompactionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompactionClauseContext {
	var p = new(CompactionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_compactionClause

	return p
}

func (s *CompactionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CompactionClauseContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOMPACT, 0)
}

func (s *CompactionClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CompactionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CompactionClauseContext) BASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBASE, 0)
}

func (s *CompactionClauseContext) CUMULATIVE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCUMULATIVE, 0)
}

func (s *CompactionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompactionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompactionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCompactionClause(s)
	}
}

func (s *CompactionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCompactionClause(s)
	}
}

func (s *CompactionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCompactionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CompactionClause() (localctx ICompactionClauseContext) {
	localctx = NewCompactionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, DorisSQLParserParserRULE_compactionClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3047)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserBASE || _la == DorisSQLParserParserCUMULATIVE {
		{
			p.SetState(3046)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserBASE || _la == DorisSQLParserParserCUMULATIVE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3049)
		p.Match(DorisSQLParserParserCOMPACT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3052)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserACCESS, DorisSQLParserParserACTIVE, DorisSQLParserParserADMIN, DorisSQLParserParserADVISOR, DorisSQLParserParserAFTER, DorisSQLParserParserAGGREGATE, DorisSQLParserParserANTI, DorisSQLParserParserAPPLY, DorisSQLParserParserARRAY_AGG, DorisSQLParserParserARRAY_AGG_DISTINCT, DorisSQLParserParserASYNC, DorisSQLParserParserAUTHORS, DorisSQLParserParserAUTHENTICATION, DorisSQLParserParserAUTOMATED, DorisSQLParserParserAUTO_INCREMENT, DorisSQLParserParserAVG, DorisSQLParserParserBACKEND, DorisSQLParserParserBACKENDS, DorisSQLParserParserBACKUP, DorisSQLParserParserBASE, DorisSQLParserParserBASELINE, DorisSQLParserParserBEGIN, DorisSQLParserParserBINARY, DorisSQLParserParserBITMAP_UNION, DorisSQLParserParserBLACKHOLE, DorisSQLParserParserBLACKLIST, DorisSQLParserParserBODY, DorisSQLParserParserBOOLEAN, DorisSQLParserParserBRANCH, DorisSQLParserParserBROKER, DorisSQLParserParserBUCKETS, DorisSQLParserParserBUILTIN, DorisSQLParserParserCACHE, DorisSQLParserParserCANCEL, DorisSQLParserParserCAST, DorisSQLParserParserCATALOG, DorisSQLParserParserCATALOGS, DorisSQLParserParserCEIL, DorisSQLParserParserCHAIN, DorisSQLParserParserCHARSET, DorisSQLParserParserCLEAN, DorisSQLParserParserCLEAR, DorisSQLParserParserCLUSTER, DorisSQLParserParserCLUSTERS, DorisSQLParserParserCNGROUP, DorisSQLParserParserCNGROUPS, DorisSQLParserParserCOLLATION, DorisSQLParserParserCOLUMNS, DorisSQLParserParserCOMMENT, DorisSQLParserParserCOMMIT, DorisSQLParserParserCOMMITTED, DorisSQLParserParserCOMPACT, DorisSQLParserParserCOMPUTE, DorisSQLParserParserCONFIG, DorisSQLParserParserCONNECTION, DorisSQLParserParserCONSISTENT, DorisSQLParserParserCOSTS, DorisSQLParserParserCOUNT, DorisSQLParserParserCUME_DIST, DorisSQLParserParserCUMULATIVE, DorisSQLParserParserCURRENT, DorisSQLParserParserDATA, DorisSQLParserParserDATACACHE, DorisSQLParserParserDATE, DorisSQLParserParserDATETIME, DorisSQLParserParserDAY, DorisSQLParserParserDAYS, DorisSQLParserParserDEALLOCATE, DorisSQLParserParserDECOMMISSION, DorisSQLParserParserDIALECT, DorisSQLParserParserDICTIONARY, DorisSQLParserParserDICTIONARY_GET, DorisSQLParserParserDISABLE, DorisSQLParserParserDISTRIBUTED, DorisSQLParserParserDISTRIBUTION, DorisSQLParserParserDUPLICATE, DorisSQLParserParserDYNAMIC, DorisSQLParserParserENABLE, DorisSQLParserParserENCLOSE, DorisSQLParserParserEND, DorisSQLParserParserENGINE, DorisSQLParserParserENGINES, DorisSQLParserParserERRORS, DorisSQLParserParserESCAPE, DorisSQLParserParserEVENTS, DorisSQLParserParserEXCEPT, DorisSQLParserParserEXCLUDE, DorisSQLParserParserEXECUTE, DorisSQLParserParserEXPORT, DorisSQLParserParserEXTERNAL, DorisSQLParserParserEXTRACT, DorisSQLParserParserEVERY, DorisSQLParserParserFAILPOINT, DorisSQLParserParserFAILPOINTS, DorisSQLParserParserFIELDS, DorisSQLParserParserFILE, DorisSQLParserParserFILTER, DorisSQLParserParserFIRST, DorisSQLParserParserFLOOR, DorisSQLParserParserFN, DorisSQLParserParserFOLLOWING, DorisSQLParserParserFOLLOWER, DorisSQLParserParserFORMAT, DorisSQLParserParserFREE, DorisSQLParserParserFRONTEND, DorisSQLParserParserFRONTENDS, DorisSQLParserParserFUNCTIONS, DorisSQLParserParserGLOBAL, DorisSQLParserParserGRANTS, DorisSQLParserParserGROUP_CONCAT, DorisSQLParserParserHASH, DorisSQLParserParserHELP, DorisSQLParserParserHISTOGRAM, DorisSQLParserParserHLL_UNION, DorisSQLParserParserHOST, DorisSQLParserParserHOUR, DorisSQLParserParserHOURS, DorisSQLParserParserHUB, DorisSQLParserParserIDENTIFIED, DorisSQLParserParserIMPERSONATE, DorisSQLParserParserIMAGE, DorisSQLParserParserINACTIVE, DorisSQLParserParserINCREMENTAL, DorisSQLParserParserINDEXES, DorisSQLParserParserINSTALL, DorisSQLParserParserINTEGRATION, DorisSQLParserParserINTEGRATIONS, DorisSQLParserParserINTERMEDIATE, DorisSQLParserParserINTERVAL, DorisSQLParserParserOVERWRITE, DorisSQLParserParserISOLATION, DorisSQLParserParserJOB, DorisSQLParserParserLABEL, DorisSQLParserParserLAST, DorisSQLParserParserLESS, DorisSQLParserParserLEVEL, DorisSQLParserParserLIST, DorisSQLParserParserLOCAL, DorisSQLParserParserLOCATION, DorisSQLParserParserLOCATIONS, DorisSQLParserParserLOGS, DorisSQLParserParserLOGICAL, DorisSQLParserParserMANUAL, DorisSQLParserParserMAP, DorisSQLParserParserMAPPING, DorisSQLParserParserMAPPINGS, DorisSQLParserParserMASKING, DorisSQLParserParserMATCH, DorisSQLParserParserMATERIALIZED, DorisSQLParserParserMAX, DorisSQLParserParserMERGE, DorisSQLParserParserMIN, DorisSQLParserParserMINUTE, DorisSQLParserParserMINUTES, DorisSQLParserParserMINUS, DorisSQLParserParserMETA, DorisSQLParserParserMODE, DorisSQLParserParserMODIFY, DorisSQLParserParserMONTH, DorisSQLParserParserMULTIPLE, DorisSQLParserParserNAME, DorisSQLParserParserNAMES, DorisSQLParserParserNEGATIVE, DorisSQLParserParserNGRAMBF, DorisSQLParserParserNO, DorisSQLParserParserNODE, DorisSQLParserParserNODES, DorisSQLParserParserNONE, DorisSQLParserParserNULLS, DorisSQLParserParserNUMBER, DorisSQLParserParserNUMERIC, DorisSQLParserParserOBSERVER, DorisSQLParserParserOF, DorisSQLParserParserOFF, DorisSQLParserParserOFFSET, DorisSQLParserParserONLY, DorisSQLParserParserOPEN, DorisSQLParserParserOPERATE, DorisSQLParserParserOPTIMIZER, DorisSQLParserParserOPTION, DorisSQLParserParserPARTITIONS, DorisSQLParserParserPASSWORD, DorisSQLParserParserPATH, DorisSQLParserParserPAUSE, DorisSQLParserParserPENDING, DorisSQLParserParserPERCENT_RANK, DorisSQLParserParserPERCENTILE_UNION, DorisSQLParserParserPLAN, DorisSQLParserParserPLUGIN, DorisSQLParserParserPLUGINS, DorisSQLParserParserPIPE, DorisSQLParserParserPIPES, DorisSQLParserParserPIVOT, DorisSQLParserParserPOLICY, DorisSQLParserParserPOLICIES, DorisSQLParserParserPRECEDING, DorisSQLParserParserPREDICATE, DorisSQLParserParserPRIORITY, DorisSQLParserParserPRIVILEGES, DorisSQLParserParserPROBABILITY, DorisSQLParserParserPROC, DorisSQLParserParserPROCESSLIST, DorisSQLParserParserPROFILE, DorisSQLParserParserPROFILELIST, DorisSQLParserParserPROPERTIES, DorisSQLParserParserPROPERTY, DorisSQLParserParserPROVIDER, DorisSQLParserParserPROVIDERS, DorisSQLParserParserQUALIFY, DorisSQLParserParserQUARTER, DorisSQLParserParserQUERY, DorisSQLParserParserQUERIES, DorisSQLParserParserQUEUE, DorisSQLParserParserQUOTA, DorisSQLParserParserRANDOM, DorisSQLParserParserRANK, DorisSQLParserParserREASON, DorisSQLParserParserRECOVER, DorisSQLParserParserREFRESH, DorisSQLParserParserREWRITE, DorisSQLParserParserREMOVE, DorisSQLParserParserREPAIR, DorisSQLParserParserREPEATABLE, DorisSQLParserParserREPLACE_IF_NOT_NULL, DorisSQLParserParserREPLICA, DorisSQLParserParserREPOSITORY, DorisSQLParserParserREPOSITORIES, DorisSQLParserParserRESOURCE, DorisSQLParserParserRESOURCES, DorisSQLParserParserRESTORE, DorisSQLParserParserRESUME, DorisSQLParserParserRETAIN, DorisSQLParserParserRETENTION, DorisSQLParserParserRETURNS, DorisSQLParserParserRETRY, DorisSQLParserParserREVERT, DorisSQLParserParserROLE, DorisSQLParserParserROLES, DorisSQLParserParserROLLBACK, DorisSQLParserParserROLLUP, DorisSQLParserParserROUTINE, DorisSQLParserParserROW, DorisSQLParserParserRULE, DorisSQLParserParserRULES, DorisSQLParserParserRUNNING, DorisSQLParserParserSAMPLE, DorisSQLParserParserSCHEDULE, DorisSQLParserParserSCHEDULER, DorisSQLParserParserSECOND, DorisSQLParserParserSECURITY, DorisSQLParserParserSEMI, DorisSQLParserParserSEPARATOR, DorisSQLParserParserSERIALIZABLE, DorisSQLParserParserSESSION, DorisSQLParserParserSETS, DorisSQLParserParserSIGNED, DorisSQLParserParserSKIP_HEADER, DorisSQLParserParserSNAPSHOT, DorisSQLParserParserSNAPSHOTS, DorisSQLParserParserSQLBLACKLIST, DorisSQLParserParserSTART, DorisSQLParserParserSTATS, DorisSQLParserParserSTATUS, DorisSQLParserParserSTOP, DorisSQLParserParserSTORAGE, DorisSQLParserParserSTREAM, DorisSQLParserParserSTRING, DorisSQLParserParserSUBMIT, DorisSQLParserParserSUM, DorisSQLParserParserSUSPEND, DorisSQLParserParserSYNC, DorisSQLParserParserSYSTEM_TIME, DorisSQLParserParserSWAP, DorisSQLParserParserSTRUCT, DorisSQLParserParserTABLES, DorisSQLParserParserTABLET, DorisSQLParserParserTABLETS, DorisSQLParserParserTAG, DorisSQLParserParserTASK, DorisSQLParserParserTEMPORARY, DorisSQLParserParserTHAN, DorisSQLParserParserTIME, DorisSQLParserParserTIMES, DorisSQLParserParserTIMESTAMP, DorisSQLParserParserTIMESTAMPADD, DorisSQLParserParserTIMESTAMPDIFF, DorisSQLParserParserTRANSACTION, DorisSQLParserParserTRANSLATE, DorisSQLParserParserTRACE, DorisSQLParserParserTRIGGERS, DorisSQLParserParserTRIM_SPACE, DorisSQLParserParserTRUNCATE, DorisSQLParserParserTYPE, DorisSQLParserParserTYPES, DorisSQLParserParserUNBOUNDED, DorisSQLParserParserUNCOMMITTED, DorisSQLParserParserUNINSTALL, DorisSQLParserParserUNSET, DorisSQLParserParserUSAGE, DorisSQLParserParserUSER, DorisSQLParserParserUSERS, DorisSQLParserParserVALUE, DorisSQLParserParserVARBINARY, DorisSQLParserParserVARIABLES, DorisSQLParserParserVECTOR, DorisSQLParserParserVERBOSE, DorisSQLParserParserVERSION, DorisSQLParserParserVIEW, DorisSQLParserParserVIEWS, DorisSQLParserParserVOLUME, DorisSQLParserParserVOLUMES, DorisSQLParserParserWAREHOUSE, DorisSQLParserParserWAREHOUSES, DorisSQLParserParserWARNINGS, DorisSQLParserParserWEEK, DorisSQLParserParserWHITELIST, DorisSQLParserParserWORK, DorisSQLParserParserWRITE, DorisSQLParserParserYEAR, DorisSQLParserParserLOCK, DorisSQLParserParserUNLOCK, DorisSQLParserParserLOW_PRIORITY, DorisSQLParserParserDISK, DorisSQLParserParserBEFORE, DorisSQLParserParserFIELD, DorisSQLParserParserPERSISTENT, DorisSQLParserParserARRAY_ELEMENT, DorisSQLParserParserLETTER_IDENTIFIER, DorisSQLParserParserDIGIT_IDENTIFIER, DorisSQLParserParserBACKQUOTED_IDENTIFIER, DorisSQLParserParserDOTDOTDOT:
		{
			p.SetState(3050)
			p.Identifier()
		}

	case DorisSQLParserParserT__1:
		{
			p.SetState(3051)
			p.IdentifierList()
		}

	case DorisSQLParserParserEOF, DorisSQLParserParserT__2, DorisSQLParserParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubfieldNameContext is an interface to support dynamic dispatch.
type ISubfieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ARRAY_ELEMENT() antlr.TerminalNode

	// IsSubfieldNameContext differentiates from other interfaces.
	IsSubfieldNameContext()
}

type SubfieldNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubfieldNameContext() *SubfieldNameContext {
	var p = new(SubfieldNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_subfieldName
	return p
}

func InitEmptySubfieldNameContext(p *SubfieldNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_subfieldName
}

func (*SubfieldNameContext) IsSubfieldNameContext() {}

func NewSubfieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubfieldNameContext {
	var p = new(SubfieldNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_subfieldName

	return p
}

func (s *SubfieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SubfieldNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubfieldNameContext) ARRAY_ELEMENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserARRAY_ELEMENT, 0)
}

func (s *SubfieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubfieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubfieldNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSubfieldName(s)
	}
}

func (s *SubfieldNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSubfieldName(s)
	}
}

func (s *SubfieldNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSubfieldName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SubfieldName() (localctx ISubfieldNameContext) {
	localctx = NewSubfieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, DorisSQLParserParserRULE_subfieldName)
	p.SetState(3056)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 244, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3054)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3055)
			p.Match(DorisSQLParserParserARRAY_ELEMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INestedFieldNameContext is an interface to support dynamic dispatch.
type INestedFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSubfieldName() []ISubfieldNameContext
	SubfieldName(i int) ISubfieldNameContext
	AllDOT_IDENTIFIER() []antlr.TerminalNode
	DOT_IDENTIFIER(i int) antlr.TerminalNode

	// IsNestedFieldNameContext differentiates from other interfaces.
	IsNestedFieldNameContext()
}

type NestedFieldNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNestedFieldNameContext() *NestedFieldNameContext {
	var p = new(NestedFieldNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_nestedFieldName
	return p
}

func InitEmptyNestedFieldNameContext(p *NestedFieldNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_nestedFieldName
}

func (*NestedFieldNameContext) IsNestedFieldNameContext() {}

func NewNestedFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NestedFieldNameContext {
	var p = new(NestedFieldNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_nestedFieldName

	return p
}

func (s *NestedFieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *NestedFieldNameContext) AllSubfieldName() []ISubfieldNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubfieldNameContext); ok {
			len++
		}
	}

	tst := make([]ISubfieldNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubfieldNameContext); ok {
			tst[i] = t.(ISubfieldNameContext)
			i++
		}
	}

	return tst
}

func (s *NestedFieldNameContext) SubfieldName(i int) ISubfieldNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubfieldNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubfieldNameContext)
}

func (s *NestedFieldNameContext) AllDOT_IDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserDOT_IDENTIFIER)
}

func (s *NestedFieldNameContext) DOT_IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDOT_IDENTIFIER, i)
}

func (s *NestedFieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedFieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NestedFieldNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterNestedFieldName(s)
	}
}

func (s *NestedFieldNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitNestedFieldName(s)
	}
}

func (s *NestedFieldNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitNestedFieldName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) NestedFieldName() (localctx INestedFieldNameContext) {
	localctx = NewNestedFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, DorisSQLParserParserRULE_nestedFieldName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3058)
		p.SubfieldName()
	}
	p.SetState(3064)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__0 || _la == DorisSQLParserParserDOT_IDENTIFIER {
		p.SetState(3062)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserParserDOT_IDENTIFIER:
			{
				p.SetState(3059)
				p.Match(DorisSQLParserParserDOT_IDENTIFIER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisSQLParserParserT__0:
			{
				p.SetState(3060)
				p.Match(DorisSQLParserParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3061)
				p.SubfieldName()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(3066)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddFieldClauseContext is an interface to support dynamic dispatch.
type IAddFieldClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODIFY() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	ADD() antlr.TerminalNode
	FIELD() antlr.TerminalNode
	SubfieldDesc() ISubfieldDescContext
	FIRST() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsAddFieldClauseContext differentiates from other interfaces.
	IsAddFieldClauseContext()
}

type AddFieldClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddFieldClauseContext() *AddFieldClauseContext {
	var p = new(AddFieldClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_addFieldClause
	return p
}

func InitEmptyAddFieldClauseContext(p *AddFieldClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_addFieldClause
}

func (*AddFieldClauseContext) IsAddFieldClauseContext() {}

func NewAddFieldClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddFieldClauseContext {
	var p = new(AddFieldClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_addFieldClause

	return p
}

func (s *AddFieldClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddFieldClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMODIFY, 0)
}

func (s *AddFieldClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLUMN, 0)
}

func (s *AddFieldClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AddFieldClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddFieldClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADD, 0)
}

func (s *AddFieldClauseContext) FIELD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFIELD, 0)
}

func (s *AddFieldClauseContext) SubfieldDesc() ISubfieldDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubfieldDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubfieldDescContext)
}

func (s *AddFieldClauseContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFIRST, 0)
}

func (s *AddFieldClauseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAFTER, 0)
}

func (s *AddFieldClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AddFieldClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddFieldClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddFieldClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAddFieldClause(s)
	}
}

func (s *AddFieldClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAddFieldClause(s)
	}
}

func (s *AddFieldClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAddFieldClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AddFieldClause() (localctx IAddFieldClauseContext) {
	localctx = NewAddFieldClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, DorisSQLParserParserRULE_addFieldClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3067)
		p.Match(DorisSQLParserParserMODIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3068)
		p.Match(DorisSQLParserParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3069)
		p.Identifier()
	}
	{
		p.SetState(3070)
		p.Match(DorisSQLParserParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3071)
		p.Match(DorisSQLParserParserFIELD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3072)
		p.SubfieldDesc()
	}
	p.SetState(3076)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserFIRST:
		{
			p.SetState(3073)
			p.Match(DorisSQLParserParserFIRST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserAFTER:
		{
			p.SetState(3074)
			p.Match(DorisSQLParserParserAFTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3075)
			p.Identifier()
		}

	case DorisSQLParserParserEOF, DorisSQLParserParserT__2, DorisSQLParserParserPROPERTIES, DorisSQLParserParserSEMICOLON:

	default:
	}
	p.SetState(3079)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(3078)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropFieldClauseContext is an interface to support dynamic dispatch.
type IDropFieldClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODIFY() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	Identifier() IIdentifierContext
	DROP() antlr.TerminalNode
	FIELD() antlr.TerminalNode
	NestedFieldName() INestedFieldNameContext
	Properties() IPropertiesContext

	// IsDropFieldClauseContext differentiates from other interfaces.
	IsDropFieldClauseContext()
}

type DropFieldClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropFieldClauseContext() *DropFieldClauseContext {
	var p = new(DropFieldClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropFieldClause
	return p
}

func InitEmptyDropFieldClauseContext(p *DropFieldClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropFieldClause
}

func (*DropFieldClauseContext) IsDropFieldClauseContext() {}

func NewDropFieldClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFieldClauseContext {
	var p = new(DropFieldClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropFieldClause

	return p
}

func (s *DropFieldClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFieldClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMODIFY, 0)
}

func (s *DropFieldClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLUMN, 0)
}

func (s *DropFieldClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropFieldClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropFieldClauseContext) FIELD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFIELD, 0)
}

func (s *DropFieldClauseContext) NestedFieldName() INestedFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedFieldNameContext)
}

func (s *DropFieldClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *DropFieldClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFieldClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropFieldClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropFieldClause(s)
	}
}

func (s *DropFieldClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropFieldClause(s)
	}
}

func (s *DropFieldClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropFieldClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropFieldClause() (localctx IDropFieldClauseContext) {
	localctx = NewDropFieldClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, DorisSQLParserParserRULE_dropFieldClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3081)
		p.Match(DorisSQLParserParserMODIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3082)
		p.Match(DorisSQLParserParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3083)
		p.Identifier()
	}
	{
		p.SetState(3084)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3085)
		p.Match(DorisSQLParserParserFIELD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3086)
		p.NestedFieldName()
	}
	p.SetState(3088)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(3087)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateOrReplaceTagClauseContext is an interface to support dynamic dispatch.
type ICreateOrReplaceTagClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLACE() antlr.TerminalNode
	TAG() antlr.TerminalNode
	Identifier() IIdentifierContext
	TagOptions() ITagOptionsContext
	CREATE() antlr.TerminalNode
	OR() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsCreateOrReplaceTagClauseContext differentiates from other interfaces.
	IsCreateOrReplaceTagClauseContext()
}

type CreateOrReplaceTagClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateOrReplaceTagClauseContext() *CreateOrReplaceTagClauseContext {
	var p = new(CreateOrReplaceTagClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createOrReplaceTagClause
	return p
}

func InitEmptyCreateOrReplaceTagClauseContext(p *CreateOrReplaceTagClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createOrReplaceTagClause
}

func (*CreateOrReplaceTagClauseContext) IsCreateOrReplaceTagClauseContext() {}

func NewCreateOrReplaceTagClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateOrReplaceTagClauseContext {
	var p = new(CreateOrReplaceTagClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createOrReplaceTagClause

	return p
}

func (s *CreateOrReplaceTagClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateOrReplaceTagClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPLACE, 0)
}

func (s *CreateOrReplaceTagClauseContext) TAG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTAG, 0)
}

func (s *CreateOrReplaceTagClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateOrReplaceTagClauseContext) TagOptions() ITagOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITagOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITagOptionsContext)
}

func (s *CreateOrReplaceTagClauseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateOrReplaceTagClauseContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOR, 0)
}

func (s *CreateOrReplaceTagClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *CreateOrReplaceTagClauseContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *CreateOrReplaceTagClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *CreateOrReplaceTagClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateOrReplaceTagClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateOrReplaceTagClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateOrReplaceTagClause(s)
	}
}

func (s *CreateOrReplaceTagClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateOrReplaceTagClause(s)
	}
}

func (s *CreateOrReplaceTagClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateOrReplaceTagClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateOrReplaceTagClause() (localctx ICreateOrReplaceTagClauseContext) {
	localctx = NewCreateOrReplaceTagClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, DorisSQLParserParserRULE_createOrReplaceTagClause)
	var _la int

	p.SetState(3109)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 252, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3092)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserCREATE {
			{
				p.SetState(3090)
				p.Match(DorisSQLParserParserCREATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3091)
				p.Match(DorisSQLParserParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3094)
			p.Match(DorisSQLParserParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3095)
			p.Match(DorisSQLParserParserTAG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3096)
			p.Identifier()
		}
		{
			p.SetState(3097)
			p.TagOptions()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3099)
			p.Match(DorisSQLParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3100)
			p.Match(DorisSQLParserParserTAG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3104)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserIF {
			{
				p.SetState(3101)
				p.Match(DorisSQLParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3102)
				p.Match(DorisSQLParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3103)
				p.Match(DorisSQLParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3106)
			p.Identifier()
		}
		{
			p.SetState(3107)
			p.TagOptions()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateOrReplaceBranchClauseContext is an interface to support dynamic dispatch.
type ICreateOrReplaceBranchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLACE() antlr.TerminalNode
	BRANCH() antlr.TerminalNode
	Identifier() IIdentifierContext
	BranchOptions() IBranchOptionsContext
	CREATE() antlr.TerminalNode
	OR() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsCreateOrReplaceBranchClauseContext differentiates from other interfaces.
	IsCreateOrReplaceBranchClauseContext()
}

type CreateOrReplaceBranchClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateOrReplaceBranchClauseContext() *CreateOrReplaceBranchClauseContext {
	var p = new(CreateOrReplaceBranchClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createOrReplaceBranchClause
	return p
}

func InitEmptyCreateOrReplaceBranchClauseContext(p *CreateOrReplaceBranchClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createOrReplaceBranchClause
}

func (*CreateOrReplaceBranchClauseContext) IsCreateOrReplaceBranchClauseContext() {}

func NewCreateOrReplaceBranchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateOrReplaceBranchClauseContext {
	var p = new(CreateOrReplaceBranchClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createOrReplaceBranchClause

	return p
}

func (s *CreateOrReplaceBranchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateOrReplaceBranchClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPLACE, 0)
}

func (s *CreateOrReplaceBranchClauseContext) BRANCH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBRANCH, 0)
}

func (s *CreateOrReplaceBranchClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateOrReplaceBranchClauseContext) BranchOptions() IBranchOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBranchOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBranchOptionsContext)
}

func (s *CreateOrReplaceBranchClauseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateOrReplaceBranchClauseContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOR, 0)
}

func (s *CreateOrReplaceBranchClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *CreateOrReplaceBranchClauseContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *CreateOrReplaceBranchClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *CreateOrReplaceBranchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateOrReplaceBranchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateOrReplaceBranchClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateOrReplaceBranchClause(s)
	}
}

func (s *CreateOrReplaceBranchClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateOrReplaceBranchClause(s)
	}
}

func (s *CreateOrReplaceBranchClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateOrReplaceBranchClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateOrReplaceBranchClause() (localctx ICreateOrReplaceBranchClauseContext) {
	localctx = NewCreateOrReplaceBranchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, DorisSQLParserParserRULE_createOrReplaceBranchClause)
	var _la int

	p.SetState(3130)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 255, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3113)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserCREATE {
			{
				p.SetState(3111)
				p.Match(DorisSQLParserParserCREATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3112)
				p.Match(DorisSQLParserParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3115)
			p.Match(DorisSQLParserParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3116)
			p.Match(DorisSQLParserParserBRANCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3117)
			p.Identifier()
		}
		{
			p.SetState(3118)
			p.BranchOptions()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3120)
			p.Match(DorisSQLParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3121)
			p.Match(DorisSQLParserParserBRANCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3125)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserIF {
			{
				p.SetState(3122)
				p.Match(DorisSQLParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3123)
				p.Match(DorisSQLParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3124)
				p.Match(DorisSQLParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3127)
			p.Identifier()
		}
		{
			p.SetState(3128)
			p.BranchOptions()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropBranchClauseContext is an interface to support dynamic dispatch.
type IDropBranchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	BRANCH() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropBranchClauseContext differentiates from other interfaces.
	IsDropBranchClauseContext()
}

type DropBranchClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropBranchClauseContext() *DropBranchClauseContext {
	var p = new(DropBranchClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropBranchClause
	return p
}

func InitEmptyDropBranchClauseContext(p *DropBranchClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropBranchClause
}

func (*DropBranchClauseContext) IsDropBranchClauseContext() {}

func NewDropBranchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropBranchClauseContext {
	var p = new(DropBranchClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropBranchClause

	return p
}

func (s *DropBranchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropBranchClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropBranchClauseContext) BRANCH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBRANCH, 0)
}

func (s *DropBranchClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropBranchClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *DropBranchClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *DropBranchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropBranchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropBranchClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropBranchClause(s)
	}
}

func (s *DropBranchClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropBranchClause(s)
	}
}

func (s *DropBranchClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropBranchClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropBranchClause() (localctx IDropBranchClauseContext) {
	localctx = NewDropBranchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, DorisSQLParserParserRULE_dropBranchClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3132)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3133)
		p.Match(DorisSQLParserParserBRANCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3136)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(3134)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3135)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3138)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTagClauseContext is an interface to support dynamic dispatch.
type IDropTagClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TAG() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropTagClauseContext differentiates from other interfaces.
	IsDropTagClauseContext()
}

type DropTagClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTagClauseContext() *DropTagClauseContext {
	var p = new(DropTagClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropTagClause
	return p
}

func InitEmptyDropTagClauseContext(p *DropTagClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropTagClause
}

func (*DropTagClauseContext) IsDropTagClauseContext() {}

func NewDropTagClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTagClauseContext {
	var p = new(DropTagClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropTagClause

	return p
}

func (s *DropTagClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTagClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropTagClauseContext) TAG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTAG, 0)
}

func (s *DropTagClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropTagClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *DropTagClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *DropTagClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTagClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTagClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropTagClause(s)
	}
}

func (s *DropTagClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropTagClause(s)
	}
}

func (s *DropTagClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropTagClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropTagClause() (localctx IDropTagClauseContext) {
	localctx = NewDropTagClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, DorisSQLParserParserRULE_dropTagClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3140)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3141)
		p.Match(DorisSQLParserParserTAG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3144)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(3142)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3143)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3146)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableOperationClauseContext is an interface to support dynamic dispatch.
type ITableOperationClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXECUTE() antlr.TerminalNode
	FunctionCall() IFunctionCallContext

	// IsTableOperationClauseContext differentiates from other interfaces.
	IsTableOperationClauseContext()
}

type TableOperationClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableOperationClauseContext() *TableOperationClauseContext {
	var p = new(TableOperationClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_tableOperationClause
	return p
}

func InitEmptyTableOperationClauseContext(p *TableOperationClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_tableOperationClause
}

func (*TableOperationClauseContext) IsTableOperationClauseContext() {}

func NewTableOperationClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableOperationClauseContext {
	var p = new(TableOperationClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_tableOperationClause

	return p
}

func (s *TableOperationClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TableOperationClauseContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXECUTE, 0)
}

func (s *TableOperationClauseContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *TableOperationClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOperationClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableOperationClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTableOperationClause(s)
	}
}

func (s *TableOperationClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTableOperationClause(s)
	}
}

func (s *TableOperationClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTableOperationClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) TableOperationClause() (localctx ITableOperationClauseContext) {
	localctx = NewTableOperationClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, DorisSQLParserParserRULE_tableOperationClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3148)
		p.Match(DorisSQLParserParserEXECUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3149)
		p.FunctionCall()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITagOptionsContext is an interface to support dynamic dispatch.
type ITagOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	SnapshotId() ISnapshotIdContext
	RefRetain() IRefRetainContext

	// IsTagOptionsContext differentiates from other interfaces.
	IsTagOptionsContext()
}

type TagOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTagOptionsContext() *TagOptionsContext {
	var p = new(TagOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_tagOptions
	return p
}

func InitEmptyTagOptionsContext(p *TagOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_tagOptions
}

func (*TagOptionsContext) IsTagOptionsContext() {}

func NewTagOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TagOptionsContext {
	var p = new(TagOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_tagOptions

	return p
}

func (s *TagOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *TagOptionsContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *TagOptionsContext) OF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOF, 0)
}

func (s *TagOptionsContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVERSION, 0)
}

func (s *TagOptionsContext) SnapshotId() ISnapshotIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISnapshotIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISnapshotIdContext)
}

func (s *TagOptionsContext) RefRetain() IRefRetainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefRetainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefRetainContext)
}

func (s *TagOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TagOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TagOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTagOptions(s)
	}
}

func (s *TagOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTagOptions(s)
	}
}

func (s *TagOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTagOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) TagOptions() (localctx ITagOptionsContext) {
	localctx = NewTagOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, DorisSQLParserParserRULE_tagOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3155)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserAS {
		{
			p.SetState(3151)
			p.Match(DorisSQLParserParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3152)
			p.Match(DorisSQLParserParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3153)
			p.Match(DorisSQLParserParserVERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3154)
			p.SnapshotId()
		}

	}
	p.SetState(3158)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserRETAIN {
		{
			p.SetState(3157)
			p.RefRetain()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBranchOptionsContext is an interface to support dynamic dispatch.
type IBranchOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	SnapshotId() ISnapshotIdContext
	RefRetain() IRefRetainContext
	SnapshotRetention() ISnapshotRetentionContext

	// IsBranchOptionsContext differentiates from other interfaces.
	IsBranchOptionsContext()
}

type BranchOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBranchOptionsContext() *BranchOptionsContext {
	var p = new(BranchOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_branchOptions
	return p
}

func InitEmptyBranchOptionsContext(p *BranchOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_branchOptions
}

func (*BranchOptionsContext) IsBranchOptionsContext() {}

func NewBranchOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BranchOptionsContext {
	var p = new(BranchOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_branchOptions

	return p
}

func (s *BranchOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *BranchOptionsContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *BranchOptionsContext) OF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOF, 0)
}

func (s *BranchOptionsContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVERSION, 0)
}

func (s *BranchOptionsContext) SnapshotId() ISnapshotIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISnapshotIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISnapshotIdContext)
}

func (s *BranchOptionsContext) RefRetain() IRefRetainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefRetainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefRetainContext)
}

func (s *BranchOptionsContext) SnapshotRetention() ISnapshotRetentionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISnapshotRetentionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISnapshotRetentionContext)
}

func (s *BranchOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BranchOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BranchOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterBranchOptions(s)
	}
}

func (s *BranchOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitBranchOptions(s)
	}
}

func (s *BranchOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitBranchOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) BranchOptions() (localctx IBranchOptionsContext) {
	localctx = NewBranchOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, DorisSQLParserParserRULE_branchOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3164)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserAS {
		{
			p.SetState(3160)
			p.Match(DorisSQLParserParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3161)
			p.Match(DorisSQLParserParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3162)
			p.Match(DorisSQLParserParserVERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3163)
			p.SnapshotId()
		}

	}
	p.SetState(3167)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserRETAIN {
		{
			p.SetState(3166)
			p.RefRetain()
		}

	}
	p.SetState(3170)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWITH {
		{
			p.SetState(3169)
			p.SnapshotRetention()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISnapshotRetentionContext is an interface to support dynamic dispatch.
type ISnapshotRetentionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	RETENTION() antlr.TerminalNode
	MinSnapshotsToKeep() IMinSnapshotsToKeepContext
	MaxSnapshotAge() IMaxSnapshotAgeContext

	// IsSnapshotRetentionContext differentiates from other interfaces.
	IsSnapshotRetentionContext()
}

type SnapshotRetentionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySnapshotRetentionContext() *SnapshotRetentionContext {
	var p = new(SnapshotRetentionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_snapshotRetention
	return p
}

func InitEmptySnapshotRetentionContext(p *SnapshotRetentionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_snapshotRetention
}

func (*SnapshotRetentionContext) IsSnapshotRetentionContext() {}

func NewSnapshotRetentionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SnapshotRetentionContext {
	var p = new(SnapshotRetentionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_snapshotRetention

	return p
}

func (s *SnapshotRetentionContext) GetParser() antlr.Parser { return s.parser }

func (s *SnapshotRetentionContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *SnapshotRetentionContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSNAPSHOT, 0)
}

func (s *SnapshotRetentionContext) RETENTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRETENTION, 0)
}

func (s *SnapshotRetentionContext) MinSnapshotsToKeep() IMinSnapshotsToKeepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMinSnapshotsToKeepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMinSnapshotsToKeepContext)
}

func (s *SnapshotRetentionContext) MaxSnapshotAge() IMaxSnapshotAgeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaxSnapshotAgeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaxSnapshotAgeContext)
}

func (s *SnapshotRetentionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SnapshotRetentionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SnapshotRetentionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSnapshotRetention(s)
	}
}

func (s *SnapshotRetentionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSnapshotRetention(s)
	}
}

func (s *SnapshotRetentionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSnapshotRetention(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SnapshotRetention() (localctx ISnapshotRetentionContext) {
	localctx = NewSnapshotRetentionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, DorisSQLParserParserRULE_snapshotRetention)
	p.SetState(3186)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 263, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3172)
			p.Match(DorisSQLParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3173)
			p.Match(DorisSQLParserParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3174)
			p.Match(DorisSQLParserParserRETENTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3175)
			p.MinSnapshotsToKeep()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3176)
			p.Match(DorisSQLParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3177)
			p.Match(DorisSQLParserParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3178)
			p.Match(DorisSQLParserParserRETENTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3179)
			p.MaxSnapshotAge()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3180)
			p.Match(DorisSQLParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3181)
			p.Match(DorisSQLParserParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3182)
			p.Match(DorisSQLParserParserRETENTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3183)
			p.MinSnapshotsToKeep()
		}
		{
			p.SetState(3184)
			p.MaxSnapshotAge()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefRetainContext is an interface to support dynamic dispatch.
type IRefRetainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETAIN() antlr.TerminalNode
	Number() INumberContext
	TimeUnit() ITimeUnitContext

	// IsRefRetainContext differentiates from other interfaces.
	IsRefRetainContext()
}

type RefRetainContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefRetainContext() *RefRetainContext {
	var p = new(RefRetainContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_refRetain
	return p
}

func InitEmptyRefRetainContext(p *RefRetainContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_refRetain
}

func (*RefRetainContext) IsRefRetainContext() {}

func NewRefRetainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefRetainContext {
	var p = new(RefRetainContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_refRetain

	return p
}

func (s *RefRetainContext) GetParser() antlr.Parser { return s.parser }

func (s *RefRetainContext) RETAIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRETAIN, 0)
}

func (s *RefRetainContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *RefRetainContext) TimeUnit() ITimeUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeUnitContext)
}

func (s *RefRetainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefRetainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefRetainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRefRetain(s)
	}
}

func (s *RefRetainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRefRetain(s)
	}
}

func (s *RefRetainContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRefRetain(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) RefRetain() (localctx IRefRetainContext) {
	localctx = NewRefRetainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, DorisSQLParserParserRULE_refRetain)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3188)
		p.Match(DorisSQLParserParserRETAIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3189)
		p.Number()
	}
	{
		p.SetState(3190)
		p.TimeUnit()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaxSnapshotAgeContext is an interface to support dynamic dispatch.
type IMaxSnapshotAgeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext
	TimeUnit() ITimeUnitContext

	// IsMaxSnapshotAgeContext differentiates from other interfaces.
	IsMaxSnapshotAgeContext()
}

type MaxSnapshotAgeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaxSnapshotAgeContext() *MaxSnapshotAgeContext {
	var p = new(MaxSnapshotAgeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_maxSnapshotAge
	return p
}

func InitEmptyMaxSnapshotAgeContext(p *MaxSnapshotAgeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_maxSnapshotAge
}

func (*MaxSnapshotAgeContext) IsMaxSnapshotAgeContext() {}

func NewMaxSnapshotAgeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaxSnapshotAgeContext {
	var p = new(MaxSnapshotAgeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_maxSnapshotAge

	return p
}

func (s *MaxSnapshotAgeContext) GetParser() antlr.Parser { return s.parser }

func (s *MaxSnapshotAgeContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *MaxSnapshotAgeContext) TimeUnit() ITimeUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeUnitContext)
}

func (s *MaxSnapshotAgeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaxSnapshotAgeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaxSnapshotAgeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterMaxSnapshotAge(s)
	}
}

func (s *MaxSnapshotAgeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitMaxSnapshotAge(s)
	}
}

func (s *MaxSnapshotAgeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitMaxSnapshotAge(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) MaxSnapshotAge() (localctx IMaxSnapshotAgeContext) {
	localctx = NewMaxSnapshotAgeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, DorisSQLParserParserRULE_maxSnapshotAge)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3192)
		p.Number()
	}
	{
		p.SetState(3193)
		p.TimeUnit()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMinSnapshotsToKeepContext is an interface to support dynamic dispatch.
type IMinSnapshotsToKeepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext
	SNAPSHOTS() antlr.TerminalNode

	// IsMinSnapshotsToKeepContext differentiates from other interfaces.
	IsMinSnapshotsToKeepContext()
}

type MinSnapshotsToKeepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMinSnapshotsToKeepContext() *MinSnapshotsToKeepContext {
	var p = new(MinSnapshotsToKeepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_minSnapshotsToKeep
	return p
}

func InitEmptyMinSnapshotsToKeepContext(p *MinSnapshotsToKeepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_minSnapshotsToKeep
}

func (*MinSnapshotsToKeepContext) IsMinSnapshotsToKeepContext() {}

func NewMinSnapshotsToKeepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MinSnapshotsToKeepContext {
	var p = new(MinSnapshotsToKeepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_minSnapshotsToKeep

	return p
}

func (s *MinSnapshotsToKeepContext) GetParser() antlr.Parser { return s.parser }

func (s *MinSnapshotsToKeepContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *MinSnapshotsToKeepContext) SNAPSHOTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSNAPSHOTS, 0)
}

func (s *MinSnapshotsToKeepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MinSnapshotsToKeepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MinSnapshotsToKeepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterMinSnapshotsToKeep(s)
	}
}

func (s *MinSnapshotsToKeepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitMinSnapshotsToKeep(s)
	}
}

func (s *MinSnapshotsToKeepContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitMinSnapshotsToKeep(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) MinSnapshotsToKeep() (localctx IMinSnapshotsToKeepContext) {
	localctx = NewMinSnapshotsToKeepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, DorisSQLParserParserRULE_minSnapshotsToKeep)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3195)
		p.Number()
	}
	{
		p.SetState(3196)
		p.Match(DorisSQLParserParserSNAPSHOTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISnapshotIdContext is an interface to support dynamic dispatch.
type ISnapshotIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext

	// IsSnapshotIdContext differentiates from other interfaces.
	IsSnapshotIdContext()
}

type SnapshotIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySnapshotIdContext() *SnapshotIdContext {
	var p = new(SnapshotIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_snapshotId
	return p
}

func InitEmptySnapshotIdContext(p *SnapshotIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_snapshotId
}

func (*SnapshotIdContext) IsSnapshotIdContext() {}

func NewSnapshotIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SnapshotIdContext {
	var p = new(SnapshotIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_snapshotId

	return p
}

func (s *SnapshotIdContext) GetParser() antlr.Parser { return s.parser }

func (s *SnapshotIdContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *SnapshotIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SnapshotIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SnapshotIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSnapshotId(s)
	}
}

func (s *SnapshotIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSnapshotId(s)
	}
}

func (s *SnapshotIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSnapshotId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SnapshotId() (localctx ISnapshotIdContext) {
	localctx = NewSnapshotIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, DorisSQLParserParserRULE_snapshotId)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3198)
		p.Number()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimeUnitContext is an interface to support dynamic dispatch.
type ITimeUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DAYS() antlr.TerminalNode
	HOURS() antlr.TerminalNode
	MINUTES() antlr.TerminalNode

	// IsTimeUnitContext differentiates from other interfaces.
	IsTimeUnitContext()
}

type TimeUnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeUnitContext() *TimeUnitContext {
	var p = new(TimeUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_timeUnit
	return p
}

func InitEmptyTimeUnitContext(p *TimeUnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_timeUnit
}

func (*TimeUnitContext) IsTimeUnitContext() {}

func NewTimeUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeUnitContext {
	var p = new(TimeUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_timeUnit

	return p
}

func (s *TimeUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeUnitContext) DAYS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDAYS, 0)
}

func (s *TimeUnitContext) HOURS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserHOURS, 0)
}

func (s *TimeUnitContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMINUTES, 0)
}

func (s *TimeUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimeUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTimeUnit(s)
	}
}

func (s *TimeUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTimeUnit(s)
	}
}

func (s *TimeUnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTimeUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) TimeUnit() (localctx ITimeUnitContext) {
	localctx = NewTimeUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, DorisSQLParserParserRULE_timeUnit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3200)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserDAYS || _la == DorisSQLParserParserHOURS || _la == DorisSQLParserParserMINUTES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInteger_listContext is an interface to support dynamic dispatch.
type IInteger_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsInteger_listContext differentiates from other interfaces.
	IsInteger_listContext()
}

type Integer_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInteger_listContext() *Integer_listContext {
	var p = new(Integer_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_integer_list
	return p
}

func InitEmptyInteger_listContext(p *Integer_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_integer_list
}

func (*Integer_listContext) IsInteger_listContext() {}

func NewInteger_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Integer_listContext {
	var p = new(Integer_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_integer_list

	return p
}

func (s *Integer_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Integer_listContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserINTEGER_VALUE)
}

func (s *Integer_listContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, i)
}

func (s *Integer_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Integer_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Integer_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterInteger_list(s)
	}
}

func (s *Integer_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitInteger_list(s)
	}
}

func (s *Integer_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitInteger_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Integer_list() (localctx IInteger_listContext) {
	localctx = NewInteger_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, DorisSQLParserParserRULE_integer_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3202)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3203)
		p.Match(DorisSQLParserParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3208)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(3204)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3205)
			p.Match(DorisSQLParserParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(3210)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3211)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropPersistentIndexClauseContext is an interface to support dynamic dispatch.
type IDropPersistentIndexClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	PERSISTENT() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	ON() antlr.TerminalNode
	TABLETS() antlr.TerminalNode
	Integer_list() IInteger_listContext

	// IsDropPersistentIndexClauseContext differentiates from other interfaces.
	IsDropPersistentIndexClauseContext()
}

type DropPersistentIndexClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropPersistentIndexClauseContext() *DropPersistentIndexClauseContext {
	var p = new(DropPersistentIndexClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropPersistentIndexClause
	return p
}

func InitEmptyDropPersistentIndexClauseContext(p *DropPersistentIndexClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropPersistentIndexClause
}

func (*DropPersistentIndexClauseContext) IsDropPersistentIndexClauseContext() {}

func NewDropPersistentIndexClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropPersistentIndexClauseContext {
	var p = new(DropPersistentIndexClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropPersistentIndexClause

	return p
}

func (s *DropPersistentIndexClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropPersistentIndexClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropPersistentIndexClauseContext) PERSISTENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPERSISTENT, 0)
}

func (s *DropPersistentIndexClauseContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINDEX, 0)
}

func (s *DropPersistentIndexClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *DropPersistentIndexClauseContext) TABLETS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLETS, 0)
}

func (s *DropPersistentIndexClauseContext) Integer_list() IInteger_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInteger_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInteger_listContext)
}

func (s *DropPersistentIndexClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropPersistentIndexClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropPersistentIndexClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropPersistentIndexClause(s)
	}
}

func (s *DropPersistentIndexClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropPersistentIndexClause(s)
	}
}

func (s *DropPersistentIndexClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropPersistentIndexClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropPersistentIndexClause() (localctx IDropPersistentIndexClauseContext) {
	localctx = NewDropPersistentIndexClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, DorisSQLParserParserRULE_dropPersistentIndexClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3213)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3214)
		p.Match(DorisSQLParserParserPERSISTENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3215)
		p.Match(DorisSQLParserParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3216)
		p.Match(DorisSQLParserParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3217)
		p.Match(DorisSQLParserParserTABLETS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3218)
		p.Integer_list()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddPartitionClauseContext is an interface to support dynamic dispatch.
type IAddPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	SingleRangePartition() ISingleRangePartitionContext
	PARTITIONS() antlr.TerminalNode
	MultiRangePartition() IMultiRangePartitionContext
	TEMPORARY() antlr.TerminalNode
	DistributionDesc() IDistributionDescContext
	Properties() IPropertiesContext
	SingleItemListPartitionDesc() ISingleItemListPartitionDescContext
	MultiItemListPartitionDesc() IMultiItemListPartitionDescContext

	// IsAddPartitionClauseContext differentiates from other interfaces.
	IsAddPartitionClauseContext()
}

type AddPartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddPartitionClauseContext() *AddPartitionClauseContext {
	var p = new(AddPartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_addPartitionClause
	return p
}

func InitEmptyAddPartitionClauseContext(p *AddPartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_addPartitionClause
}

func (*AddPartitionClauseContext) IsAddPartitionClauseContext() {}

func NewAddPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddPartitionClauseContext {
	var p = new(AddPartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_addPartitionClause

	return p
}

func (s *AddPartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddPartitionClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADD, 0)
}

func (s *AddPartitionClauseContext) SingleRangePartition() ISingleRangePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleRangePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleRangePartitionContext)
}

func (s *AddPartitionClauseContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPARTITIONS, 0)
}

func (s *AddPartitionClauseContext) MultiRangePartition() IMultiRangePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiRangePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiRangePartitionContext)
}

func (s *AddPartitionClauseContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTEMPORARY, 0)
}

func (s *AddPartitionClauseContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *AddPartitionClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AddPartitionClauseContext) SingleItemListPartitionDesc() ISingleItemListPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleItemListPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleItemListPartitionDescContext)
}

func (s *AddPartitionClauseContext) MultiItemListPartitionDesc() IMultiItemListPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiItemListPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiItemListPartitionDescContext)
}

func (s *AddPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddPartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAddPartitionClause(s)
	}
}

func (s *AddPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAddPartitionClause(s)
	}
}

func (s *AddPartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAddPartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AddPartitionClause() (localctx IAddPartitionClauseContext) {
	localctx = NewAddPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, DorisSQLParserParserRULE_addPartitionClause)
	var _la int

	p.SetState(3249)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 273, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3220)
			p.Match(DorisSQLParserParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3222)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserTEMPORARY {
			{
				p.SetState(3221)
				p.Match(DorisSQLParserParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3227)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserParserPARTITION:
			{
				p.SetState(3224)
				p.SingleRangePartition()
			}

		case DorisSQLParserParserPARTITIONS:
			{
				p.SetState(3225)
				p.Match(DorisSQLParserParserPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3226)
				p.MultiRangePartition()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(3230)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserDISTRIBUTED {
			{
				p.SetState(3229)
				p.DistributionDesc()
			}

		}
		p.SetState(3233)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserPROPERTIES {
			{
				p.SetState(3232)
				p.Properties()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3235)
			p.Match(DorisSQLParserParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3237)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserTEMPORARY {
			{
				p.SetState(3236)
				p.Match(DorisSQLParserParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3241)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 270, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3239)
				p.SingleItemListPartitionDesc()
			}

		case 2:
			{
				p.SetState(3240)
				p.MultiItemListPartitionDesc()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(3244)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserDISTRIBUTED {
			{
				p.SetState(3243)
				p.DistributionDesc()
			}

		}
		p.SetState(3247)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserPROPERTIES {
			{
				p.SetState(3246)
				p.Properties()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropPartitionClauseContext is an interface to support dynamic dispatch.
type IDropPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	PARTITIONS() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	TEMPORARY() antlr.TerminalNode
	FORCE() antlr.TerminalNode
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	MultiRangePartition() IMultiRangePartitionContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ALL() antlr.TerminalNode

	// IsDropPartitionClauseContext differentiates from other interfaces.
	IsDropPartitionClauseContext()
}

type DropPartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IExpressionContext
}

func NewEmptyDropPartitionClauseContext() *DropPartitionClauseContext {
	var p = new(DropPartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropPartitionClause
	return p
}

func InitEmptyDropPartitionClauseContext(p *DropPartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropPartitionClause
}

func (*DropPartitionClauseContext) IsDropPartitionClauseContext() {}

func NewDropPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropPartitionClauseContext {
	var p = new(DropPartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropPartitionClause

	return p
}

func (s *DropPartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropPartitionClauseContext) GetWhere() IExpressionContext { return s.where }

func (s *DropPartitionClauseContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *DropPartitionClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropPartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPARTITION, 0)
}

func (s *DropPartitionClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropPartitionClauseContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPARTITIONS, 0)
}

func (s *DropPartitionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DropPartitionClauseContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTEMPORARY, 0)
}

func (s *DropPartitionClauseContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFORCE, 0)
}

func (s *DropPartitionClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *DropPartitionClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *DropPartitionClauseContext) MultiRangePartition() IMultiRangePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiRangePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiRangePartitionContext)
}

func (s *DropPartitionClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *DropPartitionClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DropPartitionClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, 0)
}

func (s *DropPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropPartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropPartitionClause(s)
	}
}

func (s *DropPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropPartitionClause(s)
	}
}

func (s *DropPartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropPartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropPartitionClause() (localctx IDropPartitionClauseContext) {
	localctx = NewDropPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, DorisSQLParserParserRULE_dropPartitionClause)
	var _la int

	p.SetState(3306)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 286, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3251)
			p.Match(DorisSQLParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3253)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserTEMPORARY {
			{
				p.SetState(3252)
				p.Match(DorisSQLParserParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3267)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserParserPARTITION:
			{
				p.SetState(3255)
				p.Match(DorisSQLParserParserPARTITION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3258)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserParserIF {
				{
					p.SetState(3256)
					p.Match(DorisSQLParserParserIF)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3257)
					p.Match(DorisSQLParserParserEXISTS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(3260)
				p.Identifier()
			}

		case DorisSQLParserParserPARTITIONS:
			{
				p.SetState(3261)
				p.Match(DorisSQLParserParserPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3264)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserParserIF {
				{
					p.SetState(3262)
					p.Match(DorisSQLParserParserIF)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3263)
					p.Match(DorisSQLParserParserEXISTS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(3266)
				p.IdentifierList()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(3270)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserFORCE {
			{
				p.SetState(3269)
				p.Match(DorisSQLParserParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3272)
			p.Match(DorisSQLParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3274)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserTEMPORARY {
			{
				p.SetState(3273)
				p.Match(DorisSQLParserParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3276)
			p.Match(DorisSQLParserParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3279)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserIF {
			{
				p.SetState(3277)
				p.Match(DorisSQLParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3278)
				p.Match(DorisSQLParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3281)
			p.MultiRangePartition()
		}
		p.SetState(3283)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserFORCE {
			{
				p.SetState(3282)
				p.Match(DorisSQLParserParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3285)
			p.Match(DorisSQLParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3287)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserTEMPORARY {
			{
				p.SetState(3286)
				p.Match(DorisSQLParserParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3289)
			p.Match(DorisSQLParserParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3292)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserIF {
			{
				p.SetState(3290)
				p.Match(DorisSQLParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3291)
				p.Match(DorisSQLParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3294)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3295)

			var _x = p.expression(0)

			localctx.(*DropPartitionClauseContext).where = _x
		}
		p.SetState(3297)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserFORCE {
			{
				p.SetState(3296)
				p.Match(DorisSQLParserParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3299)
			p.Match(DorisSQLParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3300)
			p.Match(DorisSQLParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3301)
			p.Match(DorisSQLParserParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3302)
			p.Match(DorisSQLParserParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3304)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserFORCE {
			{
				p.SetState(3303)
				p.Match(DorisSQLParserParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITruncatePartitionClauseContext is an interface to support dynamic dispatch.
type ITruncatePartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUNCATE() antlr.TerminalNode
	PartitionNames() IPartitionNamesContext

	// IsTruncatePartitionClauseContext differentiates from other interfaces.
	IsTruncatePartitionClauseContext()
}

type TruncatePartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncatePartitionClauseContext() *TruncatePartitionClauseContext {
	var p = new(TruncatePartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_truncatePartitionClause
	return p
}

func InitEmptyTruncatePartitionClauseContext(p *TruncatePartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_truncatePartitionClause
}

func (*TruncatePartitionClauseContext) IsTruncatePartitionClauseContext() {}

func NewTruncatePartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncatePartitionClauseContext {
	var p = new(TruncatePartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_truncatePartitionClause

	return p
}

func (s *TruncatePartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncatePartitionClauseContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTRUNCATE, 0)
}

func (s *TruncatePartitionClauseContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *TruncatePartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncatePartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TruncatePartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTruncatePartitionClause(s)
	}
}

func (s *TruncatePartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTruncatePartitionClause(s)
	}
}

func (s *TruncatePartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTruncatePartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) TruncatePartitionClause() (localctx ITruncatePartitionClauseContext) {
	localctx = NewTruncatePartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, DorisSQLParserParserRULE_truncatePartitionClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3308)
		p.Match(DorisSQLParserParserTRUNCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3309)
		p.PartitionNames()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyPartitionClauseContext is an interface to support dynamic dispatch.
type IModifyPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODIFY() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext
	Identifier() IIdentifierContext
	IdentifierList() IIdentifierListContext
	ASTERISK_SYMBOL() antlr.TerminalNode
	DistributionDesc() IDistributionDescContext

	// IsModifyPartitionClauseContext differentiates from other interfaces.
	IsModifyPartitionClauseContext()
}

type ModifyPartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyPartitionClauseContext() *ModifyPartitionClauseContext {
	var p = new(ModifyPartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_modifyPartitionClause
	return p
}

func InitEmptyModifyPartitionClauseContext(p *ModifyPartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_modifyPartitionClause
}

func (*ModifyPartitionClauseContext) IsModifyPartitionClauseContext() {}

func NewModifyPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyPartitionClauseContext {
	var p = new(ModifyPartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_modifyPartitionClause

	return p
}

func (s *ModifyPartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyPartitionClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMODIFY, 0)
}

func (s *ModifyPartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPARTITION, 0)
}

func (s *ModifyPartitionClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *ModifyPartitionClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *ModifyPartitionClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifyPartitionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ModifyPartitionClauseContext) ASTERISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserASTERISK_SYMBOL, 0)
}

func (s *ModifyPartitionClauseContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *ModifyPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyPartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterModifyPartitionClause(s)
	}
}

func (s *ModifyPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitModifyPartitionClause(s)
	}
}

func (s *ModifyPartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitModifyPartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ModifyPartitionClause() (localctx IModifyPartitionClauseContext) {
	localctx = NewModifyPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, DorisSQLParserParserRULE_modifyPartitionClause)
	p.SetState(3325)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 288, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3311)
			p.Match(DorisSQLParserParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3312)
			p.Match(DorisSQLParserParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3318)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 287, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3313)
				p.Identifier()
			}

		case 2:
			{
				p.SetState(3314)
				p.IdentifierList()
			}

		case 3:
			{
				p.SetState(3315)
				p.Match(DorisSQLParserParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3316)
				p.Match(DorisSQLParserParserASTERISK_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3317)
				p.Match(DorisSQLParserParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(3320)
			p.Match(DorisSQLParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3321)
			p.PropertyList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3322)
			p.Match(DorisSQLParserParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3323)
			p.Match(DorisSQLParserParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3324)
			p.DistributionDesc()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplacePartitionClauseContext is an interface to support dynamic dispatch.
type IReplacePartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetParName returns the parName rule contexts.
	GetParName() IPartitionNamesContext

	// GetTempParName returns the tempParName rule contexts.
	GetTempParName() IPartitionNamesContext

	// SetParName sets the parName rule contexts.
	SetParName(IPartitionNamesContext)

	// SetTempParName sets the tempParName rule contexts.
	SetTempParName(IPartitionNamesContext)

	// Getter signatures
	REPLACE() antlr.TerminalNode
	WITH() antlr.TerminalNode
	AllPartitionNames() []IPartitionNamesContext
	PartitionNames(i int) IPartitionNamesContext
	Properties() IPropertiesContext

	// IsReplacePartitionClauseContext differentiates from other interfaces.
	IsReplacePartitionClauseContext()
}

type ReplacePartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	parName     IPartitionNamesContext
	tempParName IPartitionNamesContext
}

func NewEmptyReplacePartitionClauseContext() *ReplacePartitionClauseContext {
	var p = new(ReplacePartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_replacePartitionClause
	return p
}

func InitEmptyReplacePartitionClauseContext(p *ReplacePartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_replacePartitionClause
}

func (*ReplacePartitionClauseContext) IsReplacePartitionClauseContext() {}

func NewReplacePartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplacePartitionClauseContext {
	var p = new(ReplacePartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_replacePartitionClause

	return p
}

func (s *ReplacePartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplacePartitionClauseContext) GetParName() IPartitionNamesContext { return s.parName }

func (s *ReplacePartitionClauseContext) GetTempParName() IPartitionNamesContext { return s.tempParName }

func (s *ReplacePartitionClauseContext) SetParName(v IPartitionNamesContext) { s.parName = v }

func (s *ReplacePartitionClauseContext) SetTempParName(v IPartitionNamesContext) { s.tempParName = v }

func (s *ReplacePartitionClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPLACE, 0)
}

func (s *ReplacePartitionClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *ReplacePartitionClauseContext) AllPartitionNames() []IPartitionNamesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			len++
		}
	}

	tst := make([]IPartitionNamesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionNamesContext); ok {
			tst[i] = t.(IPartitionNamesContext)
			i++
		}
	}

	return tst
}

func (s *ReplacePartitionClauseContext) PartitionNames(i int) IPartitionNamesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *ReplacePartitionClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *ReplacePartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplacePartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplacePartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterReplacePartitionClause(s)
	}
}

func (s *ReplacePartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitReplacePartitionClause(s)
	}
}

func (s *ReplacePartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitReplacePartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ReplacePartitionClause() (localctx IReplacePartitionClauseContext) {
	localctx = NewReplacePartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, DorisSQLParserParserRULE_replacePartitionClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3327)
		p.Match(DorisSQLParserParserREPLACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3328)

		var _x = p.PartitionNames()

		localctx.(*ReplacePartitionClauseContext).parName = _x
	}
	{
		p.SetState(3329)
		p.Match(DorisSQLParserParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3330)

		var _x = p.PartitionNames()

		localctx.(*ReplacePartitionClauseContext).tempParName = _x
	}
	p.SetState(3332)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(3331)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionRenameClauseContext is an interface to support dynamic dispatch.
type IPartitionRenameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetParName returns the parName rule contexts.
	GetParName() IIdentifierContext

	// GetNewParName returns the newParName rule contexts.
	GetNewParName() IIdentifierContext

	// SetParName sets the parName rule contexts.
	SetParName(IIdentifierContext)

	// SetNewParName sets the newParName rule contexts.
	SetNewParName(IIdentifierContext)

	// Getter signatures
	RENAME() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsPartitionRenameClauseContext differentiates from other interfaces.
	IsPartitionRenameClauseContext()
}

type PartitionRenameClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	parName    IIdentifierContext
	newParName IIdentifierContext
}

func NewEmptyPartitionRenameClauseContext() *PartitionRenameClauseContext {
	var p = new(PartitionRenameClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_partitionRenameClause
	return p
}

func InitEmptyPartitionRenameClauseContext(p *PartitionRenameClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_partitionRenameClause
}

func (*PartitionRenameClauseContext) IsPartitionRenameClauseContext() {}

func NewPartitionRenameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionRenameClauseContext {
	var p = new(PartitionRenameClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_partitionRenameClause

	return p
}

func (s *PartitionRenameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionRenameClauseContext) GetParName() IIdentifierContext { return s.parName }

func (s *PartitionRenameClauseContext) GetNewParName() IIdentifierContext { return s.newParName }

func (s *PartitionRenameClauseContext) SetParName(v IIdentifierContext) { s.parName = v }

func (s *PartitionRenameClauseContext) SetNewParName(v IIdentifierContext) { s.newParName = v }

func (s *PartitionRenameClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRENAME, 0)
}

func (s *PartitionRenameClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPARTITION, 0)
}

func (s *PartitionRenameClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *PartitionRenameClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PartitionRenameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionRenameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionRenameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPartitionRenameClause(s)
	}
}

func (s *PartitionRenameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPartitionRenameClause(s)
	}
}

func (s *PartitionRenameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPartitionRenameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PartitionRenameClause() (localctx IPartitionRenameClauseContext) {
	localctx = NewPartitionRenameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, DorisSQLParserParserRULE_partitionRenameClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3334)
		p.Match(DorisSQLParserParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3335)
		p.Match(DorisSQLParserParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3336)

		var _x = p.Identifier()

		localctx.(*PartitionRenameClauseContext).parName = _x
	}
	{
		p.SetState(3337)

		var _x = p.Identifier()

		localctx.(*PartitionRenameClauseContext).newParName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertStatementContext is an interface to support dynamic dispatch.
type IInsertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INSERT() antlr.TerminalNode
	INTO() antlr.TerminalNode
	OVERWRITE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	QueryStatement() IQueryStatementContext
	ExplainDesc() IExplainDescContext
	AllInsertLabelOrColumnAliases() []IInsertLabelOrColumnAliasesContext
	InsertLabelOrColumnAliases(i int) IInsertLabelOrColumnAliasesContext
	Properties() IPropertiesContext
	FILES() antlr.TerminalNode
	PropertyList() IPropertyListContext
	BLACKHOLE() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	AllExpressionsWithDefault() []IExpressionsWithDefaultContext
	ExpressionsWithDefault(i int) IExpressionsWithDefaultContext
	WriteBranch() IWriteBranchContext
	PartitionNames() IPartitionNamesContext

	// IsInsertStatementContext differentiates from other interfaces.
	IsInsertStatementContext()
}

type InsertStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertStatementContext() *InsertStatementContext {
	var p = new(InsertStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_insertStatement
	return p
}

func InitEmptyInsertStatementContext(p *InsertStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_insertStatement
}

func (*InsertStatementContext) IsInsertStatementContext() {}

func NewInsertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertStatementContext {
	var p = new(InsertStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_insertStatement

	return p
}

func (s *InsertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertStatementContext) INSERT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINSERT, 0)
}

func (s *InsertStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTO, 0)
}

func (s *InsertStatementContext) OVERWRITE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOVERWRITE, 0)
}

func (s *InsertStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *InsertStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *InsertStatementContext) ExplainDesc() IExplainDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainDescContext)
}

func (s *InsertStatementContext) AllInsertLabelOrColumnAliases() []IInsertLabelOrColumnAliasesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInsertLabelOrColumnAliasesContext); ok {
			len++
		}
	}

	tst := make([]IInsertLabelOrColumnAliasesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInsertLabelOrColumnAliasesContext); ok {
			tst[i] = t.(IInsertLabelOrColumnAliasesContext)
			i++
		}
	}

	return tst
}

func (s *InsertStatementContext) InsertLabelOrColumnAliases(i int) IInsertLabelOrColumnAliasesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertLabelOrColumnAliasesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertLabelOrColumnAliasesContext)
}

func (s *InsertStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *InsertStatementContext) FILES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFILES, 0)
}

func (s *InsertStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *InsertStatementContext) BLACKHOLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBLACKHOLE, 0)
}

func (s *InsertStatementContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVALUES, 0)
}

func (s *InsertStatementContext) AllExpressionsWithDefault() []IExpressionsWithDefaultContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionsWithDefaultContext); ok {
			len++
		}
	}

	tst := make([]IExpressionsWithDefaultContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionsWithDefaultContext); ok {
			tst[i] = t.(IExpressionsWithDefaultContext)
			i++
		}
	}

	return tst
}

func (s *InsertStatementContext) ExpressionsWithDefault(i int) IExpressionsWithDefaultContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsWithDefaultContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsWithDefaultContext)
}

func (s *InsertStatementContext) WriteBranch() IWriteBranchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWriteBranchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWriteBranchContext)
}

func (s *InsertStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *InsertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterInsertStatement(s)
	}
}

func (s *InsertStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitInsertStatement(s)
	}
}

func (s *InsertStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitInsertStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) InsertStatement() (localctx IInsertStatementContext) {
	localctx = NewInsertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, DorisSQLParserParserRULE_insertStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-125)) & ^0x3f) == 0 && ((int64(1)<<(_la-125))&16777219) != 0 {
		{
			p.SetState(3339)
			p.ExplainDesc()
		}

	}
	{
		p.SetState(3342)
		p.Match(DorisSQLParserParserINSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3343)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserINTO || _la == DorisSQLParserParserOVERWRITE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3356)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 293, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3344)
			p.QualifiedName()
		}
		p.SetState(3346)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserFOR || _la == DorisSQLParserParserVERSION {
			{
				p.SetState(3345)
				p.WriteBranch()
			}

		}
		p.SetState(3349)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserPARTITION || _la == DorisSQLParserParserPARTITIONS || _la == DorisSQLParserParserTEMPORARY {
			{
				p.SetState(3348)
				p.PartitionNames()
			}

		}

	case 2:
		{
			p.SetState(3351)
			p.Match(DorisSQLParserParserFILES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3352)
			p.PropertyList()
		}

	case 3:
		{
			p.SetState(3353)
			p.Match(DorisSQLParserParserBLACKHOLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3354)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3355)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(3361)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 294, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3358)
				p.InsertLabelOrColumnAliases()
			}

		}
		p.SetState(3363)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 294, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(3365)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(3364)
			p.Properties()
		}

	}
	p.SetState(3377)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserT__1, DorisSQLParserParserDESC, DorisSQLParserParserDESCRIBE, DorisSQLParserParserEXPLAIN, DorisSQLParserParserSELECT, DorisSQLParserParserTRACE, DorisSQLParserParserWITH:
		{
			p.SetState(3367)
			p.QueryStatement()
		}

	case DorisSQLParserParserVALUES:
		{
			p.SetState(3368)
			p.Match(DorisSQLParserParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3369)
			p.ExpressionsWithDefault()
		}
		p.SetState(3374)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(3370)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3371)
				p.ExpressionsWithDefault()
			}

			p.SetState(3376)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertLabelOrColumnAliasesContext is an interface to support dynamic dispatch.
type IInsertLabelOrColumnAliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLabel returns the label rule contexts.
	GetLabel() IIdentifierContext

	// SetLabel sets the label rule contexts.
	SetLabel(IIdentifierContext)

	// Getter signatures
	ColumnAliasesOrByName() IColumnAliasesOrByNameContext
	WITH() antlr.TerminalNode
	LABEL() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsInsertLabelOrColumnAliasesContext differentiates from other interfaces.
	IsInsertLabelOrColumnAliasesContext()
}

type InsertLabelOrColumnAliasesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	label  IIdentifierContext
}

func NewEmptyInsertLabelOrColumnAliasesContext() *InsertLabelOrColumnAliasesContext {
	var p = new(InsertLabelOrColumnAliasesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_insertLabelOrColumnAliases
	return p
}

func InitEmptyInsertLabelOrColumnAliasesContext(p *InsertLabelOrColumnAliasesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_insertLabelOrColumnAliases
}

func (*InsertLabelOrColumnAliasesContext) IsInsertLabelOrColumnAliasesContext() {}

func NewInsertLabelOrColumnAliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertLabelOrColumnAliasesContext {
	var p = new(InsertLabelOrColumnAliasesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_insertLabelOrColumnAliases

	return p
}

func (s *InsertLabelOrColumnAliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertLabelOrColumnAliasesContext) GetLabel() IIdentifierContext { return s.label }

func (s *InsertLabelOrColumnAliasesContext) SetLabel(v IIdentifierContext) { s.label = v }

func (s *InsertLabelOrColumnAliasesContext) ColumnAliasesOrByName() IColumnAliasesOrByNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesOrByNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesOrByNameContext)
}

func (s *InsertLabelOrColumnAliasesContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *InsertLabelOrColumnAliasesContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLABEL, 0)
}

func (s *InsertLabelOrColumnAliasesContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InsertLabelOrColumnAliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertLabelOrColumnAliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertLabelOrColumnAliasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterInsertLabelOrColumnAliases(s)
	}
}

func (s *InsertLabelOrColumnAliasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitInsertLabelOrColumnAliases(s)
	}
}

func (s *InsertLabelOrColumnAliasesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitInsertLabelOrColumnAliases(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) InsertLabelOrColumnAliases() (localctx IInsertLabelOrColumnAliasesContext) {
	localctx = NewInsertLabelOrColumnAliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, DorisSQLParserParserRULE_insertLabelOrColumnAliases)
	p.SetState(3383)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserT__1, DorisSQLParserParserBY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3379)
			p.ColumnAliasesOrByName()
		}

	case DorisSQLParserParserWITH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3380)
			p.Match(DorisSQLParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3381)
			p.Match(DorisSQLParserParserLABEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3382)

			var _x = p.Identifier()

			localctx.(*InsertLabelOrColumnAliasesContext).label = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnAliasesOrByNameContext is an interface to support dynamic dispatch.
type IColumnAliasesOrByNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnAliases() IColumnAliasesContext
	BY() antlr.TerminalNode
	NAME() antlr.TerminalNode

	// IsColumnAliasesOrByNameContext differentiates from other interfaces.
	IsColumnAliasesOrByNameContext()
}

type ColumnAliasesOrByNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnAliasesOrByNameContext() *ColumnAliasesOrByNameContext {
	var p = new(ColumnAliasesOrByNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_columnAliasesOrByName
	return p
}

func InitEmptyColumnAliasesOrByNameContext(p *ColumnAliasesOrByNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_columnAliasesOrByName
}

func (*ColumnAliasesOrByNameContext) IsColumnAliasesOrByNameContext() {}

func NewColumnAliasesOrByNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnAliasesOrByNameContext {
	var p = new(ColumnAliasesOrByNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_columnAliasesOrByName

	return p
}

func (s *ColumnAliasesOrByNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnAliasesOrByNameContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *ColumnAliasesOrByNameContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *ColumnAliasesOrByNameContext) NAME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNAME, 0)
}

func (s *ColumnAliasesOrByNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnAliasesOrByNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnAliasesOrByNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterColumnAliasesOrByName(s)
	}
}

func (s *ColumnAliasesOrByNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitColumnAliasesOrByName(s)
	}
}

func (s *ColumnAliasesOrByNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitColumnAliasesOrByName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ColumnAliasesOrByName() (localctx IColumnAliasesOrByNameContext) {
	localctx = NewColumnAliasesOrByNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, DorisSQLParserParserRULE_columnAliasesOrByName)
	p.SetState(3388)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserT__1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3385)
			p.ColumnAliases()
		}

	case DorisSQLParserParserBY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3386)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3387)
			p.Match(DorisSQLParserParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateStatementContext is an interface to support dynamic dispatch.
type IUpdateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	UPDATE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	SET() antlr.TerminalNode
	AssignmentList() IAssignmentListContext
	FromClause() IFromClauseContext
	ExplainDesc() IExplainDescContext
	WithClause() IWithClauseContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsUpdateStatementContext differentiates from other interfaces.
	IsUpdateStatementContext()
}

type UpdateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IExpressionContext
}

func NewEmptyUpdateStatementContext() *UpdateStatementContext {
	var p = new(UpdateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_updateStatement
	return p
}

func InitEmptyUpdateStatementContext(p *UpdateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_updateStatement
}

func (*UpdateStatementContext) IsUpdateStatementContext() {}

func NewUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateStatementContext {
	var p = new(UpdateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_updateStatement

	return p
}

func (s *UpdateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateStatementContext) GetWhere() IExpressionContext { return s.where }

func (s *UpdateStatementContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *UpdateStatementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUPDATE, 0)
}

func (s *UpdateStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *UpdateStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *UpdateStatementContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *UpdateStatementContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *UpdateStatementContext) ExplainDesc() IExplainDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainDescContext)
}

func (s *UpdateStatementContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *UpdateStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *UpdateStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UpdateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitUpdateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) UpdateStatement() (localctx IUpdateStatementContext) {
	localctx = NewUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, DorisSQLParserParserRULE_updateStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3391)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-125)) & ^0x3f) == 0 && ((int64(1)<<(_la-125))&16777219) != 0 {
		{
			p.SetState(3390)
			p.ExplainDesc()
		}

	}
	p.SetState(3394)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWITH {
		{
			p.SetState(3393)
			p.WithClause()
		}

	}
	{
		p.SetState(3396)
		p.Match(DorisSQLParserParserUPDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3397)
		p.QualifiedName()
	}
	{
		p.SetState(3398)
		p.Match(DorisSQLParserParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3399)
		p.AssignmentList()
	}
	{
		p.SetState(3400)
		p.FromClause()
	}
	p.SetState(3403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWHERE {
		{
			p.SetState(3401)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3402)

			var _x = p.expression(0)

			localctx.(*UpdateStatementContext).where = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteStatementContext is an interface to support dynamic dispatch.
type IDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUsing returns the using rule contexts.
	GetUsing() IRelationsContext

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetUsing sets the using rule contexts.
	SetUsing(IRelationsContext)

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	DELETE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	ExplainDesc() IExplainDescContext
	WithClause() IWithClauseContext
	PartitionNames() IPartitionNamesContext
	USING() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Relations() IRelationsContext
	Expression() IExpressionContext

	// IsDeleteStatementContext differentiates from other interfaces.
	IsDeleteStatementContext()
}

type DeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	using  IRelationsContext
	where  IExpressionContext
}

func NewEmptyDeleteStatementContext() *DeleteStatementContext {
	var p = new(DeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_deleteStatement
	return p
}

func InitEmptyDeleteStatementContext(p *DeleteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_deleteStatement
}

func (*DeleteStatementContext) IsDeleteStatementContext() {}

func NewDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteStatementContext {
	var p = new(DeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_deleteStatement

	return p
}

func (s *DeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteStatementContext) GetUsing() IRelationsContext { return s.using }

func (s *DeleteStatementContext) GetWhere() IExpressionContext { return s.where }

func (s *DeleteStatementContext) SetUsing(v IRelationsContext) { s.using = v }

func (s *DeleteStatementContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *DeleteStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDELETE, 0)
}

func (s *DeleteStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *DeleteStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DeleteStatementContext) ExplainDesc() IExplainDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainDescContext)
}

func (s *DeleteStatementContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *DeleteStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *DeleteStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSING, 0)
}

func (s *DeleteStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *DeleteStatementContext) Relations() IRelationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationsContext)
}

func (s *DeleteStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDeleteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DeleteStatement() (localctx IDeleteStatementContext) {
	localctx = NewDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, DorisSQLParserParserRULE_deleteStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3406)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-125)) & ^0x3f) == 0 && ((int64(1)<<(_la-125))&16777219) != 0 {
		{
			p.SetState(3405)
			p.ExplainDesc()
		}

	}
	p.SetState(3409)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWITH {
		{
			p.SetState(3408)
			p.WithClause()
		}

	}
	{
		p.SetState(3411)
		p.Match(DorisSQLParserParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3412)
		p.Match(DorisSQLParserParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3413)
		p.QualifiedName()
	}
	p.SetState(3415)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPARTITION || _la == DorisSQLParserParserPARTITIONS || _la == DorisSQLParserParserTEMPORARY {
		{
			p.SetState(3414)
			p.PartitionNames()
		}

	}
	p.SetState(3419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserUSING {
		{
			p.SetState(3417)
			p.Match(DorisSQLParserParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3418)

			var _x = p.Relations()

			localctx.(*DeleteStatementContext).using = _x
		}

	}
	p.SetState(3423)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWHERE {
		{
			p.SetState(3421)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3422)

			var _x = p.expression(0)

			localctx.(*DeleteStatementContext).where = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateRoutineLoadStatementContext is an interface to support dynamic dispatch.
type ICreateRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// GetSource returns the source rule contexts.
	GetSource() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// SetSource sets the source rule contexts.
	SetSource(IIdentifierContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	ON() antlr.TerminalNode
	FROM() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	AllLoadProperties() []ILoadPropertiesContext
	LoadProperties(i int) ILoadPropertiesContext
	JobProperties() IJobPropertiesContext
	DataSourceProperties() IDataSourcePropertiesContext

	// IsCreateRoutineLoadStatementContext differentiates from other interfaces.
	IsCreateRoutineLoadStatementContext()
}

type CreateRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
	table  IQualifiedNameContext
	source IIdentifierContext
}

func NewEmptyCreateRoutineLoadStatementContext() *CreateRoutineLoadStatementContext {
	var p = new(CreateRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createRoutineLoadStatement
	return p
}

func InitEmptyCreateRoutineLoadStatementContext(p *CreateRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createRoutineLoadStatement
}

func (*CreateRoutineLoadStatementContext) IsCreateRoutineLoadStatementContext() {}

func NewCreateRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRoutineLoadStatementContext {
	var p = new(CreateRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createRoutineLoadStatement

	return p
}

func (s *CreateRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *CreateRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *CreateRoutineLoadStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *CreateRoutineLoadStatementContext) GetSource() IIdentifierContext { return s.source }

func (s *CreateRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *CreateRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateRoutineLoadStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *CreateRoutineLoadStatementContext) SetSource(v IIdentifierContext) { s.source = v }

func (s *CreateRoutineLoadStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROUTINE, 0)
}

func (s *CreateRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOAD, 0)
}

func (s *CreateRoutineLoadStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *CreateRoutineLoadStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *CreateRoutineLoadStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateRoutineLoadStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRoutineLoadStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *CreateRoutineLoadStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateRoutineLoadStatementContext) AllLoadProperties() []ILoadPropertiesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILoadPropertiesContext); ok {
			len++
		}
	}

	tst := make([]ILoadPropertiesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILoadPropertiesContext); ok {
			tst[i] = t.(ILoadPropertiesContext)
			i++
		}
	}

	return tst
}

func (s *CreateRoutineLoadStatementContext) LoadProperties(i int) ILoadPropertiesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadPropertiesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadPropertiesContext)
}

func (s *CreateRoutineLoadStatementContext) JobProperties() IJobPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJobPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJobPropertiesContext)
}

func (s *CreateRoutineLoadStatementContext) DataSourceProperties() IDataSourcePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataSourcePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataSourcePropertiesContext)
}

func (s *CreateRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateRoutineLoadStatement(s)
	}
}

func (s *CreateRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateRoutineLoadStatement(s)
	}
}

func (s *CreateRoutineLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateRoutineLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateRoutineLoadStatement() (localctx ICreateRoutineLoadStatementContext) {
	localctx = NewCreateRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, DorisSQLParserParserRULE_createRoutineLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3425)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3426)
		p.Match(DorisSQLParserParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3427)
		p.Match(DorisSQLParserParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3431)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 308, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3428)

			var _x = p.QualifiedName()

			localctx.(*CreateRoutineLoadStatementContext).db = _x
		}
		{
			p.SetState(3429)
			p.Match(DorisSQLParserParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3433)

		var _x = p.Identifier()

		localctx.(*CreateRoutineLoadStatementContext).name = _x
	}
	{
		p.SetState(3434)
		p.Match(DorisSQLParserParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3435)

		var _x = p.QualifiedName()

		localctx.(*CreateRoutineLoadStatementContext).table = _x
	}
	p.SetState(3444)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserCOLUMNS || _la == DorisSQLParserParserPARTITION || _la == DorisSQLParserParserPARTITIONS || _la == DorisSQLParserParserROWS || _la == DorisSQLParserParserTEMPORARY || _la == DorisSQLParserParserWHERE {
		{
			p.SetState(3436)
			p.LoadProperties()
		}
		p.SetState(3441)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(3437)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3438)
				p.LoadProperties()
			}

			p.SetState(3443)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(3446)
			p.JobProperties()
		}

	}
	{
		p.SetState(3449)
		p.Match(DorisSQLParserParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3450)

		var _x = p.Identifier()

		localctx.(*CreateRoutineLoadStatementContext).source = _x
	}
	p.SetState(3452)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserT__1 {
		{
			p.SetState(3451)
			p.DataSourceProperties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterRoutineLoadStatementContext is an interface to support dynamic dispatch.
type IAlterRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	AllLoadProperties() []ILoadPropertiesContext
	LoadProperties(i int) ILoadPropertiesContext
	JobProperties() IJobPropertiesContext
	DataSource() IDataSourceContext
	QualifiedName() IQualifiedNameContext

	// IsAlterRoutineLoadStatementContext differentiates from other interfaces.
	IsAlterRoutineLoadStatementContext()
}

type AlterRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyAlterRoutineLoadStatementContext() *AlterRoutineLoadStatementContext {
	var p = new(AlterRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterRoutineLoadStatement
	return p
}

func InitEmptyAlterRoutineLoadStatementContext(p *AlterRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterRoutineLoadStatement
}

func (*AlterRoutineLoadStatementContext) IsAlterRoutineLoadStatementContext() {}

func NewAlterRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterRoutineLoadStatementContext {
	var p = new(AlterRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_alterRoutineLoadStatement

	return p
}

func (s *AlterRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *AlterRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *AlterRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *AlterRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterRoutineLoadStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *AlterRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROUTINE, 0)
}

func (s *AlterRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOAD, 0)
}

func (s *AlterRoutineLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFOR, 0)
}

func (s *AlterRoutineLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterRoutineLoadStatementContext) AllLoadProperties() []ILoadPropertiesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILoadPropertiesContext); ok {
			len++
		}
	}

	tst := make([]ILoadPropertiesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILoadPropertiesContext); ok {
			tst[i] = t.(ILoadPropertiesContext)
			i++
		}
	}

	return tst
}

func (s *AlterRoutineLoadStatementContext) LoadProperties(i int) ILoadPropertiesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadPropertiesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadPropertiesContext)
}

func (s *AlterRoutineLoadStatementContext) JobProperties() IJobPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJobPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJobPropertiesContext)
}

func (s *AlterRoutineLoadStatementContext) DataSource() IDataSourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataSourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataSourceContext)
}

func (s *AlterRoutineLoadStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAlterRoutineLoadStatement(s)
	}
}

func (s *AlterRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAlterRoutineLoadStatement(s)
	}
}

func (s *AlterRoutineLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAlterRoutineLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AlterRoutineLoadStatement() (localctx IAlterRoutineLoadStatementContext) {
	localctx = NewAlterRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, DorisSQLParserParserRULE_alterRoutineLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3454)
		p.Match(DorisSQLParserParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3455)
		p.Match(DorisSQLParserParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3456)
		p.Match(DorisSQLParserParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3457)
		p.Match(DorisSQLParserParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3461)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 313, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3458)

			var _x = p.QualifiedName()

			localctx.(*AlterRoutineLoadStatementContext).db = _x
		}
		{
			p.SetState(3459)
			p.Match(DorisSQLParserParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3463)

		var _x = p.Identifier()

		localctx.(*AlterRoutineLoadStatementContext).name = _x
	}
	p.SetState(3472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserCOLUMNS || _la == DorisSQLParserParserPARTITION || _la == DorisSQLParserParserPARTITIONS || _la == DorisSQLParserParserROWS || _la == DorisSQLParserParserTEMPORARY || _la == DorisSQLParserParserWHERE {
		{
			p.SetState(3464)
			p.LoadProperties()
		}
		p.SetState(3469)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(3465)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3466)
				p.LoadProperties()
			}

			p.SetState(3471)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3475)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(3474)
			p.JobProperties()
		}

	}
	p.SetState(3478)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM {
		{
			p.SetState(3477)
			p.DataSource()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataSourceContext is an interface to support dynamic dispatch.
type IDataSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSource returns the source rule contexts.
	GetSource() IIdentifierContext

	// SetSource sets the source rule contexts.
	SetSource(IIdentifierContext)

	// Getter signatures
	FROM() antlr.TerminalNode
	DataSourceProperties() IDataSourcePropertiesContext
	Identifier() IIdentifierContext

	// IsDataSourceContext differentiates from other interfaces.
	IsDataSourceContext()
}

type DataSourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	source IIdentifierContext
}

func NewEmptyDataSourceContext() *DataSourceContext {
	var p = new(DataSourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dataSource
	return p
}

func InitEmptyDataSourceContext(p *DataSourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dataSource
}

func (*DataSourceContext) IsDataSourceContext() {}

func NewDataSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataSourceContext {
	var p = new(DataSourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dataSource

	return p
}

func (s *DataSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *DataSourceContext) GetSource() IIdentifierContext { return s.source }

func (s *DataSourceContext) SetSource(v IIdentifierContext) { s.source = v }

func (s *DataSourceContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *DataSourceContext) DataSourceProperties() IDataSourcePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataSourcePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataSourcePropertiesContext)
}

func (s *DataSourceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DataSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDataSource(s)
	}
}

func (s *DataSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDataSource(s)
	}
}

func (s *DataSourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDataSource(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DataSource() (localctx IDataSourceContext) {
	localctx = NewDataSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, DorisSQLParserParserRULE_dataSource)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3480)
		p.Match(DorisSQLParserParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3481)

		var _x = p.Identifier()

		localctx.(*DataSourceContext).source = _x
	}
	{
		p.SetState(3482)
		p.DataSourceProperties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoadPropertiesContext is an interface to support dynamic dispatch.
type ILoadPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColSeparatorProperty() IColSeparatorPropertyContext
	RowDelimiterProperty() IRowDelimiterPropertyContext
	ImportColumns() IImportColumnsContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	PartitionNames() IPartitionNamesContext

	// IsLoadPropertiesContext differentiates from other interfaces.
	IsLoadPropertiesContext()
}

type LoadPropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoadPropertiesContext() *LoadPropertiesContext {
	var p = new(LoadPropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_loadProperties
	return p
}

func InitEmptyLoadPropertiesContext(p *LoadPropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_loadProperties
}

func (*LoadPropertiesContext) IsLoadPropertiesContext() {}

func NewLoadPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadPropertiesContext {
	var p = new(LoadPropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_loadProperties

	return p
}

func (s *LoadPropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadPropertiesContext) ColSeparatorProperty() IColSeparatorPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColSeparatorPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColSeparatorPropertyContext)
}

func (s *LoadPropertiesContext) RowDelimiterProperty() IRowDelimiterPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowDelimiterPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowDelimiterPropertyContext)
}

func (s *LoadPropertiesContext) ImportColumns() IImportColumnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportColumnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportColumnsContext)
}

func (s *LoadPropertiesContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *LoadPropertiesContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LoadPropertiesContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *LoadPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadPropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterLoadProperties(s)
	}
}

func (s *LoadPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitLoadProperties(s)
	}
}

func (s *LoadPropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitLoadProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) LoadProperties() (localctx ILoadPropertiesContext) {
	localctx = NewLoadPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, DorisSQLParserParserRULE_loadProperties)
	p.SetState(3490)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 318, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3484)
			p.ColSeparatorProperty()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3485)
			p.RowDelimiterProperty()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3486)
			p.ImportColumns()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3487)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3488)
			p.expression(0)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3489)
			p.PartitionNames()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColSeparatorPropertyContext is an interface to support dynamic dispatch.
type IColSeparatorPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLUMNS() antlr.TerminalNode
	TERMINATED() antlr.TerminalNode
	BY() antlr.TerminalNode
	String_() IStringContext

	// IsColSeparatorPropertyContext differentiates from other interfaces.
	IsColSeparatorPropertyContext()
}

type ColSeparatorPropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColSeparatorPropertyContext() *ColSeparatorPropertyContext {
	var p = new(ColSeparatorPropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_colSeparatorProperty
	return p
}

func InitEmptyColSeparatorPropertyContext(p *ColSeparatorPropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_colSeparatorProperty
}

func (*ColSeparatorPropertyContext) IsColSeparatorPropertyContext() {}

func NewColSeparatorPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColSeparatorPropertyContext {
	var p = new(ColSeparatorPropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_colSeparatorProperty

	return p
}

func (s *ColSeparatorPropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *ColSeparatorPropertyContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLUMNS, 0)
}

func (s *ColSeparatorPropertyContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTERMINATED, 0)
}

func (s *ColSeparatorPropertyContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *ColSeparatorPropertyContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ColSeparatorPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColSeparatorPropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColSeparatorPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterColSeparatorProperty(s)
	}
}

func (s *ColSeparatorPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitColSeparatorProperty(s)
	}
}

func (s *ColSeparatorPropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitColSeparatorProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ColSeparatorProperty() (localctx IColSeparatorPropertyContext) {
	localctx = NewColSeparatorPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, DorisSQLParserParserRULE_colSeparatorProperty)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3492)
		p.Match(DorisSQLParserParserCOLUMNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3493)
		p.Match(DorisSQLParserParserTERMINATED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3494)
		p.Match(DorisSQLParserParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3495)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowDelimiterPropertyContext is an interface to support dynamic dispatch.
type IRowDelimiterPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROWS() antlr.TerminalNode
	TERMINATED() antlr.TerminalNode
	BY() antlr.TerminalNode
	String_() IStringContext

	// IsRowDelimiterPropertyContext differentiates from other interfaces.
	IsRowDelimiterPropertyContext()
}

type RowDelimiterPropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowDelimiterPropertyContext() *RowDelimiterPropertyContext {
	var p = new(RowDelimiterPropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_rowDelimiterProperty
	return p
}

func InitEmptyRowDelimiterPropertyContext(p *RowDelimiterPropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_rowDelimiterProperty
}

func (*RowDelimiterPropertyContext) IsRowDelimiterPropertyContext() {}

func NewRowDelimiterPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowDelimiterPropertyContext {
	var p = new(RowDelimiterPropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_rowDelimiterProperty

	return p
}

func (s *RowDelimiterPropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *RowDelimiterPropertyContext) ROWS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROWS, 0)
}

func (s *RowDelimiterPropertyContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTERMINATED, 0)
}

func (s *RowDelimiterPropertyContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *RowDelimiterPropertyContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *RowDelimiterPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowDelimiterPropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowDelimiterPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRowDelimiterProperty(s)
	}
}

func (s *RowDelimiterPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRowDelimiterProperty(s)
	}
}

func (s *RowDelimiterPropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRowDelimiterProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) RowDelimiterProperty() (localctx IRowDelimiterPropertyContext) {
	localctx = NewRowDelimiterPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, DorisSQLParserParserRULE_rowDelimiterProperty)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3497)
		p.Match(DorisSQLParserParserROWS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3498)
		p.Match(DorisSQLParserParserTERMINATED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3499)
		p.Match(DorisSQLParserParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3500)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportColumnsContext is an interface to support dynamic dispatch.
type IImportColumnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLUMNS() antlr.TerminalNode
	ColumnProperties() IColumnPropertiesContext

	// IsImportColumnsContext differentiates from other interfaces.
	IsImportColumnsContext()
}

type ImportColumnsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportColumnsContext() *ImportColumnsContext {
	var p = new(ImportColumnsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_importColumns
	return p
}

func InitEmptyImportColumnsContext(p *ImportColumnsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_importColumns
}

func (*ImportColumnsContext) IsImportColumnsContext() {}

func NewImportColumnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportColumnsContext {
	var p = new(ImportColumnsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_importColumns

	return p
}

func (s *ImportColumnsContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLUMNS, 0)
}

func (s *ImportColumnsContext) ColumnProperties() IColumnPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnPropertiesContext)
}

func (s *ImportColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportColumnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterImportColumns(s)
	}
}

func (s *ImportColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitImportColumns(s)
	}
}

func (s *ImportColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitImportColumns(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ImportColumns() (localctx IImportColumnsContext) {
	localctx = NewImportColumnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, DorisSQLParserParserRULE_importColumns)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3502)
		p.Match(DorisSQLParserParserCOLUMNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3503)
		p.ColumnProperties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnPropertiesContext is an interface to support dynamic dispatch.
type IColumnPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	AllAssignment() []IAssignmentContext
	Assignment(i int) IAssignmentContext

	// IsColumnPropertiesContext differentiates from other interfaces.
	IsColumnPropertiesContext()
}

type ColumnPropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnPropertiesContext() *ColumnPropertiesContext {
	var p = new(ColumnPropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_columnProperties
	return p
}

func InitEmptyColumnPropertiesContext(p *ColumnPropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_columnProperties
}

func (*ColumnPropertiesContext) IsColumnPropertiesContext() {}

func NewColumnPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnPropertiesContext {
	var p = new(ColumnPropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_columnProperties

	return p
}

func (s *ColumnPropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnPropertiesContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *ColumnPropertiesContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ColumnPropertiesContext) AllAssignment() []IAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentContext); ok {
			tst[i] = t.(IAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *ColumnPropertiesContext) Assignment(i int) IAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *ColumnPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnPropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterColumnProperties(s)
	}
}

func (s *ColumnPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitColumnProperties(s)
	}
}

func (s *ColumnPropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitColumnProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ColumnProperties() (localctx IColumnPropertiesContext) {
	localctx = NewColumnPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, DorisSQLParserParserRULE_columnProperties)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3505)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3508)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 319, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3506)
			p.QualifiedName()
		}

	case 2:
		{
			p.SetState(3507)
			p.Assignment()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(3517)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(3510)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3513)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 320, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3511)
				p.QualifiedName()
			}

		case 2:
			{
				p.SetState(3512)
				p.Assignment()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(3519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3520)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJobPropertiesContext is an interface to support dynamic dispatch.
type IJobPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Properties() IPropertiesContext

	// IsJobPropertiesContext differentiates from other interfaces.
	IsJobPropertiesContext()
}

type JobPropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJobPropertiesContext() *JobPropertiesContext {
	var p = new(JobPropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_jobProperties
	return p
}

func InitEmptyJobPropertiesContext(p *JobPropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_jobProperties
}

func (*JobPropertiesContext) IsJobPropertiesContext() {}

func NewJobPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JobPropertiesContext {
	var p = new(JobPropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_jobProperties

	return p
}

func (s *JobPropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *JobPropertiesContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *JobPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JobPropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JobPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterJobProperties(s)
	}
}

func (s *JobPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitJobProperties(s)
	}
}

func (s *JobPropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitJobProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) JobProperties() (localctx IJobPropertiesContext) {
	localctx = NewJobPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, DorisSQLParserParserRULE_jobProperties)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3522)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataSourcePropertiesContext is an interface to support dynamic dispatch.
type IDataSourcePropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PropertyList() IPropertyListContext

	// IsDataSourcePropertiesContext differentiates from other interfaces.
	IsDataSourcePropertiesContext()
}

type DataSourcePropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataSourcePropertiesContext() *DataSourcePropertiesContext {
	var p = new(DataSourcePropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dataSourceProperties
	return p
}

func InitEmptyDataSourcePropertiesContext(p *DataSourcePropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dataSourceProperties
}

func (*DataSourcePropertiesContext) IsDataSourcePropertiesContext() {}

func NewDataSourcePropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataSourcePropertiesContext {
	var p = new(DataSourcePropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dataSourceProperties

	return p
}

func (s *DataSourcePropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *DataSourcePropertiesContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *DataSourcePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataSourcePropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataSourcePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDataSourceProperties(s)
	}
}

func (s *DataSourcePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDataSourceProperties(s)
	}
}

func (s *DataSourcePropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDataSourceProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DataSourceProperties() (localctx IDataSourcePropertiesContext) {
	localctx = NewDataSourcePropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, DorisSQLParserParserRULE_dataSourceProperties)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3524)
		p.PropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStopRoutineLoadStatementContext is an interface to support dynamic dispatch.
type IStopRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	STOP() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	QualifiedName() IQualifiedNameContext

	// IsStopRoutineLoadStatementContext differentiates from other interfaces.
	IsStopRoutineLoadStatementContext()
}

type StopRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyStopRoutineLoadStatementContext() *StopRoutineLoadStatementContext {
	var p = new(StopRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_stopRoutineLoadStatement
	return p
}

func InitEmptyStopRoutineLoadStatementContext(p *StopRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_stopRoutineLoadStatement
}

func (*StopRoutineLoadStatementContext) IsStopRoutineLoadStatementContext() {}

func NewStopRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StopRoutineLoadStatementContext {
	var p = new(StopRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_stopRoutineLoadStatement

	return p
}

func (s *StopRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StopRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *StopRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *StopRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *StopRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *StopRoutineLoadStatementContext) STOP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTOP, 0)
}

func (s *StopRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROUTINE, 0)
}

func (s *StopRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOAD, 0)
}

func (s *StopRoutineLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFOR, 0)
}

func (s *StopRoutineLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StopRoutineLoadStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *StopRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StopRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StopRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterStopRoutineLoadStatement(s)
	}
}

func (s *StopRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitStopRoutineLoadStatement(s)
	}
}

func (s *StopRoutineLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitStopRoutineLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) StopRoutineLoadStatement() (localctx IStopRoutineLoadStatementContext) {
	localctx = NewStopRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, DorisSQLParserParserRULE_stopRoutineLoadStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3526)
		p.Match(DorisSQLParserParserSTOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3527)
		p.Match(DorisSQLParserParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3528)
		p.Match(DorisSQLParserParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3529)
		p.Match(DorisSQLParserParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3533)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 322, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3530)

			var _x = p.QualifiedName()

			localctx.(*StopRoutineLoadStatementContext).db = _x
		}
		{
			p.SetState(3531)
			p.Match(DorisSQLParserParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3535)

		var _x = p.Identifier()

		localctx.(*StopRoutineLoadStatementContext).name = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResumeRoutineLoadStatementContext is an interface to support dynamic dispatch.
type IResumeRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	RESUME() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	QualifiedName() IQualifiedNameContext

	// IsResumeRoutineLoadStatementContext differentiates from other interfaces.
	IsResumeRoutineLoadStatementContext()
}

type ResumeRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyResumeRoutineLoadStatementContext() *ResumeRoutineLoadStatementContext {
	var p = new(ResumeRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_resumeRoutineLoadStatement
	return p
}

func InitEmptyResumeRoutineLoadStatementContext(p *ResumeRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_resumeRoutineLoadStatement
}

func (*ResumeRoutineLoadStatementContext) IsResumeRoutineLoadStatementContext() {}

func NewResumeRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResumeRoutineLoadStatementContext {
	var p = new(ResumeRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_resumeRoutineLoadStatement

	return p
}

func (s *ResumeRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ResumeRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ResumeRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *ResumeRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ResumeRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ResumeRoutineLoadStatementContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRESUME, 0)
}

func (s *ResumeRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROUTINE, 0)
}

func (s *ResumeRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOAD, 0)
}

func (s *ResumeRoutineLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFOR, 0)
}

func (s *ResumeRoutineLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ResumeRoutineLoadStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ResumeRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumeRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResumeRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterResumeRoutineLoadStatement(s)
	}
}

func (s *ResumeRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitResumeRoutineLoadStatement(s)
	}
}

func (s *ResumeRoutineLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitResumeRoutineLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ResumeRoutineLoadStatement() (localctx IResumeRoutineLoadStatementContext) {
	localctx = NewResumeRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, DorisSQLParserParserRULE_resumeRoutineLoadStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3537)
		p.Match(DorisSQLParserParserRESUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3538)
		p.Match(DorisSQLParserParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3539)
		p.Match(DorisSQLParserParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3540)
		p.Match(DorisSQLParserParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3544)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 323, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3541)

			var _x = p.QualifiedName()

			localctx.(*ResumeRoutineLoadStatementContext).db = _x
		}
		{
			p.SetState(3542)
			p.Match(DorisSQLParserParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3546)

		var _x = p.Identifier()

		localctx.(*ResumeRoutineLoadStatementContext).name = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPauseRoutineLoadStatementContext is an interface to support dynamic dispatch.
type IPauseRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	PAUSE() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	QualifiedName() IQualifiedNameContext

	// IsPauseRoutineLoadStatementContext differentiates from other interfaces.
	IsPauseRoutineLoadStatementContext()
}

type PauseRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyPauseRoutineLoadStatementContext() *PauseRoutineLoadStatementContext {
	var p = new(PauseRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_pauseRoutineLoadStatement
	return p
}

func InitEmptyPauseRoutineLoadStatementContext(p *PauseRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_pauseRoutineLoadStatement
}

func (*PauseRoutineLoadStatementContext) IsPauseRoutineLoadStatementContext() {}

func NewPauseRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PauseRoutineLoadStatementContext {
	var p = new(PauseRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_pauseRoutineLoadStatement

	return p
}

func (s *PauseRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PauseRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *PauseRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *PauseRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *PauseRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *PauseRoutineLoadStatementContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPAUSE, 0)
}

func (s *PauseRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROUTINE, 0)
}

func (s *PauseRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOAD, 0)
}

func (s *PauseRoutineLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFOR, 0)
}

func (s *PauseRoutineLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PauseRoutineLoadStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *PauseRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PauseRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PauseRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPauseRoutineLoadStatement(s)
	}
}

func (s *PauseRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPauseRoutineLoadStatement(s)
	}
}

func (s *PauseRoutineLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPauseRoutineLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PauseRoutineLoadStatement() (localctx IPauseRoutineLoadStatementContext) {
	localctx = NewPauseRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, DorisSQLParserParserRULE_pauseRoutineLoadStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3548)
		p.Match(DorisSQLParserParserPAUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3549)
		p.Match(DorisSQLParserParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3550)
		p.Match(DorisSQLParserParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3551)
		p.Match(DorisSQLParserParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3555)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 324, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3552)

			var _x = p.QualifiedName()

			localctx.(*PauseRoutineLoadStatementContext).db = _x
		}
		{
			p.SetState(3553)
			p.Match(DorisSQLParserParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3557)

		var _x = p.Identifier()

		localctx.(*PauseRoutineLoadStatementContext).name = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowRoutineLoadStatementContext is an interface to support dynamic dispatch.
type IShowRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	ALL() antlr.TerminalNode
	FOR() antlr.TerminalNode
	FROM() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext
	Identifier() IIdentifierContext
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext

	// IsShowRoutineLoadStatementContext differentiates from other interfaces.
	IsShowRoutineLoadStatementContext()
}

type ShowRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyShowRoutineLoadStatementContext() *ShowRoutineLoadStatementContext {
	var p = new(ShowRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showRoutineLoadStatement
	return p
}

func InitEmptyShowRoutineLoadStatementContext(p *ShowRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showRoutineLoadStatement
}

func (*ShowRoutineLoadStatementContext) IsShowRoutineLoadStatementContext() {}

func NewShowRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRoutineLoadStatementContext {
	var p = new(ShowRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showRoutineLoadStatement

	return p
}

func (s *ShowRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *ShowRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ShowRoutineLoadStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROUTINE, 0)
}

func (s *ShowRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOAD, 0)
}

func (s *ShowRoutineLoadStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, 0)
}

func (s *ShowRoutineLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFOR, 0)
}

func (s *ShowRoutineLoadStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowRoutineLoadStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowRoutineLoadStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowRoutineLoadStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserORDER, 0)
}

func (s *ShowRoutineLoadStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *ShowRoutineLoadStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowRoutineLoadStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowRoutineLoadStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowRoutineLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowRoutineLoadStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *ShowRoutineLoadStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowRoutineLoadStatement(s)
	}
}

func (s *ShowRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowRoutineLoadStatement(s)
	}
}

func (s *ShowRoutineLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowRoutineLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowRoutineLoadStatement() (localctx IShowRoutineLoadStatementContext) {
	localctx = NewShowRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, DorisSQLParserParserRULE_showRoutineLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3559)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3561)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserALL {
		{
			p.SetState(3560)
			p.Match(DorisSQLParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3563)
		p.Match(DorisSQLParserParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3564)
		p.Match(DorisSQLParserParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3572)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFOR {
		{
			p.SetState(3565)
			p.Match(DorisSQLParserParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3569)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 326, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3566)

				var _x = p.QualifiedName()

				localctx.(*ShowRoutineLoadStatementContext).db = _x
			}
			{
				p.SetState(3567)
				p.Match(DorisSQLParserParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3571)

			var _x = p.Identifier()

			localctx.(*ShowRoutineLoadStatementContext).name = _x
		}

	}
	p.SetState(3576)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM {
		{
			p.SetState(3574)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3575)

			var _x = p.QualifiedName()

			localctx.(*ShowRoutineLoadStatementContext).db = _x
		}

	}
	p.SetState(3580)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWHERE {
		{
			p.SetState(3578)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3579)
			p.expression(0)
		}

	}
	p.SetState(3592)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserORDER {
		{
			p.SetState(3582)
			p.Match(DorisSQLParserParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3583)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3584)
			p.SortItem()
		}
		p.SetState(3589)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(3585)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3586)
				p.SortItem()
			}

			p.SetState(3591)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3595)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserLIMIT {
		{
			p.SetState(3594)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowRoutineLoadTaskStatementContext is an interface to support dynamic dispatch.
type IShowRoutineLoadTaskStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	TASK() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowRoutineLoadTaskStatementContext differentiates from other interfaces.
	IsShowRoutineLoadTaskStatementContext()
}

type ShowRoutineLoadTaskStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
}

func NewEmptyShowRoutineLoadTaskStatementContext() *ShowRoutineLoadTaskStatementContext {
	var p = new(ShowRoutineLoadTaskStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showRoutineLoadTaskStatement
	return p
}

func InitEmptyShowRoutineLoadTaskStatementContext(p *ShowRoutineLoadTaskStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showRoutineLoadTaskStatement
}

func (*ShowRoutineLoadTaskStatementContext) IsShowRoutineLoadTaskStatementContext() {}

func NewShowRoutineLoadTaskStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRoutineLoadTaskStatementContext {
	var p = new(ShowRoutineLoadTaskStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showRoutineLoadTaskStatement

	return p
}

func (s *ShowRoutineLoadTaskStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRoutineLoadTaskStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowRoutineLoadTaskStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowRoutineLoadTaskStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowRoutineLoadTaskStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROUTINE, 0)
}

func (s *ShowRoutineLoadTaskStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOAD, 0)
}

func (s *ShowRoutineLoadTaskStatementContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTASK, 0)
}

func (s *ShowRoutineLoadTaskStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowRoutineLoadTaskStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowRoutineLoadTaskStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowRoutineLoadTaskStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowRoutineLoadTaskStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRoutineLoadTaskStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRoutineLoadTaskStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowRoutineLoadTaskStatement(s)
	}
}

func (s *ShowRoutineLoadTaskStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowRoutineLoadTaskStatement(s)
	}
}

func (s *ShowRoutineLoadTaskStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowRoutineLoadTaskStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowRoutineLoadTaskStatement() (localctx IShowRoutineLoadTaskStatementContext) {
	localctx = NewShowRoutineLoadTaskStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, DorisSQLParserParserRULE_showRoutineLoadTaskStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3597)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3598)
		p.Match(DorisSQLParserParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3599)
		p.Match(DorisSQLParserParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3600)
		p.Match(DorisSQLParserParserTASK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3603)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM {
		{
			p.SetState(3601)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3602)

			var _x = p.QualifiedName()

			localctx.(*ShowRoutineLoadTaskStatementContext).db = _x
		}

	}
	{
		p.SetState(3605)
		p.Match(DorisSQLParserParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3606)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCreateRoutineLoadStatementContext is an interface to support dynamic dispatch.
type IShowCreateRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	Identifier() IIdentifierContext
	QualifiedName() IQualifiedNameContext

	// IsShowCreateRoutineLoadStatementContext differentiates from other interfaces.
	IsShowCreateRoutineLoadStatementContext()
}

type ShowCreateRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyShowCreateRoutineLoadStatementContext() *ShowCreateRoutineLoadStatementContext {
	var p = new(ShowCreateRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showCreateRoutineLoadStatement
	return p
}

func InitEmptyShowCreateRoutineLoadStatementContext(p *ShowCreateRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showCreateRoutineLoadStatement
}

func (*ShowCreateRoutineLoadStatementContext) IsShowCreateRoutineLoadStatementContext() {}

func NewShowCreateRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCreateRoutineLoadStatementContext {
	var p = new(ShowCreateRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showCreateRoutineLoadStatement

	return p
}

func (s *ShowCreateRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCreateRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowCreateRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *ShowCreateRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowCreateRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ShowCreateRoutineLoadStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowCreateRoutineLoadStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *ShowCreateRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROUTINE, 0)
}

func (s *ShowCreateRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOAD, 0)
}

func (s *ShowCreateRoutineLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateRoutineLoadStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCreateRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCreateRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowCreateRoutineLoadStatement(s)
	}
}

func (s *ShowCreateRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowCreateRoutineLoadStatement(s)
	}
}

func (s *ShowCreateRoutineLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowCreateRoutineLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowCreateRoutineLoadStatement() (localctx IShowCreateRoutineLoadStatementContext) {
	localctx = NewShowCreateRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, DorisSQLParserParserRULE_showCreateRoutineLoadStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3608)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3609)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3610)
		p.Match(DorisSQLParserParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3611)
		p.Match(DorisSQLParserParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3615)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 334, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3612)

			var _x = p.QualifiedName()

			localctx.(*ShowCreateRoutineLoadStatementContext).db = _x
		}
		{
			p.SetState(3613)
			p.Match(DorisSQLParserParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3617)

		var _x = p.Identifier()

		localctx.(*ShowCreateRoutineLoadStatementContext).name = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowStreamLoadStatementContext is an interface to support dynamic dispatch.
type IShowStreamLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	STREAM() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	ALL() antlr.TerminalNode
	FOR() antlr.TerminalNode
	FROM() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext
	Identifier() IIdentifierContext
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext

	// IsShowStreamLoadStatementContext differentiates from other interfaces.
	IsShowStreamLoadStatementContext()
}

type ShowStreamLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyShowStreamLoadStatementContext() *ShowStreamLoadStatementContext {
	var p = new(ShowStreamLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showStreamLoadStatement
	return p
}

func InitEmptyShowStreamLoadStatementContext(p *ShowStreamLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showStreamLoadStatement
}

func (*ShowStreamLoadStatementContext) IsShowStreamLoadStatementContext() {}

func NewShowStreamLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStreamLoadStatementContext {
	var p = new(ShowStreamLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showStreamLoadStatement

	return p
}

func (s *ShowStreamLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStreamLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowStreamLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *ShowStreamLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowStreamLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ShowStreamLoadStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowStreamLoadStatementContext) STREAM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTREAM, 0)
}

func (s *ShowStreamLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOAD, 0)
}

func (s *ShowStreamLoadStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, 0)
}

func (s *ShowStreamLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFOR, 0)
}

func (s *ShowStreamLoadStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowStreamLoadStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowStreamLoadStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowStreamLoadStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserORDER, 0)
}

func (s *ShowStreamLoadStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *ShowStreamLoadStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowStreamLoadStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowStreamLoadStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowStreamLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowStreamLoadStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *ShowStreamLoadStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowStreamLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStreamLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowStreamLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowStreamLoadStatement(s)
	}
}

func (s *ShowStreamLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowStreamLoadStatement(s)
	}
}

func (s *ShowStreamLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowStreamLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowStreamLoadStatement() (localctx IShowStreamLoadStatementContext) {
	localctx = NewShowStreamLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, DorisSQLParserParserRULE_showStreamLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3619)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3621)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserALL {
		{
			p.SetState(3620)
			p.Match(DorisSQLParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3623)
		p.Match(DorisSQLParserParserSTREAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3624)
		p.Match(DorisSQLParserParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFOR {
		{
			p.SetState(3625)
			p.Match(DorisSQLParserParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3629)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 336, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3626)

				var _x = p.QualifiedName()

				localctx.(*ShowStreamLoadStatementContext).db = _x
			}
			{
				p.SetState(3627)
				p.Match(DorisSQLParserParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3631)

			var _x = p.Identifier()

			localctx.(*ShowStreamLoadStatementContext).name = _x
		}

	}
	p.SetState(3636)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM {
		{
			p.SetState(3634)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3635)

			var _x = p.QualifiedName()

			localctx.(*ShowStreamLoadStatementContext).db = _x
		}

	}
	p.SetState(3640)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWHERE {
		{
			p.SetState(3638)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3639)
			p.expression(0)
		}

	}
	p.SetState(3652)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserORDER {
		{
			p.SetState(3642)
			p.Match(DorisSQLParserParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3643)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3644)
			p.SortItem()
		}
		p.SetState(3649)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(3645)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3646)
				p.SortItem()
			}

			p.SetState(3651)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3655)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserLIMIT {
		{
			p.SetState(3654)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyzeStatementContext is an interface to support dynamic dispatch.
type IAnalyzeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANALYZE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	AnalyzeColumnClause() IAnalyzeColumnClauseContext
	PartitionNames() IPartitionNamesContext
	WITH() antlr.TerminalNode
	MODE() antlr.TerminalNode
	Properties() IPropertiesContext
	FULL() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	ASYNC() antlr.TerminalNode

	// IsAnalyzeStatementContext differentiates from other interfaces.
	IsAnalyzeStatementContext()
}

type AnalyzeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalyzeStatementContext() *AnalyzeStatementContext {
	var p = new(AnalyzeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_analyzeStatement
	return p
}

func InitEmptyAnalyzeStatementContext(p *AnalyzeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_analyzeStatement
}

func (*AnalyzeStatementContext) IsAnalyzeStatementContext() {}

func NewAnalyzeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzeStatementContext {
	var p = new(AnalyzeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_analyzeStatement

	return p
}

func (s *AnalyzeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzeStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserANALYZE, 0)
}

func (s *AnalyzeStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *AnalyzeStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AnalyzeStatementContext) AnalyzeColumnClause() IAnalyzeColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeColumnClauseContext)
}

func (s *AnalyzeStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *AnalyzeStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *AnalyzeStatementContext) MODE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMODE, 0)
}

func (s *AnalyzeStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AnalyzeStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFULL, 0)
}

func (s *AnalyzeStatementContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSAMPLE, 0)
}

func (s *AnalyzeStatementContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSYNC, 0)
}

func (s *AnalyzeStatementContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserASYNC, 0)
}

func (s *AnalyzeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnalyzeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAnalyzeStatement(s)
	}
}

func (s *AnalyzeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAnalyzeStatement(s)
	}
}

func (s *AnalyzeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAnalyzeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AnalyzeStatement() (localctx IAnalyzeStatementContext) {
	localctx = NewAnalyzeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, DorisSQLParserParserRULE_analyzeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3657)
		p.Match(DorisSQLParserParserANALYZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3659)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFULL || _la == DorisSQLParserParserSAMPLE {
		{
			p.SetState(3658)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserFULL || _la == DorisSQLParserParserSAMPLE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3661)
		p.Match(DorisSQLParserParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3662)
		p.TableName()
	}
	p.SetState(3664)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 344, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3663)
			p.AnalyzeColumnClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3667)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPARTITION || _la == DorisSQLParserParserPARTITIONS || _la == DorisSQLParserParserTEMPORARY {
		{
			p.SetState(3666)
			p.PartitionNames()
		}

	}
	p.SetState(3672)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWITH {
		{
			p.SetState(3669)
			p.Match(DorisSQLParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3670)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserASYNC || _la == DorisSQLParserParserSYNC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3671)
			p.Match(DorisSQLParserParserMODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(3674)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyzeColumnClauseContext is an interface to support dynamic dispatch.
type IAnalyzeColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAnalyzeColumnClauseContext differentiates from other interfaces.
	IsAnalyzeColumnClauseContext()
}

type AnalyzeColumnClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalyzeColumnClauseContext() *AnalyzeColumnClauseContext {
	var p = new(AnalyzeColumnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_analyzeColumnClause
	return p
}

func InitEmptyAnalyzeColumnClauseContext(p *AnalyzeColumnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_analyzeColumnClause
}

func (*AnalyzeColumnClauseContext) IsAnalyzeColumnClauseContext() {}

func NewAnalyzeColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzeColumnClauseContext {
	var p = new(AnalyzeColumnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_analyzeColumnClause

	return p
}

func (s *AnalyzeColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzeColumnClauseContext) CopyAll(ctx *AnalyzeColumnClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AnalyzeColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PredicateColumnsContext struct {
	AnalyzeColumnClauseContext
}

func NewPredicateColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicateColumnsContext {
	var p = new(PredicateColumnsContext)

	InitEmptyAnalyzeColumnClauseContext(&p.AnalyzeColumnClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AnalyzeColumnClauseContext))

	return p
}

func (s *PredicateColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateColumnsContext) PREDICATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPREDICATE, 0)
}

func (s *PredicateColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLUMNS, 0)
}

func (s *PredicateColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPredicateColumns(s)
	}
}

func (s *PredicateColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPredicateColumns(s)
	}
}

func (s *PredicateColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPredicateColumns(s)

	default:
		return t.VisitChildren(s)
	}
}

type RegularColumnsContext struct {
	AnalyzeColumnClauseContext
}

func NewRegularColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegularColumnsContext {
	var p = new(RegularColumnsContext)

	InitEmptyAnalyzeColumnClauseContext(&p.AnalyzeColumnClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AnalyzeColumnClauseContext))

	return p
}

func (s *RegularColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegularColumnsContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *RegularColumnsContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RegularColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRegularColumns(s)
	}
}

func (s *RegularColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRegularColumns(s)
	}
}

func (s *RegularColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRegularColumns(s)

	default:
		return t.VisitChildren(s)
	}
}

type AllColumnsContext struct {
	AnalyzeColumnClauseContext
}

func NewAllColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AllColumnsContext {
	var p = new(AllColumnsContext)

	InitEmptyAnalyzeColumnClauseContext(&p.AnalyzeColumnClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AnalyzeColumnClauseContext))

	return p
}

func (s *AllColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AllColumnsContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, 0)
}

func (s *AllColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLUMNS, 0)
}

func (s *AllColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAllColumns(s)
	}
}

func (s *AllColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAllColumns(s)
	}
}

func (s *AllColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAllColumns(s)

	default:
		return t.VisitChildren(s)
	}
}

type MultiColumnSetContext struct {
	AnalyzeColumnClauseContext
}

func NewMultiColumnSetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultiColumnSetContext {
	var p = new(MultiColumnSetContext)

	InitEmptyAnalyzeColumnClauseContext(&p.AnalyzeColumnClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AnalyzeColumnClauseContext))

	return p
}

func (s *MultiColumnSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiColumnSetContext) MULTIPLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMULTIPLE, 0)
}

func (s *MultiColumnSetContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLUMNS, 0)
}

func (s *MultiColumnSetContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *MultiColumnSetContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *MultiColumnSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterMultiColumnSet(s)
	}
}

func (s *MultiColumnSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitMultiColumnSet(s)
	}
}

func (s *MultiColumnSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitMultiColumnSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AnalyzeColumnClause() (localctx IAnalyzeColumnClauseContext) {
	localctx = NewAnalyzeColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, DorisSQLParserParserRULE_analyzeColumnClause)
	var _la int

	p.SetState(3713)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 351, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRegularColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3677)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3678)
			p.QualifiedName()
		}
		p.SetState(3683)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(3679)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3680)
				p.QualifiedName()
			}

			p.SetState(3685)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3686)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewRegularColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3688)
			p.QualifiedName()
		}
		p.SetState(3693)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(3689)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3690)
				p.QualifiedName()
			}

			p.SetState(3695)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		localctx = NewAllColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3696)
			p.Match(DorisSQLParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3697)
			p.Match(DorisSQLParserParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewPredicateColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3698)
			p.Match(DorisSQLParserParserPREDICATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3699)
			p.Match(DorisSQLParserParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewMultiColumnSetContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3700)
			p.Match(DorisSQLParserParserMULTIPLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3701)
			p.Match(DorisSQLParserParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3702)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3703)
			p.QualifiedName()
		}
		p.SetState(3708)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(3704)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3705)
				p.QualifiedName()
			}

			p.SetState(3710)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3711)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropStatsStatementContext is an interface to support dynamic dispatch.
type IDropStatsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	STATS() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	MULTIPLE() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode

	// IsDropStatsStatementContext differentiates from other interfaces.
	IsDropStatsStatementContext()
}

type DropStatsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropStatsStatementContext() *DropStatsStatementContext {
	var p = new(DropStatsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropStatsStatement
	return p
}

func InitEmptyDropStatsStatementContext(p *DropStatsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropStatsStatement
}

func (*DropStatsStatementContext) IsDropStatsStatementContext() {}

func NewDropStatsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropStatsStatementContext {
	var p = new(DropStatsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropStatsStatement

	return p
}

func (s *DropStatsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropStatsStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropStatsStatementContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTATS, 0)
}

func (s *DropStatsStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropStatsStatementContext) MULTIPLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMULTIPLE, 0)
}

func (s *DropStatsStatementContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLUMNS, 0)
}

func (s *DropStatsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStatsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropStatsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropStatsStatement(s)
	}
}

func (s *DropStatsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropStatsStatement(s)
	}
}

func (s *DropStatsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropStatsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropStatsStatement() (localctx IDropStatsStatementContext) {
	localctx = NewDropStatsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, DorisSQLParserParserRULE_dropStatsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3715)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3718)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserMULTIPLE {
		{
			p.SetState(3716)
			p.Match(DorisSQLParserParserMULTIPLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3717)
			p.Match(DorisSQLParserParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3720)
		p.Match(DorisSQLParserParserSTATS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3721)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHistogramStatementContext is an interface to support dynamic dispatch.
type IHistogramStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBucket returns the bucket token.
	GetBucket() antlr.Token

	// SetBucket sets the bucket token.
	SetBucket(antlr.Token)

	// Getter signatures
	ANALYZE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	UPDATE() antlr.TerminalNode
	HISTOGRAM() antlr.TerminalNode
	ON() antlr.TerminalNode
	AnalyzeColumnClause() IAnalyzeColumnClauseContext
	WITH() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	Properties() IPropertiesContext
	INTEGER_VALUE() antlr.TerminalNode

	// IsHistogramStatementContext differentiates from other interfaces.
	IsHistogramStatementContext()
}

type HistogramStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	bucket antlr.Token
}

func NewEmptyHistogramStatementContext() *HistogramStatementContext {
	var p = new(HistogramStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_histogramStatement
	return p
}

func InitEmptyHistogramStatementContext(p *HistogramStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_histogramStatement
}

func (*HistogramStatementContext) IsHistogramStatementContext() {}

func NewHistogramStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HistogramStatementContext {
	var p = new(HistogramStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_histogramStatement

	return p
}

func (s *HistogramStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HistogramStatementContext) GetBucket() antlr.Token { return s.bucket }

func (s *HistogramStatementContext) SetBucket(v antlr.Token) { s.bucket = v }

func (s *HistogramStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserANALYZE, 0)
}

func (s *HistogramStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *HistogramStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *HistogramStatementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUPDATE, 0)
}

func (s *HistogramStatementContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserHISTOGRAM, 0)
}

func (s *HistogramStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *HistogramStatementContext) AnalyzeColumnClause() IAnalyzeColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeColumnClauseContext)
}

func (s *HistogramStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *HistogramStatementContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBUCKETS, 0)
}

func (s *HistogramStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *HistogramStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, 0)
}

func (s *HistogramStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HistogramStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HistogramStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterHistogramStatement(s)
	}
}

func (s *HistogramStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitHistogramStatement(s)
	}
}

func (s *HistogramStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitHistogramStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) HistogramStatement() (localctx IHistogramStatementContext) {
	localctx = NewHistogramStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, DorisSQLParserParserRULE_histogramStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3723)
		p.Match(DorisSQLParserParserANALYZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3724)
		p.Match(DorisSQLParserParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3725)
		p.TableName()
	}
	{
		p.SetState(3726)
		p.Match(DorisSQLParserParserUPDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3727)
		p.Match(DorisSQLParserParserHISTOGRAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3728)
		p.Match(DorisSQLParserParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3729)
		p.AnalyzeColumnClause()
	}
	p.SetState(3733)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 353, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3730)
			p.Match(DorisSQLParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3731)

			var _m = p.Match(DorisSQLParserParserINTEGER_VALUE)

			localctx.(*HistogramStatementContext).bucket = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3732)
			p.Match(DorisSQLParserParserBUCKETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3736)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(3735)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyzeHistogramStatementContext is an interface to support dynamic dispatch.
type IAnalyzeHistogramStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HistogramStatement() IHistogramStatementContext
	WITH() antlr.TerminalNode
	MODE() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	ASYNC() antlr.TerminalNode

	// IsAnalyzeHistogramStatementContext differentiates from other interfaces.
	IsAnalyzeHistogramStatementContext()
}

type AnalyzeHistogramStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalyzeHistogramStatementContext() *AnalyzeHistogramStatementContext {
	var p = new(AnalyzeHistogramStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_analyzeHistogramStatement
	return p
}

func InitEmptyAnalyzeHistogramStatementContext(p *AnalyzeHistogramStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_analyzeHistogramStatement
}

func (*AnalyzeHistogramStatementContext) IsAnalyzeHistogramStatementContext() {}

func NewAnalyzeHistogramStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzeHistogramStatementContext {
	var p = new(AnalyzeHistogramStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_analyzeHistogramStatement

	return p
}

func (s *AnalyzeHistogramStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzeHistogramStatementContext) HistogramStatement() IHistogramStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHistogramStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHistogramStatementContext)
}

func (s *AnalyzeHistogramStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *AnalyzeHistogramStatementContext) MODE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMODE, 0)
}

func (s *AnalyzeHistogramStatementContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSYNC, 0)
}

func (s *AnalyzeHistogramStatementContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserASYNC, 0)
}

func (s *AnalyzeHistogramStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeHistogramStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnalyzeHistogramStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAnalyzeHistogramStatement(s)
	}
}

func (s *AnalyzeHistogramStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAnalyzeHistogramStatement(s)
	}
}

func (s *AnalyzeHistogramStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAnalyzeHistogramStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AnalyzeHistogramStatement() (localctx IAnalyzeHistogramStatementContext) {
	localctx = NewAnalyzeHistogramStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, DorisSQLParserParserRULE_analyzeHistogramStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3738)
		p.HistogramStatement()
	}
	p.SetState(3742)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWITH {
		{
			p.SetState(3739)
			p.Match(DorisSQLParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3740)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserASYNC || _la == DorisSQLParserParserSYNC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3741)
			p.Match(DorisSQLParserParserMODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropHistogramStatementContext is an interface to support dynamic dispatch.
type IDropHistogramStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANALYZE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	DROP() antlr.TerminalNode
	HISTOGRAM() antlr.TerminalNode
	ON() antlr.TerminalNode

	// IsDropHistogramStatementContext differentiates from other interfaces.
	IsDropHistogramStatementContext()
}

type DropHistogramStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropHistogramStatementContext() *DropHistogramStatementContext {
	var p = new(DropHistogramStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropHistogramStatement
	return p
}

func InitEmptyDropHistogramStatementContext(p *DropHistogramStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropHistogramStatement
}

func (*DropHistogramStatementContext) IsDropHistogramStatementContext() {}

func NewDropHistogramStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropHistogramStatementContext {
	var p = new(DropHistogramStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropHistogramStatement

	return p
}

func (s *DropHistogramStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropHistogramStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserANALYZE, 0)
}

func (s *DropHistogramStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *DropHistogramStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *DropHistogramStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropHistogramStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropHistogramStatementContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserHISTOGRAM, 0)
}

func (s *DropHistogramStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *DropHistogramStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropHistogramStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropHistogramStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropHistogramStatement(s)
	}
}

func (s *DropHistogramStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropHistogramStatement(s)
	}
}

func (s *DropHistogramStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropHistogramStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropHistogramStatement() (localctx IDropHistogramStatementContext) {
	localctx = NewDropHistogramStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, DorisSQLParserParserRULE_dropHistogramStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3744)
		p.Match(DorisSQLParserParserANALYZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3745)
		p.Match(DorisSQLParserParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3746)
		p.QualifiedName()
	}
	{
		p.SetState(3747)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3748)
		p.Match(DorisSQLParserParserHISTOGRAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3749)
		p.Match(DorisSQLParserParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3750)
		p.QualifiedName()
	}
	p.SetState(3755)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(3751)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3752)
			p.QualifiedName()
		}

		p.SetState(3757)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateAnalyzeStatementContext is an interface to support dynamic dispatch.
type ICreateAnalyzeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IIdentifierContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	Properties() IPropertiesContext
	FULL() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	Identifier() IIdentifierContext
	TABLE() antlr.TerminalNode
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	HistogramStatement() IHistogramStatementContext

	// IsCreateAnalyzeStatementContext differentiates from other interfaces.
	IsCreateAnalyzeStatementContext()
}

type CreateAnalyzeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IIdentifierContext
}

func NewEmptyCreateAnalyzeStatementContext() *CreateAnalyzeStatementContext {
	var p = new(CreateAnalyzeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createAnalyzeStatement
	return p
}

func InitEmptyCreateAnalyzeStatementContext(p *CreateAnalyzeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createAnalyzeStatement
}

func (*CreateAnalyzeStatementContext) IsCreateAnalyzeStatementContext() {}

func NewCreateAnalyzeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateAnalyzeStatementContext {
	var p = new(CreateAnalyzeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createAnalyzeStatement

	return p
}

func (s *CreateAnalyzeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateAnalyzeStatementContext) GetDb() IIdentifierContext { return s.db }

func (s *CreateAnalyzeStatementContext) SetDb(v IIdentifierContext) { s.db = v }

func (s *CreateAnalyzeStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateAnalyzeStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserANALYZE, 0)
}

func (s *CreateAnalyzeStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, 0)
}

func (s *CreateAnalyzeStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateAnalyzeStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFULL, 0)
}

func (s *CreateAnalyzeStatementContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSAMPLE, 0)
}

func (s *CreateAnalyzeStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATABASE, 0)
}

func (s *CreateAnalyzeStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateAnalyzeStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *CreateAnalyzeStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *CreateAnalyzeStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateAnalyzeStatementContext) HistogramStatement() IHistogramStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHistogramStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHistogramStatementContext)
}

func (s *CreateAnalyzeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateAnalyzeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateAnalyzeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateAnalyzeStatement(s)
	}
}

func (s *CreateAnalyzeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateAnalyzeStatement(s)
	}
}

func (s *CreateAnalyzeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateAnalyzeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateAnalyzeStatement() (localctx ICreateAnalyzeStatementContext) {
	localctx = NewCreateAnalyzeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, DorisSQLParserParserRULE_createAnalyzeStatement)
	var _la int

	p.SetState(3802)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 365, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3758)
			p.Match(DorisSQLParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3759)
			p.Match(DorisSQLParserParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3761)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserFULL || _la == DorisSQLParserParserSAMPLE {
			{
				p.SetState(3760)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserParserFULL || _la == DorisSQLParserParserSAMPLE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(3763)
			p.Match(DorisSQLParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3765)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserPROPERTIES {
			{
				p.SetState(3764)
				p.Properties()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3767)
			p.Match(DorisSQLParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3768)
			p.Match(DorisSQLParserParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3770)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserFULL || _la == DorisSQLParserParserSAMPLE {
			{
				p.SetState(3769)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserParserFULL || _la == DorisSQLParserParserSAMPLE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(3772)
			p.Match(DorisSQLParserParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3773)

			var _x = p.Identifier()

			localctx.(*CreateAnalyzeStatementContext).db = _x
		}
		p.SetState(3775)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserPROPERTIES {
			{
				p.SetState(3774)
				p.Properties()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3777)
			p.Match(DorisSQLParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3778)
			p.Match(DorisSQLParserParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3780)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserFULL || _la == DorisSQLParserParserSAMPLE {
			{
				p.SetState(3779)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserParserFULL || _la == DorisSQLParserParserSAMPLE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(3782)
			p.Match(DorisSQLParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3783)
			p.QualifiedName()
		}
		p.SetState(3795)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__1 {
			{
				p.SetState(3784)
				p.Match(DorisSQLParserParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3785)
				p.QualifiedName()
			}
			p.SetState(3790)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(3786)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3787)
					p.QualifiedName()
				}

				p.SetState(3792)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3793)
				p.Match(DorisSQLParserParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3798)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserPROPERTIES {
			{
				p.SetState(3797)
				p.Properties()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3800)
			p.Match(DorisSQLParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3801)
			p.HistogramStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropAnalyzeJobStatementContext is an interface to support dynamic dispatch.
type IDropAnalyzeJobStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	JOB() antlr.TerminalNode

	// IsDropAnalyzeJobStatementContext differentiates from other interfaces.
	IsDropAnalyzeJobStatementContext()
}

type DropAnalyzeJobStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropAnalyzeJobStatementContext() *DropAnalyzeJobStatementContext {
	var p = new(DropAnalyzeJobStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropAnalyzeJobStatement
	return p
}

func InitEmptyDropAnalyzeJobStatementContext(p *DropAnalyzeJobStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropAnalyzeJobStatement
}

func (*DropAnalyzeJobStatementContext) IsDropAnalyzeJobStatementContext() {}

func NewDropAnalyzeJobStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropAnalyzeJobStatementContext {
	var p = new(DropAnalyzeJobStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropAnalyzeJobStatement

	return p
}

func (s *DropAnalyzeJobStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropAnalyzeJobStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropAnalyzeJobStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserANALYZE, 0)
}

func (s *DropAnalyzeJobStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, 0)
}

func (s *DropAnalyzeJobStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, 0)
}

func (s *DropAnalyzeJobStatementContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserJOB, 0)
}

func (s *DropAnalyzeJobStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropAnalyzeJobStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropAnalyzeJobStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropAnalyzeJobStatement(s)
	}
}

func (s *DropAnalyzeJobStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropAnalyzeJobStatement(s)
	}
}

func (s *DropAnalyzeJobStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropAnalyzeJobStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropAnalyzeJobStatement() (localctx IDropAnalyzeJobStatementContext) {
	localctx = NewDropAnalyzeJobStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, DorisSQLParserParserRULE_dropAnalyzeJobStatement)
	p.SetState(3811)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 366, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3804)
			p.Match(DorisSQLParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3805)
			p.Match(DorisSQLParserParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3806)
			p.Match(DorisSQLParserParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3807)
			p.Match(DorisSQLParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3808)
			p.Match(DorisSQLParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3809)
			p.Match(DorisSQLParserParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3810)
			p.Match(DorisSQLParserParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowAnalyzeStatementContext is an interface to support dynamic dispatch.
type IShowAnalyzeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext
	JOB() antlr.TerminalNode
	STATUS() antlr.TerminalNode

	// IsShowAnalyzeStatementContext differentiates from other interfaces.
	IsShowAnalyzeStatementContext()
}

type ShowAnalyzeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowAnalyzeStatementContext() *ShowAnalyzeStatementContext {
	var p = new(ShowAnalyzeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showAnalyzeStatement
	return p
}

func InitEmptyShowAnalyzeStatementContext(p *ShowAnalyzeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showAnalyzeStatement
}

func (*ShowAnalyzeStatementContext) IsShowAnalyzeStatementContext() {}

func NewShowAnalyzeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowAnalyzeStatementContext {
	var p = new(ShowAnalyzeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showAnalyzeStatement

	return p
}

func (s *ShowAnalyzeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowAnalyzeStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowAnalyzeStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserANALYZE, 0)
}

func (s *ShowAnalyzeStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowAnalyzeStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowAnalyzeStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserORDER, 0)
}

func (s *ShowAnalyzeStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *ShowAnalyzeStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowAnalyzeStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowAnalyzeStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowAnalyzeStatementContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserJOB, 0)
}

func (s *ShowAnalyzeStatementContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTATUS, 0)
}

func (s *ShowAnalyzeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAnalyzeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowAnalyzeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowAnalyzeStatement(s)
	}
}

func (s *ShowAnalyzeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowAnalyzeStatement(s)
	}
}

func (s *ShowAnalyzeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowAnalyzeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowAnalyzeStatement() (localctx IShowAnalyzeStatementContext) {
	localctx = NewShowAnalyzeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, DorisSQLParserParserRULE_showAnalyzeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3813)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3814)
		p.Match(DorisSQLParserParserANALYZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3816)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserJOB || _la == DorisSQLParserParserSTATUS {
		{
			p.SetState(3815)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserJOB || _la == DorisSQLParserParserSTATUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3820)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWHERE {
		{
			p.SetState(3818)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3819)
			p.expression(0)
		}

	}
	p.SetState(3832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserORDER {
		{
			p.SetState(3822)
			p.Match(DorisSQLParserParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3823)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3824)
			p.SortItem()
		}
		p.SetState(3829)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(3825)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3826)
				p.SortItem()
			}

			p.SetState(3831)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3835)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserLIMIT {
		{
			p.SetState(3834)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowStatsMetaStatementContext is an interface to support dynamic dispatch.
type IShowStatsMetaStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	STATS() antlr.TerminalNode
	META() antlr.TerminalNode
	MULTIPLE() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext

	// IsShowStatsMetaStatementContext differentiates from other interfaces.
	IsShowStatsMetaStatementContext()
}

type ShowStatsMetaStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowStatsMetaStatementContext() *ShowStatsMetaStatementContext {
	var p = new(ShowStatsMetaStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showStatsMetaStatement
	return p
}

func InitEmptyShowStatsMetaStatementContext(p *ShowStatsMetaStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showStatsMetaStatement
}

func (*ShowStatsMetaStatementContext) IsShowStatsMetaStatementContext() {}

func NewShowStatsMetaStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStatsMetaStatementContext {
	var p = new(ShowStatsMetaStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showStatsMetaStatement

	return p
}

func (s *ShowStatsMetaStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStatsMetaStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowStatsMetaStatementContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTATS, 0)
}

func (s *ShowStatsMetaStatementContext) META() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMETA, 0)
}

func (s *ShowStatsMetaStatementContext) MULTIPLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMULTIPLE, 0)
}

func (s *ShowStatsMetaStatementContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLUMNS, 0)
}

func (s *ShowStatsMetaStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowStatsMetaStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowStatsMetaStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserORDER, 0)
}

func (s *ShowStatsMetaStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *ShowStatsMetaStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowStatsMetaStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowStatsMetaStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowStatsMetaStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatsMetaStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowStatsMetaStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowStatsMetaStatement(s)
	}
}

func (s *ShowStatsMetaStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowStatsMetaStatement(s)
	}
}

func (s *ShowStatsMetaStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowStatsMetaStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowStatsMetaStatement() (localctx IShowStatsMetaStatementContext) {
	localctx = NewShowStatsMetaStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, DorisSQLParserParserRULE_showStatsMetaStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3837)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3840)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserMULTIPLE {
		{
			p.SetState(3838)
			p.Match(DorisSQLParserParserMULTIPLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3839)
			p.Match(DorisSQLParserParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3842)
		p.Match(DorisSQLParserParserSTATS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3843)
		p.Match(DorisSQLParserParserMETA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWHERE {
		{
			p.SetState(3844)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3845)
			p.expression(0)
		}

	}
	p.SetState(3858)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserORDER {
		{
			p.SetState(3848)
			p.Match(DorisSQLParserParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3849)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3850)
			p.SortItem()
		}
		p.SetState(3855)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(3851)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3852)
				p.SortItem()
			}

			p.SetState(3857)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3861)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserLIMIT {
		{
			p.SetState(3860)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowHistogramMetaStatementContext is an interface to support dynamic dispatch.
type IShowHistogramMetaStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	HISTOGRAM() antlr.TerminalNode
	META() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext

	// IsShowHistogramMetaStatementContext differentiates from other interfaces.
	IsShowHistogramMetaStatementContext()
}

type ShowHistogramMetaStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowHistogramMetaStatementContext() *ShowHistogramMetaStatementContext {
	var p = new(ShowHistogramMetaStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showHistogramMetaStatement
	return p
}

func InitEmptyShowHistogramMetaStatementContext(p *ShowHistogramMetaStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showHistogramMetaStatement
}

func (*ShowHistogramMetaStatementContext) IsShowHistogramMetaStatementContext() {}

func NewShowHistogramMetaStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowHistogramMetaStatementContext {
	var p = new(ShowHistogramMetaStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showHistogramMetaStatement

	return p
}

func (s *ShowHistogramMetaStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowHistogramMetaStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowHistogramMetaStatementContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserHISTOGRAM, 0)
}

func (s *ShowHistogramMetaStatementContext) META() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMETA, 0)
}

func (s *ShowHistogramMetaStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowHistogramMetaStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowHistogramMetaStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserORDER, 0)
}

func (s *ShowHistogramMetaStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *ShowHistogramMetaStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowHistogramMetaStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowHistogramMetaStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowHistogramMetaStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowHistogramMetaStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowHistogramMetaStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowHistogramMetaStatement(s)
	}
}

func (s *ShowHistogramMetaStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowHistogramMetaStatement(s)
	}
}

func (s *ShowHistogramMetaStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowHistogramMetaStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowHistogramMetaStatement() (localctx IShowHistogramMetaStatementContext) {
	localctx = NewShowHistogramMetaStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, DorisSQLParserParserRULE_showHistogramMetaStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3863)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3864)
		p.Match(DorisSQLParserParserHISTOGRAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3865)
		p.Match(DorisSQLParserParserMETA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3868)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWHERE {
		{
			p.SetState(3866)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3867)
			p.expression(0)
		}

	}
	p.SetState(3880)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserORDER {
		{
			p.SetState(3870)
			p.Match(DorisSQLParserParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3871)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3872)
			p.SortItem()
		}
		p.SetState(3877)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(3873)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3874)
				p.SortItem()
			}

			p.SetState(3879)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3883)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserLIMIT {
		{
			p.SetState(3882)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKillAnalyzeStatementContext is an interface to support dynamic dispatch.
type IKillAnalyzeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KILL() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsKillAnalyzeStatementContext differentiates from other interfaces.
	IsKillAnalyzeStatementContext()
}

type KillAnalyzeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKillAnalyzeStatementContext() *KillAnalyzeStatementContext {
	var p = new(KillAnalyzeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_killAnalyzeStatement
	return p
}

func InitEmptyKillAnalyzeStatementContext(p *KillAnalyzeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_killAnalyzeStatement
}

func (*KillAnalyzeStatementContext) IsKillAnalyzeStatementContext() {}

func NewKillAnalyzeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KillAnalyzeStatementContext {
	var p = new(KillAnalyzeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_killAnalyzeStatement

	return p
}

func (s *KillAnalyzeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *KillAnalyzeStatementContext) KILL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserKILL, 0)
}

func (s *KillAnalyzeStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserANALYZE, 0)
}

func (s *KillAnalyzeStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, 0)
}

func (s *KillAnalyzeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillAnalyzeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KillAnalyzeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterKillAnalyzeStatement(s)
	}
}

func (s *KillAnalyzeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitKillAnalyzeStatement(s)
	}
}

func (s *KillAnalyzeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitKillAnalyzeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) KillAnalyzeStatement() (localctx IKillAnalyzeStatementContext) {
	localctx = NewKillAnalyzeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, DorisSQLParserParserRULE_killAnalyzeStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3885)
		p.Match(DorisSQLParserParserKILL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3886)
		p.Match(DorisSQLParserParserANALYZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3887)
		p.Match(DorisSQLParserParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyzeProfileStatementContext is an interface to support dynamic dispatch.
type IAnalyzeProfileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANALYZE() antlr.TerminalNode
	PROFILE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	String_() IStringContext
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsAnalyzeProfileStatementContext differentiates from other interfaces.
	IsAnalyzeProfileStatementContext()
}

type AnalyzeProfileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalyzeProfileStatementContext() *AnalyzeProfileStatementContext {
	var p = new(AnalyzeProfileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_analyzeProfileStatement
	return p
}

func InitEmptyAnalyzeProfileStatementContext(p *AnalyzeProfileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_analyzeProfileStatement
}

func (*AnalyzeProfileStatementContext) IsAnalyzeProfileStatementContext() {}

func NewAnalyzeProfileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzeProfileStatementContext {
	var p = new(AnalyzeProfileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_analyzeProfileStatement

	return p
}

func (s *AnalyzeProfileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzeProfileStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserANALYZE, 0)
}

func (s *AnalyzeProfileStatementContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROFILE, 0)
}

func (s *AnalyzeProfileStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *AnalyzeProfileStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AnalyzeProfileStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserINTEGER_VALUE)
}

func (s *AnalyzeProfileStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, i)
}

func (s *AnalyzeProfileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeProfileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnalyzeProfileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAnalyzeProfileStatement(s)
	}
}

func (s *AnalyzeProfileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAnalyzeProfileStatement(s)
	}
}

func (s *AnalyzeProfileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAnalyzeProfileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AnalyzeProfileStatement() (localctx IAnalyzeProfileStatementContext) {
	localctx = NewAnalyzeProfileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, DorisSQLParserParserRULE_analyzeProfileStatement)
	var _la int

	p.SetState(3906)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 382, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3889)
			p.Match(DorisSQLParserParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3890)
			p.Match(DorisSQLParserParserPROFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3891)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3892)
			p.String_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3893)
			p.Match(DorisSQLParserParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3894)
			p.Match(DorisSQLParserParserPROFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3895)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3896)
			p.String_()
		}
		{
			p.SetState(3897)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3898)
			p.Match(DorisSQLParserParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3903)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(3899)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3900)
				p.Match(DorisSQLParserParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(3905)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateBaselinePlanStatementContext is an interface to support dynamic dispatch.
type ICreateBaselinePlanStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	BASELINE() antlr.TerminalNode
	USING() antlr.TerminalNode
	AllQueryRelation() []IQueryRelationContext
	QueryRelation(i int) IQueryRelationContext
	GLOBAL() antlr.TerminalNode
	ON() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsCreateBaselinePlanStatementContext differentiates from other interfaces.
	IsCreateBaselinePlanStatementContext()
}

type CreateBaselinePlanStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateBaselinePlanStatementContext() *CreateBaselinePlanStatementContext {
	var p = new(CreateBaselinePlanStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createBaselinePlanStatement
	return p
}

func InitEmptyCreateBaselinePlanStatementContext(p *CreateBaselinePlanStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createBaselinePlanStatement
}

func (*CreateBaselinePlanStatementContext) IsCreateBaselinePlanStatementContext() {}

func NewCreateBaselinePlanStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateBaselinePlanStatementContext {
	var p = new(CreateBaselinePlanStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createBaselinePlanStatement

	return p
}

func (s *CreateBaselinePlanStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateBaselinePlanStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateBaselinePlanStatementContext) BASELINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBASELINE, 0)
}

func (s *CreateBaselinePlanStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSING, 0)
}

func (s *CreateBaselinePlanStatementContext) AllQueryRelation() []IQueryRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQueryRelationContext); ok {
			len++
		}
	}

	tst := make([]IQueryRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQueryRelationContext); ok {
			tst[i] = t.(IQueryRelationContext)
			i++
		}
	}

	return tst
}

func (s *CreateBaselinePlanStatementContext) QueryRelation(i int) IQueryRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *CreateBaselinePlanStatementContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGLOBAL, 0)
}

func (s *CreateBaselinePlanStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *CreateBaselinePlanStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateBaselinePlanStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateBaselinePlanStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateBaselinePlanStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateBaselinePlanStatement(s)
	}
}

func (s *CreateBaselinePlanStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateBaselinePlanStatement(s)
	}
}

func (s *CreateBaselinePlanStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateBaselinePlanStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateBaselinePlanStatement() (localctx ICreateBaselinePlanStatementContext) {
	localctx = NewCreateBaselinePlanStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, DorisSQLParserParserRULE_createBaselinePlanStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3908)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3910)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserGLOBAL {
		{
			p.SetState(3909)
			p.Match(DorisSQLParserParserGLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3912)
		p.Match(DorisSQLParserParserBASELINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3915)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserON {
		{
			p.SetState(3913)
			p.Match(DorisSQLParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3914)
			p.QueryRelation()
		}

	}
	{
		p.SetState(3917)
		p.Match(DorisSQLParserParserUSING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3918)
		p.QueryRelation()
	}
	p.SetState(3920)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(3919)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropBaselinePlanStatementContext is an interface to support dynamic dispatch.
type IDropBaselinePlanStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	BASELINE() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsDropBaselinePlanStatementContext differentiates from other interfaces.
	IsDropBaselinePlanStatementContext()
}

type DropBaselinePlanStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropBaselinePlanStatementContext() *DropBaselinePlanStatementContext {
	var p = new(DropBaselinePlanStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropBaselinePlanStatement
	return p
}

func InitEmptyDropBaselinePlanStatementContext(p *DropBaselinePlanStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropBaselinePlanStatement
}

func (*DropBaselinePlanStatementContext) IsDropBaselinePlanStatementContext() {}

func NewDropBaselinePlanStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropBaselinePlanStatementContext {
	var p = new(DropBaselinePlanStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropBaselinePlanStatement

	return p
}

func (s *DropBaselinePlanStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropBaselinePlanStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropBaselinePlanStatementContext) BASELINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBASELINE, 0)
}

func (s *DropBaselinePlanStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserINTEGER_VALUE)
}

func (s *DropBaselinePlanStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, i)
}

func (s *DropBaselinePlanStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropBaselinePlanStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropBaselinePlanStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropBaselinePlanStatement(s)
	}
}

func (s *DropBaselinePlanStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropBaselinePlanStatement(s)
	}
}

func (s *DropBaselinePlanStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropBaselinePlanStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropBaselinePlanStatement() (localctx IDropBaselinePlanStatementContext) {
	localctx = NewDropBaselinePlanStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, DorisSQLParserParserRULE_dropBaselinePlanStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3922)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3923)
		p.Match(DorisSQLParserParserBASELINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3924)
		p.Match(DorisSQLParserParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3929)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(3925)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3926)
			p.Match(DorisSQLParserParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(3931)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowBaselinePlanStatementContext is an interface to support dynamic dispatch.
type IShowBaselinePlanStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	BASELINE() antlr.TerminalNode

	// IsShowBaselinePlanStatementContext differentiates from other interfaces.
	IsShowBaselinePlanStatementContext()
}

type ShowBaselinePlanStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowBaselinePlanStatementContext() *ShowBaselinePlanStatementContext {
	var p = new(ShowBaselinePlanStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showBaselinePlanStatement
	return p
}

func InitEmptyShowBaselinePlanStatementContext(p *ShowBaselinePlanStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showBaselinePlanStatement
}

func (*ShowBaselinePlanStatementContext) IsShowBaselinePlanStatementContext() {}

func NewShowBaselinePlanStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowBaselinePlanStatementContext {
	var p = new(ShowBaselinePlanStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showBaselinePlanStatement

	return p
}

func (s *ShowBaselinePlanStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowBaselinePlanStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowBaselinePlanStatementContext) BASELINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBASELINE, 0)
}

func (s *ShowBaselinePlanStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBaselinePlanStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowBaselinePlanStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowBaselinePlanStatement(s)
	}
}

func (s *ShowBaselinePlanStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowBaselinePlanStatement(s)
	}
}

func (s *ShowBaselinePlanStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowBaselinePlanStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowBaselinePlanStatement() (localctx IShowBaselinePlanStatementContext) {
	localctx = NewShowBaselinePlanStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, DorisSQLParserParserRULE_showBaselinePlanStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3932)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3933)
		p.Match(DorisSQLParserParserBASELINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateResourceGroupStatementContext is an interface to support dynamic dispatch.
type ICreateResourceGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Identifier() IIdentifierContext
	WITH() antlr.TerminalNode
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	TO() antlr.TerminalNode
	AllClassifier() []IClassifierContext
	Classifier(i int) IClassifierContext

	// IsCreateResourceGroupStatementContext differentiates from other interfaces.
	IsCreateResourceGroupStatementContext()
}

type CreateResourceGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateResourceGroupStatementContext() *CreateResourceGroupStatementContext {
	var p = new(CreateResourceGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createResourceGroupStatement
	return p
}

func InitEmptyCreateResourceGroupStatementContext(p *CreateResourceGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createResourceGroupStatement
}

func (*CreateResourceGroupStatementContext) IsCreateResourceGroupStatementContext() {}

func NewCreateResourceGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateResourceGroupStatementContext {
	var p = new(CreateResourceGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createResourceGroupStatement

	return p
}

func (s *CreateResourceGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateResourceGroupStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateResourceGroupStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRESOURCE, 0)
}

func (s *CreateResourceGroupStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGROUP, 0)
}

func (s *CreateResourceGroupStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateResourceGroupStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *CreateResourceGroupStatementContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *CreateResourceGroupStatementContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *CreateResourceGroupStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *CreateResourceGroupStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *CreateResourceGroupStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *CreateResourceGroupStatementContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOR, 0)
}

func (s *CreateResourceGroupStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPLACE, 0)
}

func (s *CreateResourceGroupStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTO, 0)
}

func (s *CreateResourceGroupStatementContext) AllClassifier() []IClassifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassifierContext); ok {
			len++
		}
	}

	tst := make([]IClassifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassifierContext); ok {
			tst[i] = t.(IClassifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateResourceGroupStatementContext) Classifier(i int) IClassifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassifierContext)
}

func (s *CreateResourceGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateResourceGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateResourceGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateResourceGroupStatement(s)
	}
}

func (s *CreateResourceGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateResourceGroupStatement(s)
	}
}

func (s *CreateResourceGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateResourceGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateResourceGroupStatement() (localctx ICreateResourceGroupStatementContext) {
	localctx = NewCreateResourceGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, DorisSQLParserParserRULE_createResourceGroupStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3935)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3936)
		p.Match(DorisSQLParserParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3937)
		p.Match(DorisSQLParserParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3941)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(3938)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3939)
			p.Match(DorisSQLParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3940)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3945)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserOR {
		{
			p.SetState(3943)
			p.Match(DorisSQLParserParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3944)
			p.Match(DorisSQLParserParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3947)
		p.Identifier()
	}
	p.SetState(3957)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserTO {
		{
			p.SetState(3948)
			p.Match(DorisSQLParserParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3949)
			p.Classifier()
		}
		p.SetState(3954)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(3950)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3951)
				p.Classifier()
			}

			p.SetState(3956)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3959)
		p.Match(DorisSQLParserParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3960)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3961)
		p.Property()
	}
	p.SetState(3966)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(3962)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3963)
			p.Property()
		}

		p.SetState(3968)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3969)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropResourceGroupStatementContext is an interface to support dynamic dispatch.
type IDropResourceGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDropResourceGroupStatementContext differentiates from other interfaces.
	IsDropResourceGroupStatementContext()
}

type DropResourceGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropResourceGroupStatementContext() *DropResourceGroupStatementContext {
	var p = new(DropResourceGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropResourceGroupStatement
	return p
}

func InitEmptyDropResourceGroupStatementContext(p *DropResourceGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropResourceGroupStatement
}

func (*DropResourceGroupStatementContext) IsDropResourceGroupStatementContext() {}

func NewDropResourceGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropResourceGroupStatementContext {
	var p = new(DropResourceGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropResourceGroupStatement

	return p
}

func (s *DropResourceGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropResourceGroupStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropResourceGroupStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRESOURCE, 0)
}

func (s *DropResourceGroupStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGROUP, 0)
}

func (s *DropResourceGroupStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropResourceGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropResourceGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropResourceGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropResourceGroupStatement(s)
	}
}

func (s *DropResourceGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropResourceGroupStatement(s)
	}
}

func (s *DropResourceGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropResourceGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropResourceGroupStatement() (localctx IDropResourceGroupStatementContext) {
	localctx = NewDropResourceGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, DorisSQLParserParserRULE_dropResourceGroupStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3971)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3972)
		p.Match(DorisSQLParserParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3973)
		p.Match(DorisSQLParserParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3974)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterResourceGroupStatementContext is an interface to support dynamic dispatch.
type IAlterResourceGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Identifier() IIdentifierContext
	ADD() antlr.TerminalNode
	AllClassifier() []IClassifierContext
	Classifier(i int) IClassifierContext
	DROP() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	ALL() antlr.TerminalNode
	WITH() antlr.TerminalNode
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext

	// IsAlterResourceGroupStatementContext differentiates from other interfaces.
	IsAlterResourceGroupStatementContext()
}

type AlterResourceGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterResourceGroupStatementContext() *AlterResourceGroupStatementContext {
	var p = new(AlterResourceGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterResourceGroupStatement
	return p
}

func InitEmptyAlterResourceGroupStatementContext(p *AlterResourceGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterResourceGroupStatement
}

func (*AlterResourceGroupStatementContext) IsAlterResourceGroupStatementContext() {}

func NewAlterResourceGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterResourceGroupStatementContext {
	var p = new(AlterResourceGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_alterResourceGroupStatement

	return p
}

func (s *AlterResourceGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterResourceGroupStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *AlterResourceGroupStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRESOURCE, 0)
}

func (s *AlterResourceGroupStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGROUP, 0)
}

func (s *AlterResourceGroupStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterResourceGroupStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADD, 0)
}

func (s *AlterResourceGroupStatementContext) AllClassifier() []IClassifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassifierContext); ok {
			len++
		}
	}

	tst := make([]IClassifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassifierContext); ok {
			tst[i] = t.(IClassifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterResourceGroupStatementContext) Classifier(i int) IClassifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassifierContext)
}

func (s *AlterResourceGroupStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *AlterResourceGroupStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserINTEGER_VALUE)
}

func (s *AlterResourceGroupStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, i)
}

func (s *AlterResourceGroupStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, 0)
}

func (s *AlterResourceGroupStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *AlterResourceGroupStatementContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *AlterResourceGroupStatementContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *AlterResourceGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterResourceGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterResourceGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAlterResourceGroupStatement(s)
	}
}

func (s *AlterResourceGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAlterResourceGroupStatement(s)
	}
}

func (s *AlterResourceGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAlterResourceGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AlterResourceGroupStatement() (localctx IAlterResourceGroupStatementContext) {
	localctx = NewAlterResourceGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, DorisSQLParserParserRULE_alterResourceGroupStatement)
	var _la int

	p.SetState(4028)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 395, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3976)
			p.Match(DorisSQLParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3977)
			p.Match(DorisSQLParserParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3978)
			p.Match(DorisSQLParserParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3979)
			p.Identifier()
		}
		{
			p.SetState(3980)
			p.Match(DorisSQLParserParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3981)
			p.Classifier()
		}
		p.SetState(3986)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(3982)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3983)
				p.Classifier()
			}

			p.SetState(3988)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3989)
			p.Match(DorisSQLParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3990)
			p.Match(DorisSQLParserParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3991)
			p.Match(DorisSQLParserParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3992)
			p.Identifier()
		}
		{
			p.SetState(3993)
			p.Match(DorisSQLParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3994)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3995)
			p.Match(DorisSQLParserParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4000)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(3996)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3997)
				p.Match(DorisSQLParserParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(4002)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4003)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4005)
			p.Match(DorisSQLParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4006)
			p.Match(DorisSQLParserParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4007)
			p.Match(DorisSQLParserParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4008)
			p.Identifier()
		}
		{
			p.SetState(4009)
			p.Match(DorisSQLParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4010)
			p.Match(DorisSQLParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4012)
			p.Match(DorisSQLParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4013)
			p.Match(DorisSQLParserParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4014)
			p.Match(DorisSQLParserParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4015)
			p.Identifier()
		}
		{
			p.SetState(4016)
			p.Match(DorisSQLParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4017)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4018)
			p.Property()
		}
		p.SetState(4023)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(4019)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4020)
				p.Property()
			}

			p.SetState(4025)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4026)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowResourceGroupStatementContext is an interface to support dynamic dispatch.
type IShowResourceGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Identifier() IIdentifierContext
	VERBOSE() antlr.TerminalNode
	GROUPS() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsShowResourceGroupStatementContext differentiates from other interfaces.
	IsShowResourceGroupStatementContext()
}

type ShowResourceGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowResourceGroupStatementContext() *ShowResourceGroupStatementContext {
	var p = new(ShowResourceGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showResourceGroupStatement
	return p
}

func InitEmptyShowResourceGroupStatementContext(p *ShowResourceGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showResourceGroupStatement
}

func (*ShowResourceGroupStatementContext) IsShowResourceGroupStatementContext() {}

func NewShowResourceGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowResourceGroupStatementContext {
	var p = new(ShowResourceGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showResourceGroupStatement

	return p
}

func (s *ShowResourceGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowResourceGroupStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowResourceGroupStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRESOURCE, 0)
}

func (s *ShowResourceGroupStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGROUP, 0)
}

func (s *ShowResourceGroupStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowResourceGroupStatementContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVERBOSE, 0)
}

func (s *ShowResourceGroupStatementContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGROUPS, 0)
}

func (s *ShowResourceGroupStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, 0)
}

func (s *ShowResourceGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowResourceGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowResourceGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowResourceGroupStatement(s)
	}
}

func (s *ShowResourceGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowResourceGroupStatement(s)
	}
}

func (s *ShowResourceGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowResourceGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowResourceGroupStatement() (localctx IShowResourceGroupStatementContext) {
	localctx = NewShowResourceGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, DorisSQLParserParserRULE_showResourceGroupStatement)
	var _la int

	p.SetState(4046)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 399, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4030)
			p.Match(DorisSQLParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4032)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserVERBOSE {
			{
				p.SetState(4031)
				p.Match(DorisSQLParserParserVERBOSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4034)
			p.Match(DorisSQLParserParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4035)
			p.Match(DorisSQLParserParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4036)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4037)
			p.Match(DorisSQLParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4039)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserVERBOSE {
			{
				p.SetState(4038)
				p.Match(DorisSQLParserParserVERBOSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4041)
			p.Match(DorisSQLParserParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4042)
			p.Match(DorisSQLParserParserGROUPS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4044)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserALL {
			{
				p.SetState(4043)
				p.Match(DorisSQLParserParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowResourceGroupUsageStatementContext is an interface to support dynamic dispatch.
type IShowResourceGroupUsageStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	USAGE() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Identifier() IIdentifierContext
	GROUPS() antlr.TerminalNode

	// IsShowResourceGroupUsageStatementContext differentiates from other interfaces.
	IsShowResourceGroupUsageStatementContext()
}

type ShowResourceGroupUsageStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowResourceGroupUsageStatementContext() *ShowResourceGroupUsageStatementContext {
	var p = new(ShowResourceGroupUsageStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showResourceGroupUsageStatement
	return p
}

func InitEmptyShowResourceGroupUsageStatementContext(p *ShowResourceGroupUsageStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showResourceGroupUsageStatement
}

func (*ShowResourceGroupUsageStatementContext) IsShowResourceGroupUsageStatementContext() {}

func NewShowResourceGroupUsageStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowResourceGroupUsageStatementContext {
	var p = new(ShowResourceGroupUsageStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showResourceGroupUsageStatement

	return p
}

func (s *ShowResourceGroupUsageStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowResourceGroupUsageStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowResourceGroupUsageStatementContext) USAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSAGE, 0)
}

func (s *ShowResourceGroupUsageStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRESOURCE, 0)
}

func (s *ShowResourceGroupUsageStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGROUP, 0)
}

func (s *ShowResourceGroupUsageStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowResourceGroupUsageStatementContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGROUPS, 0)
}

func (s *ShowResourceGroupUsageStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowResourceGroupUsageStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowResourceGroupUsageStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowResourceGroupUsageStatement(s)
	}
}

func (s *ShowResourceGroupUsageStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowResourceGroupUsageStatement(s)
	}
}

func (s *ShowResourceGroupUsageStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowResourceGroupUsageStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowResourceGroupUsageStatement() (localctx IShowResourceGroupUsageStatementContext) {
	localctx = NewShowResourceGroupUsageStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, DorisSQLParserParserRULE_showResourceGroupUsageStatement)
	p.SetState(4057)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 400, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4048)
			p.Match(DorisSQLParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4049)
			p.Match(DorisSQLParserParserUSAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4050)
			p.Match(DorisSQLParserParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4051)
			p.Match(DorisSQLParserParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4052)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4053)
			p.Match(DorisSQLParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4054)
			p.Match(DorisSQLParserParserUSAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4055)
			p.Match(DorisSQLParserParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4056)
			p.Match(DorisSQLParserParserGROUPS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateResourceStatementContext is an interface to support dynamic dispatch.
type ICreateResourceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResourceName returns the resourceName rule contexts.
	GetResourceName() IIdentifierOrStringContext

	// SetResourceName sets the resourceName rule contexts.
	SetResourceName(IIdentifierOrStringContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	EXTERNAL() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsCreateResourceStatementContext differentiates from other interfaces.
	IsCreateResourceStatementContext()
}

type CreateResourceStatementContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	resourceName IIdentifierOrStringContext
}

func NewEmptyCreateResourceStatementContext() *CreateResourceStatementContext {
	var p = new(CreateResourceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createResourceStatement
	return p
}

func InitEmptyCreateResourceStatementContext(p *CreateResourceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createResourceStatement
}

func (*CreateResourceStatementContext) IsCreateResourceStatementContext() {}

func NewCreateResourceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateResourceStatementContext {
	var p = new(CreateResourceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createResourceStatement

	return p
}

func (s *CreateResourceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateResourceStatementContext) GetResourceName() IIdentifierOrStringContext {
	return s.resourceName
}

func (s *CreateResourceStatementContext) SetResourceName(v IIdentifierOrStringContext) {
	s.resourceName = v
}

func (s *CreateResourceStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateResourceStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRESOURCE, 0)
}

func (s *CreateResourceStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CreateResourceStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXTERNAL, 0)
}

func (s *CreateResourceStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateResourceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateResourceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateResourceStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateResourceStatement(s)
	}
}

func (s *CreateResourceStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateResourceStatement(s)
	}
}

func (s *CreateResourceStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateResourceStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateResourceStatement() (localctx ICreateResourceStatementContext) {
	localctx = NewCreateResourceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, DorisSQLParserParserRULE_createResourceStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4059)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4061)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserEXTERNAL {
		{
			p.SetState(4060)
			p.Match(DorisSQLParserParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4063)
		p.Match(DorisSQLParserParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4064)

		var _x = p.IdentifierOrString()

		localctx.(*CreateResourceStatementContext).resourceName = _x
	}
	p.SetState(4066)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(4065)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterResourceStatementContext is an interface to support dynamic dispatch.
type IAlterResourceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResourceName returns the resourceName rule contexts.
	GetResourceName() IIdentifierOrStringContext

	// SetResourceName sets the resourceName rule contexts.
	SetResourceName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	SET() antlr.TerminalNode
	Properties() IPropertiesContext
	IdentifierOrString() IIdentifierOrStringContext

	// IsAlterResourceStatementContext differentiates from other interfaces.
	IsAlterResourceStatementContext()
}

type AlterResourceStatementContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	resourceName IIdentifierOrStringContext
}

func NewEmptyAlterResourceStatementContext() *AlterResourceStatementContext {
	var p = new(AlterResourceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterResourceStatement
	return p
}

func InitEmptyAlterResourceStatementContext(p *AlterResourceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterResourceStatement
}

func (*AlterResourceStatementContext) IsAlterResourceStatementContext() {}

func NewAlterResourceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterResourceStatementContext {
	var p = new(AlterResourceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_alterResourceStatement

	return p
}

func (s *AlterResourceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterResourceStatementContext) GetResourceName() IIdentifierOrStringContext {
	return s.resourceName
}

func (s *AlterResourceStatementContext) SetResourceName(v IIdentifierOrStringContext) {
	s.resourceName = v
}

func (s *AlterResourceStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *AlterResourceStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRESOURCE, 0)
}

func (s *AlterResourceStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *AlterResourceStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AlterResourceStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AlterResourceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterResourceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterResourceStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAlterResourceStatement(s)
	}
}

func (s *AlterResourceStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAlterResourceStatement(s)
	}
}

func (s *AlterResourceStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAlterResourceStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AlterResourceStatement() (localctx IAlterResourceStatementContext) {
	localctx = NewAlterResourceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, DorisSQLParserParserRULE_alterResourceStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4068)
		p.Match(DorisSQLParserParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4069)
		p.Match(DorisSQLParserParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4070)

		var _x = p.IdentifierOrString()

		localctx.(*AlterResourceStatementContext).resourceName = _x
	}
	{
		p.SetState(4071)
		p.Match(DorisSQLParserParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4072)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropResourceStatementContext is an interface to support dynamic dispatch.
type IDropResourceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResourceName returns the resourceName rule contexts.
	GetResourceName() IIdentifierOrStringContext

	// SetResourceName sets the resourceName rule contexts.
	SetResourceName(IIdentifierOrStringContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsDropResourceStatementContext differentiates from other interfaces.
	IsDropResourceStatementContext()
}

type DropResourceStatementContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	resourceName IIdentifierOrStringContext
}

func NewEmptyDropResourceStatementContext() *DropResourceStatementContext {
	var p = new(DropResourceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropResourceStatement
	return p
}

func InitEmptyDropResourceStatementContext(p *DropResourceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropResourceStatement
}

func (*DropResourceStatementContext) IsDropResourceStatementContext() {}

func NewDropResourceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropResourceStatementContext {
	var p = new(DropResourceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropResourceStatement

	return p
}

func (s *DropResourceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropResourceStatementContext) GetResourceName() IIdentifierOrStringContext {
	return s.resourceName
}

func (s *DropResourceStatementContext) SetResourceName(v IIdentifierOrStringContext) {
	s.resourceName = v
}

func (s *DropResourceStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropResourceStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRESOURCE, 0)
}

func (s *DropResourceStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropResourceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropResourceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropResourceStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropResourceStatement(s)
	}
}

func (s *DropResourceStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropResourceStatement(s)
	}
}

func (s *DropResourceStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropResourceStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropResourceStatement() (localctx IDropResourceStatementContext) {
	localctx = NewDropResourceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, DorisSQLParserParserRULE_dropResourceStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4074)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4075)
		p.Match(DorisSQLParserParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4076)

		var _x = p.IdentifierOrString()

		localctx.(*DropResourceStatementContext).resourceName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowResourceStatementContext is an interface to support dynamic dispatch.
type IShowResourceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	RESOURCES() antlr.TerminalNode

	// IsShowResourceStatementContext differentiates from other interfaces.
	IsShowResourceStatementContext()
}

type ShowResourceStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowResourceStatementContext() *ShowResourceStatementContext {
	var p = new(ShowResourceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showResourceStatement
	return p
}

func InitEmptyShowResourceStatementContext(p *ShowResourceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showResourceStatement
}

func (*ShowResourceStatementContext) IsShowResourceStatementContext() {}

func NewShowResourceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowResourceStatementContext {
	var p = new(ShowResourceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showResourceStatement

	return p
}

func (s *ShowResourceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowResourceStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowResourceStatementContext) RESOURCES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRESOURCES, 0)
}

func (s *ShowResourceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowResourceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowResourceStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowResourceStatement(s)
	}
}

func (s *ShowResourceStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowResourceStatement(s)
	}
}

func (s *ShowResourceStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowResourceStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowResourceStatement() (localctx IShowResourceStatementContext) {
	localctx = NewShowResourceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, DorisSQLParserParserRULE_showResourceStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4078)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4079)
		p.Match(DorisSQLParserParserRESOURCES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassifierContext is an interface to support dynamic dispatch.
type IClassifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionList() IExpressionListContext

	// IsClassifierContext differentiates from other interfaces.
	IsClassifierContext()
}

type ClassifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassifierContext() *ClassifierContext {
	var p = new(ClassifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_classifier
	return p
}

func InitEmptyClassifierContext(p *ClassifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_classifier
}

func (*ClassifierContext) IsClassifierContext() {}

func NewClassifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassifierContext {
	var p = new(ClassifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_classifier

	return p
}

func (s *ClassifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassifierContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ClassifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterClassifier(s)
	}
}

func (s *ClassifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitClassifier(s)
	}
}

func (s *ClassifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitClassifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Classifier() (localctx IClassifierContext) {
	localctx = NewClassifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, DorisSQLParserParserRULE_classifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4081)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4082)
		p.ExpressionList()
	}
	{
		p.SetState(4083)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowFunctionsStatementContext is an interface to support dynamic dispatch.
type IShowFunctionsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	FUNCTIONS() antlr.TerminalNode
	FULL() antlr.TerminalNode
	BUILTIN() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowFunctionsStatementContext differentiates from other interfaces.
	IsShowFunctionsStatementContext()
}

type ShowFunctionsStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	db      IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowFunctionsStatementContext() *ShowFunctionsStatementContext {
	var p = new(ShowFunctionsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showFunctionsStatement
	return p
}

func InitEmptyShowFunctionsStatementContext(p *ShowFunctionsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showFunctionsStatement
}

func (*ShowFunctionsStatementContext) IsShowFunctionsStatementContext() {}

func NewShowFunctionsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowFunctionsStatementContext {
	var p = new(ShowFunctionsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showFunctionsStatement

	return p
}

func (s *ShowFunctionsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowFunctionsStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowFunctionsStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowFunctionsStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowFunctionsStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowFunctionsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowFunctionsStatementContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFUNCTIONS, 0)
}

func (s *ShowFunctionsStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFULL, 0)
}

func (s *ShowFunctionsStatementContext) BUILTIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBUILTIN, 0)
}

func (s *ShowFunctionsStatementContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGLOBAL, 0)
}

func (s *ShowFunctionsStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowFunctionsStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *ShowFunctionsStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowFunctionsStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *ShowFunctionsStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowFunctionsStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowFunctionsStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowFunctionsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFunctionsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowFunctionsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowFunctionsStatement(s)
	}
}

func (s *ShowFunctionsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowFunctionsStatement(s)
	}
}

func (s *ShowFunctionsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowFunctionsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowFunctionsStatement() (localctx IShowFunctionsStatementContext) {
	localctx = NewShowFunctionsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, DorisSQLParserParserRULE_showFunctionsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4085)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4087)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFULL {
		{
			p.SetState(4086)
			p.Match(DorisSQLParserParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4090)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserBUILTIN || _la == DorisSQLParserParserGLOBAL {
		{
			p.SetState(4089)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserBUILTIN || _la == DorisSQLParserParserGLOBAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(4092)
		p.Match(DorisSQLParserParserFUNCTIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4095)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN {
		{
			p.SetState(4093)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4094)

			var _x = p.QualifiedName()

			localctx.(*ShowFunctionsStatementContext).db = _x
		}

	}
	p.SetState(4101)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserLIKE:
		{
			p.SetState(4097)
			p.Match(DorisSQLParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4098)

			var _x = p.String_()

			localctx.(*ShowFunctionsStatementContext).pattern = _x
		}

	case DorisSQLParserParserWHERE:
		{
			p.SetState(4099)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4100)
			p.expression(0)
		}

	case DorisSQLParserParserEOF, DorisSQLParserParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropFunctionStatementContext is an interface to support dynamic dispatch.
type IDropFunctionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	TypeList() ITypeListContext
	GLOBAL() antlr.TerminalNode
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropFunctionStatementContext differentiates from other interfaces.
	IsDropFunctionStatementContext()
}

type DropFunctionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropFunctionStatementContext() *DropFunctionStatementContext {
	var p = new(DropFunctionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropFunctionStatement
	return p
}

func InitEmptyDropFunctionStatementContext(p *DropFunctionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropFunctionStatement
}

func (*DropFunctionStatementContext) IsDropFunctionStatementContext() {}

func NewDropFunctionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFunctionStatementContext {
	var p = new(DropFunctionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropFunctionStatement

	return p
}

func (s *DropFunctionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFunctionStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropFunctionStatementContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFUNCTION, 0)
}

func (s *DropFunctionStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropFunctionStatementContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *DropFunctionStatementContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGLOBAL, 0)
}

func (s *DropFunctionStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *DropFunctionStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *DropFunctionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFunctionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropFunctionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropFunctionStatement(s)
	}
}

func (s *DropFunctionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropFunctionStatement(s)
	}
}

func (s *DropFunctionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropFunctionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropFunctionStatement() (localctx IDropFunctionStatementContext) {
	localctx = NewDropFunctionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, DorisSQLParserParserRULE_dropFunctionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4103)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4105)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserGLOBAL {
		{
			p.SetState(4104)
			p.Match(DorisSQLParserParserGLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4107)
		p.Match(DorisSQLParserParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4110)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(4108)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4109)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4112)
		p.QualifiedName()
	}
	{
		p.SetState(4113)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4114)
		p.TypeList()
	}
	{
		p.SetState(4115)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateFunctionStatementContext is an interface to support dynamic dispatch.
type ICreateFunctionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFunctionType returns the functionType token.
	GetFunctionType() antlr.Token

	// SetFunctionType sets the functionType token.
	SetFunctionType(antlr.Token)

	// GetReturnType returns the returnType rule contexts.
	GetReturnType() ITypeContext

	// SetReturnType sets the returnType rule contexts.
	SetReturnType(ITypeContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	OrReplace() IOrReplaceContext
	FUNCTION() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	QualifiedName() IQualifiedNameContext
	TypeList() ITypeListContext
	RETURNS() antlr.TerminalNode
	Type_() ITypeContext
	GLOBAL() antlr.TerminalNode
	Properties() IPropertiesContext
	InlineProperties() IInlinePropertiesContext
	InlineFunction() IInlineFunctionContext
	TABLE() antlr.TerminalNode
	AGGREGATE() antlr.TerminalNode

	// IsCreateFunctionStatementContext differentiates from other interfaces.
	IsCreateFunctionStatementContext()
}

type CreateFunctionStatementContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	functionType antlr.Token
	returnType   ITypeContext
}

func NewEmptyCreateFunctionStatementContext() *CreateFunctionStatementContext {
	var p = new(CreateFunctionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createFunctionStatement
	return p
}

func InitEmptyCreateFunctionStatementContext(p *CreateFunctionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createFunctionStatement
}

func (*CreateFunctionStatementContext) IsCreateFunctionStatementContext() {}

func NewCreateFunctionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateFunctionStatementContext {
	var p = new(CreateFunctionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createFunctionStatement

	return p
}

func (s *CreateFunctionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateFunctionStatementContext) GetFunctionType() antlr.Token { return s.functionType }

func (s *CreateFunctionStatementContext) SetFunctionType(v antlr.Token) { s.functionType = v }

func (s *CreateFunctionStatementContext) GetReturnType() ITypeContext { return s.returnType }

func (s *CreateFunctionStatementContext) SetReturnType(v ITypeContext) { s.returnType = v }

func (s *CreateFunctionStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateFunctionStatementContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreateFunctionStatementContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFUNCTION, 0)
}

func (s *CreateFunctionStatementContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateFunctionStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateFunctionStatementContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *CreateFunctionStatementContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRETURNS, 0)
}

func (s *CreateFunctionStatementContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *CreateFunctionStatementContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGLOBAL, 0)
}

func (s *CreateFunctionStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateFunctionStatementContext) InlineProperties() IInlinePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlinePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlinePropertiesContext)
}

func (s *CreateFunctionStatementContext) InlineFunction() IInlineFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineFunctionContext)
}

func (s *CreateFunctionStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *CreateFunctionStatementContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAGGREGATE, 0)
}

func (s *CreateFunctionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFunctionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateFunctionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateFunctionStatement(s)
	}
}

func (s *CreateFunctionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateFunctionStatement(s)
	}
}

func (s *CreateFunctionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateFunctionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateFunctionStatement() (localctx ICreateFunctionStatementContext) {
	localctx = NewCreateFunctionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, DorisSQLParserParserRULE_createFunctionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4117)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4118)
		p.OrReplace()
	}
	p.SetState(4120)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserGLOBAL {
		{
			p.SetState(4119)
			p.Match(DorisSQLParserParserGLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4123)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserAGGREGATE || _la == DorisSQLParserParserTABLE {
		{
			p.SetState(4122)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateFunctionStatementContext).functionType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserAGGREGATE || _la == DorisSQLParserParserTABLE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateFunctionStatementContext).functionType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(4125)
		p.Match(DorisSQLParserParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4126)
		p.IfNotExists()
	}
	{
		p.SetState(4127)
		p.QualifiedName()
	}
	{
		p.SetState(4128)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4129)
		p.TypeList()
	}
	{
		p.SetState(4130)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4131)
		p.Match(DorisSQLParserParserRETURNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4132)

		var _x = p.Type_()

		localctx.(*CreateFunctionStatementContext).returnType = _x
	}
	p.SetState(4135)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 411, p.GetParserRuleContext()) == 1+1 {
		{
			p.SetState(4133)
			p.Properties()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 411, p.GetParserRuleContext()) == 2+1 {
		{
			p.SetState(4134)
			p.InlineProperties()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4138)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserAS {
		{
			p.SetState(4137)
			p.InlineFunction()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlineFunctionContext is an interface to support dynamic dispatch.
type IInlineFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	ATTACHMENT() antlr.TerminalNode

	// IsInlineFunctionContext differentiates from other interfaces.
	IsInlineFunctionContext()
}

type InlineFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineFunctionContext() *InlineFunctionContext {
	var p = new(InlineFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_inlineFunction
	return p
}

func InitEmptyInlineFunctionContext(p *InlineFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_inlineFunction
}

func (*InlineFunctionContext) IsInlineFunctionContext() {}

func NewInlineFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineFunctionContext {
	var p = new(InlineFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_inlineFunction

	return p
}

func (s *InlineFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *InlineFunctionContext) ATTACHMENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserATTACHMENT, 0)
}

func (s *InlineFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterInlineFunction(s)
	}
}

func (s *InlineFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitInlineFunction(s)
	}
}

func (s *InlineFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitInlineFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) InlineFunction() (localctx IInlineFunctionContext) {
	localctx = NewInlineFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, DorisSQLParserParserRULE_inlineFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4140)
		p.Match(DorisSQLParserParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4141)
		p.Match(DorisSQLParserParserATTACHMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	DOTDOTDOT() antlr.TerminalNode

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_typeList
	return p
}

func InitEmptyTypeListContext(p *TypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_typeList
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeListContext) DOTDOTDOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDOTDOTDOT, 0)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTypeList(s)
	}
}

func (s *TypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTypeList(s)
	}
}

func (s *TypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, DorisSQLParserParserRULE_typeList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4144)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-24)) & ^0x3f) == 0 && ((int64(1)<<(_la-24))&1099547017217) != 0) || ((int64((_la-106)) & ^0x3f) == 0 && ((int64(1)<<(_la-106))&144115188109411299) != 0) || ((int64((_la-190)) & ^0x3f) == 0 && ((int64(1)<<(_la-190))&4611690485199667201) != 0) || ((int64((_la-284)) & ^0x3f) == 0 && ((int64(1)<<(_la-284))&67108867) != 0) || ((int64((_la-399)) & ^0x3f) == 0 && ((int64(1)<<(_la-399))&36029080491024393) != 0) || _la == DorisSQLParserParserVARBINARY || _la == DorisSQLParserParserVARCHAR {
		{
			p.SetState(4143)
			p.Type_()
		}

	}
	p.SetState(4150)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 414, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4146)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4147)
				p.Type_()
			}

		}
		p.SetState(4152)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 414, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(4155)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserT__2 {
		{
			p.SetState(4153)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4154)
			p.Match(DorisSQLParserParserDOTDOTDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoadStatementContext is an interface to support dynamic dispatch.
type ILoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLabel returns the label rule contexts.
	GetLabel() ILabelNameContext

	// GetData returns the data rule contexts.
	GetData() IDataDescListContext

	// GetBroker returns the broker rule contexts.
	GetBroker() IBrokerDescContext

	// GetSystem returns the system rule contexts.
	GetSystem() IIdentifierOrStringContext

	// GetProps returns the props rule contexts.
	GetProps() IPropertyListContext

	// GetResource returns the resource rule contexts.
	GetResource() IResourceDescContext

	// SetLabel sets the label rule contexts.
	SetLabel(ILabelNameContext)

	// SetData sets the data rule contexts.
	SetData(IDataDescListContext)

	// SetBroker sets the broker rule contexts.
	SetBroker(IBrokerDescContext)

	// SetSystem sets the system rule contexts.
	SetSystem(IIdentifierOrStringContext)

	// SetProps sets the props rule contexts.
	SetProps(IPropertyListContext)

	// SetResource sets the resource rule contexts.
	SetResource(IResourceDescContext)

	// Getter signatures
	LOAD() antlr.TerminalNode
	LABEL() antlr.TerminalNode
	LabelName() ILabelNameContext
	BY() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode
	DataDescList() IDataDescListContext
	BrokerDesc() IBrokerDescContext
	IdentifierOrString() IIdentifierOrStringContext
	PropertyList() IPropertyListContext
	ResourceDesc() IResourceDescContext

	// IsLoadStatementContext differentiates from other interfaces.
	IsLoadStatementContext()
}

type LoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	label    ILabelNameContext
	data     IDataDescListContext
	broker   IBrokerDescContext
	system   IIdentifierOrStringContext
	props    IPropertyListContext
	resource IResourceDescContext
}

func NewEmptyLoadStatementContext() *LoadStatementContext {
	var p = new(LoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_loadStatement
	return p
}

func InitEmptyLoadStatementContext(p *LoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_loadStatement
}

func (*LoadStatementContext) IsLoadStatementContext() {}

func NewLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadStatementContext {
	var p = new(LoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_loadStatement

	return p
}

func (s *LoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadStatementContext) GetLabel() ILabelNameContext { return s.label }

func (s *LoadStatementContext) GetData() IDataDescListContext { return s.data }

func (s *LoadStatementContext) GetBroker() IBrokerDescContext { return s.broker }

func (s *LoadStatementContext) GetSystem() IIdentifierOrStringContext { return s.system }

func (s *LoadStatementContext) GetProps() IPropertyListContext { return s.props }

func (s *LoadStatementContext) GetResource() IResourceDescContext { return s.resource }

func (s *LoadStatementContext) SetLabel(v ILabelNameContext) { s.label = v }

func (s *LoadStatementContext) SetData(v IDataDescListContext) { s.data = v }

func (s *LoadStatementContext) SetBroker(v IBrokerDescContext) { s.broker = v }

func (s *LoadStatementContext) SetSystem(v IIdentifierOrStringContext) { s.system = v }

func (s *LoadStatementContext) SetProps(v IPropertyListContext) { s.props = v }

func (s *LoadStatementContext) SetResource(v IResourceDescContext) { s.resource = v }

func (s *LoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOAD, 0)
}

func (s *LoadStatementContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLABEL, 0)
}

func (s *LoadStatementContext) LabelName() ILabelNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelNameContext)
}

func (s *LoadStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *LoadStatementContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROPERTIES, 0)
}

func (s *LoadStatementContext) DataDescList() IDataDescListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescListContext)
}

func (s *LoadStatementContext) BrokerDesc() IBrokerDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBrokerDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBrokerDescContext)
}

func (s *LoadStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *LoadStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *LoadStatementContext) ResourceDesc() IResourceDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceDescContext)
}

func (s *LoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterLoadStatement(s)
	}
}

func (s *LoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitLoadStatement(s)
	}
}

func (s *LoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) LoadStatement() (localctx ILoadStatementContext) {
	localctx = NewLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, DorisSQLParserParserRULE_loadStatement)
	var _la int

	p.SetState(4185)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 422, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4157)
			p.Match(DorisSQLParserParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4158)
			p.Match(DorisSQLParserParserLABEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4159)

			var _x = p.LabelName()

			localctx.(*LoadStatementContext).label = _x
		}
		p.SetState(4161)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__1 {
			{
				p.SetState(4160)

				var _x = p.DataDescList()

				localctx.(*LoadStatementContext).data = _x
			}

		}
		p.SetState(4164)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserWITH {
			{
				p.SetState(4163)

				var _x = p.BrokerDesc()

				localctx.(*LoadStatementContext).broker = _x
			}

		}
		p.SetState(4168)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserBY {
			{
				p.SetState(4166)
				p.Match(DorisSQLParserParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4167)

				var _x = p.IdentifierOrString()

				localctx.(*LoadStatementContext).system = _x
			}

		}
		p.SetState(4172)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserPROPERTIES {
			{
				p.SetState(4170)
				p.Match(DorisSQLParserParserPROPERTIES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4171)

				var _x = p.PropertyList()

				localctx.(*LoadStatementContext).props = _x
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4174)
			p.Match(DorisSQLParserParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4175)
			p.Match(DorisSQLParserParserLABEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4176)

			var _x = p.LabelName()

			localctx.(*LoadStatementContext).label = _x
		}
		p.SetState(4178)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__1 {
			{
				p.SetState(4177)

				var _x = p.DataDescList()

				localctx.(*LoadStatementContext).data = _x
			}

		}
		{
			p.SetState(4180)

			var _x = p.ResourceDesc()

			localctx.(*LoadStatementContext).resource = _x
		}
		p.SetState(4183)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserPROPERTIES {
			{
				p.SetState(4181)
				p.Match(DorisSQLParserParserPROPERTIES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4182)

				var _x = p.PropertyList()

				localctx.(*LoadStatementContext).props = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelNameContext is an interface to support dynamic dispatch.
type ILabelNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IIdentifierContext

	// GetLabel returns the label rule contexts.
	GetLabel() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IIdentifierContext)

	// SetLabel sets the label rule contexts.
	SetLabel(IIdentifierContext)

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsLabelNameContext differentiates from other interfaces.
	IsLabelNameContext()
}

type LabelNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IIdentifierContext
	label  IIdentifierContext
}

func NewEmptyLabelNameContext() *LabelNameContext {
	var p = new(LabelNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_labelName
	return p
}

func InitEmptyLabelNameContext(p *LabelNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_labelName
}

func (*LabelNameContext) IsLabelNameContext() {}

func NewLabelNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelNameContext {
	var p = new(LabelNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_labelName

	return p
}

func (s *LabelNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelNameContext) GetDb() IIdentifierContext { return s.db }

func (s *LabelNameContext) GetLabel() IIdentifierContext { return s.label }

func (s *LabelNameContext) SetDb(v IIdentifierContext) { s.db = v }

func (s *LabelNameContext) SetLabel(v IIdentifierContext) { s.label = v }

func (s *LabelNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *LabelNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LabelNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterLabelName(s)
	}
}

func (s *LabelNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitLabelName(s)
	}
}

func (s *LabelNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitLabelName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) LabelName() (localctx ILabelNameContext) {
	localctx = NewLabelNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, DorisSQLParserParserRULE_labelName)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4190)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 423, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4187)

			var _x = p.Identifier()

			localctx.(*LabelNameContext).db = _x
		}
		{
			p.SetState(4188)
			p.Match(DorisSQLParserParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4192)

		var _x = p.Identifier()

		localctx.(*LabelNameContext).label = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataDescListContext is an interface to support dynamic dispatch.
type IDataDescListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDataDesc() []IDataDescContext
	DataDesc(i int) IDataDescContext

	// IsDataDescListContext differentiates from other interfaces.
	IsDataDescListContext()
}

type DataDescListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDescListContext() *DataDescListContext {
	var p = new(DataDescListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dataDescList
	return p
}

func InitEmptyDataDescListContext(p *DataDescListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dataDescList
}

func (*DataDescListContext) IsDataDescListContext() {}

func NewDataDescListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescListContext {
	var p = new(DataDescListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dataDescList

	return p
}

func (s *DataDescListContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDescListContext) AllDataDesc() []IDataDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataDescContext); ok {
			len++
		}
	}

	tst := make([]IDataDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataDescContext); ok {
			tst[i] = t.(IDataDescContext)
			i++
		}
	}

	return tst
}

func (s *DataDescListContext) DataDesc(i int) IDataDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescContext)
}

func (s *DataDescListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDataDescList(s)
	}
}

func (s *DataDescListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDataDescList(s)
	}
}

func (s *DataDescListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDataDescList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DataDescList() (localctx IDataDescListContext) {
	localctx = NewDataDescListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, DorisSQLParserParserRULE_dataDescList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4194)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4195)
		p.DataDesc()
	}
	p.SetState(4200)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(4196)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4197)
			p.DataDesc()
		}

		p.SetState(4202)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4203)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataDescContext is an interface to support dynamic dispatch.
type IDataDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSrcFiles returns the srcFiles rule contexts.
	GetSrcFiles() IStringListContext

	// GetDstTableName returns the dstTableName rule contexts.
	GetDstTableName() IIdentifierContext

	// GetPartitions returns the partitions rule contexts.
	GetPartitions() IPartitionNamesContext

	// GetColSep returns the colSep rule contexts.
	GetColSep() IStringContext

	// GetRowSep returns the rowSep rule contexts.
	GetRowSep() IStringContext

	// GetFormat returns the format rule contexts.
	GetFormat() IFileFormatContext

	// GetFormatPropsField returns the formatPropsField rule contexts.
	GetFormatPropsField() IFormatPropsContext

	// GetColList returns the colList rule contexts.
	GetColList() IColumnAliasesContext

	// GetColFromPath returns the colFromPath rule contexts.
	GetColFromPath() IIdentifierListContext

	// GetColMappingList returns the colMappingList rule contexts.
	GetColMappingList() IClassifierContext

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// GetSrcTableName returns the srcTableName rule contexts.
	GetSrcTableName() IIdentifierContext

	// SetSrcFiles sets the srcFiles rule contexts.
	SetSrcFiles(IStringListContext)

	// SetDstTableName sets the dstTableName rule contexts.
	SetDstTableName(IIdentifierContext)

	// SetPartitions sets the partitions rule contexts.
	SetPartitions(IPartitionNamesContext)

	// SetColSep sets the colSep rule contexts.
	SetColSep(IStringContext)

	// SetRowSep sets the rowSep rule contexts.
	SetRowSep(IStringContext)

	// SetFormat sets the format rule contexts.
	SetFormat(IFileFormatContext)

	// SetFormatPropsField sets the formatPropsField rule contexts.
	SetFormatPropsField(IFormatPropsContext)

	// SetColList sets the colList rule contexts.
	SetColList(IColumnAliasesContext)

	// SetColFromPath sets the colFromPath rule contexts.
	SetColFromPath(IIdentifierListContext)

	// SetColMappingList sets the colMappingList rule contexts.
	SetColMappingList(IClassifierContext)

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// SetSrcTableName sets the srcTableName rule contexts.
	SetSrcTableName(IIdentifierContext)

	// Getter signatures
	DATA() antlr.TerminalNode
	INFILE() antlr.TerminalNode
	INTO() antlr.TerminalNode
	AllTABLE() []antlr.TerminalNode
	TABLE(i int) antlr.TerminalNode
	StringList() IStringListContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	NEGATIVE() antlr.TerminalNode
	AllCOLUMNS() []antlr.TerminalNode
	COLUMNS(i int) antlr.TerminalNode
	AllTERMINATED() []antlr.TerminalNode
	TERMINATED(i int) antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	ROWS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	PATH() antlr.TerminalNode
	AS() antlr.TerminalNode
	SET() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	PartitionNames() IPartitionNamesContext
	AllString_() []IStringContext
	String_(i int) IStringContext
	FileFormat() IFileFormatContext
	FormatProps() IFormatPropsContext
	ColumnAliases() IColumnAliasesContext
	IdentifierList() IIdentifierListContext
	Classifier() IClassifierContext
	Expression() IExpressionContext

	// IsDataDescContext differentiates from other interfaces.
	IsDataDescContext()
}

type DataDescContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	srcFiles         IStringListContext
	dstTableName     IIdentifierContext
	partitions       IPartitionNamesContext
	colSep           IStringContext
	rowSep           IStringContext
	format           IFileFormatContext
	formatPropsField IFormatPropsContext
	colList          IColumnAliasesContext
	colFromPath      IIdentifierListContext
	colMappingList   IClassifierContext
	where            IExpressionContext
	srcTableName     IIdentifierContext
}

func NewEmptyDataDescContext() *DataDescContext {
	var p = new(DataDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dataDesc
	return p
}

func InitEmptyDataDescContext(p *DataDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dataDesc
}

func (*DataDescContext) IsDataDescContext() {}

func NewDataDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescContext {
	var p = new(DataDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dataDesc

	return p
}

func (s *DataDescContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDescContext) GetSrcFiles() IStringListContext { return s.srcFiles }

func (s *DataDescContext) GetDstTableName() IIdentifierContext { return s.dstTableName }

func (s *DataDescContext) GetPartitions() IPartitionNamesContext { return s.partitions }

func (s *DataDescContext) GetColSep() IStringContext { return s.colSep }

func (s *DataDescContext) GetRowSep() IStringContext { return s.rowSep }

func (s *DataDescContext) GetFormat() IFileFormatContext { return s.format }

func (s *DataDescContext) GetFormatPropsField() IFormatPropsContext { return s.formatPropsField }

func (s *DataDescContext) GetColList() IColumnAliasesContext { return s.colList }

func (s *DataDescContext) GetColFromPath() IIdentifierListContext { return s.colFromPath }

func (s *DataDescContext) GetColMappingList() IClassifierContext { return s.colMappingList }

func (s *DataDescContext) GetWhere() IExpressionContext { return s.where }

func (s *DataDescContext) GetSrcTableName() IIdentifierContext { return s.srcTableName }

func (s *DataDescContext) SetSrcFiles(v IStringListContext) { s.srcFiles = v }

func (s *DataDescContext) SetDstTableName(v IIdentifierContext) { s.dstTableName = v }

func (s *DataDescContext) SetPartitions(v IPartitionNamesContext) { s.partitions = v }

func (s *DataDescContext) SetColSep(v IStringContext) { s.colSep = v }

func (s *DataDescContext) SetRowSep(v IStringContext) { s.rowSep = v }

func (s *DataDescContext) SetFormat(v IFileFormatContext) { s.format = v }

func (s *DataDescContext) SetFormatPropsField(v IFormatPropsContext) { s.formatPropsField = v }

func (s *DataDescContext) SetColList(v IColumnAliasesContext) { s.colList = v }

func (s *DataDescContext) SetColFromPath(v IIdentifierListContext) { s.colFromPath = v }

func (s *DataDescContext) SetColMappingList(v IClassifierContext) { s.colMappingList = v }

func (s *DataDescContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *DataDescContext) SetSrcTableName(v IIdentifierContext) { s.srcTableName = v }

func (s *DataDescContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATA, 0)
}

func (s *DataDescContext) INFILE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINFILE, 0)
}

func (s *DataDescContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTO, 0)
}

func (s *DataDescContext) AllTABLE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserTABLE)
}

func (s *DataDescContext) TABLE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, i)
}

func (s *DataDescContext) StringList() IStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringListContext)
}

func (s *DataDescContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DataDescContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DataDescContext) NEGATIVE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNEGATIVE, 0)
}

func (s *DataDescContext) AllCOLUMNS() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserCOLUMNS)
}

func (s *DataDescContext) COLUMNS(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLUMNS, i)
}

func (s *DataDescContext) AllTERMINATED() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserTERMINATED)
}

func (s *DataDescContext) TERMINATED(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTERMINATED, i)
}

func (s *DataDescContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserBY)
}

func (s *DataDescContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, i)
}

func (s *DataDescContext) ROWS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROWS, 0)
}

func (s *DataDescContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *DataDescContext) PATH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPATH, 0)
}

func (s *DataDescContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *DataDescContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *DataDescContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *DataDescContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *DataDescContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *DataDescContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DataDescContext) FileFormat() IFileFormatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileFormatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileFormatContext)
}

func (s *DataDescContext) FormatProps() IFormatPropsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormatPropsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormatPropsContext)
}

func (s *DataDescContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *DataDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DataDescContext) Classifier() IClassifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassifierContext)
}

func (s *DataDescContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DataDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDataDesc(s)
	}
}

func (s *DataDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDataDesc(s)
	}
}

func (s *DataDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDataDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DataDesc() (localctx IDataDescContext) {
	localctx = NewDataDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, DorisSQLParserParserRULE_dataDesc)
	var _la int

	p.SetState(4274)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 439, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4205)
			p.Match(DorisSQLParserParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4206)
			p.Match(DorisSQLParserParserINFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4207)

			var _x = p.StringList()

			localctx.(*DataDescContext).srcFiles = _x
		}
		p.SetState(4209)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserNEGATIVE {
			{
				p.SetState(4208)
				p.Match(DorisSQLParserParserNEGATIVE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4211)
			p.Match(DorisSQLParserParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4212)
			p.Match(DorisSQLParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4213)

			var _x = p.Identifier()

			localctx.(*DataDescContext).dstTableName = _x
		}
		p.SetState(4215)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserPARTITION || _la == DorisSQLParserParserPARTITIONS || _la == DorisSQLParserParserTEMPORARY {
			{
				p.SetState(4214)

				var _x = p.PartitionNames()

				localctx.(*DataDescContext).partitions = _x
			}

		}
		p.SetState(4221)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 427, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4217)
				p.Match(DorisSQLParserParserCOLUMNS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4218)
				p.Match(DorisSQLParserParserTERMINATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4219)
				p.Match(DorisSQLParserParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4220)

				var _x = p.String_()

				localctx.(*DataDescContext).colSep = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4227)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserROWS {
			{
				p.SetState(4223)
				p.Match(DorisSQLParserParserROWS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4224)
				p.Match(DorisSQLParserParserTERMINATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4225)
				p.Match(DorisSQLParserParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4226)

				var _x = p.String_()

				localctx.(*DataDescContext).rowSep = _x
			}

		}
		p.SetState(4230)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserFORMAT {
			{
				p.SetState(4229)

				var _x = p.FileFormat()

				localctx.(*DataDescContext).format = _x
			}

		}
		p.SetState(4233)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 430, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4232)

				var _x = p.FormatProps()

				localctx.(*DataDescContext).formatPropsField = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4236)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__1 {
			{
				p.SetState(4235)

				var _x = p.ColumnAliases()

				localctx.(*DataDescContext).colList = _x
			}

		}
		p.SetState(4243)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserCOLUMNS {
			{
				p.SetState(4238)
				p.Match(DorisSQLParserParserCOLUMNS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4239)
				p.Match(DorisSQLParserParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4240)
				p.Match(DorisSQLParserParserPATH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4241)
				p.Match(DorisSQLParserParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4242)

				var _x = p.IdentifierList()

				localctx.(*DataDescContext).colFromPath = _x
			}

		}
		p.SetState(4247)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserSET {
			{
				p.SetState(4245)
				p.Match(DorisSQLParserParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4246)

				var _x = p.Classifier()

				localctx.(*DataDescContext).colMappingList = _x
			}

		}
		p.SetState(4251)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserWHERE {
			{
				p.SetState(4249)
				p.Match(DorisSQLParserParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4250)

				var _x = p.expression(0)

				localctx.(*DataDescContext).where = _x
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4253)
			p.Match(DorisSQLParserParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4254)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4255)
			p.Match(DorisSQLParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4256)

			var _x = p.Identifier()

			localctx.(*DataDescContext).srcTableName = _x
		}
		p.SetState(4258)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserNEGATIVE {
			{
				p.SetState(4257)
				p.Match(DorisSQLParserParserNEGATIVE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4260)
			p.Match(DorisSQLParserParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4261)
			p.Match(DorisSQLParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4262)

			var _x = p.Identifier()

			localctx.(*DataDescContext).dstTableName = _x
		}
		p.SetState(4264)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserPARTITION || _la == DorisSQLParserParserPARTITIONS || _la == DorisSQLParserParserTEMPORARY {
			{
				p.SetState(4263)

				var _x = p.PartitionNames()

				localctx.(*DataDescContext).partitions = _x
			}

		}
		p.SetState(4268)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserSET {
			{
				p.SetState(4266)
				p.Match(DorisSQLParserParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4267)

				var _x = p.Classifier()

				localctx.(*DataDescContext).colMappingList = _x
			}

		}
		p.SetState(4272)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserWHERE {
			{
				p.SetState(4270)
				p.Match(DorisSQLParserParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4271)

				var _x = p.expression(0)

				localctx.(*DataDescContext).where = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormatPropsContext is an interface to support dynamic dispatch.
type IFormatPropsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetEncloseCharacter returns the encloseCharacter rule contexts.
	GetEncloseCharacter() IStringContext

	// GetEscapeCharacter returns the escapeCharacter rule contexts.
	GetEscapeCharacter() IStringContext

	// SetEncloseCharacter sets the encloseCharacter rule contexts.
	SetEncloseCharacter(IStringContext)

	// SetEscapeCharacter sets the escapeCharacter rule contexts.
	SetEscapeCharacter(IStringContext)

	// Getter signatures
	SKIP_HEADER() antlr.TerminalNode
	AllEQ() []antlr.TerminalNode
	EQ(i int) antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	TRIM_SPACE() antlr.TerminalNode
	BooleanValue() IBooleanValueContext
	ENCLOSE() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsFormatPropsContext differentiates from other interfaces.
	IsFormatPropsContext()
}

type FormatPropsContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	encloseCharacter IStringContext
	escapeCharacter  IStringContext
}

func NewEmptyFormatPropsContext() *FormatPropsContext {
	var p = new(FormatPropsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_formatProps
	return p
}

func InitEmptyFormatPropsContext(p *FormatPropsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_formatProps
}

func (*FormatPropsContext) IsFormatPropsContext() {}

func NewFormatPropsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormatPropsContext {
	var p = new(FormatPropsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_formatProps

	return p
}

func (s *FormatPropsContext) GetParser() antlr.Parser { return s.parser }

func (s *FormatPropsContext) GetEncloseCharacter() IStringContext { return s.encloseCharacter }

func (s *FormatPropsContext) GetEscapeCharacter() IStringContext { return s.escapeCharacter }

func (s *FormatPropsContext) SetEncloseCharacter(v IStringContext) { s.encloseCharacter = v }

func (s *FormatPropsContext) SetEscapeCharacter(v IStringContext) { s.escapeCharacter = v }

func (s *FormatPropsContext) SKIP_HEADER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSKIP_HEADER, 0)
}

func (s *FormatPropsContext) AllEQ() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserEQ)
}

func (s *FormatPropsContext) EQ(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEQ, i)
}

func (s *FormatPropsContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, 0)
}

func (s *FormatPropsContext) TRIM_SPACE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTRIM_SPACE, 0)
}

func (s *FormatPropsContext) BooleanValue() IBooleanValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *FormatPropsContext) ENCLOSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserENCLOSE, 0)
}

func (s *FormatPropsContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserESCAPE, 0)
}

func (s *FormatPropsContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *FormatPropsContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *FormatPropsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormatPropsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormatPropsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterFormatProps(s)
	}
}

func (s *FormatPropsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitFormatProps(s)
	}
}

func (s *FormatPropsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitFormatProps(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) FormatProps() (localctx IFormatPropsContext) {
	localctx = NewFormatPropsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, DorisSQLParserParserRULE_formatProps)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4276)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4280)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserSKIP_HEADER {
		{
			p.SetState(4277)
			p.Match(DorisSQLParserParserSKIP_HEADER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4278)
			p.Match(DorisSQLParserParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4279)
			p.Match(DorisSQLParserParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4285)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserTRIM_SPACE {
		{
			p.SetState(4282)
			p.Match(DorisSQLParserParserTRIM_SPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4283)
			p.Match(DorisSQLParserParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4284)
			p.BooleanValue()
		}

	}
	p.SetState(4290)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserENCLOSE {
		{
			p.SetState(4287)
			p.Match(DorisSQLParserParserENCLOSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4288)
			p.Match(DorisSQLParserParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4289)

			var _x = p.String_()

			localctx.(*FormatPropsContext).encloseCharacter = _x
		}

	}
	p.SetState(4295)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserESCAPE {
		{
			p.SetState(4292)
			p.Match(DorisSQLParserParserESCAPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4293)
			p.Match(DorisSQLParserParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4294)

			var _x = p.String_()

			localctx.(*FormatPropsContext).escapeCharacter = _x
		}

	}
	{
		p.SetState(4297)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBrokerDescContext is an interface to support dynamic dispatch.
type IBrokerDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetProps returns the props rule contexts.
	GetProps() IPropertyListContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierOrStringContext

	// SetProps sets the props rule contexts.
	SetProps(IPropertyListContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierOrStringContext)

	// Getter signatures
	WITH() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	PropertyList() IPropertyListContext
	IdentifierOrString() IIdentifierOrStringContext

	// IsBrokerDescContext differentiates from other interfaces.
	IsBrokerDescContext()
}

type BrokerDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	props  IPropertyListContext
	name   IIdentifierOrStringContext
}

func NewEmptyBrokerDescContext() *BrokerDescContext {
	var p = new(BrokerDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_brokerDesc
	return p
}

func InitEmptyBrokerDescContext(p *BrokerDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_brokerDesc
}

func (*BrokerDescContext) IsBrokerDescContext() {}

func NewBrokerDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BrokerDescContext {
	var p = new(BrokerDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_brokerDesc

	return p
}

func (s *BrokerDescContext) GetParser() antlr.Parser { return s.parser }

func (s *BrokerDescContext) GetProps() IPropertyListContext { return s.props }

func (s *BrokerDescContext) GetName() IIdentifierOrStringContext { return s.name }

func (s *BrokerDescContext) SetProps(v IPropertyListContext) { s.props = v }

func (s *BrokerDescContext) SetName(v IIdentifierOrStringContext) { s.name = v }

func (s *BrokerDescContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *BrokerDescContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBROKER, 0)
}

func (s *BrokerDescContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *BrokerDescContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *BrokerDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BrokerDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BrokerDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterBrokerDesc(s)
	}
}

func (s *BrokerDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitBrokerDesc(s)
	}
}

func (s *BrokerDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitBrokerDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) BrokerDesc() (localctx IBrokerDescContext) {
	localctx = NewBrokerDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, DorisSQLParserParserRULE_brokerDesc)
	var _la int

	p.SetState(4310)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 446, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4299)
			p.Match(DorisSQLParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4300)
			p.Match(DorisSQLParserParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4302)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__1 {
			{
				p.SetState(4301)

				var _x = p.PropertyList()

				localctx.(*BrokerDescContext).props = _x
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4304)
			p.Match(DorisSQLParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4305)
			p.Match(DorisSQLParserParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4306)

			var _x = p.IdentifierOrString()

			localctx.(*BrokerDescContext).name = _x
		}
		p.SetState(4308)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__1 {
			{
				p.SetState(4307)

				var _x = p.PropertyList()

				localctx.(*BrokerDescContext).props = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceDescContext is an interface to support dynamic dispatch.
type IResourceDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierOrStringContext

	// GetProps returns the props rule contexts.
	GetProps() IPropertyListContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierOrStringContext)

	// SetProps sets the props rule contexts.
	SetProps(IPropertyListContext)

	// Getter signatures
	WITH() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	PropertyList() IPropertyListContext

	// IsResourceDescContext differentiates from other interfaces.
	IsResourceDescContext()
}

type ResourceDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierOrStringContext
	props  IPropertyListContext
}

func NewEmptyResourceDescContext() *ResourceDescContext {
	var p = new(ResourceDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_resourceDesc
	return p
}

func InitEmptyResourceDescContext(p *ResourceDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_resourceDesc
}

func (*ResourceDescContext) IsResourceDescContext() {}

func NewResourceDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceDescContext {
	var p = new(ResourceDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_resourceDesc

	return p
}

func (s *ResourceDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceDescContext) GetName() IIdentifierOrStringContext { return s.name }

func (s *ResourceDescContext) GetProps() IPropertyListContext { return s.props }

func (s *ResourceDescContext) SetName(v IIdentifierOrStringContext) { s.name = v }

func (s *ResourceDescContext) SetProps(v IPropertyListContext) { s.props = v }

func (s *ResourceDescContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *ResourceDescContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRESOURCE, 0)
}

func (s *ResourceDescContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *ResourceDescContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *ResourceDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterResourceDesc(s)
	}
}

func (s *ResourceDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitResourceDesc(s)
	}
}

func (s *ResourceDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitResourceDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ResourceDesc() (localctx IResourceDescContext) {
	localctx = NewResourceDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, DorisSQLParserParserRULE_resourceDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4312)
		p.Match(DorisSQLParserParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4313)
		p.Match(DorisSQLParserParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4314)

		var _x = p.IdentifierOrString()

		localctx.(*ResourceDescContext).name = _x
	}
	p.SetState(4316)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserT__1 {
		{
			p.SetState(4315)

			var _x = p.PropertyList()

			localctx.(*ResourceDescContext).props = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowLoadStatementContext is an interface to support dynamic dispatch.
type IShowLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	ALL() antlr.TerminalNode
	FROM() antlr.TerminalNode
	Identifier() IIdentifierContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext

	// IsShowLoadStatementContext differentiates from other interfaces.
	IsShowLoadStatementContext()
}

type ShowLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowLoadStatementContext() *ShowLoadStatementContext {
	var p = new(ShowLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showLoadStatement
	return p
}

func InitEmptyShowLoadStatementContext(p *ShowLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showLoadStatement
}

func (*ShowLoadStatementContext) IsShowLoadStatementContext() {}

func NewShowLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowLoadStatementContext {
	var p = new(ShowLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showLoadStatement

	return p
}

func (s *ShowLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowLoadStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOAD, 0)
}

func (s *ShowLoadStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, 0)
}

func (s *ShowLoadStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowLoadStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowLoadStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowLoadStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserORDER, 0)
}

func (s *ShowLoadStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *ShowLoadStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowLoadStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowLoadStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowLoadStatement(s)
	}
}

func (s *ShowLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowLoadStatement(s)
	}
}

func (s *ShowLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowLoadStatement() (localctx IShowLoadStatementContext) {
	localctx = NewShowLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, DorisSQLParserParserRULE_showLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4318)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4319)
		p.Match(DorisSQLParserParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4321)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserALL {
		{
			p.SetState(4320)
			p.Match(DorisSQLParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4325)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM {
		{
			p.SetState(4323)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4324)
			p.Identifier()
		}

	}
	p.SetState(4329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWHERE {
		{
			p.SetState(4327)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4328)
			p.expression(0)
		}

	}
	p.SetState(4341)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserORDER {
		{
			p.SetState(4331)
			p.Match(DorisSQLParserParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4332)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4333)
			p.SortItem()
		}
		p.SetState(4338)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(4334)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4335)
				p.SortItem()
			}

			p.SetState(4340)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(4344)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserLIMIT {
		{
			p.SetState(4343)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowLoadWarningsStatementContext is an interface to support dynamic dispatch.
type IShowLoadWarningsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	WARNINGS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	Identifier() IIdentifierContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	LimitElement() ILimitElementContext
	ON() antlr.TerminalNode
	String_() IStringContext

	// IsShowLoadWarningsStatementContext differentiates from other interfaces.
	IsShowLoadWarningsStatementContext()
}

type ShowLoadWarningsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowLoadWarningsStatementContext() *ShowLoadWarningsStatementContext {
	var p = new(ShowLoadWarningsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showLoadWarningsStatement
	return p
}

func InitEmptyShowLoadWarningsStatementContext(p *ShowLoadWarningsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showLoadWarningsStatement
}

func (*ShowLoadWarningsStatementContext) IsShowLoadWarningsStatementContext() {}

func NewShowLoadWarningsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowLoadWarningsStatementContext {
	var p = new(ShowLoadWarningsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showLoadWarningsStatement

	return p
}

func (s *ShowLoadWarningsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowLoadWarningsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowLoadWarningsStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOAD, 0)
}

func (s *ShowLoadWarningsStatementContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWARNINGS, 0)
}

func (s *ShowLoadWarningsStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowLoadWarningsStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowLoadWarningsStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowLoadWarningsStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowLoadWarningsStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowLoadWarningsStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *ShowLoadWarningsStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowLoadWarningsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowLoadWarningsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowLoadWarningsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowLoadWarningsStatement(s)
	}
}

func (s *ShowLoadWarningsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowLoadWarningsStatement(s)
	}
}

func (s *ShowLoadWarningsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowLoadWarningsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowLoadWarningsStatement() (localctx IShowLoadWarningsStatementContext) {
	localctx = NewShowLoadWarningsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, DorisSQLParserParserRULE_showLoadWarningsStatement)
	var _la int

	p.SetState(4365)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 457, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4346)
			p.Match(DorisSQLParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4347)
			p.Match(DorisSQLParserParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4348)
			p.Match(DorisSQLParserParserWARNINGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4351)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserFROM {
			{
				p.SetState(4349)
				p.Match(DorisSQLParserParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4350)
				p.Identifier()
			}

		}
		p.SetState(4355)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserWHERE {
			{
				p.SetState(4353)
				p.Match(DorisSQLParserParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4354)
				p.expression(0)
			}

		}
		p.SetState(4358)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserLIMIT {
			{
				p.SetState(4357)
				p.LimitElement()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4360)
			p.Match(DorisSQLParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4361)
			p.Match(DorisSQLParserParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4362)
			p.Match(DorisSQLParserParserWARNINGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4363)
			p.Match(DorisSQLParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4364)
			p.String_()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelLoadStatementContext is an interface to support dynamic dispatch.
type ICancelLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FROM() antlr.TerminalNode
	Identifier() IIdentifierContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsCancelLoadStatementContext differentiates from other interfaces.
	IsCancelLoadStatementContext()
}

type CancelLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelLoadStatementContext() *CancelLoadStatementContext {
	var p = new(CancelLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cancelLoadStatement
	return p
}

func InitEmptyCancelLoadStatementContext(p *CancelLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cancelLoadStatement
}

func (*CancelLoadStatementContext) IsCancelLoadStatementContext() {}

func NewCancelLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelLoadStatementContext {
	var p = new(CancelLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_cancelLoadStatement

	return p
}

func (s *CancelLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelLoadStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCANCEL, 0)
}

func (s *CancelLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOAD, 0)
}

func (s *CancelLoadStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *CancelLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelLoadStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *CancelLoadStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CancelLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCancelLoadStatement(s)
	}
}

func (s *CancelLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCancelLoadStatement(s)
	}
}

func (s *CancelLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCancelLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CancelLoadStatement() (localctx ICancelLoadStatementContext) {
	localctx = NewCancelLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, DorisSQLParserParserRULE_cancelLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4367)
		p.Match(DorisSQLParserParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4368)
		p.Match(DorisSQLParserParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4371)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM {
		{
			p.SetState(4369)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4370)
			p.Identifier()
		}

	}
	p.SetState(4375)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWHERE {
		{
			p.SetState(4373)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4374)
			p.expression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterLoadStatementContext is an interface to support dynamic dispatch.
type IAlterLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	JobProperties() IJobPropertiesContext
	QualifiedName() IQualifiedNameContext

	// IsAlterLoadStatementContext differentiates from other interfaces.
	IsAlterLoadStatementContext()
}

type AlterLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyAlterLoadStatementContext() *AlterLoadStatementContext {
	var p = new(AlterLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterLoadStatement
	return p
}

func InitEmptyAlterLoadStatementContext(p *AlterLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterLoadStatement
}

func (*AlterLoadStatementContext) IsAlterLoadStatementContext() {}

func NewAlterLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterLoadStatementContext {
	var p = new(AlterLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_alterLoadStatement

	return p
}

func (s *AlterLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *AlterLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *AlterLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *AlterLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterLoadStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *AlterLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOAD, 0)
}

func (s *AlterLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFOR, 0)
}

func (s *AlterLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterLoadStatementContext) JobProperties() IJobPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJobPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJobPropertiesContext)
}

func (s *AlterLoadStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAlterLoadStatement(s)
	}
}

func (s *AlterLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAlterLoadStatement(s)
	}
}

func (s *AlterLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAlterLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AlterLoadStatement() (localctx IAlterLoadStatementContext) {
	localctx = NewAlterLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, DorisSQLParserParserRULE_alterLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4377)
		p.Match(DorisSQLParserParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4378)
		p.Match(DorisSQLParserParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4379)
		p.Match(DorisSQLParserParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4383)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 460, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4380)

			var _x = p.QualifiedName()

			localctx.(*AlterLoadStatementContext).db = _x
		}
		{
			p.SetState(4381)
			p.Match(DorisSQLParserParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4385)

		var _x = p.Identifier()

		localctx.(*AlterLoadStatementContext).name = _x
	}
	p.SetState(4387)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(4386)
			p.JobProperties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelCompactionStatementContext is an interface to support dynamic dispatch.
type ICancelCompactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	COMPACTION() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsCancelCompactionStatementContext differentiates from other interfaces.
	IsCancelCompactionStatementContext()
}

type CancelCompactionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelCompactionStatementContext() *CancelCompactionStatementContext {
	var p = new(CancelCompactionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cancelCompactionStatement
	return p
}

func InitEmptyCancelCompactionStatementContext(p *CancelCompactionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cancelCompactionStatement
}

func (*CancelCompactionStatementContext) IsCancelCompactionStatementContext() {}

func NewCancelCompactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelCompactionStatementContext {
	var p = new(CancelCompactionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_cancelCompactionStatement

	return p
}

func (s *CancelCompactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelCompactionStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCANCEL, 0)
}

func (s *CancelCompactionStatementContext) COMPACTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOMPACTION, 0)
}

func (s *CancelCompactionStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *CancelCompactionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CancelCompactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelCompactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelCompactionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCancelCompactionStatement(s)
	}
}

func (s *CancelCompactionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCancelCompactionStatement(s)
	}
}

func (s *CancelCompactionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCancelCompactionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CancelCompactionStatement() (localctx ICancelCompactionStatementContext) {
	localctx = NewCancelCompactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, DorisSQLParserParserRULE_cancelCompactionStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4389)
		p.Match(DorisSQLParserParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4390)
		p.Match(DorisSQLParserParserCOMPACTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4391)
		p.Match(DorisSQLParserParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4392)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowAuthorStatementContext is an interface to support dynamic dispatch.
type IShowAuthorStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	AUTHORS() antlr.TerminalNode

	// IsShowAuthorStatementContext differentiates from other interfaces.
	IsShowAuthorStatementContext()
}

type ShowAuthorStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowAuthorStatementContext() *ShowAuthorStatementContext {
	var p = new(ShowAuthorStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showAuthorStatement
	return p
}

func InitEmptyShowAuthorStatementContext(p *ShowAuthorStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showAuthorStatement
}

func (*ShowAuthorStatementContext) IsShowAuthorStatementContext() {}

func NewShowAuthorStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowAuthorStatementContext {
	var p = new(ShowAuthorStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showAuthorStatement

	return p
}

func (s *ShowAuthorStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowAuthorStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowAuthorStatementContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAUTHORS, 0)
}

func (s *ShowAuthorStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAuthorStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowAuthorStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowAuthorStatement(s)
	}
}

func (s *ShowAuthorStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowAuthorStatement(s)
	}
}

func (s *ShowAuthorStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowAuthorStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowAuthorStatement() (localctx IShowAuthorStatementContext) {
	localctx = NewShowAuthorStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, DorisSQLParserParserRULE_showAuthorStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4394)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4395)
		p.Match(DorisSQLParserParserAUTHORS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowBackendsStatementContext is an interface to support dynamic dispatch.
type IShowBackendsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	BACKENDS() antlr.TerminalNode

	// IsShowBackendsStatementContext differentiates from other interfaces.
	IsShowBackendsStatementContext()
}

type ShowBackendsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowBackendsStatementContext() *ShowBackendsStatementContext {
	var p = new(ShowBackendsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showBackendsStatement
	return p
}

func InitEmptyShowBackendsStatementContext(p *ShowBackendsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showBackendsStatement
}

func (*ShowBackendsStatementContext) IsShowBackendsStatementContext() {}

func NewShowBackendsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowBackendsStatementContext {
	var p = new(ShowBackendsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showBackendsStatement

	return p
}

func (s *ShowBackendsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowBackendsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowBackendsStatementContext) BACKENDS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBACKENDS, 0)
}

func (s *ShowBackendsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBackendsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowBackendsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowBackendsStatement(s)
	}
}

func (s *ShowBackendsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowBackendsStatement(s)
	}
}

func (s *ShowBackendsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowBackendsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowBackendsStatement() (localctx IShowBackendsStatementContext) {
	localctx = NewShowBackendsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, DorisSQLParserParserRULE_showBackendsStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4397)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4398)
		p.Match(DorisSQLParserParserBACKENDS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowBrokerStatementContext is an interface to support dynamic dispatch.
type IShowBrokerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	BROKER() antlr.TerminalNode

	// IsShowBrokerStatementContext differentiates from other interfaces.
	IsShowBrokerStatementContext()
}

type ShowBrokerStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowBrokerStatementContext() *ShowBrokerStatementContext {
	var p = new(ShowBrokerStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showBrokerStatement
	return p
}

func InitEmptyShowBrokerStatementContext(p *ShowBrokerStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showBrokerStatement
}

func (*ShowBrokerStatementContext) IsShowBrokerStatementContext() {}

func NewShowBrokerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowBrokerStatementContext {
	var p = new(ShowBrokerStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showBrokerStatement

	return p
}

func (s *ShowBrokerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowBrokerStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowBrokerStatementContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBROKER, 0)
}

func (s *ShowBrokerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBrokerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowBrokerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowBrokerStatement(s)
	}
}

func (s *ShowBrokerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowBrokerStatement(s)
	}
}

func (s *ShowBrokerStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowBrokerStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowBrokerStatement() (localctx IShowBrokerStatementContext) {
	localctx = NewShowBrokerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, DorisSQLParserParserRULE_showBrokerStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4400)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4401)
		p.Match(DorisSQLParserParserBROKER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCharsetStatementContext is an interface to support dynamic dispatch.
type IShowCharsetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	SET() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowCharsetStatementContext differentiates from other interfaces.
	IsShowCharsetStatementContext()
}

type ShowCharsetStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowCharsetStatementContext() *ShowCharsetStatementContext {
	var p = new(ShowCharsetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showCharsetStatement
	return p
}

func InitEmptyShowCharsetStatementContext(p *ShowCharsetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showCharsetStatement
}

func (*ShowCharsetStatementContext) IsShowCharsetStatementContext() {}

func NewShowCharsetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCharsetStatementContext {
	var p = new(ShowCharsetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showCharsetStatement

	return p
}

func (s *ShowCharsetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCharsetStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowCharsetStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowCharsetStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowCharsetStatementContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCHAR, 0)
}

func (s *ShowCharsetStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *ShowCharsetStatementContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCHARSET, 0)
}

func (s *ShowCharsetStatementContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCHARACTER, 0)
}

func (s *ShowCharsetStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *ShowCharsetStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowCharsetStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowCharsetStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowCharsetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCharsetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCharsetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowCharsetStatement(s)
	}
}

func (s *ShowCharsetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowCharsetStatement(s)
	}
}

func (s *ShowCharsetStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowCharsetStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowCharsetStatement() (localctx IShowCharsetStatementContext) {
	localctx = NewShowCharsetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, DorisSQLParserParserRULE_showCharsetStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4403)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4409)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserCHAR:
		{
			p.SetState(4404)
			p.Match(DorisSQLParserParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4405)
			p.Match(DorisSQLParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserCHARSET:
		{
			p.SetState(4406)
			p.Match(DorisSQLParserParserCHARSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserCHARACTER:
		{
			p.SetState(4407)
			p.Match(DorisSQLParserParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4408)
			p.Match(DorisSQLParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(4415)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserLIKE:
		{
			p.SetState(4411)
			p.Match(DorisSQLParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4412)

			var _x = p.String_()

			localctx.(*ShowCharsetStatementContext).pattern = _x
		}

	case DorisSQLParserParserWHERE:
		{
			p.SetState(4413)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4414)
			p.expression(0)
		}

	case DorisSQLParserParserEOF, DorisSQLParserParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCollationStatementContext is an interface to support dynamic dispatch.
type IShowCollationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowCollationStatementContext differentiates from other interfaces.
	IsShowCollationStatementContext()
}

type ShowCollationStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowCollationStatementContext() *ShowCollationStatementContext {
	var p = new(ShowCollationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showCollationStatement
	return p
}

func InitEmptyShowCollationStatementContext(p *ShowCollationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showCollationStatement
}

func (*ShowCollationStatementContext) IsShowCollationStatementContext() {}

func NewShowCollationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCollationStatementContext {
	var p = new(ShowCollationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showCollationStatement

	return p
}

func (s *ShowCollationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCollationStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowCollationStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowCollationStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowCollationStatementContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLLATION, 0)
}

func (s *ShowCollationStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *ShowCollationStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowCollationStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowCollationStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowCollationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCollationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCollationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowCollationStatement(s)
	}
}

func (s *ShowCollationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowCollationStatement(s)
	}
}

func (s *ShowCollationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowCollationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowCollationStatement() (localctx IShowCollationStatementContext) {
	localctx = NewShowCollationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, DorisSQLParserParserRULE_showCollationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4417)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4418)
		p.Match(DorisSQLParserParserCOLLATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4423)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserLIKE:
		{
			p.SetState(4419)
			p.Match(DorisSQLParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4420)

			var _x = p.String_()

			localctx.(*ShowCollationStatementContext).pattern = _x
		}

	case DorisSQLParserParserWHERE:
		{
			p.SetState(4421)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4422)
			p.expression(0)
		}

	case DorisSQLParserParserEOF, DorisSQLParserParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDeleteStatementContext is an interface to support dynamic dispatch.
type IShowDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowDeleteStatementContext differentiates from other interfaces.
	IsShowDeleteStatementContext()
}

type ShowDeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
}

func NewEmptyShowDeleteStatementContext() *ShowDeleteStatementContext {
	var p = new(ShowDeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showDeleteStatement
	return p
}

func InitEmptyShowDeleteStatementContext(p *ShowDeleteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showDeleteStatement
}

func (*ShowDeleteStatementContext) IsShowDeleteStatementContext() {}

func NewShowDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDeleteStatementContext {
	var p = new(ShowDeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showDeleteStatement

	return p
}

func (s *ShowDeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDeleteStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowDeleteStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowDeleteStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowDeleteStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDELETE, 0)
}

func (s *ShowDeleteStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowDeleteStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *ShowDeleteStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowDeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowDeleteStatement(s)
	}
}

func (s *ShowDeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowDeleteStatement(s)
	}
}

func (s *ShowDeleteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowDeleteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowDeleteStatement() (localctx IShowDeleteStatementContext) {
	localctx = NewShowDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, DorisSQLParserParserRULE_showDeleteStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4425)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4426)
		p.Match(DorisSQLParserParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4429)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN {
		{
			p.SetState(4427)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4428)

			var _x = p.QualifiedName()

			localctx.(*ShowDeleteStatementContext).db = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDynamicPartitionStatementContext is an interface to support dynamic dispatch.
type IShowDynamicPartitionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	DYNAMIC() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowDynamicPartitionStatementContext differentiates from other interfaces.
	IsShowDynamicPartitionStatementContext()
}

type ShowDynamicPartitionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
}

func NewEmptyShowDynamicPartitionStatementContext() *ShowDynamicPartitionStatementContext {
	var p = new(ShowDynamicPartitionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showDynamicPartitionStatement
	return p
}

func InitEmptyShowDynamicPartitionStatementContext(p *ShowDynamicPartitionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showDynamicPartitionStatement
}

func (*ShowDynamicPartitionStatementContext) IsShowDynamicPartitionStatementContext() {}

func NewShowDynamicPartitionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDynamicPartitionStatementContext {
	var p = new(ShowDynamicPartitionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showDynamicPartitionStatement

	return p
}

func (s *ShowDynamicPartitionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDynamicPartitionStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowDynamicPartitionStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowDynamicPartitionStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowDynamicPartitionStatementContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDYNAMIC, 0)
}

func (s *ShowDynamicPartitionStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPARTITION, 0)
}

func (s *ShowDynamicPartitionStatementContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLES, 0)
}

func (s *ShowDynamicPartitionStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowDynamicPartitionStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *ShowDynamicPartitionStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowDynamicPartitionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDynamicPartitionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDynamicPartitionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowDynamicPartitionStatement(s)
	}
}

func (s *ShowDynamicPartitionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowDynamicPartitionStatement(s)
	}
}

func (s *ShowDynamicPartitionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowDynamicPartitionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowDynamicPartitionStatement() (localctx IShowDynamicPartitionStatementContext) {
	localctx = NewShowDynamicPartitionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, DorisSQLParserParserRULE_showDynamicPartitionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4431)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4432)
		p.Match(DorisSQLParserParserDYNAMIC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4433)
		p.Match(DorisSQLParserParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4434)
		p.Match(DorisSQLParserParserTABLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4437)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN {
		{
			p.SetState(4435)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4436)

			var _x = p.QualifiedName()

			localctx.(*ShowDynamicPartitionStatementContext).db = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowEventsStatementContext is an interface to support dynamic dispatch.
type IShowEventsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	EVENTS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowEventsStatementContext differentiates from other interfaces.
	IsShowEventsStatementContext()
}

type ShowEventsStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowEventsStatementContext() *ShowEventsStatementContext {
	var p = new(ShowEventsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showEventsStatement
	return p
}

func InitEmptyShowEventsStatementContext(p *ShowEventsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showEventsStatement
}

func (*ShowEventsStatementContext) IsShowEventsStatementContext() {}

func NewShowEventsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowEventsStatementContext {
	var p = new(ShowEventsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showEventsStatement

	return p
}

func (s *ShowEventsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowEventsStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *ShowEventsStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowEventsStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *ShowEventsStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowEventsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowEventsStatementContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEVENTS, 0)
}

func (s *ShowEventsStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowEventsStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *ShowEventsStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowEventsStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *ShowEventsStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowEventsStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowEventsStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowEventsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowEventsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowEventsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowEventsStatement(s)
	}
}

func (s *ShowEventsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowEventsStatement(s)
	}
}

func (s *ShowEventsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowEventsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowEventsStatement() (localctx IShowEventsStatementContext) {
	localctx = NewShowEventsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, DorisSQLParserParserRULE_showEventsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4439)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4440)
		p.Match(DorisSQLParserParserEVENTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4443)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN {
		{
			p.SetState(4441)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4442)

			var _x = p.QualifiedName()

			localctx.(*ShowEventsStatementContext).catalog = _x
		}

	}
	p.SetState(4449)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserLIKE:
		{
			p.SetState(4445)
			p.Match(DorisSQLParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4446)

			var _x = p.String_()

			localctx.(*ShowEventsStatementContext).pattern = _x
		}

	case DorisSQLParserParserWHERE:
		{
			p.SetState(4447)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4448)
			p.expression(0)
		}

	case DorisSQLParserParserEOF, DorisSQLParserParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowEnginesStatementContext is an interface to support dynamic dispatch.
type IShowEnginesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	ENGINES() antlr.TerminalNode

	// IsShowEnginesStatementContext differentiates from other interfaces.
	IsShowEnginesStatementContext()
}

type ShowEnginesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowEnginesStatementContext() *ShowEnginesStatementContext {
	var p = new(ShowEnginesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showEnginesStatement
	return p
}

func InitEmptyShowEnginesStatementContext(p *ShowEnginesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showEnginesStatement
}

func (*ShowEnginesStatementContext) IsShowEnginesStatementContext() {}

func NewShowEnginesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowEnginesStatementContext {
	var p = new(ShowEnginesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showEnginesStatement

	return p
}

func (s *ShowEnginesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowEnginesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowEnginesStatementContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserENGINES, 0)
}

func (s *ShowEnginesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowEnginesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowEnginesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowEnginesStatement(s)
	}
}

func (s *ShowEnginesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowEnginesStatement(s)
	}
}

func (s *ShowEnginesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowEnginesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowEnginesStatement() (localctx IShowEnginesStatementContext) {
	localctx = NewShowEnginesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, DorisSQLParserParserRULE_showEnginesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4451)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4452)
		p.Match(DorisSQLParserParserENGINES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowFrontendsStatementContext is an interface to support dynamic dispatch.
type IShowFrontendsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	FRONTENDS() antlr.TerminalNode

	// IsShowFrontendsStatementContext differentiates from other interfaces.
	IsShowFrontendsStatementContext()
}

type ShowFrontendsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowFrontendsStatementContext() *ShowFrontendsStatementContext {
	var p = new(ShowFrontendsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showFrontendsStatement
	return p
}

func InitEmptyShowFrontendsStatementContext(p *ShowFrontendsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showFrontendsStatement
}

func (*ShowFrontendsStatementContext) IsShowFrontendsStatementContext() {}

func NewShowFrontendsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowFrontendsStatementContext {
	var p = new(ShowFrontendsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showFrontendsStatement

	return p
}

func (s *ShowFrontendsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowFrontendsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowFrontendsStatementContext) FRONTENDS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFRONTENDS, 0)
}

func (s *ShowFrontendsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFrontendsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowFrontendsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowFrontendsStatement(s)
	}
}

func (s *ShowFrontendsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowFrontendsStatement(s)
	}
}

func (s *ShowFrontendsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowFrontendsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowFrontendsStatement() (localctx IShowFrontendsStatementContext) {
	localctx = NewShowFrontendsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, DorisSQLParserParserRULE_showFrontendsStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4454)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4455)
		p.Match(DorisSQLParserParserFRONTENDS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowPluginsStatementContext is an interface to support dynamic dispatch.
type IShowPluginsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	PLUGINS() antlr.TerminalNode

	// IsShowPluginsStatementContext differentiates from other interfaces.
	IsShowPluginsStatementContext()
}

type ShowPluginsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowPluginsStatementContext() *ShowPluginsStatementContext {
	var p = new(ShowPluginsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showPluginsStatement
	return p
}

func InitEmptyShowPluginsStatementContext(p *ShowPluginsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showPluginsStatement
}

func (*ShowPluginsStatementContext) IsShowPluginsStatementContext() {}

func NewShowPluginsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowPluginsStatementContext {
	var p = new(ShowPluginsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showPluginsStatement

	return p
}

func (s *ShowPluginsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowPluginsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowPluginsStatementContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPLUGINS, 0)
}

func (s *ShowPluginsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPluginsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowPluginsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowPluginsStatement(s)
	}
}

func (s *ShowPluginsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowPluginsStatement(s)
	}
}

func (s *ShowPluginsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowPluginsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowPluginsStatement() (localctx IShowPluginsStatementContext) {
	localctx = NewShowPluginsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, DorisSQLParserParserRULE_showPluginsStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4457)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4458)
		p.Match(DorisSQLParserParserPLUGINS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowRepositoriesStatementContext is an interface to support dynamic dispatch.
type IShowRepositoriesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	REPOSITORIES() antlr.TerminalNode

	// IsShowRepositoriesStatementContext differentiates from other interfaces.
	IsShowRepositoriesStatementContext()
}

type ShowRepositoriesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowRepositoriesStatementContext() *ShowRepositoriesStatementContext {
	var p = new(ShowRepositoriesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showRepositoriesStatement
	return p
}

func InitEmptyShowRepositoriesStatementContext(p *ShowRepositoriesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showRepositoriesStatement
}

func (*ShowRepositoriesStatementContext) IsShowRepositoriesStatementContext() {}

func NewShowRepositoriesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRepositoriesStatementContext {
	var p = new(ShowRepositoriesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showRepositoriesStatement

	return p
}

func (s *ShowRepositoriesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRepositoriesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowRepositoriesStatementContext) REPOSITORIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPOSITORIES, 0)
}

func (s *ShowRepositoriesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRepositoriesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRepositoriesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowRepositoriesStatement(s)
	}
}

func (s *ShowRepositoriesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowRepositoriesStatement(s)
	}
}

func (s *ShowRepositoriesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowRepositoriesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowRepositoriesStatement() (localctx IShowRepositoriesStatementContext) {
	localctx = NewShowRepositoriesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, DorisSQLParserParserRULE_showRepositoriesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4460)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4461)
		p.Match(DorisSQLParserParserREPOSITORIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowOpenTableStatementContext is an interface to support dynamic dispatch.
type IShowOpenTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	TABLES() antlr.TerminalNode

	// IsShowOpenTableStatementContext differentiates from other interfaces.
	IsShowOpenTableStatementContext()
}

type ShowOpenTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowOpenTableStatementContext() *ShowOpenTableStatementContext {
	var p = new(ShowOpenTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showOpenTableStatement
	return p
}

func InitEmptyShowOpenTableStatementContext(p *ShowOpenTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showOpenTableStatement
}

func (*ShowOpenTableStatementContext) IsShowOpenTableStatementContext() {}

func NewShowOpenTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowOpenTableStatementContext {
	var p = new(ShowOpenTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showOpenTableStatement

	return p
}

func (s *ShowOpenTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowOpenTableStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowOpenTableStatementContext) OPEN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOPEN, 0)
}

func (s *ShowOpenTableStatementContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLES, 0)
}

func (s *ShowOpenTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowOpenTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowOpenTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowOpenTableStatement(s)
	}
}

func (s *ShowOpenTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowOpenTableStatement(s)
	}
}

func (s *ShowOpenTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowOpenTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowOpenTableStatement() (localctx IShowOpenTableStatementContext) {
	localctx = NewShowOpenTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, DorisSQLParserParserRULE_showOpenTableStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4463)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4464)
		p.Match(DorisSQLParserParserOPEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4465)
		p.Match(DorisSQLParserParserTABLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowPrivilegesStatementContext is an interface to support dynamic dispatch.
type IShowPrivilegesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode

	// IsShowPrivilegesStatementContext differentiates from other interfaces.
	IsShowPrivilegesStatementContext()
}

type ShowPrivilegesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowPrivilegesStatementContext() *ShowPrivilegesStatementContext {
	var p = new(ShowPrivilegesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showPrivilegesStatement
	return p
}

func InitEmptyShowPrivilegesStatementContext(p *ShowPrivilegesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showPrivilegesStatement
}

func (*ShowPrivilegesStatementContext) IsShowPrivilegesStatementContext() {}

func NewShowPrivilegesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowPrivilegesStatementContext {
	var p = new(ShowPrivilegesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showPrivilegesStatement

	return p
}

func (s *ShowPrivilegesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowPrivilegesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowPrivilegesStatementContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPRIVILEGES, 0)
}

func (s *ShowPrivilegesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPrivilegesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowPrivilegesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowPrivilegesStatement(s)
	}
}

func (s *ShowPrivilegesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowPrivilegesStatement(s)
	}
}

func (s *ShowPrivilegesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowPrivilegesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowPrivilegesStatement() (localctx IShowPrivilegesStatementContext) {
	localctx = NewShowPrivilegesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, DorisSQLParserParserRULE_showPrivilegesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4467)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4468)
		p.Match(DorisSQLParserParserPRIVILEGES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowProcedureStatementContext is an interface to support dynamic dispatch.
type IShowProcedureStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	String_() IStringContext
	Expression() IExpressionContext

	// IsShowProcedureStatementContext differentiates from other interfaces.
	IsShowProcedureStatementContext()
}

type ShowProcedureStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
	where   IExpressionContext
}

func NewEmptyShowProcedureStatementContext() *ShowProcedureStatementContext {
	var p = new(ShowProcedureStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showProcedureStatement
	return p
}

func InitEmptyShowProcedureStatementContext(p *ShowProcedureStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showProcedureStatement
}

func (*ShowProcedureStatementContext) IsShowProcedureStatementContext() {}

func NewShowProcedureStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowProcedureStatementContext {
	var p = new(ShowProcedureStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showProcedureStatement

	return p
}

func (s *ShowProcedureStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowProcedureStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowProcedureStatementContext) GetWhere() IExpressionContext { return s.where }

func (s *ShowProcedureStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowProcedureStatementContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *ShowProcedureStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowProcedureStatementContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTATUS, 0)
}

func (s *ShowProcedureStatementContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROCEDURE, 0)
}

func (s *ShowProcedureStatementContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFUNCTION, 0)
}

func (s *ShowProcedureStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *ShowProcedureStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowProcedureStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowProcedureStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowProcedureStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProcedureStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowProcedureStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowProcedureStatement(s)
	}
}

func (s *ShowProcedureStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowProcedureStatement(s)
	}
}

func (s *ShowProcedureStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowProcedureStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowProcedureStatement() (localctx IShowProcedureStatementContext) {
	localctx = NewShowProcedureStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, DorisSQLParserParserRULE_showProcedureStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4470)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4471)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserFUNCTION || _la == DorisSQLParserParserPROCEDURE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4472)
		p.Match(DorisSQLParserParserSTATUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4477)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserLIKE:
		{
			p.SetState(4473)
			p.Match(DorisSQLParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4474)

			var _x = p.String_()

			localctx.(*ShowProcedureStatementContext).pattern = _x
		}

	case DorisSQLParserParserWHERE:
		{
			p.SetState(4475)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4476)

			var _x = p.expression(0)

			localctx.(*ShowProcedureStatementContext).where = _x
		}

	case DorisSQLParserParserEOF, DorisSQLParserParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowProcStatementContext is an interface to support dynamic dispatch.
type IShowProcStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPath returns the path rule contexts.
	GetPath() IStringContext

	// SetPath sets the path rule contexts.
	SetPath(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	PROC() antlr.TerminalNode
	String_() IStringContext

	// IsShowProcStatementContext differentiates from other interfaces.
	IsShowProcStatementContext()
}

type ShowProcStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	path   IStringContext
}

func NewEmptyShowProcStatementContext() *ShowProcStatementContext {
	var p = new(ShowProcStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showProcStatement
	return p
}

func InitEmptyShowProcStatementContext(p *ShowProcStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showProcStatement
}

func (*ShowProcStatementContext) IsShowProcStatementContext() {}

func NewShowProcStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowProcStatementContext {
	var p = new(ShowProcStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showProcStatement

	return p
}

func (s *ShowProcStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowProcStatementContext) GetPath() IStringContext { return s.path }

func (s *ShowProcStatementContext) SetPath(v IStringContext) { s.path = v }

func (s *ShowProcStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowProcStatementContext) PROC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROC, 0)
}

func (s *ShowProcStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowProcStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProcStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowProcStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowProcStatement(s)
	}
}

func (s *ShowProcStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowProcStatement(s)
	}
}

func (s *ShowProcStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowProcStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowProcStatement() (localctx IShowProcStatementContext) {
	localctx = NewShowProcStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, DorisSQLParserParserRULE_showProcStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4479)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4480)
		p.Match(DorisSQLParserParserPROC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4481)

		var _x = p.String_()

		localctx.(*ShowProcStatementContext).path = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowProcesslistStatementContext is an interface to support dynamic dispatch.
type IShowProcesslistStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	PROCESSLIST() antlr.TerminalNode
	FULL() antlr.TerminalNode
	FOR() antlr.TerminalNode
	String_() IStringContext

	// IsShowProcesslistStatementContext differentiates from other interfaces.
	IsShowProcesslistStatementContext()
}

type ShowProcesslistStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowProcesslistStatementContext() *ShowProcesslistStatementContext {
	var p = new(ShowProcesslistStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showProcesslistStatement
	return p
}

func InitEmptyShowProcesslistStatementContext(p *ShowProcesslistStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showProcesslistStatement
}

func (*ShowProcesslistStatementContext) IsShowProcesslistStatementContext() {}

func NewShowProcesslistStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowProcesslistStatementContext {
	var p = new(ShowProcesslistStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showProcesslistStatement

	return p
}

func (s *ShowProcesslistStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowProcesslistStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowProcesslistStatementContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROCESSLIST, 0)
}

func (s *ShowProcesslistStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFULL, 0)
}

func (s *ShowProcesslistStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFOR, 0)
}

func (s *ShowProcesslistStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowProcesslistStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProcesslistStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowProcesslistStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowProcesslistStatement(s)
	}
}

func (s *ShowProcesslistStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowProcesslistStatement(s)
	}
}

func (s *ShowProcesslistStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowProcesslistStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowProcesslistStatement() (localctx IShowProcesslistStatementContext) {
	localctx = NewShowProcesslistStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, DorisSQLParserParserRULE_showProcesslistStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4483)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4485)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFULL {
		{
			p.SetState(4484)
			p.Match(DorisSQLParserParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4487)
		p.Match(DorisSQLParserParserPROCESSLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4490)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFOR {
		{
			p.SetState(4488)
			p.Match(DorisSQLParserParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4489)
			p.String_()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowProfilelistStatementContext is an interface to support dynamic dispatch.
type IShowProfilelistStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// Getter signatures
	SHOW() antlr.TerminalNode
	PROFILELIST() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsShowProfilelistStatementContext differentiates from other interfaces.
	IsShowProfilelistStatementContext()
}

type ShowProfilelistStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	limit  antlr.Token
}

func NewEmptyShowProfilelistStatementContext() *ShowProfilelistStatementContext {
	var p = new(ShowProfilelistStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showProfilelistStatement
	return p
}

func InitEmptyShowProfilelistStatementContext(p *ShowProfilelistStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showProfilelistStatement
}

func (*ShowProfilelistStatementContext) IsShowProfilelistStatementContext() {}

func NewShowProfilelistStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowProfilelistStatementContext {
	var p = new(ShowProfilelistStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showProfilelistStatement

	return p
}

func (s *ShowProfilelistStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowProfilelistStatementContext) GetLimit() antlr.Token { return s.limit }

func (s *ShowProfilelistStatementContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *ShowProfilelistStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowProfilelistStatementContext) PROFILELIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROFILELIST, 0)
}

func (s *ShowProfilelistStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIMIT, 0)
}

func (s *ShowProfilelistStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, 0)
}

func (s *ShowProfilelistStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProfilelistStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowProfilelistStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowProfilelistStatement(s)
	}
}

func (s *ShowProfilelistStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowProfilelistStatement(s)
	}
}

func (s *ShowProfilelistStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowProfilelistStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowProfilelistStatement() (localctx IShowProfilelistStatementContext) {
	localctx = NewShowProfilelistStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, DorisSQLParserParserRULE_showProfilelistStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4492)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4493)
		p.Match(DorisSQLParserParserPROFILELIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4496)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserLIMIT {
		{
			p.SetState(4494)
			p.Match(DorisSQLParserParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4495)

			var _m = p.Match(DorisSQLParserParserINTEGER_VALUE)

			localctx.(*ShowProfilelistStatementContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowRunningQueriesStatementContext is an interface to support dynamic dispatch.
type IShowRunningQueriesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// Getter signatures
	SHOW() antlr.TerminalNode
	RUNNING() antlr.TerminalNode
	QUERIES() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsShowRunningQueriesStatementContext differentiates from other interfaces.
	IsShowRunningQueriesStatementContext()
}

type ShowRunningQueriesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	limit  antlr.Token
}

func NewEmptyShowRunningQueriesStatementContext() *ShowRunningQueriesStatementContext {
	var p = new(ShowRunningQueriesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showRunningQueriesStatement
	return p
}

func InitEmptyShowRunningQueriesStatementContext(p *ShowRunningQueriesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showRunningQueriesStatement
}

func (*ShowRunningQueriesStatementContext) IsShowRunningQueriesStatementContext() {}

func NewShowRunningQueriesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRunningQueriesStatementContext {
	var p = new(ShowRunningQueriesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showRunningQueriesStatement

	return p
}

func (s *ShowRunningQueriesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRunningQueriesStatementContext) GetLimit() antlr.Token { return s.limit }

func (s *ShowRunningQueriesStatementContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *ShowRunningQueriesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowRunningQueriesStatementContext) RUNNING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRUNNING, 0)
}

func (s *ShowRunningQueriesStatementContext) QUERIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserQUERIES, 0)
}

func (s *ShowRunningQueriesStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIMIT, 0)
}

func (s *ShowRunningQueriesStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, 0)
}

func (s *ShowRunningQueriesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRunningQueriesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRunningQueriesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowRunningQueriesStatement(s)
	}
}

func (s *ShowRunningQueriesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowRunningQueriesStatement(s)
	}
}

func (s *ShowRunningQueriesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowRunningQueriesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowRunningQueriesStatement() (localctx IShowRunningQueriesStatementContext) {
	localctx = NewShowRunningQueriesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, DorisSQLParserParserRULE_showRunningQueriesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4498)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4499)
		p.Match(DorisSQLParserParserRUNNING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4500)
		p.Match(DorisSQLParserParserQUERIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4503)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserLIMIT {
		{
			p.SetState(4501)
			p.Match(DorisSQLParserParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4502)

			var _m = p.Match(DorisSQLParserParserINTEGER_VALUE)

			localctx.(*ShowRunningQueriesStatementContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowStatusStatementContext is an interface to support dynamic dispatch.
type IShowStatusStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	VarType() IVarTypeContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowStatusStatementContext differentiates from other interfaces.
	IsShowStatusStatementContext()
}

type ShowStatusStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowStatusStatementContext() *ShowStatusStatementContext {
	var p = new(ShowStatusStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showStatusStatement
	return p
}

func InitEmptyShowStatusStatementContext(p *ShowStatusStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showStatusStatement
}

func (*ShowStatusStatementContext) IsShowStatusStatementContext() {}

func NewShowStatusStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStatusStatementContext {
	var p = new(ShowStatusStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showStatusStatement

	return p
}

func (s *ShowStatusStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStatusStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowStatusStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowStatusStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowStatusStatementContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTATUS, 0)
}

func (s *ShowStatusStatementContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *ShowStatusStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *ShowStatusStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowStatusStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowStatusStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowStatusStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatusStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowStatusStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowStatusStatement(s)
	}
}

func (s *ShowStatusStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowStatusStatement(s)
	}
}

func (s *ShowStatusStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowStatusStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowStatusStatement() (localctx IShowStatusStatementContext) {
	localctx = NewShowStatusStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, DorisSQLParserParserRULE_showStatusStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4505)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4507)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserGLOBAL || _la == DorisSQLParserParserLOCAL || _la == DorisSQLParserParserSESSION || _la == DorisSQLParserParserVERBOSE {
		{
			p.SetState(4506)
			p.VarType()
		}

	}
	{
		p.SetState(4509)
		p.Match(DorisSQLParserParserSTATUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4514)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserLIKE:
		{
			p.SetState(4510)
			p.Match(DorisSQLParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4511)

			var _x = p.String_()

			localctx.(*ShowStatusStatementContext).pattern = _x
		}

	case DorisSQLParserParserWHERE:
		{
			p.SetState(4512)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4513)
			p.expression(0)
		}

	case DorisSQLParserParserEOF, DorisSQLParserParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowTabletStatementContext is an interface to support dynamic dispatch.
type IShowTabletStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	TABLET() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	TABLETS() antlr.TerminalNode
	PartitionNames() IPartitionNamesContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext

	// IsShowTabletStatementContext differentiates from other interfaces.
	IsShowTabletStatementContext()
}

type ShowTabletStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowTabletStatementContext() *ShowTabletStatementContext {
	var p = new(ShowTabletStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showTabletStatement
	return p
}

func InitEmptyShowTabletStatementContext(p *ShowTabletStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showTabletStatement
}

func (*ShowTabletStatementContext) IsShowTabletStatementContext() {}

func NewShowTabletStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTabletStatementContext {
	var p = new(ShowTabletStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showTabletStatement

	return p
}

func (s *ShowTabletStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTabletStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowTabletStatementContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLET, 0)
}

func (s *ShowTabletStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, 0)
}

func (s *ShowTabletStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowTabletStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTabletStatementContext) TABLETS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLETS, 0)
}

func (s *ShowTabletStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *ShowTabletStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowTabletStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowTabletStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserORDER, 0)
}

func (s *ShowTabletStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *ShowTabletStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowTabletStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowTabletStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowTabletStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTabletStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowTabletStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowTabletStatement(s)
	}
}

func (s *ShowTabletStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowTabletStatement(s)
	}
}

func (s *ShowTabletStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowTabletStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowTabletStatement() (localctx IShowTabletStatementContext) {
	localctx = NewShowTabletStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, DorisSQLParserParserRULE_showTabletStatement)
	var _la int

	p.SetState(4545)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 481, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4516)
			p.Match(DorisSQLParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4517)
			p.Match(DorisSQLParserParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4518)
			p.Match(DorisSQLParserParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4519)
			p.Match(DorisSQLParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4520)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserTABLET || _la == DorisSQLParserParserTABLETS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4521)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4522)
			p.QualifiedName()
		}
		p.SetState(4524)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserPARTITION || _la == DorisSQLParserParserPARTITIONS || _la == DorisSQLParserParserTEMPORARY {
			{
				p.SetState(4523)
				p.PartitionNames()
			}

		}
		p.SetState(4528)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserWHERE {
			{
				p.SetState(4526)
				p.Match(DorisSQLParserParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4527)
				p.expression(0)
			}

		}
		p.SetState(4540)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserORDER {
			{
				p.SetState(4530)
				p.Match(DorisSQLParserParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4531)
				p.Match(DorisSQLParserParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4532)
				p.SortItem()
			}
			p.SetState(4537)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(4533)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4534)
					p.SortItem()
				}

				p.SetState(4539)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(4543)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserLIMIT {
			{
				p.SetState(4542)
				p.LimitElement()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowTransactionStatementContext is an interface to support dynamic dispatch.
type IShowTransactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowTransactionStatementContext differentiates from other interfaces.
	IsShowTransactionStatementContext()
}

type ShowTransactionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
}

func NewEmptyShowTransactionStatementContext() *ShowTransactionStatementContext {
	var p = new(ShowTransactionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showTransactionStatement
	return p
}

func InitEmptyShowTransactionStatementContext(p *ShowTransactionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showTransactionStatement
}

func (*ShowTransactionStatementContext) IsShowTransactionStatementContext() {}

func NewShowTransactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTransactionStatementContext {
	var p = new(ShowTransactionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showTransactionStatement

	return p
}

func (s *ShowTransactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTransactionStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowTransactionStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowTransactionStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowTransactionStatementContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTRANSACTION, 0)
}

func (s *ShowTransactionStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowTransactionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowTransactionStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowTransactionStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *ShowTransactionStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTransactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTransactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowTransactionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowTransactionStatement(s)
	}
}

func (s *ShowTransactionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowTransactionStatement(s)
	}
}

func (s *ShowTransactionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowTransactionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowTransactionStatement() (localctx IShowTransactionStatementContext) {
	localctx = NewShowTransactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, DorisSQLParserParserRULE_showTransactionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4547)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4548)
		p.Match(DorisSQLParserParserTRANSACTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4551)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN {
		{
			p.SetState(4549)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4550)

			var _x = p.QualifiedName()

			localctx.(*ShowTransactionStatementContext).db = _x
		}

	}
	p.SetState(4555)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWHERE {
		{
			p.SetState(4553)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4554)
			p.expression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowTriggersStatementContext is an interface to support dynamic dispatch.
type IShowTriggersStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	TRIGGERS() antlr.TerminalNode
	FULL() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowTriggersStatementContext differentiates from other interfaces.
	IsShowTriggersStatementContext()
}

type ShowTriggersStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowTriggersStatementContext() *ShowTriggersStatementContext {
	var p = new(ShowTriggersStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showTriggersStatement
	return p
}

func InitEmptyShowTriggersStatementContext(p *ShowTriggersStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showTriggersStatement
}

func (*ShowTriggersStatementContext) IsShowTriggersStatementContext() {}

func NewShowTriggersStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTriggersStatementContext {
	var p = new(ShowTriggersStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showTriggersStatement

	return p
}

func (s *ShowTriggersStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTriggersStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *ShowTriggersStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowTriggersStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *ShowTriggersStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowTriggersStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowTriggersStatementContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTRIGGERS, 0)
}

func (s *ShowTriggersStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFULL, 0)
}

func (s *ShowTriggersStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowTriggersStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *ShowTriggersStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTriggersStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *ShowTriggersStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowTriggersStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowTriggersStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowTriggersStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTriggersStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowTriggersStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowTriggersStatement(s)
	}
}

func (s *ShowTriggersStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowTriggersStatement(s)
	}
}

func (s *ShowTriggersStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowTriggersStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowTriggersStatement() (localctx IShowTriggersStatementContext) {
	localctx = NewShowTriggersStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, DorisSQLParserParserRULE_showTriggersStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4557)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4559)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFULL {
		{
			p.SetState(4558)
			p.Match(DorisSQLParserParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4561)
		p.Match(DorisSQLParserParserTRIGGERS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4564)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN {
		{
			p.SetState(4562)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4563)

			var _x = p.QualifiedName()

			localctx.(*ShowTriggersStatementContext).catalog = _x
		}

	}
	p.SetState(4570)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserLIKE:
		{
			p.SetState(4566)
			p.Match(DorisSQLParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4567)

			var _x = p.String_()

			localctx.(*ShowTriggersStatementContext).pattern = _x
		}

	case DorisSQLParserParserWHERE:
		{
			p.SetState(4568)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4569)
			p.expression(0)
		}

	case DorisSQLParserParserEOF, DorisSQLParserParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowUserPropertyStatementContext is an interface to support dynamic dispatch.
type IShowUserPropertyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode
	FOR() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	LIKE() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode

	// IsShowUserPropertyStatementContext differentiates from other interfaces.
	IsShowUserPropertyStatementContext()
}

type ShowUserPropertyStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowUserPropertyStatementContext() *ShowUserPropertyStatementContext {
	var p = new(ShowUserPropertyStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showUserPropertyStatement
	return p
}

func InitEmptyShowUserPropertyStatementContext(p *ShowUserPropertyStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showUserPropertyStatement
}

func (*ShowUserPropertyStatementContext) IsShowUserPropertyStatementContext() {}

func NewShowUserPropertyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowUserPropertyStatementContext {
	var p = new(ShowUserPropertyStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showUserPropertyStatement

	return p
}

func (s *ShowUserPropertyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowUserPropertyStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowUserPropertyStatementContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROPERTY, 0)
}

func (s *ShowUserPropertyStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFOR, 0)
}

func (s *ShowUserPropertyStatementContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ShowUserPropertyStatementContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowUserPropertyStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *ShowUserPropertyStatementContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROPERTIES, 0)
}

func (s *ShowUserPropertyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowUserPropertyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowUserPropertyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowUserPropertyStatement(s)
	}
}

func (s *ShowUserPropertyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowUserPropertyStatement(s)
	}
}

func (s *ShowUserPropertyStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowUserPropertyStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowUserPropertyStatement() (localctx IShowUserPropertyStatementContext) {
	localctx = NewShowUserPropertyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, DorisSQLParserParserRULE_showUserPropertyStatement)
	var _la int

	p.SetState(4592)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 491, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4572)
			p.Match(DorisSQLParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4573)
			p.Match(DorisSQLParserParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4576)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserFOR {
			{
				p.SetState(4574)
				p.Match(DorisSQLParserParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4575)
				p.String_()
			}

		}
		p.SetState(4580)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserLIKE {
			{
				p.SetState(4578)
				p.Match(DorisSQLParserParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4579)
				p.String_()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4582)
			p.Match(DorisSQLParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4583)
			p.Match(DorisSQLParserParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4586)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserFOR {
			{
				p.SetState(4584)
				p.Match(DorisSQLParserParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4585)
				p.String_()
			}

		}
		p.SetState(4590)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserLIKE {
			{
				p.SetState(4588)
				p.Match(DorisSQLParserParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4589)
				p.String_()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowVariablesStatementContext is an interface to support dynamic dispatch.
type IShowVariablesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	VARIABLES() antlr.TerminalNode
	VarType() IVarTypeContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowVariablesStatementContext differentiates from other interfaces.
	IsShowVariablesStatementContext()
}

type ShowVariablesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowVariablesStatementContext() *ShowVariablesStatementContext {
	var p = new(ShowVariablesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showVariablesStatement
	return p
}

func InitEmptyShowVariablesStatementContext(p *ShowVariablesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showVariablesStatement
}

func (*ShowVariablesStatementContext) IsShowVariablesStatementContext() {}

func NewShowVariablesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowVariablesStatementContext {
	var p = new(ShowVariablesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showVariablesStatement

	return p
}

func (s *ShowVariablesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowVariablesStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowVariablesStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowVariablesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowVariablesStatementContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVARIABLES, 0)
}

func (s *ShowVariablesStatementContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *ShowVariablesStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *ShowVariablesStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowVariablesStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowVariablesStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowVariablesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowVariablesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowVariablesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowVariablesStatement(s)
	}
}

func (s *ShowVariablesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowVariablesStatement(s)
	}
}

func (s *ShowVariablesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowVariablesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowVariablesStatement() (localctx IShowVariablesStatementContext) {
	localctx = NewShowVariablesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, DorisSQLParserParserRULE_showVariablesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4594)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4596)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserGLOBAL || _la == DorisSQLParserParserLOCAL || _la == DorisSQLParserParserSESSION || _la == DorisSQLParserParserVERBOSE {
		{
			p.SetState(4595)
			p.VarType()
		}

	}
	{
		p.SetState(4598)
		p.Match(DorisSQLParserParserVARIABLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4603)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserLIKE:
		{
			p.SetState(4599)
			p.Match(DorisSQLParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4600)

			var _x = p.String_()

			localctx.(*ShowVariablesStatementContext).pattern = _x
		}

	case DorisSQLParserParserWHERE:
		{
			p.SetState(4601)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4602)
			p.expression(0)
		}

	case DorisSQLParserParserEOF, DorisSQLParserParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowWarningStatementContext is an interface to support dynamic dispatch.
type IShowWarningStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	WARNINGS() antlr.TerminalNode
	ERRORS() antlr.TerminalNode
	LimitElement() ILimitElementContext

	// IsShowWarningStatementContext differentiates from other interfaces.
	IsShowWarningStatementContext()
}

type ShowWarningStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowWarningStatementContext() *ShowWarningStatementContext {
	var p = new(ShowWarningStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showWarningStatement
	return p
}

func InitEmptyShowWarningStatementContext(p *ShowWarningStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showWarningStatement
}

func (*ShowWarningStatementContext) IsShowWarningStatementContext() {}

func NewShowWarningStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowWarningStatementContext {
	var p = new(ShowWarningStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showWarningStatement

	return p
}

func (s *ShowWarningStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowWarningStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowWarningStatementContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWARNINGS, 0)
}

func (s *ShowWarningStatementContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserERRORS, 0)
}

func (s *ShowWarningStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowWarningStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWarningStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowWarningStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowWarningStatement(s)
	}
}

func (s *ShowWarningStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowWarningStatement(s)
	}
}

func (s *ShowWarningStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowWarningStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowWarningStatement() (localctx IShowWarningStatementContext) {
	localctx = NewShowWarningStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, DorisSQLParserParserRULE_showWarningStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4605)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4606)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserERRORS || _la == DorisSQLParserParserWARNINGS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(4608)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserLIMIT {
		{
			p.SetState(4607)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHelpStatementContext is an interface to support dynamic dispatch.
type IHelpStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HELP() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsHelpStatementContext differentiates from other interfaces.
	IsHelpStatementContext()
}

type HelpStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelpStatementContext() *HelpStatementContext {
	var p = new(HelpStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_helpStatement
	return p
}

func InitEmptyHelpStatementContext(p *HelpStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_helpStatement
}

func (*HelpStatementContext) IsHelpStatementContext() {}

func NewHelpStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelpStatementContext {
	var p = new(HelpStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_helpStatement

	return p
}

func (s *HelpStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HelpStatementContext) HELP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserHELP, 0)
}

func (s *HelpStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *HelpStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelpStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelpStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterHelpStatement(s)
	}
}

func (s *HelpStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitHelpStatement(s)
	}
}

func (s *HelpStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitHelpStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) HelpStatement() (localctx IHelpStatementContext) {
	localctx = NewHelpStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, DorisSQLParserParserRULE_helpStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4610)
		p.Match(DorisSQLParserParserHELP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4611)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateUserStatementContext is an interface to support dynamic dispatch.
type ICreateUserStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	USER() antlr.TerminalNode
	User() IUserContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AuthOption() IAuthOptionContext
	DEFAULT() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	RoleList() IRoleListContext
	Properties() IPropertiesContext

	// IsCreateUserStatementContext differentiates from other interfaces.
	IsCreateUserStatementContext()
}

type CreateUserStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateUserStatementContext() *CreateUserStatementContext {
	var p = new(CreateUserStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createUserStatement
	return p
}

func InitEmptyCreateUserStatementContext(p *CreateUserStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createUserStatement
}

func (*CreateUserStatementContext) IsCreateUserStatementContext() {}

func NewCreateUserStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUserStatementContext {
	var p = new(CreateUserStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createUserStatement

	return p
}

func (s *CreateUserStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUserStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateUserStatementContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSER, 0)
}

func (s *CreateUserStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *CreateUserStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *CreateUserStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *CreateUserStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *CreateUserStatementContext) AuthOption() IAuthOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthOptionContext)
}

func (s *CreateUserStatementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDEFAULT, 0)
}

func (s *CreateUserStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROLE, 0)
}

func (s *CreateUserStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *CreateUserStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateUserStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateUserStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateUserStatement(s)
	}
}

func (s *CreateUserStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateUserStatement(s)
	}
}

func (s *CreateUserStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateUserStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateUserStatement() (localctx ICreateUserStatementContext) {
	localctx = NewCreateUserStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, DorisSQLParserParserRULE_createUserStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4613)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4614)
		p.Match(DorisSQLParserParserUSER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4618)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(4615)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4616)
			p.Match(DorisSQLParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4617)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4620)
		p.User()
	}
	p.SetState(4622)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIDENTIFIED {
		{
			p.SetState(4621)
			p.AuthOption()
		}

	}
	p.SetState(4627)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserDEFAULT {
		{
			p.SetState(4624)
			p.Match(DorisSQLParserParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4625)
			p.Match(DorisSQLParserParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4626)
			p.RoleList()
		}

	}
	p.SetState(4630)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(4629)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropUserStatementContext is an interface to support dynamic dispatch.
type IDropUserStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	USER() antlr.TerminalNode
	User() IUserContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropUserStatementContext differentiates from other interfaces.
	IsDropUserStatementContext()
}

type DropUserStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropUserStatementContext() *DropUserStatementContext {
	var p = new(DropUserStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropUserStatement
	return p
}

func InitEmptyDropUserStatementContext(p *DropUserStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropUserStatement
}

func (*DropUserStatementContext) IsDropUserStatementContext() {}

func NewDropUserStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropUserStatementContext {
	var p = new(DropUserStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropUserStatement

	return p
}

func (s *DropUserStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropUserStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropUserStatementContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSER, 0)
}

func (s *DropUserStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *DropUserStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *DropUserStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *DropUserStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropUserStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropUserStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropUserStatement(s)
	}
}

func (s *DropUserStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropUserStatement(s)
	}
}

func (s *DropUserStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropUserStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropUserStatement() (localctx IDropUserStatementContext) {
	localctx = NewDropUserStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, DorisSQLParserParserRULE_dropUserStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4632)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4633)
		p.Match(DorisSQLParserParserUSER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4636)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(4634)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4635)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4638)
		p.User()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterUserStatementContext is an interface to support dynamic dispatch.
type IAlterUserStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	USER() antlr.TerminalNode
	User() IUserContext
	AuthOption() IAuthOptionContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	NONE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	RoleList() IRoleListContext
	SET() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsAlterUserStatementContext differentiates from other interfaces.
	IsAlterUserStatementContext()
}

type AlterUserStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterUserStatementContext() *AlterUserStatementContext {
	var p = new(AlterUserStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterUserStatement
	return p
}

func InitEmptyAlterUserStatementContext(p *AlterUserStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterUserStatement
}

func (*AlterUserStatementContext) IsAlterUserStatementContext() {}

func NewAlterUserStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterUserStatementContext {
	var p = new(AlterUserStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_alterUserStatement

	return p
}

func (s *AlterUserStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterUserStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *AlterUserStatementContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSER, 0)
}

func (s *AlterUserStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *AlterUserStatementContext) AuthOption() IAuthOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthOptionContext)
}

func (s *AlterUserStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *AlterUserStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *AlterUserStatementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDEFAULT, 0)
}

func (s *AlterUserStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROLE, 0)
}

func (s *AlterUserStatementContext) NONE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNONE, 0)
}

func (s *AlterUserStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, 0)
}

func (s *AlterUserStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *AlterUserStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *AlterUserStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AlterUserStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterUserStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAlterUserStatement(s)
	}
}

func (s *AlterUserStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAlterUserStatement(s)
	}
}

func (s *AlterUserStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAlterUserStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AlterUserStatement() (localctx IAlterUserStatementContext) {
	localctx = NewAlterUserStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, DorisSQLParserParserRULE_alterUserStatement)
	var _la int

	p.SetState(4673)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 504, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4640)
			p.Match(DorisSQLParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4641)
			p.Match(DorisSQLParserParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4644)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserIF {
			{
				p.SetState(4642)
				p.Match(DorisSQLParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4643)
				p.Match(DorisSQLParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4646)
			p.User()
		}
		{
			p.SetState(4647)
			p.AuthOption()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4649)
			p.Match(DorisSQLParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4650)
			p.Match(DorisSQLParserParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4653)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserIF {
			{
				p.SetState(4651)
				p.Match(DorisSQLParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4652)
				p.Match(DorisSQLParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4655)
			p.User()
		}
		{
			p.SetState(4656)
			p.Match(DorisSQLParserParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4657)
			p.Match(DorisSQLParserParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4661)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 502, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4658)
				p.Match(DorisSQLParserParserNONE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(4659)
				p.Match(DorisSQLParserParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(4660)
				p.RoleList()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4663)
			p.Match(DorisSQLParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4664)
			p.Match(DorisSQLParserParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4667)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserIF {
			{
				p.SetState(4665)
				p.Match(DorisSQLParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4666)
				p.Match(DorisSQLParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4669)
			p.User()
		}
		{
			p.SetState(4670)
			p.Match(DorisSQLParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4671)
			p.Properties()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowUserStatementContext is an interface to support dynamic dispatch.
type IShowUserStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	USER() antlr.TerminalNode
	USERS() antlr.TerminalNode

	// IsShowUserStatementContext differentiates from other interfaces.
	IsShowUserStatementContext()
}

type ShowUserStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowUserStatementContext() *ShowUserStatementContext {
	var p = new(ShowUserStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showUserStatement
	return p
}

func InitEmptyShowUserStatementContext(p *ShowUserStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showUserStatement
}

func (*ShowUserStatementContext) IsShowUserStatementContext() {}

func NewShowUserStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowUserStatementContext {
	var p = new(ShowUserStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showUserStatement

	return p
}

func (s *ShowUserStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowUserStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowUserStatementContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSER, 0)
}

func (s *ShowUserStatementContext) USERS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSERS, 0)
}

func (s *ShowUserStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowUserStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowUserStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowUserStatement(s)
	}
}

func (s *ShowUserStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowUserStatement(s)
	}
}

func (s *ShowUserStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowUserStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowUserStatement() (localctx IShowUserStatementContext) {
	localctx = NewShowUserStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, DorisSQLParserParserRULE_showUserStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4675)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4676)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserUSER || _la == DorisSQLParserParserUSERS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowAuthenticationStatementContext is an interface to support dynamic dispatch.
type IShowAuthenticationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsShowAuthenticationStatementContext differentiates from other interfaces.
	IsShowAuthenticationStatementContext()
}

type ShowAuthenticationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowAuthenticationStatementContext() *ShowAuthenticationStatementContext {
	var p = new(ShowAuthenticationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showAuthenticationStatement
	return p
}

func InitEmptyShowAuthenticationStatementContext(p *ShowAuthenticationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showAuthenticationStatement
}

func (*ShowAuthenticationStatementContext) IsShowAuthenticationStatementContext() {}

func NewShowAuthenticationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowAuthenticationStatementContext {
	var p = new(ShowAuthenticationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showAuthenticationStatement

	return p
}

func (s *ShowAuthenticationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowAuthenticationStatementContext) CopyAll(ctx *ShowAuthenticationStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ShowAuthenticationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAuthenticationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowAllAuthenticationContext struct {
	ShowAuthenticationStatementContext
}

func NewShowAllAuthenticationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAllAuthenticationContext {
	var p = new(ShowAllAuthenticationContext)

	InitEmptyShowAuthenticationStatementContext(&p.ShowAuthenticationStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowAuthenticationStatementContext))

	return p
}

func (s *ShowAllAuthenticationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAllAuthenticationContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowAllAuthenticationContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, 0)
}

func (s *ShowAllAuthenticationContext) AUTHENTICATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAUTHENTICATION, 0)
}

func (s *ShowAllAuthenticationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowAllAuthentication(s)
	}
}

func (s *ShowAllAuthenticationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowAllAuthentication(s)
	}
}

func (s *ShowAllAuthenticationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowAllAuthentication(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowAuthenticationForUserContext struct {
	ShowAuthenticationStatementContext
}

func NewShowAuthenticationForUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAuthenticationForUserContext {
	var p = new(ShowAuthenticationForUserContext)

	InitEmptyShowAuthenticationStatementContext(&p.ShowAuthenticationStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowAuthenticationStatementContext))

	return p
}

func (s *ShowAuthenticationForUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAuthenticationForUserContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowAuthenticationForUserContext) AUTHENTICATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAUTHENTICATION, 0)
}

func (s *ShowAuthenticationForUserContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFOR, 0)
}

func (s *ShowAuthenticationForUserContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *ShowAuthenticationForUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowAuthenticationForUser(s)
	}
}

func (s *ShowAuthenticationForUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowAuthenticationForUser(s)
	}
}

func (s *ShowAuthenticationForUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowAuthenticationForUser(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowAuthenticationStatement() (localctx IShowAuthenticationStatementContext) {
	localctx = NewShowAuthenticationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, DorisSQLParserParserRULE_showAuthenticationStatement)
	var _la int

	p.SetState(4687)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 506, p.GetParserRuleContext()) {
	case 1:
		localctx = NewShowAllAuthenticationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4678)
			p.Match(DorisSQLParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4679)
			p.Match(DorisSQLParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4680)
			p.Match(DorisSQLParserParserAUTHENTICATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewShowAuthenticationForUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4681)
			p.Match(DorisSQLParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4682)
			p.Match(DorisSQLParserParserAUTHENTICATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4685)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserFOR {
			{
				p.SetState(4683)
				p.Match(DorisSQLParserParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4684)
				p.User()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExecuteAsStatementContext is an interface to support dynamic dispatch.
type IExecuteAsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXECUTE() antlr.TerminalNode
	AS() antlr.TerminalNode
	User() IUserContext
	WITH() antlr.TerminalNode
	NO() antlr.TerminalNode
	REVERT() antlr.TerminalNode

	// IsExecuteAsStatementContext differentiates from other interfaces.
	IsExecuteAsStatementContext()
}

type ExecuteAsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteAsStatementContext() *ExecuteAsStatementContext {
	var p = new(ExecuteAsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_executeAsStatement
	return p
}

func InitEmptyExecuteAsStatementContext(p *ExecuteAsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_executeAsStatement
}

func (*ExecuteAsStatementContext) IsExecuteAsStatementContext() {}

func NewExecuteAsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteAsStatementContext {
	var p = new(ExecuteAsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_executeAsStatement

	return p
}

func (s *ExecuteAsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteAsStatementContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXECUTE, 0)
}

func (s *ExecuteAsStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *ExecuteAsStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *ExecuteAsStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *ExecuteAsStatementContext) NO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNO, 0)
}

func (s *ExecuteAsStatementContext) REVERT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREVERT, 0)
}

func (s *ExecuteAsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteAsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteAsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterExecuteAsStatement(s)
	}
}

func (s *ExecuteAsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitExecuteAsStatement(s)
	}
}

func (s *ExecuteAsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitExecuteAsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ExecuteAsStatement() (localctx IExecuteAsStatementContext) {
	localctx = NewExecuteAsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, DorisSQLParserParserRULE_executeAsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4689)
		p.Match(DorisSQLParserParserEXECUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4690)
		p.Match(DorisSQLParserParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4691)
		p.User()
	}
	p.SetState(4695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWITH {
		{
			p.SetState(4692)
			p.Match(DorisSQLParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4693)
			p.Match(DorisSQLParserParserNO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4694)
			p.Match(DorisSQLParserParserREVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateRoleStatementContext is an interface to support dynamic dispatch.
type ICreateRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	RoleList() IRoleListContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Comment() ICommentContext

	// IsCreateRoleStatementContext differentiates from other interfaces.
	IsCreateRoleStatementContext()
}

type CreateRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateRoleStatementContext() *CreateRoleStatementContext {
	var p = new(CreateRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createRoleStatement
	return p
}

func InitEmptyCreateRoleStatementContext(p *CreateRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createRoleStatement
}

func (*CreateRoleStatementContext) IsCreateRoleStatementContext() {}

func NewCreateRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRoleStatementContext {
	var p = new(CreateRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createRoleStatement

	return p
}

func (s *CreateRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRoleStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateRoleStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROLE, 0)
}

func (s *CreateRoleStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *CreateRoleStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *CreateRoleStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *CreateRoleStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *CreateRoleStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRoleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateRoleStatement(s)
	}
}

func (s *CreateRoleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateRoleStatement(s)
	}
}

func (s *CreateRoleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateRoleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateRoleStatement() (localctx ICreateRoleStatementContext) {
	localctx = NewCreateRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, DorisSQLParserParserRULE_createRoleStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4697)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4698)
		p.Match(DorisSQLParserParserROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4702)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(4699)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4700)
			p.Match(DorisSQLParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4701)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4704)
		p.RoleList()
	}
	p.SetState(4706)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserCOMMENT {
		{
			p.SetState(4705)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterRoleStatementContext is an interface to support dynamic dispatch.
type IAlterRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	RoleList() IRoleListContext
	SET() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	EQ() antlr.TerminalNode
	String_() IStringContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsAlterRoleStatementContext differentiates from other interfaces.
	IsAlterRoleStatementContext()
}

type AlterRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterRoleStatementContext() *AlterRoleStatementContext {
	var p = new(AlterRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterRoleStatement
	return p
}

func InitEmptyAlterRoleStatementContext(p *AlterRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterRoleStatement
}

func (*AlterRoleStatementContext) IsAlterRoleStatementContext() {}

func NewAlterRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterRoleStatementContext {
	var p = new(AlterRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_alterRoleStatement

	return p
}

func (s *AlterRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterRoleStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *AlterRoleStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROLE, 0)
}

func (s *AlterRoleStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *AlterRoleStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *AlterRoleStatementContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOMMENT, 0)
}

func (s *AlterRoleStatementContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEQ, 0)
}

func (s *AlterRoleStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AlterRoleStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *AlterRoleStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *AlterRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterRoleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAlterRoleStatement(s)
	}
}

func (s *AlterRoleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAlterRoleStatement(s)
	}
}

func (s *AlterRoleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAlterRoleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AlterRoleStatement() (localctx IAlterRoleStatementContext) {
	localctx = NewAlterRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, DorisSQLParserParserRULE_alterRoleStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4708)
		p.Match(DorisSQLParserParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4709)
		p.Match(DorisSQLParserParserROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4712)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(4710)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4711)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4714)
		p.RoleList()
	}
	{
		p.SetState(4715)
		p.Match(DorisSQLParserParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4716)
		p.Match(DorisSQLParserParserCOMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4717)
		p.Match(DorisSQLParserParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4718)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropRoleStatementContext is an interface to support dynamic dispatch.
type IDropRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	RoleList() IRoleListContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropRoleStatementContext differentiates from other interfaces.
	IsDropRoleStatementContext()
}

type DropRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropRoleStatementContext() *DropRoleStatementContext {
	var p = new(DropRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropRoleStatement
	return p
}

func InitEmptyDropRoleStatementContext(p *DropRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropRoleStatement
}

func (*DropRoleStatementContext) IsDropRoleStatementContext() {}

func NewDropRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropRoleStatementContext {
	var p = new(DropRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropRoleStatement

	return p
}

func (s *DropRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropRoleStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropRoleStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROLE, 0)
}

func (s *DropRoleStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *DropRoleStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *DropRoleStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *DropRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropRoleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropRoleStatement(s)
	}
}

func (s *DropRoleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropRoleStatement(s)
	}
}

func (s *DropRoleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropRoleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropRoleStatement() (localctx IDropRoleStatementContext) {
	localctx = NewDropRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, DorisSQLParserParserRULE_dropRoleStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4720)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4721)
		p.Match(DorisSQLParserParserROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4724)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(4722)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4723)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4726)
		p.RoleList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowRolesStatementContext is an interface to support dynamic dispatch.
type IShowRolesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	ROLES() antlr.TerminalNode

	// IsShowRolesStatementContext differentiates from other interfaces.
	IsShowRolesStatementContext()
}

type ShowRolesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowRolesStatementContext() *ShowRolesStatementContext {
	var p = new(ShowRolesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showRolesStatement
	return p
}

func InitEmptyShowRolesStatementContext(p *ShowRolesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showRolesStatement
}

func (*ShowRolesStatementContext) IsShowRolesStatementContext() {}

func NewShowRolesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRolesStatementContext {
	var p = new(ShowRolesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showRolesStatement

	return p
}

func (s *ShowRolesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRolesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowRolesStatementContext) ROLES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROLES, 0)
}

func (s *ShowRolesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRolesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRolesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowRolesStatement(s)
	}
}

func (s *ShowRolesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowRolesStatement(s)
	}
}

func (s *ShowRolesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowRolesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowRolesStatement() (localctx IShowRolesStatementContext) {
	localctx = NewShowRolesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, DorisSQLParserParserRULE_showRolesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4728)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4729)
		p.Match(DorisSQLParserParserROLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantRoleStatementContext is an interface to support dynamic dispatch.
type IGrantRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsGrantRoleStatementContext differentiates from other interfaces.
	IsGrantRoleStatementContext()
}

type GrantRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantRoleStatementContext() *GrantRoleStatementContext {
	var p = new(GrantRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_grantRoleStatement
	return p
}

func InitEmptyGrantRoleStatementContext(p *GrantRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_grantRoleStatement
}

func (*GrantRoleStatementContext) IsGrantRoleStatementContext() {}

func NewGrantRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantRoleStatementContext {
	var p = new(GrantRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_grantRoleStatement

	return p
}

func (s *GrantRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantRoleStatementContext) CopyAll(ctx *GrantRoleStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *GrantRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type GrantRoleToUserContext struct {
	GrantRoleStatementContext
}

func NewGrantRoleToUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantRoleToUserContext {
	var p = new(GrantRoleToUserContext)

	InitEmptyGrantRoleStatementContext(&p.GrantRoleStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantRoleStatementContext))

	return p
}

func (s *GrantRoleToUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRoleToUserContext) GRANT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGRANT, 0)
}

func (s *GrantRoleToUserContext) IdentifierOrStringList() IIdentifierOrStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringListContext)
}

func (s *GrantRoleToUserContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTO, 0)
}

func (s *GrantRoleToUserContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *GrantRoleToUserContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSER, 0)
}

func (s *GrantRoleToUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterGrantRoleToUser(s)
	}
}

func (s *GrantRoleToUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitGrantRoleToUser(s)
	}
}

func (s *GrantRoleToUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitGrantRoleToUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type GrantRoleToRoleContext struct {
	GrantRoleStatementContext
}

func NewGrantRoleToRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantRoleToRoleContext {
	var p = new(GrantRoleToRoleContext)

	InitEmptyGrantRoleStatementContext(&p.GrantRoleStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantRoleStatementContext))

	return p
}

func (s *GrantRoleToRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRoleToRoleContext) GRANT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGRANT, 0)
}

func (s *GrantRoleToRoleContext) IdentifierOrStringList() IIdentifierOrStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringListContext)
}

func (s *GrantRoleToRoleContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTO, 0)
}

func (s *GrantRoleToRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROLE, 0)
}

func (s *GrantRoleToRoleContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *GrantRoleToRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterGrantRoleToRole(s)
	}
}

func (s *GrantRoleToRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitGrantRoleToRole(s)
	}
}

func (s *GrantRoleToRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitGrantRoleToRole(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) GrantRoleStatement() (localctx IGrantRoleStatementContext) {
	localctx = NewGrantRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, DorisSQLParserParserRULE_grantRoleStatement)
	p.SetState(4745)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 513, p.GetParserRuleContext()) {
	case 1:
		localctx = NewGrantRoleToUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4731)
			p.Match(DorisSQLParserParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4732)
			p.IdentifierOrStringList()
		}
		{
			p.SetState(4733)
			p.Match(DorisSQLParserParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4735)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 512, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4734)
				p.Match(DorisSQLParserParserUSER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4737)
			p.User()
		}

	case 2:
		localctx = NewGrantRoleToRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4739)
			p.Match(DorisSQLParserParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4740)
			p.IdentifierOrStringList()
		}
		{
			p.SetState(4741)
			p.Match(DorisSQLParserParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4742)
			p.Match(DorisSQLParserParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4743)
			p.IdentifierOrString()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRevokeRoleStatementContext is an interface to support dynamic dispatch.
type IRevokeRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRevokeRoleStatementContext differentiates from other interfaces.
	IsRevokeRoleStatementContext()
}

type RevokeRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevokeRoleStatementContext() *RevokeRoleStatementContext {
	var p = new(RevokeRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_revokeRoleStatement
	return p
}

func InitEmptyRevokeRoleStatementContext(p *RevokeRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_revokeRoleStatement
}

func (*RevokeRoleStatementContext) IsRevokeRoleStatementContext() {}

func NewRevokeRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokeRoleStatementContext {
	var p = new(RevokeRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_revokeRoleStatement

	return p
}

func (s *RevokeRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokeRoleStatementContext) CopyAll(ctx *RevokeRoleStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RevokeRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RevokeRoleFromUserContext struct {
	RevokeRoleStatementContext
}

func NewRevokeRoleFromUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeRoleFromUserContext {
	var p = new(RevokeRoleFromUserContext)

	InitEmptyRevokeRoleStatementContext(&p.RevokeRoleStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokeRoleStatementContext))

	return p
}

func (s *RevokeRoleFromUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeRoleFromUserContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREVOKE, 0)
}

func (s *RevokeRoleFromUserContext) IdentifierOrStringList() IIdentifierOrStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringListContext)
}

func (s *RevokeRoleFromUserContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *RevokeRoleFromUserContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *RevokeRoleFromUserContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSER, 0)
}

func (s *RevokeRoleFromUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRevokeRoleFromUser(s)
	}
}

func (s *RevokeRoleFromUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRevokeRoleFromUser(s)
	}
}

func (s *RevokeRoleFromUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRevokeRoleFromUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeRoleFromRoleContext struct {
	RevokeRoleStatementContext
}

func NewRevokeRoleFromRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeRoleFromRoleContext {
	var p = new(RevokeRoleFromRoleContext)

	InitEmptyRevokeRoleStatementContext(&p.RevokeRoleStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokeRoleStatementContext))

	return p
}

func (s *RevokeRoleFromRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeRoleFromRoleContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREVOKE, 0)
}

func (s *RevokeRoleFromRoleContext) IdentifierOrStringList() IIdentifierOrStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringListContext)
}

func (s *RevokeRoleFromRoleContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *RevokeRoleFromRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROLE, 0)
}

func (s *RevokeRoleFromRoleContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *RevokeRoleFromRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRevokeRoleFromRole(s)
	}
}

func (s *RevokeRoleFromRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRevokeRoleFromRole(s)
	}
}

func (s *RevokeRoleFromRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRevokeRoleFromRole(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) RevokeRoleStatement() (localctx IRevokeRoleStatementContext) {
	localctx = NewRevokeRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, DorisSQLParserParserRULE_revokeRoleStatement)
	p.SetState(4761)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 515, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRevokeRoleFromUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4747)
			p.Match(DorisSQLParserParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4748)
			p.IdentifierOrStringList()
		}
		{
			p.SetState(4749)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4751)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 514, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4750)
				p.Match(DorisSQLParserParserUSER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4753)
			p.User()
		}

	case 2:
		localctx = NewRevokeRoleFromRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4755)
			p.Match(DorisSQLParserParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4756)
			p.IdentifierOrStringList()
		}
		{
			p.SetState(4757)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4758)
			p.Match(DorisSQLParserParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4759)
			p.IdentifierOrString()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetRoleStatementContext is an interface to support dynamic dispatch.
type ISetRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	NONE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode
	RoleList() IRoleListContext

	// IsSetRoleStatementContext differentiates from other interfaces.
	IsSetRoleStatementContext()
}

type SetRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetRoleStatementContext() *SetRoleStatementContext {
	var p = new(SetRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_setRoleStatement
	return p
}

func InitEmptySetRoleStatementContext(p *SetRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_setRoleStatement
}

func (*SetRoleStatementContext) IsSetRoleStatementContext() {}

func NewSetRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetRoleStatementContext {
	var p = new(SetRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_setRoleStatement

	return p
}

func (s *SetRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetRoleStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *SetRoleStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROLE, 0)
}

func (s *SetRoleStatementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDEFAULT, 0)
}

func (s *SetRoleStatementContext) NONE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNONE, 0)
}

func (s *SetRoleStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, 0)
}

func (s *SetRoleStatementContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXCEPT, 0)
}

func (s *SetRoleStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *SetRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetRoleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSetRoleStatement(s)
	}
}

func (s *SetRoleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSetRoleStatement(s)
	}
}

func (s *SetRoleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSetRoleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SetRoleStatement() (localctx ISetRoleStatementContext) {
	localctx = NewSetRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, DorisSQLParserParserRULE_setRoleStatement)
	var _la int

	p.SetState(4779)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 517, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4763)
			p.Match(DorisSQLParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4764)
			p.Match(DorisSQLParserParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4765)
			p.Match(DorisSQLParserParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4766)
			p.Match(DorisSQLParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4767)
			p.Match(DorisSQLParserParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4768)
			p.Match(DorisSQLParserParserNONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4769)
			p.Match(DorisSQLParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4770)
			p.Match(DorisSQLParserParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4771)
			p.Match(DorisSQLParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4774)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserEXCEPT {
			{
				p.SetState(4772)
				p.Match(DorisSQLParserParserEXCEPT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4773)
				p.RoleList()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4776)
			p.Match(DorisSQLParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4777)
			p.Match(DorisSQLParserParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4778)
			p.RoleList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetDefaultRoleStatementContext is an interface to support dynamic dispatch.
type ISetDefaultRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	TO() antlr.TerminalNode
	User() IUserContext
	NONE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	RoleList() IRoleListContext

	// IsSetDefaultRoleStatementContext differentiates from other interfaces.
	IsSetDefaultRoleStatementContext()
}

type SetDefaultRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetDefaultRoleStatementContext() *SetDefaultRoleStatementContext {
	var p = new(SetDefaultRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_setDefaultRoleStatement
	return p
}

func InitEmptySetDefaultRoleStatementContext(p *SetDefaultRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_setDefaultRoleStatement
}

func (*SetDefaultRoleStatementContext) IsSetDefaultRoleStatementContext() {}

func NewSetDefaultRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetDefaultRoleStatementContext {
	var p = new(SetDefaultRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_setDefaultRoleStatement

	return p
}

func (s *SetDefaultRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetDefaultRoleStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *SetDefaultRoleStatementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDEFAULT, 0)
}

func (s *SetDefaultRoleStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROLE, 0)
}

func (s *SetDefaultRoleStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTO, 0)
}

func (s *SetDefaultRoleStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *SetDefaultRoleStatementContext) NONE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNONE, 0)
}

func (s *SetDefaultRoleStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, 0)
}

func (s *SetDefaultRoleStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *SetDefaultRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetDefaultRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetDefaultRoleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSetDefaultRoleStatement(s)
	}
}

func (s *SetDefaultRoleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSetDefaultRoleStatement(s)
	}
}

func (s *SetDefaultRoleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSetDefaultRoleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SetDefaultRoleStatement() (localctx ISetDefaultRoleStatementContext) {
	localctx = NewSetDefaultRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, DorisSQLParserParserRULE_setDefaultRoleStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4781)
		p.Match(DorisSQLParserParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4782)
		p.Match(DorisSQLParserParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4783)
		p.Match(DorisSQLParserParserROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4787)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 518, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4784)
			p.Match(DorisSQLParserParserNONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(4785)
			p.Match(DorisSQLParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(4786)
			p.RoleList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(4789)
		p.Match(DorisSQLParserParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4790)
		p.User()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantRevokeClauseContext is an interface to support dynamic dispatch.
type IGrantRevokeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	User() IUserContext
	ROLE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	USER() antlr.TerminalNode

	// IsGrantRevokeClauseContext differentiates from other interfaces.
	IsGrantRevokeClauseContext()
}

type GrantRevokeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantRevokeClauseContext() *GrantRevokeClauseContext {
	var p = new(GrantRevokeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_grantRevokeClause
	return p
}

func InitEmptyGrantRevokeClauseContext(p *GrantRevokeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_grantRevokeClause
}

func (*GrantRevokeClauseContext) IsGrantRevokeClauseContext() {}

func NewGrantRevokeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantRevokeClauseContext {
	var p = new(GrantRevokeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_grantRevokeClause

	return p
}

func (s *GrantRevokeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantRevokeClauseContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *GrantRevokeClauseContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROLE, 0)
}

func (s *GrantRevokeClauseContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *GrantRevokeClauseContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSER, 0)
}

func (s *GrantRevokeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRevokeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantRevokeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterGrantRevokeClause(s)
	}
}

func (s *GrantRevokeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitGrantRevokeClause(s)
	}
}

func (s *GrantRevokeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitGrantRevokeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) GrantRevokeClause() (localctx IGrantRevokeClauseContext) {
	localctx = NewGrantRevokeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, DorisSQLParserParserRULE_grantRevokeClause)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4798)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 520, p.GetParserRuleContext()) {
	case 1:
		p.SetState(4793)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 519, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4792)
				p.Match(DorisSQLParserParserUSER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4795)
			p.User()
		}

	case 2:
		{
			p.SetState(4796)
			p.Match(DorisSQLParserParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4797)
			p.IdentifierOrString()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantPrivilegeStatementContext is an interface to support dynamic dispatch.
type IGrantPrivilegeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsGrantPrivilegeStatementContext differentiates from other interfaces.
	IsGrantPrivilegeStatementContext()
}

type GrantPrivilegeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantPrivilegeStatementContext() *GrantPrivilegeStatementContext {
	var p = new(GrantPrivilegeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_grantPrivilegeStatement
	return p
}

func InitEmptyGrantPrivilegeStatementContext(p *GrantPrivilegeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_grantPrivilegeStatement
}

func (*GrantPrivilegeStatementContext) IsGrantPrivilegeStatementContext() {}

func NewGrantPrivilegeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantPrivilegeStatementContext {
	var p = new(GrantPrivilegeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_grantPrivilegeStatement

	return p
}

func (s *GrantPrivilegeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantPrivilegeStatementContext) CopyAll(ctx *GrantPrivilegeStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *GrantPrivilegeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantPrivilegeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type GrantOnAllContext struct {
	GrantPrivilegeStatementContext
	isAll antlr.Token
}

func NewGrantOnAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantOnAllContext {
	var p = new(GrantOnAllContext)

	InitEmptyGrantPrivilegeStatementContext(&p.GrantPrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantPrivilegeStatementContext))

	return p
}

func (s *GrantOnAllContext) GetIsAll() antlr.Token { return s.isAll }

func (s *GrantOnAllContext) SetIsAll(v antlr.Token) { s.isAll = v }

func (s *GrantOnAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOnAllContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserGRANT)
}

func (s *GrantOnAllContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGRANT, i)
}

func (s *GrantOnAllContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *GrantOnAllContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *GrantOnAllContext) AllALL() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserALL)
}

func (s *GrantOnAllContext) ALL(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, i)
}

func (s *GrantOnAllContext) PrivObjectTypePlural() IPrivObjectTypePluralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectTypePluralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectTypePluralContext)
}

func (s *GrantOnAllContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTO, 0)
}

func (s *GrantOnAllContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *GrantOnAllContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *GrantOnAllContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATABASES, 0)
}

func (s *GrantOnAllContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATABASE, 0)
}

func (s *GrantOnAllContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *GrantOnAllContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *GrantOnAllContext) OPTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOPTION, 0)
}

func (s *GrantOnAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterGrantOnAll(s)
	}
}

func (s *GrantOnAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitGrantOnAll(s)
	}
}

func (s *GrantOnAllContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitGrantOnAll(s)

	default:
		return t.VisitChildren(s)
	}
}

type GrantOnFuncContext struct {
	GrantPrivilegeStatementContext
}

func NewGrantOnFuncContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantOnFuncContext {
	var p = new(GrantOnFuncContext)

	InitEmptyGrantPrivilegeStatementContext(&p.GrantPrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantPrivilegeStatementContext))

	return p
}

func (s *GrantOnFuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOnFuncContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserGRANT)
}

func (s *GrantOnFuncContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGRANT, i)
}

func (s *GrantOnFuncContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *GrantOnFuncContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *GrantOnFuncContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFUNCTION, 0)
}

func (s *GrantOnFuncContext) PrivFunctionObjectNameList() IPrivFunctionObjectNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivFunctionObjectNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivFunctionObjectNameListContext)
}

func (s *GrantOnFuncContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTO, 0)
}

func (s *GrantOnFuncContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *GrantOnFuncContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGLOBAL, 0)
}

func (s *GrantOnFuncContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *GrantOnFuncContext) OPTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOPTION, 0)
}

func (s *GrantOnFuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterGrantOnFunc(s)
	}
}

func (s *GrantOnFuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitGrantOnFunc(s)
	}
}

func (s *GrantOnFuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitGrantOnFunc(s)

	default:
		return t.VisitChildren(s)
	}
}

type GrantOnPrimaryObjContext struct {
	GrantPrivilegeStatementContext
}

func NewGrantOnPrimaryObjContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantOnPrimaryObjContext {
	var p = new(GrantOnPrimaryObjContext)

	InitEmptyGrantPrivilegeStatementContext(&p.GrantPrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantPrivilegeStatementContext))

	return p
}

func (s *GrantOnPrimaryObjContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOnPrimaryObjContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserGRANT)
}

func (s *GrantOnPrimaryObjContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGRANT, i)
}

func (s *GrantOnPrimaryObjContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *GrantOnPrimaryObjContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *GrantOnPrimaryObjContext) PrivObjectType() IPrivObjectTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectTypeContext)
}

func (s *GrantOnPrimaryObjContext) PrivObjectNameList() IPrivObjectNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectNameListContext)
}

func (s *GrantOnPrimaryObjContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTO, 0)
}

func (s *GrantOnPrimaryObjContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *GrantOnPrimaryObjContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *GrantOnPrimaryObjContext) OPTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOPTION, 0)
}

func (s *GrantOnPrimaryObjContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterGrantOnPrimaryObj(s)
	}
}

func (s *GrantOnPrimaryObjContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitGrantOnPrimaryObj(s)
	}
}

func (s *GrantOnPrimaryObjContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitGrantOnPrimaryObj(s)

	default:
		return t.VisitChildren(s)
	}
}

type GrantOnTableBriefContext struct {
	GrantPrivilegeStatementContext
}

func NewGrantOnTableBriefContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantOnTableBriefContext {
	var p = new(GrantOnTableBriefContext)

	InitEmptyGrantPrivilegeStatementContext(&p.GrantPrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantPrivilegeStatementContext))

	return p
}

func (s *GrantOnTableBriefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOnTableBriefContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserGRANT)
}

func (s *GrantOnTableBriefContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGRANT, i)
}

func (s *GrantOnTableBriefContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *GrantOnTableBriefContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *GrantOnTableBriefContext) PrivObjectNameList() IPrivObjectNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectNameListContext)
}

func (s *GrantOnTableBriefContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTO, 0)
}

func (s *GrantOnTableBriefContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *GrantOnTableBriefContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *GrantOnTableBriefContext) OPTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOPTION, 0)
}

func (s *GrantOnTableBriefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterGrantOnTableBrief(s)
	}
}

func (s *GrantOnTableBriefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitGrantOnTableBrief(s)
	}
}

func (s *GrantOnTableBriefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitGrantOnTableBrief(s)

	default:
		return t.VisitChildren(s)
	}
}

type GrantOnUserContext struct {
	GrantPrivilegeStatementContext
}

func NewGrantOnUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantOnUserContext {
	var p = new(GrantOnUserContext)

	InitEmptyGrantPrivilegeStatementContext(&p.GrantPrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantPrivilegeStatementContext))

	return p
}

func (s *GrantOnUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOnUserContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserGRANT)
}

func (s *GrantOnUserContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGRANT, i)
}

func (s *GrantOnUserContext) IMPERSONATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIMPERSONATE, 0)
}

func (s *GrantOnUserContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *GrantOnUserContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSER, 0)
}

func (s *GrantOnUserContext) AllUser() []IUserContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserContext); ok {
			len++
		}
	}

	tst := make([]IUserContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserContext); ok {
			tst[i] = t.(IUserContext)
			i++
		}
	}

	return tst
}

func (s *GrantOnUserContext) User(i int) IUserContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *GrantOnUserContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTO, 0)
}

func (s *GrantOnUserContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *GrantOnUserContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *GrantOnUserContext) OPTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOPTION, 0)
}

func (s *GrantOnUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterGrantOnUser(s)
	}
}

func (s *GrantOnUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitGrantOnUser(s)
	}
}

func (s *GrantOnUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitGrantOnUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type GrantOnSystemContext struct {
	GrantPrivilegeStatementContext
}

func NewGrantOnSystemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantOnSystemContext {
	var p = new(GrantOnSystemContext)

	InitEmptyGrantPrivilegeStatementContext(&p.GrantPrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantPrivilegeStatementContext))

	return p
}

func (s *GrantOnSystemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOnSystemContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserGRANT)
}

func (s *GrantOnSystemContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGRANT, i)
}

func (s *GrantOnSystemContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *GrantOnSystemContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *GrantOnSystemContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSYSTEM, 0)
}

func (s *GrantOnSystemContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTO, 0)
}

func (s *GrantOnSystemContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *GrantOnSystemContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *GrantOnSystemContext) OPTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOPTION, 0)
}

func (s *GrantOnSystemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterGrantOnSystem(s)
	}
}

func (s *GrantOnSystemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitGrantOnSystem(s)
	}
}

func (s *GrantOnSystemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitGrantOnSystem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) GrantPrivilegeStatement() (localctx IGrantPrivilegeStatementContext) {
	localctx = NewGrantPrivilegeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, DorisSQLParserParserRULE_grantPrivilegeStatement)
	var _la int

	p.SetState(4888)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 530, p.GetParserRuleContext()) {
	case 1:
		localctx = NewGrantOnUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4800)
			p.Match(DorisSQLParserParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4801)
			p.Match(DorisSQLParserParserIMPERSONATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4802)
			p.Match(DorisSQLParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4803)
			p.Match(DorisSQLParserParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4804)
			p.User()
		}
		p.SetState(4809)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(4805)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4806)
				p.User()
			}

			p.SetState(4811)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4812)
			p.Match(DorisSQLParserParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4813)
			p.GrantRevokeClause()
		}
		p.SetState(4817)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserWITH {
			{
				p.SetState(4814)
				p.Match(DorisSQLParserParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4815)
				p.Match(DorisSQLParserParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4816)
				p.Match(DorisSQLParserParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		localctx = NewGrantOnTableBriefContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4819)
			p.Match(DorisSQLParserParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4820)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4821)
			p.Match(DorisSQLParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4822)
			p.PrivObjectNameList()
		}
		{
			p.SetState(4823)
			p.Match(DorisSQLParserParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4824)
			p.GrantRevokeClause()
		}
		p.SetState(4828)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserWITH {
			{
				p.SetState(4825)
				p.Match(DorisSQLParserParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4826)
				p.Match(DorisSQLParserParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4827)
				p.Match(DorisSQLParserParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		localctx = NewGrantOnFuncContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4830)
			p.Match(DorisSQLParserParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4831)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4832)
			p.Match(DorisSQLParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4834)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserGLOBAL {
			{
				p.SetState(4833)
				p.Match(DorisSQLParserParserGLOBAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4836)
			p.Match(DorisSQLParserParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4837)
			p.PrivFunctionObjectNameList()
		}
		{
			p.SetState(4838)
			p.Match(DorisSQLParserParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4839)
			p.GrantRevokeClause()
		}
		p.SetState(4843)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserWITH {
			{
				p.SetState(4840)
				p.Match(DorisSQLParserParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4841)
				p.Match(DorisSQLParserParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4842)
				p.Match(DorisSQLParserParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		localctx = NewGrantOnSystemContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4845)
			p.Match(DorisSQLParserParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4846)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4847)
			p.Match(DorisSQLParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4848)
			p.Match(DorisSQLParserParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4849)
			p.Match(DorisSQLParserParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4850)
			p.GrantRevokeClause()
		}
		p.SetState(4854)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserWITH {
			{
				p.SetState(4851)
				p.Match(DorisSQLParserParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4852)
				p.Match(DorisSQLParserParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4853)
				p.Match(DorisSQLParserParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		localctx = NewGrantOnPrimaryObjContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4856)
			p.Match(DorisSQLParserParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4857)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4858)
			p.Match(DorisSQLParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4859)
			p.PrivObjectType()
		}
		{
			p.SetState(4860)
			p.PrivObjectNameList()
		}
		{
			p.SetState(4861)
			p.Match(DorisSQLParserParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4862)
			p.GrantRevokeClause()
		}
		p.SetState(4866)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserWITH {
			{
				p.SetState(4863)
				p.Match(DorisSQLParserParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4864)
				p.Match(DorisSQLParserParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4865)
				p.Match(DorisSQLParserParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		localctx = NewGrantOnAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4868)
			p.Match(DorisSQLParserParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4869)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4870)
			p.Match(DorisSQLParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4871)
			p.Match(DorisSQLParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4872)
			p.PrivObjectTypePlural()
		}
		p.SetState(4879)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 528, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4873)
				p.Match(DorisSQLParserParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4874)

				var _m = p.Match(DorisSQLParserParserALL)

				localctx.(*GrantOnAllContext).isAll = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4875)
				p.Match(DorisSQLParserParserDATABASES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 528, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(4876)
				p.Match(DorisSQLParserParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4877)
				p.Match(DorisSQLParserParserDATABASE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4878)
				p.IdentifierOrString()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4881)
			p.Match(DorisSQLParserParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4882)
			p.GrantRevokeClause()
		}
		p.SetState(4886)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserWITH {
			{
				p.SetState(4883)
				p.Match(DorisSQLParserParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4884)
				p.Match(DorisSQLParserParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4885)
				p.Match(DorisSQLParserParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRevokePrivilegeStatementContext is an interface to support dynamic dispatch.
type IRevokePrivilegeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRevokePrivilegeStatementContext differentiates from other interfaces.
	IsRevokePrivilegeStatementContext()
}

type RevokePrivilegeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevokePrivilegeStatementContext() *RevokePrivilegeStatementContext {
	var p = new(RevokePrivilegeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_revokePrivilegeStatement
	return p
}

func InitEmptyRevokePrivilegeStatementContext(p *RevokePrivilegeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_revokePrivilegeStatement
}

func (*RevokePrivilegeStatementContext) IsRevokePrivilegeStatementContext() {}

func NewRevokePrivilegeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokePrivilegeStatementContext {
	var p = new(RevokePrivilegeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_revokePrivilegeStatement

	return p
}

func (s *RevokePrivilegeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokePrivilegeStatementContext) CopyAll(ctx *RevokePrivilegeStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RevokePrivilegeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokePrivilegeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RevokeOnPrimaryObjContext struct {
	RevokePrivilegeStatementContext
}

func NewRevokeOnPrimaryObjContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeOnPrimaryObjContext {
	var p = new(RevokeOnPrimaryObjContext)

	InitEmptyRevokePrivilegeStatementContext(&p.RevokePrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokePrivilegeStatementContext))

	return p
}

func (s *RevokeOnPrimaryObjContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeOnPrimaryObjContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREVOKE, 0)
}

func (s *RevokeOnPrimaryObjContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *RevokeOnPrimaryObjContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *RevokeOnPrimaryObjContext) PrivObjectType() IPrivObjectTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectTypeContext)
}

func (s *RevokeOnPrimaryObjContext) PrivObjectNameList() IPrivObjectNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectNameListContext)
}

func (s *RevokeOnPrimaryObjContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *RevokeOnPrimaryObjContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *RevokeOnPrimaryObjContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRevokeOnPrimaryObj(s)
	}
}

func (s *RevokeOnPrimaryObjContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRevokeOnPrimaryObj(s)
	}
}

func (s *RevokeOnPrimaryObjContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRevokeOnPrimaryObj(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeOnTableBriefContext struct {
	RevokePrivilegeStatementContext
}

func NewRevokeOnTableBriefContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeOnTableBriefContext {
	var p = new(RevokeOnTableBriefContext)

	InitEmptyRevokePrivilegeStatementContext(&p.RevokePrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokePrivilegeStatementContext))

	return p
}

func (s *RevokeOnTableBriefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeOnTableBriefContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREVOKE, 0)
}

func (s *RevokeOnTableBriefContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *RevokeOnTableBriefContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *RevokeOnTableBriefContext) PrivObjectNameList() IPrivObjectNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectNameListContext)
}

func (s *RevokeOnTableBriefContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *RevokeOnTableBriefContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *RevokeOnTableBriefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRevokeOnTableBrief(s)
	}
}

func (s *RevokeOnTableBriefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRevokeOnTableBrief(s)
	}
}

func (s *RevokeOnTableBriefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRevokeOnTableBrief(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeOnAllContext struct {
	RevokePrivilegeStatementContext
	isAll antlr.Token
}

func NewRevokeOnAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeOnAllContext {
	var p = new(RevokeOnAllContext)

	InitEmptyRevokePrivilegeStatementContext(&p.RevokePrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokePrivilegeStatementContext))

	return p
}

func (s *RevokeOnAllContext) GetIsAll() antlr.Token { return s.isAll }

func (s *RevokeOnAllContext) SetIsAll(v antlr.Token) { s.isAll = v }

func (s *RevokeOnAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeOnAllContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREVOKE, 0)
}

func (s *RevokeOnAllContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *RevokeOnAllContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *RevokeOnAllContext) AllALL() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserALL)
}

func (s *RevokeOnAllContext) ALL(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, i)
}

func (s *RevokeOnAllContext) PrivObjectTypePlural() IPrivObjectTypePluralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectTypePluralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectTypePluralContext)
}

func (s *RevokeOnAllContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *RevokeOnAllContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *RevokeOnAllContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *RevokeOnAllContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATABASES, 0)
}

func (s *RevokeOnAllContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATABASE, 0)
}

func (s *RevokeOnAllContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *RevokeOnAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRevokeOnAll(s)
	}
}

func (s *RevokeOnAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRevokeOnAll(s)
	}
}

func (s *RevokeOnAllContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRevokeOnAll(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeOnUserContext struct {
	RevokePrivilegeStatementContext
}

func NewRevokeOnUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeOnUserContext {
	var p = new(RevokeOnUserContext)

	InitEmptyRevokePrivilegeStatementContext(&p.RevokePrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokePrivilegeStatementContext))

	return p
}

func (s *RevokeOnUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeOnUserContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREVOKE, 0)
}

func (s *RevokeOnUserContext) IMPERSONATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIMPERSONATE, 0)
}

func (s *RevokeOnUserContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *RevokeOnUserContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSER, 0)
}

func (s *RevokeOnUserContext) AllUser() []IUserContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserContext); ok {
			len++
		}
	}

	tst := make([]IUserContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserContext); ok {
			tst[i] = t.(IUserContext)
			i++
		}
	}

	return tst
}

func (s *RevokeOnUserContext) User(i int) IUserContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *RevokeOnUserContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *RevokeOnUserContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *RevokeOnUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRevokeOnUser(s)
	}
}

func (s *RevokeOnUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRevokeOnUser(s)
	}
}

func (s *RevokeOnUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRevokeOnUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeOnFuncContext struct {
	RevokePrivilegeStatementContext
}

func NewRevokeOnFuncContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeOnFuncContext {
	var p = new(RevokeOnFuncContext)

	InitEmptyRevokePrivilegeStatementContext(&p.RevokePrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokePrivilegeStatementContext))

	return p
}

func (s *RevokeOnFuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeOnFuncContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREVOKE, 0)
}

func (s *RevokeOnFuncContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *RevokeOnFuncContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *RevokeOnFuncContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFUNCTION, 0)
}

func (s *RevokeOnFuncContext) PrivFunctionObjectNameList() IPrivFunctionObjectNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivFunctionObjectNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivFunctionObjectNameListContext)
}

func (s *RevokeOnFuncContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *RevokeOnFuncContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *RevokeOnFuncContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGLOBAL, 0)
}

func (s *RevokeOnFuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRevokeOnFunc(s)
	}
}

func (s *RevokeOnFuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRevokeOnFunc(s)
	}
}

func (s *RevokeOnFuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRevokeOnFunc(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeOnSystemContext struct {
	RevokePrivilegeStatementContext
}

func NewRevokeOnSystemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeOnSystemContext {
	var p = new(RevokeOnSystemContext)

	InitEmptyRevokePrivilegeStatementContext(&p.RevokePrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokePrivilegeStatementContext))

	return p
}

func (s *RevokeOnSystemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeOnSystemContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREVOKE, 0)
}

func (s *RevokeOnSystemContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *RevokeOnSystemContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *RevokeOnSystemContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSYSTEM, 0)
}

func (s *RevokeOnSystemContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *RevokeOnSystemContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *RevokeOnSystemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRevokeOnSystem(s)
	}
}

func (s *RevokeOnSystemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRevokeOnSystem(s)
	}
}

func (s *RevokeOnSystemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRevokeOnSystem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) RevokePrivilegeStatement() (localctx IRevokePrivilegeStatementContext) {
	localctx = NewRevokePrivilegeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, DorisSQLParserParserRULE_revokePrivilegeStatement)
	var _la int

	p.SetState(4954)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 534, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRevokeOnUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4890)
			p.Match(DorisSQLParserParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4891)
			p.Match(DorisSQLParserParserIMPERSONATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4892)
			p.Match(DorisSQLParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4893)
			p.Match(DorisSQLParserParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4894)
			p.User()
		}
		p.SetState(4899)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(4895)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4896)
				p.User()
			}

			p.SetState(4901)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4902)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4903)
			p.GrantRevokeClause()
		}

	case 2:
		localctx = NewRevokeOnTableBriefContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4905)
			p.Match(DorisSQLParserParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4906)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4907)
			p.Match(DorisSQLParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4908)
			p.PrivObjectNameList()
		}
		{
			p.SetState(4909)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4910)
			p.GrantRevokeClause()
		}

	case 3:
		localctx = NewRevokeOnFuncContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4912)
			p.Match(DorisSQLParserParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4913)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4914)
			p.Match(DorisSQLParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4916)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserGLOBAL {
			{
				p.SetState(4915)
				p.Match(DorisSQLParserParserGLOBAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4918)
			p.Match(DorisSQLParserParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4919)
			p.PrivFunctionObjectNameList()
		}
		{
			p.SetState(4920)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4921)
			p.GrantRevokeClause()
		}

	case 4:
		localctx = NewRevokeOnSystemContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4923)
			p.Match(DorisSQLParserParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4924)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4925)
			p.Match(DorisSQLParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4926)
			p.Match(DorisSQLParserParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4927)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4928)
			p.GrantRevokeClause()
		}

	case 5:
		localctx = NewRevokeOnPrimaryObjContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4930)
			p.Match(DorisSQLParserParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4931)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4932)
			p.Match(DorisSQLParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4933)
			p.PrivObjectType()
		}
		{
			p.SetState(4934)
			p.PrivObjectNameList()
		}
		{
			p.SetState(4935)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4936)
			p.GrantRevokeClause()
		}

	case 6:
		localctx = NewRevokeOnAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4938)
			p.Match(DorisSQLParserParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4939)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4940)
			p.Match(DorisSQLParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4941)
			p.Match(DorisSQLParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4942)
			p.PrivObjectTypePlural()
		}
		p.SetState(4949)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 533, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4943)
				p.Match(DorisSQLParserParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4944)

				var _m = p.Match(DorisSQLParserParserALL)

				localctx.(*RevokeOnAllContext).isAll = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4945)
				p.Match(DorisSQLParserParserDATABASES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 533, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(4946)
				p.Match(DorisSQLParserParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4947)
				p.Match(DorisSQLParserParserDATABASE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4948)
				p.IdentifierOrString()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4951)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4952)
			p.GrantRevokeClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowGrantsStatementContext is an interface to support dynamic dispatch.
type IShowGrantsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	GRANTS() antlr.TerminalNode
	FOR() antlr.TerminalNode
	User() IUserContext
	USER() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsShowGrantsStatementContext differentiates from other interfaces.
	IsShowGrantsStatementContext()
}

type ShowGrantsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowGrantsStatementContext() *ShowGrantsStatementContext {
	var p = new(ShowGrantsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showGrantsStatement
	return p
}

func InitEmptyShowGrantsStatementContext(p *ShowGrantsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showGrantsStatement
}

func (*ShowGrantsStatementContext) IsShowGrantsStatementContext() {}

func NewShowGrantsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowGrantsStatementContext {
	var p = new(ShowGrantsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showGrantsStatement

	return p
}

func (s *ShowGrantsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowGrantsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowGrantsStatementContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGRANTS, 0)
}

func (s *ShowGrantsStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFOR, 0)
}

func (s *ShowGrantsStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *ShowGrantsStatementContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSER, 0)
}

func (s *ShowGrantsStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROLE, 0)
}

func (s *ShowGrantsStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *ShowGrantsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGrantsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowGrantsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowGrantsStatement(s)
	}
}

func (s *ShowGrantsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowGrantsStatement(s)
	}
}

func (s *ShowGrantsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowGrantsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowGrantsStatement() (localctx IShowGrantsStatementContext) {
	localctx = NewShowGrantsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, DorisSQLParserParserRULE_showGrantsStatement)
	p.SetState(4970)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 536, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4956)
			p.Match(DorisSQLParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4957)
			p.Match(DorisSQLParserParserGRANTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4958)
			p.Match(DorisSQLParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4959)
			p.Match(DorisSQLParserParserGRANTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4960)
			p.Match(DorisSQLParserParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4962)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 535, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4961)
				p.Match(DorisSQLParserParserUSER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4964)
			p.User()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4965)
			p.Match(DorisSQLParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4966)
			p.Match(DorisSQLParserParserGRANTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4967)
			p.Match(DorisSQLParserParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4968)
			p.Match(DorisSQLParserParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4969)
			p.IdentifierOrString()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAuthOptionContext is an interface to support dynamic dispatch.
type IAuthOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAuthOptionContext differentiates from other interfaces.
	IsAuthOptionContext()
}

type AuthOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAuthOptionContext() *AuthOptionContext {
	var p = new(AuthOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_authOption
	return p
}

func InitEmptyAuthOptionContext(p *AuthOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_authOption
}

func (*AuthOptionContext) IsAuthOptionContext() {}

func NewAuthOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AuthOptionContext {
	var p = new(AuthOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_authOption

	return p
}

func (s *AuthOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *AuthOptionContext) CopyAll(ctx *AuthOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AuthWithPluginContext struct {
	AuthOptionContext
}

func NewAuthWithPluginContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AuthWithPluginContext {
	var p = new(AuthWithPluginContext)

	InitEmptyAuthOptionContext(&p.AuthOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*AuthOptionContext))

	return p
}

func (s *AuthWithPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthWithPluginContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIDENTIFIED, 0)
}

func (s *AuthWithPluginContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *AuthWithPluginContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AuthWithPluginContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AuthWithPluginContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *AuthWithPluginContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *AuthWithPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAuthWithPlugin(s)
	}
}

func (s *AuthWithPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAuthWithPlugin(s)
	}
}

func (s *AuthWithPluginContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAuthWithPlugin(s)

	default:
		return t.VisitChildren(s)
	}
}

type AuthWithoutPluginContext struct {
	AuthOptionContext
}

func NewAuthWithoutPluginContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AuthWithoutPluginContext {
	var p = new(AuthWithoutPluginContext)

	InitEmptyAuthOptionContext(&p.AuthOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*AuthOptionContext))

	return p
}

func (s *AuthWithoutPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthWithoutPluginContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIDENTIFIED, 0)
}

func (s *AuthWithoutPluginContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *AuthWithoutPluginContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AuthWithoutPluginContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPASSWORD, 0)
}

func (s *AuthWithoutPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAuthWithoutPlugin(s)
	}
}

func (s *AuthWithoutPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAuthWithoutPlugin(s)
	}
}

func (s *AuthWithoutPluginContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAuthWithoutPlugin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AuthOption() (localctx IAuthOptionContext) {
	localctx = NewAuthOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, DorisSQLParserParserRULE_authOption)
	var _la int

	p.SetState(4985)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 539, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAuthWithoutPluginContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4972)
			p.Match(DorisSQLParserParserIDENTIFIED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4973)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4975)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserPASSWORD {
			{
				p.SetState(4974)
				p.Match(DorisSQLParserParserPASSWORD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4977)
			p.String_()
		}

	case 2:
		localctx = NewAuthWithPluginContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4978)
			p.Match(DorisSQLParserParserIDENTIFIED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4979)
			p.Match(DorisSQLParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4980)
			p.IdentifierOrString()
		}
		p.SetState(4983)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserAS || _la == DorisSQLParserParserBY {
			{
				p.SetState(4981)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserParserAS || _la == DorisSQLParserParserBY) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(4982)
				p.String_()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivObjectNameContext is an interface to support dynamic dispatch.
type IPrivObjectNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierOrStringOrStar() []IIdentifierOrStringOrStarContext
	IdentifierOrStringOrStar(i int) IIdentifierOrStringOrStarContext

	// IsPrivObjectNameContext differentiates from other interfaces.
	IsPrivObjectNameContext()
}

type PrivObjectNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivObjectNameContext() *PrivObjectNameContext {
	var p = new(PrivObjectNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_privObjectName
	return p
}

func InitEmptyPrivObjectNameContext(p *PrivObjectNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_privObjectName
}

func (*PrivObjectNameContext) IsPrivObjectNameContext() {}

func NewPrivObjectNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivObjectNameContext {
	var p = new(PrivObjectNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_privObjectName

	return p
}

func (s *PrivObjectNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivObjectNameContext) AllIdentifierOrStringOrStar() []IIdentifierOrStringOrStarContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringOrStarContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringOrStarContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringOrStarContext); ok {
			tst[i] = t.(IIdentifierOrStringOrStarContext)
			i++
		}
	}

	return tst
}

func (s *PrivObjectNameContext) IdentifierOrStringOrStar(i int) IIdentifierOrStringOrStarContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringOrStarContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringOrStarContext)
}

func (s *PrivObjectNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivObjectNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivObjectNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPrivObjectName(s)
	}
}

func (s *PrivObjectNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPrivObjectName(s)
	}
}

func (s *PrivObjectNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPrivObjectName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PrivObjectName() (localctx IPrivObjectNameContext) {
	localctx = NewPrivObjectNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, DorisSQLParserParserRULE_privObjectName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4987)
		p.IdentifierOrStringOrStar()
	}
	p.SetState(4990)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserT__0 {
		{
			p.SetState(4988)
			p.Match(DorisSQLParserParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4989)
			p.IdentifierOrStringOrStar()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivObjectNameListContext is an interface to support dynamic dispatch.
type IPrivObjectNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrivObjectName() []IPrivObjectNameContext
	PrivObjectName(i int) IPrivObjectNameContext

	// IsPrivObjectNameListContext differentiates from other interfaces.
	IsPrivObjectNameListContext()
}

type PrivObjectNameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivObjectNameListContext() *PrivObjectNameListContext {
	var p = new(PrivObjectNameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_privObjectNameList
	return p
}

func InitEmptyPrivObjectNameListContext(p *PrivObjectNameListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_privObjectNameList
}

func (*PrivObjectNameListContext) IsPrivObjectNameListContext() {}

func NewPrivObjectNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivObjectNameListContext {
	var p = new(PrivObjectNameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_privObjectNameList

	return p
}

func (s *PrivObjectNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivObjectNameListContext) AllPrivObjectName() []IPrivObjectNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivObjectNameContext); ok {
			len++
		}
	}

	tst := make([]IPrivObjectNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivObjectNameContext); ok {
			tst[i] = t.(IPrivObjectNameContext)
			i++
		}
	}

	return tst
}

func (s *PrivObjectNameListContext) PrivObjectName(i int) IPrivObjectNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectNameContext)
}

func (s *PrivObjectNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivObjectNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivObjectNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPrivObjectNameList(s)
	}
}

func (s *PrivObjectNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPrivObjectNameList(s)
	}
}

func (s *PrivObjectNameListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPrivObjectNameList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PrivObjectNameList() (localctx IPrivObjectNameListContext) {
	localctx = NewPrivObjectNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, DorisSQLParserParserRULE_privObjectNameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4992)
		p.PrivObjectName()
	}
	p.SetState(4997)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(4993)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4994)
			p.PrivObjectName()
		}

		p.SetState(4999)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivFunctionObjectNameListContext is an interface to support dynamic dispatch.
type IPrivFunctionObjectNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	AllTypeList() []ITypeListContext
	TypeList(i int) ITypeListContext

	// IsPrivFunctionObjectNameListContext differentiates from other interfaces.
	IsPrivFunctionObjectNameListContext()
}

type PrivFunctionObjectNameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivFunctionObjectNameListContext() *PrivFunctionObjectNameListContext {
	var p = new(PrivFunctionObjectNameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_privFunctionObjectNameList
	return p
}

func InitEmptyPrivFunctionObjectNameListContext(p *PrivFunctionObjectNameListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_privFunctionObjectNameList
}

func (*PrivFunctionObjectNameListContext) IsPrivFunctionObjectNameListContext() {}

func NewPrivFunctionObjectNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivFunctionObjectNameListContext {
	var p = new(PrivFunctionObjectNameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_privFunctionObjectNameList

	return p
}

func (s *PrivFunctionObjectNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivFunctionObjectNameListContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *PrivFunctionObjectNameListContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *PrivFunctionObjectNameListContext) AllTypeList() []ITypeListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeListContext); ok {
			len++
		}
	}

	tst := make([]ITypeListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeListContext); ok {
			tst[i] = t.(ITypeListContext)
			i++
		}
	}

	return tst
}

func (s *PrivFunctionObjectNameListContext) TypeList(i int) ITypeListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *PrivFunctionObjectNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivFunctionObjectNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivFunctionObjectNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPrivFunctionObjectNameList(s)
	}
}

func (s *PrivFunctionObjectNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPrivFunctionObjectNameList(s)
	}
}

func (s *PrivFunctionObjectNameListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPrivFunctionObjectNameList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PrivFunctionObjectNameList() (localctx IPrivFunctionObjectNameListContext) {
	localctx = NewPrivFunctionObjectNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, DorisSQLParserParserRULE_privFunctionObjectNameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5000)
		p.QualifiedName()
	}
	{
		p.SetState(5001)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5002)
		p.TypeList()
	}
	{
		p.SetState(5003)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5012)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(5004)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5005)
			p.QualifiedName()
		}
		{
			p.SetState(5006)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5007)
			p.TypeList()
		}
		{
			p.SetState(5008)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(5014)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeTypeListContext is an interface to support dynamic dispatch.
type IPrivilegeTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrivilegeType() []IPrivilegeTypeContext
	PrivilegeType(i int) IPrivilegeTypeContext

	// IsPrivilegeTypeListContext differentiates from other interfaces.
	IsPrivilegeTypeListContext()
}

type PrivilegeTypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeTypeListContext() *PrivilegeTypeListContext {
	var p = new(PrivilegeTypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_privilegeTypeList
	return p
}

func InitEmptyPrivilegeTypeListContext(p *PrivilegeTypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_privilegeTypeList
}

func (*PrivilegeTypeListContext) IsPrivilegeTypeListContext() {}

func NewPrivilegeTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeTypeListContext {
	var p = new(PrivilegeTypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_privilegeTypeList

	return p
}

func (s *PrivilegeTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeTypeListContext) AllPrivilegeType() []IPrivilegeTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivilegeTypeContext); ok {
			len++
		}
	}

	tst := make([]IPrivilegeTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivilegeTypeContext); ok {
			tst[i] = t.(IPrivilegeTypeContext)
			i++
		}
	}

	return tst
}

func (s *PrivilegeTypeListContext) PrivilegeType(i int) IPrivilegeTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeContext)
}

func (s *PrivilegeTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPrivilegeTypeList(s)
	}
}

func (s *PrivilegeTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPrivilegeTypeList(s)
	}
}

func (s *PrivilegeTypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPrivilegeTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PrivilegeTypeList() (localctx IPrivilegeTypeListContext) {
	localctx = NewPrivilegeTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, DorisSQLParserParserRULE_privilegeTypeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5015)
		p.PrivilegeType()
	}
	p.SetState(5020)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(5016)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5017)
			p.PrivilegeType()
		}

		p.SetState(5022)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeTypeContext is an interface to support dynamic dispatch.
type IPrivilegeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	APPLY() antlr.TerminalNode
	BLACKLIST() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	CNGROUP() antlr.TerminalNode
	PIPE() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	DROP() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	FILE() antlr.TerminalNode
	IMPERSONATE() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	GRANT() antlr.TerminalNode
	NODE() antlr.TerminalNode
	OPERATE() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	REPOSITORY() antlr.TerminalNode
	REFRESH() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	USAGE() antlr.TerminalNode

	// IsPrivilegeTypeContext differentiates from other interfaces.
	IsPrivilegeTypeContext()
}

type PrivilegeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeTypeContext() *PrivilegeTypeContext {
	var p = new(PrivilegeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_privilegeType
	return p
}

func InitEmptyPrivilegeTypeContext(p *PrivilegeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_privilegeType
}

func (*PrivilegeTypeContext) IsPrivilegeTypeContext() {}

func NewPrivilegeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeTypeContext {
	var p = new(PrivilegeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_privilegeType

	return p
}

func (s *PrivilegeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeTypeContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, 0)
}

func (s *PrivilegeTypeContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPRIVILEGES, 0)
}

func (s *PrivilegeTypeContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *PrivilegeTypeContext) APPLY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAPPLY, 0)
}

func (s *PrivilegeTypeContext) BLACKLIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBLACKLIST, 0)
}

func (s *PrivilegeTypeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *PrivilegeTypeContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATABASE, 0)
}

func (s *PrivilegeTypeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *PrivilegeTypeContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVIEW, 0)
}

func (s *PrivilegeTypeContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFUNCTION, 0)
}

func (s *PrivilegeTypeContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGLOBAL, 0)
}

func (s *PrivilegeTypeContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMATERIALIZED, 0)
}

func (s *PrivilegeTypeContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRESOURCE, 0)
}

func (s *PrivilegeTypeContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGROUP, 0)
}

func (s *PrivilegeTypeContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXTERNAL, 0)
}

func (s *PrivilegeTypeContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCATALOG, 0)
}

func (s *PrivilegeTypeContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTORAGE, 0)
}

func (s *PrivilegeTypeContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVOLUME, 0)
}

func (s *PrivilegeTypeContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWAREHOUSE, 0)
}

func (s *PrivilegeTypeContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCNGROUP, 0)
}

func (s *PrivilegeTypeContext) PIPE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPIPE, 0)
}

func (s *PrivilegeTypeContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDELETE, 0)
}

func (s *PrivilegeTypeContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *PrivilegeTypeContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXPORT, 0)
}

func (s *PrivilegeTypeContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFILE, 0)
}

func (s *PrivilegeTypeContext) IMPERSONATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIMPERSONATE, 0)
}

func (s *PrivilegeTypeContext) INSERT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINSERT, 0)
}

func (s *PrivilegeTypeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGRANT, 0)
}

func (s *PrivilegeTypeContext) NODE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNODE, 0)
}

func (s *PrivilegeTypeContext) OPERATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOPERATE, 0)
}

func (s *PrivilegeTypeContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPLUGIN, 0)
}

func (s *PrivilegeTypeContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPOSITORY, 0)
}

func (s *PrivilegeTypeContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREFRESH, 0)
}

func (s *PrivilegeTypeContext) SELECT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSELECT, 0)
}

func (s *PrivilegeTypeContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUPDATE, 0)
}

func (s *PrivilegeTypeContext) USAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSAGE, 0)
}

func (s *PrivilegeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPrivilegeType(s)
	}
}

func (s *PrivilegeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPrivilegeType(s)
	}
}

func (s *PrivilegeTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPrivilegeType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PrivilegeType() (localctx IPrivilegeTypeContext) {
	localctx = NewPrivilegeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, DorisSQLParserParserRULE_privilegeType)
	var _la int

	p.SetState(5066)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserALL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5023)
			p.Match(DorisSQLParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5025)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserPRIVILEGES {
			{
				p.SetState(5024)
				p.Match(DorisSQLParserParserPRIVILEGES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DorisSQLParserParserALTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5027)
			p.Match(DorisSQLParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserAPPLY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5028)
			p.Match(DorisSQLParserParserAPPLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserBLACKLIST:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5029)
			p.Match(DorisSQLParserParserBLACKLIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserCREATE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5030)
			p.Match(DorisSQLParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5049)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 545, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5031)
				p.Match(DorisSQLParserParserDATABASE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(5032)
				p.Match(DorisSQLParserParserTABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(5033)
				p.Match(DorisSQLParserParserVIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 4:
			{
				p.SetState(5034)
				p.Match(DorisSQLParserParserFUNCTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 5:
			{
				p.SetState(5035)
				p.Match(DorisSQLParserParserGLOBAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5036)
				p.Match(DorisSQLParserParserFUNCTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 6:
			{
				p.SetState(5037)
				p.Match(DorisSQLParserParserMATERIALIZED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5038)
				p.Match(DorisSQLParserParserVIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 7:
			{
				p.SetState(5039)
				p.Match(DorisSQLParserParserRESOURCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 8:
			{
				p.SetState(5040)
				p.Match(DorisSQLParserParserRESOURCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5041)
				p.Match(DorisSQLParserParserGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 9:
			{
				p.SetState(5042)
				p.Match(DorisSQLParserParserEXTERNAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5043)
				p.Match(DorisSQLParserParserCATALOG)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 10:
			{
				p.SetState(5044)
				p.Match(DorisSQLParserParserSTORAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5045)
				p.Match(DorisSQLParserParserVOLUME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 11:
			{
				p.SetState(5046)
				p.Match(DorisSQLParserParserWAREHOUSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 12:
			{
				p.SetState(5047)
				p.Match(DorisSQLParserParserCNGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 13:
			{
				p.SetState(5048)
				p.Match(DorisSQLParserParserPIPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case DorisSQLParserParserDELETE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5051)
			p.Match(DorisSQLParserParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserDROP:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5052)
			p.Match(DorisSQLParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserEXPORT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5053)
			p.Match(DorisSQLParserParserEXPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserFILE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5054)
			p.Match(DorisSQLParserParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserIMPERSONATE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5055)
			p.Match(DorisSQLParserParserIMPERSONATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserINSERT:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5056)
			p.Match(DorisSQLParserParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserGRANT:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5057)
			p.Match(DorisSQLParserParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserNODE:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5058)
			p.Match(DorisSQLParserParserNODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserOPERATE:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5059)
			p.Match(DorisSQLParserParserOPERATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserPLUGIN:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(5060)
			p.Match(DorisSQLParserParserPLUGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserREPOSITORY:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(5061)
			p.Match(DorisSQLParserParserREPOSITORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserREFRESH:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(5062)
			p.Match(DorisSQLParserParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserSELECT:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(5063)
			p.Match(DorisSQLParserParserSELECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserUPDATE:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(5064)
			p.Match(DorisSQLParserParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserUSAGE:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(5065)
			p.Match(DorisSQLParserParserUSAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivObjectTypeContext is an interface to support dynamic dispatch.
type IPrivObjectTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CATALOG() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	PIPE() antlr.TerminalNode

	// IsPrivObjectTypeContext differentiates from other interfaces.
	IsPrivObjectTypeContext()
}

type PrivObjectTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivObjectTypeContext() *PrivObjectTypeContext {
	var p = new(PrivObjectTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_privObjectType
	return p
}

func InitEmptyPrivObjectTypeContext(p *PrivObjectTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_privObjectType
}

func (*PrivObjectTypeContext) IsPrivObjectTypeContext() {}

func NewPrivObjectTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivObjectTypeContext {
	var p = new(PrivObjectTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_privObjectType

	return p
}

func (s *PrivObjectTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivObjectTypeContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCATALOG, 0)
}

func (s *PrivObjectTypeContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATABASE, 0)
}

func (s *PrivObjectTypeContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMATERIALIZED, 0)
}

func (s *PrivObjectTypeContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVIEW, 0)
}

func (s *PrivObjectTypeContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRESOURCE, 0)
}

func (s *PrivObjectTypeContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGROUP, 0)
}

func (s *PrivObjectTypeContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTORAGE, 0)
}

func (s *PrivObjectTypeContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVOLUME, 0)
}

func (s *PrivObjectTypeContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSYSTEM, 0)
}

func (s *PrivObjectTypeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *PrivObjectTypeContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWAREHOUSE, 0)
}

func (s *PrivObjectTypeContext) PIPE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPIPE, 0)
}

func (s *PrivObjectTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivObjectTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivObjectTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPrivObjectType(s)
	}
}

func (s *PrivObjectTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPrivObjectType(s)
	}
}

func (s *PrivObjectTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPrivObjectType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PrivObjectType() (localctx IPrivObjectTypeContext) {
	localctx = NewPrivObjectTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, DorisSQLParserParserRULE_privObjectType)
	p.SetState(5082)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 547, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5068)
			p.Match(DorisSQLParserParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5069)
			p.Match(DorisSQLParserParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5070)
			p.Match(DorisSQLParserParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5071)
			p.Match(DorisSQLParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5072)
			p.Match(DorisSQLParserParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5073)
			p.Match(DorisSQLParserParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5074)
			p.Match(DorisSQLParserParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5075)
			p.Match(DorisSQLParserParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5076)
			p.Match(DorisSQLParserParserVOLUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5077)
			p.Match(DorisSQLParserParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5078)
			p.Match(DorisSQLParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5079)
			p.Match(DorisSQLParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5080)
			p.Match(DorisSQLParserParserWAREHOUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5081)
			p.Match(DorisSQLParserParserPIPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivObjectTypePluralContext is an interface to support dynamic dispatch.
type IPrivObjectTypePluralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CATALOGS() antlr.TerminalNode
	DATABASES() antlr.TerminalNode
	FUNCTIONS() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEWS() antlr.TerminalNode
	POLICIES() antlr.TerminalNode
	RESOURCES() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUPS() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUMES() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	USERS() antlr.TerminalNode
	WAREHOUSES() antlr.TerminalNode
	PIPES() antlr.TerminalNode

	// IsPrivObjectTypePluralContext differentiates from other interfaces.
	IsPrivObjectTypePluralContext()
}

type PrivObjectTypePluralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivObjectTypePluralContext() *PrivObjectTypePluralContext {
	var p = new(PrivObjectTypePluralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_privObjectTypePlural
	return p
}

func InitEmptyPrivObjectTypePluralContext(p *PrivObjectTypePluralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_privObjectTypePlural
}

func (*PrivObjectTypePluralContext) IsPrivObjectTypePluralContext() {}

func NewPrivObjectTypePluralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivObjectTypePluralContext {
	var p = new(PrivObjectTypePluralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_privObjectTypePlural

	return p
}

func (s *PrivObjectTypePluralContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivObjectTypePluralContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCATALOGS, 0)
}

func (s *PrivObjectTypePluralContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATABASES, 0)
}

func (s *PrivObjectTypePluralContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFUNCTIONS, 0)
}

func (s *PrivObjectTypePluralContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGLOBAL, 0)
}

func (s *PrivObjectTypePluralContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMATERIALIZED, 0)
}

func (s *PrivObjectTypePluralContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVIEWS, 0)
}

func (s *PrivObjectTypePluralContext) POLICIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPOLICIES, 0)
}

func (s *PrivObjectTypePluralContext) RESOURCES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRESOURCES, 0)
}

func (s *PrivObjectTypePluralContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRESOURCE, 0)
}

func (s *PrivObjectTypePluralContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGROUPS, 0)
}

func (s *PrivObjectTypePluralContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTORAGE, 0)
}

func (s *PrivObjectTypePluralContext) VOLUMES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVOLUMES, 0)
}

func (s *PrivObjectTypePluralContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLES, 0)
}

func (s *PrivObjectTypePluralContext) USERS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSERS, 0)
}

func (s *PrivObjectTypePluralContext) WAREHOUSES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWAREHOUSES, 0)
}

func (s *PrivObjectTypePluralContext) PIPES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPIPES, 0)
}

func (s *PrivObjectTypePluralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivObjectTypePluralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivObjectTypePluralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPrivObjectTypePlural(s)
	}
}

func (s *PrivObjectTypePluralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPrivObjectTypePlural(s)
	}
}

func (s *PrivObjectTypePluralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPrivObjectTypePlural(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PrivObjectTypePlural() (localctx IPrivObjectTypePluralContext) {
	localctx = NewPrivObjectTypePluralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, DorisSQLParserParserRULE_privObjectTypePlural)
	p.SetState(5102)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserCATALOGS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5084)
			p.Match(DorisSQLParserParserCATALOGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserDATABASES:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5085)
			p.Match(DorisSQLParserParserDATABASES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserFUNCTIONS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5086)
			p.Match(DorisSQLParserParserFUNCTIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserGLOBAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5087)
			p.Match(DorisSQLParserParserGLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5088)
			p.Match(DorisSQLParserParserFUNCTIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserMATERIALIZED:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5089)
			p.Match(DorisSQLParserParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5090)
			p.Match(DorisSQLParserParserVIEWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserPOLICIES:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5091)
			p.Match(DorisSQLParserParserPOLICIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserRESOURCES:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5092)
			p.Match(DorisSQLParserParserRESOURCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserRESOURCE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5093)
			p.Match(DorisSQLParserParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5094)
			p.Match(DorisSQLParserParserGROUPS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserSTORAGE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5095)
			p.Match(DorisSQLParserParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5096)
			p.Match(DorisSQLParserParserVOLUMES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserTABLES:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5097)
			p.Match(DorisSQLParserParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserUSERS:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5098)
			p.Match(DorisSQLParserParserUSERS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserVIEWS:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5099)
			p.Match(DorisSQLParserParserVIEWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserWAREHOUSES:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5100)
			p.Match(DorisSQLParserParserWAREHOUSES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserPIPES:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5101)
			p.Match(DorisSQLParserParserPIPES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateSecurityIntegrationStatementContext is an interface to support dynamic dispatch.
type ICreateSecurityIntegrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	INTEGRATION() antlr.TerminalNode
	Identifier() IIdentifierContext
	Properties() IPropertiesContext

	// IsCreateSecurityIntegrationStatementContext differentiates from other interfaces.
	IsCreateSecurityIntegrationStatementContext()
}

type CreateSecurityIntegrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateSecurityIntegrationStatementContext() *CreateSecurityIntegrationStatementContext {
	var p = new(CreateSecurityIntegrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createSecurityIntegrationStatement
	return p
}

func InitEmptyCreateSecurityIntegrationStatementContext(p *CreateSecurityIntegrationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createSecurityIntegrationStatement
}

func (*CreateSecurityIntegrationStatementContext) IsCreateSecurityIntegrationStatementContext() {}

func NewCreateSecurityIntegrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateSecurityIntegrationStatementContext {
	var p = new(CreateSecurityIntegrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createSecurityIntegrationStatement

	return p
}

func (s *CreateSecurityIntegrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateSecurityIntegrationStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateSecurityIntegrationStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSECURITY, 0)
}

func (s *CreateSecurityIntegrationStatementContext) INTEGRATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGRATION, 0)
}

func (s *CreateSecurityIntegrationStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateSecurityIntegrationStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateSecurityIntegrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateSecurityIntegrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateSecurityIntegrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateSecurityIntegrationStatement(s)
	}
}

func (s *CreateSecurityIntegrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateSecurityIntegrationStatement(s)
	}
}

func (s *CreateSecurityIntegrationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateSecurityIntegrationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateSecurityIntegrationStatement() (localctx ICreateSecurityIntegrationStatementContext) {
	localctx = NewCreateSecurityIntegrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, DorisSQLParserParserRULE_createSecurityIntegrationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5104)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5105)
		p.Match(DorisSQLParserParserSECURITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5106)
		p.Match(DorisSQLParserParserINTEGRATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5107)
		p.Identifier()
	}
	{
		p.SetState(5108)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterSecurityIntegrationStatementContext is an interface to support dynamic dispatch.
type IAlterSecurityIntegrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	INTEGRATION() antlr.TerminalNode
	Identifier() IIdentifierContext
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsAlterSecurityIntegrationStatementContext differentiates from other interfaces.
	IsAlterSecurityIntegrationStatementContext()
}

type AlterSecurityIntegrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterSecurityIntegrationStatementContext() *AlterSecurityIntegrationStatementContext {
	var p = new(AlterSecurityIntegrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterSecurityIntegrationStatement
	return p
}

func InitEmptyAlterSecurityIntegrationStatementContext(p *AlterSecurityIntegrationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterSecurityIntegrationStatement
}

func (*AlterSecurityIntegrationStatementContext) IsAlterSecurityIntegrationStatementContext() {}

func NewAlterSecurityIntegrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterSecurityIntegrationStatementContext {
	var p = new(AlterSecurityIntegrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_alterSecurityIntegrationStatement

	return p
}

func (s *AlterSecurityIntegrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterSecurityIntegrationStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *AlterSecurityIntegrationStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSECURITY, 0)
}

func (s *AlterSecurityIntegrationStatementContext) INTEGRATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGRATION, 0)
}

func (s *AlterSecurityIntegrationStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterSecurityIntegrationStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *AlterSecurityIntegrationStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *AlterSecurityIntegrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSecurityIntegrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterSecurityIntegrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAlterSecurityIntegrationStatement(s)
	}
}

func (s *AlterSecurityIntegrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAlterSecurityIntegrationStatement(s)
	}
}

func (s *AlterSecurityIntegrationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAlterSecurityIntegrationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AlterSecurityIntegrationStatement() (localctx IAlterSecurityIntegrationStatementContext) {
	localctx = NewAlterSecurityIntegrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, DorisSQLParserParserRULE_alterSecurityIntegrationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5110)
		p.Match(DorisSQLParserParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5111)
		p.Match(DorisSQLParserParserSECURITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5112)
		p.Match(DorisSQLParserParserINTEGRATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5113)
		p.Identifier()
	}
	{
		p.SetState(5114)
		p.Match(DorisSQLParserParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5115)
		p.PropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropSecurityIntegrationStatementContext is an interface to support dynamic dispatch.
type IDropSecurityIntegrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	INTEGRATION() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDropSecurityIntegrationStatementContext differentiates from other interfaces.
	IsDropSecurityIntegrationStatementContext()
}

type DropSecurityIntegrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropSecurityIntegrationStatementContext() *DropSecurityIntegrationStatementContext {
	var p = new(DropSecurityIntegrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropSecurityIntegrationStatement
	return p
}

func InitEmptyDropSecurityIntegrationStatementContext(p *DropSecurityIntegrationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropSecurityIntegrationStatement
}

func (*DropSecurityIntegrationStatementContext) IsDropSecurityIntegrationStatementContext() {}

func NewDropSecurityIntegrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropSecurityIntegrationStatementContext {
	var p = new(DropSecurityIntegrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropSecurityIntegrationStatement

	return p
}

func (s *DropSecurityIntegrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropSecurityIntegrationStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropSecurityIntegrationStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSECURITY, 0)
}

func (s *DropSecurityIntegrationStatementContext) INTEGRATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGRATION, 0)
}

func (s *DropSecurityIntegrationStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropSecurityIntegrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropSecurityIntegrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropSecurityIntegrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropSecurityIntegrationStatement(s)
	}
}

func (s *DropSecurityIntegrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropSecurityIntegrationStatement(s)
	}
}

func (s *DropSecurityIntegrationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropSecurityIntegrationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropSecurityIntegrationStatement() (localctx IDropSecurityIntegrationStatementContext) {
	localctx = NewDropSecurityIntegrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, DorisSQLParserParserRULE_dropSecurityIntegrationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5117)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5118)
		p.Match(DorisSQLParserParserSECURITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5119)
		p.Match(DorisSQLParserParserINTEGRATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5120)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowSecurityIntegrationStatementContext is an interface to support dynamic dispatch.
type IShowSecurityIntegrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	INTEGRATIONS() antlr.TerminalNode

	// IsShowSecurityIntegrationStatementContext differentiates from other interfaces.
	IsShowSecurityIntegrationStatementContext()
}

type ShowSecurityIntegrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowSecurityIntegrationStatementContext() *ShowSecurityIntegrationStatementContext {
	var p = new(ShowSecurityIntegrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showSecurityIntegrationStatement
	return p
}

func InitEmptyShowSecurityIntegrationStatementContext(p *ShowSecurityIntegrationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showSecurityIntegrationStatement
}

func (*ShowSecurityIntegrationStatementContext) IsShowSecurityIntegrationStatementContext() {}

func NewShowSecurityIntegrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowSecurityIntegrationStatementContext {
	var p = new(ShowSecurityIntegrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showSecurityIntegrationStatement

	return p
}

func (s *ShowSecurityIntegrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowSecurityIntegrationStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowSecurityIntegrationStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSECURITY, 0)
}

func (s *ShowSecurityIntegrationStatementContext) INTEGRATIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGRATIONS, 0)
}

func (s *ShowSecurityIntegrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSecurityIntegrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowSecurityIntegrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowSecurityIntegrationStatement(s)
	}
}

func (s *ShowSecurityIntegrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowSecurityIntegrationStatement(s)
	}
}

func (s *ShowSecurityIntegrationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowSecurityIntegrationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowSecurityIntegrationStatement() (localctx IShowSecurityIntegrationStatementContext) {
	localctx = NewShowSecurityIntegrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, DorisSQLParserParserRULE_showSecurityIntegrationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5122)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5123)
		p.Match(DorisSQLParserParserSECURITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5124)
		p.Match(DorisSQLParserParserINTEGRATIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCreateSecurityIntegrationStatementContext is an interface to support dynamic dispatch.
type IShowCreateSecurityIntegrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	INTEGRATION() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsShowCreateSecurityIntegrationStatementContext differentiates from other interfaces.
	IsShowCreateSecurityIntegrationStatementContext()
}

type ShowCreateSecurityIntegrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowCreateSecurityIntegrationStatementContext() *ShowCreateSecurityIntegrationStatementContext {
	var p = new(ShowCreateSecurityIntegrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showCreateSecurityIntegrationStatement
	return p
}

func InitEmptyShowCreateSecurityIntegrationStatementContext(p *ShowCreateSecurityIntegrationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showCreateSecurityIntegrationStatement
}

func (*ShowCreateSecurityIntegrationStatementContext) IsShowCreateSecurityIntegrationStatementContext() {
}

func NewShowCreateSecurityIntegrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCreateSecurityIntegrationStatementContext {
	var p = new(ShowCreateSecurityIntegrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showCreateSecurityIntegrationStatement

	return p
}

func (s *ShowCreateSecurityIntegrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCreateSecurityIntegrationStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowCreateSecurityIntegrationStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *ShowCreateSecurityIntegrationStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSECURITY, 0)
}

func (s *ShowCreateSecurityIntegrationStatementContext) INTEGRATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGRATION, 0)
}

func (s *ShowCreateSecurityIntegrationStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateSecurityIntegrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateSecurityIntegrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCreateSecurityIntegrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowCreateSecurityIntegrationStatement(s)
	}
}

func (s *ShowCreateSecurityIntegrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowCreateSecurityIntegrationStatement(s)
	}
}

func (s *ShowCreateSecurityIntegrationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowCreateSecurityIntegrationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowCreateSecurityIntegrationStatement() (localctx IShowCreateSecurityIntegrationStatementContext) {
	localctx = NewShowCreateSecurityIntegrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, DorisSQLParserParserRULE_showCreateSecurityIntegrationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5126)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5127)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5128)
		p.Match(DorisSQLParserParserSECURITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5129)
		p.Match(DorisSQLParserParserINTEGRATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5130)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateGroupProviderStatementContext is an interface to support dynamic dispatch.
type ICreateGroupProviderStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	PROVIDER() antlr.TerminalNode
	Identifier() IIdentifierContext
	Properties() IPropertiesContext

	// IsCreateGroupProviderStatementContext differentiates from other interfaces.
	IsCreateGroupProviderStatementContext()
}

type CreateGroupProviderStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateGroupProviderStatementContext() *CreateGroupProviderStatementContext {
	var p = new(CreateGroupProviderStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createGroupProviderStatement
	return p
}

func InitEmptyCreateGroupProviderStatementContext(p *CreateGroupProviderStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createGroupProviderStatement
}

func (*CreateGroupProviderStatementContext) IsCreateGroupProviderStatementContext() {}

func NewCreateGroupProviderStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateGroupProviderStatementContext {
	var p = new(CreateGroupProviderStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createGroupProviderStatement

	return p
}

func (s *CreateGroupProviderStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateGroupProviderStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateGroupProviderStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGROUP, 0)
}

func (s *CreateGroupProviderStatementContext) PROVIDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROVIDER, 0)
}

func (s *CreateGroupProviderStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateGroupProviderStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateGroupProviderStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateGroupProviderStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateGroupProviderStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateGroupProviderStatement(s)
	}
}

func (s *CreateGroupProviderStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateGroupProviderStatement(s)
	}
}

func (s *CreateGroupProviderStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateGroupProviderStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateGroupProviderStatement() (localctx ICreateGroupProviderStatementContext) {
	localctx = NewCreateGroupProviderStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, DorisSQLParserParserRULE_createGroupProviderStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5132)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5133)
		p.Match(DorisSQLParserParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5134)
		p.Match(DorisSQLParserParserPROVIDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5135)
		p.Identifier()
	}
	{
		p.SetState(5136)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropGroupProviderStatementContext is an interface to support dynamic dispatch.
type IDropGroupProviderStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	PROVIDER() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDropGroupProviderStatementContext differentiates from other interfaces.
	IsDropGroupProviderStatementContext()
}

type DropGroupProviderStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropGroupProviderStatementContext() *DropGroupProviderStatementContext {
	var p = new(DropGroupProviderStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropGroupProviderStatement
	return p
}

func InitEmptyDropGroupProviderStatementContext(p *DropGroupProviderStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropGroupProviderStatement
}

func (*DropGroupProviderStatementContext) IsDropGroupProviderStatementContext() {}

func NewDropGroupProviderStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropGroupProviderStatementContext {
	var p = new(DropGroupProviderStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropGroupProviderStatement

	return p
}

func (s *DropGroupProviderStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropGroupProviderStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropGroupProviderStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGROUP, 0)
}

func (s *DropGroupProviderStatementContext) PROVIDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROVIDER, 0)
}

func (s *DropGroupProviderStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropGroupProviderStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropGroupProviderStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropGroupProviderStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropGroupProviderStatement(s)
	}
}

func (s *DropGroupProviderStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropGroupProviderStatement(s)
	}
}

func (s *DropGroupProviderStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropGroupProviderStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropGroupProviderStatement() (localctx IDropGroupProviderStatementContext) {
	localctx = NewDropGroupProviderStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, DorisSQLParserParserRULE_dropGroupProviderStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5138)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5139)
		p.Match(DorisSQLParserParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5140)
		p.Match(DorisSQLParserParserPROVIDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5141)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowGroupProvidersStatementContext is an interface to support dynamic dispatch.
type IShowGroupProvidersStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	PROVIDERS() antlr.TerminalNode

	// IsShowGroupProvidersStatementContext differentiates from other interfaces.
	IsShowGroupProvidersStatementContext()
}

type ShowGroupProvidersStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowGroupProvidersStatementContext() *ShowGroupProvidersStatementContext {
	var p = new(ShowGroupProvidersStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showGroupProvidersStatement
	return p
}

func InitEmptyShowGroupProvidersStatementContext(p *ShowGroupProvidersStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showGroupProvidersStatement
}

func (*ShowGroupProvidersStatementContext) IsShowGroupProvidersStatementContext() {}

func NewShowGroupProvidersStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowGroupProvidersStatementContext {
	var p = new(ShowGroupProvidersStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showGroupProvidersStatement

	return p
}

func (s *ShowGroupProvidersStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowGroupProvidersStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowGroupProvidersStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGROUP, 0)
}

func (s *ShowGroupProvidersStatementContext) PROVIDERS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROVIDERS, 0)
}

func (s *ShowGroupProvidersStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGroupProvidersStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowGroupProvidersStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowGroupProvidersStatement(s)
	}
}

func (s *ShowGroupProvidersStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowGroupProvidersStatement(s)
	}
}

func (s *ShowGroupProvidersStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowGroupProvidersStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowGroupProvidersStatement() (localctx IShowGroupProvidersStatementContext) {
	localctx = NewShowGroupProvidersStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, DorisSQLParserParserRULE_showGroupProvidersStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5143)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5144)
		p.Match(DorisSQLParserParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5145)
		p.Match(DorisSQLParserParserPROVIDERS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCreateGroupProviderStatementContext is an interface to support dynamic dispatch.
type IShowCreateGroupProviderStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	PROVIDER() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsShowCreateGroupProviderStatementContext differentiates from other interfaces.
	IsShowCreateGroupProviderStatementContext()
}

type ShowCreateGroupProviderStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowCreateGroupProviderStatementContext() *ShowCreateGroupProviderStatementContext {
	var p = new(ShowCreateGroupProviderStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showCreateGroupProviderStatement
	return p
}

func InitEmptyShowCreateGroupProviderStatementContext(p *ShowCreateGroupProviderStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showCreateGroupProviderStatement
}

func (*ShowCreateGroupProviderStatementContext) IsShowCreateGroupProviderStatementContext() {}

func NewShowCreateGroupProviderStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCreateGroupProviderStatementContext {
	var p = new(ShowCreateGroupProviderStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showCreateGroupProviderStatement

	return p
}

func (s *ShowCreateGroupProviderStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCreateGroupProviderStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowCreateGroupProviderStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *ShowCreateGroupProviderStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGROUP, 0)
}

func (s *ShowCreateGroupProviderStatementContext) PROVIDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROVIDER, 0)
}

func (s *ShowCreateGroupProviderStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateGroupProviderStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateGroupProviderStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCreateGroupProviderStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowCreateGroupProviderStatement(s)
	}
}

func (s *ShowCreateGroupProviderStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowCreateGroupProviderStatement(s)
	}
}

func (s *ShowCreateGroupProviderStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowCreateGroupProviderStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowCreateGroupProviderStatement() (localctx IShowCreateGroupProviderStatementContext) {
	localctx = NewShowCreateGroupProviderStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, DorisSQLParserParserRULE_showCreateGroupProviderStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5147)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5148)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5149)
		p.Match(DorisSQLParserParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5150)
		p.Match(DorisSQLParserParserPROVIDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5151)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBackupStatementContext is an interface to support dynamic dispatch.
type IBackupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDbName returns the dbName rule contexts.
	GetDbName() IIdentifierContext

	// GetRepoName returns the repoName rule contexts.
	GetRepoName() IIdentifierContext

	// SetDbName sets the dbName rule contexts.
	SetDbName(IIdentifierContext)

	// SetRepoName sets the repoName rule contexts.
	SetRepoName(IIdentifierContext)

	// Getter signatures
	BACKUP() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	TO() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	ALL() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	CATALOGS() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	DATABASE() antlr.TerminalNode
	ON() antlr.TerminalNode
	AllBackupRestoreObjectDesc() []IBackupRestoreObjectDescContext
	BackupRestoreObjectDesc(i int) IBackupRestoreObjectDescContext
	PROPERTIES() antlr.TerminalNode
	PropertyList() IPropertyListContext
	CATALOG() antlr.TerminalNode

	// IsBackupStatementContext differentiates from other interfaces.
	IsBackupStatementContext()
}

type BackupStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	dbName   IIdentifierContext
	repoName IIdentifierContext
}

func NewEmptyBackupStatementContext() *BackupStatementContext {
	var p = new(BackupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_backupStatement
	return p
}

func InitEmptyBackupStatementContext(p *BackupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_backupStatement
}

func (*BackupStatementContext) IsBackupStatementContext() {}

func NewBackupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BackupStatementContext {
	var p = new(BackupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_backupStatement

	return p
}

func (s *BackupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BackupStatementContext) GetDbName() IIdentifierContext { return s.dbName }

func (s *BackupStatementContext) GetRepoName() IIdentifierContext { return s.repoName }

func (s *BackupStatementContext) SetDbName(v IIdentifierContext) { s.dbName = v }

func (s *BackupStatementContext) SetRepoName(v IIdentifierContext) { s.repoName = v }

func (s *BackupStatementContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBACKUP, 0)
}

func (s *BackupStatementContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSNAPSHOT, 0)
}

func (s *BackupStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *BackupStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTO, 0)
}

func (s *BackupStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *BackupStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BackupStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, 0)
}

func (s *BackupStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXTERNAL, 0)
}

func (s *BackupStatementContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCATALOGS, 0)
}

func (s *BackupStatementContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *BackupStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATABASE, 0)
}

func (s *BackupStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *BackupStatementContext) AllBackupRestoreObjectDesc() []IBackupRestoreObjectDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBackupRestoreObjectDescContext); ok {
			len++
		}
	}

	tst := make([]IBackupRestoreObjectDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBackupRestoreObjectDescContext); ok {
			tst[i] = t.(IBackupRestoreObjectDescContext)
			i++
		}
	}

	return tst
}

func (s *BackupStatementContext) BackupRestoreObjectDesc(i int) IBackupRestoreObjectDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackupRestoreObjectDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackupRestoreObjectDescContext)
}

func (s *BackupStatementContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROPERTIES, 0)
}

func (s *BackupStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *BackupStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCATALOG, 0)
}

func (s *BackupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BackupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterBackupStatement(s)
	}
}

func (s *BackupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitBackupStatement(s)
	}
}

func (s *BackupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitBackupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) BackupStatement() (localctx IBackupStatementContext) {
	localctx = NewBackupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, DorisSQLParserParserRULE_backupStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5153)
		p.Match(DorisSQLParserParserBACKUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5160)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserALL:
		{
			p.SetState(5154)
			p.Match(DorisSQLParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5155)
			p.Match(DorisSQLParserParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5156)
			p.Match(DorisSQLParserParserCATALOGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserEXTERNAL:
		{
			p.SetState(5157)
			p.Match(DorisSQLParserParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5158)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserCATALOG || _la == DorisSQLParserParserCATALOGS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5159)
			p.IdentifierList()
		}

	case DorisSQLParserParserDATABASE, DorisSQLParserParserSNAPSHOT:

	default:
	}
	p.SetState(5164)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserDATABASE {
		{
			p.SetState(5162)
			p.Match(DorisSQLParserParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5163)

			var _x = p.Identifier()

			localctx.(*BackupStatementContext).dbName = _x
		}

	}
	{
		p.SetState(5166)
		p.Match(DorisSQLParserParserSNAPSHOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5167)
		p.QualifiedName()
	}
	{
		p.SetState(5168)
		p.Match(DorisSQLParserParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5169)

		var _x = p.Identifier()

		localctx.(*BackupStatementContext).repoName = _x
	}
	p.SetState(5182)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserON {
		{
			p.SetState(5170)
			p.Match(DorisSQLParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5171)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5172)
			p.BackupRestoreObjectDesc()
		}
		p.SetState(5177)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(5173)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5174)
				p.BackupRestoreObjectDesc()
			}

			p.SetState(5179)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5180)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5186)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(5184)
			p.Match(DorisSQLParserParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5185)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelBackupStatementContext is an interface to support dynamic dispatch.
type ICancelBackupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	BACKUP() antlr.TerminalNode
	Identifier() IIdentifierContext
	FOR() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode

	// IsCancelBackupStatementContext differentiates from other interfaces.
	IsCancelBackupStatementContext()
}

type CancelBackupStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelBackupStatementContext() *CancelBackupStatementContext {
	var p = new(CancelBackupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cancelBackupStatement
	return p
}

func InitEmptyCancelBackupStatementContext(p *CancelBackupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cancelBackupStatement
}

func (*CancelBackupStatementContext) IsCancelBackupStatementContext() {}

func NewCancelBackupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelBackupStatementContext {
	var p = new(CancelBackupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_cancelBackupStatement

	return p
}

func (s *CancelBackupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelBackupStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCANCEL, 0)
}

func (s *CancelBackupStatementContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBACKUP, 0)
}

func (s *CancelBackupStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelBackupStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFOR, 0)
}

func (s *CancelBackupStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXTERNAL, 0)
}

func (s *CancelBackupStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCATALOG, 0)
}

func (s *CancelBackupStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *CancelBackupStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *CancelBackupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelBackupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelBackupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCancelBackupStatement(s)
	}
}

func (s *CancelBackupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCancelBackupStatement(s)
	}
}

func (s *CancelBackupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCancelBackupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CancelBackupStatement() (localctx ICancelBackupStatementContext) {
	localctx = NewCancelBackupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, DorisSQLParserParserRULE_cancelBackupStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5188)
		p.Match(DorisSQLParserParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5189)
		p.Match(DorisSQLParserParserBACKUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5195)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserFROM, DorisSQLParserParserIN:
		{
			p.SetState(5190)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5191)
			p.Identifier()
		}

	case DorisSQLParserParserFOR:
		{
			p.SetState(5192)
			p.Match(DorisSQLParserParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5193)
			p.Match(DorisSQLParserParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5194)
			p.Match(DorisSQLParserParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserEOF, DorisSQLParserParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowBackupStatementContext is an interface to support dynamic dispatch.
type IShowBackupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	BACKUP() antlr.TerminalNode
	Identifier() IIdentifierContext
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode

	// IsShowBackupStatementContext differentiates from other interfaces.
	IsShowBackupStatementContext()
}

type ShowBackupStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowBackupStatementContext() *ShowBackupStatementContext {
	var p = new(ShowBackupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showBackupStatement
	return p
}

func InitEmptyShowBackupStatementContext(p *ShowBackupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showBackupStatement
}

func (*ShowBackupStatementContext) IsShowBackupStatementContext() {}

func NewShowBackupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowBackupStatementContext {
	var p = new(ShowBackupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showBackupStatement

	return p
}

func (s *ShowBackupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowBackupStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowBackupStatementContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBACKUP, 0)
}

func (s *ShowBackupStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowBackupStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowBackupStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *ShowBackupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBackupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowBackupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowBackupStatement(s)
	}
}

func (s *ShowBackupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowBackupStatement(s)
	}
}

func (s *ShowBackupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowBackupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowBackupStatement() (localctx IShowBackupStatementContext) {
	localctx = NewShowBackupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, DorisSQLParserParserRULE_showBackupStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5197)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5198)
		p.Match(DorisSQLParserParserBACKUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5201)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN {
		{
			p.SetState(5199)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5200)
			p.Identifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRestoreStatementContext is an interface to support dynamic dispatch.
type IRestoreStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRepoName returns the repoName rule contexts.
	GetRepoName() IIdentifierContext

	// GetDbName returns the dbName rule contexts.
	GetDbName() IIdentifierContext

	// GetDbAlias returns the dbAlias rule contexts.
	GetDbAlias() IIdentifierContext

	// SetRepoName sets the repoName rule contexts.
	SetRepoName(IIdentifierContext)

	// SetDbName sets the dbName rule contexts.
	SetDbName(IIdentifierContext)

	// SetDbAlias sets the dbAlias rule contexts.
	SetDbAlias(IIdentifierContext)

	// Getter signatures
	RESTORE() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	FROM() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	ALL() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	CATALOGS() antlr.TerminalNode
	IdentifierWithAliasList() IIdentifierWithAliasListContext
	DATABASE() antlr.TerminalNode
	ON() antlr.TerminalNode
	AllBackupRestoreObjectDesc() []IBackupRestoreObjectDescContext
	BackupRestoreObjectDesc(i int) IBackupRestoreObjectDescContext
	PROPERTIES() antlr.TerminalNode
	PropertyList() IPropertyListContext
	CATALOG() antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsRestoreStatementContext differentiates from other interfaces.
	IsRestoreStatementContext()
}

type RestoreStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	repoName IIdentifierContext
	dbName   IIdentifierContext
	dbAlias  IIdentifierContext
}

func NewEmptyRestoreStatementContext() *RestoreStatementContext {
	var p = new(RestoreStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_restoreStatement
	return p
}

func InitEmptyRestoreStatementContext(p *RestoreStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_restoreStatement
}

func (*RestoreStatementContext) IsRestoreStatementContext() {}

func NewRestoreStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RestoreStatementContext {
	var p = new(RestoreStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_restoreStatement

	return p
}

func (s *RestoreStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RestoreStatementContext) GetRepoName() IIdentifierContext { return s.repoName }

func (s *RestoreStatementContext) GetDbName() IIdentifierContext { return s.dbName }

func (s *RestoreStatementContext) GetDbAlias() IIdentifierContext { return s.dbAlias }

func (s *RestoreStatementContext) SetRepoName(v IIdentifierContext) { s.repoName = v }

func (s *RestoreStatementContext) SetDbName(v IIdentifierContext) { s.dbName = v }

func (s *RestoreStatementContext) SetDbAlias(v IIdentifierContext) { s.dbAlias = v }

func (s *RestoreStatementContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRESTORE, 0)
}

func (s *RestoreStatementContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSNAPSHOT, 0)
}

func (s *RestoreStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RestoreStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *RestoreStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RestoreStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RestoreStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, 0)
}

func (s *RestoreStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXTERNAL, 0)
}

func (s *RestoreStatementContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCATALOGS, 0)
}

func (s *RestoreStatementContext) IdentifierWithAliasList() IIdentifierWithAliasListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierWithAliasListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierWithAliasListContext)
}

func (s *RestoreStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATABASE, 0)
}

func (s *RestoreStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *RestoreStatementContext) AllBackupRestoreObjectDesc() []IBackupRestoreObjectDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBackupRestoreObjectDescContext); ok {
			len++
		}
	}

	tst := make([]IBackupRestoreObjectDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBackupRestoreObjectDescContext); ok {
			tst[i] = t.(IBackupRestoreObjectDescContext)
			i++
		}
	}

	return tst
}

func (s *RestoreStatementContext) BackupRestoreObjectDesc(i int) IBackupRestoreObjectDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackupRestoreObjectDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackupRestoreObjectDescContext)
}

func (s *RestoreStatementContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROPERTIES, 0)
}

func (s *RestoreStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *RestoreStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCATALOG, 0)
}

func (s *RestoreStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *RestoreStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RestoreStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RestoreStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRestoreStatement(s)
	}
}

func (s *RestoreStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRestoreStatement(s)
	}
}

func (s *RestoreStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRestoreStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) RestoreStatement() (localctx IRestoreStatementContext) {
	localctx = NewRestoreStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, DorisSQLParserParserRULE_restoreStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5203)
		p.Match(DorisSQLParserParserRESTORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5204)
		p.Match(DorisSQLParserParserSNAPSHOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5205)
		p.QualifiedName()
	}
	{
		p.SetState(5206)
		p.Match(DorisSQLParserParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5207)

		var _x = p.Identifier()

		localctx.(*RestoreStatementContext).repoName = _x
	}
	p.SetState(5214)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserALL:
		{
			p.SetState(5208)
			p.Match(DorisSQLParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5209)
			p.Match(DorisSQLParserParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5210)
			p.Match(DorisSQLParserParserCATALOGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserEXTERNAL:
		{
			p.SetState(5211)
			p.Match(DorisSQLParserParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5212)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserCATALOG || _la == DorisSQLParserParserCATALOGS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5213)
			p.IdentifierWithAliasList()
		}

	case DorisSQLParserParserEOF, DorisSQLParserParserDATABASE, DorisSQLParserParserON, DorisSQLParserParserPROPERTIES, DorisSQLParserParserSEMICOLON:

	default:
	}
	p.SetState(5222)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserDATABASE {
		{
			p.SetState(5216)
			p.Match(DorisSQLParserParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5217)

			var _x = p.Identifier()

			localctx.(*RestoreStatementContext).dbName = _x
		}
		p.SetState(5220)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserAS {
			{
				p.SetState(5218)
				p.Match(DorisSQLParserParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5219)

				var _x = p.Identifier()

				localctx.(*RestoreStatementContext).dbAlias = _x
			}

		}

	}
	p.SetState(5236)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserON {
		{
			p.SetState(5224)
			p.Match(DorisSQLParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5225)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5226)
			p.BackupRestoreObjectDesc()
		}
		p.SetState(5231)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(5227)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5228)
				p.BackupRestoreObjectDesc()
			}

			p.SetState(5233)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5234)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5240)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(5238)
			p.Match(DorisSQLParserParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5239)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelRestoreStatementContext is an interface to support dynamic dispatch.
type ICancelRestoreStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	RESTORE() antlr.TerminalNode
	Identifier() IIdentifierContext
	FOR() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode

	// IsCancelRestoreStatementContext differentiates from other interfaces.
	IsCancelRestoreStatementContext()
}

type CancelRestoreStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelRestoreStatementContext() *CancelRestoreStatementContext {
	var p = new(CancelRestoreStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cancelRestoreStatement
	return p
}

func InitEmptyCancelRestoreStatementContext(p *CancelRestoreStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cancelRestoreStatement
}

func (*CancelRestoreStatementContext) IsCancelRestoreStatementContext() {}

func NewCancelRestoreStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelRestoreStatementContext {
	var p = new(CancelRestoreStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_cancelRestoreStatement

	return p
}

func (s *CancelRestoreStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelRestoreStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCANCEL, 0)
}

func (s *CancelRestoreStatementContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRESTORE, 0)
}

func (s *CancelRestoreStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelRestoreStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFOR, 0)
}

func (s *CancelRestoreStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXTERNAL, 0)
}

func (s *CancelRestoreStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCATALOG, 0)
}

func (s *CancelRestoreStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *CancelRestoreStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *CancelRestoreStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelRestoreStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelRestoreStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCancelRestoreStatement(s)
	}
}

func (s *CancelRestoreStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCancelRestoreStatement(s)
	}
}

func (s *CancelRestoreStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCancelRestoreStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CancelRestoreStatement() (localctx ICancelRestoreStatementContext) {
	localctx = NewCancelRestoreStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, DorisSQLParserParserRULE_cancelRestoreStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5242)
		p.Match(DorisSQLParserParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5243)
		p.Match(DorisSQLParserParserRESTORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5249)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserFROM, DorisSQLParserParserIN:
		{
			p.SetState(5244)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5245)
			p.Identifier()
		}

	case DorisSQLParserParserFOR:
		{
			p.SetState(5246)
			p.Match(DorisSQLParserParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5247)
			p.Match(DorisSQLParserParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5248)
			p.Match(DorisSQLParserParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserEOF, DorisSQLParserParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowRestoreStatementContext is an interface to support dynamic dispatch.
type IShowRestoreStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	RESTORE() antlr.TerminalNode
	Identifier() IIdentifierContext
	WHERE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsShowRestoreStatementContext differentiates from other interfaces.
	IsShowRestoreStatementContext()
}

type ShowRestoreStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IExpressionContext
}

func NewEmptyShowRestoreStatementContext() *ShowRestoreStatementContext {
	var p = new(ShowRestoreStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showRestoreStatement
	return p
}

func InitEmptyShowRestoreStatementContext(p *ShowRestoreStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showRestoreStatement
}

func (*ShowRestoreStatementContext) IsShowRestoreStatementContext() {}

func NewShowRestoreStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRestoreStatementContext {
	var p = new(ShowRestoreStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showRestoreStatement

	return p
}

func (s *ShowRestoreStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRestoreStatementContext) GetWhere() IExpressionContext { return s.where }

func (s *ShowRestoreStatementContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *ShowRestoreStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowRestoreStatementContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRESTORE, 0)
}

func (s *ShowRestoreStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowRestoreStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowRestoreStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowRestoreStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *ShowRestoreStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowRestoreStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRestoreStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRestoreStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowRestoreStatement(s)
	}
}

func (s *ShowRestoreStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowRestoreStatement(s)
	}
}

func (s *ShowRestoreStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowRestoreStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowRestoreStatement() (localctx IShowRestoreStatementContext) {
	localctx = NewShowRestoreStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, DorisSQLParserParserRULE_showRestoreStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5251)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5252)
		p.Match(DorisSQLParserParserRESTORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5255)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN {
		{
			p.SetState(5253)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5254)
			p.Identifier()
		}

	}
	p.SetState(5259)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWHERE {
		{
			p.SetState(5257)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5258)

			var _x = p.expression(0)

			localctx.(*ShowRestoreStatementContext).where = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowSnapshotStatementContext is an interface to support dynamic dispatch.
type IShowSnapshotStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	ON() antlr.TerminalNode
	Identifier() IIdentifierContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsShowSnapshotStatementContext differentiates from other interfaces.
	IsShowSnapshotStatementContext()
}

type ShowSnapshotStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowSnapshotStatementContext() *ShowSnapshotStatementContext {
	var p = new(ShowSnapshotStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showSnapshotStatement
	return p
}

func InitEmptyShowSnapshotStatementContext(p *ShowSnapshotStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showSnapshotStatement
}

func (*ShowSnapshotStatementContext) IsShowSnapshotStatementContext() {}

func NewShowSnapshotStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowSnapshotStatementContext {
	var p = new(ShowSnapshotStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showSnapshotStatement

	return p
}

func (s *ShowSnapshotStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowSnapshotStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowSnapshotStatementContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSNAPSHOT, 0)
}

func (s *ShowSnapshotStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *ShowSnapshotStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowSnapshotStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowSnapshotStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowSnapshotStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSnapshotStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowSnapshotStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowSnapshotStatement(s)
	}
}

func (s *ShowSnapshotStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowSnapshotStatement(s)
	}
}

func (s *ShowSnapshotStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowSnapshotStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowSnapshotStatement() (localctx IShowSnapshotStatementContext) {
	localctx = NewShowSnapshotStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, DorisSQLParserParserRULE_showSnapshotStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5261)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5262)
		p.Match(DorisSQLParserParserSNAPSHOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5263)
		p.Match(DorisSQLParserParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5264)
		p.Identifier()
	}
	p.SetState(5267)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWHERE {
		{
			p.SetState(5265)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5266)
			p.expression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateRepositoryStatementContext is an interface to support dynamic dispatch.
type ICreateRepositoryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRepoName returns the repoName rule contexts.
	GetRepoName() IIdentifierContext

	// GetBrokerName returns the brokerName rule contexts.
	GetBrokerName() IIdentifierOrStringContext

	// GetLocation returns the location rule contexts.
	GetLocation() IStringContext

	// SetRepoName sets the repoName rule contexts.
	SetRepoName(IIdentifierContext)

	// SetBrokerName sets the brokerName rule contexts.
	SetBrokerName(IIdentifierOrStringContext)

	// SetLocation sets the location rule contexts.
	SetLocation(IStringContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	REPOSITORY() antlr.TerminalNode
	WITH() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	ON() antlr.TerminalNode
	LOCATION() antlr.TerminalNode
	Identifier() IIdentifierContext
	String_() IStringContext
	READ() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode
	PropertyList() IPropertyListContext
	IdentifierOrString() IIdentifierOrStringContext

	// IsCreateRepositoryStatementContext differentiates from other interfaces.
	IsCreateRepositoryStatementContext()
}

type CreateRepositoryStatementContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	repoName   IIdentifierContext
	brokerName IIdentifierOrStringContext
	location   IStringContext
}

func NewEmptyCreateRepositoryStatementContext() *CreateRepositoryStatementContext {
	var p = new(CreateRepositoryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createRepositoryStatement
	return p
}

func InitEmptyCreateRepositoryStatementContext(p *CreateRepositoryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createRepositoryStatement
}

func (*CreateRepositoryStatementContext) IsCreateRepositoryStatementContext() {}

func NewCreateRepositoryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRepositoryStatementContext {
	var p = new(CreateRepositoryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createRepositoryStatement

	return p
}

func (s *CreateRepositoryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRepositoryStatementContext) GetRepoName() IIdentifierContext { return s.repoName }

func (s *CreateRepositoryStatementContext) GetBrokerName() IIdentifierOrStringContext {
	return s.brokerName
}

func (s *CreateRepositoryStatementContext) GetLocation() IStringContext { return s.location }

func (s *CreateRepositoryStatementContext) SetRepoName(v IIdentifierContext) { s.repoName = v }

func (s *CreateRepositoryStatementContext) SetBrokerName(v IIdentifierOrStringContext) {
	s.brokerName = v
}

func (s *CreateRepositoryStatementContext) SetLocation(v IStringContext) { s.location = v }

func (s *CreateRepositoryStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateRepositoryStatementContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPOSITORY, 0)
}

func (s *CreateRepositoryStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *CreateRepositoryStatementContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBROKER, 0)
}

func (s *CreateRepositoryStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *CreateRepositoryStatementContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOCATION, 0)
}

func (s *CreateRepositoryStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRepositoryStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CreateRepositoryStatementContext) READ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREAD, 0)
}

func (s *CreateRepositoryStatementContext) ONLY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserONLY, 0)
}

func (s *CreateRepositoryStatementContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROPERTIES, 0)
}

func (s *CreateRepositoryStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *CreateRepositoryStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CreateRepositoryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRepositoryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRepositoryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateRepositoryStatement(s)
	}
}

func (s *CreateRepositoryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateRepositoryStatement(s)
	}
}

func (s *CreateRepositoryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateRepositoryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateRepositoryStatement() (localctx ICreateRepositoryStatementContext) {
	localctx = NewCreateRepositoryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, DorisSQLParserParserRULE_createRepositoryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5269)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserREAD {
		{
			p.SetState(5270)
			p.Match(DorisSQLParserParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5271)
			p.Match(DorisSQLParserParserONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5274)
		p.Match(DorisSQLParserParserREPOSITORY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5275)

		var _x = p.Identifier()

		localctx.(*CreateRepositoryStatementContext).repoName = _x
	}
	{
		p.SetState(5276)
		p.Match(DorisSQLParserParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5277)
		p.Match(DorisSQLParserParserBROKER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5279)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262756702208) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-6664167256628462851) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-1331487429127569487) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&-7546427580836201) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-4573491655345179) != 0) || ((int64((_la-324)) & ^0x3f) == 0 && ((int64(1)<<(_la-324))&9114828243924942831) != 0) || ((int64((_la-389)) & ^0x3f) == 0 && ((int64(1)<<(_la-389))&-6956096606152176261) != 0) || ((int64((_la-453)) & ^0x3f) == 0 && ((int64(1)<<(_la-453))&70849595962729) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&4211) != 0) {
		{
			p.SetState(5278)

			var _x = p.IdentifierOrString()

			localctx.(*CreateRepositoryStatementContext).brokerName = _x
		}

	}
	{
		p.SetState(5281)
		p.Match(DorisSQLParserParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5282)
		p.Match(DorisSQLParserParserLOCATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5283)

		var _x = p.String_()

		localctx.(*CreateRepositoryStatementContext).location = _x
	}
	p.SetState(5286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(5284)
			p.Match(DorisSQLParserParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5285)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropRepositoryStatementContext is an interface to support dynamic dispatch.
type IDropRepositoryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	REPOSITORY() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDropRepositoryStatementContext differentiates from other interfaces.
	IsDropRepositoryStatementContext()
}

type DropRepositoryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropRepositoryStatementContext() *DropRepositoryStatementContext {
	var p = new(DropRepositoryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropRepositoryStatement
	return p
}

func InitEmptyDropRepositoryStatementContext(p *DropRepositoryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropRepositoryStatement
}

func (*DropRepositoryStatementContext) IsDropRepositoryStatementContext() {}

func NewDropRepositoryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropRepositoryStatementContext {
	var p = new(DropRepositoryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropRepositoryStatement

	return p
}

func (s *DropRepositoryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropRepositoryStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropRepositoryStatementContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPOSITORY, 0)
}

func (s *DropRepositoryStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropRepositoryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRepositoryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropRepositoryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropRepositoryStatement(s)
	}
}

func (s *DropRepositoryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropRepositoryStatement(s)
	}
}

func (s *DropRepositoryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropRepositoryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropRepositoryStatement() (localctx IDropRepositoryStatementContext) {
	localctx = NewDropRepositoryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, DorisSQLParserParserRULE_dropRepositoryStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5288)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5289)
		p.Match(DorisSQLParserParserREPOSITORY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5290)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddSqlBlackListStatementContext is an interface to support dynamic dispatch.
type IAddSqlBlackListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	SQLBLACKLIST() antlr.TerminalNode
	String_() IStringContext

	// IsAddSqlBlackListStatementContext differentiates from other interfaces.
	IsAddSqlBlackListStatementContext()
}

type AddSqlBlackListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddSqlBlackListStatementContext() *AddSqlBlackListStatementContext {
	var p = new(AddSqlBlackListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_addSqlBlackListStatement
	return p
}

func InitEmptyAddSqlBlackListStatementContext(p *AddSqlBlackListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_addSqlBlackListStatement
}

func (*AddSqlBlackListStatementContext) IsAddSqlBlackListStatementContext() {}

func NewAddSqlBlackListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddSqlBlackListStatementContext {
	var p = new(AddSqlBlackListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_addSqlBlackListStatement

	return p
}

func (s *AddSqlBlackListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AddSqlBlackListStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADD, 0)
}

func (s *AddSqlBlackListStatementContext) SQLBLACKLIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSQLBLACKLIST, 0)
}

func (s *AddSqlBlackListStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AddSqlBlackListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddSqlBlackListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddSqlBlackListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAddSqlBlackListStatement(s)
	}
}

func (s *AddSqlBlackListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAddSqlBlackListStatement(s)
	}
}

func (s *AddSqlBlackListStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAddSqlBlackListStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AddSqlBlackListStatement() (localctx IAddSqlBlackListStatementContext) {
	localctx = NewAddSqlBlackListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, DorisSQLParserParserRULE_addSqlBlackListStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5292)
		p.Match(DorisSQLParserParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5293)
		p.Match(DorisSQLParserParserSQLBLACKLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5294)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelSqlBlackListStatementContext is an interface to support dynamic dispatch.
type IDelSqlBlackListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	SQLBLACKLIST() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsDelSqlBlackListStatementContext differentiates from other interfaces.
	IsDelSqlBlackListStatementContext()
}

type DelSqlBlackListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelSqlBlackListStatementContext() *DelSqlBlackListStatementContext {
	var p = new(DelSqlBlackListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_delSqlBlackListStatement
	return p
}

func InitEmptyDelSqlBlackListStatementContext(p *DelSqlBlackListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_delSqlBlackListStatement
}

func (*DelSqlBlackListStatementContext) IsDelSqlBlackListStatementContext() {}

func NewDelSqlBlackListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelSqlBlackListStatementContext {
	var p = new(DelSqlBlackListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_delSqlBlackListStatement

	return p
}

func (s *DelSqlBlackListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DelSqlBlackListStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDELETE, 0)
}

func (s *DelSqlBlackListStatementContext) SQLBLACKLIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSQLBLACKLIST, 0)
}

func (s *DelSqlBlackListStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserINTEGER_VALUE)
}

func (s *DelSqlBlackListStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, i)
}

func (s *DelSqlBlackListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelSqlBlackListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelSqlBlackListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDelSqlBlackListStatement(s)
	}
}

func (s *DelSqlBlackListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDelSqlBlackListStatement(s)
	}
}

func (s *DelSqlBlackListStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDelSqlBlackListStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DelSqlBlackListStatement() (localctx IDelSqlBlackListStatementContext) {
	localctx = NewDelSqlBlackListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, DorisSQLParserParserRULE_delSqlBlackListStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5296)
		p.Match(DorisSQLParserParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5297)
		p.Match(DorisSQLParserParserSQLBLACKLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5298)
		p.Match(DorisSQLParserParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5303)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(5299)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5300)
			p.Match(DorisSQLParserParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(5305)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowSqlBlackListStatementContext is an interface to support dynamic dispatch.
type IShowSqlBlackListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	SQLBLACKLIST() antlr.TerminalNode

	// IsShowSqlBlackListStatementContext differentiates from other interfaces.
	IsShowSqlBlackListStatementContext()
}

type ShowSqlBlackListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowSqlBlackListStatementContext() *ShowSqlBlackListStatementContext {
	var p = new(ShowSqlBlackListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showSqlBlackListStatement
	return p
}

func InitEmptyShowSqlBlackListStatementContext(p *ShowSqlBlackListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showSqlBlackListStatement
}

func (*ShowSqlBlackListStatementContext) IsShowSqlBlackListStatementContext() {}

func NewShowSqlBlackListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowSqlBlackListStatementContext {
	var p = new(ShowSqlBlackListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showSqlBlackListStatement

	return p
}

func (s *ShowSqlBlackListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowSqlBlackListStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowSqlBlackListStatementContext) SQLBLACKLIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSQLBLACKLIST, 0)
}

func (s *ShowSqlBlackListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSqlBlackListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowSqlBlackListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowSqlBlackListStatement(s)
	}
}

func (s *ShowSqlBlackListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowSqlBlackListStatement(s)
	}
}

func (s *ShowSqlBlackListStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowSqlBlackListStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowSqlBlackListStatement() (localctx IShowSqlBlackListStatementContext) {
	localctx = NewShowSqlBlackListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, DorisSQLParserParserRULE_showSqlBlackListStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5306)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5307)
		p.Match(DorisSQLParserParserSQLBLACKLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowWhiteListStatementContext is an interface to support dynamic dispatch.
type IShowWhiteListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	WHITELIST() antlr.TerminalNode

	// IsShowWhiteListStatementContext differentiates from other interfaces.
	IsShowWhiteListStatementContext()
}

type ShowWhiteListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowWhiteListStatementContext() *ShowWhiteListStatementContext {
	var p = new(ShowWhiteListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showWhiteListStatement
	return p
}

func InitEmptyShowWhiteListStatementContext(p *ShowWhiteListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showWhiteListStatement
}

func (*ShowWhiteListStatementContext) IsShowWhiteListStatementContext() {}

func NewShowWhiteListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowWhiteListStatementContext {
	var p = new(ShowWhiteListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showWhiteListStatement

	return p
}

func (s *ShowWhiteListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowWhiteListStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowWhiteListStatementContext) WHITELIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHITELIST, 0)
}

func (s *ShowWhiteListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWhiteListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowWhiteListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowWhiteListStatement(s)
	}
}

func (s *ShowWhiteListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowWhiteListStatement(s)
	}
}

func (s *ShowWhiteListStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowWhiteListStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowWhiteListStatement() (localctx IShowWhiteListStatementContext) {
	localctx = NewShowWhiteListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, DorisSQLParserParserRULE_showWhiteListStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5309)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5310)
		p.Match(DorisSQLParserParserWHITELIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddBackendBlackListStatementContext is an interface to support dynamic dispatch.
type IAddBackendBlackListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	BLACKLIST() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsAddBackendBlackListStatementContext differentiates from other interfaces.
	IsAddBackendBlackListStatementContext()
}

type AddBackendBlackListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddBackendBlackListStatementContext() *AddBackendBlackListStatementContext {
	var p = new(AddBackendBlackListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_addBackendBlackListStatement
	return p
}

func InitEmptyAddBackendBlackListStatementContext(p *AddBackendBlackListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_addBackendBlackListStatement
}

func (*AddBackendBlackListStatementContext) IsAddBackendBlackListStatementContext() {}

func NewAddBackendBlackListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddBackendBlackListStatementContext {
	var p = new(AddBackendBlackListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_addBackendBlackListStatement

	return p
}

func (s *AddBackendBlackListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AddBackendBlackListStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADD, 0)
}

func (s *AddBackendBlackListStatementContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBACKEND, 0)
}

func (s *AddBackendBlackListStatementContext) BLACKLIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBLACKLIST, 0)
}

func (s *AddBackendBlackListStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserINTEGER_VALUE)
}

func (s *AddBackendBlackListStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, i)
}

func (s *AddBackendBlackListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddBackendBlackListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddBackendBlackListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAddBackendBlackListStatement(s)
	}
}

func (s *AddBackendBlackListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAddBackendBlackListStatement(s)
	}
}

func (s *AddBackendBlackListStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAddBackendBlackListStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AddBackendBlackListStatement() (localctx IAddBackendBlackListStatementContext) {
	localctx = NewAddBackendBlackListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, DorisSQLParserParserRULE_addBackendBlackListStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5312)
		p.Match(DorisSQLParserParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5313)
		p.Match(DorisSQLParserParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5314)
		p.Match(DorisSQLParserParserBLACKLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5315)
		p.Match(DorisSQLParserParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5320)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(5316)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5317)
			p.Match(DorisSQLParserParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(5322)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelBackendBlackListStatementContext is an interface to support dynamic dispatch.
type IDelBackendBlackListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	BLACKLIST() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsDelBackendBlackListStatementContext differentiates from other interfaces.
	IsDelBackendBlackListStatementContext()
}

type DelBackendBlackListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelBackendBlackListStatementContext() *DelBackendBlackListStatementContext {
	var p = new(DelBackendBlackListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_delBackendBlackListStatement
	return p
}

func InitEmptyDelBackendBlackListStatementContext(p *DelBackendBlackListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_delBackendBlackListStatement
}

func (*DelBackendBlackListStatementContext) IsDelBackendBlackListStatementContext() {}

func NewDelBackendBlackListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelBackendBlackListStatementContext {
	var p = new(DelBackendBlackListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_delBackendBlackListStatement

	return p
}

func (s *DelBackendBlackListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DelBackendBlackListStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDELETE, 0)
}

func (s *DelBackendBlackListStatementContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBACKEND, 0)
}

func (s *DelBackendBlackListStatementContext) BLACKLIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBLACKLIST, 0)
}

func (s *DelBackendBlackListStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserINTEGER_VALUE)
}

func (s *DelBackendBlackListStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, i)
}

func (s *DelBackendBlackListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelBackendBlackListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelBackendBlackListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDelBackendBlackListStatement(s)
	}
}

func (s *DelBackendBlackListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDelBackendBlackListStatement(s)
	}
}

func (s *DelBackendBlackListStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDelBackendBlackListStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DelBackendBlackListStatement() (localctx IDelBackendBlackListStatementContext) {
	localctx = NewDelBackendBlackListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, DorisSQLParserParserRULE_delBackendBlackListStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5323)
		p.Match(DorisSQLParserParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5324)
		p.Match(DorisSQLParserParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5325)
		p.Match(DorisSQLParserParserBLACKLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5326)
		p.Match(DorisSQLParserParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5331)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(5327)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5328)
			p.Match(DorisSQLParserParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(5333)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowBackendBlackListStatementContext is an interface to support dynamic dispatch.
type IShowBackendBlackListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	BLACKLIST() antlr.TerminalNode

	// IsShowBackendBlackListStatementContext differentiates from other interfaces.
	IsShowBackendBlackListStatementContext()
}

type ShowBackendBlackListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowBackendBlackListStatementContext() *ShowBackendBlackListStatementContext {
	var p = new(ShowBackendBlackListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showBackendBlackListStatement
	return p
}

func InitEmptyShowBackendBlackListStatementContext(p *ShowBackendBlackListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showBackendBlackListStatement
}

func (*ShowBackendBlackListStatementContext) IsShowBackendBlackListStatementContext() {}

func NewShowBackendBlackListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowBackendBlackListStatementContext {
	var p = new(ShowBackendBlackListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showBackendBlackListStatement

	return p
}

func (s *ShowBackendBlackListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowBackendBlackListStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowBackendBlackListStatementContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBACKEND, 0)
}

func (s *ShowBackendBlackListStatementContext) BLACKLIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBLACKLIST, 0)
}

func (s *ShowBackendBlackListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBackendBlackListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowBackendBlackListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowBackendBlackListStatement(s)
	}
}

func (s *ShowBackendBlackListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowBackendBlackListStatement(s)
	}
}

func (s *ShowBackendBlackListStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowBackendBlackListStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowBackendBlackListStatement() (localctx IShowBackendBlackListStatementContext) {
	localctx = NewShowBackendBlackListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, DorisSQLParserParserRULE_showBackendBlackListStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5334)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5335)
		p.Match(DorisSQLParserParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5336)
		p.Match(DorisSQLParserParserBLACKLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataCacheTargetContext is an interface to support dynamic dispatch.
type IDataCacheTargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierOrStringOrStar() []IIdentifierOrStringOrStarContext
	IdentifierOrStringOrStar(i int) IIdentifierOrStringOrStarContext

	// IsDataCacheTargetContext differentiates from other interfaces.
	IsDataCacheTargetContext()
}

type DataCacheTargetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataCacheTargetContext() *DataCacheTargetContext {
	var p = new(DataCacheTargetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dataCacheTarget
	return p
}

func InitEmptyDataCacheTargetContext(p *DataCacheTargetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dataCacheTarget
}

func (*DataCacheTargetContext) IsDataCacheTargetContext() {}

func NewDataCacheTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataCacheTargetContext {
	var p = new(DataCacheTargetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dataCacheTarget

	return p
}

func (s *DataCacheTargetContext) GetParser() antlr.Parser { return s.parser }

func (s *DataCacheTargetContext) AllIdentifierOrStringOrStar() []IIdentifierOrStringOrStarContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringOrStarContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringOrStarContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringOrStarContext); ok {
			tst[i] = t.(IIdentifierOrStringOrStarContext)
			i++
		}
	}

	return tst
}

func (s *DataCacheTargetContext) IdentifierOrStringOrStar(i int) IIdentifierOrStringOrStarContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringOrStarContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringOrStarContext)
}

func (s *DataCacheTargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataCacheTargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataCacheTargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDataCacheTarget(s)
	}
}

func (s *DataCacheTargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDataCacheTarget(s)
	}
}

func (s *DataCacheTargetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDataCacheTarget(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DataCacheTarget() (localctx IDataCacheTargetContext) {
	localctx = NewDataCacheTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, DorisSQLParserParserRULE_dataCacheTarget)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5338)
		p.IdentifierOrStringOrStar()
	}
	{
		p.SetState(5339)
		p.Match(DorisSQLParserParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5340)
		p.IdentifierOrStringOrStar()
	}
	{
		p.SetState(5341)
		p.Match(DorisSQLParserParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5342)
		p.IdentifierOrStringOrStar()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDataCacheRuleStatementContext is an interface to support dynamic dispatch.
type ICreateDataCacheRuleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	DATACACHE() antlr.TerminalNode
	RULE() antlr.TerminalNode
	DataCacheTarget() IDataCacheTargetContext
	PRIORITY() antlr.TerminalNode
	EQ() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	MINUS_SYMBOL() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsCreateDataCacheRuleStatementContext differentiates from other interfaces.
	IsCreateDataCacheRuleStatementContext()
}

type CreateDataCacheRuleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDataCacheRuleStatementContext() *CreateDataCacheRuleStatementContext {
	var p = new(CreateDataCacheRuleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createDataCacheRuleStatement
	return p
}

func InitEmptyCreateDataCacheRuleStatementContext(p *CreateDataCacheRuleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createDataCacheRuleStatement
}

func (*CreateDataCacheRuleStatementContext) IsCreateDataCacheRuleStatementContext() {}

func NewCreateDataCacheRuleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDataCacheRuleStatementContext {
	var p = new(CreateDataCacheRuleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createDataCacheRuleStatement

	return p
}

func (s *CreateDataCacheRuleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDataCacheRuleStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateDataCacheRuleStatementContext) DATACACHE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATACACHE, 0)
}

func (s *CreateDataCacheRuleStatementContext) RULE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRULE, 0)
}

func (s *CreateDataCacheRuleStatementContext) DataCacheTarget() IDataCacheTargetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataCacheTargetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataCacheTargetContext)
}

func (s *CreateDataCacheRuleStatementContext) PRIORITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPRIORITY, 0)
}

func (s *CreateDataCacheRuleStatementContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEQ, 0)
}

func (s *CreateDataCacheRuleStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, 0)
}

func (s *CreateDataCacheRuleStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *CreateDataCacheRuleStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CreateDataCacheRuleStatementContext) MINUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMINUS_SYMBOL, 0)
}

func (s *CreateDataCacheRuleStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateDataCacheRuleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDataCacheRuleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDataCacheRuleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateDataCacheRuleStatement(s)
	}
}

func (s *CreateDataCacheRuleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateDataCacheRuleStatement(s)
	}
}

func (s *CreateDataCacheRuleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateDataCacheRuleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateDataCacheRuleStatement() (localctx ICreateDataCacheRuleStatementContext) {
	localctx = NewCreateDataCacheRuleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, DorisSQLParserParserRULE_createDataCacheRuleStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5344)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5345)
		p.Match(DorisSQLParserParserDATACACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5346)
		p.Match(DorisSQLParserParserRULE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5347)
		p.DataCacheTarget()
	}
	p.SetState(5350)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWHERE {
		{
			p.SetState(5348)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5349)
			p.expression(0)
		}

	}
	{
		p.SetState(5352)
		p.Match(DorisSQLParserParserPRIORITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5353)
		p.Match(DorisSQLParserParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5355)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserMINUS_SYMBOL {
		{
			p.SetState(5354)
			p.Match(DorisSQLParserParserMINUS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5357)
		p.Match(DorisSQLParserParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5359)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(5358)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDataCacheRulesStatementContext is an interface to support dynamic dispatch.
type IShowDataCacheRulesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	DATACACHE() antlr.TerminalNode
	RULES() antlr.TerminalNode

	// IsShowDataCacheRulesStatementContext differentiates from other interfaces.
	IsShowDataCacheRulesStatementContext()
}

type ShowDataCacheRulesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowDataCacheRulesStatementContext() *ShowDataCacheRulesStatementContext {
	var p = new(ShowDataCacheRulesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showDataCacheRulesStatement
	return p
}

func InitEmptyShowDataCacheRulesStatementContext(p *ShowDataCacheRulesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showDataCacheRulesStatement
}

func (*ShowDataCacheRulesStatementContext) IsShowDataCacheRulesStatementContext() {}

func NewShowDataCacheRulesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDataCacheRulesStatementContext {
	var p = new(ShowDataCacheRulesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showDataCacheRulesStatement

	return p
}

func (s *ShowDataCacheRulesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDataCacheRulesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowDataCacheRulesStatementContext) DATACACHE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATACACHE, 0)
}

func (s *ShowDataCacheRulesStatementContext) RULES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRULES, 0)
}

func (s *ShowDataCacheRulesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDataCacheRulesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDataCacheRulesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowDataCacheRulesStatement(s)
	}
}

func (s *ShowDataCacheRulesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowDataCacheRulesStatement(s)
	}
}

func (s *ShowDataCacheRulesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowDataCacheRulesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowDataCacheRulesStatement() (localctx IShowDataCacheRulesStatementContext) {
	localctx = NewShowDataCacheRulesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, DorisSQLParserParserRULE_showDataCacheRulesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5361)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5362)
		p.Match(DorisSQLParserParserDATACACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5363)
		p.Match(DorisSQLParserParserRULES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropDataCacheRuleStatementContext is an interface to support dynamic dispatch.
type IDropDataCacheRuleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	DATACACHE() antlr.TerminalNode
	RULE() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsDropDataCacheRuleStatementContext differentiates from other interfaces.
	IsDropDataCacheRuleStatementContext()
}

type DropDataCacheRuleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropDataCacheRuleStatementContext() *DropDataCacheRuleStatementContext {
	var p = new(DropDataCacheRuleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropDataCacheRuleStatement
	return p
}

func InitEmptyDropDataCacheRuleStatementContext(p *DropDataCacheRuleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropDataCacheRuleStatement
}

func (*DropDataCacheRuleStatementContext) IsDropDataCacheRuleStatementContext() {}

func NewDropDataCacheRuleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropDataCacheRuleStatementContext {
	var p = new(DropDataCacheRuleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropDataCacheRuleStatement

	return p
}

func (s *DropDataCacheRuleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropDataCacheRuleStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropDataCacheRuleStatementContext) DATACACHE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATACACHE, 0)
}

func (s *DropDataCacheRuleStatementContext) RULE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRULE, 0)
}

func (s *DropDataCacheRuleStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, 0)
}

func (s *DropDataCacheRuleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDataCacheRuleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropDataCacheRuleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropDataCacheRuleStatement(s)
	}
}

func (s *DropDataCacheRuleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropDataCacheRuleStatement(s)
	}
}

func (s *DropDataCacheRuleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropDataCacheRuleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropDataCacheRuleStatement() (localctx IDropDataCacheRuleStatementContext) {
	localctx = NewDropDataCacheRuleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, DorisSQLParserParserRULE_dropDataCacheRuleStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5365)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5366)
		p.Match(DorisSQLParserParserDATACACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5367)
		p.Match(DorisSQLParserParserRULE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5368)
		p.Match(DorisSQLParserParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClearDataCacheRulesStatementContext is an interface to support dynamic dispatch.
type IClearDataCacheRulesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLEAR() antlr.TerminalNode
	DATACACHE() antlr.TerminalNode
	RULES() antlr.TerminalNode

	// IsClearDataCacheRulesStatementContext differentiates from other interfaces.
	IsClearDataCacheRulesStatementContext()
}

type ClearDataCacheRulesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClearDataCacheRulesStatementContext() *ClearDataCacheRulesStatementContext {
	var p = new(ClearDataCacheRulesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_clearDataCacheRulesStatement
	return p
}

func InitEmptyClearDataCacheRulesStatementContext(p *ClearDataCacheRulesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_clearDataCacheRulesStatement
}

func (*ClearDataCacheRulesStatementContext) IsClearDataCacheRulesStatementContext() {}

func NewClearDataCacheRulesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClearDataCacheRulesStatementContext {
	var p = new(ClearDataCacheRulesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_clearDataCacheRulesStatement

	return p
}

func (s *ClearDataCacheRulesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ClearDataCacheRulesStatementContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCLEAR, 0)
}

func (s *ClearDataCacheRulesStatementContext) DATACACHE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATACACHE, 0)
}

func (s *ClearDataCacheRulesStatementContext) RULES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRULES, 0)
}

func (s *ClearDataCacheRulesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClearDataCacheRulesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClearDataCacheRulesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterClearDataCacheRulesStatement(s)
	}
}

func (s *ClearDataCacheRulesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitClearDataCacheRulesStatement(s)
	}
}

func (s *ClearDataCacheRulesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitClearDataCacheRulesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ClearDataCacheRulesStatement() (localctx IClearDataCacheRulesStatementContext) {
	localctx = NewClearDataCacheRulesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, DorisSQLParserParserRULE_clearDataCacheRulesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5370)
		p.Match(DorisSQLParserParserCLEAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5371)
		p.Match(DorisSQLParserParserDATACACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5372)
		p.Match(DorisSQLParserParserRULES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataCacheSelectStatementContext is an interface to support dynamic dispatch.
type IDataCacheSelectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	CACHE() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	AllSelectItem() []ISelectItemContext
	SelectItem(i int) ISelectItemContext
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	WHERE() antlr.TerminalNode
	Properties() IPropertiesContext
	Expression() IExpressionContext

	// IsDataCacheSelectStatementContext differentiates from other interfaces.
	IsDataCacheSelectStatementContext()
}

type DataCacheSelectStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IExpressionContext
}

func NewEmptyDataCacheSelectStatementContext() *DataCacheSelectStatementContext {
	var p = new(DataCacheSelectStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dataCacheSelectStatement
	return p
}

func InitEmptyDataCacheSelectStatementContext(p *DataCacheSelectStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dataCacheSelectStatement
}

func (*DataCacheSelectStatementContext) IsDataCacheSelectStatementContext() {}

func NewDataCacheSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataCacheSelectStatementContext {
	var p = new(DataCacheSelectStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dataCacheSelectStatement

	return p
}

func (s *DataCacheSelectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DataCacheSelectStatementContext) GetWhere() IExpressionContext { return s.where }

func (s *DataCacheSelectStatementContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *DataCacheSelectStatementContext) CACHE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCACHE, 0)
}

func (s *DataCacheSelectStatementContext) SELECT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSELECT, 0)
}

func (s *DataCacheSelectStatementContext) AllSelectItem() []ISelectItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectItemContext); ok {
			len++
		}
	}

	tst := make([]ISelectItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectItemContext); ok {
			tst[i] = t.(ISelectItemContext)
			i++
		}
	}

	return tst
}

func (s *DataCacheSelectStatementContext) SelectItem(i int) ISelectItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectItemContext)
}

func (s *DataCacheSelectStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *DataCacheSelectStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DataCacheSelectStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *DataCacheSelectStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *DataCacheSelectStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DataCacheSelectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataCacheSelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataCacheSelectStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDataCacheSelectStatement(s)
	}
}

func (s *DataCacheSelectStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDataCacheSelectStatement(s)
	}
}

func (s *DataCacheSelectStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDataCacheSelectStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DataCacheSelectStatement() (localctx IDataCacheSelectStatementContext) {
	localctx = NewDataCacheSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, DorisSQLParserParserRULE_dataCacheSelectStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5374)
		p.Match(DorisSQLParserParserCACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5375)
		p.Match(DorisSQLParserParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5376)
		p.SelectItem()
	}
	p.SetState(5381)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(5377)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5378)
			p.SelectItem()
		}

		p.SetState(5383)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5384)
		p.Match(DorisSQLParserParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5385)
		p.QualifiedName()
	}
	p.SetState(5388)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWHERE {
		{
			p.SetState(5386)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5387)

			var _x = p.expression(0)

			localctx.(*DataCacheSelectStatementContext).where = _x
		}

	}
	p.SetState(5391)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(5390)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportStatementContext is an interface to support dynamic dispatch.
type IExportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXPORT() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableDesc() ITableDescContext
	TO() antlr.TerminalNode
	String_() IStringContext
	ColumnAliases() IColumnAliasesContext
	WITH() antlr.TerminalNode
	MODE() antlr.TerminalNode
	Properties() IPropertiesContext
	BrokerDesc() IBrokerDescContext
	SYNC() antlr.TerminalNode
	ASYNC() antlr.TerminalNode

	// IsExportStatementContext differentiates from other interfaces.
	IsExportStatementContext()
}

type ExportStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportStatementContext() *ExportStatementContext {
	var p = new(ExportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_exportStatement
	return p
}

func InitEmptyExportStatementContext(p *ExportStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_exportStatement
}

func (*ExportStatementContext) IsExportStatementContext() {}

func NewExportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportStatementContext {
	var p = new(ExportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_exportStatement

	return p
}

func (s *ExportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportStatementContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXPORT, 0)
}

func (s *ExportStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *ExportStatementContext) TableDesc() ITableDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableDescContext)
}

func (s *ExportStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTO, 0)
}

func (s *ExportStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ExportStatementContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *ExportStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *ExportStatementContext) MODE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMODE, 0)
}

func (s *ExportStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *ExportStatementContext) BrokerDesc() IBrokerDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBrokerDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBrokerDescContext)
}

func (s *ExportStatementContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSYNC, 0)
}

func (s *ExportStatementContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserASYNC, 0)
}

func (s *ExportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterExportStatement(s)
	}
}

func (s *ExportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitExportStatement(s)
	}
}

func (s *ExportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitExportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ExportStatement() (localctx IExportStatementContext) {
	localctx = NewExportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, DorisSQLParserParserRULE_exportStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5393)
		p.Match(DorisSQLParserParserEXPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5394)
		p.Match(DorisSQLParserParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5395)
		p.TableDesc()
	}
	p.SetState(5397)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserT__1 {
		{
			p.SetState(5396)
			p.ColumnAliases()
		}

	}
	{
		p.SetState(5399)
		p.Match(DorisSQLParserParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5400)
		p.String_()
	}
	p.SetState(5404)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 579, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5401)
			p.Match(DorisSQLParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5402)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserASYNC || _la == DorisSQLParserParserSYNC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5403)
			p.Match(DorisSQLParserParserMODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(5407)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(5406)
			p.Properties()
		}

	}
	p.SetState(5410)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWITH {
		{
			p.SetState(5409)
			p.BrokerDesc()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelExportStatementContext is an interface to support dynamic dispatch.
type ICancelExportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	CANCEL() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsCancelExportStatementContext differentiates from other interfaces.
	IsCancelExportStatementContext()
}

type CancelExportStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyCancelExportStatementContext() *CancelExportStatementContext {
	var p = new(CancelExportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cancelExportStatement
	return p
}

func InitEmptyCancelExportStatementContext(p *CancelExportStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_cancelExportStatement
}

func (*CancelExportStatementContext) IsCancelExportStatementContext() {}

func NewCancelExportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelExportStatementContext {
	var p = new(CancelExportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_cancelExportStatement

	return p
}

func (s *CancelExportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelExportStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *CancelExportStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *CancelExportStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *CancelExportStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *CancelExportStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCANCEL, 0)
}

func (s *CancelExportStatementContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXPORT, 0)
}

func (s *CancelExportStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *CancelExportStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *CancelExportStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CancelExportStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *CancelExportStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *CancelExportStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CancelExportStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CancelExportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelExportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelExportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCancelExportStatement(s)
	}
}

func (s *CancelExportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCancelExportStatement(s)
	}
}

func (s *CancelExportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCancelExportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CancelExportStatement() (localctx ICancelExportStatementContext) {
	localctx = NewCancelExportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, DorisSQLParserParserRULE_cancelExportStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5412)
		p.Match(DorisSQLParserParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5413)
		p.Match(DorisSQLParserParserEXPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5416)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN {
		{
			p.SetState(5414)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5415)

			var _x = p.QualifiedName()

			localctx.(*CancelExportStatementContext).catalog = _x
		}

	}
	p.SetState(5422)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserLIKE:
		{
			p.SetState(5418)
			p.Match(DorisSQLParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5419)

			var _x = p.String_()

			localctx.(*CancelExportStatementContext).pattern = _x
		}

	case DorisSQLParserParserWHERE:
		{
			p.SetState(5420)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5421)
			p.expression(0)
		}

	case DorisSQLParserParserEOF, DorisSQLParserParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowExportStatementContext is an interface to support dynamic dispatch.
type IShowExportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowExportStatementContext differentiates from other interfaces.
	IsShowExportStatementContext()
}

type ShowExportStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowExportStatementContext() *ShowExportStatementContext {
	var p = new(ShowExportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showExportStatement
	return p
}

func InitEmptyShowExportStatementContext(p *ShowExportStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showExportStatement
}

func (*ShowExportStatementContext) IsShowExportStatementContext() {}

func NewShowExportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowExportStatementContext {
	var p = new(ShowExportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showExportStatement

	return p
}

func (s *ShowExportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowExportStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *ShowExportStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowExportStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *ShowExportStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowExportStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowExportStatementContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXPORT, 0)
}

func (s *ShowExportStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserORDER, 0)
}

func (s *ShowExportStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *ShowExportStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowExportStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowExportStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowExportStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowExportStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *ShowExportStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowExportStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *ShowExportStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowExportStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowExportStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowExportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowExportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowExportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowExportStatement(s)
	}
}

func (s *ShowExportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowExportStatement(s)
	}
}

func (s *ShowExportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowExportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowExportStatement() (localctx IShowExportStatementContext) {
	localctx = NewShowExportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, DorisSQLParserParserRULE_showExportStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5424)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5425)
		p.Match(DorisSQLParserParserEXPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5428)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN {
		{
			p.SetState(5426)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5427)

			var _x = p.QualifiedName()

			localctx.(*ShowExportStatementContext).catalog = _x
		}

	}
	p.SetState(5434)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserLIKE:
		{
			p.SetState(5430)
			p.Match(DorisSQLParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5431)

			var _x = p.String_()

			localctx.(*ShowExportStatementContext).pattern = _x
		}

	case DorisSQLParserParserWHERE:
		{
			p.SetState(5432)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5433)
			p.expression(0)
		}

	case DorisSQLParserParserEOF, DorisSQLParserParserLIMIT, DorisSQLParserParserORDER, DorisSQLParserParserSEMICOLON:

	default:
	}
	p.SetState(5446)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserORDER {
		{
			p.SetState(5436)
			p.Match(DorisSQLParserParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5437)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5438)
			p.SortItem()
		}
		p.SetState(5443)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(5439)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5440)
				p.SortItem()
			}

			p.SetState(5445)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(5449)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserLIMIT {
		{
			p.SetState(5448)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstallPluginStatementContext is an interface to support dynamic dispatch.
type IInstallPluginStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INSTALL() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	Properties() IPropertiesContext

	// IsInstallPluginStatementContext differentiates from other interfaces.
	IsInstallPluginStatementContext()
}

type InstallPluginStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstallPluginStatementContext() *InstallPluginStatementContext {
	var p = new(InstallPluginStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_installPluginStatement
	return p
}

func InitEmptyInstallPluginStatementContext(p *InstallPluginStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_installPluginStatement
}

func (*InstallPluginStatementContext) IsInstallPluginStatementContext() {}

func NewInstallPluginStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstallPluginStatementContext {
	var p = new(InstallPluginStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_installPluginStatement

	return p
}

func (s *InstallPluginStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InstallPluginStatementContext) INSTALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINSTALL, 0)
}

func (s *InstallPluginStatementContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPLUGIN, 0)
}

func (s *InstallPluginStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *InstallPluginStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *InstallPluginStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *InstallPluginStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstallPluginStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstallPluginStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterInstallPluginStatement(s)
	}
}

func (s *InstallPluginStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitInstallPluginStatement(s)
	}
}

func (s *InstallPluginStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitInstallPluginStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) InstallPluginStatement() (localctx IInstallPluginStatementContext) {
	localctx = NewInstallPluginStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, DorisSQLParserParserRULE_installPluginStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5451)
		p.Match(DorisSQLParserParserINSTALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5452)
		p.Match(DorisSQLParserParserPLUGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5453)
		p.Match(DorisSQLParserParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5454)
		p.IdentifierOrString()
	}
	p.SetState(5456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(5455)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUninstallPluginStatementContext is an interface to support dynamic dispatch.
type IUninstallPluginStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNINSTALL() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsUninstallPluginStatementContext differentiates from other interfaces.
	IsUninstallPluginStatementContext()
}

type UninstallPluginStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUninstallPluginStatementContext() *UninstallPluginStatementContext {
	var p = new(UninstallPluginStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_uninstallPluginStatement
	return p
}

func InitEmptyUninstallPluginStatementContext(p *UninstallPluginStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_uninstallPluginStatement
}

func (*UninstallPluginStatementContext) IsUninstallPluginStatementContext() {}

func NewUninstallPluginStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UninstallPluginStatementContext {
	var p = new(UninstallPluginStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_uninstallPluginStatement

	return p
}

func (s *UninstallPluginStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UninstallPluginStatementContext) UNINSTALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUNINSTALL, 0)
}

func (s *UninstallPluginStatementContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPLUGIN, 0)
}

func (s *UninstallPluginStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *UninstallPluginStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UninstallPluginStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UninstallPluginStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterUninstallPluginStatement(s)
	}
}

func (s *UninstallPluginStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitUninstallPluginStatement(s)
	}
}

func (s *UninstallPluginStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitUninstallPluginStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) UninstallPluginStatement() (localctx IUninstallPluginStatementContext) {
	localctx = NewUninstallPluginStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, DorisSQLParserParserRULE_uninstallPluginStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5458)
		p.Match(DorisSQLParserParserUNINSTALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5459)
		p.Match(DorisSQLParserParserPLUGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5460)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateFileStatementContext is an interface to support dynamic dispatch.
type ICreateFileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	FILE() antlr.TerminalNode
	String_() IStringContext
	Properties() IPropertiesContext
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsCreateFileStatementContext differentiates from other interfaces.
	IsCreateFileStatementContext()
}

type CreateFileStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
}

func NewEmptyCreateFileStatementContext() *CreateFileStatementContext {
	var p = new(CreateFileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createFileStatement
	return p
}

func InitEmptyCreateFileStatementContext(p *CreateFileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createFileStatement
}

func (*CreateFileStatementContext) IsCreateFileStatementContext() {}

func NewCreateFileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateFileStatementContext {
	var p = new(CreateFileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createFileStatement

	return p
}

func (s *CreateFileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateFileStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *CreateFileStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *CreateFileStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateFileStatementContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFILE, 0)
}

func (s *CreateFileStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CreateFileStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateFileStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *CreateFileStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *CreateFileStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateFileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateFileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateFileStatement(s)
	}
}

func (s *CreateFileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateFileStatement(s)
	}
}

func (s *CreateFileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateFileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateFileStatement() (localctx ICreateFileStatementContext) {
	localctx = NewCreateFileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, DorisSQLParserParserRULE_createFileStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5462)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5463)
		p.Match(DorisSQLParserParserFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5464)
		p.String_()
	}
	p.SetState(5467)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN {
		{
			p.SetState(5465)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5466)

			var _x = p.QualifiedName()

			localctx.(*CreateFileStatementContext).catalog = _x
		}

	}
	{
		p.SetState(5469)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropFileStatementContext is an interface to support dynamic dispatch.
type IDropFileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	FILE() antlr.TerminalNode
	String_() IStringContext
	Properties() IPropertiesContext
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsDropFileStatementContext differentiates from other interfaces.
	IsDropFileStatementContext()
}

type DropFileStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
}

func NewEmptyDropFileStatementContext() *DropFileStatementContext {
	var p = new(DropFileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropFileStatement
	return p
}

func InitEmptyDropFileStatementContext(p *DropFileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropFileStatement
}

func (*DropFileStatementContext) IsDropFileStatementContext() {}

func NewDropFileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFileStatementContext {
	var p = new(DropFileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropFileStatement

	return p
}

func (s *DropFileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFileStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *DropFileStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *DropFileStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropFileStatementContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFILE, 0)
}

func (s *DropFileStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DropFileStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *DropFileStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *DropFileStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *DropFileStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropFileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropFileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropFileStatement(s)
	}
}

func (s *DropFileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropFileStatement(s)
	}
}

func (s *DropFileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropFileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropFileStatement() (localctx IDropFileStatementContext) {
	localctx = NewDropFileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, DorisSQLParserParserRULE_dropFileStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5471)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5472)
		p.Match(DorisSQLParserParserFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5473)
		p.String_()
	}
	p.SetState(5476)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN {
		{
			p.SetState(5474)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5475)

			var _x = p.QualifiedName()

			localctx.(*DropFileStatementContext).catalog = _x
		}

	}
	{
		p.SetState(5478)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowSmallFilesStatementContext is an interface to support dynamic dispatch.
type IShowSmallFilesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	FILE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowSmallFilesStatementContext differentiates from other interfaces.
	IsShowSmallFilesStatementContext()
}

type ShowSmallFilesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
}

func NewEmptyShowSmallFilesStatementContext() *ShowSmallFilesStatementContext {
	var p = new(ShowSmallFilesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showSmallFilesStatement
	return p
}

func InitEmptyShowSmallFilesStatementContext(p *ShowSmallFilesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showSmallFilesStatement
}

func (*ShowSmallFilesStatementContext) IsShowSmallFilesStatementContext() {}

func NewShowSmallFilesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowSmallFilesStatementContext {
	var p = new(ShowSmallFilesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showSmallFilesStatement

	return p
}

func (s *ShowSmallFilesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowSmallFilesStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *ShowSmallFilesStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *ShowSmallFilesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowSmallFilesStatementContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFILE, 0)
}

func (s *ShowSmallFilesStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowSmallFilesStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *ShowSmallFilesStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowSmallFilesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSmallFilesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowSmallFilesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowSmallFilesStatement(s)
	}
}

func (s *ShowSmallFilesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowSmallFilesStatement(s)
	}
}

func (s *ShowSmallFilesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowSmallFilesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowSmallFilesStatement() (localctx IShowSmallFilesStatementContext) {
	localctx = NewShowSmallFilesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, DorisSQLParserParserRULE_showSmallFilesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5480)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5481)
		p.Match(DorisSQLParserParserFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5484)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN {
		{
			p.SetState(5482)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserFROM || _la == DorisSQLParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5483)

			var _x = p.QualifiedName()

			localctx.(*ShowSmallFilesStatementContext).catalog = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreatePipeStatementContext is an interface to support dynamic dispatch.
type ICreatePipeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	OrReplace() IOrReplaceContext
	PIPE() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	QualifiedName() IQualifiedNameContext
	AS() antlr.TerminalNode
	InsertStatement() IInsertStatementContext
	Properties() IPropertiesContext

	// IsCreatePipeStatementContext differentiates from other interfaces.
	IsCreatePipeStatementContext()
}

type CreatePipeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreatePipeStatementContext() *CreatePipeStatementContext {
	var p = new(CreatePipeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createPipeStatement
	return p
}

func InitEmptyCreatePipeStatementContext(p *CreatePipeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createPipeStatement
}

func (*CreatePipeStatementContext) IsCreatePipeStatementContext() {}

func NewCreatePipeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreatePipeStatementContext {
	var p = new(CreatePipeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createPipeStatement

	return p
}

func (s *CreatePipeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreatePipeStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreatePipeStatementContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreatePipeStatementContext) PIPE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPIPE, 0)
}

func (s *CreatePipeStatementContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreatePipeStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreatePipeStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *CreatePipeStatementContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *CreatePipeStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreatePipeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatePipeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreatePipeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreatePipeStatement(s)
	}
}

func (s *CreatePipeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreatePipeStatement(s)
	}
}

func (s *CreatePipeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreatePipeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreatePipeStatement() (localctx ICreatePipeStatementContext) {
	localctx = NewCreatePipeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 666, DorisSQLParserParserRULE_createPipeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5486)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5487)
		p.OrReplace()
	}
	{
		p.SetState(5488)
		p.Match(DorisSQLParserParserPIPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5489)
		p.IfNotExists()
	}
	{
		p.SetState(5490)
		p.QualifiedName()
	}
	p.SetState(5492)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(5491)
			p.Properties()
		}

	}
	{
		p.SetState(5494)
		p.Match(DorisSQLParserParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5495)
		p.InsertStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropPipeStatementContext is an interface to support dynamic dispatch.
type IDropPipeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	PIPE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropPipeStatementContext differentiates from other interfaces.
	IsDropPipeStatementContext()
}

type DropPipeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropPipeStatementContext() *DropPipeStatementContext {
	var p = new(DropPipeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropPipeStatement
	return p
}

func InitEmptyDropPipeStatementContext(p *DropPipeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropPipeStatement
}

func (*DropPipeStatementContext) IsDropPipeStatementContext() {}

func NewDropPipeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropPipeStatementContext {
	var p = new(DropPipeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropPipeStatement

	return p
}

func (s *DropPipeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropPipeStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropPipeStatementContext) PIPE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPIPE, 0)
}

func (s *DropPipeStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropPipeStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *DropPipeStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *DropPipeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropPipeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropPipeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropPipeStatement(s)
	}
}

func (s *DropPipeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropPipeStatement(s)
	}
}

func (s *DropPipeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropPipeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropPipeStatement() (localctx IDropPipeStatementContext) {
	localctx = NewDropPipeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 668, DorisSQLParserParserRULE_dropPipeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5497)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5498)
		p.Match(DorisSQLParserParserPIPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5501)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(5499)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5500)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5503)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterPipeClauseContext is an interface to support dynamic dispatch.
type IAlterPipeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFileName returns the fileName rule contexts.
	GetFileName() IStringContext

	// SetFileName sets the fileName rule contexts.
	SetFileName(IStringContext)

	// Getter signatures
	SUSPEND() antlr.TerminalNode
	RESUME() antlr.TerminalNode
	RETRY() antlr.TerminalNode
	ALL() antlr.TerminalNode
	FILE() antlr.TerminalNode
	String_() IStringContext
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsAlterPipeClauseContext differentiates from other interfaces.
	IsAlterPipeClauseContext()
}

type AlterPipeClauseContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	fileName IStringContext
}

func NewEmptyAlterPipeClauseContext() *AlterPipeClauseContext {
	var p = new(AlterPipeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterPipeClause
	return p
}

func InitEmptyAlterPipeClauseContext(p *AlterPipeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterPipeClause
}

func (*AlterPipeClauseContext) IsAlterPipeClauseContext() {}

func NewAlterPipeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterPipeClauseContext {
	var p = new(AlterPipeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_alterPipeClause

	return p
}

func (s *AlterPipeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterPipeClauseContext) GetFileName() IStringContext { return s.fileName }

func (s *AlterPipeClauseContext) SetFileName(v IStringContext) { s.fileName = v }

func (s *AlterPipeClauseContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSUSPEND, 0)
}

func (s *AlterPipeClauseContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRESUME, 0)
}

func (s *AlterPipeClauseContext) RETRY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRETRY, 0)
}

func (s *AlterPipeClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, 0)
}

func (s *AlterPipeClauseContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFILE, 0)
}

func (s *AlterPipeClauseContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AlterPipeClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *AlterPipeClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *AlterPipeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterPipeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterPipeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAlterPipeClause(s)
	}
}

func (s *AlterPipeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAlterPipeClause(s)
	}
}

func (s *AlterPipeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAlterPipeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AlterPipeClause() (localctx IAlterPipeClauseContext) {
	localctx = NewAlterPipeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 670, DorisSQLParserParserRULE_alterPipeClause)
	p.SetState(5514)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 595, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5505)
			p.Match(DorisSQLParserParserSUSPEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5506)
			p.Match(DorisSQLParserParserRESUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5507)
			p.Match(DorisSQLParserParserRETRY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5508)
			p.Match(DorisSQLParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5509)
			p.Match(DorisSQLParserParserRETRY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5510)
			p.Match(DorisSQLParserParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5511)

			var _x = p.String_()

			localctx.(*AlterPipeClauseContext).fileName = _x
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5512)
			p.Match(DorisSQLParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5513)
			p.PropertyList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterPipeStatementContext is an interface to support dynamic dispatch.
type IAlterPipeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	PIPE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AlterPipeClause() IAlterPipeClauseContext

	// IsAlterPipeStatementContext differentiates from other interfaces.
	IsAlterPipeStatementContext()
}

type AlterPipeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterPipeStatementContext() *AlterPipeStatementContext {
	var p = new(AlterPipeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterPipeStatement
	return p
}

func InitEmptyAlterPipeStatementContext(p *AlterPipeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterPipeStatement
}

func (*AlterPipeStatementContext) IsAlterPipeStatementContext() {}

func NewAlterPipeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterPipeStatementContext {
	var p = new(AlterPipeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_alterPipeStatement

	return p
}

func (s *AlterPipeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterPipeStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *AlterPipeStatementContext) PIPE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPIPE, 0)
}

func (s *AlterPipeStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterPipeStatementContext) AlterPipeClause() IAlterPipeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterPipeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterPipeClauseContext)
}

func (s *AlterPipeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterPipeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterPipeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAlterPipeStatement(s)
	}
}

func (s *AlterPipeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAlterPipeStatement(s)
	}
}

func (s *AlterPipeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAlterPipeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AlterPipeStatement() (localctx IAlterPipeStatementContext) {
	localctx = NewAlterPipeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 672, DorisSQLParserParserRULE_alterPipeStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5516)
		p.Match(DorisSQLParserParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5517)
		p.Match(DorisSQLParserParserPIPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5518)
		p.QualifiedName()
	}
	{
		p.SetState(5519)
		p.AlterPipeClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescPipeStatementContext is an interface to support dynamic dispatch.
type IDescPipeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PIPE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode

	// IsDescPipeStatementContext differentiates from other interfaces.
	IsDescPipeStatementContext()
}

type DescPipeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescPipeStatementContext() *DescPipeStatementContext {
	var p = new(DescPipeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_descPipeStatement
	return p
}

func InitEmptyDescPipeStatementContext(p *DescPipeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_descPipeStatement
}

func (*DescPipeStatementContext) IsDescPipeStatementContext() {}

func NewDescPipeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescPipeStatementContext {
	var p = new(DescPipeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_descPipeStatement

	return p
}

func (s *DescPipeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DescPipeStatementContext) PIPE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPIPE, 0)
}

func (s *DescPipeStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DescPipeStatementContext) DESC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDESC, 0)
}

func (s *DescPipeStatementContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDESCRIBE, 0)
}

func (s *DescPipeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescPipeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescPipeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDescPipeStatement(s)
	}
}

func (s *DescPipeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDescPipeStatement(s)
	}
}

func (s *DescPipeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDescPipeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DescPipeStatement() (localctx IDescPipeStatementContext) {
	localctx = NewDescPipeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 674, DorisSQLParserParserRULE_descPipeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5521)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserDESC || _la == DorisSQLParserParserDESCRIBE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5522)
		p.Match(DorisSQLParserParserPIPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5523)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowPipeStatementContext is an interface to support dynamic dispatch.
type IShowPipeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	PIPES() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	String_() IStringContext

	// IsShowPipeStatementContext differentiates from other interfaces.
	IsShowPipeStatementContext()
}

type ShowPipeStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowPipeStatementContext() *ShowPipeStatementContext {
	var p = new(ShowPipeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showPipeStatement
	return p
}

func InitEmptyShowPipeStatementContext(p *ShowPipeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showPipeStatement
}

func (*ShowPipeStatementContext) IsShowPipeStatementContext() {}

func NewShowPipeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowPipeStatementContext {
	var p = new(ShowPipeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showPipeStatement

	return p
}

func (s *ShowPipeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowPipeStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowPipeStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowPipeStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowPipeStatementContext) PIPES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPIPES, 0)
}

func (s *ShowPipeStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserORDER, 0)
}

func (s *ShowPipeStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *ShowPipeStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowPipeStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowPipeStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowPipeStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *ShowPipeStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *ShowPipeStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowPipeStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowPipeStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowPipeStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowPipeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPipeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowPipeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowPipeStatement(s)
	}
}

func (s *ShowPipeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowPipeStatement(s)
	}
}

func (s *ShowPipeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowPipeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowPipeStatement() (localctx IShowPipeStatementContext) {
	localctx = NewShowPipeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 676, DorisSQLParserParserRULE_showPipeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5525)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5526)
		p.Match(DorisSQLParserParserPIPES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5533)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserLIKE:
		{
			p.SetState(5527)
			p.Match(DorisSQLParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5528)

			var _x = p.String_()

			localctx.(*ShowPipeStatementContext).pattern = _x
		}

	case DorisSQLParserParserWHERE:
		{
			p.SetState(5529)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5530)
			p.expression(0)
		}

	case DorisSQLParserParserFROM:
		{
			p.SetState(5531)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5532)
			p.QualifiedName()
		}

	case DorisSQLParserParserEOF, DorisSQLParserParserLIMIT, DorisSQLParserParserORDER, DorisSQLParserParserSEMICOLON:

	default:
	}
	p.SetState(5545)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserORDER {
		{
			p.SetState(5535)
			p.Match(DorisSQLParserParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5536)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5537)
			p.SortItem()
		}
		p.SetState(5542)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(5538)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5539)
				p.SortItem()
			}

			p.SetState(5544)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(5548)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserLIMIT {
		{
			p.SetState(5547)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetStatementContext is an interface to support dynamic dispatch.
type ISetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	AllSetVar() []ISetVarContext
	SetVar(i int) ISetVarContext

	// IsSetStatementContext differentiates from other interfaces.
	IsSetStatementContext()
}

type SetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetStatementContext() *SetStatementContext {
	var p = new(SetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_setStatement
	return p
}

func InitEmptySetStatementContext(p *SetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_setStatement
}

func (*SetStatementContext) IsSetStatementContext() {}

func NewSetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetStatementContext {
	var p = new(SetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_setStatement

	return p
}

func (s *SetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *SetStatementContext) AllSetVar() []ISetVarContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISetVarContext); ok {
			len++
		}
	}

	tst := make([]ISetVarContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISetVarContext); ok {
			tst[i] = t.(ISetVarContext)
			i++
		}
	}

	return tst
}

func (s *SetStatementContext) SetVar(i int) ISetVarContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetVarContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetVarContext)
}

func (s *SetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSetStatement(s)
	}
}

func (s *SetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSetStatement(s)
	}
}

func (s *SetStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSetStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SetStatement() (localctx ISetStatementContext) {
	localctx = NewSetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 678, DorisSQLParserParserRULE_setStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5550)
		p.Match(DorisSQLParserParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5551)
		p.SetVar()
	}
	p.SetState(5556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(5552)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5553)
			p.SetVar()
		}

		p.SetState(5558)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetVarContext is an interface to support dynamic dispatch.
type ISetVarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSetVarContext differentiates from other interfaces.
	IsSetVarContext()
}

type SetVarContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetVarContext() *SetVarContext {
	var p = new(SetVarContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_setVar
	return p
}

func InitEmptySetVarContext(p *SetVarContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_setVar
}

func (*SetVarContext) IsSetVarContext() {}

func NewSetVarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetVarContext {
	var p = new(SetVarContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_setVar

	return p
}

func (s *SetVarContext) GetParser() antlr.Parser { return s.parser }

func (s *SetVarContext) CopyAll(ctx *SetVarContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SetVarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetVarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SetTransactionContext struct {
	SetVarContext
}

func NewSetTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetTransactionContext {
	var p = new(SetTransactionContext)

	InitEmptySetVarContext(&p.SetVarContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetVarContext))

	return p
}

func (s *SetTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTRANSACTION, 0)
}

func (s *SetTransactionContext) Transaction_characteristics() ITransaction_characteristicsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransaction_characteristicsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransaction_characteristicsContext)
}

func (s *SetTransactionContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *SetTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSetTransaction(s)
	}
}

func (s *SetTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSetTransaction(s)
	}
}

func (s *SetTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSetTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetNamesContext struct {
	SetVarContext
	charset IIdentifierOrStringContext
	collate IIdentifierOrStringContext
}

func NewSetNamesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetNamesContext {
	var p = new(SetNamesContext)

	InitEmptySetVarContext(&p.SetVarContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetVarContext))

	return p
}

func (s *SetNamesContext) GetCharset() IIdentifierOrStringContext { return s.charset }

func (s *SetNamesContext) GetCollate() IIdentifierOrStringContext { return s.collate }

func (s *SetNamesContext) SetCharset(v IIdentifierOrStringContext) { s.charset = v }

func (s *SetNamesContext) SetCollate(v IIdentifierOrStringContext) { s.collate = v }

func (s *SetNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetNamesContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCHAR, 0)
}

func (s *SetNamesContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *SetNamesContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCHARSET, 0)
}

func (s *SetNamesContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCHARACTER, 0)
}

func (s *SetNamesContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *SetNamesContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *SetNamesContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserDEFAULT)
}

func (s *SetNamesContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDEFAULT, i)
}

func (s *SetNamesContext) NAMES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNAMES, 0)
}

func (s *SetNamesContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLLATE, 0)
}

func (s *SetNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSetNames(s)
	}
}

func (s *SetNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSetNames(s)
	}
}

func (s *SetNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSetNames(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetPasswordContext struct {
	SetVarContext
}

func NewSetPasswordContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetPasswordContext {
	var p = new(SetPasswordContext)

	InitEmptySetVarContext(&p.SetVarContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetVarContext))

	return p
}

func (s *SetPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetPasswordContext) AllPASSWORD() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserPASSWORD)
}

func (s *SetPasswordContext) PASSWORD(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPASSWORD, i)
}

func (s *SetPasswordContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEQ, 0)
}

func (s *SetPasswordContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *SetPasswordContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFOR, 0)
}

func (s *SetPasswordContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *SetPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSetPassword(s)
	}
}

func (s *SetPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSetPassword(s)
	}
}

func (s *SetPasswordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSetPassword(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetUserVarContext struct {
	SetVarContext
}

func NewSetUserVarContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetUserVarContext {
	var p = new(SetUserVarContext)

	InitEmptySetVarContext(&p.SetVarContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetVarContext))

	return p
}

func (s *SetUserVarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetUserVarContext) UserVariable() IUserVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariableContext)
}

func (s *SetUserVarContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEQ, 0)
}

func (s *SetUserVarContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetUserVarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSetUserVar(s)
	}
}

func (s *SetUserVarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSetUserVar(s)
	}
}

func (s *SetUserVarContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSetUserVar(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetSystemVarContext struct {
	SetVarContext
}

func NewSetSystemVarContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetSystemVarContext {
	var p = new(SetSystemVarContext)

	InitEmptySetVarContext(&p.SetVarContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetVarContext))

	return p
}

func (s *SetSystemVarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetSystemVarContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetSystemVarContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEQ, 0)
}

func (s *SetSystemVarContext) SetExprOrDefault() ISetExprOrDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetExprOrDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetExprOrDefaultContext)
}

func (s *SetSystemVarContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *SetSystemVarContext) SystemVariable() ISystemVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISystemVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISystemVariableContext)
}

func (s *SetSystemVarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSetSystemVar(s)
	}
}

func (s *SetSystemVarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSetSystemVar(s)
	}
}

func (s *SetSystemVarContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSetSystemVar(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SetVar() (localctx ISetVarContext) {
	localctx = NewSetVarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 680, DorisSQLParserParserRULE_setVar)
	var _la int

	p.SetState(5624)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 610, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSetNamesContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5564)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserParserCHAR:
			{
				p.SetState(5559)
				p.Match(DorisSQLParserParserCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5560)
				p.Match(DorisSQLParserParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisSQLParserParserCHARSET:
			{
				p.SetState(5561)
				p.Match(DorisSQLParserParserCHARSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisSQLParserParserCHARACTER:
			{
				p.SetState(5562)
				p.Match(DorisSQLParserParserCHARACTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5563)
				p.Match(DorisSQLParserParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(5568)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserParserACCESS, DorisSQLParserParserACTIVE, DorisSQLParserParserADMIN, DorisSQLParserParserADVISOR, DorisSQLParserParserAFTER, DorisSQLParserParserAGGREGATE, DorisSQLParserParserANTI, DorisSQLParserParserAPPLY, DorisSQLParserParserARRAY_AGG, DorisSQLParserParserARRAY_AGG_DISTINCT, DorisSQLParserParserASYNC, DorisSQLParserParserAUTHORS, DorisSQLParserParserAUTHENTICATION, DorisSQLParserParserAUTOMATED, DorisSQLParserParserAUTO_INCREMENT, DorisSQLParserParserAVG, DorisSQLParserParserBACKEND, DorisSQLParserParserBACKENDS, DorisSQLParserParserBACKUP, DorisSQLParserParserBASE, DorisSQLParserParserBASELINE, DorisSQLParserParserBEGIN, DorisSQLParserParserBINARY, DorisSQLParserParserBITMAP_UNION, DorisSQLParserParserBLACKHOLE, DorisSQLParserParserBLACKLIST, DorisSQLParserParserBODY, DorisSQLParserParserBOOLEAN, DorisSQLParserParserBRANCH, DorisSQLParserParserBROKER, DorisSQLParserParserBUCKETS, DorisSQLParserParserBUILTIN, DorisSQLParserParserCACHE, DorisSQLParserParserCANCEL, DorisSQLParserParserCAST, DorisSQLParserParserCATALOG, DorisSQLParserParserCATALOGS, DorisSQLParserParserCEIL, DorisSQLParserParserCHAIN, DorisSQLParserParserCHARSET, DorisSQLParserParserCLEAN, DorisSQLParserParserCLEAR, DorisSQLParserParserCLUSTER, DorisSQLParserParserCLUSTERS, DorisSQLParserParserCNGROUP, DorisSQLParserParserCNGROUPS, DorisSQLParserParserCOLLATION, DorisSQLParserParserCOLUMNS, DorisSQLParserParserCOMMENT, DorisSQLParserParserCOMMIT, DorisSQLParserParserCOMMITTED, DorisSQLParserParserCOMPACT, DorisSQLParserParserCOMPUTE, DorisSQLParserParserCONFIG, DorisSQLParserParserCONNECTION, DorisSQLParserParserCONSISTENT, DorisSQLParserParserCOSTS, DorisSQLParserParserCOUNT, DorisSQLParserParserCUME_DIST, DorisSQLParserParserCUMULATIVE, DorisSQLParserParserCURRENT, DorisSQLParserParserDATA, DorisSQLParserParserDATACACHE, DorisSQLParserParserDATE, DorisSQLParserParserDATETIME, DorisSQLParserParserDAY, DorisSQLParserParserDAYS, DorisSQLParserParserDEALLOCATE, DorisSQLParserParserDECOMMISSION, DorisSQLParserParserDIALECT, DorisSQLParserParserDICTIONARY, DorisSQLParserParserDICTIONARY_GET, DorisSQLParserParserDISABLE, DorisSQLParserParserDISTRIBUTED, DorisSQLParserParserDISTRIBUTION, DorisSQLParserParserDUPLICATE, DorisSQLParserParserDYNAMIC, DorisSQLParserParserENABLE, DorisSQLParserParserENCLOSE, DorisSQLParserParserEND, DorisSQLParserParserENGINE, DorisSQLParserParserENGINES, DorisSQLParserParserERRORS, DorisSQLParserParserESCAPE, DorisSQLParserParserEVENTS, DorisSQLParserParserEXCEPT, DorisSQLParserParserEXCLUDE, DorisSQLParserParserEXECUTE, DorisSQLParserParserEXPORT, DorisSQLParserParserEXTERNAL, DorisSQLParserParserEXTRACT, DorisSQLParserParserEVERY, DorisSQLParserParserFAILPOINT, DorisSQLParserParserFAILPOINTS, DorisSQLParserParserFIELDS, DorisSQLParserParserFILE, DorisSQLParserParserFILTER, DorisSQLParserParserFIRST, DorisSQLParserParserFLOOR, DorisSQLParserParserFN, DorisSQLParserParserFOLLOWING, DorisSQLParserParserFOLLOWER, DorisSQLParserParserFORMAT, DorisSQLParserParserFREE, DorisSQLParserParserFRONTEND, DorisSQLParserParserFRONTENDS, DorisSQLParserParserFUNCTIONS, DorisSQLParserParserGLOBAL, DorisSQLParserParserGRANTS, DorisSQLParserParserGROUP_CONCAT, DorisSQLParserParserHASH, DorisSQLParserParserHELP, DorisSQLParserParserHISTOGRAM, DorisSQLParserParserHLL_UNION, DorisSQLParserParserHOST, DorisSQLParserParserHOUR, DorisSQLParserParserHOURS, DorisSQLParserParserHUB, DorisSQLParserParserIDENTIFIED, DorisSQLParserParserIMPERSONATE, DorisSQLParserParserIMAGE, DorisSQLParserParserINACTIVE, DorisSQLParserParserINCREMENTAL, DorisSQLParserParserINDEXES, DorisSQLParserParserINSTALL, DorisSQLParserParserINTEGRATION, DorisSQLParserParserINTEGRATIONS, DorisSQLParserParserINTERMEDIATE, DorisSQLParserParserINTERVAL, DorisSQLParserParserOVERWRITE, DorisSQLParserParserISOLATION, DorisSQLParserParserJOB, DorisSQLParserParserLABEL, DorisSQLParserParserLAST, DorisSQLParserParserLESS, DorisSQLParserParserLEVEL, DorisSQLParserParserLIST, DorisSQLParserParserLOCAL, DorisSQLParserParserLOCATION, DorisSQLParserParserLOCATIONS, DorisSQLParserParserLOGS, DorisSQLParserParserLOGICAL, DorisSQLParserParserMANUAL, DorisSQLParserParserMAP, DorisSQLParserParserMAPPING, DorisSQLParserParserMAPPINGS, DorisSQLParserParserMASKING, DorisSQLParserParserMATCH, DorisSQLParserParserMATERIALIZED, DorisSQLParserParserMAX, DorisSQLParserParserMERGE, DorisSQLParserParserMIN, DorisSQLParserParserMINUTE, DorisSQLParserParserMINUTES, DorisSQLParserParserMINUS, DorisSQLParserParserMETA, DorisSQLParserParserMODE, DorisSQLParserParserMODIFY, DorisSQLParserParserMONTH, DorisSQLParserParserMULTIPLE, DorisSQLParserParserNAME, DorisSQLParserParserNAMES, DorisSQLParserParserNEGATIVE, DorisSQLParserParserNGRAMBF, DorisSQLParserParserNO, DorisSQLParserParserNODE, DorisSQLParserParserNODES, DorisSQLParserParserNONE, DorisSQLParserParserNULLS, DorisSQLParserParserNUMBER, DorisSQLParserParserNUMERIC, DorisSQLParserParserOBSERVER, DorisSQLParserParserOF, DorisSQLParserParserOFF, DorisSQLParserParserOFFSET, DorisSQLParserParserONLY, DorisSQLParserParserOPEN, DorisSQLParserParserOPERATE, DorisSQLParserParserOPTIMIZER, DorisSQLParserParserOPTION, DorisSQLParserParserPARTITIONS, DorisSQLParserParserPASSWORD, DorisSQLParserParserPATH, DorisSQLParserParserPAUSE, DorisSQLParserParserPENDING, DorisSQLParserParserPERCENT_RANK, DorisSQLParserParserPERCENTILE_UNION, DorisSQLParserParserPLAN, DorisSQLParserParserPLUGIN, DorisSQLParserParserPLUGINS, DorisSQLParserParserPIPE, DorisSQLParserParserPIPES, DorisSQLParserParserPIVOT, DorisSQLParserParserPOLICY, DorisSQLParserParserPOLICIES, DorisSQLParserParserPRECEDING, DorisSQLParserParserPREDICATE, DorisSQLParserParserPRIORITY, DorisSQLParserParserPRIVILEGES, DorisSQLParserParserPROBABILITY, DorisSQLParserParserPROC, DorisSQLParserParserPROCESSLIST, DorisSQLParserParserPROFILE, DorisSQLParserParserPROFILELIST, DorisSQLParserParserPROPERTIES, DorisSQLParserParserPROPERTY, DorisSQLParserParserPROVIDER, DorisSQLParserParserPROVIDERS, DorisSQLParserParserQUALIFY, DorisSQLParserParserQUARTER, DorisSQLParserParserQUERY, DorisSQLParserParserQUERIES, DorisSQLParserParserQUEUE, DorisSQLParserParserQUOTA, DorisSQLParserParserRANDOM, DorisSQLParserParserRANK, DorisSQLParserParserREASON, DorisSQLParserParserRECOVER, DorisSQLParserParserREFRESH, DorisSQLParserParserREWRITE, DorisSQLParserParserREMOVE, DorisSQLParserParserREPAIR, DorisSQLParserParserREPEATABLE, DorisSQLParserParserREPLACE_IF_NOT_NULL, DorisSQLParserParserREPLICA, DorisSQLParserParserREPOSITORY, DorisSQLParserParserREPOSITORIES, DorisSQLParserParserRESOURCE, DorisSQLParserParserRESOURCES, DorisSQLParserParserRESTORE, DorisSQLParserParserRESUME, DorisSQLParserParserRETAIN, DorisSQLParserParserRETENTION, DorisSQLParserParserRETURNS, DorisSQLParserParserRETRY, DorisSQLParserParserREVERT, DorisSQLParserParserROLE, DorisSQLParserParserROLES, DorisSQLParserParserROLLBACK, DorisSQLParserParserROLLUP, DorisSQLParserParserROUTINE, DorisSQLParserParserROW, DorisSQLParserParserRULE, DorisSQLParserParserRULES, DorisSQLParserParserRUNNING, DorisSQLParserParserSAMPLE, DorisSQLParserParserSCHEDULE, DorisSQLParserParserSCHEDULER, DorisSQLParserParserSECOND, DorisSQLParserParserSECURITY, DorisSQLParserParserSEMI, DorisSQLParserParserSEPARATOR, DorisSQLParserParserSERIALIZABLE, DorisSQLParserParserSESSION, DorisSQLParserParserSETS, DorisSQLParserParserSIGNED, DorisSQLParserParserSKIP_HEADER, DorisSQLParserParserSNAPSHOT, DorisSQLParserParserSNAPSHOTS, DorisSQLParserParserSQLBLACKLIST, DorisSQLParserParserSTART, DorisSQLParserParserSTATS, DorisSQLParserParserSTATUS, DorisSQLParserParserSTOP, DorisSQLParserParserSTORAGE, DorisSQLParserParserSTREAM, DorisSQLParserParserSTRING, DorisSQLParserParserSUBMIT, DorisSQLParserParserSUM, DorisSQLParserParserSUSPEND, DorisSQLParserParserSYNC, DorisSQLParserParserSYSTEM_TIME, DorisSQLParserParserSWAP, DorisSQLParserParserSTRUCT, DorisSQLParserParserTABLES, DorisSQLParserParserTABLET, DorisSQLParserParserTABLETS, DorisSQLParserParserTAG, DorisSQLParserParserTASK, DorisSQLParserParserTEMPORARY, DorisSQLParserParserTHAN, DorisSQLParserParserTIME, DorisSQLParserParserTIMES, DorisSQLParserParserTIMESTAMP, DorisSQLParserParserTIMESTAMPADD, DorisSQLParserParserTIMESTAMPDIFF, DorisSQLParserParserTRANSACTION, DorisSQLParserParserTRANSLATE, DorisSQLParserParserTRACE, DorisSQLParserParserTRIGGERS, DorisSQLParserParserTRIM_SPACE, DorisSQLParserParserTRUNCATE, DorisSQLParserParserTYPE, DorisSQLParserParserTYPES, DorisSQLParserParserUNBOUNDED, DorisSQLParserParserUNCOMMITTED, DorisSQLParserParserUNINSTALL, DorisSQLParserParserUNSET, DorisSQLParserParserUSAGE, DorisSQLParserParserUSER, DorisSQLParserParserUSERS, DorisSQLParserParserVALUE, DorisSQLParserParserVARBINARY, DorisSQLParserParserVARIABLES, DorisSQLParserParserVECTOR, DorisSQLParserParserVERBOSE, DorisSQLParserParserVERSION, DorisSQLParserParserVIEW, DorisSQLParserParserVIEWS, DorisSQLParserParserVOLUME, DorisSQLParserParserVOLUMES, DorisSQLParserParserWAREHOUSE, DorisSQLParserParserWAREHOUSES, DorisSQLParserParserWARNINGS, DorisSQLParserParserWEEK, DorisSQLParserParserWHITELIST, DorisSQLParserParserWORK, DorisSQLParserParserWRITE, DorisSQLParserParserYEAR, DorisSQLParserParserLOCK, DorisSQLParserParserUNLOCK, DorisSQLParserParserLOW_PRIORITY, DorisSQLParserParserDISK, DorisSQLParserParserBEFORE, DorisSQLParserParserFIELD, DorisSQLParserParserPERSISTENT, DorisSQLParserParserARRAY_ELEMENT, DorisSQLParserParserSINGLE_QUOTED_TEXT, DorisSQLParserParserDOUBLE_QUOTED_TEXT, DorisSQLParserParserLETTER_IDENTIFIER, DorisSQLParserParserDIGIT_IDENTIFIER, DorisSQLParserParserBACKQUOTED_IDENTIFIER, DorisSQLParserParserDOTDOTDOT:
			{
				p.SetState(5566)
				p.IdentifierOrString()
			}

		case DorisSQLParserParserDEFAULT:
			{
				p.SetState(5567)
				p.Match(DorisSQLParserParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		localctx = NewSetNamesContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5570)
			p.Match(DorisSQLParserParserNAMES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5573)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserParserACCESS, DorisSQLParserParserACTIVE, DorisSQLParserParserADMIN, DorisSQLParserParserADVISOR, DorisSQLParserParserAFTER, DorisSQLParserParserAGGREGATE, DorisSQLParserParserANTI, DorisSQLParserParserAPPLY, DorisSQLParserParserARRAY_AGG, DorisSQLParserParserARRAY_AGG_DISTINCT, DorisSQLParserParserASYNC, DorisSQLParserParserAUTHORS, DorisSQLParserParserAUTHENTICATION, DorisSQLParserParserAUTOMATED, DorisSQLParserParserAUTO_INCREMENT, DorisSQLParserParserAVG, DorisSQLParserParserBACKEND, DorisSQLParserParserBACKENDS, DorisSQLParserParserBACKUP, DorisSQLParserParserBASE, DorisSQLParserParserBASELINE, DorisSQLParserParserBEGIN, DorisSQLParserParserBINARY, DorisSQLParserParserBITMAP_UNION, DorisSQLParserParserBLACKHOLE, DorisSQLParserParserBLACKLIST, DorisSQLParserParserBODY, DorisSQLParserParserBOOLEAN, DorisSQLParserParserBRANCH, DorisSQLParserParserBROKER, DorisSQLParserParserBUCKETS, DorisSQLParserParserBUILTIN, DorisSQLParserParserCACHE, DorisSQLParserParserCANCEL, DorisSQLParserParserCAST, DorisSQLParserParserCATALOG, DorisSQLParserParserCATALOGS, DorisSQLParserParserCEIL, DorisSQLParserParserCHAIN, DorisSQLParserParserCHARSET, DorisSQLParserParserCLEAN, DorisSQLParserParserCLEAR, DorisSQLParserParserCLUSTER, DorisSQLParserParserCLUSTERS, DorisSQLParserParserCNGROUP, DorisSQLParserParserCNGROUPS, DorisSQLParserParserCOLLATION, DorisSQLParserParserCOLUMNS, DorisSQLParserParserCOMMENT, DorisSQLParserParserCOMMIT, DorisSQLParserParserCOMMITTED, DorisSQLParserParserCOMPACT, DorisSQLParserParserCOMPUTE, DorisSQLParserParserCONFIG, DorisSQLParserParserCONNECTION, DorisSQLParserParserCONSISTENT, DorisSQLParserParserCOSTS, DorisSQLParserParserCOUNT, DorisSQLParserParserCUME_DIST, DorisSQLParserParserCUMULATIVE, DorisSQLParserParserCURRENT, DorisSQLParserParserDATA, DorisSQLParserParserDATACACHE, DorisSQLParserParserDATE, DorisSQLParserParserDATETIME, DorisSQLParserParserDAY, DorisSQLParserParserDAYS, DorisSQLParserParserDEALLOCATE, DorisSQLParserParserDECOMMISSION, DorisSQLParserParserDIALECT, DorisSQLParserParserDICTIONARY, DorisSQLParserParserDICTIONARY_GET, DorisSQLParserParserDISABLE, DorisSQLParserParserDISTRIBUTED, DorisSQLParserParserDISTRIBUTION, DorisSQLParserParserDUPLICATE, DorisSQLParserParserDYNAMIC, DorisSQLParserParserENABLE, DorisSQLParserParserENCLOSE, DorisSQLParserParserEND, DorisSQLParserParserENGINE, DorisSQLParserParserENGINES, DorisSQLParserParserERRORS, DorisSQLParserParserESCAPE, DorisSQLParserParserEVENTS, DorisSQLParserParserEXCEPT, DorisSQLParserParserEXCLUDE, DorisSQLParserParserEXECUTE, DorisSQLParserParserEXPORT, DorisSQLParserParserEXTERNAL, DorisSQLParserParserEXTRACT, DorisSQLParserParserEVERY, DorisSQLParserParserFAILPOINT, DorisSQLParserParserFAILPOINTS, DorisSQLParserParserFIELDS, DorisSQLParserParserFILE, DorisSQLParserParserFILTER, DorisSQLParserParserFIRST, DorisSQLParserParserFLOOR, DorisSQLParserParserFN, DorisSQLParserParserFOLLOWING, DorisSQLParserParserFOLLOWER, DorisSQLParserParserFORMAT, DorisSQLParserParserFREE, DorisSQLParserParserFRONTEND, DorisSQLParserParserFRONTENDS, DorisSQLParserParserFUNCTIONS, DorisSQLParserParserGLOBAL, DorisSQLParserParserGRANTS, DorisSQLParserParserGROUP_CONCAT, DorisSQLParserParserHASH, DorisSQLParserParserHELP, DorisSQLParserParserHISTOGRAM, DorisSQLParserParserHLL_UNION, DorisSQLParserParserHOST, DorisSQLParserParserHOUR, DorisSQLParserParserHOURS, DorisSQLParserParserHUB, DorisSQLParserParserIDENTIFIED, DorisSQLParserParserIMPERSONATE, DorisSQLParserParserIMAGE, DorisSQLParserParserINACTIVE, DorisSQLParserParserINCREMENTAL, DorisSQLParserParserINDEXES, DorisSQLParserParserINSTALL, DorisSQLParserParserINTEGRATION, DorisSQLParserParserINTEGRATIONS, DorisSQLParserParserINTERMEDIATE, DorisSQLParserParserINTERVAL, DorisSQLParserParserOVERWRITE, DorisSQLParserParserISOLATION, DorisSQLParserParserJOB, DorisSQLParserParserLABEL, DorisSQLParserParserLAST, DorisSQLParserParserLESS, DorisSQLParserParserLEVEL, DorisSQLParserParserLIST, DorisSQLParserParserLOCAL, DorisSQLParserParserLOCATION, DorisSQLParserParserLOCATIONS, DorisSQLParserParserLOGS, DorisSQLParserParserLOGICAL, DorisSQLParserParserMANUAL, DorisSQLParserParserMAP, DorisSQLParserParserMAPPING, DorisSQLParserParserMAPPINGS, DorisSQLParserParserMASKING, DorisSQLParserParserMATCH, DorisSQLParserParserMATERIALIZED, DorisSQLParserParserMAX, DorisSQLParserParserMERGE, DorisSQLParserParserMIN, DorisSQLParserParserMINUTE, DorisSQLParserParserMINUTES, DorisSQLParserParserMINUS, DorisSQLParserParserMETA, DorisSQLParserParserMODE, DorisSQLParserParserMODIFY, DorisSQLParserParserMONTH, DorisSQLParserParserMULTIPLE, DorisSQLParserParserNAME, DorisSQLParserParserNAMES, DorisSQLParserParserNEGATIVE, DorisSQLParserParserNGRAMBF, DorisSQLParserParserNO, DorisSQLParserParserNODE, DorisSQLParserParserNODES, DorisSQLParserParserNONE, DorisSQLParserParserNULLS, DorisSQLParserParserNUMBER, DorisSQLParserParserNUMERIC, DorisSQLParserParserOBSERVER, DorisSQLParserParserOF, DorisSQLParserParserOFF, DorisSQLParserParserOFFSET, DorisSQLParserParserONLY, DorisSQLParserParserOPEN, DorisSQLParserParserOPERATE, DorisSQLParserParserOPTIMIZER, DorisSQLParserParserOPTION, DorisSQLParserParserPARTITIONS, DorisSQLParserParserPASSWORD, DorisSQLParserParserPATH, DorisSQLParserParserPAUSE, DorisSQLParserParserPENDING, DorisSQLParserParserPERCENT_RANK, DorisSQLParserParserPERCENTILE_UNION, DorisSQLParserParserPLAN, DorisSQLParserParserPLUGIN, DorisSQLParserParserPLUGINS, DorisSQLParserParserPIPE, DorisSQLParserParserPIPES, DorisSQLParserParserPIVOT, DorisSQLParserParserPOLICY, DorisSQLParserParserPOLICIES, DorisSQLParserParserPRECEDING, DorisSQLParserParserPREDICATE, DorisSQLParserParserPRIORITY, DorisSQLParserParserPRIVILEGES, DorisSQLParserParserPROBABILITY, DorisSQLParserParserPROC, DorisSQLParserParserPROCESSLIST, DorisSQLParserParserPROFILE, DorisSQLParserParserPROFILELIST, DorisSQLParserParserPROPERTIES, DorisSQLParserParserPROPERTY, DorisSQLParserParserPROVIDER, DorisSQLParserParserPROVIDERS, DorisSQLParserParserQUALIFY, DorisSQLParserParserQUARTER, DorisSQLParserParserQUERY, DorisSQLParserParserQUERIES, DorisSQLParserParserQUEUE, DorisSQLParserParserQUOTA, DorisSQLParserParserRANDOM, DorisSQLParserParserRANK, DorisSQLParserParserREASON, DorisSQLParserParserRECOVER, DorisSQLParserParserREFRESH, DorisSQLParserParserREWRITE, DorisSQLParserParserREMOVE, DorisSQLParserParserREPAIR, DorisSQLParserParserREPEATABLE, DorisSQLParserParserREPLACE_IF_NOT_NULL, DorisSQLParserParserREPLICA, DorisSQLParserParserREPOSITORY, DorisSQLParserParserREPOSITORIES, DorisSQLParserParserRESOURCE, DorisSQLParserParserRESOURCES, DorisSQLParserParserRESTORE, DorisSQLParserParserRESUME, DorisSQLParserParserRETAIN, DorisSQLParserParserRETENTION, DorisSQLParserParserRETURNS, DorisSQLParserParserRETRY, DorisSQLParserParserREVERT, DorisSQLParserParserROLE, DorisSQLParserParserROLES, DorisSQLParserParserROLLBACK, DorisSQLParserParserROLLUP, DorisSQLParserParserROUTINE, DorisSQLParserParserROW, DorisSQLParserParserRULE, DorisSQLParserParserRULES, DorisSQLParserParserRUNNING, DorisSQLParserParserSAMPLE, DorisSQLParserParserSCHEDULE, DorisSQLParserParserSCHEDULER, DorisSQLParserParserSECOND, DorisSQLParserParserSECURITY, DorisSQLParserParserSEMI, DorisSQLParserParserSEPARATOR, DorisSQLParserParserSERIALIZABLE, DorisSQLParserParserSESSION, DorisSQLParserParserSETS, DorisSQLParserParserSIGNED, DorisSQLParserParserSKIP_HEADER, DorisSQLParserParserSNAPSHOT, DorisSQLParserParserSNAPSHOTS, DorisSQLParserParserSQLBLACKLIST, DorisSQLParserParserSTART, DorisSQLParserParserSTATS, DorisSQLParserParserSTATUS, DorisSQLParserParserSTOP, DorisSQLParserParserSTORAGE, DorisSQLParserParserSTREAM, DorisSQLParserParserSTRING, DorisSQLParserParserSUBMIT, DorisSQLParserParserSUM, DorisSQLParserParserSUSPEND, DorisSQLParserParserSYNC, DorisSQLParserParserSYSTEM_TIME, DorisSQLParserParserSWAP, DorisSQLParserParserSTRUCT, DorisSQLParserParserTABLES, DorisSQLParserParserTABLET, DorisSQLParserParserTABLETS, DorisSQLParserParserTAG, DorisSQLParserParserTASK, DorisSQLParserParserTEMPORARY, DorisSQLParserParserTHAN, DorisSQLParserParserTIME, DorisSQLParserParserTIMES, DorisSQLParserParserTIMESTAMP, DorisSQLParserParserTIMESTAMPADD, DorisSQLParserParserTIMESTAMPDIFF, DorisSQLParserParserTRANSACTION, DorisSQLParserParserTRANSLATE, DorisSQLParserParserTRACE, DorisSQLParserParserTRIGGERS, DorisSQLParserParserTRIM_SPACE, DorisSQLParserParserTRUNCATE, DorisSQLParserParserTYPE, DorisSQLParserParserTYPES, DorisSQLParserParserUNBOUNDED, DorisSQLParserParserUNCOMMITTED, DorisSQLParserParserUNINSTALL, DorisSQLParserParserUNSET, DorisSQLParserParserUSAGE, DorisSQLParserParserUSER, DorisSQLParserParserUSERS, DorisSQLParserParserVALUE, DorisSQLParserParserVARBINARY, DorisSQLParserParserVARIABLES, DorisSQLParserParserVECTOR, DorisSQLParserParserVERBOSE, DorisSQLParserParserVERSION, DorisSQLParserParserVIEW, DorisSQLParserParserVIEWS, DorisSQLParserParserVOLUME, DorisSQLParserParserVOLUMES, DorisSQLParserParserWAREHOUSE, DorisSQLParserParserWAREHOUSES, DorisSQLParserParserWARNINGS, DorisSQLParserParserWEEK, DorisSQLParserParserWHITELIST, DorisSQLParserParserWORK, DorisSQLParserParserWRITE, DorisSQLParserParserYEAR, DorisSQLParserParserLOCK, DorisSQLParserParserUNLOCK, DorisSQLParserParserLOW_PRIORITY, DorisSQLParserParserDISK, DorisSQLParserParserBEFORE, DorisSQLParserParserFIELD, DorisSQLParserParserPERSISTENT, DorisSQLParserParserARRAY_ELEMENT, DorisSQLParserParserSINGLE_QUOTED_TEXT, DorisSQLParserParserDOUBLE_QUOTED_TEXT, DorisSQLParserParserLETTER_IDENTIFIER, DorisSQLParserParserDIGIT_IDENTIFIER, DorisSQLParserParserBACKQUOTED_IDENTIFIER, DorisSQLParserParserDOTDOTDOT:
			{
				p.SetState(5571)

				var _x = p.IdentifierOrString()

				localctx.(*SetNamesContext).charset = _x
			}

		case DorisSQLParserParserDEFAULT:
			{
				p.SetState(5572)
				p.Match(DorisSQLParserParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(5580)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserCOLLATE {
			{
				p.SetState(5575)
				p.Match(DorisSQLParserParserCOLLATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5578)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisSQLParserParserACCESS, DorisSQLParserParserACTIVE, DorisSQLParserParserADMIN, DorisSQLParserParserADVISOR, DorisSQLParserParserAFTER, DorisSQLParserParserAGGREGATE, DorisSQLParserParserANTI, DorisSQLParserParserAPPLY, DorisSQLParserParserARRAY_AGG, DorisSQLParserParserARRAY_AGG_DISTINCT, DorisSQLParserParserASYNC, DorisSQLParserParserAUTHORS, DorisSQLParserParserAUTHENTICATION, DorisSQLParserParserAUTOMATED, DorisSQLParserParserAUTO_INCREMENT, DorisSQLParserParserAVG, DorisSQLParserParserBACKEND, DorisSQLParserParserBACKENDS, DorisSQLParserParserBACKUP, DorisSQLParserParserBASE, DorisSQLParserParserBASELINE, DorisSQLParserParserBEGIN, DorisSQLParserParserBINARY, DorisSQLParserParserBITMAP_UNION, DorisSQLParserParserBLACKHOLE, DorisSQLParserParserBLACKLIST, DorisSQLParserParserBODY, DorisSQLParserParserBOOLEAN, DorisSQLParserParserBRANCH, DorisSQLParserParserBROKER, DorisSQLParserParserBUCKETS, DorisSQLParserParserBUILTIN, DorisSQLParserParserCACHE, DorisSQLParserParserCANCEL, DorisSQLParserParserCAST, DorisSQLParserParserCATALOG, DorisSQLParserParserCATALOGS, DorisSQLParserParserCEIL, DorisSQLParserParserCHAIN, DorisSQLParserParserCHARSET, DorisSQLParserParserCLEAN, DorisSQLParserParserCLEAR, DorisSQLParserParserCLUSTER, DorisSQLParserParserCLUSTERS, DorisSQLParserParserCNGROUP, DorisSQLParserParserCNGROUPS, DorisSQLParserParserCOLLATION, DorisSQLParserParserCOLUMNS, DorisSQLParserParserCOMMENT, DorisSQLParserParserCOMMIT, DorisSQLParserParserCOMMITTED, DorisSQLParserParserCOMPACT, DorisSQLParserParserCOMPUTE, DorisSQLParserParserCONFIG, DorisSQLParserParserCONNECTION, DorisSQLParserParserCONSISTENT, DorisSQLParserParserCOSTS, DorisSQLParserParserCOUNT, DorisSQLParserParserCUME_DIST, DorisSQLParserParserCUMULATIVE, DorisSQLParserParserCURRENT, DorisSQLParserParserDATA, DorisSQLParserParserDATACACHE, DorisSQLParserParserDATE, DorisSQLParserParserDATETIME, DorisSQLParserParserDAY, DorisSQLParserParserDAYS, DorisSQLParserParserDEALLOCATE, DorisSQLParserParserDECOMMISSION, DorisSQLParserParserDIALECT, DorisSQLParserParserDICTIONARY, DorisSQLParserParserDICTIONARY_GET, DorisSQLParserParserDISABLE, DorisSQLParserParserDISTRIBUTED, DorisSQLParserParserDISTRIBUTION, DorisSQLParserParserDUPLICATE, DorisSQLParserParserDYNAMIC, DorisSQLParserParserENABLE, DorisSQLParserParserENCLOSE, DorisSQLParserParserEND, DorisSQLParserParserENGINE, DorisSQLParserParserENGINES, DorisSQLParserParserERRORS, DorisSQLParserParserESCAPE, DorisSQLParserParserEVENTS, DorisSQLParserParserEXCEPT, DorisSQLParserParserEXCLUDE, DorisSQLParserParserEXECUTE, DorisSQLParserParserEXPORT, DorisSQLParserParserEXTERNAL, DorisSQLParserParserEXTRACT, DorisSQLParserParserEVERY, DorisSQLParserParserFAILPOINT, DorisSQLParserParserFAILPOINTS, DorisSQLParserParserFIELDS, DorisSQLParserParserFILE, DorisSQLParserParserFILTER, DorisSQLParserParserFIRST, DorisSQLParserParserFLOOR, DorisSQLParserParserFN, DorisSQLParserParserFOLLOWING, DorisSQLParserParserFOLLOWER, DorisSQLParserParserFORMAT, DorisSQLParserParserFREE, DorisSQLParserParserFRONTEND, DorisSQLParserParserFRONTENDS, DorisSQLParserParserFUNCTIONS, DorisSQLParserParserGLOBAL, DorisSQLParserParserGRANTS, DorisSQLParserParserGROUP_CONCAT, DorisSQLParserParserHASH, DorisSQLParserParserHELP, DorisSQLParserParserHISTOGRAM, DorisSQLParserParserHLL_UNION, DorisSQLParserParserHOST, DorisSQLParserParserHOUR, DorisSQLParserParserHOURS, DorisSQLParserParserHUB, DorisSQLParserParserIDENTIFIED, DorisSQLParserParserIMPERSONATE, DorisSQLParserParserIMAGE, DorisSQLParserParserINACTIVE, DorisSQLParserParserINCREMENTAL, DorisSQLParserParserINDEXES, DorisSQLParserParserINSTALL, DorisSQLParserParserINTEGRATION, DorisSQLParserParserINTEGRATIONS, DorisSQLParserParserINTERMEDIATE, DorisSQLParserParserINTERVAL, DorisSQLParserParserOVERWRITE, DorisSQLParserParserISOLATION, DorisSQLParserParserJOB, DorisSQLParserParserLABEL, DorisSQLParserParserLAST, DorisSQLParserParserLESS, DorisSQLParserParserLEVEL, DorisSQLParserParserLIST, DorisSQLParserParserLOCAL, DorisSQLParserParserLOCATION, DorisSQLParserParserLOCATIONS, DorisSQLParserParserLOGS, DorisSQLParserParserLOGICAL, DorisSQLParserParserMANUAL, DorisSQLParserParserMAP, DorisSQLParserParserMAPPING, DorisSQLParserParserMAPPINGS, DorisSQLParserParserMASKING, DorisSQLParserParserMATCH, DorisSQLParserParserMATERIALIZED, DorisSQLParserParserMAX, DorisSQLParserParserMERGE, DorisSQLParserParserMIN, DorisSQLParserParserMINUTE, DorisSQLParserParserMINUTES, DorisSQLParserParserMINUS, DorisSQLParserParserMETA, DorisSQLParserParserMODE, DorisSQLParserParserMODIFY, DorisSQLParserParserMONTH, DorisSQLParserParserMULTIPLE, DorisSQLParserParserNAME, DorisSQLParserParserNAMES, DorisSQLParserParserNEGATIVE, DorisSQLParserParserNGRAMBF, DorisSQLParserParserNO, DorisSQLParserParserNODE, DorisSQLParserParserNODES, DorisSQLParserParserNONE, DorisSQLParserParserNULLS, DorisSQLParserParserNUMBER, DorisSQLParserParserNUMERIC, DorisSQLParserParserOBSERVER, DorisSQLParserParserOF, DorisSQLParserParserOFF, DorisSQLParserParserOFFSET, DorisSQLParserParserONLY, DorisSQLParserParserOPEN, DorisSQLParserParserOPERATE, DorisSQLParserParserOPTIMIZER, DorisSQLParserParserOPTION, DorisSQLParserParserPARTITIONS, DorisSQLParserParserPASSWORD, DorisSQLParserParserPATH, DorisSQLParserParserPAUSE, DorisSQLParserParserPENDING, DorisSQLParserParserPERCENT_RANK, DorisSQLParserParserPERCENTILE_UNION, DorisSQLParserParserPLAN, DorisSQLParserParserPLUGIN, DorisSQLParserParserPLUGINS, DorisSQLParserParserPIPE, DorisSQLParserParserPIPES, DorisSQLParserParserPIVOT, DorisSQLParserParserPOLICY, DorisSQLParserParserPOLICIES, DorisSQLParserParserPRECEDING, DorisSQLParserParserPREDICATE, DorisSQLParserParserPRIORITY, DorisSQLParserParserPRIVILEGES, DorisSQLParserParserPROBABILITY, DorisSQLParserParserPROC, DorisSQLParserParserPROCESSLIST, DorisSQLParserParserPROFILE, DorisSQLParserParserPROFILELIST, DorisSQLParserParserPROPERTIES, DorisSQLParserParserPROPERTY, DorisSQLParserParserPROVIDER, DorisSQLParserParserPROVIDERS, DorisSQLParserParserQUALIFY, DorisSQLParserParserQUARTER, DorisSQLParserParserQUERY, DorisSQLParserParserQUERIES, DorisSQLParserParserQUEUE, DorisSQLParserParserQUOTA, DorisSQLParserParserRANDOM, DorisSQLParserParserRANK, DorisSQLParserParserREASON, DorisSQLParserParserRECOVER, DorisSQLParserParserREFRESH, DorisSQLParserParserREWRITE, DorisSQLParserParserREMOVE, DorisSQLParserParserREPAIR, DorisSQLParserParserREPEATABLE, DorisSQLParserParserREPLACE_IF_NOT_NULL, DorisSQLParserParserREPLICA, DorisSQLParserParserREPOSITORY, DorisSQLParserParserREPOSITORIES, DorisSQLParserParserRESOURCE, DorisSQLParserParserRESOURCES, DorisSQLParserParserRESTORE, DorisSQLParserParserRESUME, DorisSQLParserParserRETAIN, DorisSQLParserParserRETENTION, DorisSQLParserParserRETURNS, DorisSQLParserParserRETRY, DorisSQLParserParserREVERT, DorisSQLParserParserROLE, DorisSQLParserParserROLES, DorisSQLParserParserROLLBACK, DorisSQLParserParserROLLUP, DorisSQLParserParserROUTINE, DorisSQLParserParserROW, DorisSQLParserParserRULE, DorisSQLParserParserRULES, DorisSQLParserParserRUNNING, DorisSQLParserParserSAMPLE, DorisSQLParserParserSCHEDULE, DorisSQLParserParserSCHEDULER, DorisSQLParserParserSECOND, DorisSQLParserParserSECURITY, DorisSQLParserParserSEMI, DorisSQLParserParserSEPARATOR, DorisSQLParserParserSERIALIZABLE, DorisSQLParserParserSESSION, DorisSQLParserParserSETS, DorisSQLParserParserSIGNED, DorisSQLParserParserSKIP_HEADER, DorisSQLParserParserSNAPSHOT, DorisSQLParserParserSNAPSHOTS, DorisSQLParserParserSQLBLACKLIST, DorisSQLParserParserSTART, DorisSQLParserParserSTATS, DorisSQLParserParserSTATUS, DorisSQLParserParserSTOP, DorisSQLParserParserSTORAGE, DorisSQLParserParserSTREAM, DorisSQLParserParserSTRING, DorisSQLParserParserSUBMIT, DorisSQLParserParserSUM, DorisSQLParserParserSUSPEND, DorisSQLParserParserSYNC, DorisSQLParserParserSYSTEM_TIME, DorisSQLParserParserSWAP, DorisSQLParserParserSTRUCT, DorisSQLParserParserTABLES, DorisSQLParserParserTABLET, DorisSQLParserParserTABLETS, DorisSQLParserParserTAG, DorisSQLParserParserTASK, DorisSQLParserParserTEMPORARY, DorisSQLParserParserTHAN, DorisSQLParserParserTIME, DorisSQLParserParserTIMES, DorisSQLParserParserTIMESTAMP, DorisSQLParserParserTIMESTAMPADD, DorisSQLParserParserTIMESTAMPDIFF, DorisSQLParserParserTRANSACTION, DorisSQLParserParserTRANSLATE, DorisSQLParserParserTRACE, DorisSQLParserParserTRIGGERS, DorisSQLParserParserTRIM_SPACE, DorisSQLParserParserTRUNCATE, DorisSQLParserParserTYPE, DorisSQLParserParserTYPES, DorisSQLParserParserUNBOUNDED, DorisSQLParserParserUNCOMMITTED, DorisSQLParserParserUNINSTALL, DorisSQLParserParserUNSET, DorisSQLParserParserUSAGE, DorisSQLParserParserUSER, DorisSQLParserParserUSERS, DorisSQLParserParserVALUE, DorisSQLParserParserVARBINARY, DorisSQLParserParserVARIABLES, DorisSQLParserParserVECTOR, DorisSQLParserParserVERBOSE, DorisSQLParserParserVERSION, DorisSQLParserParserVIEW, DorisSQLParserParserVIEWS, DorisSQLParserParserVOLUME, DorisSQLParserParserVOLUMES, DorisSQLParserParserWAREHOUSE, DorisSQLParserParserWAREHOUSES, DorisSQLParserParserWARNINGS, DorisSQLParserParserWEEK, DorisSQLParserParserWHITELIST, DorisSQLParserParserWORK, DorisSQLParserParserWRITE, DorisSQLParserParserYEAR, DorisSQLParserParserLOCK, DorisSQLParserParserUNLOCK, DorisSQLParserParserLOW_PRIORITY, DorisSQLParserParserDISK, DorisSQLParserParserBEFORE, DorisSQLParserParserFIELD, DorisSQLParserParserPERSISTENT, DorisSQLParserParserARRAY_ELEMENT, DorisSQLParserParserSINGLE_QUOTED_TEXT, DorisSQLParserParserDOUBLE_QUOTED_TEXT, DorisSQLParserParserLETTER_IDENTIFIER, DorisSQLParserParserDIGIT_IDENTIFIER, DorisSQLParserParserBACKQUOTED_IDENTIFIER, DorisSQLParserParserDOTDOTDOT:
				{
					p.SetState(5576)

					var _x = p.IdentifierOrString()

					localctx.(*SetNamesContext).collate = _x
				}

			case DorisSQLParserParserDEFAULT:
				{
					p.SetState(5577)
					p.Match(DorisSQLParserParserDEFAULT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}

	case 3:
		localctx = NewSetPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5582)
			p.Match(DorisSQLParserParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5583)
			p.Match(DorisSQLParserParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5590)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserParserSINGLE_QUOTED_TEXT, DorisSQLParserParserDOUBLE_QUOTED_TEXT:
			{
				p.SetState(5584)
				p.String_()
			}

		case DorisSQLParserParserPASSWORD:
			{
				p.SetState(5585)
				p.Match(DorisSQLParserParserPASSWORD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5586)
				p.Match(DorisSQLParserParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5587)
				p.String_()
			}
			{
				p.SetState(5588)
				p.Match(DorisSQLParserParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 4:
		localctx = NewSetPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5592)
			p.Match(DorisSQLParserParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5593)
			p.Match(DorisSQLParserParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5594)
			p.User()
		}
		{
			p.SetState(5595)
			p.Match(DorisSQLParserParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5602)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserParserSINGLE_QUOTED_TEXT, DorisSQLParserParserDOUBLE_QUOTED_TEXT:
			{
				p.SetState(5596)
				p.String_()
			}

		case DorisSQLParserParserPASSWORD:
			{
				p.SetState(5597)
				p.Match(DorisSQLParserParserPASSWORD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5598)
				p.Match(DorisSQLParserParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5599)
				p.String_()
			}
			{
				p.SetState(5600)
				p.Match(DorisSQLParserParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 5:
		localctx = NewSetUserVarContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5604)
			p.UserVariable()
		}
		{
			p.SetState(5605)
			p.Match(DorisSQLParserParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5606)
			p.expression(0)
		}

	case 6:
		localctx = NewSetSystemVarContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(5609)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 608, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5608)
				p.VarType()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5611)
			p.Identifier()
		}
		{
			p.SetState(5612)
			p.Match(DorisSQLParserParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5613)
			p.SetExprOrDefault()
		}

	case 7:
		localctx = NewSetSystemVarContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5615)
			p.SystemVariable()
		}
		{
			p.SetState(5616)
			p.Match(DorisSQLParserParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5617)
			p.SetExprOrDefault()
		}

	case 8:
		localctx = NewSetTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		p.SetState(5620)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserGLOBAL || _la == DorisSQLParserParserLOCAL || _la == DorisSQLParserParserSESSION || _la == DorisSQLParserParserVERBOSE {
			{
				p.SetState(5619)
				p.VarType()
			}

		}
		{
			p.SetState(5622)
			p.Match(DorisSQLParserParserTRANSACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5623)
			p.Transaction_characteristics()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransaction_characteristicsContext is an interface to support dynamic dispatch.
type ITransaction_characteristicsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Transaction_access_mode() ITransaction_access_modeContext
	Isolation_level() IIsolation_levelContext

	// IsTransaction_characteristicsContext differentiates from other interfaces.
	IsTransaction_characteristicsContext()
}

type Transaction_characteristicsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransaction_characteristicsContext() *Transaction_characteristicsContext {
	var p = new(Transaction_characteristicsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_transaction_characteristics
	return p
}

func InitEmptyTransaction_characteristicsContext(p *Transaction_characteristicsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_transaction_characteristics
}

func (*Transaction_characteristicsContext) IsTransaction_characteristicsContext() {}

func NewTransaction_characteristicsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transaction_characteristicsContext {
	var p = new(Transaction_characteristicsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_transaction_characteristics

	return p
}

func (s *Transaction_characteristicsContext) GetParser() antlr.Parser { return s.parser }

func (s *Transaction_characteristicsContext) Transaction_access_mode() ITransaction_access_modeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransaction_access_modeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransaction_access_modeContext)
}

func (s *Transaction_characteristicsContext) Isolation_level() IIsolation_levelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsolation_levelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsolation_levelContext)
}

func (s *Transaction_characteristicsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transaction_characteristicsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transaction_characteristicsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTransaction_characteristics(s)
	}
}

func (s *Transaction_characteristicsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTransaction_characteristics(s)
	}
}

func (s *Transaction_characteristicsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTransaction_characteristics(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Transaction_characteristics() (localctx ITransaction_characteristicsContext) {
	localctx = NewTransaction_characteristicsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 682, DorisSQLParserParserRULE_transaction_characteristics)
	p.SetState(5636)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 611, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5626)
			p.Transaction_access_mode()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5627)
			p.Isolation_level()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5628)
			p.Transaction_access_mode()
		}
		{
			p.SetState(5629)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5630)
			p.Isolation_level()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5632)
			p.Isolation_level()
		}
		{
			p.SetState(5633)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5634)
			p.Transaction_access_mode()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransaction_access_modeContext is an interface to support dynamic dispatch.
type ITransaction_access_modeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	WRITE() antlr.TerminalNode

	// IsTransaction_access_modeContext differentiates from other interfaces.
	IsTransaction_access_modeContext()
}

type Transaction_access_modeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransaction_access_modeContext() *Transaction_access_modeContext {
	var p = new(Transaction_access_modeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_transaction_access_mode
	return p
}

func InitEmptyTransaction_access_modeContext(p *Transaction_access_modeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_transaction_access_mode
}

func (*Transaction_access_modeContext) IsTransaction_access_modeContext() {}

func NewTransaction_access_modeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transaction_access_modeContext {
	var p = new(Transaction_access_modeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_transaction_access_mode

	return p
}

func (s *Transaction_access_modeContext) GetParser() antlr.Parser { return s.parser }

func (s *Transaction_access_modeContext) READ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREAD, 0)
}

func (s *Transaction_access_modeContext) ONLY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserONLY, 0)
}

func (s *Transaction_access_modeContext) WRITE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWRITE, 0)
}

func (s *Transaction_access_modeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transaction_access_modeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transaction_access_modeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTransaction_access_mode(s)
	}
}

func (s *Transaction_access_modeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTransaction_access_mode(s)
	}
}

func (s *Transaction_access_modeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTransaction_access_mode(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Transaction_access_mode() (localctx ITransaction_access_modeContext) {
	localctx = NewTransaction_access_modeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 684, DorisSQLParserParserRULE_transaction_access_mode)
	p.SetState(5642)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 612, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5638)
			p.Match(DorisSQLParserParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5639)
			p.Match(DorisSQLParserParserONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5640)
			p.Match(DorisSQLParserParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5641)
			p.Match(DorisSQLParserParserWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIsolation_levelContext is an interface to support dynamic dispatch.
type IIsolation_levelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ISOLATION() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	Isolation_types() IIsolation_typesContext

	// IsIsolation_levelContext differentiates from other interfaces.
	IsIsolation_levelContext()
}

type Isolation_levelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsolation_levelContext() *Isolation_levelContext {
	var p = new(Isolation_levelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_isolation_level
	return p
}

func InitEmptyIsolation_levelContext(p *Isolation_levelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_isolation_level
}

func (*Isolation_levelContext) IsIsolation_levelContext() {}

func NewIsolation_levelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Isolation_levelContext {
	var p = new(Isolation_levelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_isolation_level

	return p
}

func (s *Isolation_levelContext) GetParser() antlr.Parser { return s.parser }

func (s *Isolation_levelContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserISOLATION, 0)
}

func (s *Isolation_levelContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLEVEL, 0)
}

func (s *Isolation_levelContext) Isolation_types() IIsolation_typesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsolation_typesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsolation_typesContext)
}

func (s *Isolation_levelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Isolation_levelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Isolation_levelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterIsolation_level(s)
	}
}

func (s *Isolation_levelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitIsolation_level(s)
	}
}

func (s *Isolation_levelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitIsolation_level(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Isolation_level() (localctx IIsolation_levelContext) {
	localctx = NewIsolation_levelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 686, DorisSQLParserParserRULE_isolation_level)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5644)
		p.Match(DorisSQLParserParserISOLATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5645)
		p.Match(DorisSQLParserParserLEVEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5646)
		p.Isolation_types()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIsolation_typesContext is an interface to support dynamic dispatch.
type IIsolation_typesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	REPEATABLE() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode

	// IsIsolation_typesContext differentiates from other interfaces.
	IsIsolation_typesContext()
}

type Isolation_typesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsolation_typesContext() *Isolation_typesContext {
	var p = new(Isolation_typesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_isolation_types
	return p
}

func InitEmptyIsolation_typesContext(p *Isolation_typesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_isolation_types
}

func (*Isolation_typesContext) IsIsolation_typesContext() {}

func NewIsolation_typesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Isolation_typesContext {
	var p = new(Isolation_typesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_isolation_types

	return p
}

func (s *Isolation_typesContext) GetParser() antlr.Parser { return s.parser }

func (s *Isolation_typesContext) READ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREAD, 0)
}

func (s *Isolation_typesContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUNCOMMITTED, 0)
}

func (s *Isolation_typesContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOMMITTED, 0)
}

func (s *Isolation_typesContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPEATABLE, 0)
}

func (s *Isolation_typesContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSERIALIZABLE, 0)
}

func (s *Isolation_typesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Isolation_typesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Isolation_typesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterIsolation_types(s)
	}
}

func (s *Isolation_typesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitIsolation_types(s)
	}
}

func (s *Isolation_typesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitIsolation_types(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Isolation_types() (localctx IIsolation_typesContext) {
	localctx = NewIsolation_typesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 688, DorisSQLParserParserRULE_isolation_types)
	p.SetState(5655)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 613, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5648)
			p.Match(DorisSQLParserParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5649)
			p.Match(DorisSQLParserParserUNCOMMITTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5650)
			p.Match(DorisSQLParserParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5651)
			p.Match(DorisSQLParserParserCOMMITTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5652)
			p.Match(DorisSQLParserParserREPEATABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5653)
			p.Match(DorisSQLParserParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5654)
			p.Match(DorisSQLParserParserSERIALIZABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetExprOrDefaultContext is an interface to support dynamic dispatch.
type ISetExprOrDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	ON() antlr.TerminalNode
	ALL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsSetExprOrDefaultContext differentiates from other interfaces.
	IsSetExprOrDefaultContext()
}

type SetExprOrDefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetExprOrDefaultContext() *SetExprOrDefaultContext {
	var p = new(SetExprOrDefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_setExprOrDefault
	return p
}

func InitEmptySetExprOrDefaultContext(p *SetExprOrDefaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_setExprOrDefault
}

func (*SetExprOrDefaultContext) IsSetExprOrDefaultContext() {}

func NewSetExprOrDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetExprOrDefaultContext {
	var p = new(SetExprOrDefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_setExprOrDefault

	return p
}

func (s *SetExprOrDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *SetExprOrDefaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDEFAULT, 0)
}

func (s *SetExprOrDefaultContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *SetExprOrDefaultContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, 0)
}

func (s *SetExprOrDefaultContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetExprOrDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetExprOrDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetExprOrDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSetExprOrDefault(s)
	}
}

func (s *SetExprOrDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSetExprOrDefault(s)
	}
}

func (s *SetExprOrDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSetExprOrDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SetExprOrDefault() (localctx ISetExprOrDefaultContext) {
	localctx = NewSetExprOrDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 690, DorisSQLParserParserRULE_setExprOrDefault)
	p.SetState(5661)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserDEFAULT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5657)
			p.Match(DorisSQLParserParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5658)
			p.Match(DorisSQLParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserALL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5659)
			p.Match(DorisSQLParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserT__1, DorisSQLParserParserT__5, DorisSQLParserParserT__8, DorisSQLParserParserACCESS, DorisSQLParserParserACTIVE, DorisSQLParserParserADMIN, DorisSQLParserParserADVISOR, DorisSQLParserParserAFTER, DorisSQLParserParserAGGREGATE, DorisSQLParserParserANTI, DorisSQLParserParserAPPLY, DorisSQLParserParserARRAY, DorisSQLParserParserARRAY_AGG, DorisSQLParserParserARRAY_AGG_DISTINCT, DorisSQLParserParserASYNC, DorisSQLParserParserAUTHORS, DorisSQLParserParserAUTHENTICATION, DorisSQLParserParserAUTOMATED, DorisSQLParserParserAUTO_INCREMENT, DorisSQLParserParserAVG, DorisSQLParserParserBACKEND, DorisSQLParserParserBACKENDS, DorisSQLParserParserBACKUP, DorisSQLParserParserBASE, DorisSQLParserParserBASELINE, DorisSQLParserParserBEGIN, DorisSQLParserParserBINARY, DorisSQLParserParserBITMAP_UNION, DorisSQLParserParserBLACKHOLE, DorisSQLParserParserBLACKLIST, DorisSQLParserParserBODY, DorisSQLParserParserBOOLEAN, DorisSQLParserParserBRANCH, DorisSQLParserParserBROKER, DorisSQLParserParserBUCKETS, DorisSQLParserParserBUILTIN, DorisSQLParserParserCACHE, DorisSQLParserParserCANCEL, DorisSQLParserParserCASE, DorisSQLParserParserCAST, DorisSQLParserParserCATALOG, DorisSQLParserParserCATALOGS, DorisSQLParserParserCEIL, DorisSQLParserParserCHAIN, DorisSQLParserParserCHAR, DorisSQLParserParserCHARSET, DorisSQLParserParserCLEAN, DorisSQLParserParserCLEAR, DorisSQLParserParserCLUSTER, DorisSQLParserParserCLUSTERS, DorisSQLParserParserCNGROUP, DorisSQLParserParserCNGROUPS, DorisSQLParserParserCOLLATION, DorisSQLParserParserCOLUMNS, DorisSQLParserParserCOMMENT, DorisSQLParserParserCOMMIT, DorisSQLParserParserCOMMITTED, DorisSQLParserParserCOMPACT, DorisSQLParserParserCOMPUTE, DorisSQLParserParserCONFIG, DorisSQLParserParserCONNECTION, DorisSQLParserParserCONSISTENT, DorisSQLParserParserCONVERT, DorisSQLParserParserCOSTS, DorisSQLParserParserCOUNT, DorisSQLParserParserCUME_DIST, DorisSQLParserParserCUMULATIVE, DorisSQLParserParserCURRENT, DorisSQLParserParserCURRENT_DATE, DorisSQLParserParserCURRENT_GROUP, DorisSQLParserParserCURRENT_ROLE, DorisSQLParserParserCURRENT_TIME, DorisSQLParserParserCURRENT_TIMESTAMP, DorisSQLParserParserCURRENT_USER, DorisSQLParserParserDATA, DorisSQLParserParserDATACACHE, DorisSQLParserParserDATABASE, DorisSQLParserParserDATE, DorisSQLParserParserDATETIME, DorisSQLParserParserDAY, DorisSQLParserParserDAYS, DorisSQLParserParserDEALLOCATE, DorisSQLParserParserDECOMMISSION, DorisSQLParserParserDENSE_RANK, DorisSQLParserParserDIALECT, DorisSQLParserParserDICTIONARY, DorisSQLParserParserDICTIONARY_GET, DorisSQLParserParserNTILE, DorisSQLParserParserDISABLE, DorisSQLParserParserDISTRIBUTED, DorisSQLParserParserDISTRIBUTION, DorisSQLParserParserDUPLICATE, DorisSQLParserParserDYNAMIC, DorisSQLParserParserENABLE, DorisSQLParserParserENCLOSE, DorisSQLParserParserEND, DorisSQLParserParserENGINE, DorisSQLParserParserENGINES, DorisSQLParserParserERRORS, DorisSQLParserParserESCAPE, DorisSQLParserParserEVENTS, DorisSQLParserParserEXCEPT, DorisSQLParserParserEXCLUDE, DorisSQLParserParserEXECUTE, DorisSQLParserParserEXISTS, DorisSQLParserParserEXPORT, DorisSQLParserParserEXTERNAL, DorisSQLParserParserEXTRACT, DorisSQLParserParserEVERY, DorisSQLParserParserFAILPOINT, DorisSQLParserParserFAILPOINTS, DorisSQLParserParserFALSE, DorisSQLParserParserFIELDS, DorisSQLParserParserFILE, DorisSQLParserParserFILTER, DorisSQLParserParserFIRST, DorisSQLParserParserFIRST_VALUE, DorisSQLParserParserFLOOR, DorisSQLParserParserFN, DorisSQLParserParserFOLLOWING, DorisSQLParserParserFOLLOWER, DorisSQLParserParserFORMAT, DorisSQLParserParserFREE, DorisSQLParserParserFRONTEND, DorisSQLParserParserFRONTENDS, DorisSQLParserParserFUNCTIONS, DorisSQLParserParserGLOBAL, DorisSQLParserParserGRANTS, DorisSQLParserParserGROUPING, DorisSQLParserParserGROUPING_ID, DorisSQLParserParserGROUP_CONCAT, DorisSQLParserParserHASH, DorisSQLParserParserHELP, DorisSQLParserParserHISTOGRAM, DorisSQLParserParserHLL_UNION, DorisSQLParserParserHOST, DorisSQLParserParserHOUR, DorisSQLParserParserHOURS, DorisSQLParserParserHUB, DorisSQLParserParserIDENTIFIED, DorisSQLParserParserIF, DorisSQLParserParserIMPERSONATE, DorisSQLParserParserIMAGE, DorisSQLParserParserINACTIVE, DorisSQLParserParserINCREMENTAL, DorisSQLParserParserINDEXES, DorisSQLParserParserINSTALL, DorisSQLParserParserINTEGRATION, DorisSQLParserParserINTEGRATIONS, DorisSQLParserParserINTERMEDIATE, DorisSQLParserParserINTERVAL, DorisSQLParserParserOVERWRITE, DorisSQLParserParserISOLATION, DorisSQLParserParserJOB, DorisSQLParserParserLABEL, DorisSQLParserParserLAG, DorisSQLParserParserLAST, DorisSQLParserParserLAST_VALUE, DorisSQLParserParserLEAD, DorisSQLParserParserLEFT, DorisSQLParserParserLESS, DorisSQLParserParserLEVEL, DorisSQLParserParserLIKE, DorisSQLParserParserLIST, DorisSQLParserParserLOCAL, DorisSQLParserParserLOCALTIME, DorisSQLParserParserLOCALTIMESTAMP, DorisSQLParserParserLOCATION, DorisSQLParserParserLOCATIONS, DorisSQLParserParserLOGS, DorisSQLParserParserLOGICAL, DorisSQLParserParserMANUAL, DorisSQLParserParserMAP, DorisSQLParserParserMAPPING, DorisSQLParserParserMAPPINGS, DorisSQLParserParserMASKING, DorisSQLParserParserMATCH, DorisSQLParserParserMATERIALIZED, DorisSQLParserParserMAX, DorisSQLParserParserMERGE, DorisSQLParserParserMIN, DorisSQLParserParserMINUTE, DorisSQLParserParserMINUTES, DorisSQLParserParserMINUS, DorisSQLParserParserMETA, DorisSQLParserParserMOD, DorisSQLParserParserMODE, DorisSQLParserParserMODIFY, DorisSQLParserParserMONTH, DorisSQLParserParserMULTIPLE, DorisSQLParserParserNAME, DorisSQLParserParserNAMES, DorisSQLParserParserNEGATIVE, DorisSQLParserParserNGRAMBF, DorisSQLParserParserNO, DorisSQLParserParserNODE, DorisSQLParserParserNODES, DorisSQLParserParserNONE, DorisSQLParserParserNOT, DorisSQLParserParserNULL, DorisSQLParserParserNULLS, DorisSQLParserParserNUMBER, DorisSQLParserParserNUMERIC, DorisSQLParserParserOBSERVER, DorisSQLParserParserOF, DorisSQLParserParserOFF, DorisSQLParserParserOFFSET, DorisSQLParserParserONLY, DorisSQLParserParserOPEN, DorisSQLParserParserOPERATE, DorisSQLParserParserOPTIMIZER, DorisSQLParserParserOPTION, DorisSQLParserParserPARAMETER, DorisSQLParserParserPARTITIONS, DorisSQLParserParserPASSWORD, DorisSQLParserParserPATH, DorisSQLParserParserPAUSE, DorisSQLParserParserPENDING, DorisSQLParserParserPERCENT_RANK, DorisSQLParserParserPERCENTILE_UNION, DorisSQLParserParserPLAN, DorisSQLParserParserPLUGIN, DorisSQLParserParserPLUGINS, DorisSQLParserParserPIPE, DorisSQLParserParserPIPES, DorisSQLParserParserPIVOT, DorisSQLParserParserPOLICY, DorisSQLParserParserPOLICIES, DorisSQLParserParserPRECEDING, DorisSQLParserParserPREDICATE, DorisSQLParserParserPRIORITY, DorisSQLParserParserPRIVILEGES, DorisSQLParserParserPROBABILITY, DorisSQLParserParserPROC, DorisSQLParserParserPROCESSLIST, DorisSQLParserParserPROFILE, DorisSQLParserParserPROFILELIST, DorisSQLParserParserPROPERTIES, DorisSQLParserParserPROPERTY, DorisSQLParserParserPROVIDER, DorisSQLParserParserPROVIDERS, DorisSQLParserParserQUALIFY, DorisSQLParserParserQUARTER, DorisSQLParserParserQUERY, DorisSQLParserParserQUERIES, DorisSQLParserParserQUEUE, DorisSQLParserParserQUOTA, DorisSQLParserParserRANDOM, DorisSQLParserParserRANK, DorisSQLParserParserREASON, DorisSQLParserParserRECOVER, DorisSQLParserParserREFRESH, DorisSQLParserParserREWRITE, DorisSQLParserParserREGEXP, DorisSQLParserParserREMOVE, DorisSQLParserParserREPAIR, DorisSQLParserParserREPEATABLE, DorisSQLParserParserREPLACE, DorisSQLParserParserREPLACE_IF_NOT_NULL, DorisSQLParserParserREPLICA, DorisSQLParserParserREPOSITORY, DorisSQLParserParserREPOSITORIES, DorisSQLParserParserRESOURCE, DorisSQLParserParserRESOURCES, DorisSQLParserParserRESTORE, DorisSQLParserParserRESUME, DorisSQLParserParserRETAIN, DorisSQLParserParserRETENTION, DorisSQLParserParserRETURNS, DorisSQLParserParserRETRY, DorisSQLParserParserREVERT, DorisSQLParserParserRIGHT, DorisSQLParserParserRLIKE, DorisSQLParserParserROLE, DorisSQLParserParserROLES, DorisSQLParserParserROLLBACK, DorisSQLParserParserROLLUP, DorisSQLParserParserROUTINE, DorisSQLParserParserROW, DorisSQLParserParserROW_NUMBER, DorisSQLParserParserRULE, DorisSQLParserParserRULES, DorisSQLParserParserRUNNING, DorisSQLParserParserSAMPLE, DorisSQLParserParserSCHEDULE, DorisSQLParserParserSCHEDULER, DorisSQLParserParserSCHEMA, DorisSQLParserParserSECOND, DorisSQLParserParserSECURITY, DorisSQLParserParserSEMI, DorisSQLParserParserSEPARATOR, DorisSQLParserParserSERIALIZABLE, DorisSQLParserParserSESSION, DorisSQLParserParserSETS, DorisSQLParserParserSIGNED, DorisSQLParserParserSKIP_HEADER, DorisSQLParserParserSNAPSHOT, DorisSQLParserParserSNAPSHOTS, DorisSQLParserParserSQLBLACKLIST, DorisSQLParserParserSTART, DorisSQLParserParserSTATS, DorisSQLParserParserSTATUS, DorisSQLParserParserSTOP, DorisSQLParserParserSTORAGE, DorisSQLParserParserSTREAM, DorisSQLParserParserSTRING, DorisSQLParserParserSUBMIT, DorisSQLParserParserSUM, DorisSQLParserParserSUSPEND, DorisSQLParserParserSYNC, DorisSQLParserParserSYSTEM_TIME, DorisSQLParserParserSWAP, DorisSQLParserParserSTRUCT, DorisSQLParserParserTABLES, DorisSQLParserParserTABLET, DorisSQLParserParserTABLETS, DorisSQLParserParserTAG, DorisSQLParserParserTASK, DorisSQLParserParserTEMPORARY, DorisSQLParserParserTHAN, DorisSQLParserParserTIME, DorisSQLParserParserTIMES, DorisSQLParserParserTIMESTAMP, DorisSQLParserParserTIMESTAMPADD, DorisSQLParserParserTIMESTAMPDIFF, DorisSQLParserParserTRANSACTION, DorisSQLParserParserTRANSLATE, DorisSQLParserParserTRACE, DorisSQLParserParserTRIGGERS, DorisSQLParserParserTRIM_SPACE, DorisSQLParserParserTRUE, DorisSQLParserParserTRUNCATE, DorisSQLParserParserTYPE, DorisSQLParserParserTYPES, DorisSQLParserParserUNBOUNDED, DorisSQLParserParserUNCOMMITTED, DorisSQLParserParserUNINSTALL, DorisSQLParserParserUNSET, DorisSQLParserParserUSAGE, DorisSQLParserParserUSER, DorisSQLParserParserUSERS, DorisSQLParserParserVALUE, DorisSQLParserParserVARBINARY, DorisSQLParserParserVARIABLES, DorisSQLParserParserVECTOR, DorisSQLParserParserVERBOSE, DorisSQLParserParserVERSION, DorisSQLParserParserVIEW, DorisSQLParserParserVIEWS, DorisSQLParserParserVOLUME, DorisSQLParserParserVOLUMES, DorisSQLParserParserWAREHOUSE, DorisSQLParserParserWAREHOUSES, DorisSQLParserParserWARNINGS, DorisSQLParserParserWEEK, DorisSQLParserParserWHITELIST, DorisSQLParserParserWORK, DorisSQLParserParserWRITE, DorisSQLParserParserYEAR, DorisSQLParserParserLOCK, DorisSQLParserParserUNLOCK, DorisSQLParserParserLOW_PRIORITY, DorisSQLParserParserDISK, DorisSQLParserParserBEFORE, DorisSQLParserParserFIELD, DorisSQLParserParserPERSISTENT, DorisSQLParserParserARRAY_ELEMENT, DorisSQLParserParserPLUS_SYMBOL, DorisSQLParserParserMINUS_SYMBOL, DorisSQLParserParserLOGICAL_NOT, DorisSQLParserParserBITNOT, DorisSQLParserParserAT, DorisSQLParserParserINTEGER_VALUE, DorisSQLParserParserDECIMAL_VALUE, DorisSQLParserParserDOUBLE_VALUE, DorisSQLParserParserSINGLE_QUOTED_TEXT, DorisSQLParserParserDOUBLE_QUOTED_TEXT, DorisSQLParserParserBINARY_SINGLE_QUOTED_TEXT, DorisSQLParserParserBINARY_DOUBLE_QUOTED_TEXT, DorisSQLParserParserLETTER_IDENTIFIER, DorisSQLParserParserDIGIT_IDENTIFIER, DorisSQLParserParserBACKQUOTED_IDENTIFIER, DorisSQLParserParserDOTDOTDOT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5660)
			p.expression(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetUserPropertyStatementContext is an interface to support dynamic dispatch.
type ISetUserPropertyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode
	UserPropertyList() IUserPropertyListContext
	FOR() antlr.TerminalNode
	String_() IStringContext

	// IsSetUserPropertyStatementContext differentiates from other interfaces.
	IsSetUserPropertyStatementContext()
}

type SetUserPropertyStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetUserPropertyStatementContext() *SetUserPropertyStatementContext {
	var p = new(SetUserPropertyStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_setUserPropertyStatement
	return p
}

func InitEmptySetUserPropertyStatementContext(p *SetUserPropertyStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_setUserPropertyStatement
}

func (*SetUserPropertyStatementContext) IsSetUserPropertyStatementContext() {}

func NewSetUserPropertyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetUserPropertyStatementContext {
	var p = new(SetUserPropertyStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_setUserPropertyStatement

	return p
}

func (s *SetUserPropertyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetUserPropertyStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *SetUserPropertyStatementContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROPERTY, 0)
}

func (s *SetUserPropertyStatementContext) UserPropertyList() IUserPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserPropertyListContext)
}

func (s *SetUserPropertyStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFOR, 0)
}

func (s *SetUserPropertyStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *SetUserPropertyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetUserPropertyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetUserPropertyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSetUserPropertyStatement(s)
	}
}

func (s *SetUserPropertyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSetUserPropertyStatement(s)
	}
}

func (s *SetUserPropertyStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSetUserPropertyStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SetUserPropertyStatement() (localctx ISetUserPropertyStatementContext) {
	localctx = NewSetUserPropertyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 692, DorisSQLParserParserRULE_setUserPropertyStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5663)
		p.Match(DorisSQLParserParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5664)
		p.Match(DorisSQLParserParserPROPERTY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5667)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFOR {
		{
			p.SetState(5665)
			p.Match(DorisSQLParserParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5666)
			p.String_()
		}

	}
	{
		p.SetState(5669)
		p.UserPropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleListContext is an interface to support dynamic dispatch.
type IRoleListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext

	// IsRoleListContext differentiates from other interfaces.
	IsRoleListContext()
}

type RoleListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleListContext() *RoleListContext {
	var p = new(RoleListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_roleList
	return p
}

func InitEmptyRoleListContext(p *RoleListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_roleList
}

func (*RoleListContext) IsRoleListContext() {}

func NewRoleListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleListContext {
	var p = new(RoleListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_roleList

	return p
}

func (s *RoleListContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleListContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *RoleListContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *RoleListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRoleList(s)
	}
}

func (s *RoleListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRoleList(s)
	}
}

func (s *RoleListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRoleList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) RoleList() (localctx IRoleListContext) {
	localctx = NewRoleListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 694, DorisSQLParserParserRULE_roleList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5671)
		p.IdentifierOrString()
	}
	p.SetState(5676)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(5672)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5673)
			p.IdentifierOrString()
		}

		p.SetState(5678)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExecuteScriptStatementContext is an interface to support dynamic dispatch.
type IExecuteScriptStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	EXECUTE() antlr.TerminalNode
	ON() antlr.TerminalNode
	String_() IStringContext
	FRONTEND() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsExecuteScriptStatementContext differentiates from other interfaces.
	IsExecuteScriptStatementContext()
}

type ExecuteScriptStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteScriptStatementContext() *ExecuteScriptStatementContext {
	var p = new(ExecuteScriptStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_executeScriptStatement
	return p
}

func InitEmptyExecuteScriptStatementContext(p *ExecuteScriptStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_executeScriptStatement
}

func (*ExecuteScriptStatementContext) IsExecuteScriptStatementContext() {}

func NewExecuteScriptStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteScriptStatementContext {
	var p = new(ExecuteScriptStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_executeScriptStatement

	return p
}

func (s *ExecuteScriptStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteScriptStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADMIN, 0)
}

func (s *ExecuteScriptStatementContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXECUTE, 0)
}

func (s *ExecuteScriptStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *ExecuteScriptStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ExecuteScriptStatementContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFRONTEND, 0)
}

func (s *ExecuteScriptStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, 0)
}

func (s *ExecuteScriptStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteScriptStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteScriptStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterExecuteScriptStatement(s)
	}
}

func (s *ExecuteScriptStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitExecuteScriptStatement(s)
	}
}

func (s *ExecuteScriptStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitExecuteScriptStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ExecuteScriptStatement() (localctx IExecuteScriptStatementContext) {
	localctx = NewExecuteScriptStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 696, DorisSQLParserParserRULE_executeScriptStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5679)
		p.Match(DorisSQLParserParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5680)
		p.Match(DorisSQLParserParserEXECUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5681)
		p.Match(DorisSQLParserParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5682)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserFRONTEND || _la == DorisSQLParserParserINTEGER_VALUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5683)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedStatementContext is an interface to support dynamic dispatch.
type IUnsupportedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCK() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	AllLock_item() []ILock_itemContext
	Lock_item(i int) ILock_itemContext
	UNLOCK() antlr.TerminalNode

	// IsUnsupportedStatementContext differentiates from other interfaces.
	IsUnsupportedStatementContext()
}

type UnsupportedStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedStatementContext() *UnsupportedStatementContext {
	var p = new(UnsupportedStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_unsupportedStatement
	return p
}

func InitEmptyUnsupportedStatementContext(p *UnsupportedStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_unsupportedStatement
}

func (*UnsupportedStatementContext) IsUnsupportedStatementContext() {}

func NewUnsupportedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedStatementContext {
	var p = new(UnsupportedStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_unsupportedStatement

	return p
}

func (s *UnsupportedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedStatementContext) LOCK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOCK, 0)
}

func (s *UnsupportedStatementContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLES, 0)
}

func (s *UnsupportedStatementContext) AllLock_item() []ILock_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILock_itemContext); ok {
			len++
		}
	}

	tst := make([]ILock_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILock_itemContext); ok {
			tst[i] = t.(ILock_itemContext)
			i++
		}
	}

	return tst
}

func (s *UnsupportedStatementContext) Lock_item(i int) ILock_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILock_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILock_itemContext)
}

func (s *UnsupportedStatementContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUNLOCK, 0)
}

func (s *UnsupportedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsupportedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterUnsupportedStatement(s)
	}
}

func (s *UnsupportedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitUnsupportedStatement(s)
	}
}

func (s *UnsupportedStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitUnsupportedStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) UnsupportedStatement() (localctx IUnsupportedStatementContext) {
	localctx = NewUnsupportedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 698, DorisSQLParserParserRULE_unsupportedStatement)
	var _la int

	p.SetState(5697)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserLOCK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5685)
			p.Match(DorisSQLParserParserLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5686)
			p.Match(DorisSQLParserParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5687)
			p.Lock_item()
		}
		p.SetState(5692)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(5688)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5689)
				p.Lock_item()
			}

			p.SetState(5694)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case DorisSQLParserParserUNLOCK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5695)
			p.Match(DorisSQLParserParserUNLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5696)
			p.Match(DorisSQLParserParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILock_itemContext is an interface to support dynamic dispatch.
type ILock_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlias returns the alias rule contexts.
	GetAlias() IIdentifierContext

	// SetAlias sets the alias rule contexts.
	SetAlias(IIdentifierContext)

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	Lock_type() ILock_typeContext
	AS() antlr.TerminalNode

	// IsLock_itemContext differentiates from other interfaces.
	IsLock_itemContext()
}

type Lock_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	alias  IIdentifierContext
}

func NewEmptyLock_itemContext() *Lock_itemContext {
	var p = new(Lock_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_lock_item
	return p
}

func InitEmptyLock_itemContext(p *Lock_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_lock_item
}

func (*Lock_itemContext) IsLock_itemContext() {}

func NewLock_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lock_itemContext {
	var p = new(Lock_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_lock_item

	return p
}

func (s *Lock_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Lock_itemContext) GetAlias() IIdentifierContext { return s.alias }

func (s *Lock_itemContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *Lock_itemContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Lock_itemContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Lock_itemContext) Lock_type() ILock_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILock_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILock_typeContext)
}

func (s *Lock_itemContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *Lock_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lock_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lock_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterLock_item(s)
	}
}

func (s *Lock_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitLock_item(s)
	}
}

func (s *Lock_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitLock_item(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Lock_item() (localctx ILock_itemContext) {
	localctx = NewLock_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 700, DorisSQLParserParserRULE_lock_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5699)
		p.Identifier()
	}
	p.SetState(5704)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 620, p.GetParserRuleContext()) == 1 {
		p.SetState(5701)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserAS {
			{
				p.SetState(5700)
				p.Match(DorisSQLParserParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5703)

			var _x = p.Identifier()

			localctx.(*Lock_itemContext).alias = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(5706)
		p.Lock_type()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILock_typeContext is an interface to support dynamic dispatch.
type ILock_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	LOW_PRIORITY() antlr.TerminalNode

	// IsLock_typeContext differentiates from other interfaces.
	IsLock_typeContext()
}

type Lock_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLock_typeContext() *Lock_typeContext {
	var p = new(Lock_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_lock_type
	return p
}

func InitEmptyLock_typeContext(p *Lock_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_lock_type
}

func (*Lock_typeContext) IsLock_typeContext() {}

func NewLock_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lock_typeContext {
	var p = new(Lock_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_lock_type

	return p
}

func (s *Lock_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Lock_typeContext) READ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREAD, 0)
}

func (s *Lock_typeContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOCAL, 0)
}

func (s *Lock_typeContext) WRITE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWRITE, 0)
}

func (s *Lock_typeContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOW_PRIORITY, 0)
}

func (s *Lock_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lock_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lock_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterLock_type(s)
	}
}

func (s *Lock_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitLock_type(s)
	}
}

func (s *Lock_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitLock_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Lock_type() (localctx ILock_typeContext) {
	localctx = NewLock_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 702, DorisSQLParserParserRULE_lock_type)
	var _la int

	p.SetState(5716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserREAD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5708)
			p.Match(DorisSQLParserParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5710)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserLOCAL {
			{
				p.SetState(5709)
				p.Match(DorisSQLParserParserLOCAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DorisSQLParserParserWRITE, DorisSQLParserParserLOW_PRIORITY:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5713)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserLOW_PRIORITY {
			{
				p.SetState(5712)
				p.Match(DorisSQLParserParserLOW_PRIORITY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5715)
			p.Match(DorisSQLParserParserWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterPlanAdvisorAddStatementContext is an interface to support dynamic dispatch.
type IAlterPlanAdvisorAddStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	ADVISOR() antlr.TerminalNode
	ADD() antlr.TerminalNode
	QueryStatement() IQueryStatementContext

	// IsAlterPlanAdvisorAddStatementContext differentiates from other interfaces.
	IsAlterPlanAdvisorAddStatementContext()
}

type AlterPlanAdvisorAddStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterPlanAdvisorAddStatementContext() *AlterPlanAdvisorAddStatementContext {
	var p = new(AlterPlanAdvisorAddStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterPlanAdvisorAddStatement
	return p
}

func InitEmptyAlterPlanAdvisorAddStatementContext(p *AlterPlanAdvisorAddStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterPlanAdvisorAddStatement
}

func (*AlterPlanAdvisorAddStatementContext) IsAlterPlanAdvisorAddStatementContext() {}

func NewAlterPlanAdvisorAddStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterPlanAdvisorAddStatementContext {
	var p = new(AlterPlanAdvisorAddStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_alterPlanAdvisorAddStatement

	return p
}

func (s *AlterPlanAdvisorAddStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterPlanAdvisorAddStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *AlterPlanAdvisorAddStatementContext) PLAN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPLAN, 0)
}

func (s *AlterPlanAdvisorAddStatementContext) ADVISOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADVISOR, 0)
}

func (s *AlterPlanAdvisorAddStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADD, 0)
}

func (s *AlterPlanAdvisorAddStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *AlterPlanAdvisorAddStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterPlanAdvisorAddStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterPlanAdvisorAddStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAlterPlanAdvisorAddStatement(s)
	}
}

func (s *AlterPlanAdvisorAddStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAlterPlanAdvisorAddStatement(s)
	}
}

func (s *AlterPlanAdvisorAddStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAlterPlanAdvisorAddStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AlterPlanAdvisorAddStatement() (localctx IAlterPlanAdvisorAddStatementContext) {
	localctx = NewAlterPlanAdvisorAddStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 704, DorisSQLParserParserRULE_alterPlanAdvisorAddStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5718)
		p.Match(DorisSQLParserParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5719)
		p.Match(DorisSQLParserParserPLAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5720)
		p.Match(DorisSQLParserParserADVISOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5721)
		p.Match(DorisSQLParserParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5722)
		p.QueryStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITruncatePlanAdvisorStatementContext is an interface to support dynamic dispatch.
type ITruncatePlanAdvisorStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUNCATE() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	ADVISOR() antlr.TerminalNode

	// IsTruncatePlanAdvisorStatementContext differentiates from other interfaces.
	IsTruncatePlanAdvisorStatementContext()
}

type TruncatePlanAdvisorStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncatePlanAdvisorStatementContext() *TruncatePlanAdvisorStatementContext {
	var p = new(TruncatePlanAdvisorStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_truncatePlanAdvisorStatement
	return p
}

func InitEmptyTruncatePlanAdvisorStatementContext(p *TruncatePlanAdvisorStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_truncatePlanAdvisorStatement
}

func (*TruncatePlanAdvisorStatementContext) IsTruncatePlanAdvisorStatementContext() {}

func NewTruncatePlanAdvisorStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncatePlanAdvisorStatementContext {
	var p = new(TruncatePlanAdvisorStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_truncatePlanAdvisorStatement

	return p
}

func (s *TruncatePlanAdvisorStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncatePlanAdvisorStatementContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTRUNCATE, 0)
}

func (s *TruncatePlanAdvisorStatementContext) PLAN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPLAN, 0)
}

func (s *TruncatePlanAdvisorStatementContext) ADVISOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADVISOR, 0)
}

func (s *TruncatePlanAdvisorStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncatePlanAdvisorStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TruncatePlanAdvisorStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTruncatePlanAdvisorStatement(s)
	}
}

func (s *TruncatePlanAdvisorStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTruncatePlanAdvisorStatement(s)
	}
}

func (s *TruncatePlanAdvisorStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTruncatePlanAdvisorStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) TruncatePlanAdvisorStatement() (localctx ITruncatePlanAdvisorStatementContext) {
	localctx = NewTruncatePlanAdvisorStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 706, DorisSQLParserParserRULE_truncatePlanAdvisorStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5724)
		p.Match(DorisSQLParserParserTRUNCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5725)
		p.Match(DorisSQLParserParserPLAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5726)
		p.Match(DorisSQLParserParserADVISOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterPlanAdvisorDropStatementContext is an interface to support dynamic dispatch.
type IAlterPlanAdvisorDropStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	ADVISOR() antlr.TerminalNode
	DROP() antlr.TerminalNode
	String_() IStringContext

	// IsAlterPlanAdvisorDropStatementContext differentiates from other interfaces.
	IsAlterPlanAdvisorDropStatementContext()
}

type AlterPlanAdvisorDropStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterPlanAdvisorDropStatementContext() *AlterPlanAdvisorDropStatementContext {
	var p = new(AlterPlanAdvisorDropStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterPlanAdvisorDropStatement
	return p
}

func InitEmptyAlterPlanAdvisorDropStatementContext(p *AlterPlanAdvisorDropStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterPlanAdvisorDropStatement
}

func (*AlterPlanAdvisorDropStatementContext) IsAlterPlanAdvisorDropStatementContext() {}

func NewAlterPlanAdvisorDropStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterPlanAdvisorDropStatementContext {
	var p = new(AlterPlanAdvisorDropStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_alterPlanAdvisorDropStatement

	return p
}

func (s *AlterPlanAdvisorDropStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterPlanAdvisorDropStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *AlterPlanAdvisorDropStatementContext) PLAN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPLAN, 0)
}

func (s *AlterPlanAdvisorDropStatementContext) ADVISOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADVISOR, 0)
}

func (s *AlterPlanAdvisorDropStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *AlterPlanAdvisorDropStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AlterPlanAdvisorDropStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterPlanAdvisorDropStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterPlanAdvisorDropStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAlterPlanAdvisorDropStatement(s)
	}
}

func (s *AlterPlanAdvisorDropStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAlterPlanAdvisorDropStatement(s)
	}
}

func (s *AlterPlanAdvisorDropStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAlterPlanAdvisorDropStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AlterPlanAdvisorDropStatement() (localctx IAlterPlanAdvisorDropStatementContext) {
	localctx = NewAlterPlanAdvisorDropStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 708, DorisSQLParserParserRULE_alterPlanAdvisorDropStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5728)
		p.Match(DorisSQLParserParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5729)
		p.Match(DorisSQLParserParserPLAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5730)
		p.Match(DorisSQLParserParserADVISOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5731)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5732)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowPlanAdvisorStatementContext is an interface to support dynamic dispatch.
type IShowPlanAdvisorStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	ADVISOR() antlr.TerminalNode

	// IsShowPlanAdvisorStatementContext differentiates from other interfaces.
	IsShowPlanAdvisorStatementContext()
}

type ShowPlanAdvisorStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowPlanAdvisorStatementContext() *ShowPlanAdvisorStatementContext {
	var p = new(ShowPlanAdvisorStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showPlanAdvisorStatement
	return p
}

func InitEmptyShowPlanAdvisorStatementContext(p *ShowPlanAdvisorStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showPlanAdvisorStatement
}

func (*ShowPlanAdvisorStatementContext) IsShowPlanAdvisorStatementContext() {}

func NewShowPlanAdvisorStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowPlanAdvisorStatementContext {
	var p = new(ShowPlanAdvisorStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showPlanAdvisorStatement

	return p
}

func (s *ShowPlanAdvisorStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowPlanAdvisorStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowPlanAdvisorStatementContext) PLAN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPLAN, 0)
}

func (s *ShowPlanAdvisorStatementContext) ADVISOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADVISOR, 0)
}

func (s *ShowPlanAdvisorStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPlanAdvisorStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowPlanAdvisorStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowPlanAdvisorStatement(s)
	}
}

func (s *ShowPlanAdvisorStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowPlanAdvisorStatement(s)
	}
}

func (s *ShowPlanAdvisorStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowPlanAdvisorStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowPlanAdvisorStatement() (localctx IShowPlanAdvisorStatementContext) {
	localctx = NewShowPlanAdvisorStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 710, DorisSQLParserParserRULE_showPlanAdvisorStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5734)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5735)
		p.Match(DorisSQLParserParserPLAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5736)
		p.Match(DorisSQLParserParserADVISOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateWarehouseStatementContext is an interface to support dynamic dispatch.
type ICreateWarehouseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	WAREHOUSE() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Comment() ICommentContext
	Properties() IPropertiesContext

	// IsCreateWarehouseStatementContext differentiates from other interfaces.
	IsCreateWarehouseStatementContext()
}

type CreateWarehouseStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
}

func NewEmptyCreateWarehouseStatementContext() *CreateWarehouseStatementContext {
	var p = new(CreateWarehouseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createWarehouseStatement
	return p
}

func InitEmptyCreateWarehouseStatementContext(p *CreateWarehouseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createWarehouseStatement
}

func (*CreateWarehouseStatementContext) IsCreateWarehouseStatementContext() {}

func NewCreateWarehouseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateWarehouseStatementContext {
	var p = new(CreateWarehouseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createWarehouseStatement

	return p
}

func (s *CreateWarehouseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateWarehouseStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *CreateWarehouseStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *CreateWarehouseStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCREATE, 0)
}

func (s *CreateWarehouseStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CreateWarehouseStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWAREHOUSE, 0)
}

func (s *CreateWarehouseStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *CreateWarehouseStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *CreateWarehouseStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *CreateWarehouseStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateWarehouseStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateWarehouseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateWarehouseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateWarehouseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateWarehouseStatement(s)
	}
}

func (s *CreateWarehouseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateWarehouseStatement(s)
	}
}

func (s *CreateWarehouseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateWarehouseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateWarehouseStatement() (localctx ICreateWarehouseStatementContext) {
	localctx = NewCreateWarehouseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 712, DorisSQLParserParserRULE_createWarehouseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5738)
		p.Match(DorisSQLParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	{
		p.SetState(5739)
		p.Match(DorisSQLParserParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	p.SetState(5743)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(5740)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5741)
			p.Match(DorisSQLParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5742)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5745)

		var _x = p.IdentifierOrString()

		localctx.(*CreateWarehouseStatementContext).warehouseName = _x
	}
	p.SetState(5747)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserCOMMENT {
		{
			p.SetState(5746)
			p.Comment()
		}

	}
	p.SetState(5750)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(5749)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropWarehouseStatementContext is an interface to support dynamic dispatch.
type IDropWarehouseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropWarehouseStatementContext differentiates from other interfaces.
	IsDropWarehouseStatementContext()
}

type DropWarehouseStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
}

func NewEmptyDropWarehouseStatementContext() *DropWarehouseStatementContext {
	var p = new(DropWarehouseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropWarehouseStatement
	return p
}

func InitEmptyDropWarehouseStatementContext(p *DropWarehouseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropWarehouseStatement
}

func (*DropWarehouseStatementContext) IsDropWarehouseStatementContext() {}

func NewDropWarehouseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropWarehouseStatementContext {
	var p = new(DropWarehouseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropWarehouseStatement

	return p
}

func (s *DropWarehouseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropWarehouseStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *DropWarehouseStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *DropWarehouseStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropWarehouseStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWAREHOUSE, 0)
}

func (s *DropWarehouseStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropWarehouseStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *DropWarehouseStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *DropWarehouseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropWarehouseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropWarehouseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropWarehouseStatement(s)
	}
}

func (s *DropWarehouseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropWarehouseStatement(s)
	}
}

func (s *DropWarehouseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropWarehouseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropWarehouseStatement() (localctx IDropWarehouseStatementContext) {
	localctx = NewDropWarehouseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 714, DorisSQLParserParserRULE_dropWarehouseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5752)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5753)
		p.Match(DorisSQLParserParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5756)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(5754)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5755)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5758)

		var _x = p.IdentifierOrString()

		localctx.(*DropWarehouseStatementContext).warehouseName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISuspendWarehouseStatementContext is an interface to support dynamic dispatch.
type ISuspendWarehouseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUSPEND() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsSuspendWarehouseStatementContext differentiates from other interfaces.
	IsSuspendWarehouseStatementContext()
}

type SuspendWarehouseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuspendWarehouseStatementContext() *SuspendWarehouseStatementContext {
	var p = new(SuspendWarehouseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_suspendWarehouseStatement
	return p
}

func InitEmptySuspendWarehouseStatementContext(p *SuspendWarehouseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_suspendWarehouseStatement
}

func (*SuspendWarehouseStatementContext) IsSuspendWarehouseStatementContext() {}

func NewSuspendWarehouseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuspendWarehouseStatementContext {
	var p = new(SuspendWarehouseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_suspendWarehouseStatement

	return p
}

func (s *SuspendWarehouseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SuspendWarehouseStatementContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSUSPEND, 0)
}

func (s *SuspendWarehouseStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWAREHOUSE, 0)
}

func (s *SuspendWarehouseStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SuspendWarehouseStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *SuspendWarehouseStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *SuspendWarehouseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuspendWarehouseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SuspendWarehouseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSuspendWarehouseStatement(s)
	}
}

func (s *SuspendWarehouseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSuspendWarehouseStatement(s)
	}
}

func (s *SuspendWarehouseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSuspendWarehouseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SuspendWarehouseStatement() (localctx ISuspendWarehouseStatementContext) {
	localctx = NewSuspendWarehouseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 716, DorisSQLParserParserRULE_suspendWarehouseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5760)
		p.Match(DorisSQLParserParserSUSPEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5761)
		p.Match(DorisSQLParserParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5764)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(5762)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5763)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5766)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResumeWarehouseStatementContext is an interface to support dynamic dispatch.
type IResumeWarehouseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESUME() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsResumeWarehouseStatementContext differentiates from other interfaces.
	IsResumeWarehouseStatementContext()
}

type ResumeWarehouseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResumeWarehouseStatementContext() *ResumeWarehouseStatementContext {
	var p = new(ResumeWarehouseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_resumeWarehouseStatement
	return p
}

func InitEmptyResumeWarehouseStatementContext(p *ResumeWarehouseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_resumeWarehouseStatement
}

func (*ResumeWarehouseStatementContext) IsResumeWarehouseStatementContext() {}

func NewResumeWarehouseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResumeWarehouseStatementContext {
	var p = new(ResumeWarehouseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_resumeWarehouseStatement

	return p
}

func (s *ResumeWarehouseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ResumeWarehouseStatementContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRESUME, 0)
}

func (s *ResumeWarehouseStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWAREHOUSE, 0)
}

func (s *ResumeWarehouseStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ResumeWarehouseStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *ResumeWarehouseStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *ResumeWarehouseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumeWarehouseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResumeWarehouseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterResumeWarehouseStatement(s)
	}
}

func (s *ResumeWarehouseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitResumeWarehouseStatement(s)
	}
}

func (s *ResumeWarehouseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitResumeWarehouseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ResumeWarehouseStatement() (localctx IResumeWarehouseStatementContext) {
	localctx = NewResumeWarehouseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 718, DorisSQLParserParserRULE_resumeWarehouseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5768)
		p.Match(DorisSQLParserParserRESUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5769)
		p.Match(DorisSQLParserParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5772)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(5770)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5771)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5774)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetWarehouseStatementContext is an interface to support dynamic dispatch.
type ISetWarehouseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	SESSION() antlr.TerminalNode
	EQ() antlr.TerminalNode

	// IsSetWarehouseStatementContext differentiates from other interfaces.
	IsSetWarehouseStatementContext()
}

type SetWarehouseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetWarehouseStatementContext() *SetWarehouseStatementContext {
	var p = new(SetWarehouseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_setWarehouseStatement
	return p
}

func InitEmptySetWarehouseStatementContext(p *SetWarehouseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_setWarehouseStatement
}

func (*SetWarehouseStatementContext) IsSetWarehouseStatementContext() {}

func NewSetWarehouseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetWarehouseStatementContext {
	var p = new(SetWarehouseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_setWarehouseStatement

	return p
}

func (s *SetWarehouseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetWarehouseStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSET, 0)
}

func (s *SetWarehouseStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWAREHOUSE, 0)
}

func (s *SetWarehouseStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *SetWarehouseStatementContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSESSION, 0)
}

func (s *SetWarehouseStatementContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEQ, 0)
}

func (s *SetWarehouseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetWarehouseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetWarehouseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSetWarehouseStatement(s)
	}
}

func (s *SetWarehouseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSetWarehouseStatement(s)
	}
}

func (s *SetWarehouseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSetWarehouseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SetWarehouseStatement() (localctx ISetWarehouseStatementContext) {
	localctx = NewSetWarehouseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 720, DorisSQLParserParserRULE_setWarehouseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5776)
		p.Match(DorisSQLParserParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5778)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserSESSION {
		{
			p.SetState(5777)
			p.Match(DorisSQLParserParserSESSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5780)
		p.Match(DorisSQLParserParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5782)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserEQ {
		{
			p.SetState(5781)
			p.Match(DorisSQLParserParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5784)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowWarehousesStatementContext is an interface to support dynamic dispatch.
type IShowWarehousesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	WAREHOUSES() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	String_() IStringContext

	// IsShowWarehousesStatementContext differentiates from other interfaces.
	IsShowWarehousesStatementContext()
}

type ShowWarehousesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowWarehousesStatementContext() *ShowWarehousesStatementContext {
	var p = new(ShowWarehousesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showWarehousesStatement
	return p
}

func InitEmptyShowWarehousesStatementContext(p *ShowWarehousesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showWarehousesStatement
}

func (*ShowWarehousesStatementContext) IsShowWarehousesStatementContext() {}

func NewShowWarehousesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowWarehousesStatementContext {
	var p = new(ShowWarehousesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showWarehousesStatement

	return p
}

func (s *ShowWarehousesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowWarehousesStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowWarehousesStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowWarehousesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowWarehousesStatementContext) WAREHOUSES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWAREHOUSES, 0)
}

func (s *ShowWarehousesStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *ShowWarehousesStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowWarehousesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWarehousesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowWarehousesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowWarehousesStatement(s)
	}
}

func (s *ShowWarehousesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowWarehousesStatement(s)
	}
}

func (s *ShowWarehousesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowWarehousesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowWarehousesStatement() (localctx IShowWarehousesStatementContext) {
	localctx = NewShowWarehousesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 722, DorisSQLParserParserRULE_showWarehousesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5786)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5787)
		p.Match(DorisSQLParserParserWAREHOUSES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5790)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserLIKE {
		{
			p.SetState(5788)
			p.Match(DorisSQLParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5789)

			var _x = p.String_()

			localctx.(*ShowWarehousesStatementContext).pattern = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowClustersStatementContext is an interface to support dynamic dispatch.
type IShowClustersStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	FROM() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	Identifier() IIdentifierContext
	CLUSTERS() antlr.TerminalNode
	CNGROUPS() antlr.TerminalNode

	// IsShowClustersStatementContext differentiates from other interfaces.
	IsShowClustersStatementContext()
}

type ShowClustersStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowClustersStatementContext() *ShowClustersStatementContext {
	var p = new(ShowClustersStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showClustersStatement
	return p
}

func InitEmptyShowClustersStatementContext(p *ShowClustersStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showClustersStatement
}

func (*ShowClustersStatementContext) IsShowClustersStatementContext() {}

func NewShowClustersStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowClustersStatementContext {
	var p = new(ShowClustersStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showClustersStatement

	return p
}

func (s *ShowClustersStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowClustersStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowClustersStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowClustersStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWAREHOUSE, 0)
}

func (s *ShowClustersStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowClustersStatementContext) CLUSTERS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCLUSTERS, 0)
}

func (s *ShowClustersStatementContext) CNGROUPS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCNGROUPS, 0)
}

func (s *ShowClustersStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowClustersStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowClustersStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowClustersStatement(s)
	}
}

func (s *ShowClustersStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowClustersStatement(s)
	}
}

func (s *ShowClustersStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowClustersStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowClustersStatement() (localctx IShowClustersStatementContext) {
	localctx = NewShowClustersStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 724, DorisSQLParserParserRULE_showClustersStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5792)
		p.Match(DorisSQLParserParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5793)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserCLUSTERS || _la == DorisSQLParserParserCNGROUPS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5794)
		p.Match(DorisSQLParserParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5795)
		p.Match(DorisSQLParserParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5796)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowNodesStatementContext is an interface to support dynamic dispatch.
type IShowNodesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	NODES() antlr.TerminalNode
	FROM() antlr.TerminalNode
	WAREHOUSES() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	String_() IStringContext
	WAREHOUSE() antlr.TerminalNode
	Identifier() IIdentifierContext
	CNGROUP() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsShowNodesStatementContext differentiates from other interfaces.
	IsShowNodesStatementContext()
}

type ShowNodesStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	pattern     IStringContext
	cngroupName IIdentifierOrStringContext
}

func NewEmptyShowNodesStatementContext() *ShowNodesStatementContext {
	var p = new(ShowNodesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showNodesStatement
	return p
}

func InitEmptyShowNodesStatementContext(p *ShowNodesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_showNodesStatement
}

func (*ShowNodesStatementContext) IsShowNodesStatementContext() {}

func NewShowNodesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowNodesStatementContext {
	var p = new(ShowNodesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_showNodesStatement

	return p
}

func (s *ShowNodesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowNodesStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowNodesStatementContext) GetCngroupName() IIdentifierOrStringContext { return s.cngroupName }

func (s *ShowNodesStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowNodesStatementContext) SetCngroupName(v IIdentifierOrStringContext) { s.cngroupName = v }

func (s *ShowNodesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSHOW, 0)
}

func (s *ShowNodesStatementContext) NODES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNODES, 0)
}

func (s *ShowNodesStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ShowNodesStatementContext) WAREHOUSES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWAREHOUSES, 0)
}

func (s *ShowNodesStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *ShowNodesStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowNodesStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWAREHOUSE, 0)
}

func (s *ShowNodesStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowNodesStatementContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCNGROUP, 0)
}

func (s *ShowNodesStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *ShowNodesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowNodesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowNodesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterShowNodesStatement(s)
	}
}

func (s *ShowNodesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitShowNodesStatement(s)
	}
}

func (s *ShowNodesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitShowNodesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ShowNodesStatement() (localctx IShowNodesStatementContext) {
	localctx = NewShowNodesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 726, DorisSQLParserParserRULE_showNodesStatement)
	var _la int

	p.SetState(5815)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 635, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5798)
			p.Match(DorisSQLParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5799)
			p.Match(DorisSQLParserParserNODES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5800)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5801)
			p.Match(DorisSQLParserParserWAREHOUSES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5804)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserLIKE {
			{
				p.SetState(5802)
				p.Match(DorisSQLParserParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5803)

				var _x = p.String_()

				localctx.(*ShowNodesStatementContext).pattern = _x
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5806)
			p.Match(DorisSQLParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5807)
			p.Match(DorisSQLParserParserNODES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5808)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5809)
			p.Match(DorisSQLParserParserWAREHOUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5810)
			p.Identifier()
		}
		p.SetState(5813)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserCNGROUP {
			{
				p.SetState(5811)
				p.Match(DorisSQLParserParserCNGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5812)

				var _x = p.IdentifierOrString()

				localctx.(*ShowNodesStatementContext).cngroupName = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterWarehouseStatementContext is an interface to support dynamic dispatch.
type IAlterWarehouseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	ModifyPropertiesClause() IModifyPropertiesClauseContext
	IdentifierOrString() IIdentifierOrStringContext

	// IsAlterWarehouseStatementContext differentiates from other interfaces.
	IsAlterWarehouseStatementContext()
}

type AlterWarehouseStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
}

func NewEmptyAlterWarehouseStatementContext() *AlterWarehouseStatementContext {
	var p = new(AlterWarehouseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterWarehouseStatement
	return p
}

func InitEmptyAlterWarehouseStatementContext(p *AlterWarehouseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterWarehouseStatement
}

func (*AlterWarehouseStatementContext) IsAlterWarehouseStatementContext() {}

func NewAlterWarehouseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterWarehouseStatementContext {
	var p = new(AlterWarehouseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_alterWarehouseStatement

	return p
}

func (s *AlterWarehouseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterWarehouseStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *AlterWarehouseStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *AlterWarehouseStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *AlterWarehouseStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWAREHOUSE, 0)
}

func (s *AlterWarehouseStatementContext) ModifyPropertiesClause() IModifyPropertiesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyPropertiesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyPropertiesClauseContext)
}

func (s *AlterWarehouseStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AlterWarehouseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterWarehouseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterWarehouseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAlterWarehouseStatement(s)
	}
}

func (s *AlterWarehouseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAlterWarehouseStatement(s)
	}
}

func (s *AlterWarehouseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAlterWarehouseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AlterWarehouseStatement() (localctx IAlterWarehouseStatementContext) {
	localctx = NewAlterWarehouseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 728, DorisSQLParserParserRULE_alterWarehouseStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5817)
		p.Match(DorisSQLParserParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5818)
		p.Match(DorisSQLParserParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5819)

		var _x = p.IdentifierOrString()

		localctx.(*AlterWarehouseStatementContext).warehouseName = _x
	}
	{
		p.SetState(5820)
		p.ModifyPropertiesClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateCNGroupStatementContext is an interface to support dynamic dispatch.
type ICreateCNGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	ADD() antlr.TerminalNode
	CNGROUP() antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Comment() ICommentContext
	Properties() IPropertiesContext

	// IsCreateCNGroupStatementContext differentiates from other interfaces.
	IsCreateCNGroupStatementContext()
}

type CreateCNGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyCreateCNGroupStatementContext() *CreateCNGroupStatementContext {
	var p = new(CreateCNGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createCNGroupStatement
	return p
}

func InitEmptyCreateCNGroupStatementContext(p *CreateCNGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_createCNGroupStatement
}

func (*CreateCNGroupStatementContext) IsCreateCNGroupStatementContext() {}

func NewCreateCNGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateCNGroupStatementContext {
	var p = new(CreateCNGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_createCNGroupStatement

	return p
}

func (s *CreateCNGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateCNGroupStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *CreateCNGroupStatementContext) GetCngroupName() IIdentifierOrStringContext {
	return s.cngroupName
}

func (s *CreateCNGroupStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *CreateCNGroupStatementContext) SetCngroupName(v IIdentifierOrStringContext) {
	s.cngroupName = v
}

func (s *CreateCNGroupStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *CreateCNGroupStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWAREHOUSE, 0)
}

func (s *CreateCNGroupStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADD, 0)
}

func (s *CreateCNGroupStatementContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCNGROUP, 0)
}

func (s *CreateCNGroupStatementContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *CreateCNGroupStatementContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CreateCNGroupStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *CreateCNGroupStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *CreateCNGroupStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *CreateCNGroupStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateCNGroupStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateCNGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateCNGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateCNGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCreateCNGroupStatement(s)
	}
}

func (s *CreateCNGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCreateCNGroupStatement(s)
	}
}

func (s *CreateCNGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCreateCNGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CreateCNGroupStatement() (localctx ICreateCNGroupStatementContext) {
	localctx = NewCreateCNGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 730, DorisSQLParserParserRULE_createCNGroupStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5822)
		p.Match(DorisSQLParserParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5823)
		p.Match(DorisSQLParserParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5824)

		var _x = p.IdentifierOrString()

		localctx.(*CreateCNGroupStatementContext).warehouseName = _x
	}
	{
		p.SetState(5825)
		p.Match(DorisSQLParserParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5826)
		p.Match(DorisSQLParserParserCNGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5830)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(5827)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5828)
			p.Match(DorisSQLParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5829)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5832)

		var _x = p.IdentifierOrString()

		localctx.(*CreateCNGroupStatementContext).cngroupName = _x
	}
	p.SetState(5834)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserCOMMENT {
		{
			p.SetState(5833)
			p.Comment()
		}

	}
	p.SetState(5837)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(5836)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropCNGroupStatementContext is an interface to support dynamic dispatch.
type IDropCNGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	DROP() antlr.TerminalNode
	CNGROUP() antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	FORCE() antlr.TerminalNode

	// IsDropCNGroupStatementContext differentiates from other interfaces.
	IsDropCNGroupStatementContext()
}

type DropCNGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyDropCNGroupStatementContext() *DropCNGroupStatementContext {
	var p = new(DropCNGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropCNGroupStatement
	return p
}

func InitEmptyDropCNGroupStatementContext(p *DropCNGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dropCNGroupStatement
}

func (*DropCNGroupStatementContext) IsDropCNGroupStatementContext() {}

func NewDropCNGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropCNGroupStatementContext {
	var p = new(DropCNGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dropCNGroupStatement

	return p
}

func (s *DropCNGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropCNGroupStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *DropCNGroupStatementContext) GetCngroupName() IIdentifierOrStringContext {
	return s.cngroupName
}

func (s *DropCNGroupStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *DropCNGroupStatementContext) SetCngroupName(v IIdentifierOrStringContext) { s.cngroupName = v }

func (s *DropCNGroupStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *DropCNGroupStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWAREHOUSE, 0)
}

func (s *DropCNGroupStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DropCNGroupStatementContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCNGROUP, 0)
}

func (s *DropCNGroupStatementContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *DropCNGroupStatementContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropCNGroupStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *DropCNGroupStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *DropCNGroupStatementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFORCE, 0)
}

func (s *DropCNGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropCNGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropCNGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDropCNGroupStatement(s)
	}
}

func (s *DropCNGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDropCNGroupStatement(s)
	}
}

func (s *DropCNGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDropCNGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DropCNGroupStatement() (localctx IDropCNGroupStatementContext) {
	localctx = NewDropCNGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 732, DorisSQLParserParserRULE_dropCNGroupStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5839)
		p.Match(DorisSQLParserParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5840)
		p.Match(DorisSQLParserParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5841)

		var _x = p.IdentifierOrString()

		localctx.(*DropCNGroupStatementContext).warehouseName = _x
	}
	{
		p.SetState(5842)
		p.Match(DorisSQLParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5843)
		p.Match(DorisSQLParserParserCNGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(5844)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5845)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5848)

		var _x = p.IdentifierOrString()

		localctx.(*DropCNGroupStatementContext).cngroupName = _x
	}
	p.SetState(5850)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFORCE {
		{
			p.SetState(5849)
			p.Match(DorisSQLParserParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnableCNGroupStatementContext is an interface to support dynamic dispatch.
type IEnableCNGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	ENABLE() antlr.TerminalNode
	CNGROUP() antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext

	// IsEnableCNGroupStatementContext differentiates from other interfaces.
	IsEnableCNGroupStatementContext()
}

type EnableCNGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyEnableCNGroupStatementContext() *EnableCNGroupStatementContext {
	var p = new(EnableCNGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_enableCNGroupStatement
	return p
}

func InitEmptyEnableCNGroupStatementContext(p *EnableCNGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_enableCNGroupStatement
}

func (*EnableCNGroupStatementContext) IsEnableCNGroupStatementContext() {}

func NewEnableCNGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnableCNGroupStatementContext {
	var p = new(EnableCNGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_enableCNGroupStatement

	return p
}

func (s *EnableCNGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EnableCNGroupStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *EnableCNGroupStatementContext) GetCngroupName() IIdentifierOrStringContext {
	return s.cngroupName
}

func (s *EnableCNGroupStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *EnableCNGroupStatementContext) SetCngroupName(v IIdentifierOrStringContext) {
	s.cngroupName = v
}

func (s *EnableCNGroupStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *EnableCNGroupStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWAREHOUSE, 0)
}

func (s *EnableCNGroupStatementContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserENABLE, 0)
}

func (s *EnableCNGroupStatementContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCNGROUP, 0)
}

func (s *EnableCNGroupStatementContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *EnableCNGroupStatementContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *EnableCNGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnableCNGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnableCNGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterEnableCNGroupStatement(s)
	}
}

func (s *EnableCNGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitEnableCNGroupStatement(s)
	}
}

func (s *EnableCNGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitEnableCNGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) EnableCNGroupStatement() (localctx IEnableCNGroupStatementContext) {
	localctx = NewEnableCNGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 734, DorisSQLParserParserRULE_enableCNGroupStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5852)
		p.Match(DorisSQLParserParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5853)
		p.Match(DorisSQLParserParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5854)

		var _x = p.IdentifierOrString()

		localctx.(*EnableCNGroupStatementContext).warehouseName = _x
	}
	{
		p.SetState(5855)
		p.Match(DorisSQLParserParserENABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5856)
		p.Match(DorisSQLParserParserCNGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5857)

		var _x = p.IdentifierOrString()

		localctx.(*EnableCNGroupStatementContext).cngroupName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDisableCNGroupStatementContext is an interface to support dynamic dispatch.
type IDisableCNGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	CNGROUP() antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext

	// IsDisableCNGroupStatementContext differentiates from other interfaces.
	IsDisableCNGroupStatementContext()
}

type DisableCNGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyDisableCNGroupStatementContext() *DisableCNGroupStatementContext {
	var p = new(DisableCNGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_disableCNGroupStatement
	return p
}

func InitEmptyDisableCNGroupStatementContext(p *DisableCNGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_disableCNGroupStatement
}

func (*DisableCNGroupStatementContext) IsDisableCNGroupStatementContext() {}

func NewDisableCNGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisableCNGroupStatementContext {
	var p = new(DisableCNGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_disableCNGroupStatement

	return p
}

func (s *DisableCNGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DisableCNGroupStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *DisableCNGroupStatementContext) GetCngroupName() IIdentifierOrStringContext {
	return s.cngroupName
}

func (s *DisableCNGroupStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *DisableCNGroupStatementContext) SetCngroupName(v IIdentifierOrStringContext) {
	s.cngroupName = v
}

func (s *DisableCNGroupStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *DisableCNGroupStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWAREHOUSE, 0)
}

func (s *DisableCNGroupStatementContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDISABLE, 0)
}

func (s *DisableCNGroupStatementContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCNGROUP, 0)
}

func (s *DisableCNGroupStatementContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *DisableCNGroupStatementContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DisableCNGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisableCNGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisableCNGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDisableCNGroupStatement(s)
	}
}

func (s *DisableCNGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDisableCNGroupStatement(s)
	}
}

func (s *DisableCNGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDisableCNGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DisableCNGroupStatement() (localctx IDisableCNGroupStatementContext) {
	localctx = NewDisableCNGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 736, DorisSQLParserParserRULE_disableCNGroupStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5859)
		p.Match(DorisSQLParserParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5860)
		p.Match(DorisSQLParserParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5861)

		var _x = p.IdentifierOrString()

		localctx.(*DisableCNGroupStatementContext).warehouseName = _x
	}
	{
		p.SetState(5862)
		p.Match(DorisSQLParserParserDISABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5863)
		p.Match(DorisSQLParserParserCNGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5864)

		var _x = p.IdentifierOrString()

		localctx.(*DisableCNGroupStatementContext).cngroupName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterCNGroupStatementContext is an interface to support dynamic dispatch.
type IAlterCNGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	CNGROUP() antlr.TerminalNode
	ModifyPropertiesClause() IModifyPropertiesClauseContext
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext

	// IsAlterCNGroupStatementContext differentiates from other interfaces.
	IsAlterCNGroupStatementContext()
}

type AlterCNGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyAlterCNGroupStatementContext() *AlterCNGroupStatementContext {
	var p = new(AlterCNGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterCNGroupStatement
	return p
}

func InitEmptyAlterCNGroupStatementContext(p *AlterCNGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_alterCNGroupStatement
}

func (*AlterCNGroupStatementContext) IsAlterCNGroupStatementContext() {}

func NewAlterCNGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterCNGroupStatementContext {
	var p = new(AlterCNGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_alterCNGroupStatement

	return p
}

func (s *AlterCNGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterCNGroupStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *AlterCNGroupStatementContext) GetCngroupName() IIdentifierOrStringContext {
	return s.cngroupName
}

func (s *AlterCNGroupStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *AlterCNGroupStatementContext) SetCngroupName(v IIdentifierOrStringContext) {
	s.cngroupName = v
}

func (s *AlterCNGroupStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALTER, 0)
}

func (s *AlterCNGroupStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWAREHOUSE, 0)
}

func (s *AlterCNGroupStatementContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMODIFY, 0)
}

func (s *AlterCNGroupStatementContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCNGROUP, 0)
}

func (s *AlterCNGroupStatementContext) ModifyPropertiesClause() IModifyPropertiesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyPropertiesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyPropertiesClauseContext)
}

func (s *AlterCNGroupStatementContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *AlterCNGroupStatementContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AlterCNGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterCNGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterCNGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAlterCNGroupStatement(s)
	}
}

func (s *AlterCNGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAlterCNGroupStatement(s)
	}
}

func (s *AlterCNGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAlterCNGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AlterCNGroupStatement() (localctx IAlterCNGroupStatementContext) {
	localctx = NewAlterCNGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 738, DorisSQLParserParserRULE_alterCNGroupStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5866)
		p.Match(DorisSQLParserParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5867)
		p.Match(DorisSQLParserParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5868)

		var _x = p.IdentifierOrString()

		localctx.(*AlterCNGroupStatementContext).warehouseName = _x
	}
	{
		p.SetState(5869)
		p.Match(DorisSQLParserParserMODIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5870)
		p.Match(DorisSQLParserParserCNGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5871)

		var _x = p.IdentifierOrString()

		localctx.(*AlterCNGroupStatementContext).cngroupName = _x
	}
	{
		p.SetState(5872)
		p.ModifyPropertiesClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBeginStatementContext is an interface to support dynamic dispatch.
type IBeginStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	WITH() antlr.TerminalNode
	CONSISTENT() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	WORK() antlr.TerminalNode

	// IsBeginStatementContext differentiates from other interfaces.
	IsBeginStatementContext()
}

type BeginStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBeginStatementContext() *BeginStatementContext {
	var p = new(BeginStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_beginStatement
	return p
}

func InitEmptyBeginStatementContext(p *BeginStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_beginStatement
}

func (*BeginStatementContext) IsBeginStatementContext() {}

func NewBeginStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BeginStatementContext {
	var p = new(BeginStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_beginStatement

	return p
}

func (s *BeginStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BeginStatementContext) START() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTART, 0)
}

func (s *BeginStatementContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTRANSACTION, 0)
}

func (s *BeginStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *BeginStatementContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCONSISTENT, 0)
}

func (s *BeginStatementContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSNAPSHOT, 0)
}

func (s *BeginStatementContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBEGIN, 0)
}

func (s *BeginStatementContext) WORK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWORK, 0)
}

func (s *BeginStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BeginStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BeginStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterBeginStatement(s)
	}
}

func (s *BeginStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitBeginStatement(s)
	}
}

func (s *BeginStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitBeginStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) BeginStatement() (localctx IBeginStatementContext) {
	localctx = NewBeginStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 740, DorisSQLParserParserRULE_beginStatement)
	var _la int

	p.SetState(5885)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserSTART:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5874)
			p.Match(DorisSQLParserParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5875)
			p.Match(DorisSQLParserParserTRANSACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5879)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserWITH {
			{
				p.SetState(5876)
				p.Match(DorisSQLParserParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5877)
				p.Match(DorisSQLParserParserCONSISTENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5878)
				p.Match(DorisSQLParserParserSNAPSHOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DorisSQLParserParserBEGIN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5881)
			p.Match(DorisSQLParserParserBEGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5883)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserWORK {
			{
				p.SetState(5882)
				p.Match(DorisSQLParserParserWORK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommitStatementContext is an interface to support dynamic dispatch.
type ICommitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMIT() antlr.TerminalNode
	WORK() antlr.TerminalNode
	AND() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	RELEASE() antlr.TerminalNode
	AllNO() []antlr.TerminalNode
	NO(i int) antlr.TerminalNode

	// IsCommitStatementContext differentiates from other interfaces.
	IsCommitStatementContext()
}

type CommitStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommitStatementContext() *CommitStatementContext {
	var p = new(CommitStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_commitStatement
	return p
}

func InitEmptyCommitStatementContext(p *CommitStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_commitStatement
}

func (*CommitStatementContext) IsCommitStatementContext() {}

func NewCommitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommitStatementContext {
	var p = new(CommitStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_commitStatement

	return p
}

func (s *CommitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CommitStatementContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOMMIT, 0)
}

func (s *CommitStatementContext) WORK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWORK, 0)
}

func (s *CommitStatementContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAND, 0)
}

func (s *CommitStatementContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCHAIN, 0)
}

func (s *CommitStatementContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRELEASE, 0)
}

func (s *CommitStatementContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserNO)
}

func (s *CommitStatementContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNO, i)
}

func (s *CommitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCommitStatement(s)
	}
}

func (s *CommitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCommitStatement(s)
	}
}

func (s *CommitStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCommitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CommitStatement() (localctx ICommitStatementContext) {
	localctx = NewCommitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 742, DorisSQLParserParserRULE_commitStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5887)
		p.Match(DorisSQLParserParserCOMMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5889)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWORK {
		{
			p.SetState(5888)
			p.Match(DorisSQLParserParserWORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5896)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserAND {
		{
			p.SetState(5891)
			p.Match(DorisSQLParserParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5893)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserNO {
			{
				p.SetState(5892)
				p.Match(DorisSQLParserParserNO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5895)
			p.Match(DorisSQLParserParserCHAIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5902)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserNO || _la == DorisSQLParserParserRELEASE {
		p.SetState(5899)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserNO {
			{
				p.SetState(5898)
				p.Match(DorisSQLParserParserNO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5901)
			p.Match(DorisSQLParserParserRELEASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollbackStatementContext is an interface to support dynamic dispatch.
type IRollbackStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLLBACK() antlr.TerminalNode
	WORK() antlr.TerminalNode
	AND() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	RELEASE() antlr.TerminalNode
	AllNO() []antlr.TerminalNode
	NO(i int) antlr.TerminalNode

	// IsRollbackStatementContext differentiates from other interfaces.
	IsRollbackStatementContext()
}

type RollbackStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollbackStatementContext() *RollbackStatementContext {
	var p = new(RollbackStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_rollbackStatement
	return p
}

func InitEmptyRollbackStatementContext(p *RollbackStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_rollbackStatement
}

func (*RollbackStatementContext) IsRollbackStatementContext() {}

func NewRollbackStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollbackStatementContext {
	var p = new(RollbackStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_rollbackStatement

	return p
}

func (s *RollbackStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RollbackStatementContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROLLBACK, 0)
}

func (s *RollbackStatementContext) WORK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWORK, 0)
}

func (s *RollbackStatementContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAND, 0)
}

func (s *RollbackStatementContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCHAIN, 0)
}

func (s *RollbackStatementContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRELEASE, 0)
}

func (s *RollbackStatementContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserNO)
}

func (s *RollbackStatementContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNO, i)
}

func (s *RollbackStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollbackStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollbackStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRollbackStatement(s)
	}
}

func (s *RollbackStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRollbackStatement(s)
	}
}

func (s *RollbackStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRollbackStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) RollbackStatement() (localctx IRollbackStatementContext) {
	localctx = NewRollbackStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 744, DorisSQLParserParserRULE_rollbackStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5904)
		p.Match(DorisSQLParserParserROLLBACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5906)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWORK {
		{
			p.SetState(5905)
			p.Match(DorisSQLParserParserWORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5913)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserAND {
		{
			p.SetState(5908)
			p.Match(DorisSQLParserParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5910)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserNO {
			{
				p.SetState(5909)
				p.Match(DorisSQLParserParserNO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5912)
			p.Match(DorisSQLParserParserCHAIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5919)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserNO || _la == DorisSQLParserParserRELEASE {
		p.SetState(5916)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserNO {
			{
				p.SetState(5915)
				p.Match(DorisSQLParserParserNO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5918)
			p.Match(DorisSQLParserParserRELEASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITranslateStatementContext is an interface to support dynamic dispatch.
type ITranslateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRANSLATE() antlr.TerminalNode
	Dialect() IDialectContext
	TranslateSQL() ITranslateSQLContext

	// IsTranslateStatementContext differentiates from other interfaces.
	IsTranslateStatementContext()
}

type TranslateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTranslateStatementContext() *TranslateStatementContext {
	var p = new(TranslateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_translateStatement
	return p
}

func InitEmptyTranslateStatementContext(p *TranslateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_translateStatement
}

func (*TranslateStatementContext) IsTranslateStatementContext() {}

func NewTranslateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TranslateStatementContext {
	var p = new(TranslateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_translateStatement

	return p
}

func (s *TranslateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TranslateStatementContext) TRANSLATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTRANSLATE, 0)
}

func (s *TranslateStatementContext) Dialect() IDialectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDialectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDialectContext)
}

func (s *TranslateStatementContext) TranslateSQL() ITranslateSQLContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITranslateSQLContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITranslateSQLContext)
}

func (s *TranslateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TranslateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TranslateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTranslateStatement(s)
	}
}

func (s *TranslateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTranslateStatement(s)
	}
}

func (s *TranslateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTranslateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) TranslateStatement() (localctx ITranslateStatementContext) {
	localctx = NewTranslateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 746, DorisSQLParserParserRULE_translateStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5921)
		p.Match(DorisSQLParserParserTRANSLATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5922)
		p.Dialect()
	}
	{
		p.SetState(5923)
		p.TranslateSQL()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDialectContext is an interface to support dynamic dispatch.
type IDialectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsDialectContext differentiates from other interfaces.
	IsDialectContext()
}

type DialectContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDialectContext() *DialectContext {
	var p = new(DialectContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dialect
	return p
}

func InitEmptyDialectContext(p *DialectContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_dialect
}

func (*DialectContext) IsDialectContext() {}

func NewDialectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DialectContext {
	var p = new(DialectContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_dialect

	return p
}

func (s *DialectContext) GetParser() antlr.Parser { return s.parser }

func (s *DialectContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DialectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DialectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DialectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDialect(s)
	}
}

func (s *DialectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDialect(s)
	}
}

func (s *DialectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDialect(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Dialect() (localctx IDialectContext) {
	localctx = NewDialectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 748, DorisSQLParserParserRULE_dialect)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5925)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITranslateSQLContext is an interface to support dynamic dispatch.
type ITranslateSQLContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTranslateSQLContext differentiates from other interfaces.
	IsTranslateSQLContext()
}

type TranslateSQLContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTranslateSQLContext() *TranslateSQLContext {
	var p = new(TranslateSQLContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_translateSQL
	return p
}

func InitEmptyTranslateSQLContext(p *TranslateSQLContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_translateSQL
}

func (*TranslateSQLContext) IsTranslateSQLContext() {}

func NewTranslateSQLContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TranslateSQLContext {
	var p = new(TranslateSQLContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_translateSQL

	return p
}

func (s *TranslateSQLContext) GetParser() antlr.Parser { return s.parser }
func (s *TranslateSQLContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TranslateSQLContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TranslateSQLContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTranslateSQL(s)
	}
}

func (s *TranslateSQLContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTranslateSQL(s)
	}
}

func (s *TranslateSQLContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTranslateSQL(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) TranslateSQL() (localctx ITranslateSQLContext) {
	localctx = NewTranslateSQLContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 750, DorisSQLParserParserRULE_translateSQL)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5928)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(5927)
			p.MatchWildcard()

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(5930)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 654, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryStatementContext is an interface to support dynamic dispatch.
type IQueryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryRelation() IQueryRelationContext
	ExplainDesc() IExplainDescContext
	OptimizerTrace() IOptimizerTraceContext
	Outfile() IOutfileContext

	// IsQueryStatementContext differentiates from other interfaces.
	IsQueryStatementContext()
}

type QueryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryStatementContext() *QueryStatementContext {
	var p = new(QueryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_queryStatement
	return p
}

func InitEmptyQueryStatementContext(p *QueryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_queryStatement
}

func (*QueryStatementContext) IsQueryStatementContext() {}

func NewQueryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryStatementContext {
	var p = new(QueryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_queryStatement

	return p
}

func (s *QueryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryStatementContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *QueryStatementContext) ExplainDesc() IExplainDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainDescContext)
}

func (s *QueryStatementContext) OptimizerTrace() IOptimizerTraceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptimizerTraceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptimizerTraceContext)
}

func (s *QueryStatementContext) Outfile() IOutfileContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOutfileContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOutfileContext)
}

func (s *QueryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterQueryStatement(s)
	}
}

func (s *QueryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitQueryStatement(s)
	}
}

func (s *QueryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitQueryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) QueryStatement() (localctx IQueryStatementContext) {
	localctx = NewQueryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 752, DorisSQLParserParserRULE_queryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5934)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserDESC, DorisSQLParserParserDESCRIBE, DorisSQLParserParserEXPLAIN:
		{
			p.SetState(5932)
			p.ExplainDesc()
		}

	case DorisSQLParserParserTRACE:
		{
			p.SetState(5933)
			p.OptimizerTrace()
		}

	case DorisSQLParserParserT__1, DorisSQLParserParserSELECT, DorisSQLParserParserWITH:

	default:
	}
	{
		p.SetState(5936)
		p.QueryRelation()
	}
	p.SetState(5938)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserINTO {
		{
			p.SetState(5937)
			p.Outfile()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryRelationContext is an interface to support dynamic dispatch.
type IQueryRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryNoWith() IQueryNoWithContext
	WithClause() IWithClauseContext

	// IsQueryRelationContext differentiates from other interfaces.
	IsQueryRelationContext()
}

type QueryRelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryRelationContext() *QueryRelationContext {
	var p = new(QueryRelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_queryRelation
	return p
}

func InitEmptyQueryRelationContext(p *QueryRelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_queryRelation
}

func (*QueryRelationContext) IsQueryRelationContext() {}

func NewQueryRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryRelationContext {
	var p = new(QueryRelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_queryRelation

	return p
}

func (s *QueryRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryRelationContext) QueryNoWith() IQueryNoWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryNoWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryNoWithContext)
}

func (s *QueryRelationContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *QueryRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterQueryRelation(s)
	}
}

func (s *QueryRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitQueryRelation(s)
	}
}

func (s *QueryRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitQueryRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) QueryRelation() (localctx IQueryRelationContext) {
	localctx = NewQueryRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 754, DorisSQLParserParserRULE_queryRelation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5941)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserWITH {
		{
			p.SetState(5940)
			p.WithClause()
		}

	}
	{
		p.SetState(5943)
		p.QueryNoWith()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithClauseContext is an interface to support dynamic dispatch.
type IWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	AllCommonTableExpression() []ICommonTableExpressionContext
	CommonTableExpression(i int) ICommonTableExpressionContext

	// IsWithClauseContext differentiates from other interfaces.
	IsWithClauseContext()
}

type WithClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithClauseContext() *WithClauseContext {
	var p = new(WithClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_withClause
	return p
}

func InitEmptyWithClauseContext(p *WithClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_withClause
}

func (*WithClauseContext) IsWithClauseContext() {}

func NewWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithClauseContext {
	var p = new(WithClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_withClause

	return p
}

func (s *WithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWITH, 0)
}

func (s *WithClauseContext) AllCommonTableExpression() []ICommonTableExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommonTableExpressionContext); ok {
			len++
		}
	}

	tst := make([]ICommonTableExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommonTableExpressionContext); ok {
			tst[i] = t.(ICommonTableExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WithClauseContext) CommonTableExpression(i int) ICommonTableExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommonTableExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommonTableExpressionContext)
}

func (s *WithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterWithClause(s)
	}
}

func (s *WithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitWithClause(s)
	}
}

func (s *WithClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitWithClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) WithClause() (localctx IWithClauseContext) {
	localctx = NewWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 756, DorisSQLParserParserRULE_withClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5945)
		p.Match(DorisSQLParserParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5946)
		p.CommonTableExpression()
	}
	p.SetState(5951)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(5947)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5948)
			p.CommonTableExpression()
		}

		p.SetState(5953)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryNoWithContext is an interface to support dynamic dispatch.
type IQueryNoWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryPrimary() IQueryPrimaryContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext

	// IsQueryNoWithContext differentiates from other interfaces.
	IsQueryNoWithContext()
}

type QueryNoWithContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryNoWithContext() *QueryNoWithContext {
	var p = new(QueryNoWithContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_queryNoWith
	return p
}

func InitEmptyQueryNoWithContext(p *QueryNoWithContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_queryNoWith
}

func (*QueryNoWithContext) IsQueryNoWithContext() {}

func NewQueryNoWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryNoWithContext {
	var p = new(QueryNoWithContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_queryNoWith

	return p
}

func (s *QueryNoWithContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryNoWithContext) QueryPrimary() IQueryPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryPrimaryContext)
}

func (s *QueryNoWithContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserORDER, 0)
}

func (s *QueryNoWithContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *QueryNoWithContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *QueryNoWithContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *QueryNoWithContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *QueryNoWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryNoWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryNoWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterQueryNoWith(s)
	}
}

func (s *QueryNoWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitQueryNoWith(s)
	}
}

func (s *QueryNoWithContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitQueryNoWith(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) QueryNoWith() (localctx IQueryNoWithContext) {
	localctx = NewQueryNoWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 758, DorisSQLParserParserRULE_queryNoWith)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5954)
		p.queryPrimary(0)
	}
	p.SetState(5965)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserORDER {
		{
			p.SetState(5955)
			p.Match(DorisSQLParserParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5956)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5957)
			p.SortItem()
		}
		p.SetState(5962)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(5958)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5959)
				p.SortItem()
			}

			p.SetState(5964)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(5968)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserLIMIT {
		{
			p.SetState(5967)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryPeriodContext is an interface to support dynamic dispatch.
type IQueryPeriodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetEnd returns the end rule contexts.
	GetEnd() IExpressionContext

	// SetEnd sets the end rule contexts.
	SetEnd(IExpressionContext)

	// Getter signatures
	PeriodType() IPeriodTypeContext
	BETWEEN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AND() antlr.TerminalNode
	FOR() antlr.TerminalNode
	FROM() antlr.TerminalNode
	TO() antlr.TerminalNode
	ALL() antlr.TerminalNode
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode

	// IsQueryPeriodContext differentiates from other interfaces.
	IsQueryPeriodContext()
}

type QueryPeriodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	end    IExpressionContext
}

func NewEmptyQueryPeriodContext() *QueryPeriodContext {
	var p = new(QueryPeriodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_queryPeriod
	return p
}

func InitEmptyQueryPeriodContext(p *QueryPeriodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_queryPeriod
}

func (*QueryPeriodContext) IsQueryPeriodContext() {}

func NewQueryPeriodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryPeriodContext {
	var p = new(QueryPeriodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_queryPeriod

	return p
}

func (s *QueryPeriodContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryPeriodContext) GetEnd() IExpressionContext { return s.end }

func (s *QueryPeriodContext) SetEnd(v IExpressionContext) { s.end = v }

func (s *QueryPeriodContext) PeriodType() IPeriodTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPeriodTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPeriodTypeContext)
}

func (s *QueryPeriodContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBETWEEN, 0)
}

func (s *QueryPeriodContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *QueryPeriodContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *QueryPeriodContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAND, 0)
}

func (s *QueryPeriodContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFOR, 0)
}

func (s *QueryPeriodContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *QueryPeriodContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTO, 0)
}

func (s *QueryPeriodContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, 0)
}

func (s *QueryPeriodContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *QueryPeriodContext) OF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOF, 0)
}

func (s *QueryPeriodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPeriodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryPeriodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterQueryPeriod(s)
	}
}

func (s *QueryPeriodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitQueryPeriod(s)
	}
}

func (s *QueryPeriodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitQueryPeriod(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) QueryPeriod() (localctx IQueryPeriodContext) {
	localctx = NewQueryPeriodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 760, DorisSQLParserParserRULE_queryPeriod)
	var _la int

	p.SetState(6002)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 666, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5971)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserFOR {
			{
				p.SetState(5970)
				p.Match(DorisSQLParserParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5973)
			p.PeriodType()
		}
		{
			p.SetState(5974)
			p.Match(DorisSQLParserParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5975)
			p.expression(0)
		}
		{
			p.SetState(5976)
			p.Match(DorisSQLParserParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5977)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5980)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserFOR {
			{
				p.SetState(5979)
				p.Match(DorisSQLParserParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5982)
			p.PeriodType()
		}
		{
			p.SetState(5983)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5984)
			p.expression(0)
		}
		{
			p.SetState(5985)
			p.Match(DorisSQLParserParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5986)
			p.expression(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(5989)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserFOR {
			{
				p.SetState(5988)
				p.Match(DorisSQLParserParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5991)
			p.PeriodType()
		}
		{
			p.SetState(5992)
			p.Match(DorisSQLParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(5995)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserFOR {
			{
				p.SetState(5994)
				p.Match(DorisSQLParserParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5997)
			p.PeriodType()
		}
		{
			p.SetState(5998)
			p.Match(DorisSQLParserParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5999)
			p.Match(DorisSQLParserParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6000)

			var _x = p.expression(0)

			localctx.(*QueryPeriodContext).end = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPeriodTypeContext is an interface to support dynamic dispatch.
type IPeriodTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SYSTEM_TIME() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	VERSION() antlr.TerminalNode

	// IsPeriodTypeContext differentiates from other interfaces.
	IsPeriodTypeContext()
}

type PeriodTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPeriodTypeContext() *PeriodTypeContext {
	var p = new(PeriodTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_periodType
	return p
}

func InitEmptyPeriodTypeContext(p *PeriodTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_periodType
}

func (*PeriodTypeContext) IsPeriodTypeContext() {}

func NewPeriodTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PeriodTypeContext {
	var p = new(PeriodTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_periodType

	return p
}

func (s *PeriodTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PeriodTypeContext) SYSTEM_TIME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSYSTEM_TIME, 0)
}

func (s *PeriodTypeContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTIMESTAMP, 0)
}

func (s *PeriodTypeContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVERSION, 0)
}

func (s *PeriodTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PeriodTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PeriodTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPeriodType(s)
	}
}

func (s *PeriodTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPeriodType(s)
	}
}

func (s *PeriodTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPeriodType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PeriodType() (localctx IPeriodTypeContext) {
	localctx = NewPeriodTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 762, DorisSQLParserParserRULE_periodType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6004)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-419)) & ^0x3f) == 0 && ((int64(1)<<(_la-419))&562949953454081) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryPrimaryContext is an interface to support dynamic dispatch.
type IQueryPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQueryPrimaryContext differentiates from other interfaces.
	IsQueryPrimaryContext()
}

type QueryPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryPrimaryContext() *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_queryPrimary
	return p
}

func InitEmptyQueryPrimaryContext(p *QueryPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_queryPrimary
}

func (*QueryPrimaryContext) IsQueryPrimaryContext() {}

func NewQueryPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_queryPrimary

	return p
}

func (s *QueryPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryPrimaryContext) CopyAll(ctx *QueryPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QueryPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QueryWithParenthesesContext struct {
	QueryPrimaryContext
}

func NewQueryWithParenthesesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryWithParenthesesContext {
	var p = new(QueryWithParenthesesContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *QueryWithParenthesesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryWithParenthesesContext) Subquery() ISubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *QueryWithParenthesesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterQueryWithParentheses(s)
	}
}

func (s *QueryWithParenthesesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitQueryWithParentheses(s)
	}
}

func (s *QueryWithParenthesesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitQueryWithParentheses(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetOperationContext struct {
	QueryPrimaryContext
	left     IQueryPrimaryContext
	operator antlr.Token
	right    IQueryPrimaryContext
}

func NewSetOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetOperationContext {
	var p = new(SetOperationContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *SetOperationContext) GetOperator() antlr.Token { return s.operator }

func (s *SetOperationContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *SetOperationContext) GetLeft() IQueryPrimaryContext { return s.left }

func (s *SetOperationContext) GetRight() IQueryPrimaryContext { return s.right }

func (s *SetOperationContext) SetLeft(v IQueryPrimaryContext) { s.left = v }

func (s *SetOperationContext) SetRight(v IQueryPrimaryContext) { s.right = v }

func (s *SetOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOperationContext) AllQueryPrimary() []IQueryPrimaryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			len++
		}
	}

	tst := make([]IQueryPrimaryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQueryPrimaryContext); ok {
			tst[i] = t.(IQueryPrimaryContext)
			i++
		}
	}

	return tst
}

func (s *SetOperationContext) QueryPrimary(i int) IQueryPrimaryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryPrimaryContext)
}

func (s *SetOperationContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTERSECT, 0)
}

func (s *SetOperationContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *SetOperationContext) UNION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUNION, 0)
}

func (s *SetOperationContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXCEPT, 0)
}

func (s *SetOperationContext) MINUS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMINUS, 0)
}

func (s *SetOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSetOperation(s)
	}
}

func (s *SetOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSetOperation(s)
	}
}

func (s *SetOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSetOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

type QueryPrimaryDefaultContext struct {
	QueryPrimaryContext
}

func NewQueryPrimaryDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryPrimaryDefaultContext {
	var p = new(QueryPrimaryDefaultContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *QueryPrimaryDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryDefaultContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *QueryPrimaryDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterQueryPrimaryDefault(s)
	}
}

func (s *QueryPrimaryDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitQueryPrimaryDefault(s)
	}
}

func (s *QueryPrimaryDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitQueryPrimaryDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) QueryPrimary() (localctx IQueryPrimaryContext) {
	return p.queryPrimary(0)
}

func (p *DorisSQLParserParser) queryPrimary(_p int) (localctx IQueryPrimaryContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewQueryPrimaryContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IQueryPrimaryContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 764
	p.EnterRecursionRule(localctx, 764, DorisSQLParserParserRULE_queryPrimary, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6009)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserSELECT:
		localctx = NewQueryPrimaryDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(6007)
			p.QuerySpecification()
		}

	case DorisSQLParserParserT__1:
		localctx = NewQueryWithParenthesesContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6008)
			p.Subquery()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(6025)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 671, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(6023)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 670, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSetOperationContext(p, NewQueryPrimaryContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserParserRULE_queryPrimary)
				p.SetState(6011)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(6012)

					var _m = p.Match(DorisSQLParserParserINTERSECT)

					localctx.(*SetOperationContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(6014)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisSQLParserParserALL || _la == DorisSQLParserParserDISTINCT {
					{
						p.SetState(6013)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(6016)

					var _x = p.queryPrimary(3)

					localctx.(*SetOperationContext).right = _x
				}

			case 2:
				localctx = NewSetOperationContext(p, NewQueryPrimaryContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserParserRULE_queryPrimary)
				p.SetState(6017)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(6018)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*SetOperationContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisSQLParserParserEXCEPT || _la == DorisSQLParserParserMINUS || _la == DorisSQLParserParserUNION) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*SetOperationContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(6020)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisSQLParserParserALL || _la == DorisSQLParserParserDISTINCT {
					{
						p.SetState(6019)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(6022)

					var _x = p.queryPrimary(2)

					localctx.(*SetOperationContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(6027)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 671, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubqueryContext is an interface to support dynamic dispatch.
type ISubqueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryRelation() IQueryRelationContext

	// IsSubqueryContext differentiates from other interfaces.
	IsSubqueryContext()
}

type SubqueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubqueryContext() *SubqueryContext {
	var p = new(SubqueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_subquery
	return p
}

func InitEmptySubqueryContext(p *SubqueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_subquery
}

func (*SubqueryContext) IsSubqueryContext() {}

func NewSubqueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubqueryContext {
	var p = new(SubqueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_subquery

	return p
}

func (s *SubqueryContext) GetParser() antlr.Parser { return s.parser }

func (s *SubqueryContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSubquery(s)
	}
}

func (s *SubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSubquery(s)
	}
}

func (s *SubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Subquery() (localctx ISubqueryContext) {
	localctx = NewSubqueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 766, DorisSQLParserParserRULE_subquery)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6028)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6029)
		p.QueryRelation()
	}
	{
		p.SetState(6030)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowConstructorContext is an interface to support dynamic dispatch.
type IRowConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionList() IExpressionListContext

	// IsRowConstructorContext differentiates from other interfaces.
	IsRowConstructorContext()
}

type RowConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowConstructorContext() *RowConstructorContext {
	var p = new(RowConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_rowConstructor
	return p
}

func InitEmptyRowConstructorContext(p *RowConstructorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_rowConstructor
}

func (*RowConstructorContext) IsRowConstructorContext() {}

func NewRowConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowConstructorContext {
	var p = new(RowConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_rowConstructor

	return p
}

func (s *RowConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *RowConstructorContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *RowConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRowConstructor(s)
	}
}

func (s *RowConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRowConstructor(s)
	}
}

func (s *RowConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRowConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) RowConstructor() (localctx IRowConstructorContext) {
	localctx = NewRowConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 768, DorisSQLParserParserRULE_rowConstructor)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6032)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6033)
		p.ExpressionList()
	}
	{
		p.SetState(6034)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortItemContext is an interface to support dynamic dispatch.
type ISortItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrdering returns the ordering token.
	GetOrdering() antlr.Token

	// GetNullOrdering returns the nullOrdering token.
	GetNullOrdering() antlr.Token

	// SetOrdering sets the ordering token.
	SetOrdering(antlr.Token)

	// SetNullOrdering sets the nullOrdering token.
	SetNullOrdering(antlr.Token)

	// Getter signatures
	Expression() IExpressionContext
	NULLS() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode

	// IsSortItemContext differentiates from other interfaces.
	IsSortItemContext()
}

type SortItemContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	ordering     antlr.Token
	nullOrdering antlr.Token
}

func NewEmptySortItemContext() *SortItemContext {
	var p = new(SortItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_sortItem
	return p
}

func InitEmptySortItemContext(p *SortItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_sortItem
}

func (*SortItemContext) IsSortItemContext() {}

func NewSortItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortItemContext {
	var p = new(SortItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_sortItem

	return p
}

func (s *SortItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SortItemContext) GetOrdering() antlr.Token { return s.ordering }

func (s *SortItemContext) GetNullOrdering() antlr.Token { return s.nullOrdering }

func (s *SortItemContext) SetOrdering(v antlr.Token) { s.ordering = v }

func (s *SortItemContext) SetNullOrdering(v antlr.Token) { s.nullOrdering = v }

func (s *SortItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SortItemContext) NULLS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNULLS, 0)
}

func (s *SortItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserASC, 0)
}

func (s *SortItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDESC, 0)
}

func (s *SortItemContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFIRST, 0)
}

func (s *SortItemContext) LAST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLAST, 0)
}

func (s *SortItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSortItem(s)
	}
}

func (s *SortItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSortItem(s)
	}
}

func (s *SortItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSortItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SortItem() (localctx ISortItemContext) {
	localctx = NewSortItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 770, DorisSQLParserParserRULE_sortItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6036)
		p.expression(0)
	}
	p.SetState(6038)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserASC || _la == DorisSQLParserParserDESC {
		{
			p.SetState(6037)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).ordering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserASC || _la == DorisSQLParserParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).ordering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(6042)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserNULLS {
		{
			p.SetState(6040)
			p.Match(DorisSQLParserParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6041)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).nullOrdering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserFIRST || _la == DorisSQLParserParserLAST) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).nullOrdering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitConstExprContext is an interface to support dynamic dispatch.
type ILimitConstExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER_VALUE() antlr.TerminalNode
	PARAMETER() antlr.TerminalNode
	UserVariable() IUserVariableContext

	// IsLimitConstExprContext differentiates from other interfaces.
	IsLimitConstExprContext()
}

type LimitConstExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitConstExprContext() *LimitConstExprContext {
	var p = new(LimitConstExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_limitConstExpr
	return p
}

func InitEmptyLimitConstExprContext(p *LimitConstExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_limitConstExpr
}

func (*LimitConstExprContext) IsLimitConstExprContext() {}

func NewLimitConstExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitConstExprContext {
	var p = new(LimitConstExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_limitConstExpr

	return p
}

func (s *LimitConstExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitConstExprContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, 0)
}

func (s *LimitConstExprContext) PARAMETER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPARAMETER, 0)
}

func (s *LimitConstExprContext) UserVariable() IUserVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariableContext)
}

func (s *LimitConstExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitConstExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitConstExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterLimitConstExpr(s)
	}
}

func (s *LimitConstExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitLimitConstExpr(s)
	}
}

func (s *LimitConstExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitLimitConstExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) LimitConstExpr() (localctx ILimitConstExprContext) {
	localctx = NewLimitConstExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 772, DorisSQLParserParserRULE_limitConstExpr)
	p.SetState(6047)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserINTEGER_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6044)
			p.Match(DorisSQLParserParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserPARAMETER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6045)
			p.Match(DorisSQLParserParserPARAMETER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserAT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6046)
			p.UserVariable()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitElementContext is an interface to support dynamic dispatch.
type ILimitElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit rule contexts.
	GetLimit() ILimitConstExprContext

	// GetOffset returns the offset rule contexts.
	GetOffset() ILimitConstExprContext

	// SetLimit sets the limit rule contexts.
	SetLimit(ILimitConstExprContext)

	// SetOffset sets the offset rule contexts.
	SetOffset(ILimitConstExprContext)

	// Getter signatures
	LIMIT() antlr.TerminalNode
	AllLimitConstExpr() []ILimitConstExprContext
	LimitConstExpr(i int) ILimitConstExprContext
	OFFSET() antlr.TerminalNode

	// IsLimitElementContext differentiates from other interfaces.
	IsLimitElementContext()
}

type LimitElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	limit  ILimitConstExprContext
	offset ILimitConstExprContext
}

func NewEmptyLimitElementContext() *LimitElementContext {
	var p = new(LimitElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_limitElement
	return p
}

func InitEmptyLimitElementContext(p *LimitElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_limitElement
}

func (*LimitElementContext) IsLimitElementContext() {}

func NewLimitElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitElementContext {
	var p = new(LimitElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_limitElement

	return p
}

func (s *LimitElementContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitElementContext) GetLimit() ILimitConstExprContext { return s.limit }

func (s *LimitElementContext) GetOffset() ILimitConstExprContext { return s.offset }

func (s *LimitElementContext) SetLimit(v ILimitConstExprContext) { s.limit = v }

func (s *LimitElementContext) SetOffset(v ILimitConstExprContext) { s.offset = v }

func (s *LimitElementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIMIT, 0)
}

func (s *LimitElementContext) AllLimitConstExpr() []ILimitConstExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILimitConstExprContext); ok {
			len++
		}
	}

	tst := make([]ILimitConstExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILimitConstExprContext); ok {
			tst[i] = t.(ILimitConstExprContext)
			i++
		}
	}

	return tst
}

func (s *LimitElementContext) LimitConstExpr(i int) ILimitConstExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitConstExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitConstExprContext)
}

func (s *LimitElementContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOFFSET, 0)
}

func (s *LimitElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterLimitElement(s)
	}
}

func (s *LimitElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitLimitElement(s)
	}
}

func (s *LimitElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitLimitElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) LimitElement() (localctx ILimitElementContext) {
	localctx = NewLimitElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 774, DorisSQLParserParserRULE_limitElement)
	var _la int

	p.SetState(6060)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 676, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6049)
			p.Match(DorisSQLParserParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6050)

			var _x = p.LimitConstExpr()

			localctx.(*LimitElementContext).limit = _x
		}
		p.SetState(6053)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserOFFSET {
			{
				p.SetState(6051)
				p.Match(DorisSQLParserParserOFFSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6052)

				var _x = p.LimitConstExpr()

				localctx.(*LimitElementContext).offset = _x
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6055)
			p.Match(DorisSQLParserParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6056)

			var _x = p.LimitConstExpr()

			localctx.(*LimitElementContext).offset = _x
		}
		{
			p.SetState(6057)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6058)

			var _x = p.LimitConstExpr()

			localctx.(*LimitElementContext).limit = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// GetHaving returns the having rule contexts.
	GetHaving() IExpressionContext

	// GetQualifyFunction returns the qualifyFunction rule contexts.
	GetQualifyFunction() ISelectItemContext

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// SetHaving sets the having rule contexts.
	SetHaving(IExpressionContext)

	// SetQualifyFunction sets the qualifyFunction rule contexts.
	SetQualifyFunction(ISelectItemContext)

	// Getter signatures
	SELECT() antlr.TerminalNode
	AllSelectItem() []ISelectItemContext
	SelectItem(i int) ISelectItemContext
	FromClause() IFromClauseContext
	SetQuantifier() ISetQuantifierContext
	WHERE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	GroupingElement() IGroupingElementContext
	HAVING() antlr.TerminalNode
	QUALIFY() antlr.TerminalNode
	ComparisonOperator() IComparisonOperatorContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	INTEGER_VALUE() antlr.TerminalNode

	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	where           IExpressionContext
	having          IExpressionContext
	qualifyFunction ISelectItemContext
	limit           antlr.Token
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_querySpecification
	return p
}

func InitEmptyQuerySpecificationContext(p *QuerySpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_querySpecification
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) GetLimit() antlr.Token { return s.limit }

func (s *QuerySpecificationContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *QuerySpecificationContext) GetWhere() IExpressionContext { return s.where }

func (s *QuerySpecificationContext) GetHaving() IExpressionContext { return s.having }

func (s *QuerySpecificationContext) GetQualifyFunction() ISelectItemContext { return s.qualifyFunction }

func (s *QuerySpecificationContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *QuerySpecificationContext) SetHaving(v IExpressionContext) { s.having = v }

func (s *QuerySpecificationContext) SetQualifyFunction(v ISelectItemContext) { s.qualifyFunction = v }

func (s *QuerySpecificationContext) SELECT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSELECT, 0)
}

func (s *QuerySpecificationContext) AllSelectItem() []ISelectItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectItemContext); ok {
			len++
		}
	}

	tst := make([]ISelectItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectItemContext); ok {
			tst[i] = t.(ISelectItemContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationContext) SelectItem(i int) ISelectItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectItemContext)
}

func (s *QuerySpecificationContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *QuerySpecificationContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *QuerySpecificationContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHERE, 0)
}

func (s *QuerySpecificationContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGROUP, 0)
}

func (s *QuerySpecificationContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *QuerySpecificationContext) GroupingElement() IGroupingElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingElementContext)
}

func (s *QuerySpecificationContext) HAVING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserHAVING, 0)
}

func (s *QuerySpecificationContext) QUALIFY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserQUALIFY, 0)
}

func (s *QuerySpecificationContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *QuerySpecificationContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *QuerySpecificationContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, 0)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitQuerySpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 776, DorisSQLParserParserRULE_querySpecification)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6062)
		p.Match(DorisSQLParserParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6064)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserALL || _la == DorisSQLParserParserDISTINCT {
		{
			p.SetState(6063)
			p.SetQuantifier()
		}

	}
	{
		p.SetState(6066)
		p.SelectItem()
	}
	p.SetState(6071)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 678, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6067)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6068)
				p.SelectItem()
			}

		}
		p.SetState(6073)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 678, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(6074)
		p.FromClause()
	}

	p.SetState(6077)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 679, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6075)
			p.Match(DorisSQLParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6076)

			var _x = p.expression(0)

			localctx.(*QuerySpecificationContext).where = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(6082)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 680, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6079)
			p.Match(DorisSQLParserParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6080)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6081)
			p.GroupingElement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(6086)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 681, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6084)
			p.Match(DorisSQLParserParserHAVING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6085)

			var _x = p.expression(0)

			localctx.(*QuerySpecificationContext).having = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(6093)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 682, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6088)
			p.Match(DorisSQLParserParserQUALIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6089)

			var _x = p.SelectItem()

			localctx.(*QuerySpecificationContext).qualifyFunction = _x
		}
		{
			p.SetState(6090)
			p.ComparisonOperator()
		}
		{
			p.SetState(6091)

			var _m = p.Match(DorisSQLParserParserINTEGER_VALUE)

			localctx.(*QuerySpecificationContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_fromClause
	return p
}

func InitEmptyFromClauseContext(p *FromClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_fromClause
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) CopyAll(ctx *FromClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DualContext struct {
	FromClauseContext
}

func NewDualContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DualContext {
	var p = new(DualContext)

	InitEmptyFromClauseContext(&p.FromClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*FromClauseContext))

	return p
}

func (s *DualContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DualContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *DualContext) DUAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDUAL, 0)
}

func (s *DualContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDual(s)
	}
}

func (s *DualContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDual(s)
	}
}

func (s *DualContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDual(s)

	default:
		return t.VisitChildren(s)
	}
}

type FromContext struct {
	FromClauseContext
}

func NewFromContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FromContext {
	var p = new(FromContext)

	InitEmptyFromClauseContext(&p.FromClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*FromClauseContext))

	return p
}

func (s *FromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *FromContext) Relations() IRelationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationsContext)
}

func (s *FromContext) PivotClause() IPivotClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivotClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivotClauseContext)
}

func (s *FromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterFrom(s)
	}
}

func (s *FromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitFrom(s)
	}
}

func (s *FromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitFrom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) FromClause() (localctx IFromClauseContext) {
	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 778, DorisSQLParserParserRULE_fromClause)
	p.SetState(6104)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 685, p.GetParserRuleContext()) {
	case 1:
		localctx = NewFromContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6100)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 684, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6095)
				p.Match(DorisSQLParserParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6096)
				p.Relations()
			}
			p.SetState(6098)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 683, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6097)
					p.PivotClause()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewDualContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6102)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6103)
			p.Match(DorisSQLParserParserDUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingElementContext is an interface to support dynamic dispatch.
type IGroupingElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsGroupingElementContext differentiates from other interfaces.
	IsGroupingElementContext()
}

type GroupingElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingElementContext() *GroupingElementContext {
	var p = new(GroupingElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_groupingElement
	return p
}

func InitEmptyGroupingElementContext(p *GroupingElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_groupingElement
}

func (*GroupingElementContext) IsGroupingElementContext() {}

func NewGroupingElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingElementContext {
	var p = new(GroupingElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_groupingElement

	return p
}

func (s *GroupingElementContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingElementContext) CopyAll(ctx *GroupingElementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *GroupingElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type MultipleGroupingSetsContext struct {
	GroupingElementContext
}

func NewMultipleGroupingSetsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultipleGroupingSetsContext {
	var p = new(MultipleGroupingSetsContext)

	InitEmptyGroupingElementContext(&p.GroupingElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingElementContext))

	return p
}

func (s *MultipleGroupingSetsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleGroupingSetsContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGROUPING, 0)
}

func (s *MultipleGroupingSetsContext) SETS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSETS, 0)
}

func (s *MultipleGroupingSetsContext) AllGroupingSet() []IGroupingSetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupingSetContext); ok {
			len++
		}
	}

	tst := make([]IGroupingSetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupingSetContext); ok {
			tst[i] = t.(IGroupingSetContext)
			i++
		}
	}

	return tst
}

func (s *MultipleGroupingSetsContext) GroupingSet(i int) IGroupingSetContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingSetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *MultipleGroupingSetsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterMultipleGroupingSets(s)
	}
}

func (s *MultipleGroupingSetsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitMultipleGroupingSets(s)
	}
}

func (s *MultipleGroupingSetsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitMultipleGroupingSets(s)

	default:
		return t.VisitChildren(s)
	}
}

type SingleGroupingSetContext struct {
	GroupingElementContext
}

func NewSingleGroupingSetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SingleGroupingSetContext {
	var p = new(SingleGroupingSetContext)

	InitEmptyGroupingElementContext(&p.GroupingElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingElementContext))

	return p
}

func (s *SingleGroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleGroupingSetContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *SingleGroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSingleGroupingSet(s)
	}
}

func (s *SingleGroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSingleGroupingSet(s)
	}
}

func (s *SingleGroupingSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSingleGroupingSet(s)

	default:
		return t.VisitChildren(s)
	}
}

type CubeContext struct {
	GroupingElementContext
}

func NewCubeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CubeContext {
	var p = new(CubeContext)

	InitEmptyGroupingElementContext(&p.GroupingElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingElementContext))

	return p
}

func (s *CubeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CubeContext) CUBE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCUBE, 0)
}

func (s *CubeContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *CubeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCube(s)
	}
}

func (s *CubeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCube(s)
	}
}

func (s *CubeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCube(s)

	default:
		return t.VisitChildren(s)
	}
}

type RollupContext struct {
	GroupingElementContext
}

func NewRollupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RollupContext {
	var p = new(RollupContext)

	InitEmptyGroupingElementContext(&p.GroupingElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingElementContext))

	return p
}

func (s *RollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROLLUP, 0)
}

func (s *RollupContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *RollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRollup(s)
	}
}

func (s *RollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRollup(s)
	}
}

func (s *RollupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRollup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) GroupingElement() (localctx IGroupingElementContext) {
	localctx = NewGroupingElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 780, DorisSQLParserParserRULE_groupingElement)
	var _la int

	p.SetState(6132)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 689, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRollupContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6106)
			p.Match(DorisSQLParserParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6107)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6109)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(6108)
				p.ExpressionList()
			}

		}
		{
			p.SetState(6111)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewCubeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6112)
			p.Match(DorisSQLParserParserCUBE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6113)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6115)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(6114)
				p.ExpressionList()
			}

		}
		{
			p.SetState(6117)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewMultipleGroupingSetsContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6118)
			p.Match(DorisSQLParserParserGROUPING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6119)
			p.Match(DorisSQLParserParserSETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6120)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6121)
			p.GroupingSet()
		}
		p.SetState(6126)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(6122)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6123)
				p.GroupingSet()
			}

			p.SetState(6128)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6129)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewSingleGroupingSetContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6131)
			p.ExpressionList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingSetContext is an interface to support dynamic dispatch.
type IGroupingSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsGroupingSetContext differentiates from other interfaces.
	IsGroupingSetContext()
}

type GroupingSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingSetContext() *GroupingSetContext {
	var p = new(GroupingSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_groupingSet
	return p
}

func InitEmptyGroupingSetContext(p *GroupingSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_groupingSet
}

func (*GroupingSetContext) IsGroupingSetContext() {}

func NewGroupingSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingSetContext {
	var p = new(GroupingSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_groupingSet

	return p
}

func (s *GroupingSetContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingSetContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupingSetContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterGroupingSet(s)
	}
}

func (s *GroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitGroupingSet(s)
	}
}

func (s *GroupingSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitGroupingSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) GroupingSet() (localctx IGroupingSetContext) {
	localctx = NewGroupingSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 782, DorisSQLParserParserRULE_groupingSet)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6134)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6136)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
		{
			p.SetState(6135)
			p.expression(0)
		}

	}
	p.SetState(6142)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(6138)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6139)
			p.expression(0)
		}

		p.SetState(6144)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6145)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommonTableExpressionContext is an interface to support dynamic dispatch.
type ICommonTableExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	AS() antlr.TerminalNode
	QueryRelation() IQueryRelationContext
	Identifier() IIdentifierContext
	ColumnAliases() IColumnAliasesContext

	// IsCommonTableExpressionContext differentiates from other interfaces.
	IsCommonTableExpressionContext()
}

type CommonTableExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyCommonTableExpressionContext() *CommonTableExpressionContext {
	var p = new(CommonTableExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_commonTableExpression
	return p
}

func InitEmptyCommonTableExpressionContext(p *CommonTableExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_commonTableExpression
}

func (*CommonTableExpressionContext) IsCommonTableExpressionContext() {}

func NewCommonTableExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommonTableExpressionContext {
	var p = new(CommonTableExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_commonTableExpression

	return p
}

func (s *CommonTableExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CommonTableExpressionContext) GetName() IIdentifierContext { return s.name }

func (s *CommonTableExpressionContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CommonTableExpressionContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *CommonTableExpressionContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *CommonTableExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CommonTableExpressionContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *CommonTableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommonTableExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommonTableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCommonTableExpression(s)
	}
}

func (s *CommonTableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCommonTableExpression(s)
	}
}

func (s *CommonTableExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCommonTableExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CommonTableExpression() (localctx ICommonTableExpressionContext) {
	localctx = NewCommonTableExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 784, DorisSQLParserParserRULE_commonTableExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6147)

		var _x = p.Identifier()

		localctx.(*CommonTableExpressionContext).name = _x
	}
	p.SetState(6149)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserT__1 {
		{
			p.SetState(6148)
			p.ColumnAliases()
		}

	}
	{
		p.SetState(6151)
		p.Match(DorisSQLParserParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6152)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6153)
		p.QueryRelation()
	}
	{
		p.SetState(6154)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetQuantifierContext is an interface to support dynamic dispatch.
type ISetQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTINCT() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsSetQuantifierContext differentiates from other interfaces.
	IsSetQuantifierContext()
}

type SetQuantifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetQuantifierContext() *SetQuantifierContext {
	var p = new(SetQuantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_setQuantifier
	return p
}

func InitEmptySetQuantifierContext(p *SetQuantifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_setQuantifier
}

func (*SetQuantifierContext) IsSetQuantifierContext() {}

func NewSetQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetQuantifierContext {
	var p = new(SetQuantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_setQuantifier

	return p
}

func (s *SetQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SetQuantifierContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDISTINCT, 0)
}

func (s *SetQuantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, 0)
}

func (s *SetQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSetQuantifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SetQuantifier() (localctx ISetQuantifierContext) {
	localctx = NewSetQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 786, DorisSQLParserParserRULE_setQuantifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6156)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserALL || _la == DorisSQLParserParserDISTINCT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectItemContext is an interface to support dynamic dispatch.
type ISelectItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSelectItemContext differentiates from other interfaces.
	IsSelectItemContext()
}

type SelectItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectItemContext() *SelectItemContext {
	var p = new(SelectItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_selectItem
	return p
}

func InitEmptySelectItemContext(p *SelectItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_selectItem
}

func (*SelectItemContext) IsSelectItemContext() {}

func NewSelectItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectItemContext {
	var p = new(SelectItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_selectItem

	return p
}

func (s *SelectItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectItemContext) CopyAll(ctx *SelectItemContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SelectItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectAllContext struct {
	SelectItemContext
}

func NewSelectAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectAllContext {
	var p = new(SelectAllContext)

	InitEmptySelectItemContext(&p.SelectItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectItemContext))

	return p
}

func (s *SelectAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectAllContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SelectAllContext) ASTERISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserASTERISK_SYMBOL, 0)
}

func (s *SelectAllContext) ExcludeClause() IExcludeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExcludeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExcludeClauseContext)
}

func (s *SelectAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSelectAll(s)
	}
}

func (s *SelectAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSelectAll(s)
	}
}

func (s *SelectAllContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSelectAll(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectSingleContext struct {
	SelectItemContext
}

func NewSelectSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectSingleContext {
	var p = new(SelectSingleContext)

	InitEmptySelectItemContext(&p.SelectItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectItemContext))

	return p
}

func (s *SelectSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectSingleContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectSingleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SelectSingleContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *SelectSingleContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *SelectSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSelectSingle(s)
	}
}

func (s *SelectSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSelectSingle(s)
	}
}

func (s *SelectSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSelectSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SelectItem() (localctx ISelectItemContext) {
	localctx = NewSelectItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 788, DorisSQLParserParserRULE_selectItem)
	var _la int

	p.SetState(6178)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 698, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6158)
			p.expression(0)
		}
		p.SetState(6166)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 695, p.GetParserRuleContext()) == 1 {
			p.SetState(6160)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserParserAS {
				{
					p.SetState(6159)
					p.Match(DorisSQLParserParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(6164)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisSQLParserParserACCESS, DorisSQLParserParserACTIVE, DorisSQLParserParserADMIN, DorisSQLParserParserADVISOR, DorisSQLParserParserAFTER, DorisSQLParserParserAGGREGATE, DorisSQLParserParserANTI, DorisSQLParserParserAPPLY, DorisSQLParserParserARRAY_AGG, DorisSQLParserParserARRAY_AGG_DISTINCT, DorisSQLParserParserASYNC, DorisSQLParserParserAUTHORS, DorisSQLParserParserAUTHENTICATION, DorisSQLParserParserAUTOMATED, DorisSQLParserParserAUTO_INCREMENT, DorisSQLParserParserAVG, DorisSQLParserParserBACKEND, DorisSQLParserParserBACKENDS, DorisSQLParserParserBACKUP, DorisSQLParserParserBASE, DorisSQLParserParserBASELINE, DorisSQLParserParserBEGIN, DorisSQLParserParserBINARY, DorisSQLParserParserBITMAP_UNION, DorisSQLParserParserBLACKHOLE, DorisSQLParserParserBLACKLIST, DorisSQLParserParserBODY, DorisSQLParserParserBOOLEAN, DorisSQLParserParserBRANCH, DorisSQLParserParserBROKER, DorisSQLParserParserBUCKETS, DorisSQLParserParserBUILTIN, DorisSQLParserParserCACHE, DorisSQLParserParserCANCEL, DorisSQLParserParserCAST, DorisSQLParserParserCATALOG, DorisSQLParserParserCATALOGS, DorisSQLParserParserCEIL, DorisSQLParserParserCHAIN, DorisSQLParserParserCHARSET, DorisSQLParserParserCLEAN, DorisSQLParserParserCLEAR, DorisSQLParserParserCLUSTER, DorisSQLParserParserCLUSTERS, DorisSQLParserParserCNGROUP, DorisSQLParserParserCNGROUPS, DorisSQLParserParserCOLLATION, DorisSQLParserParserCOLUMNS, DorisSQLParserParserCOMMENT, DorisSQLParserParserCOMMIT, DorisSQLParserParserCOMMITTED, DorisSQLParserParserCOMPACT, DorisSQLParserParserCOMPUTE, DorisSQLParserParserCONFIG, DorisSQLParserParserCONNECTION, DorisSQLParserParserCONSISTENT, DorisSQLParserParserCOSTS, DorisSQLParserParserCOUNT, DorisSQLParserParserCUME_DIST, DorisSQLParserParserCUMULATIVE, DorisSQLParserParserCURRENT, DorisSQLParserParserDATA, DorisSQLParserParserDATACACHE, DorisSQLParserParserDATE, DorisSQLParserParserDATETIME, DorisSQLParserParserDAY, DorisSQLParserParserDAYS, DorisSQLParserParserDEALLOCATE, DorisSQLParserParserDECOMMISSION, DorisSQLParserParserDIALECT, DorisSQLParserParserDICTIONARY, DorisSQLParserParserDICTIONARY_GET, DorisSQLParserParserDISABLE, DorisSQLParserParserDISTRIBUTED, DorisSQLParserParserDISTRIBUTION, DorisSQLParserParserDUPLICATE, DorisSQLParserParserDYNAMIC, DorisSQLParserParserENABLE, DorisSQLParserParserENCLOSE, DorisSQLParserParserEND, DorisSQLParserParserENGINE, DorisSQLParserParserENGINES, DorisSQLParserParserERRORS, DorisSQLParserParserESCAPE, DorisSQLParserParserEVENTS, DorisSQLParserParserEXCEPT, DorisSQLParserParserEXCLUDE, DorisSQLParserParserEXECUTE, DorisSQLParserParserEXPORT, DorisSQLParserParserEXTERNAL, DorisSQLParserParserEXTRACT, DorisSQLParserParserEVERY, DorisSQLParserParserFAILPOINT, DorisSQLParserParserFAILPOINTS, DorisSQLParserParserFIELDS, DorisSQLParserParserFILE, DorisSQLParserParserFILTER, DorisSQLParserParserFIRST, DorisSQLParserParserFLOOR, DorisSQLParserParserFN, DorisSQLParserParserFOLLOWING, DorisSQLParserParserFOLLOWER, DorisSQLParserParserFORMAT, DorisSQLParserParserFREE, DorisSQLParserParserFRONTEND, DorisSQLParserParserFRONTENDS, DorisSQLParserParserFUNCTIONS, DorisSQLParserParserGLOBAL, DorisSQLParserParserGRANTS, DorisSQLParserParserGROUP_CONCAT, DorisSQLParserParserHASH, DorisSQLParserParserHELP, DorisSQLParserParserHISTOGRAM, DorisSQLParserParserHLL_UNION, DorisSQLParserParserHOST, DorisSQLParserParserHOUR, DorisSQLParserParserHOURS, DorisSQLParserParserHUB, DorisSQLParserParserIDENTIFIED, DorisSQLParserParserIMPERSONATE, DorisSQLParserParserIMAGE, DorisSQLParserParserINACTIVE, DorisSQLParserParserINCREMENTAL, DorisSQLParserParserINDEXES, DorisSQLParserParserINSTALL, DorisSQLParserParserINTEGRATION, DorisSQLParserParserINTEGRATIONS, DorisSQLParserParserINTERMEDIATE, DorisSQLParserParserINTERVAL, DorisSQLParserParserOVERWRITE, DorisSQLParserParserISOLATION, DorisSQLParserParserJOB, DorisSQLParserParserLABEL, DorisSQLParserParserLAST, DorisSQLParserParserLESS, DorisSQLParserParserLEVEL, DorisSQLParserParserLIST, DorisSQLParserParserLOCAL, DorisSQLParserParserLOCATION, DorisSQLParserParserLOCATIONS, DorisSQLParserParserLOGS, DorisSQLParserParserLOGICAL, DorisSQLParserParserMANUAL, DorisSQLParserParserMAP, DorisSQLParserParserMAPPING, DorisSQLParserParserMAPPINGS, DorisSQLParserParserMASKING, DorisSQLParserParserMATCH, DorisSQLParserParserMATERIALIZED, DorisSQLParserParserMAX, DorisSQLParserParserMERGE, DorisSQLParserParserMIN, DorisSQLParserParserMINUTE, DorisSQLParserParserMINUTES, DorisSQLParserParserMINUS, DorisSQLParserParserMETA, DorisSQLParserParserMODE, DorisSQLParserParserMODIFY, DorisSQLParserParserMONTH, DorisSQLParserParserMULTIPLE, DorisSQLParserParserNAME, DorisSQLParserParserNAMES, DorisSQLParserParserNEGATIVE, DorisSQLParserParserNGRAMBF, DorisSQLParserParserNO, DorisSQLParserParserNODE, DorisSQLParserParserNODES, DorisSQLParserParserNONE, DorisSQLParserParserNULLS, DorisSQLParserParserNUMBER, DorisSQLParserParserNUMERIC, DorisSQLParserParserOBSERVER, DorisSQLParserParserOF, DorisSQLParserParserOFF, DorisSQLParserParserOFFSET, DorisSQLParserParserONLY, DorisSQLParserParserOPEN, DorisSQLParserParserOPERATE, DorisSQLParserParserOPTIMIZER, DorisSQLParserParserOPTION, DorisSQLParserParserPARTITIONS, DorisSQLParserParserPASSWORD, DorisSQLParserParserPATH, DorisSQLParserParserPAUSE, DorisSQLParserParserPENDING, DorisSQLParserParserPERCENT_RANK, DorisSQLParserParserPERCENTILE_UNION, DorisSQLParserParserPLAN, DorisSQLParserParserPLUGIN, DorisSQLParserParserPLUGINS, DorisSQLParserParserPIPE, DorisSQLParserParserPIPES, DorisSQLParserParserPIVOT, DorisSQLParserParserPOLICY, DorisSQLParserParserPOLICIES, DorisSQLParserParserPRECEDING, DorisSQLParserParserPREDICATE, DorisSQLParserParserPRIORITY, DorisSQLParserParserPRIVILEGES, DorisSQLParserParserPROBABILITY, DorisSQLParserParserPROC, DorisSQLParserParserPROCESSLIST, DorisSQLParserParserPROFILE, DorisSQLParserParserPROFILELIST, DorisSQLParserParserPROPERTIES, DorisSQLParserParserPROPERTY, DorisSQLParserParserPROVIDER, DorisSQLParserParserPROVIDERS, DorisSQLParserParserQUALIFY, DorisSQLParserParserQUARTER, DorisSQLParserParserQUERY, DorisSQLParserParserQUERIES, DorisSQLParserParserQUEUE, DorisSQLParserParserQUOTA, DorisSQLParserParserRANDOM, DorisSQLParserParserRANK, DorisSQLParserParserREASON, DorisSQLParserParserRECOVER, DorisSQLParserParserREFRESH, DorisSQLParserParserREWRITE, DorisSQLParserParserREMOVE, DorisSQLParserParserREPAIR, DorisSQLParserParserREPEATABLE, DorisSQLParserParserREPLACE_IF_NOT_NULL, DorisSQLParserParserREPLICA, DorisSQLParserParserREPOSITORY, DorisSQLParserParserREPOSITORIES, DorisSQLParserParserRESOURCE, DorisSQLParserParserRESOURCES, DorisSQLParserParserRESTORE, DorisSQLParserParserRESUME, DorisSQLParserParserRETAIN, DorisSQLParserParserRETENTION, DorisSQLParserParserRETURNS, DorisSQLParserParserRETRY, DorisSQLParserParserREVERT, DorisSQLParserParserROLE, DorisSQLParserParserROLES, DorisSQLParserParserROLLBACK, DorisSQLParserParserROLLUP, DorisSQLParserParserROUTINE, DorisSQLParserParserROW, DorisSQLParserParserRULE, DorisSQLParserParserRULES, DorisSQLParserParserRUNNING, DorisSQLParserParserSAMPLE, DorisSQLParserParserSCHEDULE, DorisSQLParserParserSCHEDULER, DorisSQLParserParserSECOND, DorisSQLParserParserSECURITY, DorisSQLParserParserSEMI, DorisSQLParserParserSEPARATOR, DorisSQLParserParserSERIALIZABLE, DorisSQLParserParserSESSION, DorisSQLParserParserSETS, DorisSQLParserParserSIGNED, DorisSQLParserParserSKIP_HEADER, DorisSQLParserParserSNAPSHOT, DorisSQLParserParserSNAPSHOTS, DorisSQLParserParserSQLBLACKLIST, DorisSQLParserParserSTART, DorisSQLParserParserSTATS, DorisSQLParserParserSTATUS, DorisSQLParserParserSTOP, DorisSQLParserParserSTORAGE, DorisSQLParserParserSTREAM, DorisSQLParserParserSTRING, DorisSQLParserParserSUBMIT, DorisSQLParserParserSUM, DorisSQLParserParserSUSPEND, DorisSQLParserParserSYNC, DorisSQLParserParserSYSTEM_TIME, DorisSQLParserParserSWAP, DorisSQLParserParserSTRUCT, DorisSQLParserParserTABLES, DorisSQLParserParserTABLET, DorisSQLParserParserTABLETS, DorisSQLParserParserTAG, DorisSQLParserParserTASK, DorisSQLParserParserTEMPORARY, DorisSQLParserParserTHAN, DorisSQLParserParserTIME, DorisSQLParserParserTIMES, DorisSQLParserParserTIMESTAMP, DorisSQLParserParserTIMESTAMPADD, DorisSQLParserParserTIMESTAMPDIFF, DorisSQLParserParserTRANSACTION, DorisSQLParserParserTRANSLATE, DorisSQLParserParserTRACE, DorisSQLParserParserTRIGGERS, DorisSQLParserParserTRIM_SPACE, DorisSQLParserParserTRUNCATE, DorisSQLParserParserTYPE, DorisSQLParserParserTYPES, DorisSQLParserParserUNBOUNDED, DorisSQLParserParserUNCOMMITTED, DorisSQLParserParserUNINSTALL, DorisSQLParserParserUNSET, DorisSQLParserParserUSAGE, DorisSQLParserParserUSER, DorisSQLParserParserUSERS, DorisSQLParserParserVALUE, DorisSQLParserParserVARBINARY, DorisSQLParserParserVARIABLES, DorisSQLParserParserVECTOR, DorisSQLParserParserVERBOSE, DorisSQLParserParserVERSION, DorisSQLParserParserVIEW, DorisSQLParserParserVIEWS, DorisSQLParserParserVOLUME, DorisSQLParserParserVOLUMES, DorisSQLParserParserWAREHOUSE, DorisSQLParserParserWAREHOUSES, DorisSQLParserParserWARNINGS, DorisSQLParserParserWEEK, DorisSQLParserParserWHITELIST, DorisSQLParserParserWORK, DorisSQLParserParserWRITE, DorisSQLParserParserYEAR, DorisSQLParserParserLOCK, DorisSQLParserParserUNLOCK, DorisSQLParserParserLOW_PRIORITY, DorisSQLParserParserDISK, DorisSQLParserParserBEFORE, DorisSQLParserParserFIELD, DorisSQLParserParserPERSISTENT, DorisSQLParserParserARRAY_ELEMENT, DorisSQLParserParserLETTER_IDENTIFIER, DorisSQLParserParserDIGIT_IDENTIFIER, DorisSQLParserParserBACKQUOTED_IDENTIFIER, DorisSQLParserParserDOTDOTDOT:
				{
					p.SetState(6162)
					p.Identifier()
				}

			case DorisSQLParserParserSINGLE_QUOTED_TEXT, DorisSQLParserParserDOUBLE_QUOTED_TEXT:
				{
					p.SetState(6163)
					p.String_()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6168)
			p.QualifiedName()
		}
		{
			p.SetState(6169)
			p.Match(DorisSQLParserParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6170)
			p.Match(DorisSQLParserParserASTERISK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6172)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 696, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6171)
				p.ExcludeClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6174)
			p.Match(DorisSQLParserParserASTERISK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6176)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 697, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6175)
				p.ExcludeClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExcludeClauseContext is an interface to support dynamic dispatch.
type IExcludeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	EXCEPT() antlr.TerminalNode
	EXCLUDE() antlr.TerminalNode

	// IsExcludeClauseContext differentiates from other interfaces.
	IsExcludeClauseContext()
}

type ExcludeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExcludeClauseContext() *ExcludeClauseContext {
	var p = new(ExcludeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_excludeClause
	return p
}

func InitEmptyExcludeClauseContext(p *ExcludeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_excludeClause
}

func (*ExcludeClauseContext) IsExcludeClauseContext() {}

func NewExcludeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExcludeClauseContext {
	var p = new(ExcludeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_excludeClause

	return p
}

func (s *ExcludeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ExcludeClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ExcludeClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExcludeClauseContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXCEPT, 0)
}

func (s *ExcludeClauseContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXCLUDE, 0)
}

func (s *ExcludeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExcludeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExcludeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterExcludeClause(s)
	}
}

func (s *ExcludeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitExcludeClause(s)
	}
}

func (s *ExcludeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitExcludeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ExcludeClause() (localctx IExcludeClauseContext) {
	localctx = NewExcludeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 790, DorisSQLParserParserRULE_excludeClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6180)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserEXCEPT || _la == DorisSQLParserParserEXCLUDE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6181)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6182)
		p.Identifier()
	}
	p.SetState(6187)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(6183)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6184)
			p.Identifier()
		}

		p.SetState(6189)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6190)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationsContext is an interface to support dynamic dispatch.
type IRelationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRelation() []IRelationContext
	Relation(i int) IRelationContext
	AllLATERAL() []antlr.TerminalNode
	LATERAL(i int) antlr.TerminalNode

	// IsRelationsContext differentiates from other interfaces.
	IsRelationsContext()
}

type RelationsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationsContext() *RelationsContext {
	var p = new(RelationsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_relations
	return p
}

func InitEmptyRelationsContext(p *RelationsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_relations
}

func (*RelationsContext) IsRelationsContext() {}

func NewRelationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationsContext {
	var p = new(RelationsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_relations

	return p
}

func (s *RelationsContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationsContext) AllRelation() []IRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelationContext); ok {
			len++
		}
	}

	tst := make([]IRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelationContext); ok {
			tst[i] = t.(IRelationContext)
			i++
		}
	}

	return tst
}

func (s *RelationsContext) Relation(i int) IRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *RelationsContext) AllLATERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserLATERAL)
}

func (s *RelationsContext) LATERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLATERAL, i)
}

func (s *RelationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRelations(s)
	}
}

func (s *RelationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRelations(s)
	}
}

func (s *RelationsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRelations(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Relations() (localctx IRelationsContext) {
	localctx = NewRelationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 792, DorisSQLParserParserRULE_relations)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6192)
		p.Relation()
	}
	p.SetState(6200)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 701, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6193)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(6195)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserParserLATERAL {
				{
					p.SetState(6194)
					p.Match(DorisSQLParserParserLATERAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6197)
				p.Relation()
			}

		}
		p.SetState(6202)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 701, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RelationPrimary() IRelationPrimaryContext
	AllJoinRelation() []IJoinRelationContext
	JoinRelation(i int) IJoinRelationContext

	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_relation
	return p
}

func InitEmptyRelationContext(p *RelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_relation
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) RelationPrimary() IRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *RelationContext) AllJoinRelation() []IJoinRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinRelationContext); ok {
			len++
		}
	}

	tst := make([]IJoinRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinRelationContext); ok {
			tst[i] = t.(IJoinRelationContext)
			i++
		}
	}

	return tst
}

func (s *RelationContext) JoinRelation(i int) IJoinRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinRelationContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRelation(s)
	}
}

func (s *RelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRelation(s)
	}
}

func (s *RelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Relation() (localctx IRelationContext) {
	localctx = NewRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 794, DorisSQLParserParserRULE_relation)
	var _la int

	var _alt int

	p.SetState(6220)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 704, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6203)
			p.RelationPrimary()
		}
		p.SetState(6207)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 702, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(6204)
					p.JoinRelation()
				}

			}
			p.SetState(6209)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 702, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6210)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6211)
			p.RelationPrimary()
		}
		p.SetState(6215)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserCROSS || ((int64((_la-175)) & ^0x3f) == 0 && ((int64(1)<<(_la-175))&4612811926924165121) != 0) || _la == DorisSQLParserParserRIGHT {
			{
				p.SetState(6212)
				p.JoinRelation()
			}

			p.SetState(6217)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6218)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationPrimaryContext is an interface to support dynamic dispatch.
type IRelationPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationPrimaryContext differentiates from other interfaces.
	IsRelationPrimaryContext()
}

type RelationPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationPrimaryContext() *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_relationPrimary
	return p
}

func InitEmptyRelationPrimaryContext(p *RelationPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_relationPrimary
}

func (*RelationPrimaryContext) IsRelationPrimaryContext() {}

func NewRelationPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_relationPrimary

	return p
}

func (s *RelationPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationPrimaryContext) CopyAll(ctx *RelationPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RelationPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryWithAliasContext struct {
	RelationPrimaryContext
	alias IIdentifierContext
}

func NewSubqueryWithAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryWithAliasContext {
	var p = new(SubqueryWithAliasContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *SubqueryWithAliasContext) GetAlias() IIdentifierContext { return s.alias }

func (s *SubqueryWithAliasContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *SubqueryWithAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryWithAliasContext) Subquery() ISubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *SubqueryWithAliasContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubqueryWithAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *SubqueryWithAliasContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *SubqueryWithAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSubqueryWithAlias(s)
	}
}

func (s *SubqueryWithAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSubqueryWithAlias(s)
	}
}

func (s *SubqueryWithAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSubqueryWithAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type NormalizedTableFunctionContext struct {
	RelationPrimaryContext
	alias IIdentifierContext
}

func NewNormalizedTableFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NormalizedTableFunctionContext {
	var p = new(NormalizedTableFunctionContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *NormalizedTableFunctionContext) GetAlias() IIdentifierContext { return s.alias }

func (s *NormalizedTableFunctionContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *NormalizedTableFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalizedTableFunctionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *NormalizedTableFunctionContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *NormalizedTableFunctionContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *NormalizedTableFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NormalizedTableFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *NormalizedTableFunctionContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *NormalizedTableFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterNormalizedTableFunction(s)
	}
}

func (s *NormalizedTableFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitNormalizedTableFunction(s)
	}
}

func (s *NormalizedTableFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitNormalizedTableFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableFunctionContext struct {
	RelationPrimaryContext
	alias IIdentifierContext
}

func NewTableFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableFunctionContext {
	var p = new(TableFunctionContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableFunctionContext) GetAlias() IIdentifierContext { return s.alias }

func (s *TableFunctionContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *TableFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableFunctionContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableFunctionContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *TableFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *TableFunctionContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *TableFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTableFunction(s)
	}
}

func (s *TableFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTableFunction(s)
	}
}

func (s *TableFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTableFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesizedRelationContext struct {
	RelationPrimaryContext
}

func NewParenthesizedRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedRelationContext {
	var p = new(ParenthesizedRelationContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *ParenthesizedRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedRelationContext) Relations() IRelationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationsContext)
}

func (s *ParenthesizedRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterParenthesizedRelation(s)
	}
}

func (s *ParenthesizedRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitParenthesizedRelation(s)
	}
}

func (s *ParenthesizedRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitParenthesizedRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

type FileTableFunctionContext struct {
	RelationPrimaryContext
	alias IIdentifierContext
}

func NewFileTableFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FileTableFunctionContext {
	var p = new(FileTableFunctionContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *FileTableFunctionContext) GetAlias() IIdentifierContext { return s.alias }

func (s *FileTableFunctionContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *FileTableFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileTableFunctionContext) FILES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFILES, 0)
}

func (s *FileTableFunctionContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *FileTableFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FileTableFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *FileTableFunctionContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *FileTableFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterFileTableFunction(s)
	}
}

func (s *FileTableFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitFileTableFunction(s)
	}
}

func (s *FileTableFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitFileTableFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableAtomContext struct {
	RelationPrimaryContext
	alias IIdentifierContext
	ts    IStringContext
}

func NewTableAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableAtomContext {
	var p = new(TableAtomContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableAtomContext) GetAlias() IIdentifierContext { return s.alias }

func (s *TableAtomContext) GetTs() IStringContext { return s.ts }

func (s *TableAtomContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *TableAtomContext) SetTs(v IStringContext) { s.ts = v }

func (s *TableAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableAtomContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableAtomContext) QueryPeriod() IQueryPeriodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryPeriodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryPeriodContext)
}

func (s *TableAtomContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *TableAtomContext) TabletList() ITabletListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabletListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabletListContext)
}

func (s *TableAtomContext) ReplicaList() IReplicaListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplicaListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplicaListContext)
}

func (s *TableAtomContext) SampleClause() ISampleClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleClauseContext)
}

func (s *TableAtomContext) BracketHint() IBracketHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBracketHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBracketHintContext)
}

func (s *TableAtomContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBEFORE, 0)
}

func (s *TableAtomContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableAtomContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *TableAtomContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *TableAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTableAtom(s)
	}
}

func (s *TableAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTableAtom(s)
	}
}

func (s *TableAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTableAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type InlineTableContext struct {
	RelationPrimaryContext
	alias IIdentifierContext
}

func NewInlineTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InlineTableContext {
	var p = new(InlineTableContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *InlineTableContext) GetAlias() IIdentifierContext { return s.alias }

func (s *InlineTableContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *InlineTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineTableContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVALUES, 0)
}

func (s *InlineTableContext) AllRowConstructor() []IRowConstructorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRowConstructorContext); ok {
			len++
		}
	}

	tst := make([]IRowConstructorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRowConstructorContext); ok {
			tst[i] = t.(IRowConstructorContext)
			i++
		}
	}

	return tst
}

func (s *InlineTableContext) RowConstructor(i int) IRowConstructorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowConstructorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowConstructorContext)
}

func (s *InlineTableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InlineTableContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *InlineTableContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *InlineTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterInlineTable(s)
	}
}

func (s *InlineTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitInlineTable(s)
	}
}

func (s *InlineTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitInlineTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) RelationPrimary() (localctx IRelationPrimaryContext) {
	localctx = NewRelationPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 796, DorisSQLParserParserRULE_relationPrimary)
	var _la int

	p.SetState(6325)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 730, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableAtomContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6222)
			p.QualifiedName()
		}
		p.SetState(6224)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 705, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6223)
				p.QueryPeriod()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6227)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 706, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6226)
				p.PartitionNames()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6230)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 707, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6229)
				p.TabletList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6233)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 708, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6232)
				p.ReplicaList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6236)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 709, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6235)
				p.SampleClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6242)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 711, p.GetParserRuleContext()) == 1 {
			p.SetState(6239)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserParserAS {
				{
					p.SetState(6238)
					p.Match(DorisSQLParserParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6241)

				var _x = p.Identifier()

				localctx.(*TableAtomContext).alias = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6245)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 712, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6244)
				p.BracketHint()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6249)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 713, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6247)
				p.Match(DorisSQLParserParserBEFORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6248)

				var _x = p.String_()

				localctx.(*TableAtomContext).ts = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewInlineTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6251)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6252)
			p.Match(DorisSQLParserParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6253)
			p.RowConstructor()
		}
		p.SetState(6258)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(6254)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6255)
				p.RowConstructor()
			}

			p.SetState(6260)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6261)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6269)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 717, p.GetParserRuleContext()) == 1 {
			p.SetState(6263)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserParserAS {
				{
					p.SetState(6262)
					p.Match(DorisSQLParserParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6265)

				var _x = p.Identifier()

				localctx.(*InlineTableContext).alias = _x
			}
			p.SetState(6267)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 716, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6266)
					p.ColumnAliases()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewSubqueryWithAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6271)
			p.Subquery()
		}
		p.SetState(6279)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 720, p.GetParserRuleContext()) == 1 {
			p.SetState(6273)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserParserAS {
				{
					p.SetState(6272)
					p.Match(DorisSQLParserParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6275)

				var _x = p.Identifier()

				localctx.(*SubqueryWithAliasContext).alias = _x
			}
			p.SetState(6277)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 719, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6276)
					p.ColumnAliases()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		localctx = NewTableFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6281)
			p.QualifiedName()
		}
		{
			p.SetState(6282)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6283)
			p.ExpressionList()
		}
		{
			p.SetState(6284)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6292)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 723, p.GetParserRuleContext()) == 1 {
			p.SetState(6286)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserParserAS {
				{
					p.SetState(6285)
					p.Match(DorisSQLParserParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6288)

				var _x = p.Identifier()

				localctx.(*TableFunctionContext).alias = _x
			}
			p.SetState(6290)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 722, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6289)
					p.ColumnAliases()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		localctx = NewNormalizedTableFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6294)
			p.Match(DorisSQLParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6295)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6296)
			p.QualifiedName()
		}
		{
			p.SetState(6297)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6298)
			p.ArgumentList()
		}
		{
			p.SetState(6299)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6300)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6308)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 726, p.GetParserRuleContext()) == 1 {
			p.SetState(6302)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserParserAS {
				{
					p.SetState(6301)
					p.Match(DorisSQLParserParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6304)

				var _x = p.Identifier()

				localctx.(*NormalizedTableFunctionContext).alias = _x
			}
			p.SetState(6306)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 725, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6305)
					p.ColumnAliases()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		localctx = NewFileTableFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6310)
			p.Match(DorisSQLParserParserFILES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6311)
			p.PropertyList()
		}
		p.SetState(6319)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 729, p.GetParserRuleContext()) == 1 {
			p.SetState(6313)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserParserAS {
				{
					p.SetState(6312)
					p.Match(DorisSQLParserParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6315)

				var _x = p.Identifier()

				localctx.(*FileTableFunctionContext).alias = _x
			}
			p.SetState(6317)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 728, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6316)
					p.ColumnAliases()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		localctx = NewParenthesizedRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6321)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6322)
			p.Relations()
		}
		{
			p.SetState(6323)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPivotClauseContext is an interface to support dynamic dispatch.
type IPivotClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PIVOT() antlr.TerminalNode
	AllPivotAggregationExpression() []IPivotAggregationExpressionContext
	PivotAggregationExpression(i int) IPivotAggregationExpressionContext
	FOR() antlr.TerminalNode
	IN() antlr.TerminalNode
	AllPivotValue() []IPivotValueContext
	PivotValue(i int) IPivotValueContext
	Identifier() IIdentifierContext
	IdentifierList() IIdentifierListContext

	// IsPivotClauseContext differentiates from other interfaces.
	IsPivotClauseContext()
}

type PivotClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivotClauseContext() *PivotClauseContext {
	var p = new(PivotClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_pivotClause
	return p
}

func InitEmptyPivotClauseContext(p *PivotClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_pivotClause
}

func (*PivotClauseContext) IsPivotClauseContext() {}

func NewPivotClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PivotClauseContext {
	var p = new(PivotClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_pivotClause

	return p
}

func (s *PivotClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PivotClauseContext) PIVOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPIVOT, 0)
}

func (s *PivotClauseContext) AllPivotAggregationExpression() []IPivotAggregationExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPivotAggregationExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPivotAggregationExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPivotAggregationExpressionContext); ok {
			tst[i] = t.(IPivotAggregationExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PivotClauseContext) PivotAggregationExpression(i int) IPivotAggregationExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivotAggregationExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivotAggregationExpressionContext)
}

func (s *PivotClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFOR, 0)
}

func (s *PivotClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *PivotClauseContext) AllPivotValue() []IPivotValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPivotValueContext); ok {
			len++
		}
	}

	tst := make([]IPivotValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPivotValueContext); ok {
			tst[i] = t.(IPivotValueContext)
			i++
		}
	}

	return tst
}

func (s *PivotClauseContext) PivotValue(i int) IPivotValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivotValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivotValueContext)
}

func (s *PivotClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PivotClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PivotClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PivotClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PivotClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPivotClause(s)
	}
}

func (s *PivotClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPivotClause(s)
	}
}

func (s *PivotClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPivotClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PivotClause() (localctx IPivotClauseContext) {
	localctx = NewPivotClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 798, DorisSQLParserParserRULE_pivotClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6327)
		p.Match(DorisSQLParserParserPIVOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6328)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6329)
		p.PivotAggregationExpression()
	}
	p.SetState(6334)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(6330)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6331)
			p.PivotAggregationExpression()
		}

		p.SetState(6336)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6337)
		p.Match(DorisSQLParserParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserACCESS, DorisSQLParserParserACTIVE, DorisSQLParserParserADMIN, DorisSQLParserParserADVISOR, DorisSQLParserParserAFTER, DorisSQLParserParserAGGREGATE, DorisSQLParserParserANTI, DorisSQLParserParserAPPLY, DorisSQLParserParserARRAY_AGG, DorisSQLParserParserARRAY_AGG_DISTINCT, DorisSQLParserParserASYNC, DorisSQLParserParserAUTHORS, DorisSQLParserParserAUTHENTICATION, DorisSQLParserParserAUTOMATED, DorisSQLParserParserAUTO_INCREMENT, DorisSQLParserParserAVG, DorisSQLParserParserBACKEND, DorisSQLParserParserBACKENDS, DorisSQLParserParserBACKUP, DorisSQLParserParserBASE, DorisSQLParserParserBASELINE, DorisSQLParserParserBEGIN, DorisSQLParserParserBINARY, DorisSQLParserParserBITMAP_UNION, DorisSQLParserParserBLACKHOLE, DorisSQLParserParserBLACKLIST, DorisSQLParserParserBODY, DorisSQLParserParserBOOLEAN, DorisSQLParserParserBRANCH, DorisSQLParserParserBROKER, DorisSQLParserParserBUCKETS, DorisSQLParserParserBUILTIN, DorisSQLParserParserCACHE, DorisSQLParserParserCANCEL, DorisSQLParserParserCAST, DorisSQLParserParserCATALOG, DorisSQLParserParserCATALOGS, DorisSQLParserParserCEIL, DorisSQLParserParserCHAIN, DorisSQLParserParserCHARSET, DorisSQLParserParserCLEAN, DorisSQLParserParserCLEAR, DorisSQLParserParserCLUSTER, DorisSQLParserParserCLUSTERS, DorisSQLParserParserCNGROUP, DorisSQLParserParserCNGROUPS, DorisSQLParserParserCOLLATION, DorisSQLParserParserCOLUMNS, DorisSQLParserParserCOMMENT, DorisSQLParserParserCOMMIT, DorisSQLParserParserCOMMITTED, DorisSQLParserParserCOMPACT, DorisSQLParserParserCOMPUTE, DorisSQLParserParserCONFIG, DorisSQLParserParserCONNECTION, DorisSQLParserParserCONSISTENT, DorisSQLParserParserCOSTS, DorisSQLParserParserCOUNT, DorisSQLParserParserCUME_DIST, DorisSQLParserParserCUMULATIVE, DorisSQLParserParserCURRENT, DorisSQLParserParserDATA, DorisSQLParserParserDATACACHE, DorisSQLParserParserDATE, DorisSQLParserParserDATETIME, DorisSQLParserParserDAY, DorisSQLParserParserDAYS, DorisSQLParserParserDEALLOCATE, DorisSQLParserParserDECOMMISSION, DorisSQLParserParserDIALECT, DorisSQLParserParserDICTIONARY, DorisSQLParserParserDICTIONARY_GET, DorisSQLParserParserDISABLE, DorisSQLParserParserDISTRIBUTED, DorisSQLParserParserDISTRIBUTION, DorisSQLParserParserDUPLICATE, DorisSQLParserParserDYNAMIC, DorisSQLParserParserENABLE, DorisSQLParserParserENCLOSE, DorisSQLParserParserEND, DorisSQLParserParserENGINE, DorisSQLParserParserENGINES, DorisSQLParserParserERRORS, DorisSQLParserParserESCAPE, DorisSQLParserParserEVENTS, DorisSQLParserParserEXCEPT, DorisSQLParserParserEXCLUDE, DorisSQLParserParserEXECUTE, DorisSQLParserParserEXPORT, DorisSQLParserParserEXTERNAL, DorisSQLParserParserEXTRACT, DorisSQLParserParserEVERY, DorisSQLParserParserFAILPOINT, DorisSQLParserParserFAILPOINTS, DorisSQLParserParserFIELDS, DorisSQLParserParserFILE, DorisSQLParserParserFILTER, DorisSQLParserParserFIRST, DorisSQLParserParserFLOOR, DorisSQLParserParserFN, DorisSQLParserParserFOLLOWING, DorisSQLParserParserFOLLOWER, DorisSQLParserParserFORMAT, DorisSQLParserParserFREE, DorisSQLParserParserFRONTEND, DorisSQLParserParserFRONTENDS, DorisSQLParserParserFUNCTIONS, DorisSQLParserParserGLOBAL, DorisSQLParserParserGRANTS, DorisSQLParserParserGROUP_CONCAT, DorisSQLParserParserHASH, DorisSQLParserParserHELP, DorisSQLParserParserHISTOGRAM, DorisSQLParserParserHLL_UNION, DorisSQLParserParserHOST, DorisSQLParserParserHOUR, DorisSQLParserParserHOURS, DorisSQLParserParserHUB, DorisSQLParserParserIDENTIFIED, DorisSQLParserParserIMPERSONATE, DorisSQLParserParserIMAGE, DorisSQLParserParserINACTIVE, DorisSQLParserParserINCREMENTAL, DorisSQLParserParserINDEXES, DorisSQLParserParserINSTALL, DorisSQLParserParserINTEGRATION, DorisSQLParserParserINTEGRATIONS, DorisSQLParserParserINTERMEDIATE, DorisSQLParserParserINTERVAL, DorisSQLParserParserOVERWRITE, DorisSQLParserParserISOLATION, DorisSQLParserParserJOB, DorisSQLParserParserLABEL, DorisSQLParserParserLAST, DorisSQLParserParserLESS, DorisSQLParserParserLEVEL, DorisSQLParserParserLIST, DorisSQLParserParserLOCAL, DorisSQLParserParserLOCATION, DorisSQLParserParserLOCATIONS, DorisSQLParserParserLOGS, DorisSQLParserParserLOGICAL, DorisSQLParserParserMANUAL, DorisSQLParserParserMAP, DorisSQLParserParserMAPPING, DorisSQLParserParserMAPPINGS, DorisSQLParserParserMASKING, DorisSQLParserParserMATCH, DorisSQLParserParserMATERIALIZED, DorisSQLParserParserMAX, DorisSQLParserParserMERGE, DorisSQLParserParserMIN, DorisSQLParserParserMINUTE, DorisSQLParserParserMINUTES, DorisSQLParserParserMINUS, DorisSQLParserParserMETA, DorisSQLParserParserMODE, DorisSQLParserParserMODIFY, DorisSQLParserParserMONTH, DorisSQLParserParserMULTIPLE, DorisSQLParserParserNAME, DorisSQLParserParserNAMES, DorisSQLParserParserNEGATIVE, DorisSQLParserParserNGRAMBF, DorisSQLParserParserNO, DorisSQLParserParserNODE, DorisSQLParserParserNODES, DorisSQLParserParserNONE, DorisSQLParserParserNULLS, DorisSQLParserParserNUMBER, DorisSQLParserParserNUMERIC, DorisSQLParserParserOBSERVER, DorisSQLParserParserOF, DorisSQLParserParserOFF, DorisSQLParserParserOFFSET, DorisSQLParserParserONLY, DorisSQLParserParserOPEN, DorisSQLParserParserOPERATE, DorisSQLParserParserOPTIMIZER, DorisSQLParserParserOPTION, DorisSQLParserParserPARTITIONS, DorisSQLParserParserPASSWORD, DorisSQLParserParserPATH, DorisSQLParserParserPAUSE, DorisSQLParserParserPENDING, DorisSQLParserParserPERCENT_RANK, DorisSQLParserParserPERCENTILE_UNION, DorisSQLParserParserPLAN, DorisSQLParserParserPLUGIN, DorisSQLParserParserPLUGINS, DorisSQLParserParserPIPE, DorisSQLParserParserPIPES, DorisSQLParserParserPIVOT, DorisSQLParserParserPOLICY, DorisSQLParserParserPOLICIES, DorisSQLParserParserPRECEDING, DorisSQLParserParserPREDICATE, DorisSQLParserParserPRIORITY, DorisSQLParserParserPRIVILEGES, DorisSQLParserParserPROBABILITY, DorisSQLParserParserPROC, DorisSQLParserParserPROCESSLIST, DorisSQLParserParserPROFILE, DorisSQLParserParserPROFILELIST, DorisSQLParserParserPROPERTIES, DorisSQLParserParserPROPERTY, DorisSQLParserParserPROVIDER, DorisSQLParserParserPROVIDERS, DorisSQLParserParserQUALIFY, DorisSQLParserParserQUARTER, DorisSQLParserParserQUERY, DorisSQLParserParserQUERIES, DorisSQLParserParserQUEUE, DorisSQLParserParserQUOTA, DorisSQLParserParserRANDOM, DorisSQLParserParserRANK, DorisSQLParserParserREASON, DorisSQLParserParserRECOVER, DorisSQLParserParserREFRESH, DorisSQLParserParserREWRITE, DorisSQLParserParserREMOVE, DorisSQLParserParserREPAIR, DorisSQLParserParserREPEATABLE, DorisSQLParserParserREPLACE_IF_NOT_NULL, DorisSQLParserParserREPLICA, DorisSQLParserParserREPOSITORY, DorisSQLParserParserREPOSITORIES, DorisSQLParserParserRESOURCE, DorisSQLParserParserRESOURCES, DorisSQLParserParserRESTORE, DorisSQLParserParserRESUME, DorisSQLParserParserRETAIN, DorisSQLParserParserRETENTION, DorisSQLParserParserRETURNS, DorisSQLParserParserRETRY, DorisSQLParserParserREVERT, DorisSQLParserParserROLE, DorisSQLParserParserROLES, DorisSQLParserParserROLLBACK, DorisSQLParserParserROLLUP, DorisSQLParserParserROUTINE, DorisSQLParserParserROW, DorisSQLParserParserRULE, DorisSQLParserParserRULES, DorisSQLParserParserRUNNING, DorisSQLParserParserSAMPLE, DorisSQLParserParserSCHEDULE, DorisSQLParserParserSCHEDULER, DorisSQLParserParserSECOND, DorisSQLParserParserSECURITY, DorisSQLParserParserSEMI, DorisSQLParserParserSEPARATOR, DorisSQLParserParserSERIALIZABLE, DorisSQLParserParserSESSION, DorisSQLParserParserSETS, DorisSQLParserParserSIGNED, DorisSQLParserParserSKIP_HEADER, DorisSQLParserParserSNAPSHOT, DorisSQLParserParserSNAPSHOTS, DorisSQLParserParserSQLBLACKLIST, DorisSQLParserParserSTART, DorisSQLParserParserSTATS, DorisSQLParserParserSTATUS, DorisSQLParserParserSTOP, DorisSQLParserParserSTORAGE, DorisSQLParserParserSTREAM, DorisSQLParserParserSTRING, DorisSQLParserParserSUBMIT, DorisSQLParserParserSUM, DorisSQLParserParserSUSPEND, DorisSQLParserParserSYNC, DorisSQLParserParserSYSTEM_TIME, DorisSQLParserParserSWAP, DorisSQLParserParserSTRUCT, DorisSQLParserParserTABLES, DorisSQLParserParserTABLET, DorisSQLParserParserTABLETS, DorisSQLParserParserTAG, DorisSQLParserParserTASK, DorisSQLParserParserTEMPORARY, DorisSQLParserParserTHAN, DorisSQLParserParserTIME, DorisSQLParserParserTIMES, DorisSQLParserParserTIMESTAMP, DorisSQLParserParserTIMESTAMPADD, DorisSQLParserParserTIMESTAMPDIFF, DorisSQLParserParserTRANSACTION, DorisSQLParserParserTRANSLATE, DorisSQLParserParserTRACE, DorisSQLParserParserTRIGGERS, DorisSQLParserParserTRIM_SPACE, DorisSQLParserParserTRUNCATE, DorisSQLParserParserTYPE, DorisSQLParserParserTYPES, DorisSQLParserParserUNBOUNDED, DorisSQLParserParserUNCOMMITTED, DorisSQLParserParserUNINSTALL, DorisSQLParserParserUNSET, DorisSQLParserParserUSAGE, DorisSQLParserParserUSER, DorisSQLParserParserUSERS, DorisSQLParserParserVALUE, DorisSQLParserParserVARBINARY, DorisSQLParserParserVARIABLES, DorisSQLParserParserVECTOR, DorisSQLParserParserVERBOSE, DorisSQLParserParserVERSION, DorisSQLParserParserVIEW, DorisSQLParserParserVIEWS, DorisSQLParserParserVOLUME, DorisSQLParserParserVOLUMES, DorisSQLParserParserWAREHOUSE, DorisSQLParserParserWAREHOUSES, DorisSQLParserParserWARNINGS, DorisSQLParserParserWEEK, DorisSQLParserParserWHITELIST, DorisSQLParserParserWORK, DorisSQLParserParserWRITE, DorisSQLParserParserYEAR, DorisSQLParserParserLOCK, DorisSQLParserParserUNLOCK, DorisSQLParserParserLOW_PRIORITY, DorisSQLParserParserDISK, DorisSQLParserParserBEFORE, DorisSQLParserParserFIELD, DorisSQLParserParserPERSISTENT, DorisSQLParserParserARRAY_ELEMENT, DorisSQLParserParserLETTER_IDENTIFIER, DorisSQLParserParserDIGIT_IDENTIFIER, DorisSQLParserParserBACKQUOTED_IDENTIFIER, DorisSQLParserParserDOTDOTDOT:
		{
			p.SetState(6338)
			p.Identifier()
		}

	case DorisSQLParserParserT__1:
		{
			p.SetState(6339)
			p.IdentifierList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(6342)
		p.Match(DorisSQLParserParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6343)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6344)
		p.PivotValue()
	}
	p.SetState(6349)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(6345)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6346)
			p.PivotValue()
		}

		p.SetState(6351)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6352)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6353)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPivotAggregationExpressionContext is an interface to support dynamic dispatch.
type IPivotAggregationExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionCall() IFunctionCallContext
	Identifier() IIdentifierContext
	String_() IStringContext
	AS() antlr.TerminalNode

	// IsPivotAggregationExpressionContext differentiates from other interfaces.
	IsPivotAggregationExpressionContext()
}

type PivotAggregationExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivotAggregationExpressionContext() *PivotAggregationExpressionContext {
	var p = new(PivotAggregationExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_pivotAggregationExpression
	return p
}

func InitEmptyPivotAggregationExpressionContext(p *PivotAggregationExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_pivotAggregationExpression
}

func (*PivotAggregationExpressionContext) IsPivotAggregationExpressionContext() {}

func NewPivotAggregationExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PivotAggregationExpressionContext {
	var p = new(PivotAggregationExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_pivotAggregationExpression

	return p
}

func (s *PivotAggregationExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PivotAggregationExpressionContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *PivotAggregationExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PivotAggregationExpressionContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *PivotAggregationExpressionContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *PivotAggregationExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PivotAggregationExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PivotAggregationExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPivotAggregationExpression(s)
	}
}

func (s *PivotAggregationExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPivotAggregationExpression(s)
	}
}

func (s *PivotAggregationExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPivotAggregationExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PivotAggregationExpression() (localctx IPivotAggregationExpressionContext) {
	localctx = NewPivotAggregationExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 800, DorisSQLParserParserRULE_pivotAggregationExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6355)
		p.FunctionCall()
	}
	p.SetState(6363)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262622484480) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-6664167256628462851) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-1331487429127569487) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&-7546427580836201) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-4573491655345179) != 0) || ((int64((_la-324)) & ^0x3f) == 0 && ((int64(1)<<(_la-324))&9114828243924942831) != 0) || ((int64((_la-389)) & ^0x3f) == 0 && ((int64(1)<<(_la-389))&-6956096606152176261) != 0) || ((int64((_la-453)) & ^0x3f) == 0 && ((int64(1)<<(_la-453))&70849595962729) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&4211) != 0) {
		p.SetState(6357)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserAS {
			{
				p.SetState(6356)
				p.Match(DorisSQLParserParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(6361)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserParserACCESS, DorisSQLParserParserACTIVE, DorisSQLParserParserADMIN, DorisSQLParserParserADVISOR, DorisSQLParserParserAFTER, DorisSQLParserParserAGGREGATE, DorisSQLParserParserANTI, DorisSQLParserParserAPPLY, DorisSQLParserParserARRAY_AGG, DorisSQLParserParserARRAY_AGG_DISTINCT, DorisSQLParserParserASYNC, DorisSQLParserParserAUTHORS, DorisSQLParserParserAUTHENTICATION, DorisSQLParserParserAUTOMATED, DorisSQLParserParserAUTO_INCREMENT, DorisSQLParserParserAVG, DorisSQLParserParserBACKEND, DorisSQLParserParserBACKENDS, DorisSQLParserParserBACKUP, DorisSQLParserParserBASE, DorisSQLParserParserBASELINE, DorisSQLParserParserBEGIN, DorisSQLParserParserBINARY, DorisSQLParserParserBITMAP_UNION, DorisSQLParserParserBLACKHOLE, DorisSQLParserParserBLACKLIST, DorisSQLParserParserBODY, DorisSQLParserParserBOOLEAN, DorisSQLParserParserBRANCH, DorisSQLParserParserBROKER, DorisSQLParserParserBUCKETS, DorisSQLParserParserBUILTIN, DorisSQLParserParserCACHE, DorisSQLParserParserCANCEL, DorisSQLParserParserCAST, DorisSQLParserParserCATALOG, DorisSQLParserParserCATALOGS, DorisSQLParserParserCEIL, DorisSQLParserParserCHAIN, DorisSQLParserParserCHARSET, DorisSQLParserParserCLEAN, DorisSQLParserParserCLEAR, DorisSQLParserParserCLUSTER, DorisSQLParserParserCLUSTERS, DorisSQLParserParserCNGROUP, DorisSQLParserParserCNGROUPS, DorisSQLParserParserCOLLATION, DorisSQLParserParserCOLUMNS, DorisSQLParserParserCOMMENT, DorisSQLParserParserCOMMIT, DorisSQLParserParserCOMMITTED, DorisSQLParserParserCOMPACT, DorisSQLParserParserCOMPUTE, DorisSQLParserParserCONFIG, DorisSQLParserParserCONNECTION, DorisSQLParserParserCONSISTENT, DorisSQLParserParserCOSTS, DorisSQLParserParserCOUNT, DorisSQLParserParserCUME_DIST, DorisSQLParserParserCUMULATIVE, DorisSQLParserParserCURRENT, DorisSQLParserParserDATA, DorisSQLParserParserDATACACHE, DorisSQLParserParserDATE, DorisSQLParserParserDATETIME, DorisSQLParserParserDAY, DorisSQLParserParserDAYS, DorisSQLParserParserDEALLOCATE, DorisSQLParserParserDECOMMISSION, DorisSQLParserParserDIALECT, DorisSQLParserParserDICTIONARY, DorisSQLParserParserDICTIONARY_GET, DorisSQLParserParserDISABLE, DorisSQLParserParserDISTRIBUTED, DorisSQLParserParserDISTRIBUTION, DorisSQLParserParserDUPLICATE, DorisSQLParserParserDYNAMIC, DorisSQLParserParserENABLE, DorisSQLParserParserENCLOSE, DorisSQLParserParserEND, DorisSQLParserParserENGINE, DorisSQLParserParserENGINES, DorisSQLParserParserERRORS, DorisSQLParserParserESCAPE, DorisSQLParserParserEVENTS, DorisSQLParserParserEXCEPT, DorisSQLParserParserEXCLUDE, DorisSQLParserParserEXECUTE, DorisSQLParserParserEXPORT, DorisSQLParserParserEXTERNAL, DorisSQLParserParserEXTRACT, DorisSQLParserParserEVERY, DorisSQLParserParserFAILPOINT, DorisSQLParserParserFAILPOINTS, DorisSQLParserParserFIELDS, DorisSQLParserParserFILE, DorisSQLParserParserFILTER, DorisSQLParserParserFIRST, DorisSQLParserParserFLOOR, DorisSQLParserParserFN, DorisSQLParserParserFOLLOWING, DorisSQLParserParserFOLLOWER, DorisSQLParserParserFORMAT, DorisSQLParserParserFREE, DorisSQLParserParserFRONTEND, DorisSQLParserParserFRONTENDS, DorisSQLParserParserFUNCTIONS, DorisSQLParserParserGLOBAL, DorisSQLParserParserGRANTS, DorisSQLParserParserGROUP_CONCAT, DorisSQLParserParserHASH, DorisSQLParserParserHELP, DorisSQLParserParserHISTOGRAM, DorisSQLParserParserHLL_UNION, DorisSQLParserParserHOST, DorisSQLParserParserHOUR, DorisSQLParserParserHOURS, DorisSQLParserParserHUB, DorisSQLParserParserIDENTIFIED, DorisSQLParserParserIMPERSONATE, DorisSQLParserParserIMAGE, DorisSQLParserParserINACTIVE, DorisSQLParserParserINCREMENTAL, DorisSQLParserParserINDEXES, DorisSQLParserParserINSTALL, DorisSQLParserParserINTEGRATION, DorisSQLParserParserINTEGRATIONS, DorisSQLParserParserINTERMEDIATE, DorisSQLParserParserINTERVAL, DorisSQLParserParserOVERWRITE, DorisSQLParserParserISOLATION, DorisSQLParserParserJOB, DorisSQLParserParserLABEL, DorisSQLParserParserLAST, DorisSQLParserParserLESS, DorisSQLParserParserLEVEL, DorisSQLParserParserLIST, DorisSQLParserParserLOCAL, DorisSQLParserParserLOCATION, DorisSQLParserParserLOCATIONS, DorisSQLParserParserLOGS, DorisSQLParserParserLOGICAL, DorisSQLParserParserMANUAL, DorisSQLParserParserMAP, DorisSQLParserParserMAPPING, DorisSQLParserParserMAPPINGS, DorisSQLParserParserMASKING, DorisSQLParserParserMATCH, DorisSQLParserParserMATERIALIZED, DorisSQLParserParserMAX, DorisSQLParserParserMERGE, DorisSQLParserParserMIN, DorisSQLParserParserMINUTE, DorisSQLParserParserMINUTES, DorisSQLParserParserMINUS, DorisSQLParserParserMETA, DorisSQLParserParserMODE, DorisSQLParserParserMODIFY, DorisSQLParserParserMONTH, DorisSQLParserParserMULTIPLE, DorisSQLParserParserNAME, DorisSQLParserParserNAMES, DorisSQLParserParserNEGATIVE, DorisSQLParserParserNGRAMBF, DorisSQLParserParserNO, DorisSQLParserParserNODE, DorisSQLParserParserNODES, DorisSQLParserParserNONE, DorisSQLParserParserNULLS, DorisSQLParserParserNUMBER, DorisSQLParserParserNUMERIC, DorisSQLParserParserOBSERVER, DorisSQLParserParserOF, DorisSQLParserParserOFF, DorisSQLParserParserOFFSET, DorisSQLParserParserONLY, DorisSQLParserParserOPEN, DorisSQLParserParserOPERATE, DorisSQLParserParserOPTIMIZER, DorisSQLParserParserOPTION, DorisSQLParserParserPARTITIONS, DorisSQLParserParserPASSWORD, DorisSQLParserParserPATH, DorisSQLParserParserPAUSE, DorisSQLParserParserPENDING, DorisSQLParserParserPERCENT_RANK, DorisSQLParserParserPERCENTILE_UNION, DorisSQLParserParserPLAN, DorisSQLParserParserPLUGIN, DorisSQLParserParserPLUGINS, DorisSQLParserParserPIPE, DorisSQLParserParserPIPES, DorisSQLParserParserPIVOT, DorisSQLParserParserPOLICY, DorisSQLParserParserPOLICIES, DorisSQLParserParserPRECEDING, DorisSQLParserParserPREDICATE, DorisSQLParserParserPRIORITY, DorisSQLParserParserPRIVILEGES, DorisSQLParserParserPROBABILITY, DorisSQLParserParserPROC, DorisSQLParserParserPROCESSLIST, DorisSQLParserParserPROFILE, DorisSQLParserParserPROFILELIST, DorisSQLParserParserPROPERTIES, DorisSQLParserParserPROPERTY, DorisSQLParserParserPROVIDER, DorisSQLParserParserPROVIDERS, DorisSQLParserParserQUALIFY, DorisSQLParserParserQUARTER, DorisSQLParserParserQUERY, DorisSQLParserParserQUERIES, DorisSQLParserParserQUEUE, DorisSQLParserParserQUOTA, DorisSQLParserParserRANDOM, DorisSQLParserParserRANK, DorisSQLParserParserREASON, DorisSQLParserParserRECOVER, DorisSQLParserParserREFRESH, DorisSQLParserParserREWRITE, DorisSQLParserParserREMOVE, DorisSQLParserParserREPAIR, DorisSQLParserParserREPEATABLE, DorisSQLParserParserREPLACE_IF_NOT_NULL, DorisSQLParserParserREPLICA, DorisSQLParserParserREPOSITORY, DorisSQLParserParserREPOSITORIES, DorisSQLParserParserRESOURCE, DorisSQLParserParserRESOURCES, DorisSQLParserParserRESTORE, DorisSQLParserParserRESUME, DorisSQLParserParserRETAIN, DorisSQLParserParserRETENTION, DorisSQLParserParserRETURNS, DorisSQLParserParserRETRY, DorisSQLParserParserREVERT, DorisSQLParserParserROLE, DorisSQLParserParserROLES, DorisSQLParserParserROLLBACK, DorisSQLParserParserROLLUP, DorisSQLParserParserROUTINE, DorisSQLParserParserROW, DorisSQLParserParserRULE, DorisSQLParserParserRULES, DorisSQLParserParserRUNNING, DorisSQLParserParserSAMPLE, DorisSQLParserParserSCHEDULE, DorisSQLParserParserSCHEDULER, DorisSQLParserParserSECOND, DorisSQLParserParserSECURITY, DorisSQLParserParserSEMI, DorisSQLParserParserSEPARATOR, DorisSQLParserParserSERIALIZABLE, DorisSQLParserParserSESSION, DorisSQLParserParserSETS, DorisSQLParserParserSIGNED, DorisSQLParserParserSKIP_HEADER, DorisSQLParserParserSNAPSHOT, DorisSQLParserParserSNAPSHOTS, DorisSQLParserParserSQLBLACKLIST, DorisSQLParserParserSTART, DorisSQLParserParserSTATS, DorisSQLParserParserSTATUS, DorisSQLParserParserSTOP, DorisSQLParserParserSTORAGE, DorisSQLParserParserSTREAM, DorisSQLParserParserSTRING, DorisSQLParserParserSUBMIT, DorisSQLParserParserSUM, DorisSQLParserParserSUSPEND, DorisSQLParserParserSYNC, DorisSQLParserParserSYSTEM_TIME, DorisSQLParserParserSWAP, DorisSQLParserParserSTRUCT, DorisSQLParserParserTABLES, DorisSQLParserParserTABLET, DorisSQLParserParserTABLETS, DorisSQLParserParserTAG, DorisSQLParserParserTASK, DorisSQLParserParserTEMPORARY, DorisSQLParserParserTHAN, DorisSQLParserParserTIME, DorisSQLParserParserTIMES, DorisSQLParserParserTIMESTAMP, DorisSQLParserParserTIMESTAMPADD, DorisSQLParserParserTIMESTAMPDIFF, DorisSQLParserParserTRANSACTION, DorisSQLParserParserTRANSLATE, DorisSQLParserParserTRACE, DorisSQLParserParserTRIGGERS, DorisSQLParserParserTRIM_SPACE, DorisSQLParserParserTRUNCATE, DorisSQLParserParserTYPE, DorisSQLParserParserTYPES, DorisSQLParserParserUNBOUNDED, DorisSQLParserParserUNCOMMITTED, DorisSQLParserParserUNINSTALL, DorisSQLParserParserUNSET, DorisSQLParserParserUSAGE, DorisSQLParserParserUSER, DorisSQLParserParserUSERS, DorisSQLParserParserVALUE, DorisSQLParserParserVARBINARY, DorisSQLParserParserVARIABLES, DorisSQLParserParserVECTOR, DorisSQLParserParserVERBOSE, DorisSQLParserParserVERSION, DorisSQLParserParserVIEW, DorisSQLParserParserVIEWS, DorisSQLParserParserVOLUME, DorisSQLParserParserVOLUMES, DorisSQLParserParserWAREHOUSE, DorisSQLParserParserWAREHOUSES, DorisSQLParserParserWARNINGS, DorisSQLParserParserWEEK, DorisSQLParserParserWHITELIST, DorisSQLParserParserWORK, DorisSQLParserParserWRITE, DorisSQLParserParserYEAR, DorisSQLParserParserLOCK, DorisSQLParserParserUNLOCK, DorisSQLParserParserLOW_PRIORITY, DorisSQLParserParserDISK, DorisSQLParserParserBEFORE, DorisSQLParserParserFIELD, DorisSQLParserParserPERSISTENT, DorisSQLParserParserARRAY_ELEMENT, DorisSQLParserParserLETTER_IDENTIFIER, DorisSQLParserParserDIGIT_IDENTIFIER, DorisSQLParserParserBACKQUOTED_IDENTIFIER, DorisSQLParserParserDOTDOTDOT:
			{
				p.SetState(6359)
				p.Identifier()
			}

		case DorisSQLParserParserSINGLE_QUOTED_TEXT, DorisSQLParserParserDOUBLE_QUOTED_TEXT:
			{
				p.SetState(6360)
				p.String_()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPivotValueContext is an interface to support dynamic dispatch.
type IPivotValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LiteralExpression() ILiteralExpressionContext
	LiteralExpressionList() ILiteralExpressionListContext
	Identifier() IIdentifierContext
	String_() IStringContext
	AS() antlr.TerminalNode

	// IsPivotValueContext differentiates from other interfaces.
	IsPivotValueContext()
}

type PivotValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivotValueContext() *PivotValueContext {
	var p = new(PivotValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_pivotValue
	return p
}

func InitEmptyPivotValueContext(p *PivotValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_pivotValue
}

func (*PivotValueContext) IsPivotValueContext() {}

func NewPivotValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PivotValueContext {
	var p = new(PivotValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_pivotValue

	return p
}

func (s *PivotValueContext) GetParser() antlr.Parser { return s.parser }

func (s *PivotValueContext) LiteralExpression() ILiteralExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionContext)
}

func (s *PivotValueContext) LiteralExpressionList() ILiteralExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionListContext)
}

func (s *PivotValueContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PivotValueContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *PivotValueContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *PivotValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PivotValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PivotValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPivotValue(s)
	}
}

func (s *PivotValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPivotValue(s)
	}
}

func (s *PivotValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPivotValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PivotValue() (localctx IPivotValueContext) {
	localctx = NewPivotValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 802, DorisSQLParserParserRULE_pivotValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6367)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserCEIL, DorisSQLParserParserDATE, DorisSQLParserParserDATETIME, DorisSQLParserParserFALSE, DorisSQLParserParserFLOOR, DorisSQLParserParserINTERVAL, DorisSQLParserParserNULL, DorisSQLParserParserPARAMETER, DorisSQLParserParserTRUE, DorisSQLParserParserINTEGER_VALUE, DorisSQLParserParserDECIMAL_VALUE, DorisSQLParserParserDOUBLE_VALUE, DorisSQLParserParserSINGLE_QUOTED_TEXT, DorisSQLParserParserDOUBLE_QUOTED_TEXT, DorisSQLParserParserBINARY_SINGLE_QUOTED_TEXT, DorisSQLParserParserBINARY_DOUBLE_QUOTED_TEXT:
		{
			p.SetState(6365)
			p.LiteralExpression()
		}

	case DorisSQLParserParserT__1:
		{
			p.SetState(6366)
			p.LiteralExpressionList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(6376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262622484480) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-6664167256628462851) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-1331487429127569487) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&-7546427580836201) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-4573491655345179) != 0) || ((int64((_la-324)) & ^0x3f) == 0 && ((int64(1)<<(_la-324))&9114828243924942831) != 0) || ((int64((_la-389)) & ^0x3f) == 0 && ((int64(1)<<(_la-389))&-6956096606152176261) != 0) || ((int64((_la-453)) & ^0x3f) == 0 && ((int64(1)<<(_la-453))&70849595962729) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&4211) != 0) {
		p.SetState(6370)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserAS {
			{
				p.SetState(6369)
				p.Match(DorisSQLParserParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(6374)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserParserACCESS, DorisSQLParserParserACTIVE, DorisSQLParserParserADMIN, DorisSQLParserParserADVISOR, DorisSQLParserParserAFTER, DorisSQLParserParserAGGREGATE, DorisSQLParserParserANTI, DorisSQLParserParserAPPLY, DorisSQLParserParserARRAY_AGG, DorisSQLParserParserARRAY_AGG_DISTINCT, DorisSQLParserParserASYNC, DorisSQLParserParserAUTHORS, DorisSQLParserParserAUTHENTICATION, DorisSQLParserParserAUTOMATED, DorisSQLParserParserAUTO_INCREMENT, DorisSQLParserParserAVG, DorisSQLParserParserBACKEND, DorisSQLParserParserBACKENDS, DorisSQLParserParserBACKUP, DorisSQLParserParserBASE, DorisSQLParserParserBASELINE, DorisSQLParserParserBEGIN, DorisSQLParserParserBINARY, DorisSQLParserParserBITMAP_UNION, DorisSQLParserParserBLACKHOLE, DorisSQLParserParserBLACKLIST, DorisSQLParserParserBODY, DorisSQLParserParserBOOLEAN, DorisSQLParserParserBRANCH, DorisSQLParserParserBROKER, DorisSQLParserParserBUCKETS, DorisSQLParserParserBUILTIN, DorisSQLParserParserCACHE, DorisSQLParserParserCANCEL, DorisSQLParserParserCAST, DorisSQLParserParserCATALOG, DorisSQLParserParserCATALOGS, DorisSQLParserParserCEIL, DorisSQLParserParserCHAIN, DorisSQLParserParserCHARSET, DorisSQLParserParserCLEAN, DorisSQLParserParserCLEAR, DorisSQLParserParserCLUSTER, DorisSQLParserParserCLUSTERS, DorisSQLParserParserCNGROUP, DorisSQLParserParserCNGROUPS, DorisSQLParserParserCOLLATION, DorisSQLParserParserCOLUMNS, DorisSQLParserParserCOMMENT, DorisSQLParserParserCOMMIT, DorisSQLParserParserCOMMITTED, DorisSQLParserParserCOMPACT, DorisSQLParserParserCOMPUTE, DorisSQLParserParserCONFIG, DorisSQLParserParserCONNECTION, DorisSQLParserParserCONSISTENT, DorisSQLParserParserCOSTS, DorisSQLParserParserCOUNT, DorisSQLParserParserCUME_DIST, DorisSQLParserParserCUMULATIVE, DorisSQLParserParserCURRENT, DorisSQLParserParserDATA, DorisSQLParserParserDATACACHE, DorisSQLParserParserDATE, DorisSQLParserParserDATETIME, DorisSQLParserParserDAY, DorisSQLParserParserDAYS, DorisSQLParserParserDEALLOCATE, DorisSQLParserParserDECOMMISSION, DorisSQLParserParserDIALECT, DorisSQLParserParserDICTIONARY, DorisSQLParserParserDICTIONARY_GET, DorisSQLParserParserDISABLE, DorisSQLParserParserDISTRIBUTED, DorisSQLParserParserDISTRIBUTION, DorisSQLParserParserDUPLICATE, DorisSQLParserParserDYNAMIC, DorisSQLParserParserENABLE, DorisSQLParserParserENCLOSE, DorisSQLParserParserEND, DorisSQLParserParserENGINE, DorisSQLParserParserENGINES, DorisSQLParserParserERRORS, DorisSQLParserParserESCAPE, DorisSQLParserParserEVENTS, DorisSQLParserParserEXCEPT, DorisSQLParserParserEXCLUDE, DorisSQLParserParserEXECUTE, DorisSQLParserParserEXPORT, DorisSQLParserParserEXTERNAL, DorisSQLParserParserEXTRACT, DorisSQLParserParserEVERY, DorisSQLParserParserFAILPOINT, DorisSQLParserParserFAILPOINTS, DorisSQLParserParserFIELDS, DorisSQLParserParserFILE, DorisSQLParserParserFILTER, DorisSQLParserParserFIRST, DorisSQLParserParserFLOOR, DorisSQLParserParserFN, DorisSQLParserParserFOLLOWING, DorisSQLParserParserFOLLOWER, DorisSQLParserParserFORMAT, DorisSQLParserParserFREE, DorisSQLParserParserFRONTEND, DorisSQLParserParserFRONTENDS, DorisSQLParserParserFUNCTIONS, DorisSQLParserParserGLOBAL, DorisSQLParserParserGRANTS, DorisSQLParserParserGROUP_CONCAT, DorisSQLParserParserHASH, DorisSQLParserParserHELP, DorisSQLParserParserHISTOGRAM, DorisSQLParserParserHLL_UNION, DorisSQLParserParserHOST, DorisSQLParserParserHOUR, DorisSQLParserParserHOURS, DorisSQLParserParserHUB, DorisSQLParserParserIDENTIFIED, DorisSQLParserParserIMPERSONATE, DorisSQLParserParserIMAGE, DorisSQLParserParserINACTIVE, DorisSQLParserParserINCREMENTAL, DorisSQLParserParserINDEXES, DorisSQLParserParserINSTALL, DorisSQLParserParserINTEGRATION, DorisSQLParserParserINTEGRATIONS, DorisSQLParserParserINTERMEDIATE, DorisSQLParserParserINTERVAL, DorisSQLParserParserOVERWRITE, DorisSQLParserParserISOLATION, DorisSQLParserParserJOB, DorisSQLParserParserLABEL, DorisSQLParserParserLAST, DorisSQLParserParserLESS, DorisSQLParserParserLEVEL, DorisSQLParserParserLIST, DorisSQLParserParserLOCAL, DorisSQLParserParserLOCATION, DorisSQLParserParserLOCATIONS, DorisSQLParserParserLOGS, DorisSQLParserParserLOGICAL, DorisSQLParserParserMANUAL, DorisSQLParserParserMAP, DorisSQLParserParserMAPPING, DorisSQLParserParserMAPPINGS, DorisSQLParserParserMASKING, DorisSQLParserParserMATCH, DorisSQLParserParserMATERIALIZED, DorisSQLParserParserMAX, DorisSQLParserParserMERGE, DorisSQLParserParserMIN, DorisSQLParserParserMINUTE, DorisSQLParserParserMINUTES, DorisSQLParserParserMINUS, DorisSQLParserParserMETA, DorisSQLParserParserMODE, DorisSQLParserParserMODIFY, DorisSQLParserParserMONTH, DorisSQLParserParserMULTIPLE, DorisSQLParserParserNAME, DorisSQLParserParserNAMES, DorisSQLParserParserNEGATIVE, DorisSQLParserParserNGRAMBF, DorisSQLParserParserNO, DorisSQLParserParserNODE, DorisSQLParserParserNODES, DorisSQLParserParserNONE, DorisSQLParserParserNULLS, DorisSQLParserParserNUMBER, DorisSQLParserParserNUMERIC, DorisSQLParserParserOBSERVER, DorisSQLParserParserOF, DorisSQLParserParserOFF, DorisSQLParserParserOFFSET, DorisSQLParserParserONLY, DorisSQLParserParserOPEN, DorisSQLParserParserOPERATE, DorisSQLParserParserOPTIMIZER, DorisSQLParserParserOPTION, DorisSQLParserParserPARTITIONS, DorisSQLParserParserPASSWORD, DorisSQLParserParserPATH, DorisSQLParserParserPAUSE, DorisSQLParserParserPENDING, DorisSQLParserParserPERCENT_RANK, DorisSQLParserParserPERCENTILE_UNION, DorisSQLParserParserPLAN, DorisSQLParserParserPLUGIN, DorisSQLParserParserPLUGINS, DorisSQLParserParserPIPE, DorisSQLParserParserPIPES, DorisSQLParserParserPIVOT, DorisSQLParserParserPOLICY, DorisSQLParserParserPOLICIES, DorisSQLParserParserPRECEDING, DorisSQLParserParserPREDICATE, DorisSQLParserParserPRIORITY, DorisSQLParserParserPRIVILEGES, DorisSQLParserParserPROBABILITY, DorisSQLParserParserPROC, DorisSQLParserParserPROCESSLIST, DorisSQLParserParserPROFILE, DorisSQLParserParserPROFILELIST, DorisSQLParserParserPROPERTIES, DorisSQLParserParserPROPERTY, DorisSQLParserParserPROVIDER, DorisSQLParserParserPROVIDERS, DorisSQLParserParserQUALIFY, DorisSQLParserParserQUARTER, DorisSQLParserParserQUERY, DorisSQLParserParserQUERIES, DorisSQLParserParserQUEUE, DorisSQLParserParserQUOTA, DorisSQLParserParserRANDOM, DorisSQLParserParserRANK, DorisSQLParserParserREASON, DorisSQLParserParserRECOVER, DorisSQLParserParserREFRESH, DorisSQLParserParserREWRITE, DorisSQLParserParserREMOVE, DorisSQLParserParserREPAIR, DorisSQLParserParserREPEATABLE, DorisSQLParserParserREPLACE_IF_NOT_NULL, DorisSQLParserParserREPLICA, DorisSQLParserParserREPOSITORY, DorisSQLParserParserREPOSITORIES, DorisSQLParserParserRESOURCE, DorisSQLParserParserRESOURCES, DorisSQLParserParserRESTORE, DorisSQLParserParserRESUME, DorisSQLParserParserRETAIN, DorisSQLParserParserRETENTION, DorisSQLParserParserRETURNS, DorisSQLParserParserRETRY, DorisSQLParserParserREVERT, DorisSQLParserParserROLE, DorisSQLParserParserROLES, DorisSQLParserParserROLLBACK, DorisSQLParserParserROLLUP, DorisSQLParserParserROUTINE, DorisSQLParserParserROW, DorisSQLParserParserRULE, DorisSQLParserParserRULES, DorisSQLParserParserRUNNING, DorisSQLParserParserSAMPLE, DorisSQLParserParserSCHEDULE, DorisSQLParserParserSCHEDULER, DorisSQLParserParserSECOND, DorisSQLParserParserSECURITY, DorisSQLParserParserSEMI, DorisSQLParserParserSEPARATOR, DorisSQLParserParserSERIALIZABLE, DorisSQLParserParserSESSION, DorisSQLParserParserSETS, DorisSQLParserParserSIGNED, DorisSQLParserParserSKIP_HEADER, DorisSQLParserParserSNAPSHOT, DorisSQLParserParserSNAPSHOTS, DorisSQLParserParserSQLBLACKLIST, DorisSQLParserParserSTART, DorisSQLParserParserSTATS, DorisSQLParserParserSTATUS, DorisSQLParserParserSTOP, DorisSQLParserParserSTORAGE, DorisSQLParserParserSTREAM, DorisSQLParserParserSTRING, DorisSQLParserParserSUBMIT, DorisSQLParserParserSUM, DorisSQLParserParserSUSPEND, DorisSQLParserParserSYNC, DorisSQLParserParserSYSTEM_TIME, DorisSQLParserParserSWAP, DorisSQLParserParserSTRUCT, DorisSQLParserParserTABLES, DorisSQLParserParserTABLET, DorisSQLParserParserTABLETS, DorisSQLParserParserTAG, DorisSQLParserParserTASK, DorisSQLParserParserTEMPORARY, DorisSQLParserParserTHAN, DorisSQLParserParserTIME, DorisSQLParserParserTIMES, DorisSQLParserParserTIMESTAMP, DorisSQLParserParserTIMESTAMPADD, DorisSQLParserParserTIMESTAMPDIFF, DorisSQLParserParserTRANSACTION, DorisSQLParserParserTRANSLATE, DorisSQLParserParserTRACE, DorisSQLParserParserTRIGGERS, DorisSQLParserParserTRIM_SPACE, DorisSQLParserParserTRUNCATE, DorisSQLParserParserTYPE, DorisSQLParserParserTYPES, DorisSQLParserParserUNBOUNDED, DorisSQLParserParserUNCOMMITTED, DorisSQLParserParserUNINSTALL, DorisSQLParserParserUNSET, DorisSQLParserParserUSAGE, DorisSQLParserParserUSER, DorisSQLParserParserUSERS, DorisSQLParserParserVALUE, DorisSQLParserParserVARBINARY, DorisSQLParserParserVARIABLES, DorisSQLParserParserVECTOR, DorisSQLParserParserVERBOSE, DorisSQLParserParserVERSION, DorisSQLParserParserVIEW, DorisSQLParserParserVIEWS, DorisSQLParserParserVOLUME, DorisSQLParserParserVOLUMES, DorisSQLParserParserWAREHOUSE, DorisSQLParserParserWAREHOUSES, DorisSQLParserParserWARNINGS, DorisSQLParserParserWEEK, DorisSQLParserParserWHITELIST, DorisSQLParserParserWORK, DorisSQLParserParserWRITE, DorisSQLParserParserYEAR, DorisSQLParserParserLOCK, DorisSQLParserParserUNLOCK, DorisSQLParserParserLOW_PRIORITY, DorisSQLParserParserDISK, DorisSQLParserParserBEFORE, DorisSQLParserParserFIELD, DorisSQLParserParserPERSISTENT, DorisSQLParserParserARRAY_ELEMENT, DorisSQLParserParserLETTER_IDENTIFIER, DorisSQLParserParserDIGIT_IDENTIFIER, DorisSQLParserParserBACKQUOTED_IDENTIFIER, DorisSQLParserParserDOTDOTDOT:
			{
				p.SetState(6372)
				p.Identifier()
			}

		case DorisSQLParserParserSINGLE_QUOTED_TEXT, DorisSQLParserParserDOUBLE_QUOTED_TEXT:
			{
				p.SetState(6373)
				p.String_()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampleClauseContext is an interface to support dynamic dispatch.
type ISampleClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SAMPLE() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsSampleClauseContext differentiates from other interfaces.
	IsSampleClauseContext()
}

type SampleClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampleClauseContext() *SampleClauseContext {
	var p = new(SampleClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_sampleClause
	return p
}

func InitEmptySampleClauseContext(p *SampleClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_sampleClause
}

func (*SampleClauseContext) IsSampleClauseContext() {}

func NewSampleClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleClauseContext {
	var p = new(SampleClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_sampleClause

	return p
}

func (s *SampleClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleClauseContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSAMPLE, 0)
}

func (s *SampleClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *SampleClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampleClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSampleClause(s)
	}
}

func (s *SampleClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSampleClause(s)
	}
}

func (s *SampleClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSampleClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SampleClause() (localctx ISampleClauseContext) {
	localctx = NewSampleClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 804, DorisSQLParserParserRULE_sampleClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6378)
		p.Match(DorisSQLParserParserSAMPLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6380)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 741, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6379)
			p.PropertyList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionList() IExpressionListContext
	NamedArgumentList() INamedArgumentListContext

	// IsArgumentListContext differentiates from other interfaces.
	IsArgumentListContext()
}

type ArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext {
	var p = new(ArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_argumentList
	return p
}

func InitEmptyArgumentListContext(p *ArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_argumentList
}

func (*ArgumentListContext) IsArgumentListContext() {}

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext {
	var p = new(ArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_argumentList

	return p
}

func (s *ArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArgumentListContext) NamedArgumentList() INamedArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedArgumentListContext)
}

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterArgumentList(s)
	}
}

func (s *ArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitArgumentList(s)
	}
}

func (s *ArgumentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitArgumentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ArgumentList() (localctx IArgumentListContext) {
	localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 806, DorisSQLParserParserRULE_argumentList)
	p.SetState(6384)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 742, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6382)
			p.ExpressionList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6383)
			p.NamedArgumentList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedArgumentListContext is an interface to support dynamic dispatch.
type INamedArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNamedArgument() []INamedArgumentContext
	NamedArgument(i int) INamedArgumentContext

	// IsNamedArgumentListContext differentiates from other interfaces.
	IsNamedArgumentListContext()
}

type NamedArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedArgumentListContext() *NamedArgumentListContext {
	var p = new(NamedArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_namedArgumentList
	return p
}

func InitEmptyNamedArgumentListContext(p *NamedArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_namedArgumentList
}

func (*NamedArgumentListContext) IsNamedArgumentListContext() {}

func NewNamedArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedArgumentListContext {
	var p = new(NamedArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_namedArgumentList

	return p
}

func (s *NamedArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedArgumentListContext) AllNamedArgument() []INamedArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedArgumentContext); ok {
			len++
		}
	}

	tst := make([]INamedArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedArgumentContext); ok {
			tst[i] = t.(INamedArgumentContext)
			i++
		}
	}

	return tst
}

func (s *NamedArgumentListContext) NamedArgument(i int) INamedArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedArgumentContext)
}

func (s *NamedArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterNamedArgumentList(s)
	}
}

func (s *NamedArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitNamedArgumentList(s)
	}
}

func (s *NamedArgumentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitNamedArgumentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) NamedArgumentList() (localctx INamedArgumentListContext) {
	localctx = NewNamedArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 808, DorisSQLParserParserRULE_namedArgumentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6386)
		p.NamedArgument()
	}
	p.SetState(6391)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(6387)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6388)
			p.NamedArgument()
		}

		p.SetState(6393)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedArgumentContext is an interface to support dynamic dispatch.
type INamedArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNamedArgumentContext differentiates from other interfaces.
	IsNamedArgumentContext()
}

type NamedArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedArgumentContext() *NamedArgumentContext {
	var p = new(NamedArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_namedArgument
	return p
}

func InitEmptyNamedArgumentContext(p *NamedArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_namedArgument
}

func (*NamedArgumentContext) IsNamedArgumentContext() {}

func NewNamedArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedArgumentContext {
	var p = new(NamedArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_namedArgument

	return p
}

func (s *NamedArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedArgumentContext) CopyAll(ctx *NamedArgumentContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NamedArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type NamedArgumentsContext struct {
	NamedArgumentContext
}

func NewNamedArgumentsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NamedArgumentsContext {
	var p = new(NamedArgumentsContext)

	InitEmptyNamedArgumentContext(&p.NamedArgumentContext)
	p.parser = parser
	p.CopyAll(ctx.(*NamedArgumentContext))

	return p
}

func (s *NamedArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgumentsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamedArgumentsContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NamedArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterNamedArguments(s)
	}
}

func (s *NamedArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitNamedArguments(s)
	}
}

func (s *NamedArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitNamedArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) NamedArgument() (localctx INamedArgumentContext) {
	localctx = NewNamedArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 810, DorisSQLParserParserRULE_namedArgument)
	localctx = NewNamedArgumentsContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6394)
		p.Identifier()
	}
	{
		p.SetState(6395)
		p.Match(DorisSQLParserParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6396)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinRelationContext is an interface to support dynamic dispatch.
type IJoinRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRightRelation returns the rightRelation rule contexts.
	GetRightRelation() IRelationPrimaryContext

	// SetRightRelation sets the rightRelation rule contexts.
	SetRightRelation(IRelationPrimaryContext)

	// Getter signatures
	CrossOrInnerJoinType() ICrossOrInnerJoinTypeContext
	RelationPrimary() IRelationPrimaryContext
	BracketHint() IBracketHintContext
	LATERAL() antlr.TerminalNode
	JoinCriteria() IJoinCriteriaContext
	OuterAndSemiJoinType() IOuterAndSemiJoinTypeContext

	// IsJoinRelationContext differentiates from other interfaces.
	IsJoinRelationContext()
}

type JoinRelationContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	rightRelation IRelationPrimaryContext
}

func NewEmptyJoinRelationContext() *JoinRelationContext {
	var p = new(JoinRelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_joinRelation
	return p
}

func InitEmptyJoinRelationContext(p *JoinRelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_joinRelation
}

func (*JoinRelationContext) IsJoinRelationContext() {}

func NewJoinRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinRelationContext {
	var p = new(JoinRelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_joinRelation

	return p
}

func (s *JoinRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinRelationContext) GetRightRelation() IRelationPrimaryContext { return s.rightRelation }

func (s *JoinRelationContext) SetRightRelation(v IRelationPrimaryContext) { s.rightRelation = v }

func (s *JoinRelationContext) CrossOrInnerJoinType() ICrossOrInnerJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICrossOrInnerJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICrossOrInnerJoinTypeContext)
}

func (s *JoinRelationContext) RelationPrimary() IRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *JoinRelationContext) BracketHint() IBracketHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBracketHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBracketHintContext)
}

func (s *JoinRelationContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLATERAL, 0)
}

func (s *JoinRelationContext) JoinCriteria() IJoinCriteriaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinCriteriaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinCriteriaContext)
}

func (s *JoinRelationContext) OuterAndSemiJoinType() IOuterAndSemiJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOuterAndSemiJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOuterAndSemiJoinTypeContext)
}

func (s *JoinRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterJoinRelation(s)
	}
}

func (s *JoinRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitJoinRelation(s)
	}
}

func (s *JoinRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitJoinRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) JoinRelation() (localctx IJoinRelationContext) {
	localctx = NewJoinRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 812, DorisSQLParserParserRULE_joinRelation)
	var _la int

	p.SetState(6419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserCROSS, DorisSQLParserParserINNER, DorisSQLParserParserJOIN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6398)
			p.CrossOrInnerJoinType()
		}
		p.SetState(6400)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__5 {
			{
				p.SetState(6399)
				p.BracketHint()
			}

		}
		p.SetState(6403)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserLATERAL {
			{
				p.SetState(6402)
				p.Match(DorisSQLParserParserLATERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6405)

			var _x = p.RelationPrimary()

			localctx.(*JoinRelationContext).rightRelation = _x
		}
		p.SetState(6407)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 746, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6406)
				p.JoinCriteria()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case DorisSQLParserParserFULL, DorisSQLParserParserLEFT, DorisSQLParserParserRIGHT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6409)
			p.OuterAndSemiJoinType()
		}
		p.SetState(6411)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__5 {
			{
				p.SetState(6410)
				p.BracketHint()
			}

		}
		p.SetState(6414)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserLATERAL {
			{
				p.SetState(6413)
				p.Match(DorisSQLParserParserLATERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6416)

			var _x = p.RelationPrimary()

			localctx.(*JoinRelationContext).rightRelation = _x
		}
		{
			p.SetState(6417)
			p.JoinCriteria()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICrossOrInnerJoinTypeContext is an interface to support dynamic dispatch.
type ICrossOrInnerJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JOIN() antlr.TerminalNode
	INNER() antlr.TerminalNode
	CROSS() antlr.TerminalNode

	// IsCrossOrInnerJoinTypeContext differentiates from other interfaces.
	IsCrossOrInnerJoinTypeContext()
}

type CrossOrInnerJoinTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCrossOrInnerJoinTypeContext() *CrossOrInnerJoinTypeContext {
	var p = new(CrossOrInnerJoinTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_crossOrInnerJoinType
	return p
}

func InitEmptyCrossOrInnerJoinTypeContext(p *CrossOrInnerJoinTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_crossOrInnerJoinType
}

func (*CrossOrInnerJoinTypeContext) IsCrossOrInnerJoinTypeContext() {}

func NewCrossOrInnerJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CrossOrInnerJoinTypeContext {
	var p = new(CrossOrInnerJoinTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_crossOrInnerJoinType

	return p
}

func (s *CrossOrInnerJoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CrossOrInnerJoinTypeContext) JOIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserJOIN, 0)
}

func (s *CrossOrInnerJoinTypeContext) INNER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINNER, 0)
}

func (s *CrossOrInnerJoinTypeContext) CROSS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCROSS, 0)
}

func (s *CrossOrInnerJoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CrossOrInnerJoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CrossOrInnerJoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCrossOrInnerJoinType(s)
	}
}

func (s *CrossOrInnerJoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCrossOrInnerJoinType(s)
	}
}

func (s *CrossOrInnerJoinTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCrossOrInnerJoinType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) CrossOrInnerJoinType() (localctx ICrossOrInnerJoinTypeContext) {
	localctx = NewCrossOrInnerJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 814, DorisSQLParserParserRULE_crossOrInnerJoinType)
	p.SetState(6427)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 750, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6421)
			p.Match(DorisSQLParserParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6422)
			p.Match(DorisSQLParserParserINNER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6423)
			p.Match(DorisSQLParserParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6424)
			p.Match(DorisSQLParserParserCROSS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6425)
			p.Match(DorisSQLParserParserCROSS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6426)
			p.Match(DorisSQLParserParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOuterAndSemiJoinTypeContext is an interface to support dynamic dispatch.
type IOuterAndSemiJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	FULL() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	ANTI() antlr.TerminalNode

	// IsOuterAndSemiJoinTypeContext differentiates from other interfaces.
	IsOuterAndSemiJoinTypeContext()
}

type OuterAndSemiJoinTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOuterAndSemiJoinTypeContext() *OuterAndSemiJoinTypeContext {
	var p = new(OuterAndSemiJoinTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_outerAndSemiJoinType
	return p
}

func InitEmptyOuterAndSemiJoinTypeContext(p *OuterAndSemiJoinTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_outerAndSemiJoinType
}

func (*OuterAndSemiJoinTypeContext) IsOuterAndSemiJoinTypeContext() {}

func NewOuterAndSemiJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OuterAndSemiJoinTypeContext {
	var p = new(OuterAndSemiJoinTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_outerAndSemiJoinType

	return p
}

func (s *OuterAndSemiJoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OuterAndSemiJoinTypeContext) LEFT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLEFT, 0)
}

func (s *OuterAndSemiJoinTypeContext) JOIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserJOIN, 0)
}

func (s *OuterAndSemiJoinTypeContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRIGHT, 0)
}

func (s *OuterAndSemiJoinTypeContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFULL, 0)
}

func (s *OuterAndSemiJoinTypeContext) OUTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOUTER, 0)
}

func (s *OuterAndSemiJoinTypeContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSEMI, 0)
}

func (s *OuterAndSemiJoinTypeContext) ANTI() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserANTI, 0)
}

func (s *OuterAndSemiJoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OuterAndSemiJoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OuterAndSemiJoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterOuterAndSemiJoinType(s)
	}
}

func (s *OuterAndSemiJoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitOuterAndSemiJoinType(s)
	}
}

func (s *OuterAndSemiJoinTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitOuterAndSemiJoinType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) OuterAndSemiJoinType() (localctx IOuterAndSemiJoinTypeContext) {
	localctx = NewOuterAndSemiJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 816, DorisSQLParserParserRULE_outerAndSemiJoinType)
	p.SetState(6456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 751, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6429)
			p.Match(DorisSQLParserParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6430)
			p.Match(DorisSQLParserParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6431)
			p.Match(DorisSQLParserParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6432)
			p.Match(DorisSQLParserParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6433)
			p.Match(DorisSQLParserParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6434)
			p.Match(DorisSQLParserParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6435)
			p.Match(DorisSQLParserParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6436)
			p.Match(DorisSQLParserParserOUTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6437)
			p.Match(DorisSQLParserParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6438)
			p.Match(DorisSQLParserParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6439)
			p.Match(DorisSQLParserParserOUTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6440)
			p.Match(DorisSQLParserParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6441)
			p.Match(DorisSQLParserParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6442)
			p.Match(DorisSQLParserParserOUTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6443)
			p.Match(DorisSQLParserParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6444)
			p.Match(DorisSQLParserParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6445)
			p.Match(DorisSQLParserParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6446)
			p.Match(DorisSQLParserParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6447)
			p.Match(DorisSQLParserParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6448)
			p.Match(DorisSQLParserParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6449)
			p.Match(DorisSQLParserParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6450)
			p.Match(DorisSQLParserParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6451)
			p.Match(DorisSQLParserParserANTI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6452)
			p.Match(DorisSQLParserParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6453)
			p.Match(DorisSQLParserParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6454)
			p.Match(DorisSQLParserParserANTI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6455)
			p.Match(DorisSQLParserParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBracketHintContext is an interface to support dynamic dispatch.
type IBracketHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	BITOR() antlr.TerminalNode
	PrimaryExpression() IPrimaryExpressionContext
	LiteralExpressionList() ILiteralExpressionListContext

	// IsBracketHintContext differentiates from other interfaces.
	IsBracketHintContext()
}

type BracketHintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBracketHintContext() *BracketHintContext {
	var p = new(BracketHintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_bracketHint
	return p
}

func InitEmptyBracketHintContext(p *BracketHintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_bracketHint
}

func (*BracketHintContext) IsBracketHintContext() {}

func NewBracketHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BracketHintContext {
	var p = new(BracketHintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_bracketHint

	return p
}

func (s *BracketHintContext) GetParser() antlr.Parser { return s.parser }

func (s *BracketHintContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *BracketHintContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BracketHintContext) BITOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBITOR, 0)
}

func (s *BracketHintContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *BracketHintContext) LiteralExpressionList() ILiteralExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionListContext)
}

func (s *BracketHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BracketHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BracketHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterBracketHint(s)
	}
}

func (s *BracketHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitBracketHint(s)
	}
}

func (s *BracketHintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitBracketHint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) BracketHint() (localctx IBracketHintContext) {
	localctx = NewBracketHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 818, DorisSQLParserParserRULE_bracketHint)
	var _la int

	p.SetState(6476)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 753, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6458)
			p.Match(DorisSQLParserParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6459)
			p.Identifier()
		}
		p.SetState(6464)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(6460)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6461)
				p.Identifier()
			}

			p.SetState(6466)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6467)
			p.Match(DorisSQLParserParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6469)
			p.Match(DorisSQLParserParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6470)
			p.Identifier()
		}
		{
			p.SetState(6471)
			p.Match(DorisSQLParserParserBITOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6472)
			p.primaryExpression(0)
		}
		{
			p.SetState(6473)
			p.LiteralExpressionList()
		}
		{
			p.SetState(6474)
			p.Match(DorisSQLParserParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHintMapContext is an interface to support dynamic dispatch.
type IHintMapContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetK returns the k rule contexts.
	GetK() IIdentifierOrStringContext

	// GetV returns the v rule contexts.
	GetV() ILiteralExpressionContext

	// SetK sets the k rule contexts.
	SetK(IIdentifierOrStringContext)

	// SetV sets the v rule contexts.
	SetV(ILiteralExpressionContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	LiteralExpression() ILiteralExpressionContext

	// IsHintMapContext differentiates from other interfaces.
	IsHintMapContext()
}

type HintMapContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	k      IIdentifierOrStringContext
	v      ILiteralExpressionContext
}

func NewEmptyHintMapContext() *HintMapContext {
	var p = new(HintMapContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_hintMap
	return p
}

func InitEmptyHintMapContext(p *HintMapContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_hintMap
}

func (*HintMapContext) IsHintMapContext() {}

func NewHintMapContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintMapContext {
	var p = new(HintMapContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_hintMap

	return p
}

func (s *HintMapContext) GetParser() antlr.Parser { return s.parser }

func (s *HintMapContext) GetK() IIdentifierOrStringContext { return s.k }

func (s *HintMapContext) GetV() ILiteralExpressionContext { return s.v }

func (s *HintMapContext) SetK(v IIdentifierOrStringContext) { s.k = v }

func (s *HintMapContext) SetV(v ILiteralExpressionContext) { s.v = v }

func (s *HintMapContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEQ, 0)
}

func (s *HintMapContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *HintMapContext) LiteralExpression() ILiteralExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionContext)
}

func (s *HintMapContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintMapContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HintMapContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterHintMap(s)
	}
}

func (s *HintMapContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitHintMap(s)
	}
}

func (s *HintMapContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitHintMap(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) HintMap() (localctx IHintMapContext) {
	localctx = NewHintMapContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 820, DorisSQLParserParserRULE_hintMap)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6478)

		var _x = p.IdentifierOrString()

		localctx.(*HintMapContext).k = _x
	}
	{
		p.SetState(6479)
		p.Match(DorisSQLParserParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6480)

		var _x = p.LiteralExpression()

		localctx.(*HintMapContext).v = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinCriteriaContext is an interface to support dynamic dispatch.
type IJoinCriteriaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	Expression() IExpressionContext
	USING() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsJoinCriteriaContext differentiates from other interfaces.
	IsJoinCriteriaContext()
}

type JoinCriteriaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinCriteriaContext() *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_joinCriteria
	return p
}

func InitEmptyJoinCriteriaContext(p *JoinCriteriaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_joinCriteria
}

func (*JoinCriteriaContext) IsJoinCriteriaContext() {}

func NewJoinCriteriaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_joinCriteria

	return p
}

func (s *JoinCriteriaContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinCriteriaContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserON, 0)
}

func (s *JoinCriteriaContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JoinCriteriaContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSING, 0)
}

func (s *JoinCriteriaContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *JoinCriteriaContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *JoinCriteriaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinCriteriaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinCriteriaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitJoinCriteria(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) JoinCriteria() (localctx IJoinCriteriaContext) {
	localctx = NewJoinCriteriaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 822, DorisSQLParserParserRULE_joinCriteria)
	var _la int

	p.SetState(6496)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6482)
			p.Match(DorisSQLParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6483)
			p.expression(0)
		}

	case DorisSQLParserParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6484)
			p.Match(DorisSQLParserParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6485)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6486)
			p.Identifier()
		}
		p.SetState(6491)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(6487)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6488)
				p.Identifier()
			}

			p.SetState(6493)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6494)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnAliasesContext is an interface to support dynamic dispatch.
type IColumnAliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsColumnAliasesContext differentiates from other interfaces.
	IsColumnAliasesContext()
}

type ColumnAliasesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnAliasesContext() *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_columnAliases
	return p
}

func InitEmptyColumnAliasesContext(p *ColumnAliasesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_columnAliases
}

func (*ColumnAliasesContext) IsColumnAliasesContext() {}

func NewColumnAliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_columnAliases

	return p
}

func (s *ColumnAliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnAliasesContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnAliasesContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnAliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnAliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnAliasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterColumnAliases(s)
	}
}

func (s *ColumnAliasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitColumnAliases(s)
	}
}

func (s *ColumnAliasesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitColumnAliases(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ColumnAliases() (localctx IColumnAliasesContext) {
	localctx = NewColumnAliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 824, DorisSQLParserParserRULE_columnAliases)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6498)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6499)
		p.Identifier()
	}
	p.SetState(6504)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(6500)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6501)
			p.Identifier()
		}

		p.SetState(6506)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6507)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionNamesContext is an interface to support dynamic dispatch.
type IPartitionNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext
	PARTITION() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	KeyPartitions() IKeyPartitionsContext

	// IsPartitionNamesContext differentiates from other interfaces.
	IsPartitionNamesContext()
}

type PartitionNamesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionNamesContext() *PartitionNamesContext {
	var p = new(PartitionNamesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_partitionNames
	return p
}

func InitEmptyPartitionNamesContext(p *PartitionNamesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_partitionNames
}

func (*PartitionNamesContext) IsPartitionNamesContext() {}

func NewPartitionNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionNamesContext {
	var p = new(PartitionNamesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_partitionNames

	return p
}

func (s *PartitionNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionNamesContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *PartitionNamesContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *PartitionNamesContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPARTITION, 0)
}

func (s *PartitionNamesContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPARTITIONS, 0)
}

func (s *PartitionNamesContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTEMPORARY, 0)
}

func (s *PartitionNamesContext) KeyPartitions() IKeyPartitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyPartitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyPartitionsContext)
}

func (s *PartitionNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPartitionNames(s)
	}
}

func (s *PartitionNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPartitionNames(s)
	}
}

func (s *PartitionNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPartitionNames(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PartitionNames() (localctx IPartitionNamesContext) {
	localctx = NewPartitionNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 826, DorisSQLParserParserRULE_partitionNames)
	var _la int

	p.SetState(6530)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 760, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6510)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserTEMPORARY {
			{
				p.SetState(6509)
				p.Match(DorisSQLParserParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6512)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserPARTITION || _la == DorisSQLParserParserPARTITIONS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6513)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6514)
			p.IdentifierOrString()
		}
		p.SetState(6519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(6515)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6516)
				p.IdentifierOrString()
			}

			p.SetState(6521)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6522)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(6525)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserTEMPORARY {
			{
				p.SetState(6524)
				p.Match(DorisSQLParserParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6527)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserPARTITION || _la == DorisSQLParserParserPARTITIONS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6528)
			p.IdentifierOrString()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6529)
			p.KeyPartitions()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyPartitionsContext is an interface to support dynamic dispatch.
type IKeyPartitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsKeyPartitionsContext differentiates from other interfaces.
	IsKeyPartitionsContext()
}

type KeyPartitionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyPartitionsContext() *KeyPartitionsContext {
	var p = new(KeyPartitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_keyPartitions
	return p
}

func InitEmptyKeyPartitionsContext(p *KeyPartitionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_keyPartitions
}

func (*KeyPartitionsContext) IsKeyPartitionsContext() {}

func NewKeyPartitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyPartitionsContext {
	var p = new(KeyPartitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_keyPartitions

	return p
}

func (s *KeyPartitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyPartitionsContext) CopyAll(ctx *KeyPartitionsContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *KeyPartitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyPartitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type KeyPartitionListContext struct {
	KeyPartitionsContext
}

func NewKeyPartitionListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KeyPartitionListContext {
	var p = new(KeyPartitionListContext)

	InitEmptyKeyPartitionsContext(&p.KeyPartitionsContext)
	p.parser = parser
	p.CopyAll(ctx.(*KeyPartitionsContext))

	return p
}

func (s *KeyPartitionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyPartitionListContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPARTITION, 0)
}

func (s *KeyPartitionListContext) AllKeyPartition() []IKeyPartitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyPartitionContext); ok {
			len++
		}
	}

	tst := make([]IKeyPartitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyPartitionContext); ok {
			tst[i] = t.(IKeyPartitionContext)
			i++
		}
	}

	return tst
}

func (s *KeyPartitionListContext) KeyPartition(i int) IKeyPartitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyPartitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyPartitionContext)
}

func (s *KeyPartitionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterKeyPartitionList(s)
	}
}

func (s *KeyPartitionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitKeyPartitionList(s)
	}
}

func (s *KeyPartitionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitKeyPartitionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) KeyPartitions() (localctx IKeyPartitionsContext) {
	localctx = NewKeyPartitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 828, DorisSQLParserParserRULE_keyPartitions)
	var _la int

	localctx = NewKeyPartitionListContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6532)
		p.Match(DorisSQLParserParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6533)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6534)
		p.KeyPartition()
	}
	p.SetState(6539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(6535)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6536)
			p.KeyPartition()
		}

		p.SetState(6541)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6542)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITabletListContext is an interface to support dynamic dispatch.
type ITabletListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLET() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsTabletListContext differentiates from other interfaces.
	IsTabletListContext()
}

type TabletListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTabletListContext() *TabletListContext {
	var p = new(TabletListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_tabletList
	return p
}

func InitEmptyTabletListContext(p *TabletListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_tabletList
}

func (*TabletListContext) IsTabletListContext() {}

func NewTabletListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TabletListContext {
	var p = new(TabletListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_tabletList

	return p
}

func (s *TabletListContext) GetParser() antlr.Parser { return s.parser }

func (s *TabletListContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLET, 0)
}

func (s *TabletListContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserINTEGER_VALUE)
}

func (s *TabletListContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, i)
}

func (s *TabletListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TabletListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TabletListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTabletList(s)
	}
}

func (s *TabletListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTabletList(s)
	}
}

func (s *TabletListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTabletList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) TabletList() (localctx ITabletListContext) {
	localctx = NewTabletListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 830, DorisSQLParserParserRULE_tabletList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6544)
		p.Match(DorisSQLParserParserTABLET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6545)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6546)
		p.Match(DorisSQLParserParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6551)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(6547)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6548)
			p.Match(DorisSQLParserParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(6553)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6554)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrepareStatementContext is an interface to support dynamic dispatch.
type IPrepareStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PREPARE() antlr.TerminalNode
	Identifier() IIdentifierContext
	FROM() antlr.TerminalNode
	PrepareSql() IPrepareSqlContext

	// IsPrepareStatementContext differentiates from other interfaces.
	IsPrepareStatementContext()
}

type PrepareStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrepareStatementContext() *PrepareStatementContext {
	var p = new(PrepareStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_prepareStatement
	return p
}

func InitEmptyPrepareStatementContext(p *PrepareStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_prepareStatement
}

func (*PrepareStatementContext) IsPrepareStatementContext() {}

func NewPrepareStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrepareStatementContext {
	var p = new(PrepareStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_prepareStatement

	return p
}

func (s *PrepareStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PrepareStatementContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPREPARE, 0)
}

func (s *PrepareStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrepareStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *PrepareStatementContext) PrepareSql() IPrepareSqlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrepareSqlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrepareSqlContext)
}

func (s *PrepareStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrepareStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrepareStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPrepareStatement(s)
	}
}

func (s *PrepareStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPrepareStatement(s)
	}
}

func (s *PrepareStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPrepareStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PrepareStatement() (localctx IPrepareStatementContext) {
	localctx = NewPrepareStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 832, DorisSQLParserParserRULE_prepareStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6556)
		p.Match(DorisSQLParserParserPREPARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6557)
		p.Identifier()
	}
	{
		p.SetState(6558)
		p.Match(DorisSQLParserParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6559)
		p.PrepareSql()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrepareSqlContext is an interface to support dynamic dispatch.
type IPrepareSqlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Statement() IStatementContext
	SINGLE_QUOTED_TEXT() antlr.TerminalNode

	// IsPrepareSqlContext differentiates from other interfaces.
	IsPrepareSqlContext()
}

type PrepareSqlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrepareSqlContext() *PrepareSqlContext {
	var p = new(PrepareSqlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_prepareSql
	return p
}

func InitEmptyPrepareSqlContext(p *PrepareSqlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_prepareSql
}

func (*PrepareSqlContext) IsPrepareSqlContext() {}

func NewPrepareSqlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrepareSqlContext {
	var p = new(PrepareSqlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_prepareSql

	return p
}

func (s *PrepareSqlContext) GetParser() antlr.Parser { return s.parser }

func (s *PrepareSqlContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *PrepareSqlContext) SINGLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSINGLE_QUOTED_TEXT, 0)
}

func (s *PrepareSqlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrepareSqlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrepareSqlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPrepareSql(s)
	}
}

func (s *PrepareSqlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPrepareSql(s)
	}
}

func (s *PrepareSqlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPrepareSql(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PrepareSql() (localctx IPrepareSqlContext) {
	localctx = NewPrepareSqlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 834, DorisSQLParserParserRULE_prepareSql)
	p.SetState(6563)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserT__1, DorisSQLParserParserADD, DorisSQLParserParserADMIN, DorisSQLParserParserALTER, DorisSQLParserParserANALYZE, DorisSQLParserParserBACKUP, DorisSQLParserParserBEGIN, DorisSQLParserParserCACHE, DorisSQLParserParserCANCEL, DorisSQLParserParserCLEAN, DorisSQLParserParserCLEAR, DorisSQLParserParserCOMMIT, DorisSQLParserParserCREATE, DorisSQLParserParserDEALLOCATE, DorisSQLParserParserDELETE, DorisSQLParserParserDESC, DorisSQLParserParserDESCRIBE, DorisSQLParserParserDROP, DorisSQLParserParserEXECUTE, DorisSQLParserParserEXPLAIN, DorisSQLParserParserEXPORT, DorisSQLParserParserGRANT, DorisSQLParserParserHELP, DorisSQLParserParserINSTALL, DorisSQLParserParserINSERT, DorisSQLParserParserKILL, DorisSQLParserParserLOAD, DorisSQLParserParserPAUSE, DorisSQLParserParserPREPARE, DorisSQLParserParserRECOVER, DorisSQLParserParserREFRESH, DorisSQLParserParserRESTORE, DorisSQLParserParserRESUME, DorisSQLParserParserREVOKE, DorisSQLParserParserROLLBACK, DorisSQLParserParserSELECT, DorisSQLParserParserSET, DorisSQLParserParserSHOW, DorisSQLParserParserSTART, DorisSQLParserParserSTOP, DorisSQLParserParserSUBMIT, DorisSQLParserParserSUSPEND, DorisSQLParserParserSYNC, DorisSQLParserParserTRANSLATE, DorisSQLParserParserTRACE, DorisSQLParserParserTRUNCATE, DorisSQLParserParserUNINSTALL, DorisSQLParserParserUPDATE, DorisSQLParserParserUSE, DorisSQLParserParserWITH, DorisSQLParserParserLOCK, DorisSQLParserParserUNLOCK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6561)
			p.Statement()
		}

	case DorisSQLParserParserSINGLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6562)
			p.Match(DorisSQLParserParserSINGLE_QUOTED_TEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExecuteStatementContext is an interface to support dynamic dispatch.
type IExecuteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXECUTE() antlr.TerminalNode
	Identifier() IIdentifierContext
	USING() antlr.TerminalNode
	AllAT() []antlr.TerminalNode
	AT(i int) antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext

	// IsExecuteStatementContext differentiates from other interfaces.
	IsExecuteStatementContext()
}

type ExecuteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteStatementContext() *ExecuteStatementContext {
	var p = new(ExecuteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_executeStatement
	return p
}

func InitEmptyExecuteStatementContext(p *ExecuteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_executeStatement
}

func (*ExecuteStatementContext) IsExecuteStatementContext() {}

func NewExecuteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteStatementContext {
	var p = new(ExecuteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_executeStatement

	return p
}

func (s *ExecuteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteStatementContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXECUTE, 0)
}

func (s *ExecuteStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExecuteStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSING, 0)
}

func (s *ExecuteStatementContext) AllAT() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserAT)
}

func (s *ExecuteStatementContext) AT(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAT, i)
}

func (s *ExecuteStatementContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *ExecuteStatementContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *ExecuteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterExecuteStatement(s)
	}
}

func (s *ExecuteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitExecuteStatement(s)
	}
}

func (s *ExecuteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitExecuteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ExecuteStatement() (localctx IExecuteStatementContext) {
	localctx = NewExecuteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 836, DorisSQLParserParserRULE_executeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6565)
		p.Match(DorisSQLParserParserEXECUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6566)
		p.Identifier()
	}
	p.SetState(6578)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserUSING {
		{
			p.SetState(6567)
			p.Match(DorisSQLParserParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6568)
			p.Match(DorisSQLParserParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6569)
			p.IdentifierOrString()
		}
		p.SetState(6575)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(6570)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6571)
				p.Match(DorisSQLParserParserAT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6572)
				p.IdentifierOrString()
			}

			p.SetState(6577)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeallocateStatementContext is an interface to support dynamic dispatch.
type IDeallocateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PREPARE() antlr.TerminalNode
	Identifier() IIdentifierContext
	DEALLOCATE() antlr.TerminalNode
	DROP() antlr.TerminalNode

	// IsDeallocateStatementContext differentiates from other interfaces.
	IsDeallocateStatementContext()
}

type DeallocateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeallocateStatementContext() *DeallocateStatementContext {
	var p = new(DeallocateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_deallocateStatement
	return p
}

func InitEmptyDeallocateStatementContext(p *DeallocateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_deallocateStatement
}

func (*DeallocateStatementContext) IsDeallocateStatementContext() {}

func NewDeallocateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeallocateStatementContext {
	var p = new(DeallocateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_deallocateStatement

	return p
}

func (s *DeallocateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeallocateStatementContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPREPARE, 0)
}

func (s *DeallocateStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DeallocateStatementContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDEALLOCATE, 0)
}

func (s *DeallocateStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDROP, 0)
}

func (s *DeallocateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeallocateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeallocateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDeallocateStatement(s)
	}
}

func (s *DeallocateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDeallocateStatement(s)
	}
}

func (s *DeallocateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDeallocateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DeallocateStatement() (localctx IDeallocateStatementContext) {
	localctx = NewDeallocateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 838, DorisSQLParserParserRULE_deallocateStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6580)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserDEALLOCATE || _la == DorisSQLParserParserDROP) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6581)
		p.Match(DorisSQLParserParserPREPARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6582)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplicaListContext is an interface to support dynamic dispatch.
type IReplicaListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLICA() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsReplicaListContext differentiates from other interfaces.
	IsReplicaListContext()
}

type ReplicaListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplicaListContext() *ReplicaListContext {
	var p = new(ReplicaListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_replicaList
	return p
}

func InitEmptyReplicaListContext(p *ReplicaListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_replicaList
}

func (*ReplicaListContext) IsReplicaListContext() {}

func NewReplicaListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplicaListContext {
	var p = new(ReplicaListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_replicaList

	return p
}

func (s *ReplicaListContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplicaListContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPLICA, 0)
}

func (s *ReplicaListContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserINTEGER_VALUE)
}

func (s *ReplicaListContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, i)
}

func (s *ReplicaListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplicaListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplicaListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterReplicaList(s)
	}
}

func (s *ReplicaListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitReplicaList(s)
	}
}

func (s *ReplicaListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitReplicaList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ReplicaList() (localctx IReplicaListContext) {
	localctx = NewReplicaListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 840, DorisSQLParserParserRULE_replicaList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6584)
		p.Match(DorisSQLParserParserREPLICA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6585)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6586)
		p.Match(DorisSQLParserParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6591)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(6587)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6588)
			p.Match(DorisSQLParserParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(6593)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6594)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionsWithDefaultContext is an interface to support dynamic dispatch.
type IExpressionsWithDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpressionOrDefault() []IExpressionOrDefaultContext
	ExpressionOrDefault(i int) IExpressionOrDefaultContext

	// IsExpressionsWithDefaultContext differentiates from other interfaces.
	IsExpressionsWithDefaultContext()
}

type ExpressionsWithDefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionsWithDefaultContext() *ExpressionsWithDefaultContext {
	var p = new(ExpressionsWithDefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_expressionsWithDefault
	return p
}

func InitEmptyExpressionsWithDefaultContext(p *ExpressionsWithDefaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_expressionsWithDefault
}

func (*ExpressionsWithDefaultContext) IsExpressionsWithDefaultContext() {}

func NewExpressionsWithDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionsWithDefaultContext {
	var p = new(ExpressionsWithDefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_expressionsWithDefault

	return p
}

func (s *ExpressionsWithDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionsWithDefaultContext) AllExpressionOrDefault() []IExpressionOrDefaultContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionOrDefaultContext); ok {
			len++
		}
	}

	tst := make([]IExpressionOrDefaultContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionOrDefaultContext); ok {
			tst[i] = t.(IExpressionOrDefaultContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionsWithDefaultContext) ExpressionOrDefault(i int) IExpressionOrDefaultContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionOrDefaultContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionOrDefaultContext)
}

func (s *ExpressionsWithDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionsWithDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionsWithDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterExpressionsWithDefault(s)
	}
}

func (s *ExpressionsWithDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitExpressionsWithDefault(s)
	}
}

func (s *ExpressionsWithDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitExpressionsWithDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ExpressionsWithDefault() (localctx IExpressionsWithDefaultContext) {
	localctx = NewExpressionsWithDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 842, DorisSQLParserParserRULE_expressionsWithDefault)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6596)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6597)
		p.ExpressionOrDefault()
	}
	p.SetState(6602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(6598)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6599)
			p.ExpressionOrDefault()
		}

		p.SetState(6604)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6605)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionOrDefaultContext is an interface to support dynamic dispatch.
type IExpressionOrDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	DEFAULT() antlr.TerminalNode

	// IsExpressionOrDefaultContext differentiates from other interfaces.
	IsExpressionOrDefaultContext()
}

type ExpressionOrDefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionOrDefaultContext() *ExpressionOrDefaultContext {
	var p = new(ExpressionOrDefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_expressionOrDefault
	return p
}

func InitEmptyExpressionOrDefaultContext(p *ExpressionOrDefaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_expressionOrDefault
}

func (*ExpressionOrDefaultContext) IsExpressionOrDefaultContext() {}

func NewExpressionOrDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionOrDefaultContext {
	var p = new(ExpressionOrDefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_expressionOrDefault

	return p
}

func (s *ExpressionOrDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionOrDefaultContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionOrDefaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDEFAULT, 0)
}

func (s *ExpressionOrDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionOrDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionOrDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterExpressionOrDefault(s)
	}
}

func (s *ExpressionOrDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitExpressionOrDefault(s)
	}
}

func (s *ExpressionOrDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitExpressionOrDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ExpressionOrDefault() (localctx IExpressionOrDefaultContext) {
	localctx = NewExpressionOrDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 844, DorisSQLParserParserRULE_expressionOrDefault)
	p.SetState(6609)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserT__1, DorisSQLParserParserT__5, DorisSQLParserParserT__8, DorisSQLParserParserACCESS, DorisSQLParserParserACTIVE, DorisSQLParserParserADMIN, DorisSQLParserParserADVISOR, DorisSQLParserParserAFTER, DorisSQLParserParserAGGREGATE, DorisSQLParserParserANTI, DorisSQLParserParserAPPLY, DorisSQLParserParserARRAY, DorisSQLParserParserARRAY_AGG, DorisSQLParserParserARRAY_AGG_DISTINCT, DorisSQLParserParserASYNC, DorisSQLParserParserAUTHORS, DorisSQLParserParserAUTHENTICATION, DorisSQLParserParserAUTOMATED, DorisSQLParserParserAUTO_INCREMENT, DorisSQLParserParserAVG, DorisSQLParserParserBACKEND, DorisSQLParserParserBACKENDS, DorisSQLParserParserBACKUP, DorisSQLParserParserBASE, DorisSQLParserParserBASELINE, DorisSQLParserParserBEGIN, DorisSQLParserParserBINARY, DorisSQLParserParserBITMAP_UNION, DorisSQLParserParserBLACKHOLE, DorisSQLParserParserBLACKLIST, DorisSQLParserParserBODY, DorisSQLParserParserBOOLEAN, DorisSQLParserParserBRANCH, DorisSQLParserParserBROKER, DorisSQLParserParserBUCKETS, DorisSQLParserParserBUILTIN, DorisSQLParserParserCACHE, DorisSQLParserParserCANCEL, DorisSQLParserParserCASE, DorisSQLParserParserCAST, DorisSQLParserParserCATALOG, DorisSQLParserParserCATALOGS, DorisSQLParserParserCEIL, DorisSQLParserParserCHAIN, DorisSQLParserParserCHAR, DorisSQLParserParserCHARSET, DorisSQLParserParserCLEAN, DorisSQLParserParserCLEAR, DorisSQLParserParserCLUSTER, DorisSQLParserParserCLUSTERS, DorisSQLParserParserCNGROUP, DorisSQLParserParserCNGROUPS, DorisSQLParserParserCOLLATION, DorisSQLParserParserCOLUMNS, DorisSQLParserParserCOMMENT, DorisSQLParserParserCOMMIT, DorisSQLParserParserCOMMITTED, DorisSQLParserParserCOMPACT, DorisSQLParserParserCOMPUTE, DorisSQLParserParserCONFIG, DorisSQLParserParserCONNECTION, DorisSQLParserParserCONSISTENT, DorisSQLParserParserCONVERT, DorisSQLParserParserCOSTS, DorisSQLParserParserCOUNT, DorisSQLParserParserCUME_DIST, DorisSQLParserParserCUMULATIVE, DorisSQLParserParserCURRENT, DorisSQLParserParserCURRENT_DATE, DorisSQLParserParserCURRENT_GROUP, DorisSQLParserParserCURRENT_ROLE, DorisSQLParserParserCURRENT_TIME, DorisSQLParserParserCURRENT_TIMESTAMP, DorisSQLParserParserCURRENT_USER, DorisSQLParserParserDATA, DorisSQLParserParserDATACACHE, DorisSQLParserParserDATABASE, DorisSQLParserParserDATE, DorisSQLParserParserDATETIME, DorisSQLParserParserDAY, DorisSQLParserParserDAYS, DorisSQLParserParserDEALLOCATE, DorisSQLParserParserDECOMMISSION, DorisSQLParserParserDENSE_RANK, DorisSQLParserParserDIALECT, DorisSQLParserParserDICTIONARY, DorisSQLParserParserDICTIONARY_GET, DorisSQLParserParserNTILE, DorisSQLParserParserDISABLE, DorisSQLParserParserDISTRIBUTED, DorisSQLParserParserDISTRIBUTION, DorisSQLParserParserDUPLICATE, DorisSQLParserParserDYNAMIC, DorisSQLParserParserENABLE, DorisSQLParserParserENCLOSE, DorisSQLParserParserEND, DorisSQLParserParserENGINE, DorisSQLParserParserENGINES, DorisSQLParserParserERRORS, DorisSQLParserParserESCAPE, DorisSQLParserParserEVENTS, DorisSQLParserParserEXCEPT, DorisSQLParserParserEXCLUDE, DorisSQLParserParserEXECUTE, DorisSQLParserParserEXISTS, DorisSQLParserParserEXPORT, DorisSQLParserParserEXTERNAL, DorisSQLParserParserEXTRACT, DorisSQLParserParserEVERY, DorisSQLParserParserFAILPOINT, DorisSQLParserParserFAILPOINTS, DorisSQLParserParserFALSE, DorisSQLParserParserFIELDS, DorisSQLParserParserFILE, DorisSQLParserParserFILTER, DorisSQLParserParserFIRST, DorisSQLParserParserFIRST_VALUE, DorisSQLParserParserFLOOR, DorisSQLParserParserFN, DorisSQLParserParserFOLLOWING, DorisSQLParserParserFOLLOWER, DorisSQLParserParserFORMAT, DorisSQLParserParserFREE, DorisSQLParserParserFRONTEND, DorisSQLParserParserFRONTENDS, DorisSQLParserParserFUNCTIONS, DorisSQLParserParserGLOBAL, DorisSQLParserParserGRANTS, DorisSQLParserParserGROUPING, DorisSQLParserParserGROUPING_ID, DorisSQLParserParserGROUP_CONCAT, DorisSQLParserParserHASH, DorisSQLParserParserHELP, DorisSQLParserParserHISTOGRAM, DorisSQLParserParserHLL_UNION, DorisSQLParserParserHOST, DorisSQLParserParserHOUR, DorisSQLParserParserHOURS, DorisSQLParserParserHUB, DorisSQLParserParserIDENTIFIED, DorisSQLParserParserIF, DorisSQLParserParserIMPERSONATE, DorisSQLParserParserIMAGE, DorisSQLParserParserINACTIVE, DorisSQLParserParserINCREMENTAL, DorisSQLParserParserINDEXES, DorisSQLParserParserINSTALL, DorisSQLParserParserINTEGRATION, DorisSQLParserParserINTEGRATIONS, DorisSQLParserParserINTERMEDIATE, DorisSQLParserParserINTERVAL, DorisSQLParserParserOVERWRITE, DorisSQLParserParserISOLATION, DorisSQLParserParserJOB, DorisSQLParserParserLABEL, DorisSQLParserParserLAG, DorisSQLParserParserLAST, DorisSQLParserParserLAST_VALUE, DorisSQLParserParserLEAD, DorisSQLParserParserLEFT, DorisSQLParserParserLESS, DorisSQLParserParserLEVEL, DorisSQLParserParserLIKE, DorisSQLParserParserLIST, DorisSQLParserParserLOCAL, DorisSQLParserParserLOCALTIME, DorisSQLParserParserLOCALTIMESTAMP, DorisSQLParserParserLOCATION, DorisSQLParserParserLOCATIONS, DorisSQLParserParserLOGS, DorisSQLParserParserLOGICAL, DorisSQLParserParserMANUAL, DorisSQLParserParserMAP, DorisSQLParserParserMAPPING, DorisSQLParserParserMAPPINGS, DorisSQLParserParserMASKING, DorisSQLParserParserMATCH, DorisSQLParserParserMATERIALIZED, DorisSQLParserParserMAX, DorisSQLParserParserMERGE, DorisSQLParserParserMIN, DorisSQLParserParserMINUTE, DorisSQLParserParserMINUTES, DorisSQLParserParserMINUS, DorisSQLParserParserMETA, DorisSQLParserParserMOD, DorisSQLParserParserMODE, DorisSQLParserParserMODIFY, DorisSQLParserParserMONTH, DorisSQLParserParserMULTIPLE, DorisSQLParserParserNAME, DorisSQLParserParserNAMES, DorisSQLParserParserNEGATIVE, DorisSQLParserParserNGRAMBF, DorisSQLParserParserNO, DorisSQLParserParserNODE, DorisSQLParserParserNODES, DorisSQLParserParserNONE, DorisSQLParserParserNOT, DorisSQLParserParserNULL, DorisSQLParserParserNULLS, DorisSQLParserParserNUMBER, DorisSQLParserParserNUMERIC, DorisSQLParserParserOBSERVER, DorisSQLParserParserOF, DorisSQLParserParserOFF, DorisSQLParserParserOFFSET, DorisSQLParserParserONLY, DorisSQLParserParserOPEN, DorisSQLParserParserOPERATE, DorisSQLParserParserOPTIMIZER, DorisSQLParserParserOPTION, DorisSQLParserParserPARAMETER, DorisSQLParserParserPARTITIONS, DorisSQLParserParserPASSWORD, DorisSQLParserParserPATH, DorisSQLParserParserPAUSE, DorisSQLParserParserPENDING, DorisSQLParserParserPERCENT_RANK, DorisSQLParserParserPERCENTILE_UNION, DorisSQLParserParserPLAN, DorisSQLParserParserPLUGIN, DorisSQLParserParserPLUGINS, DorisSQLParserParserPIPE, DorisSQLParserParserPIPES, DorisSQLParserParserPIVOT, DorisSQLParserParserPOLICY, DorisSQLParserParserPOLICIES, DorisSQLParserParserPRECEDING, DorisSQLParserParserPREDICATE, DorisSQLParserParserPRIORITY, DorisSQLParserParserPRIVILEGES, DorisSQLParserParserPROBABILITY, DorisSQLParserParserPROC, DorisSQLParserParserPROCESSLIST, DorisSQLParserParserPROFILE, DorisSQLParserParserPROFILELIST, DorisSQLParserParserPROPERTIES, DorisSQLParserParserPROPERTY, DorisSQLParserParserPROVIDER, DorisSQLParserParserPROVIDERS, DorisSQLParserParserQUALIFY, DorisSQLParserParserQUARTER, DorisSQLParserParserQUERY, DorisSQLParserParserQUERIES, DorisSQLParserParserQUEUE, DorisSQLParserParserQUOTA, DorisSQLParserParserRANDOM, DorisSQLParserParserRANK, DorisSQLParserParserREASON, DorisSQLParserParserRECOVER, DorisSQLParserParserREFRESH, DorisSQLParserParserREWRITE, DorisSQLParserParserREGEXP, DorisSQLParserParserREMOVE, DorisSQLParserParserREPAIR, DorisSQLParserParserREPEATABLE, DorisSQLParserParserREPLACE, DorisSQLParserParserREPLACE_IF_NOT_NULL, DorisSQLParserParserREPLICA, DorisSQLParserParserREPOSITORY, DorisSQLParserParserREPOSITORIES, DorisSQLParserParserRESOURCE, DorisSQLParserParserRESOURCES, DorisSQLParserParserRESTORE, DorisSQLParserParserRESUME, DorisSQLParserParserRETAIN, DorisSQLParserParserRETENTION, DorisSQLParserParserRETURNS, DorisSQLParserParserRETRY, DorisSQLParserParserREVERT, DorisSQLParserParserRIGHT, DorisSQLParserParserRLIKE, DorisSQLParserParserROLE, DorisSQLParserParserROLES, DorisSQLParserParserROLLBACK, DorisSQLParserParserROLLUP, DorisSQLParserParserROUTINE, DorisSQLParserParserROW, DorisSQLParserParserROW_NUMBER, DorisSQLParserParserRULE, DorisSQLParserParserRULES, DorisSQLParserParserRUNNING, DorisSQLParserParserSAMPLE, DorisSQLParserParserSCHEDULE, DorisSQLParserParserSCHEDULER, DorisSQLParserParserSCHEMA, DorisSQLParserParserSECOND, DorisSQLParserParserSECURITY, DorisSQLParserParserSEMI, DorisSQLParserParserSEPARATOR, DorisSQLParserParserSERIALIZABLE, DorisSQLParserParserSESSION, DorisSQLParserParserSETS, DorisSQLParserParserSIGNED, DorisSQLParserParserSKIP_HEADER, DorisSQLParserParserSNAPSHOT, DorisSQLParserParserSNAPSHOTS, DorisSQLParserParserSQLBLACKLIST, DorisSQLParserParserSTART, DorisSQLParserParserSTATS, DorisSQLParserParserSTATUS, DorisSQLParserParserSTOP, DorisSQLParserParserSTORAGE, DorisSQLParserParserSTREAM, DorisSQLParserParserSTRING, DorisSQLParserParserSUBMIT, DorisSQLParserParserSUM, DorisSQLParserParserSUSPEND, DorisSQLParserParserSYNC, DorisSQLParserParserSYSTEM_TIME, DorisSQLParserParserSWAP, DorisSQLParserParserSTRUCT, DorisSQLParserParserTABLES, DorisSQLParserParserTABLET, DorisSQLParserParserTABLETS, DorisSQLParserParserTAG, DorisSQLParserParserTASK, DorisSQLParserParserTEMPORARY, DorisSQLParserParserTHAN, DorisSQLParserParserTIME, DorisSQLParserParserTIMES, DorisSQLParserParserTIMESTAMP, DorisSQLParserParserTIMESTAMPADD, DorisSQLParserParserTIMESTAMPDIFF, DorisSQLParserParserTRANSACTION, DorisSQLParserParserTRANSLATE, DorisSQLParserParserTRACE, DorisSQLParserParserTRIGGERS, DorisSQLParserParserTRIM_SPACE, DorisSQLParserParserTRUE, DorisSQLParserParserTRUNCATE, DorisSQLParserParserTYPE, DorisSQLParserParserTYPES, DorisSQLParserParserUNBOUNDED, DorisSQLParserParserUNCOMMITTED, DorisSQLParserParserUNINSTALL, DorisSQLParserParserUNSET, DorisSQLParserParserUSAGE, DorisSQLParserParserUSER, DorisSQLParserParserUSERS, DorisSQLParserParserVALUE, DorisSQLParserParserVARBINARY, DorisSQLParserParserVARIABLES, DorisSQLParserParserVECTOR, DorisSQLParserParserVERBOSE, DorisSQLParserParserVERSION, DorisSQLParserParserVIEW, DorisSQLParserParserVIEWS, DorisSQLParserParserVOLUME, DorisSQLParserParserVOLUMES, DorisSQLParserParserWAREHOUSE, DorisSQLParserParserWAREHOUSES, DorisSQLParserParserWARNINGS, DorisSQLParserParserWEEK, DorisSQLParserParserWHITELIST, DorisSQLParserParserWORK, DorisSQLParserParserWRITE, DorisSQLParserParserYEAR, DorisSQLParserParserLOCK, DorisSQLParserParserUNLOCK, DorisSQLParserParserLOW_PRIORITY, DorisSQLParserParserDISK, DorisSQLParserParserBEFORE, DorisSQLParserParserFIELD, DorisSQLParserParserPERSISTENT, DorisSQLParserParserARRAY_ELEMENT, DorisSQLParserParserPLUS_SYMBOL, DorisSQLParserParserMINUS_SYMBOL, DorisSQLParserParserLOGICAL_NOT, DorisSQLParserParserBITNOT, DorisSQLParserParserAT, DorisSQLParserParserINTEGER_VALUE, DorisSQLParserParserDECIMAL_VALUE, DorisSQLParserParserDOUBLE_VALUE, DorisSQLParserParserSINGLE_QUOTED_TEXT, DorisSQLParserParserDOUBLE_QUOTED_TEXT, DorisSQLParserParserBINARY_SINGLE_QUOTED_TEXT, DorisSQLParserParserBINARY_DOUBLE_QUOTED_TEXT, DorisSQLParserParserLETTER_IDENTIFIER, DorisSQLParserParserDIGIT_IDENTIFIER, DorisSQLParserParserBACKQUOTED_IDENTIFIER, DorisSQLParserParserDOTDOTDOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6607)
			p.expression(0)
		}

	case DorisSQLParserParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6608)
			p.Match(DorisSQLParserParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapExpressionListContext is an interface to support dynamic dispatch.
type IMapExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMapExpression() []IMapExpressionContext
	MapExpression(i int) IMapExpressionContext

	// IsMapExpressionListContext differentiates from other interfaces.
	IsMapExpressionListContext()
}

type MapExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapExpressionListContext() *MapExpressionListContext {
	var p = new(MapExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_mapExpressionList
	return p
}

func InitEmptyMapExpressionListContext(p *MapExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_mapExpressionList
}

func (*MapExpressionListContext) IsMapExpressionListContext() {}

func NewMapExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapExpressionListContext {
	var p = new(MapExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_mapExpressionList

	return p
}

func (s *MapExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *MapExpressionListContext) AllMapExpression() []IMapExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMapExpressionContext); ok {
			len++
		}
	}

	tst := make([]IMapExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMapExpressionContext); ok {
			tst[i] = t.(IMapExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MapExpressionListContext) MapExpression(i int) IMapExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapExpressionContext)
}

func (s *MapExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterMapExpressionList(s)
	}
}

func (s *MapExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitMapExpressionList(s)
	}
}

func (s *MapExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitMapExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) MapExpressionList() (localctx IMapExpressionListContext) {
	localctx = NewMapExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 846, DorisSQLParserParserRULE_mapExpressionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6611)
		p.MapExpression()
	}
	p.SetState(6616)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(6612)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6613)
			p.MapExpression()
		}

		p.SetState(6618)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapExpressionContext is an interface to support dynamic dispatch.
type IMapExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IExpressionContext

	// GetValue returns the value rule contexts.
	GetValue() IExpressionContext

	// SetKey sets the key rule contexts.
	SetKey(IExpressionContext)

	// SetValue sets the value rule contexts.
	SetValue(IExpressionContext)

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsMapExpressionContext differentiates from other interfaces.
	IsMapExpressionContext()
}

type MapExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IExpressionContext
	value  IExpressionContext
}

func NewEmptyMapExpressionContext() *MapExpressionContext {
	var p = new(MapExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_mapExpression
	return p
}

func InitEmptyMapExpressionContext(p *MapExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_mapExpression
}

func (*MapExpressionContext) IsMapExpressionContext() {}

func NewMapExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapExpressionContext {
	var p = new(MapExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_mapExpression

	return p
}

func (s *MapExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MapExpressionContext) GetKey() IExpressionContext { return s.key }

func (s *MapExpressionContext) GetValue() IExpressionContext { return s.value }

func (s *MapExpressionContext) SetKey(v IExpressionContext) { s.key = v }

func (s *MapExpressionContext) SetValue(v IExpressionContext) { s.value = v }

func (s *MapExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MapExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MapExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterMapExpression(s)
	}
}

func (s *MapExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitMapExpression(s)
	}
}

func (s *MapExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitMapExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) MapExpression() (localctx IMapExpressionContext) {
	localctx = NewMapExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 848, DorisSQLParserParserRULE_mapExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6619)

		var _x = p.expression(0)

		localctx.(*MapExpressionContext).key = _x
	}
	{
		p.SetState(6620)
		p.Match(DorisSQLParserParserT__7)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6621)

		var _x = p.expression(0)

		localctx.(*MapExpressionContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionSingletonContext is an interface to support dynamic dispatch.
type IExpressionSingletonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	EOF() antlr.TerminalNode

	// IsExpressionSingletonContext differentiates from other interfaces.
	IsExpressionSingletonContext()
}

type ExpressionSingletonContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionSingletonContext() *ExpressionSingletonContext {
	var p = new(ExpressionSingletonContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_expressionSingleton
	return p
}

func InitEmptyExpressionSingletonContext(p *ExpressionSingletonContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_expressionSingleton
}

func (*ExpressionSingletonContext) IsExpressionSingletonContext() {}

func NewExpressionSingletonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionSingletonContext {
	var p = new(ExpressionSingletonContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_expressionSingleton

	return p
}

func (s *ExpressionSingletonContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionSingletonContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionSingletonContext) EOF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEOF, 0)
}

func (s *ExpressionSingletonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionSingletonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionSingletonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterExpressionSingleton(s)
	}
}

func (s *ExpressionSingletonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitExpressionSingleton(s)
	}
}

func (s *ExpressionSingletonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitExpressionSingleton(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ExpressionSingleton() (localctx IExpressionSingletonContext) {
	localctx = NewExpressionSingletonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 850, DorisSQLParserParserRULE_expressionSingleton)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6623)
		p.expression(0)
	}
	{
		p.SetState(6624)
		p.Match(DorisSQLParserParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyAll(ctx *ExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExpressionDefaultContext struct {
	ExpressionContext
}

func NewExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExpressionDefaultContext {
	var p = new(ExpressionDefaultContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionDefaultContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ExpressionDefaultContext) BINARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBINARY, 0)
}

func (s *ExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterExpressionDefault(s)
	}
}

func (s *ExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitExpressionDefault(s)
	}
}

func (s *ExpressionDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitExpressionDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalNotContext struct {
	ExpressionContext
}

func NewLogicalNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalNotContext {
	var p = new(LogicalNotContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *LogicalNotContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterLogicalNot(s)
	}
}

func (s *LogicalNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitLogicalNot(s)
	}
}

func (s *LogicalNotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitLogicalNot(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalBinaryContext struct {
	ExpressionContext
	left     IExpressionContext
	operator antlr.Token
	right    IExpressionContext
}

func NewLogicalBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalBinaryContext {
	var p = new(LogicalBinaryContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *LogicalBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *LogicalBinaryContext) GetLeft() IExpressionContext { return s.left }

func (s *LogicalBinaryContext) GetRight() IExpressionContext { return s.right }

func (s *LogicalBinaryContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *LogicalBinaryContext) SetRight(v IExpressionContext) { s.right = v }

func (s *LogicalBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalBinaryContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalBinaryContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalBinaryContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAND, 0)
}

func (s *LogicalBinaryContext) LOGICAL_AND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOGICAL_AND, 0)
}

func (s *LogicalBinaryContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOR, 0)
}

func (s *LogicalBinaryContext) LOGICAL_OR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOGICAL_OR, 0)
}

func (s *LogicalBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitLogicalBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *DorisSQLParserParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 852
	p.EnterRecursionRule(localctx, 852, DorisSQLParserParserRULE_expression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6633)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserT__1, DorisSQLParserParserT__5, DorisSQLParserParserT__8, DorisSQLParserParserACCESS, DorisSQLParserParserACTIVE, DorisSQLParserParserADMIN, DorisSQLParserParserADVISOR, DorisSQLParserParserAFTER, DorisSQLParserParserAGGREGATE, DorisSQLParserParserANTI, DorisSQLParserParserAPPLY, DorisSQLParserParserARRAY, DorisSQLParserParserARRAY_AGG, DorisSQLParserParserARRAY_AGG_DISTINCT, DorisSQLParserParserASYNC, DorisSQLParserParserAUTHORS, DorisSQLParserParserAUTHENTICATION, DorisSQLParserParserAUTOMATED, DorisSQLParserParserAUTO_INCREMENT, DorisSQLParserParserAVG, DorisSQLParserParserBACKEND, DorisSQLParserParserBACKENDS, DorisSQLParserParserBACKUP, DorisSQLParserParserBASE, DorisSQLParserParserBASELINE, DorisSQLParserParserBEGIN, DorisSQLParserParserBINARY, DorisSQLParserParserBITMAP_UNION, DorisSQLParserParserBLACKHOLE, DorisSQLParserParserBLACKLIST, DorisSQLParserParserBODY, DorisSQLParserParserBOOLEAN, DorisSQLParserParserBRANCH, DorisSQLParserParserBROKER, DorisSQLParserParserBUCKETS, DorisSQLParserParserBUILTIN, DorisSQLParserParserCACHE, DorisSQLParserParserCANCEL, DorisSQLParserParserCASE, DorisSQLParserParserCAST, DorisSQLParserParserCATALOG, DorisSQLParserParserCATALOGS, DorisSQLParserParserCEIL, DorisSQLParserParserCHAIN, DorisSQLParserParserCHAR, DorisSQLParserParserCHARSET, DorisSQLParserParserCLEAN, DorisSQLParserParserCLEAR, DorisSQLParserParserCLUSTER, DorisSQLParserParserCLUSTERS, DorisSQLParserParserCNGROUP, DorisSQLParserParserCNGROUPS, DorisSQLParserParserCOLLATION, DorisSQLParserParserCOLUMNS, DorisSQLParserParserCOMMENT, DorisSQLParserParserCOMMIT, DorisSQLParserParserCOMMITTED, DorisSQLParserParserCOMPACT, DorisSQLParserParserCOMPUTE, DorisSQLParserParserCONFIG, DorisSQLParserParserCONNECTION, DorisSQLParserParserCONSISTENT, DorisSQLParserParserCONVERT, DorisSQLParserParserCOSTS, DorisSQLParserParserCOUNT, DorisSQLParserParserCUME_DIST, DorisSQLParserParserCUMULATIVE, DorisSQLParserParserCURRENT, DorisSQLParserParserCURRENT_DATE, DorisSQLParserParserCURRENT_GROUP, DorisSQLParserParserCURRENT_ROLE, DorisSQLParserParserCURRENT_TIME, DorisSQLParserParserCURRENT_TIMESTAMP, DorisSQLParserParserCURRENT_USER, DorisSQLParserParserDATA, DorisSQLParserParserDATACACHE, DorisSQLParserParserDATABASE, DorisSQLParserParserDATE, DorisSQLParserParserDATETIME, DorisSQLParserParserDAY, DorisSQLParserParserDAYS, DorisSQLParserParserDEALLOCATE, DorisSQLParserParserDECOMMISSION, DorisSQLParserParserDENSE_RANK, DorisSQLParserParserDIALECT, DorisSQLParserParserDICTIONARY, DorisSQLParserParserDICTIONARY_GET, DorisSQLParserParserNTILE, DorisSQLParserParserDISABLE, DorisSQLParserParserDISTRIBUTED, DorisSQLParserParserDISTRIBUTION, DorisSQLParserParserDUPLICATE, DorisSQLParserParserDYNAMIC, DorisSQLParserParserENABLE, DorisSQLParserParserENCLOSE, DorisSQLParserParserEND, DorisSQLParserParserENGINE, DorisSQLParserParserENGINES, DorisSQLParserParserERRORS, DorisSQLParserParserESCAPE, DorisSQLParserParserEVENTS, DorisSQLParserParserEXCEPT, DorisSQLParserParserEXCLUDE, DorisSQLParserParserEXECUTE, DorisSQLParserParserEXISTS, DorisSQLParserParserEXPORT, DorisSQLParserParserEXTERNAL, DorisSQLParserParserEXTRACT, DorisSQLParserParserEVERY, DorisSQLParserParserFAILPOINT, DorisSQLParserParserFAILPOINTS, DorisSQLParserParserFALSE, DorisSQLParserParserFIELDS, DorisSQLParserParserFILE, DorisSQLParserParserFILTER, DorisSQLParserParserFIRST, DorisSQLParserParserFIRST_VALUE, DorisSQLParserParserFLOOR, DorisSQLParserParserFN, DorisSQLParserParserFOLLOWING, DorisSQLParserParserFOLLOWER, DorisSQLParserParserFORMAT, DorisSQLParserParserFREE, DorisSQLParserParserFRONTEND, DorisSQLParserParserFRONTENDS, DorisSQLParserParserFUNCTIONS, DorisSQLParserParserGLOBAL, DorisSQLParserParserGRANTS, DorisSQLParserParserGROUPING, DorisSQLParserParserGROUPING_ID, DorisSQLParserParserGROUP_CONCAT, DorisSQLParserParserHASH, DorisSQLParserParserHELP, DorisSQLParserParserHISTOGRAM, DorisSQLParserParserHLL_UNION, DorisSQLParserParserHOST, DorisSQLParserParserHOUR, DorisSQLParserParserHOURS, DorisSQLParserParserHUB, DorisSQLParserParserIDENTIFIED, DorisSQLParserParserIF, DorisSQLParserParserIMPERSONATE, DorisSQLParserParserIMAGE, DorisSQLParserParserINACTIVE, DorisSQLParserParserINCREMENTAL, DorisSQLParserParserINDEXES, DorisSQLParserParserINSTALL, DorisSQLParserParserINTEGRATION, DorisSQLParserParserINTEGRATIONS, DorisSQLParserParserINTERMEDIATE, DorisSQLParserParserINTERVAL, DorisSQLParserParserOVERWRITE, DorisSQLParserParserISOLATION, DorisSQLParserParserJOB, DorisSQLParserParserLABEL, DorisSQLParserParserLAG, DorisSQLParserParserLAST, DorisSQLParserParserLAST_VALUE, DorisSQLParserParserLEAD, DorisSQLParserParserLEFT, DorisSQLParserParserLESS, DorisSQLParserParserLEVEL, DorisSQLParserParserLIKE, DorisSQLParserParserLIST, DorisSQLParserParserLOCAL, DorisSQLParserParserLOCALTIME, DorisSQLParserParserLOCALTIMESTAMP, DorisSQLParserParserLOCATION, DorisSQLParserParserLOCATIONS, DorisSQLParserParserLOGS, DorisSQLParserParserLOGICAL, DorisSQLParserParserMANUAL, DorisSQLParserParserMAP, DorisSQLParserParserMAPPING, DorisSQLParserParserMAPPINGS, DorisSQLParserParserMASKING, DorisSQLParserParserMATCH, DorisSQLParserParserMATERIALIZED, DorisSQLParserParserMAX, DorisSQLParserParserMERGE, DorisSQLParserParserMIN, DorisSQLParserParserMINUTE, DorisSQLParserParserMINUTES, DorisSQLParserParserMINUS, DorisSQLParserParserMETA, DorisSQLParserParserMOD, DorisSQLParserParserMODE, DorisSQLParserParserMODIFY, DorisSQLParserParserMONTH, DorisSQLParserParserMULTIPLE, DorisSQLParserParserNAME, DorisSQLParserParserNAMES, DorisSQLParserParserNEGATIVE, DorisSQLParserParserNGRAMBF, DorisSQLParserParserNO, DorisSQLParserParserNODE, DorisSQLParserParserNODES, DorisSQLParserParserNONE, DorisSQLParserParserNULL, DorisSQLParserParserNULLS, DorisSQLParserParserNUMBER, DorisSQLParserParserNUMERIC, DorisSQLParserParserOBSERVER, DorisSQLParserParserOF, DorisSQLParserParserOFF, DorisSQLParserParserOFFSET, DorisSQLParserParserONLY, DorisSQLParserParserOPEN, DorisSQLParserParserOPERATE, DorisSQLParserParserOPTIMIZER, DorisSQLParserParserOPTION, DorisSQLParserParserPARAMETER, DorisSQLParserParserPARTITIONS, DorisSQLParserParserPASSWORD, DorisSQLParserParserPATH, DorisSQLParserParserPAUSE, DorisSQLParserParserPENDING, DorisSQLParserParserPERCENT_RANK, DorisSQLParserParserPERCENTILE_UNION, DorisSQLParserParserPLAN, DorisSQLParserParserPLUGIN, DorisSQLParserParserPLUGINS, DorisSQLParserParserPIPE, DorisSQLParserParserPIPES, DorisSQLParserParserPIVOT, DorisSQLParserParserPOLICY, DorisSQLParserParserPOLICIES, DorisSQLParserParserPRECEDING, DorisSQLParserParserPREDICATE, DorisSQLParserParserPRIORITY, DorisSQLParserParserPRIVILEGES, DorisSQLParserParserPROBABILITY, DorisSQLParserParserPROC, DorisSQLParserParserPROCESSLIST, DorisSQLParserParserPROFILE, DorisSQLParserParserPROFILELIST, DorisSQLParserParserPROPERTIES, DorisSQLParserParserPROPERTY, DorisSQLParserParserPROVIDER, DorisSQLParserParserPROVIDERS, DorisSQLParserParserQUALIFY, DorisSQLParserParserQUARTER, DorisSQLParserParserQUERY, DorisSQLParserParserQUERIES, DorisSQLParserParserQUEUE, DorisSQLParserParserQUOTA, DorisSQLParserParserRANDOM, DorisSQLParserParserRANK, DorisSQLParserParserREASON, DorisSQLParserParserRECOVER, DorisSQLParserParserREFRESH, DorisSQLParserParserREWRITE, DorisSQLParserParserREGEXP, DorisSQLParserParserREMOVE, DorisSQLParserParserREPAIR, DorisSQLParserParserREPEATABLE, DorisSQLParserParserREPLACE, DorisSQLParserParserREPLACE_IF_NOT_NULL, DorisSQLParserParserREPLICA, DorisSQLParserParserREPOSITORY, DorisSQLParserParserREPOSITORIES, DorisSQLParserParserRESOURCE, DorisSQLParserParserRESOURCES, DorisSQLParserParserRESTORE, DorisSQLParserParserRESUME, DorisSQLParserParserRETAIN, DorisSQLParserParserRETENTION, DorisSQLParserParserRETURNS, DorisSQLParserParserRETRY, DorisSQLParserParserREVERT, DorisSQLParserParserRIGHT, DorisSQLParserParserRLIKE, DorisSQLParserParserROLE, DorisSQLParserParserROLES, DorisSQLParserParserROLLBACK, DorisSQLParserParserROLLUP, DorisSQLParserParserROUTINE, DorisSQLParserParserROW, DorisSQLParserParserROW_NUMBER, DorisSQLParserParserRULE, DorisSQLParserParserRULES, DorisSQLParserParserRUNNING, DorisSQLParserParserSAMPLE, DorisSQLParserParserSCHEDULE, DorisSQLParserParserSCHEDULER, DorisSQLParserParserSCHEMA, DorisSQLParserParserSECOND, DorisSQLParserParserSECURITY, DorisSQLParserParserSEMI, DorisSQLParserParserSEPARATOR, DorisSQLParserParserSERIALIZABLE, DorisSQLParserParserSESSION, DorisSQLParserParserSETS, DorisSQLParserParserSIGNED, DorisSQLParserParserSKIP_HEADER, DorisSQLParserParserSNAPSHOT, DorisSQLParserParserSNAPSHOTS, DorisSQLParserParserSQLBLACKLIST, DorisSQLParserParserSTART, DorisSQLParserParserSTATS, DorisSQLParserParserSTATUS, DorisSQLParserParserSTOP, DorisSQLParserParserSTORAGE, DorisSQLParserParserSTREAM, DorisSQLParserParserSTRING, DorisSQLParserParserSUBMIT, DorisSQLParserParserSUM, DorisSQLParserParserSUSPEND, DorisSQLParserParserSYNC, DorisSQLParserParserSYSTEM_TIME, DorisSQLParserParserSWAP, DorisSQLParserParserSTRUCT, DorisSQLParserParserTABLES, DorisSQLParserParserTABLET, DorisSQLParserParserTABLETS, DorisSQLParserParserTAG, DorisSQLParserParserTASK, DorisSQLParserParserTEMPORARY, DorisSQLParserParserTHAN, DorisSQLParserParserTIME, DorisSQLParserParserTIMES, DorisSQLParserParserTIMESTAMP, DorisSQLParserParserTIMESTAMPADD, DorisSQLParserParserTIMESTAMPDIFF, DorisSQLParserParserTRANSACTION, DorisSQLParserParserTRANSLATE, DorisSQLParserParserTRACE, DorisSQLParserParserTRIGGERS, DorisSQLParserParserTRIM_SPACE, DorisSQLParserParserTRUE, DorisSQLParserParserTRUNCATE, DorisSQLParserParserTYPE, DorisSQLParserParserTYPES, DorisSQLParserParserUNBOUNDED, DorisSQLParserParserUNCOMMITTED, DorisSQLParserParserUNINSTALL, DorisSQLParserParserUNSET, DorisSQLParserParserUSAGE, DorisSQLParserParserUSER, DorisSQLParserParserUSERS, DorisSQLParserParserVALUE, DorisSQLParserParserVARBINARY, DorisSQLParserParserVARIABLES, DorisSQLParserParserVECTOR, DorisSQLParserParserVERBOSE, DorisSQLParserParserVERSION, DorisSQLParserParserVIEW, DorisSQLParserParserVIEWS, DorisSQLParserParserVOLUME, DorisSQLParserParserVOLUMES, DorisSQLParserParserWAREHOUSE, DorisSQLParserParserWAREHOUSES, DorisSQLParserParserWARNINGS, DorisSQLParserParserWEEK, DorisSQLParserParserWHITELIST, DorisSQLParserParserWORK, DorisSQLParserParserWRITE, DorisSQLParserParserYEAR, DorisSQLParserParserLOCK, DorisSQLParserParserUNLOCK, DorisSQLParserParserLOW_PRIORITY, DorisSQLParserParserDISK, DorisSQLParserParserBEFORE, DorisSQLParserParserFIELD, DorisSQLParserParserPERSISTENT, DorisSQLParserParserARRAY_ELEMENT, DorisSQLParserParserPLUS_SYMBOL, DorisSQLParserParserMINUS_SYMBOL, DorisSQLParserParserLOGICAL_NOT, DorisSQLParserParserBITNOT, DorisSQLParserParserAT, DorisSQLParserParserINTEGER_VALUE, DorisSQLParserParserDECIMAL_VALUE, DorisSQLParserParserDOUBLE_VALUE, DorisSQLParserParserSINGLE_QUOTED_TEXT, DorisSQLParserParserDOUBLE_QUOTED_TEXT, DorisSQLParserParserBINARY_SINGLE_QUOTED_TEXT, DorisSQLParserParserBINARY_DOUBLE_QUOTED_TEXT, DorisSQLParserParserLETTER_IDENTIFIER, DorisSQLParserParserDIGIT_IDENTIFIER, DorisSQLParserParserBACKQUOTED_IDENTIFIER, DorisSQLParserParserDOTDOTDOT:
		localctx = NewExpressionDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		p.SetState(6628)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 770, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6627)
				p.Match(DorisSQLParserParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(6630)
			p.booleanExpression(0)
		}

	case DorisSQLParserParserNOT:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6631)
			p.Match(DorisSQLParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6632)
			p.expression(3)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(6643)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 773, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(6641)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 772, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLogicalBinaryContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserParserRULE_expression)
				p.SetState(6635)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(6636)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*LogicalBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisSQLParserParserAND || _la == DorisSQLParserParserLOGICAL_AND) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*LogicalBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(6637)

					var _x = p.expression(3)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 2:
				localctx = NewLogicalBinaryContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserParserRULE_expression)
				p.SetState(6638)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(6639)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*LogicalBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisSQLParserParserOR || _la == DorisSQLParserParserLOGICAL_OR) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*LogicalBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(6640)

					var _x = p.expression(2)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(6645)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 773, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_expressionList
	return p
}

func InitEmptyExpressionListContext(p *ExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_expressionList
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (s *ExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ExpressionList() (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 854, DorisSQLParserParserRULE_expressionList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6646)
		p.expression(0)
	}
	p.SetState(6651)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 774, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6647)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6648)
				p.expression(0)
			}

		}
		p.SetState(6653)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 774, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanExpressionContext is an interface to support dynamic dispatch.
type IBooleanExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBooleanExpressionContext differentiates from other interfaces.
	IsBooleanExpressionContext()
}

type BooleanExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanExpressionContext() *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_booleanExpression
	return p
}

func InitEmptyBooleanExpressionContext(p *BooleanExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_booleanExpression
}

func (*BooleanExpressionContext) IsBooleanExpressionContext() {}

func NewBooleanExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_booleanExpression

	return p
}

func (s *BooleanExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanExpressionContext) CopyAll(ctx *BooleanExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BooleanExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ComparisonContext struct {
	BooleanExpressionContext
	left  IBooleanExpressionContext
	right IPredicateContext
}

func NewComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonContext {
	var p = new(ComparisonContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *ComparisonContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *ComparisonContext) GetRight() IPredicateContext { return s.right }

func (s *ComparisonContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *ComparisonContext) SetRight(v IPredicateContext) { s.right = v }

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ComparisonContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitComparison(s)
	}
}

func (s *ComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitComparison(s)

	default:
		return t.VisitChildren(s)
	}
}

type BooleanExpressionDefaultContext struct {
	BooleanExpressionContext
}

func NewBooleanExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanExpressionDefaultContext {
	var p = new(BooleanExpressionDefaultContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *BooleanExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionDefaultContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BooleanExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterBooleanExpressionDefault(s)
	}
}

func (s *BooleanExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitBooleanExpressionDefault(s)
	}
}

func (s *BooleanExpressionDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitBooleanExpressionDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type IsNullContext struct {
	BooleanExpressionContext
}

func NewIsNullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsNullContext {
	var p = new(IsNullContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *IsNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsNullContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *IsNullContext) IS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIS, 0)
}

func (s *IsNullContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNULL, 0)
}

func (s *IsNullContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *IsNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterIsNull(s)
	}
}

func (s *IsNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitIsNull(s)
	}
}

func (s *IsNullContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitIsNull(s)

	default:
		return t.VisitChildren(s)
	}
}

type ScalarSubqueryContext struct {
	BooleanExpressionContext
}

func NewScalarSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ScalarSubqueryContext {
	var p = new(ScalarSubqueryContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *ScalarSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarSubqueryContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ScalarSubqueryContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ScalarSubqueryContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *ScalarSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterScalarSubquery(s)
	}
}

func (s *ScalarSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitScalarSubquery(s)
	}
}

func (s *ScalarSubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitScalarSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) BooleanExpression() (localctx IBooleanExpressionContext) {
	return p.booleanExpression(0)
}

func (p *DorisSQLParserParser) booleanExpression(_p int) (localctx IBooleanExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBooleanExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBooleanExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 856
	p.EnterRecursionRule(localctx, 856, DorisSQLParserParserRULE_booleanExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewBooleanExpressionDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(6655)
		p.Predicate()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(6675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 777, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(6673)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 776, p.GetParserRuleContext()) {
			case 1:
				localctx = NewIsNullContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserParserRULE_booleanExpression)
				p.SetState(6657)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(6658)
					p.Match(DorisSQLParserParserIS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(6660)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisSQLParserParserNOT {
					{
						p.SetState(6659)
						p.Match(DorisSQLParserParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(6662)
					p.Match(DorisSQLParserParserNULL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				localctx = NewComparisonContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*ComparisonContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserParserRULE_booleanExpression)
				p.SetState(6663)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(6664)
					p.ComparisonOperator()
				}
				{
					p.SetState(6665)

					var _x = p.Predicate()

					localctx.(*ComparisonContext).right = _x
				}

			case 3:
				localctx = NewScalarSubqueryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserParserRULE_booleanExpression)
				p.SetState(6667)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(6668)
					p.ComparisonOperator()
				}
				{
					p.SetState(6669)
					p.Match(DorisSQLParserParserT__1)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6670)
					p.QueryRelation()
				}
				{
					p.SetState(6671)
					p.Match(DorisSQLParserParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(6677)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 777, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_valueExpression returns the _valueExpression rule contexts.
	Get_valueExpression() IValueExpressionContext

	// Set_valueExpression sets the _valueExpression rule contexts.
	Set_valueExpression(IValueExpressionContext)

	// Getter signatures
	ValueExpression() IValueExpressionContext
	PredicateOperations() IPredicateOperationsContext
	TupleInSubquery() ITupleInSubqueryContext

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	_valueExpression IValueExpressionContext
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_predicate
	return p
}

func InitEmptyPredicateContext(p *PredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_predicate
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) Get_valueExpression() IValueExpressionContext { return s._valueExpression }

func (s *PredicateContext) Set_valueExpression(v IValueExpressionContext) { s._valueExpression = v }

func (s *PredicateContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicateContext) PredicateOperations() IPredicateOperationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateOperationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateOperationsContext)
}

func (s *PredicateContext) TupleInSubquery() ITupleInSubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleInSubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleInSubqueryContext)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPredicate(s)
	}
}

func (s *PredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPredicate(s)
	}
}

func (s *PredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Predicate() (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 858, DorisSQLParserParserRULE_predicate)
	p.SetState(6683)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 779, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6678)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext)._valueExpression = _x
		}
		p.SetState(6680)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 778, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6679)
				p.PredicateOperations(localctx.(*PredicateContext).Get_valueExpression())
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6682)
			p.TupleInSubquery()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleInSubqueryContext is an interface to support dynamic dispatch.
type ITupleInSubqueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	IN() antlr.TerminalNode
	QueryRelation() IQueryRelationContext
	NOT() antlr.TerminalNode

	// IsTupleInSubqueryContext differentiates from other interfaces.
	IsTupleInSubqueryContext()
}

type TupleInSubqueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleInSubqueryContext() *TupleInSubqueryContext {
	var p = new(TupleInSubqueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_tupleInSubquery
	return p
}

func InitEmptyTupleInSubqueryContext(p *TupleInSubqueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_tupleInSubquery
}

func (*TupleInSubqueryContext) IsTupleInSubqueryContext() {}

func NewTupleInSubqueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleInSubqueryContext {
	var p = new(TupleInSubqueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_tupleInSubquery

	return p
}

func (s *TupleInSubqueryContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleInSubqueryContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TupleInSubqueryContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TupleInSubqueryContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *TupleInSubqueryContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *TupleInSubqueryContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *TupleInSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleInSubqueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleInSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTupleInSubquery(s)
	}
}

func (s *TupleInSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTupleInSubquery(s)
	}
}

func (s *TupleInSubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTupleInSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) TupleInSubquery() (localctx ITupleInSubqueryContext) {
	localctx = NewTupleInSubqueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 860, DorisSQLParserParserRULE_tupleInSubquery)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6685)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6686)
		p.expression(0)
	}
	p.SetState(6689)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == DorisSQLParserParserT__2 {
		{
			p.SetState(6687)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6688)
			p.expression(0)
		}

		p.SetState(6691)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6693)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserNOT {
		{
			p.SetState(6694)
			p.Match(DorisSQLParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(6697)
		p.Match(DorisSQLParserParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6698)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6699)
		p.QueryRelation()
	}
	{
		p.SetState(6700)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateOperationsContext is an interface to support dynamic dispatch.
type IPredicateOperationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value attribute.
	GetValue() ParserRuleContext

	// SetValue sets the value attribute.
	SetValue(ParserRuleContext)

	// IsPredicateOperationsContext differentiates from other interfaces.
	IsPredicateOperationsContext()
}

type PredicateOperationsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  ParserRuleContext
}

func NewEmptyPredicateOperationsContext() *PredicateOperationsContext {
	var p = new(PredicateOperationsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_predicateOperations
	return p
}

func InitEmptyPredicateOperationsContext(p *PredicateOperationsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_predicateOperations
}

func (*PredicateOperationsContext) IsPredicateOperationsContext() {}

func NewPredicateOperationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, value ParserRuleContext) *PredicateOperationsContext {
	var p = new(PredicateOperationsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_predicateOperations

	p.value = value

	return p
}

func (s *PredicateOperationsContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateOperationsContext) GetValue() ParserRuleContext { return s.value }

func (s *PredicateOperationsContext) SetValue(v ParserRuleContext) { s.value = v }

func (s *PredicateOperationsContext) CopyAll(ctx *PredicateOperationsContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
	s.value = ctx.value
}

func (s *PredicateOperationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateOperationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LikeContext struct {
	PredicateOperationsContext
	pattern IValueExpressionContext
}

func NewLikeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikeContext {
	var p = new(LikeContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *LikeContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *LikeContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *LikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *LikeContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRLIKE, 0)
}

func (s *LikeContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREGEXP, 0)
}

func (s *LikeContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *LikeContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *LikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterLike(s)
	}
}

func (s *LikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitLike(s)
	}
}

func (s *LikeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitLike(s)

	default:
		return t.VisitChildren(s)
	}
}

type InSubqueryContext struct {
	PredicateOperationsContext
}

func NewInSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InSubqueryContext {
	var p = new(InSubqueryContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *InSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InSubqueryContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *InSubqueryContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *InSubqueryContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *InSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterInSubquery(s)
	}
}

func (s *InSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitInSubquery(s)
	}
}

func (s *InSubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitInSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

type InListContext struct {
	PredicateOperationsContext
}

func NewInListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InListContext {
	var p = new(InListContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *InListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InListContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *InListContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *InListContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *InListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterInList(s)
	}
}

func (s *InListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitInList(s)
	}
}

func (s *InListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitInList(s)

	default:
		return t.VisitChildren(s)
	}
}

type BetweenContext struct {
	PredicateOperationsContext
	lower IValueExpressionContext
	upper IPredicateContext
}

func NewBetweenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenContext {
	var p = new(BetweenContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *BetweenContext) GetLower() IValueExpressionContext { return s.lower }

func (s *BetweenContext) GetUpper() IPredicateContext { return s.upper }

func (s *BetweenContext) SetLower(v IValueExpressionContext) { s.lower = v }

func (s *BetweenContext) SetUpper(v IPredicateContext) { s.upper = v }

func (s *BetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBETWEEN, 0)
}

func (s *BetweenContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAND, 0)
}

func (s *BetweenContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *BetweenContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BetweenContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *BetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterBetween(s)
	}
}

func (s *BetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitBetween(s)
	}
}

func (s *BetweenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitBetween(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PredicateOperations(value ParserRuleContext) (localctx IPredicateOperationsContext) {
	localctx = NewPredicateOperationsContext(p, p.GetParserRuleContext(), p.GetState(), value)
	p.EnterRule(localctx, 862, DorisSQLParserParserRULE_predicateOperations)
	var _la int

	p.SetState(6731)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 786, p.GetParserRuleContext()) {
	case 1:
		localctx = NewInSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6703)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserNOT {
			{
				p.SetState(6702)
				p.Match(DorisSQLParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6705)
			p.Match(DorisSQLParserParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6706)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6707)
			p.QueryRelation()
		}
		{
			p.SetState(6708)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewInListContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(6711)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserNOT {
			{
				p.SetState(6710)
				p.Match(DorisSQLParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6713)
			p.Match(DorisSQLParserParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6714)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6715)
			p.ExpressionList()
		}
		{
			p.SetState(6716)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewBetweenContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(6719)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserNOT {
			{
				p.SetState(6718)
				p.Match(DorisSQLParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6721)
			p.Match(DorisSQLParserParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6722)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).lower = _x
		}
		{
			p.SetState(6723)
			p.Match(DorisSQLParserParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6724)

			var _x = p.Predicate()

			localctx.(*BetweenContext).upper = _x
		}

	case 4:
		localctx = NewLikeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(6727)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserNOT {
			{
				p.SetState(6726)
				p.Match(DorisSQLParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6729)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserLIKE || _la == DorisSQLParserParserREGEXP || _la == DorisSQLParserParserRLIKE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6730)

			var _x = p.valueExpression(0)

			localctx.(*LikeContext).pattern = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueExpressionContext is an interface to support dynamic dispatch.
type IValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsValueExpressionContext differentiates from other interfaces.
	IsValueExpressionContext()
}

type ValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExpressionContext() *ValueExpressionContext {
	var p = new(ValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_valueExpression
	return p
}

func InitEmptyValueExpressionContext(p *ValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_valueExpression
}

func (*ValueExpressionContext) IsValueExpressionContext() {}

func NewValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExpressionContext {
	var p = new(ValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_valueExpression

	return p
}

func (s *ValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExpressionContext) CopyAll(ctx *ValueExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ValueExpressionDefaultContext struct {
	ValueExpressionContext
}

func NewValueExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValueExpressionDefaultContext {
	var p = new(ValueExpressionDefaultContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ValueExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionDefaultContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ValueExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitValueExpressionDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArithmeticBinaryContext struct {
	ValueExpressionContext
	left     IValueExpressionContext
	operator antlr.Token
	right    IValueExpressionContext
}

func NewArithmeticBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticBinaryContext {
	var p = new(ArithmeticBinaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticBinaryContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ArithmeticBinaryContext) GetRight() IValueExpressionContext { return s.right }

func (s *ArithmeticBinaryContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ArithmeticBinaryContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ArithmeticBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticBinaryContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArithmeticBinaryContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticBinaryContext) BITXOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBITXOR, 0)
}

func (s *ArithmeticBinaryContext) ASTERISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserASTERISK_SYMBOL, 0)
}

func (s *ArithmeticBinaryContext) SLASH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSLASH_SYMBOL, 0)
}

func (s *ArithmeticBinaryContext) PERCENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPERCENT_SYMBOL, 0)
}

func (s *ArithmeticBinaryContext) INT_DIV() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINT_DIV, 0)
}

func (s *ArithmeticBinaryContext) MOD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMOD, 0)
}

func (s *ArithmeticBinaryContext) PLUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPLUS_SYMBOL, 0)
}

func (s *ArithmeticBinaryContext) MINUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMINUS_SYMBOL, 0)
}

func (s *ArithmeticBinaryContext) BITAND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBITAND, 0)
}

func (s *ArithmeticBinaryContext) BITOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBITOR, 0)
}

func (s *ArithmeticBinaryContext) BIT_SHIFT_LEFT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBIT_SHIFT_LEFT, 0)
}

func (s *ArithmeticBinaryContext) BIT_SHIFT_RIGHT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBIT_SHIFT_RIGHT, 0)
}

func (s *ArithmeticBinaryContext) BIT_SHIFT_RIGHT_LOGICAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBIT_SHIFT_RIGHT_LOGICAL, 0)
}

func (s *ArithmeticBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitArithmeticBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ValueExpression() (localctx IValueExpressionContext) {
	return p.valueExpression(0)
}

func (p *DorisSQLParserParser) valueExpression(_p int) (localctx IValueExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewValueExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 864
	p.EnterRecursionRule(localctx, 864, DorisSQLParserParserRULE_valueExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewValueExpressionDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(6734)
		p.primaryExpression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(6762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 788, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(6760)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 787, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserParserRULE_valueExpression)
				p.SetState(6736)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(6737)

					var _m = p.Match(DorisSQLParserParserBITXOR)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6738)

					var _x = p.valueExpression(9)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 2:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserParserRULE_valueExpression)
				p.SetState(6739)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(6740)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisSQLParserParserMOD || ((int64((_la-502)) & ^0x3f) == 0 && ((int64(1)<<(_la-502))&71) != 0)) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(6741)

					var _x = p.valueExpression(8)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 3:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserParserRULE_valueExpression)
				p.SetState(6742)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(6743)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisSQLParserParserPLUS_SYMBOL || _la == DorisSQLParserParserMINUS_SYMBOL) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(6744)

					var _x = p.valueExpression(7)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 4:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserParserRULE_valueExpression)
				p.SetState(6745)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(6746)

					var _m = p.Match(DorisSQLParserParserBITAND)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6747)

					var _x = p.valueExpression(6)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 5:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserParserRULE_valueExpression)
				p.SetState(6748)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(6749)

					var _m = p.Match(DorisSQLParserParserBITOR)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6750)

					var _x = p.valueExpression(5)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 6:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserParserRULE_valueExpression)
				p.SetState(6751)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(6752)

					var _m = p.Match(DorisSQLParserParserBIT_SHIFT_LEFT)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6753)

					var _x = p.valueExpression(4)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 7:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserParserRULE_valueExpression)
				p.SetState(6754)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(6755)

					var _m = p.Match(DorisSQLParserParserBIT_SHIFT_RIGHT)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6756)

					var _x = p.valueExpression(3)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 8:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserParserRULE_valueExpression)
				p.SetState(6757)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(6758)

					var _m = p.Match(DorisSQLParserParserBIT_SHIFT_RIGHT_LOGICAL)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6759)

					var _x = p.valueExpression(2)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(6764)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 788, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_primaryExpression
	return p
}

func InitEmptyPrimaryExpressionContext(p *PrimaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_primaryExpression
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) CopyAll(ctx *PrimaryExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DereferenceContext struct {
	PrimaryExpressionContext
	base      IPrimaryExpressionContext
	fieldName IIdentifierContext
}

func NewDereferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DereferenceContext {
	var p = new(DereferenceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DereferenceContext) GetBase() IPrimaryExpressionContext { return s.base }

func (s *DereferenceContext) GetFieldName() IIdentifierContext { return s.fieldName }

func (s *DereferenceContext) SetBase(v IPrimaryExpressionContext) { s.base = v }

func (s *DereferenceContext) SetFieldName(v IIdentifierContext) { s.fieldName = v }

func (s *DereferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DereferenceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *DereferenceContext) DOT_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDOT_IDENTIFIER, 0)
}

func (s *DereferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DereferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDereference(s)
	}
}

func (s *DereferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDereference(s)
	}
}

func (s *DereferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDereference(s)

	default:
		return t.VisitChildren(s)
	}
}

type OdbcFunctionCallExpressionContext struct {
	PrimaryExpressionContext
}

func NewOdbcFunctionCallExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OdbcFunctionCallExpressionContext {
	var p = new(OdbcFunctionCallExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *OdbcFunctionCallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OdbcFunctionCallExpressionContext) FN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFN, 0)
}

func (s *OdbcFunctionCallExpressionContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *OdbcFunctionCallExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterOdbcFunctionCallExpression(s)
	}
}

func (s *OdbcFunctionCallExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitOdbcFunctionCallExpression(s)
	}
}

func (s *OdbcFunctionCallExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitOdbcFunctionCallExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MatchExprContext struct {
	PrimaryExpressionContext
	left  IPrimaryExpressionContext
	right IPrimaryExpressionContext
}

func NewMatchExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MatchExprContext {
	var p = new(MatchExprContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *MatchExprContext) GetLeft() IPrimaryExpressionContext { return s.left }

func (s *MatchExprContext) GetRight() IPrimaryExpressionContext { return s.right }

func (s *MatchExprContext) SetLeft(v IPrimaryExpressionContext) { s.left = v }

func (s *MatchExprContext) SetRight(v IPrimaryExpressionContext) { s.right = v }

func (s *MatchExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchExprContext) MATCH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMATCH, 0)
}

func (s *MatchExprContext) AllPrimaryExpression() []IPrimaryExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrimaryExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrimaryExpressionContext); ok {
			tst[i] = t.(IPrimaryExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MatchExprContext) PrimaryExpression(i int) IPrimaryExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *MatchExprContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *MatchExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterMatchExpr(s)
	}
}

func (s *MatchExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitMatchExpr(s)
	}
}

func (s *MatchExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitMatchExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnRefContext struct {
	PrimaryExpressionContext
}

func NewColumnRefContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnRefContext {
	var p = new(ColumnRefContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ColumnRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnRefContext) ColumnReference() IColumnReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnReferenceContext)
}

func (s *ColumnRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterColumnRef(s)
	}
}

func (s *ColumnRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitColumnRef(s)
	}
}

func (s *ColumnRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitColumnRef(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConvertContext struct {
	PrimaryExpressionContext
}

func NewConvertContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConvertContext {
	var p = new(ConvertContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ConvertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCONVERT, 0)
}

func (s *ConvertContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConvertContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ConvertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterConvert(s)
	}
}

func (s *ConvertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitConvert(s)
	}
}

func (s *ConvertContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitConvert(s)

	default:
		return t.VisitChildren(s)
	}
}

type CollectionSubscriptContext struct {
	PrimaryExpressionContext
	value IPrimaryExpressionContext
	index IValueExpressionContext
}

func NewCollectionSubscriptContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollectionSubscriptContext {
	var p = new(CollectionSubscriptContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CollectionSubscriptContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *CollectionSubscriptContext) GetIndex() IValueExpressionContext { return s.index }

func (s *CollectionSubscriptContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *CollectionSubscriptContext) SetIndex(v IValueExpressionContext) { s.index = v }

func (s *CollectionSubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionSubscriptContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *CollectionSubscriptContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *CollectionSubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCollectionSubscript(s)
	}
}

func (s *CollectionSubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCollectionSubscript(s)
	}
}

func (s *CollectionSubscriptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCollectionSubscript(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralContext struct {
	PrimaryExpressionContext
}

func NewLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralContext {
	var p = new(LiteralContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) LiteralExpression() ILiteralExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionContext)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type CastContext struct {
	PrimaryExpressionContext
}

func NewCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastContext {
	var p = new(CastContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastContext) CAST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCAST, 0)
}

func (s *CastContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *CastContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *CastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCast(s)
	}
}

func (s *CastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCast(s)
	}
}

func (s *CastContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCast(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesizedExpressionContext struct {
	PrimaryExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitParenthesizedExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type UserVariableExpressionContext struct {
	PrimaryExpressionContext
}

func NewUserVariableExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserVariableExpressionContext {
	var p = new(UserVariableExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *UserVariableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserVariableExpressionContext) UserVariable() IUserVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariableContext)
}

func (s *UserVariableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterUserVariableExpression(s)
	}
}

func (s *UserVariableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitUserVariableExpression(s)
	}
}

func (s *UserVariableExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitUserVariableExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type FunctionCallExpressionContext struct {
	PrimaryExpressionContext
}

func NewFunctionCallExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallExpressionContext {
	var p = new(FunctionCallExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *FunctionCallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallExpressionContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *FunctionCallExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterFunctionCallExpression(s)
	}
}

func (s *FunctionCallExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitFunctionCallExpression(s)
	}
}

func (s *FunctionCallExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitFunctionCallExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleCaseContext struct {
	PrimaryExpressionContext
	caseExpr       IExpressionContext
	elseExpression IExpressionContext
}

func NewSimpleCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleCaseContext {
	var p = new(SimpleCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SimpleCaseContext) GetCaseExpr() IExpressionContext { return s.caseExpr }

func (s *SimpleCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SimpleCaseContext) SetCaseExpr(v IExpressionContext) { s.caseExpr = v }

func (s *SimpleCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SimpleCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCASE, 0)
}

func (s *SimpleCaseContext) END() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEND, 0)
}

func (s *SimpleCaseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SimpleCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserELSE, 0)
}

func (s *SimpleCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSimpleCase(s)
	}
}

func (s *SimpleCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSimpleCase(s)
	}
}

func (s *SimpleCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSimpleCase(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrowExpressionContext struct {
	PrimaryExpressionContext
}

func NewArrowExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrowExpressionContext {
	var p = new(ArrowExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArrowExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowExpressionContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ArrowExpressionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserARROW, 0)
}

func (s *ArrowExpressionContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ArrowExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterArrowExpression(s)
	}
}

func (s *ArrowExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitArrowExpression(s)
	}
}

func (s *ArrowExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitArrowExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type SystemVariableExpressionContext struct {
	PrimaryExpressionContext
}

func NewSystemVariableExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SystemVariableExpressionContext {
	var p = new(SystemVariableExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SystemVariableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SystemVariableExpressionContext) SystemVariable() ISystemVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISystemVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISystemVariableContext)
}

func (s *SystemVariableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSystemVariableExpression(s)
	}
}

func (s *SystemVariableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSystemVariableExpression(s)
	}
}

func (s *SystemVariableExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSystemVariableExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConcatContext struct {
	PrimaryExpressionContext
	left  IPrimaryExpressionContext
	right IPrimaryExpressionContext
}

func NewConcatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConcatContext {
	var p = new(ConcatContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ConcatContext) GetLeft() IPrimaryExpressionContext { return s.left }

func (s *ConcatContext) GetRight() IPrimaryExpressionContext { return s.right }

func (s *ConcatContext) SetLeft(v IPrimaryExpressionContext) { s.left = v }

func (s *ConcatContext) SetRight(v IPrimaryExpressionContext) { s.right = v }

func (s *ConcatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCONCAT, 0)
}

func (s *ConcatContext) AllPrimaryExpression() []IPrimaryExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrimaryExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrimaryExpressionContext); ok {
			tst[i] = t.(IPrimaryExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ConcatContext) PrimaryExpression(i int) IPrimaryExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ConcatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterConcat(s)
	}
}

func (s *ConcatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitConcat(s)
	}
}

func (s *ConcatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitConcat(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubqueryExpressionContext struct {
	PrimaryExpressionContext
}

func NewSubqueryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryExpressionContext {
	var p = new(SubqueryExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubqueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryExpressionContext) Subquery() ISubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *SubqueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSubqueryExpression(s)
	}
}

func (s *SubqueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSubqueryExpression(s)
	}
}

func (s *SubqueryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSubqueryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LambdaFunctionExprContext struct {
	PrimaryExpressionContext
}

func NewLambdaFunctionExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LambdaFunctionExprContext {
	var p = new(LambdaFunctionExprContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LambdaFunctionExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaFunctionExprContext) ARROW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserARROW, 0)
}

func (s *LambdaFunctionExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaFunctionExprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LambdaFunctionExprContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *LambdaFunctionExprContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *LambdaFunctionExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterLambdaFunctionExpr(s)
	}
}

func (s *LambdaFunctionExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitLambdaFunctionExpr(s)
	}
}

func (s *LambdaFunctionExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitLambdaFunctionExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type DictionaryGetExprContext struct {
	PrimaryExpressionContext
}

func NewDictionaryGetExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DictionaryGetExprContext {
	var p = new(DictionaryGetExprContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DictionaryGetExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryGetExprContext) DICTIONARY_GET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDICTIONARY_GET, 0)
}

func (s *DictionaryGetExprContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *DictionaryGetExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDictionaryGetExpr(s)
	}
}

func (s *DictionaryGetExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDictionaryGetExpr(s)
	}
}

func (s *DictionaryGetExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDictionaryGetExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type CollateContext struct {
	PrimaryExpressionContext
}

func NewCollateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollateContext {
	var p = new(CollateContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *CollateContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLLATE, 0)
}

func (s *CollateContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CollateContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CollateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCollate(s)
	}
}

func (s *CollateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCollate(s)
	}
}

func (s *CollateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCollate(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayConstructorContext struct {
	PrimaryExpressionContext
}

func NewArrayConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayConstructorContext {
	var p = new(ArrayConstructorContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArrayConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayConstructorContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *ArrayConstructorContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArrayConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitArrayConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

type MapConstructorContext struct {
	PrimaryExpressionContext
}

func NewMapConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MapConstructorContext {
	var p = new(MapConstructorContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *MapConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapConstructorContext) MapType() IMapTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapTypeContext)
}

func (s *MapConstructorContext) MapExpressionList() IMapExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapExpressionListContext)
}

func (s *MapConstructorContext) MAP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMAP, 0)
}

func (s *MapConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterMapConstructor(s)
	}
}

func (s *MapConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitMapConstructor(s)
	}
}

func (s *MapConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitMapConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArraySliceContext struct {
	PrimaryExpressionContext
	start_ antlr.Token
	end    antlr.Token
}

func NewArraySliceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArraySliceContext {
	var p = new(ArraySliceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArraySliceContext) GetStart_() antlr.Token { return s.start_ }

func (s *ArraySliceContext) GetEnd() antlr.Token { return s.end }

func (s *ArraySliceContext) SetStart_(v antlr.Token) { s.start_ = v }

func (s *ArraySliceContext) SetEnd(v antlr.Token) { s.end = v }

func (s *ArraySliceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArraySliceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ArraySliceContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserINTEGER_VALUE)
}

func (s *ArraySliceContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, i)
}

func (s *ArraySliceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterArraySlice(s)
	}
}

func (s *ArraySliceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitArraySlice(s)
	}
}

func (s *ArraySliceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitArraySlice(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExistsContext struct {
	PrimaryExpressionContext
}

func NewExistsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsContext {
	var p = new(ExistsContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *ExistsContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *ExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterExists(s)
	}
}

func (s *ExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitExists(s)
	}
}

func (s *ExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitExists(s)

	default:
		return t.VisitChildren(s)
	}
}

type SearchedCaseContext struct {
	PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSearchedCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SearchedCaseContext {
	var p = new(SearchedCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SearchedCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SearchedCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SearchedCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCASE, 0)
}

func (s *SearchedCaseContext) END() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEND, 0)
}

func (s *SearchedCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SearchedCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SearchedCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserELSE, 0)
}

func (s *SearchedCaseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SearchedCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSearchedCase(s)
	}
}

func (s *SearchedCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSearchedCase(s)
	}
}

func (s *SearchedCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSearchedCase(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArithmeticUnaryContext struct {
	PrimaryExpressionContext
	operator antlr.Token
}

func NewArithmeticUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticUnaryContext {
	var p = new(ArithmeticUnaryContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArithmeticUnaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticUnaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticUnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticUnaryContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ArithmeticUnaryContext) MINUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMINUS_SYMBOL, 0)
}

func (s *ArithmeticUnaryContext) PLUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPLUS_SYMBOL, 0)
}

func (s *ArithmeticUnaryContext) BITNOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBITNOT, 0)
}

func (s *ArithmeticUnaryContext) LOGICAL_NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOGICAL_NOT, 0)
}

func (s *ArithmeticUnaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitArithmeticUnary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	return p.primaryExpression(0)
}

func (p *DorisSQLParserParser) primaryExpression(_p int) (localctx IPrimaryExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 866
	p.EnterRecursionRule(localctx, 866, DorisSQLParserParserRULE_primaryExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6870)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 799, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUserVariableExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(6766)
			p.UserVariable()
		}

	case 2:
		localctx = NewSystemVariableExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6767)
			p.SystemVariable()
		}

	case 3:
		localctx = NewDictionaryGetExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6768)
			p.Match(DorisSQLParserParserDICTIONARY_GET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6769)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6770)
			p.ExpressionList()
		}
		{
			p.SetState(6771)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewFunctionCallExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6773)
			p.FunctionCall()
		}

	case 5:
		localctx = NewOdbcFunctionCallExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6774)
			p.Match(DorisSQLParserParserT__8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6775)
			p.Match(DorisSQLParserParserFN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6776)
			p.FunctionCall()
		}
		{
			p.SetState(6777)
			p.Match(DorisSQLParserParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6779)
			p.LiteralExpression()
		}

	case 7:
		localctx = NewColumnRefContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6780)
			p.ColumnReference()
		}

	case 8:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6781)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ArithmeticUnaryContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-500)) & ^0x3f) == 0 && ((int64(1)<<(_la-500))&4099) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ArithmeticUnaryContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6782)
			p.primaryExpression(18)
		}

	case 9:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6783)

			var _m = p.Match(DorisSQLParserParserLOGICAL_NOT)

			localctx.(*ArithmeticUnaryContext).operator = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6784)
			p.primaryExpression(17)
		}

	case 10:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6785)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6786)
			p.expression(0)
		}
		{
			p.SetState(6787)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewExistsContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6789)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6790)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6791)
			p.QueryRelation()
		}
		{
			p.SetState(6792)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewSubqueryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6794)
			p.Subquery()
		}

	case 13:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6795)
			p.Match(DorisSQLParserParserCAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6796)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6797)
			p.expression(0)
		}
		{
			p.SetState(6798)
			p.Match(DorisSQLParserParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6799)
			p.Type_()
		}
		{
			p.SetState(6800)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		localctx = NewConvertContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6802)
			p.Match(DorisSQLParserParserCONVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6803)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6804)
			p.expression(0)
		}
		{
			p.SetState(6805)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6806)
			p.Type_()
		}
		{
			p.SetState(6807)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		localctx = NewSimpleCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6809)
			p.Match(DorisSQLParserParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6810)

			var _x = p.expression(0)

			localctx.(*SimpleCaseContext).caseExpr = _x
		}
		p.SetState(6812)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == DorisSQLParserParserWHEN {
			{
				p.SetState(6811)
				p.WhenClause()
			}

			p.SetState(6814)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(6818)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserELSE {
			{
				p.SetState(6816)
				p.Match(DorisSQLParserParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6817)

				var _x = p.expression(0)

				localctx.(*SimpleCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(6820)
			p.Match(DorisSQLParserParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		localctx = NewSearchedCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6822)
			p.Match(DorisSQLParserParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6824)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == DorisSQLParserParserWHEN {
			{
				p.SetState(6823)
				p.WhenClause()
			}

			p.SetState(6826)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(6830)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserELSE {
			{
				p.SetState(6828)
				p.Match(DorisSQLParserParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6829)

				var _x = p.expression(0)

				localctx.(*SearchedCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(6832)
			p.Match(DorisSQLParserParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		localctx = NewArrayConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(6835)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserARRAY {
			{
				p.SetState(6834)
				p.ArrayType()
			}

		}
		{
			p.SetState(6837)
			p.Match(DorisSQLParserParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6839)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(6838)
				p.ExpressionList()
			}

		}
		{
			p.SetState(6841)
			p.Match(DorisSQLParserParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		localctx = NewMapConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6842)
			p.MapType()
		}
		{
			p.SetState(6843)
			p.Match(DorisSQLParserParserT__8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6845)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(6844)
				p.MapExpressionList()
			}

		}
		{
			p.SetState(6847)
			p.Match(DorisSQLParserParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		localctx = NewMapConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6849)
			p.Match(DorisSQLParserParserMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6850)
			p.Match(DorisSQLParserParserT__8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6852)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(6851)
				p.MapExpressionList()
			}

		}
		{
			p.SetState(6854)
			p.Match(DorisSQLParserParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		localctx = NewLambdaFunctionExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(6857)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserParserACCESS, DorisSQLParserParserACTIVE, DorisSQLParserParserADMIN, DorisSQLParserParserADVISOR, DorisSQLParserParserAFTER, DorisSQLParserParserAGGREGATE, DorisSQLParserParserANTI, DorisSQLParserParserAPPLY, DorisSQLParserParserARRAY_AGG, DorisSQLParserParserARRAY_AGG_DISTINCT, DorisSQLParserParserASYNC, DorisSQLParserParserAUTHORS, DorisSQLParserParserAUTHENTICATION, DorisSQLParserParserAUTOMATED, DorisSQLParserParserAUTO_INCREMENT, DorisSQLParserParserAVG, DorisSQLParserParserBACKEND, DorisSQLParserParserBACKENDS, DorisSQLParserParserBACKUP, DorisSQLParserParserBASE, DorisSQLParserParserBASELINE, DorisSQLParserParserBEGIN, DorisSQLParserParserBINARY, DorisSQLParserParserBITMAP_UNION, DorisSQLParserParserBLACKHOLE, DorisSQLParserParserBLACKLIST, DorisSQLParserParserBODY, DorisSQLParserParserBOOLEAN, DorisSQLParserParserBRANCH, DorisSQLParserParserBROKER, DorisSQLParserParserBUCKETS, DorisSQLParserParserBUILTIN, DorisSQLParserParserCACHE, DorisSQLParserParserCANCEL, DorisSQLParserParserCAST, DorisSQLParserParserCATALOG, DorisSQLParserParserCATALOGS, DorisSQLParserParserCEIL, DorisSQLParserParserCHAIN, DorisSQLParserParserCHARSET, DorisSQLParserParserCLEAN, DorisSQLParserParserCLEAR, DorisSQLParserParserCLUSTER, DorisSQLParserParserCLUSTERS, DorisSQLParserParserCNGROUP, DorisSQLParserParserCNGROUPS, DorisSQLParserParserCOLLATION, DorisSQLParserParserCOLUMNS, DorisSQLParserParserCOMMENT, DorisSQLParserParserCOMMIT, DorisSQLParserParserCOMMITTED, DorisSQLParserParserCOMPACT, DorisSQLParserParserCOMPUTE, DorisSQLParserParserCONFIG, DorisSQLParserParserCONNECTION, DorisSQLParserParserCONSISTENT, DorisSQLParserParserCOSTS, DorisSQLParserParserCOUNT, DorisSQLParserParserCUME_DIST, DorisSQLParserParserCUMULATIVE, DorisSQLParserParserCURRENT, DorisSQLParserParserDATA, DorisSQLParserParserDATACACHE, DorisSQLParserParserDATE, DorisSQLParserParserDATETIME, DorisSQLParserParserDAY, DorisSQLParserParserDAYS, DorisSQLParserParserDEALLOCATE, DorisSQLParserParserDECOMMISSION, DorisSQLParserParserDIALECT, DorisSQLParserParserDICTIONARY, DorisSQLParserParserDICTIONARY_GET, DorisSQLParserParserDISABLE, DorisSQLParserParserDISTRIBUTED, DorisSQLParserParserDISTRIBUTION, DorisSQLParserParserDUPLICATE, DorisSQLParserParserDYNAMIC, DorisSQLParserParserENABLE, DorisSQLParserParserENCLOSE, DorisSQLParserParserEND, DorisSQLParserParserENGINE, DorisSQLParserParserENGINES, DorisSQLParserParserERRORS, DorisSQLParserParserESCAPE, DorisSQLParserParserEVENTS, DorisSQLParserParserEXCEPT, DorisSQLParserParserEXCLUDE, DorisSQLParserParserEXECUTE, DorisSQLParserParserEXPORT, DorisSQLParserParserEXTERNAL, DorisSQLParserParserEXTRACT, DorisSQLParserParserEVERY, DorisSQLParserParserFAILPOINT, DorisSQLParserParserFAILPOINTS, DorisSQLParserParserFIELDS, DorisSQLParserParserFILE, DorisSQLParserParserFILTER, DorisSQLParserParserFIRST, DorisSQLParserParserFLOOR, DorisSQLParserParserFN, DorisSQLParserParserFOLLOWING, DorisSQLParserParserFOLLOWER, DorisSQLParserParserFORMAT, DorisSQLParserParserFREE, DorisSQLParserParserFRONTEND, DorisSQLParserParserFRONTENDS, DorisSQLParserParserFUNCTIONS, DorisSQLParserParserGLOBAL, DorisSQLParserParserGRANTS, DorisSQLParserParserGROUP_CONCAT, DorisSQLParserParserHASH, DorisSQLParserParserHELP, DorisSQLParserParserHISTOGRAM, DorisSQLParserParserHLL_UNION, DorisSQLParserParserHOST, DorisSQLParserParserHOUR, DorisSQLParserParserHOURS, DorisSQLParserParserHUB, DorisSQLParserParserIDENTIFIED, DorisSQLParserParserIMPERSONATE, DorisSQLParserParserIMAGE, DorisSQLParserParserINACTIVE, DorisSQLParserParserINCREMENTAL, DorisSQLParserParserINDEXES, DorisSQLParserParserINSTALL, DorisSQLParserParserINTEGRATION, DorisSQLParserParserINTEGRATIONS, DorisSQLParserParserINTERMEDIATE, DorisSQLParserParserINTERVAL, DorisSQLParserParserOVERWRITE, DorisSQLParserParserISOLATION, DorisSQLParserParserJOB, DorisSQLParserParserLABEL, DorisSQLParserParserLAST, DorisSQLParserParserLESS, DorisSQLParserParserLEVEL, DorisSQLParserParserLIST, DorisSQLParserParserLOCAL, DorisSQLParserParserLOCATION, DorisSQLParserParserLOCATIONS, DorisSQLParserParserLOGS, DorisSQLParserParserLOGICAL, DorisSQLParserParserMANUAL, DorisSQLParserParserMAP, DorisSQLParserParserMAPPING, DorisSQLParserParserMAPPINGS, DorisSQLParserParserMASKING, DorisSQLParserParserMATCH, DorisSQLParserParserMATERIALIZED, DorisSQLParserParserMAX, DorisSQLParserParserMERGE, DorisSQLParserParserMIN, DorisSQLParserParserMINUTE, DorisSQLParserParserMINUTES, DorisSQLParserParserMINUS, DorisSQLParserParserMETA, DorisSQLParserParserMODE, DorisSQLParserParserMODIFY, DorisSQLParserParserMONTH, DorisSQLParserParserMULTIPLE, DorisSQLParserParserNAME, DorisSQLParserParserNAMES, DorisSQLParserParserNEGATIVE, DorisSQLParserParserNGRAMBF, DorisSQLParserParserNO, DorisSQLParserParserNODE, DorisSQLParserParserNODES, DorisSQLParserParserNONE, DorisSQLParserParserNULLS, DorisSQLParserParserNUMBER, DorisSQLParserParserNUMERIC, DorisSQLParserParserOBSERVER, DorisSQLParserParserOF, DorisSQLParserParserOFF, DorisSQLParserParserOFFSET, DorisSQLParserParserONLY, DorisSQLParserParserOPEN, DorisSQLParserParserOPERATE, DorisSQLParserParserOPTIMIZER, DorisSQLParserParserOPTION, DorisSQLParserParserPARTITIONS, DorisSQLParserParserPASSWORD, DorisSQLParserParserPATH, DorisSQLParserParserPAUSE, DorisSQLParserParserPENDING, DorisSQLParserParserPERCENT_RANK, DorisSQLParserParserPERCENTILE_UNION, DorisSQLParserParserPLAN, DorisSQLParserParserPLUGIN, DorisSQLParserParserPLUGINS, DorisSQLParserParserPIPE, DorisSQLParserParserPIPES, DorisSQLParserParserPIVOT, DorisSQLParserParserPOLICY, DorisSQLParserParserPOLICIES, DorisSQLParserParserPRECEDING, DorisSQLParserParserPREDICATE, DorisSQLParserParserPRIORITY, DorisSQLParserParserPRIVILEGES, DorisSQLParserParserPROBABILITY, DorisSQLParserParserPROC, DorisSQLParserParserPROCESSLIST, DorisSQLParserParserPROFILE, DorisSQLParserParserPROFILELIST, DorisSQLParserParserPROPERTIES, DorisSQLParserParserPROPERTY, DorisSQLParserParserPROVIDER, DorisSQLParserParserPROVIDERS, DorisSQLParserParserQUALIFY, DorisSQLParserParserQUARTER, DorisSQLParserParserQUERY, DorisSQLParserParserQUERIES, DorisSQLParserParserQUEUE, DorisSQLParserParserQUOTA, DorisSQLParserParserRANDOM, DorisSQLParserParserRANK, DorisSQLParserParserREASON, DorisSQLParserParserRECOVER, DorisSQLParserParserREFRESH, DorisSQLParserParserREWRITE, DorisSQLParserParserREMOVE, DorisSQLParserParserREPAIR, DorisSQLParserParserREPEATABLE, DorisSQLParserParserREPLACE_IF_NOT_NULL, DorisSQLParserParserREPLICA, DorisSQLParserParserREPOSITORY, DorisSQLParserParserREPOSITORIES, DorisSQLParserParserRESOURCE, DorisSQLParserParserRESOURCES, DorisSQLParserParserRESTORE, DorisSQLParserParserRESUME, DorisSQLParserParserRETAIN, DorisSQLParserParserRETENTION, DorisSQLParserParserRETURNS, DorisSQLParserParserRETRY, DorisSQLParserParserREVERT, DorisSQLParserParserROLE, DorisSQLParserParserROLES, DorisSQLParserParserROLLBACK, DorisSQLParserParserROLLUP, DorisSQLParserParserROUTINE, DorisSQLParserParserROW, DorisSQLParserParserRULE, DorisSQLParserParserRULES, DorisSQLParserParserRUNNING, DorisSQLParserParserSAMPLE, DorisSQLParserParserSCHEDULE, DorisSQLParserParserSCHEDULER, DorisSQLParserParserSECOND, DorisSQLParserParserSECURITY, DorisSQLParserParserSEMI, DorisSQLParserParserSEPARATOR, DorisSQLParserParserSERIALIZABLE, DorisSQLParserParserSESSION, DorisSQLParserParserSETS, DorisSQLParserParserSIGNED, DorisSQLParserParserSKIP_HEADER, DorisSQLParserParserSNAPSHOT, DorisSQLParserParserSNAPSHOTS, DorisSQLParserParserSQLBLACKLIST, DorisSQLParserParserSTART, DorisSQLParserParserSTATS, DorisSQLParserParserSTATUS, DorisSQLParserParserSTOP, DorisSQLParserParserSTORAGE, DorisSQLParserParserSTREAM, DorisSQLParserParserSTRING, DorisSQLParserParserSUBMIT, DorisSQLParserParserSUM, DorisSQLParserParserSUSPEND, DorisSQLParserParserSYNC, DorisSQLParserParserSYSTEM_TIME, DorisSQLParserParserSWAP, DorisSQLParserParserSTRUCT, DorisSQLParserParserTABLES, DorisSQLParserParserTABLET, DorisSQLParserParserTABLETS, DorisSQLParserParserTAG, DorisSQLParserParserTASK, DorisSQLParserParserTEMPORARY, DorisSQLParserParserTHAN, DorisSQLParserParserTIME, DorisSQLParserParserTIMES, DorisSQLParserParserTIMESTAMP, DorisSQLParserParserTIMESTAMPADD, DorisSQLParserParserTIMESTAMPDIFF, DorisSQLParserParserTRANSACTION, DorisSQLParserParserTRANSLATE, DorisSQLParserParserTRACE, DorisSQLParserParserTRIGGERS, DorisSQLParserParserTRIM_SPACE, DorisSQLParserParserTRUNCATE, DorisSQLParserParserTYPE, DorisSQLParserParserTYPES, DorisSQLParserParserUNBOUNDED, DorisSQLParserParserUNCOMMITTED, DorisSQLParserParserUNINSTALL, DorisSQLParserParserUNSET, DorisSQLParserParserUSAGE, DorisSQLParserParserUSER, DorisSQLParserParserUSERS, DorisSQLParserParserVALUE, DorisSQLParserParserVARBINARY, DorisSQLParserParserVARIABLES, DorisSQLParserParserVECTOR, DorisSQLParserParserVERBOSE, DorisSQLParserParserVERSION, DorisSQLParserParserVIEW, DorisSQLParserParserVIEWS, DorisSQLParserParserVOLUME, DorisSQLParserParserVOLUMES, DorisSQLParserParserWAREHOUSE, DorisSQLParserParserWAREHOUSES, DorisSQLParserParserWARNINGS, DorisSQLParserParserWEEK, DorisSQLParserParserWHITELIST, DorisSQLParserParserWORK, DorisSQLParserParserWRITE, DorisSQLParserParserYEAR, DorisSQLParserParserLOCK, DorisSQLParserParserUNLOCK, DorisSQLParserParserLOW_PRIORITY, DorisSQLParserParserDISK, DorisSQLParserParserBEFORE, DorisSQLParserParserFIELD, DorisSQLParserParserPERSISTENT, DorisSQLParserParserARRAY_ELEMENT, DorisSQLParserParserLETTER_IDENTIFIER, DorisSQLParserParserDIGIT_IDENTIFIER, DorisSQLParserParserBACKQUOTED_IDENTIFIER, DorisSQLParserParserDOTDOTDOT:
			{
				p.SetState(6855)
				p.Identifier()
			}

		case DorisSQLParserParserT__1:
			{
				p.SetState(6856)
				p.IdentifierList()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(6859)
			p.Match(DorisSQLParserParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6860)
			p.expression(0)
		}

	case 21:
		localctx = NewLambdaFunctionExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6862)
			p.IdentifierList()
		}
		{
			p.SetState(6863)
			p.Match(DorisSQLParserParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6864)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6866)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(6865)
				p.ExpressionList()
			}

		}
		{
			p.SetState(6868)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(6913)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 806, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(6911)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 805, p.GetParserRuleContext()) {
			case 1:
				localctx = NewConcatContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*ConcatContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserParserRULE_primaryExpression)
				p.SetState(6872)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
					goto errorExit
				}
				{
					p.SetState(6873)
					p.Match(DorisSQLParserParserCONCAT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6874)

					var _x = p.primaryExpression(20)

					localctx.(*ConcatContext).right = _x
				}

			case 2:
				localctx = NewMatchExprContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*MatchExprContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserParserRULE_primaryExpression)
				p.SetState(6875)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				p.SetState(6877)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisSQLParserParserNOT {
					{
						p.SetState(6876)
						p.Match(DorisSQLParserParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(6879)
					p.Match(DorisSQLParserParserMATCH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6880)

					var _x = p.primaryExpression(2)

					localctx.(*MatchExprContext).right = _x
				}

			case 3:
				localctx = NewCollateContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserParserRULE_primaryExpression)
				p.SetState(6881)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
					goto errorExit
				}
				{
					p.SetState(6882)
					p.Match(DorisSQLParserParserCOLLATE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(6885)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DorisSQLParserParserACCESS, DorisSQLParserParserACTIVE, DorisSQLParserParserADMIN, DorisSQLParserParserADVISOR, DorisSQLParserParserAFTER, DorisSQLParserParserAGGREGATE, DorisSQLParserParserANTI, DorisSQLParserParserAPPLY, DorisSQLParserParserARRAY_AGG, DorisSQLParserParserARRAY_AGG_DISTINCT, DorisSQLParserParserASYNC, DorisSQLParserParserAUTHORS, DorisSQLParserParserAUTHENTICATION, DorisSQLParserParserAUTOMATED, DorisSQLParserParserAUTO_INCREMENT, DorisSQLParserParserAVG, DorisSQLParserParserBACKEND, DorisSQLParserParserBACKENDS, DorisSQLParserParserBACKUP, DorisSQLParserParserBASE, DorisSQLParserParserBASELINE, DorisSQLParserParserBEGIN, DorisSQLParserParserBINARY, DorisSQLParserParserBITMAP_UNION, DorisSQLParserParserBLACKHOLE, DorisSQLParserParserBLACKLIST, DorisSQLParserParserBODY, DorisSQLParserParserBOOLEAN, DorisSQLParserParserBRANCH, DorisSQLParserParserBROKER, DorisSQLParserParserBUCKETS, DorisSQLParserParserBUILTIN, DorisSQLParserParserCACHE, DorisSQLParserParserCANCEL, DorisSQLParserParserCAST, DorisSQLParserParserCATALOG, DorisSQLParserParserCATALOGS, DorisSQLParserParserCEIL, DorisSQLParserParserCHAIN, DorisSQLParserParserCHARSET, DorisSQLParserParserCLEAN, DorisSQLParserParserCLEAR, DorisSQLParserParserCLUSTER, DorisSQLParserParserCLUSTERS, DorisSQLParserParserCNGROUP, DorisSQLParserParserCNGROUPS, DorisSQLParserParserCOLLATION, DorisSQLParserParserCOLUMNS, DorisSQLParserParserCOMMENT, DorisSQLParserParserCOMMIT, DorisSQLParserParserCOMMITTED, DorisSQLParserParserCOMPACT, DorisSQLParserParserCOMPUTE, DorisSQLParserParserCONFIG, DorisSQLParserParserCONNECTION, DorisSQLParserParserCONSISTENT, DorisSQLParserParserCOSTS, DorisSQLParserParserCOUNT, DorisSQLParserParserCUME_DIST, DorisSQLParserParserCUMULATIVE, DorisSQLParserParserCURRENT, DorisSQLParserParserDATA, DorisSQLParserParserDATACACHE, DorisSQLParserParserDATE, DorisSQLParserParserDATETIME, DorisSQLParserParserDAY, DorisSQLParserParserDAYS, DorisSQLParserParserDEALLOCATE, DorisSQLParserParserDECOMMISSION, DorisSQLParserParserDIALECT, DorisSQLParserParserDICTIONARY, DorisSQLParserParserDICTIONARY_GET, DorisSQLParserParserDISABLE, DorisSQLParserParserDISTRIBUTED, DorisSQLParserParserDISTRIBUTION, DorisSQLParserParserDUPLICATE, DorisSQLParserParserDYNAMIC, DorisSQLParserParserENABLE, DorisSQLParserParserENCLOSE, DorisSQLParserParserEND, DorisSQLParserParserENGINE, DorisSQLParserParserENGINES, DorisSQLParserParserERRORS, DorisSQLParserParserESCAPE, DorisSQLParserParserEVENTS, DorisSQLParserParserEXCEPT, DorisSQLParserParserEXCLUDE, DorisSQLParserParserEXECUTE, DorisSQLParserParserEXPORT, DorisSQLParserParserEXTERNAL, DorisSQLParserParserEXTRACT, DorisSQLParserParserEVERY, DorisSQLParserParserFAILPOINT, DorisSQLParserParserFAILPOINTS, DorisSQLParserParserFIELDS, DorisSQLParserParserFILE, DorisSQLParserParserFILTER, DorisSQLParserParserFIRST, DorisSQLParserParserFLOOR, DorisSQLParserParserFN, DorisSQLParserParserFOLLOWING, DorisSQLParserParserFOLLOWER, DorisSQLParserParserFORMAT, DorisSQLParserParserFREE, DorisSQLParserParserFRONTEND, DorisSQLParserParserFRONTENDS, DorisSQLParserParserFUNCTIONS, DorisSQLParserParserGLOBAL, DorisSQLParserParserGRANTS, DorisSQLParserParserGROUP_CONCAT, DorisSQLParserParserHASH, DorisSQLParserParserHELP, DorisSQLParserParserHISTOGRAM, DorisSQLParserParserHLL_UNION, DorisSQLParserParserHOST, DorisSQLParserParserHOUR, DorisSQLParserParserHOURS, DorisSQLParserParserHUB, DorisSQLParserParserIDENTIFIED, DorisSQLParserParserIMPERSONATE, DorisSQLParserParserIMAGE, DorisSQLParserParserINACTIVE, DorisSQLParserParserINCREMENTAL, DorisSQLParserParserINDEXES, DorisSQLParserParserINSTALL, DorisSQLParserParserINTEGRATION, DorisSQLParserParserINTEGRATIONS, DorisSQLParserParserINTERMEDIATE, DorisSQLParserParserINTERVAL, DorisSQLParserParserOVERWRITE, DorisSQLParserParserISOLATION, DorisSQLParserParserJOB, DorisSQLParserParserLABEL, DorisSQLParserParserLAST, DorisSQLParserParserLESS, DorisSQLParserParserLEVEL, DorisSQLParserParserLIST, DorisSQLParserParserLOCAL, DorisSQLParserParserLOCATION, DorisSQLParserParserLOCATIONS, DorisSQLParserParserLOGS, DorisSQLParserParserLOGICAL, DorisSQLParserParserMANUAL, DorisSQLParserParserMAP, DorisSQLParserParserMAPPING, DorisSQLParserParserMAPPINGS, DorisSQLParserParserMASKING, DorisSQLParserParserMATCH, DorisSQLParserParserMATERIALIZED, DorisSQLParserParserMAX, DorisSQLParserParserMERGE, DorisSQLParserParserMIN, DorisSQLParserParserMINUTE, DorisSQLParserParserMINUTES, DorisSQLParserParserMINUS, DorisSQLParserParserMETA, DorisSQLParserParserMODE, DorisSQLParserParserMODIFY, DorisSQLParserParserMONTH, DorisSQLParserParserMULTIPLE, DorisSQLParserParserNAME, DorisSQLParserParserNAMES, DorisSQLParserParserNEGATIVE, DorisSQLParserParserNGRAMBF, DorisSQLParserParserNO, DorisSQLParserParserNODE, DorisSQLParserParserNODES, DorisSQLParserParserNONE, DorisSQLParserParserNULLS, DorisSQLParserParserNUMBER, DorisSQLParserParserNUMERIC, DorisSQLParserParserOBSERVER, DorisSQLParserParserOF, DorisSQLParserParserOFF, DorisSQLParserParserOFFSET, DorisSQLParserParserONLY, DorisSQLParserParserOPEN, DorisSQLParserParserOPERATE, DorisSQLParserParserOPTIMIZER, DorisSQLParserParserOPTION, DorisSQLParserParserPARTITIONS, DorisSQLParserParserPASSWORD, DorisSQLParserParserPATH, DorisSQLParserParserPAUSE, DorisSQLParserParserPENDING, DorisSQLParserParserPERCENT_RANK, DorisSQLParserParserPERCENTILE_UNION, DorisSQLParserParserPLAN, DorisSQLParserParserPLUGIN, DorisSQLParserParserPLUGINS, DorisSQLParserParserPIPE, DorisSQLParserParserPIPES, DorisSQLParserParserPIVOT, DorisSQLParserParserPOLICY, DorisSQLParserParserPOLICIES, DorisSQLParserParserPRECEDING, DorisSQLParserParserPREDICATE, DorisSQLParserParserPRIORITY, DorisSQLParserParserPRIVILEGES, DorisSQLParserParserPROBABILITY, DorisSQLParserParserPROC, DorisSQLParserParserPROCESSLIST, DorisSQLParserParserPROFILE, DorisSQLParserParserPROFILELIST, DorisSQLParserParserPROPERTIES, DorisSQLParserParserPROPERTY, DorisSQLParserParserPROVIDER, DorisSQLParserParserPROVIDERS, DorisSQLParserParserQUALIFY, DorisSQLParserParserQUARTER, DorisSQLParserParserQUERY, DorisSQLParserParserQUERIES, DorisSQLParserParserQUEUE, DorisSQLParserParserQUOTA, DorisSQLParserParserRANDOM, DorisSQLParserParserRANK, DorisSQLParserParserREASON, DorisSQLParserParserRECOVER, DorisSQLParserParserREFRESH, DorisSQLParserParserREWRITE, DorisSQLParserParserREMOVE, DorisSQLParserParserREPAIR, DorisSQLParserParserREPEATABLE, DorisSQLParserParserREPLACE_IF_NOT_NULL, DorisSQLParserParserREPLICA, DorisSQLParserParserREPOSITORY, DorisSQLParserParserREPOSITORIES, DorisSQLParserParserRESOURCE, DorisSQLParserParserRESOURCES, DorisSQLParserParserRESTORE, DorisSQLParserParserRESUME, DorisSQLParserParserRETAIN, DorisSQLParserParserRETENTION, DorisSQLParserParserRETURNS, DorisSQLParserParserRETRY, DorisSQLParserParserREVERT, DorisSQLParserParserROLE, DorisSQLParserParserROLES, DorisSQLParserParserROLLBACK, DorisSQLParserParserROLLUP, DorisSQLParserParserROUTINE, DorisSQLParserParserROW, DorisSQLParserParserRULE, DorisSQLParserParserRULES, DorisSQLParserParserRUNNING, DorisSQLParserParserSAMPLE, DorisSQLParserParserSCHEDULE, DorisSQLParserParserSCHEDULER, DorisSQLParserParserSECOND, DorisSQLParserParserSECURITY, DorisSQLParserParserSEMI, DorisSQLParserParserSEPARATOR, DorisSQLParserParserSERIALIZABLE, DorisSQLParserParserSESSION, DorisSQLParserParserSETS, DorisSQLParserParserSIGNED, DorisSQLParserParserSKIP_HEADER, DorisSQLParserParserSNAPSHOT, DorisSQLParserParserSNAPSHOTS, DorisSQLParserParserSQLBLACKLIST, DorisSQLParserParserSTART, DorisSQLParserParserSTATS, DorisSQLParserParserSTATUS, DorisSQLParserParserSTOP, DorisSQLParserParserSTORAGE, DorisSQLParserParserSTREAM, DorisSQLParserParserSTRING, DorisSQLParserParserSUBMIT, DorisSQLParserParserSUM, DorisSQLParserParserSUSPEND, DorisSQLParserParserSYNC, DorisSQLParserParserSYSTEM_TIME, DorisSQLParserParserSWAP, DorisSQLParserParserSTRUCT, DorisSQLParserParserTABLES, DorisSQLParserParserTABLET, DorisSQLParserParserTABLETS, DorisSQLParserParserTAG, DorisSQLParserParserTASK, DorisSQLParserParserTEMPORARY, DorisSQLParserParserTHAN, DorisSQLParserParserTIME, DorisSQLParserParserTIMES, DorisSQLParserParserTIMESTAMP, DorisSQLParserParserTIMESTAMPADD, DorisSQLParserParserTIMESTAMPDIFF, DorisSQLParserParserTRANSACTION, DorisSQLParserParserTRANSLATE, DorisSQLParserParserTRACE, DorisSQLParserParserTRIGGERS, DorisSQLParserParserTRIM_SPACE, DorisSQLParserParserTRUNCATE, DorisSQLParserParserTYPE, DorisSQLParserParserTYPES, DorisSQLParserParserUNBOUNDED, DorisSQLParserParserUNCOMMITTED, DorisSQLParserParserUNINSTALL, DorisSQLParserParserUNSET, DorisSQLParserParserUSAGE, DorisSQLParserParserUSER, DorisSQLParserParserUSERS, DorisSQLParserParserVALUE, DorisSQLParserParserVARBINARY, DorisSQLParserParserVARIABLES, DorisSQLParserParserVECTOR, DorisSQLParserParserVERBOSE, DorisSQLParserParserVERSION, DorisSQLParserParserVIEW, DorisSQLParserParserVIEWS, DorisSQLParserParserVOLUME, DorisSQLParserParserVOLUMES, DorisSQLParserParserWAREHOUSE, DorisSQLParserParserWAREHOUSES, DorisSQLParserParserWARNINGS, DorisSQLParserParserWEEK, DorisSQLParserParserWHITELIST, DorisSQLParserParserWORK, DorisSQLParserParserWRITE, DorisSQLParserParserYEAR, DorisSQLParserParserLOCK, DorisSQLParserParserUNLOCK, DorisSQLParserParserLOW_PRIORITY, DorisSQLParserParserDISK, DorisSQLParserParserBEFORE, DorisSQLParserParserFIELD, DorisSQLParserParserPERSISTENT, DorisSQLParserParserARRAY_ELEMENT, DorisSQLParserParserLETTER_IDENTIFIER, DorisSQLParserParserDIGIT_IDENTIFIER, DorisSQLParserParserBACKQUOTED_IDENTIFIER, DorisSQLParserParserDOTDOTDOT:
					{
						p.SetState(6883)
						p.Identifier()
					}

				case DorisSQLParserParserSINGLE_QUOTED_TEXT, DorisSQLParserParserDOUBLE_QUOTED_TEXT:
					{
						p.SetState(6884)
						p.String_()
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			case 4:
				localctx = NewDereferenceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*DereferenceContext).base = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserParserRULE_primaryExpression)
				p.SetState(6887)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
					goto errorExit
				}
				p.SetState(6891)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DorisSQLParserParserDOT_IDENTIFIER:
					{
						p.SetState(6888)
						p.Match(DorisSQLParserParserDOT_IDENTIFIER)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case DorisSQLParserParserT__0:
					{
						p.SetState(6889)
						p.Match(DorisSQLParserParserT__0)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(6890)

						var _x = p.Identifier()

						localctx.(*DereferenceContext).fieldName = _x
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			case 5:
				localctx = NewCollectionSubscriptContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*CollectionSubscriptContext).value = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserParserRULE_primaryExpression)
				p.SetState(6893)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(6894)
					p.Match(DorisSQLParserParserT__5)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6895)

					var _x = p.valueExpression(0)

					localctx.(*CollectionSubscriptContext).index = _x
				}
				{
					p.SetState(6896)
					p.Match(DorisSQLParserParserT__6)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 6:
				localctx = NewArraySliceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserParserRULE_primaryExpression)
				p.SetState(6898)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(6899)
					p.Match(DorisSQLParserParserT__5)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(6901)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisSQLParserParserINTEGER_VALUE {
					{
						p.SetState(6900)

						var _m = p.Match(DorisSQLParserParserINTEGER_VALUE)

						localctx.(*ArraySliceContext).start_ = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(6903)
					p.Match(DorisSQLParserParserT__7)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(6905)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisSQLParserParserINTEGER_VALUE {
					{
						p.SetState(6904)

						var _m = p.Match(DorisSQLParserParserINTEGER_VALUE)

						localctx.(*ArraySliceContext).end = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(6907)
					p.Match(DorisSQLParserParserT__6)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 7:
				localctx = NewArrowExpressionContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DorisSQLParserParserRULE_primaryExpression)
				p.SetState(6908)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(6909)
					p.Match(DorisSQLParserParserARROW)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6910)
					p.String_()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(6915)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 806, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralExpressionContext is an interface to support dynamic dispatch.
type ILiteralExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLiteralExpressionContext differentiates from other interfaces.
	IsLiteralExpressionContext()
}

type LiteralExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralExpressionContext() *LiteralExpressionContext {
	var p = new(LiteralExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_literalExpression
	return p
}

func InitEmptyLiteralExpressionContext(p *LiteralExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_literalExpression
}

func (*LiteralExpressionContext) IsLiteralExpressionContext() {}

func NewLiteralExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralExpressionContext {
	var p = new(LiteralExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_literalExpression

	return p
}

func (s *LiteralExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralExpressionContext) CopyAll(ctx *LiteralExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BinaryLiteralContext struct {
	LiteralExpressionContext
}

func NewBinaryLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryLiteralContext {
	var p = new(BinaryLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *BinaryLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryLiteralContext) Binary() IBinaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBinaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBinaryContext)
}

func (s *BinaryLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterBinaryLiteral(s)
	}
}

func (s *BinaryLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitBinaryLiteral(s)
	}
}

func (s *BinaryLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitBinaryLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type NullLiteralContext struct {
	LiteralExpressionContext
}

func NewNullLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralContext {
	var p = new(NullLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNULL, 0)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

func (s *NullLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitNullLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type StringLiteralContext struct {
	LiteralExpressionContext
}

func NewStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralContext {
	var p = new(StringLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (s *StringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParameterContext struct {
	LiteralExpressionContext
}

func NewParameterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParameterContext {
	var p = new(ParameterContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) PARAMETER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPARAMETER, 0)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (s *ParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

type DateLiteralContext struct {
	LiteralExpressionContext
}

func NewDateLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DateLiteralContext {
	var p = new(DateLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *DateLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateLiteralContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DateLiteralContext) DATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATE, 0)
}

func (s *DateLiteralContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATETIME, 0)
}

func (s *DateLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDateLiteral(s)
	}
}

func (s *DateLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDateLiteral(s)
	}
}

func (s *DateLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDateLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type BooleanLiteralContext struct {
	LiteralExpressionContext
}

func NewBooleanLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) BooleanValue() IBooleanValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitBooleanLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type NumericLiteralContext struct {
	LiteralExpressionContext
}

func NewNumericLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitNumericLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntervalLiteralContext struct {
	LiteralExpressionContext
}

func NewIntervalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalLiteralContext {
	var p = new(IntervalLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *IntervalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalLiteralContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *IntervalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterIntervalLiteral(s)
	}
}

func (s *IntervalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitIntervalLiteral(s)
	}
}

func (s *IntervalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitIntervalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnitBoundaryLiteralContext struct {
	LiteralExpressionContext
}

func NewUnitBoundaryLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnitBoundaryLiteralContext {
	var p = new(UnitBoundaryLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *UnitBoundaryLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitBoundaryLiteralContext) UnitBoundary() IUnitBoundaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitBoundaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitBoundaryContext)
}

func (s *UnitBoundaryLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterUnitBoundaryLiteral(s)
	}
}

func (s *UnitBoundaryLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitUnitBoundaryLiteral(s)
	}
}

func (s *UnitBoundaryLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitUnitBoundaryLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) LiteralExpression() (localctx ILiteralExpressionContext) {
	localctx = NewLiteralExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 868, DorisSQLParserParserRULE_literalExpression)
	var _la int

	p.SetState(6926)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserNULL:
		localctx = NewNullLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6916)
			p.Match(DorisSQLParserParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserFALSE, DorisSQLParserParserTRUE:
		localctx = NewBooleanLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6917)
			p.BooleanValue()
		}

	case DorisSQLParserParserINTEGER_VALUE, DorisSQLParserParserDECIMAL_VALUE, DorisSQLParserParserDOUBLE_VALUE:
		localctx = NewNumericLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6918)
			p.Number()
		}

	case DorisSQLParserParserDATE, DorisSQLParserParserDATETIME:
		localctx = NewDateLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6919)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserDATE || _la == DorisSQLParserParserDATETIME) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6920)
			p.String_()
		}

	case DorisSQLParserParserSINGLE_QUOTED_TEXT, DorisSQLParserParserDOUBLE_QUOTED_TEXT:
		localctx = NewStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6921)
			p.String_()
		}

	case DorisSQLParserParserINTERVAL:
		localctx = NewIntervalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6922)
			p.Interval()
		}

	case DorisSQLParserParserCEIL, DorisSQLParserParserFLOOR:
		localctx = NewUnitBoundaryLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6923)
			p.UnitBoundary()
		}

	case DorisSQLParserParserBINARY_SINGLE_QUOTED_TEXT, DorisSQLParserParserBINARY_DOUBLE_QUOTED_TEXT:
		localctx = NewBinaryLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6924)
			p.Binary()
		}

	case DorisSQLParserParserPARAMETER:
		localctx = NewParameterContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6925)
			p.Match(DorisSQLParserParserPARAMETER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_functionCall
	return p
}

func InitEmptyFunctionCallContext(p *FunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_functionCall
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) CopyAll(ctx *FunctionCallContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AggregationFunctionCallContext struct {
	FunctionCallContext
}

func NewAggregationFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AggregationFunctionCallContext {
	var p = new(AggregationFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *AggregationFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregationFunctionCallContext) AggregationFunction() IAggregationFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregationFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregationFunctionContext)
}

func (s *AggregationFunctionCallContext) Over() IOverContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverContext)
}

func (s *AggregationFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAggregationFunctionCall(s)
	}
}

func (s *AggregationFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAggregationFunctionCall(s)
	}
}

func (s *AggregationFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAggregationFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExtractContext struct {
	FunctionCallContext
}

func NewExtractContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExtractContext {
	var p = new(ExtractContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *ExtractContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXTRACT, 0)
}

func (s *ExtractContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExtractContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFROM, 0)
}

func (s *ExtractContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ExtractContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterExtract(s)
	}
}

func (s *ExtractContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitExtract(s)
	}
}

func (s *ExtractContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitExtract(s)

	default:
		return t.VisitChildren(s)
	}
}

type SpecialFunctionContext struct {
	FunctionCallContext
}

func NewSpecialFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialFunctionContext {
	var p = new(SpecialFunctionContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *SpecialFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialFunctionContext) SpecialFunctionExpression() ISpecialFunctionExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecialFunctionExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecialFunctionExpressionContext)
}

func (s *SpecialFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSpecialFunction(s)
	}
}

func (s *SpecialFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSpecialFunction(s)
	}
}

func (s *SpecialFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSpecialFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleFunctionCallContext struct {
	FunctionCallContext
}

func NewSimpleFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleFunctionCallContext {
	var p = new(SimpleFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *SimpleFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleFunctionCallContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SimpleFunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleFunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleFunctionCallContext) Over() IOverContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverContext)
}

func (s *SimpleFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSimpleFunctionCall(s)
	}
}

func (s *SimpleFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSimpleFunctionCall(s)
	}
}

func (s *SimpleFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSimpleFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type SpecialDateTimeContext struct {
	FunctionCallContext
}

func NewSpecialDateTimeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialDateTimeContext {
	var p = new(SpecialDateTimeContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *SpecialDateTimeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialDateTimeContext) SpecialDateTimeExpression() ISpecialDateTimeExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecialDateTimeExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecialDateTimeExpressionContext)
}

func (s *SpecialDateTimeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSpecialDateTime(s)
	}
}

func (s *SpecialDateTimeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSpecialDateTime(s)
	}
}

func (s *SpecialDateTimeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSpecialDateTime(s)

	default:
		return t.VisitChildren(s)
	}
}

type WindowFunctionCallContext struct {
	FunctionCallContext
}

func NewWindowFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WindowFunctionCallContext {
	var p = new(WindowFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *WindowFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFunctionCallContext) WindowFunction() IWindowFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFunctionContext)
}

func (s *WindowFunctionCallContext) Over() IOverContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverContext)
}

func (s *WindowFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterWindowFunctionCall(s)
	}
}

func (s *WindowFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitWindowFunctionCall(s)
	}
}

func (s *WindowFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitWindowFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type InformationFunctionContext struct {
	FunctionCallContext
}

func NewInformationFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InformationFunctionContext {
	var p = new(InformationFunctionContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *InformationFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InformationFunctionContext) InformationFunctionExpression() IInformationFunctionExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInformationFunctionExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInformationFunctionExpressionContext)
}

func (s *InformationFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterInformationFunction(s)
	}
}

func (s *InformationFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitInformationFunction(s)
	}
}

func (s *InformationFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitInformationFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type TranslateFunctionCallContext struct {
	FunctionCallContext
}

func NewTranslateFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TranslateFunctionCallContext {
	var p = new(TranslateFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *TranslateFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TranslateFunctionCallContext) TRANSLATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTRANSLATE, 0)
}

func (s *TranslateFunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TranslateFunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TranslateFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTranslateFunctionCall(s)
	}
}

func (s *TranslateFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTranslateFunctionCall(s)
	}
}

func (s *TranslateFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTranslateFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type GroupingOperationContext struct {
	FunctionCallContext
}

func NewGroupingOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GroupingOperationContext {
	var p = new(GroupingOperationContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *GroupingOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingOperationContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGROUPING, 0)
}

func (s *GroupingOperationContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupingOperationContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingOperationContext) GROUPING_ID() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGROUPING_ID, 0)
}

func (s *GroupingOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterGroupingOperation(s)
	}
}

func (s *GroupingOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitGroupingOperation(s)
	}
}

func (s *GroupingOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitGroupingOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) FunctionCall() (localctx IFunctionCallContext) {
	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 870, DorisSQLParserParserRULE_functionCall)
	var _la int

	p.SetState(7000)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 818, p.GetParserRuleContext()) {
	case 1:
		localctx = NewExtractContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6928)
			p.Match(DorisSQLParserParserEXTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6929)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6930)
			p.Identifier()
		}
		{
			p.SetState(6931)
			p.Match(DorisSQLParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6932)
			p.valueExpression(0)
		}
		{
			p.SetState(6933)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewGroupingOperationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6935)
			p.Match(DorisSQLParserParserGROUPING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6936)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6945)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(6937)
				p.expression(0)
			}
			p.SetState(6942)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(6938)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6939)
					p.expression(0)
				}

				p.SetState(6944)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(6947)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewGroupingOperationContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6948)
			p.Match(DorisSQLParserParserGROUPING_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6949)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6958)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(6950)
				p.expression(0)
			}
			p.SetState(6955)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(6951)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6952)
					p.expression(0)
				}

				p.SetState(6957)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(6960)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewInformationFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6961)
			p.InformationFunctionExpression()
		}

	case 5:
		localctx = NewSpecialDateTimeContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6962)
			p.SpecialDateTimeExpression()
		}

	case 6:
		localctx = NewSpecialFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6963)
			p.SpecialFunctionExpression()
		}

	case 7:
		localctx = NewAggregationFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6964)
			p.AggregationFunction()
		}
		p.SetState(6966)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 812, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6965)
				p.Over()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 8:
		localctx = NewWindowFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6968)
			p.WindowFunction()
		}
		{
			p.SetState(6969)
			p.Over()
		}

	case 9:
		localctx = NewTranslateFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6971)
			p.Match(DorisSQLParserParserTRANSLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6972)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6981)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(6973)
				p.expression(0)
			}
			p.SetState(6978)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(6974)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6975)
					p.expression(0)
				}

				p.SetState(6980)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(6983)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewSimpleFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6984)
			p.QualifiedName()
		}
		{
			p.SetState(6985)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6994)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(6986)
				p.expression(0)
			}
			p.SetState(6991)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(6987)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6988)
					p.expression(0)
				}

				p.SetState(6993)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(6996)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6998)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 817, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6997)
				p.Over()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggregationFunctionContext is an interface to support dynamic dispatch.
type IAggregationFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AVG() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	SetQuantifier() ISetQuantifierContext
	COUNT() antlr.TerminalNode
	ASTERISK_SYMBOL() antlr.TerminalNode
	BracketHint() IBracketHintContext
	MAX() antlr.TerminalNode
	MIN() antlr.TerminalNode
	SUM() antlr.TerminalNode
	ARRAY_AGG() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	ARRAY_AGG_DISTINCT() antlr.TerminalNode
	GROUP_CONCAT() antlr.TerminalNode
	SEPARATOR() antlr.TerminalNode

	// IsAggregationFunctionContext differentiates from other interfaces.
	IsAggregationFunctionContext()
}

type AggregationFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregationFunctionContext() *AggregationFunctionContext {
	var p = new(AggregationFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_aggregationFunction
	return p
}

func InitEmptyAggregationFunctionContext(p *AggregationFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_aggregationFunction
}

func (*AggregationFunctionContext) IsAggregationFunctionContext() {}

func NewAggregationFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregationFunctionContext {
	var p = new(AggregationFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_aggregationFunction

	return p
}

func (s *AggregationFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregationFunctionContext) AVG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAVG, 0)
}

func (s *AggregationFunctionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AggregationFunctionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AggregationFunctionContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *AggregationFunctionContext) COUNT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOUNT, 0)
}

func (s *AggregationFunctionContext) ASTERISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserASTERISK_SYMBOL, 0)
}

func (s *AggregationFunctionContext) BracketHint() IBracketHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBracketHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBracketHintContext)
}

func (s *AggregationFunctionContext) MAX() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMAX, 0)
}

func (s *AggregationFunctionContext) MIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMIN, 0)
}

func (s *AggregationFunctionContext) SUM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSUM, 0)
}

func (s *AggregationFunctionContext) ARRAY_AGG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserARRAY_AGG, 0)
}

func (s *AggregationFunctionContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserORDER, 0)
}

func (s *AggregationFunctionContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *AggregationFunctionContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *AggregationFunctionContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *AggregationFunctionContext) ARRAY_AGG_DISTINCT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserARRAY_AGG_DISTINCT, 0)
}

func (s *AggregationFunctionContext) GROUP_CONCAT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGROUP_CONCAT, 0)
}

func (s *AggregationFunctionContext) SEPARATOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSEPARATOR, 0)
}

func (s *AggregationFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregationFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregationFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAggregationFunction(s)
	}
}

func (s *AggregationFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAggregationFunction(s)
	}
}

func (s *AggregationFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAggregationFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AggregationFunction() (localctx IAggregationFunctionContext) {
	localctx = NewAggregationFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 872, DorisSQLParserParserRULE_aggregationFunction)
	var _la int

	p.SetState(7127)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 838, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7002)
			p.Match(DorisSQLParserParserAVG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7003)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7005)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserALL || _la == DorisSQLParserParserDISTINCT {
			{
				p.SetState(7004)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(7007)
			p.expression(0)
		}
		{
			p.SetState(7008)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7010)
			p.Match(DorisSQLParserParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7011)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7013)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserASTERISK_SYMBOL {
			{
				p.SetState(7012)
				p.Match(DorisSQLParserParserASTERISK_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7015)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7016)
			p.Match(DorisSQLParserParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7017)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7022)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserALL || _la == DorisSQLParserParserDISTINCT {
			{
				p.SetState(7018)
				p.SetQuantifier()
			}
			p.SetState(7020)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 821, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(7019)
					p.BracketHint()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}
		p.SetState(7032)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(7024)
				p.expression(0)
			}
			p.SetState(7029)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(7025)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7026)
					p.expression(0)
				}

				p.SetState(7031)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7034)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7035)
			p.Match(DorisSQLParserParserMAX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7036)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7038)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserALL || _la == DorisSQLParserParserDISTINCT {
			{
				p.SetState(7037)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(7040)
			p.expression(0)
		}
		{
			p.SetState(7041)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7043)
			p.Match(DorisSQLParserParserMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7044)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7046)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserALL || _la == DorisSQLParserParserDISTINCT {
			{
				p.SetState(7045)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(7048)
			p.expression(0)
		}
		{
			p.SetState(7049)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7051)
			p.Match(DorisSQLParserParserSUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7052)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7054)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserALL || _la == DorisSQLParserParserDISTINCT {
			{
				p.SetState(7053)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(7056)
			p.expression(0)
		}
		{
			p.SetState(7057)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7059)
			p.Match(DorisSQLParserParserARRAY_AGG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7060)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7062)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserALL || _la == DorisSQLParserParserDISTINCT {
			{
				p.SetState(7061)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(7064)
			p.expression(0)
		}
		p.SetState(7075)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserORDER {
			{
				p.SetState(7065)
				p.Match(DorisSQLParserParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7066)
				p.Match(DorisSQLParserParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7067)
				p.SortItem()
			}
			p.SetState(7072)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(7068)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7069)
					p.SortItem()
				}

				p.SetState(7074)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7077)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7079)
			p.Match(DorisSQLParserParserARRAY_AGG_DISTINCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7080)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7081)
			p.expression(0)
		}
		p.SetState(7092)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserORDER {
			{
				p.SetState(7082)
				p.Match(DorisSQLParserParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7083)
				p.Match(DorisSQLParserParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7084)
				p.SortItem()
			}
			p.SetState(7089)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(7085)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7086)
					p.SortItem()
				}

				p.SetState(7091)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7094)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(7096)
			p.Match(DorisSQLParserParserGROUP_CONCAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7097)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7099)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserALL || _la == DorisSQLParserParserDISTINCT {
			{
				p.SetState(7098)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(7101)
			p.expression(0)
		}
		p.SetState(7106)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(7102)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7103)
				p.expression(0)
			}

			p.SetState(7108)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(7119)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserORDER {
			{
				p.SetState(7109)
				p.Match(DorisSQLParserParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7110)
				p.Match(DorisSQLParserParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7111)
				p.SortItem()
			}
			p.SetState(7116)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(7112)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7113)
					p.SortItem()
				}

				p.SetState(7118)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(7123)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserSEPARATOR {
			{
				p.SetState(7121)
				p.Match(DorisSQLParserParserSEPARATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7122)
				p.expression(0)
			}

		}
		{
			p.SetState(7125)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserVariableContext is an interface to support dynamic dispatch.
type IUserVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsUserVariableContext differentiates from other interfaces.
	IsUserVariableContext()
}

type UserVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserVariableContext() *UserVariableContext {
	var p = new(UserVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_userVariable
	return p
}

func InitEmptyUserVariableContext(p *UserVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_userVariable
}

func (*UserVariableContext) IsUserVariableContext() {}

func NewUserVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserVariableContext {
	var p = new(UserVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_userVariable

	return p
}

func (s *UserVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *UserVariableContext) AT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAT, 0)
}

func (s *UserVariableContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *UserVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterUserVariable(s)
	}
}

func (s *UserVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitUserVariable(s)
	}
}

func (s *UserVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitUserVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) UserVariable() (localctx IUserVariableContext) {
	localctx = NewUserVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 874, DorisSQLParserParserRULE_userVariable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7129)
		p.Match(DorisSQLParserParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7130)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISystemVariableContext is an interface to support dynamic dispatch.
type ISystemVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAT() []antlr.TerminalNode
	AT(i int) antlr.TerminalNode
	Identifier() IIdentifierContext
	VarType() IVarTypeContext

	// IsSystemVariableContext differentiates from other interfaces.
	IsSystemVariableContext()
}

type SystemVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystemVariableContext() *SystemVariableContext {
	var p = new(SystemVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_systemVariable
	return p
}

func InitEmptySystemVariableContext(p *SystemVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_systemVariable
}

func (*SystemVariableContext) IsSystemVariableContext() {}

func NewSystemVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SystemVariableContext {
	var p = new(SystemVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_systemVariable

	return p
}

func (s *SystemVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *SystemVariableContext) AllAT() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserAT)
}

func (s *SystemVariableContext) AT(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAT, i)
}

func (s *SystemVariableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SystemVariableContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *SystemVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SystemVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SystemVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSystemVariable(s)
	}
}

func (s *SystemVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSystemVariable(s)
	}
}

func (s *SystemVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSystemVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SystemVariable() (localctx ISystemVariableContext) {
	localctx = NewSystemVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 876, DorisSQLParserParserRULE_systemVariable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7132)
		p.Match(DorisSQLParserParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7133)
		p.Match(DorisSQLParserParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7137)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 839, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7134)
			p.VarType()
		}
		{
			p.SetState(7135)
			p.Match(DorisSQLParserParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(7139)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnReferenceContext is an interface to support dynamic dispatch.
type IColumnReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsColumnReferenceContext differentiates from other interfaces.
	IsColumnReferenceContext()
}

type ColumnReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnReferenceContext() *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_columnReference
	return p
}

func InitEmptyColumnReferenceContext(p *ColumnReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_columnReference
}

func (*ColumnReferenceContext) IsColumnReferenceContext() {}

func NewColumnReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_columnReference

	return p
}

func (s *ColumnReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnReferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterColumnReference(s)
	}
}

func (s *ColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitColumnReference(s)
	}
}

func (s *ColumnReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitColumnReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ColumnReference() (localctx IColumnReferenceContext) {
	localctx = NewColumnReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 878, DorisSQLParserParserRULE_columnReference)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7141)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInformationFunctionExpressionContext is an interface to support dynamic dispatch.
type IInformationFunctionExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	CATALOG() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	USER() antlr.TerminalNode
	CURRENT_USER() antlr.TerminalNode
	CURRENT_ROLE() antlr.TerminalNode
	CURRENT_GROUP() antlr.TerminalNode

	// IsInformationFunctionExpressionContext differentiates from other interfaces.
	IsInformationFunctionExpressionContext()
}

type InformationFunctionExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyInformationFunctionExpressionContext() *InformationFunctionExpressionContext {
	var p = new(InformationFunctionExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_informationFunctionExpression
	return p
}

func InitEmptyInformationFunctionExpressionContext(p *InformationFunctionExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_informationFunctionExpression
}

func (*InformationFunctionExpressionContext) IsInformationFunctionExpressionContext() {}

func NewInformationFunctionExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InformationFunctionExpressionContext {
	var p = new(InformationFunctionExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_informationFunctionExpression

	return p
}

func (s *InformationFunctionExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *InformationFunctionExpressionContext) GetName() antlr.Token { return s.name }

func (s *InformationFunctionExpressionContext) SetName(v antlr.Token) { s.name = v }

func (s *InformationFunctionExpressionContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCATALOG, 0)
}

func (s *InformationFunctionExpressionContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATABASE, 0)
}

func (s *InformationFunctionExpressionContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSCHEMA, 0)
}

func (s *InformationFunctionExpressionContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSER, 0)
}

func (s *InformationFunctionExpressionContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCURRENT_USER, 0)
}

func (s *InformationFunctionExpressionContext) CURRENT_ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCURRENT_ROLE, 0)
}

func (s *InformationFunctionExpressionContext) CURRENT_GROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCURRENT_GROUP, 0)
}

func (s *InformationFunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InformationFunctionExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InformationFunctionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterInformationFunctionExpression(s)
	}
}

func (s *InformationFunctionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitInformationFunctionExpression(s)
	}
}

func (s *InformationFunctionExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitInformationFunctionExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) InformationFunctionExpression() (localctx IInformationFunctionExpressionContext) {
	localctx = NewInformationFunctionExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 880, DorisSQLParserParserRULE_informationFunctionExpression)
	p.SetState(7170)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserCATALOG:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7143)

			var _m = p.Match(DorisSQLParserParserCATALOG)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7144)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7145)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserDATABASE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7146)

			var _m = p.Match(DorisSQLParserParserDATABASE)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7147)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7148)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserSCHEMA:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7149)

			var _m = p.Match(DorisSQLParserParserSCHEMA)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7150)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7151)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserUSER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7152)

			var _m = p.Match(DorisSQLParserParserUSER)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7153)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7154)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserCURRENT_USER:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7155)

			var _m = p.Match(DorisSQLParserParserCURRENT_USER)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7158)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 840, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7156)
				p.Match(DorisSQLParserParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7157)
				p.Match(DorisSQLParserParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case DorisSQLParserParserCURRENT_ROLE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7160)

			var _m = p.Match(DorisSQLParserParserCURRENT_ROLE)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7163)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 841, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7161)
				p.Match(DorisSQLParserParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7162)
				p.Match(DorisSQLParserParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case DorisSQLParserParserCURRENT_GROUP:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7165)

			var _m = p.Match(DorisSQLParserParserCURRENT_GROUP)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7168)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 842, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7166)
				p.Match(DorisSQLParserParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7167)
				p.Match(DorisSQLParserParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpecialDateTimeExpressionContext is an interface to support dynamic dispatch.
type ISpecialDateTimeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	CURRENT_DATE() antlr.TerminalNode
	CURRENT_TIME() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	LOCALTIME() antlr.TerminalNode
	LOCALTIMESTAMP() antlr.TerminalNode

	// IsSpecialDateTimeExpressionContext differentiates from other interfaces.
	IsSpecialDateTimeExpressionContext()
}

type SpecialDateTimeExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptySpecialDateTimeExpressionContext() *SpecialDateTimeExpressionContext {
	var p = new(SpecialDateTimeExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_specialDateTimeExpression
	return p
}

func InitEmptySpecialDateTimeExpressionContext(p *SpecialDateTimeExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_specialDateTimeExpression
}

func (*SpecialDateTimeExpressionContext) IsSpecialDateTimeExpressionContext() {}

func NewSpecialDateTimeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecialDateTimeExpressionContext {
	var p = new(SpecialDateTimeExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_specialDateTimeExpression

	return p
}

func (s *SpecialDateTimeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecialDateTimeExpressionContext) GetName() antlr.Token { return s.name }

func (s *SpecialDateTimeExpressionContext) SetName(v antlr.Token) { s.name = v }

func (s *SpecialDateTimeExpressionContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCURRENT_DATE, 0)
}

func (s *SpecialDateTimeExpressionContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCURRENT_TIME, 0)
}

func (s *SpecialDateTimeExpressionContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCURRENT_TIMESTAMP, 0)
}

func (s *SpecialDateTimeExpressionContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, 0)
}

func (s *SpecialDateTimeExpressionContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOCALTIME, 0)
}

func (s *SpecialDateTimeExpressionContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOCALTIMESTAMP, 0)
}

func (s *SpecialDateTimeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialDateTimeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecialDateTimeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSpecialDateTimeExpression(s)
	}
}

func (s *SpecialDateTimeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSpecialDateTimeExpression(s)
	}
}

func (s *SpecialDateTimeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSpecialDateTimeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SpecialDateTimeExpression() (localctx ISpecialDateTimeExpressionContext) {
	localctx = NewSpecialDateTimeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 882, DorisSQLParserParserRULE_specialDateTimeExpression)
	var _la int

	p.SetState(7200)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserCURRENT_DATE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7172)

			var _m = p.Match(DorisSQLParserParserCURRENT_DATE)

			localctx.(*SpecialDateTimeExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7175)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 844, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7173)
				p.Match(DorisSQLParserParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7174)
				p.Match(DorisSQLParserParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case DorisSQLParserParserCURRENT_TIME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7177)

			var _m = p.Match(DorisSQLParserParserCURRENT_TIME)

			localctx.(*SpecialDateTimeExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7180)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 845, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7178)
				p.Match(DorisSQLParserParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7179)
				p.Match(DorisSQLParserParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case DorisSQLParserParserCURRENT_TIMESTAMP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7182)

			var _m = p.Match(DorisSQLParserParserCURRENT_TIMESTAMP)

			localctx.(*SpecialDateTimeExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7188)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 847, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7183)
				p.Match(DorisSQLParserParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(7185)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserParserINTEGER_VALUE {
				{
					p.SetState(7184)
					p.Match(DorisSQLParserParserINTEGER_VALUE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(7187)
				p.Match(DorisSQLParserParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case DorisSQLParserParserLOCALTIME:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7190)

			var _m = p.Match(DorisSQLParserParserLOCALTIME)

			localctx.(*SpecialDateTimeExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7193)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 848, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7191)
				p.Match(DorisSQLParserParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7192)
				p.Match(DorisSQLParserParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case DorisSQLParserParserLOCALTIMESTAMP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7195)

			var _m = p.Match(DorisSQLParserParserLOCALTIMESTAMP)

			localctx.(*SpecialDateTimeExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7198)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 849, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7196)
				p.Match(DorisSQLParserParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7197)
				p.Match(DorisSQLParserParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpecialFunctionExpressionContext is an interface to support dynamic dispatch.
type ISpecialFunctionExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHAR() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	IF() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MOD() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	REGEXP() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	RLIKE() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	TIMESTAMPADD() antlr.TerminalNode
	UnitIdentifier() IUnitIdentifierContext
	TIMESTAMPDIFF() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	String_() IStringContext
	FLOOR() antlr.TerminalNode
	CEIL() antlr.TerminalNode

	// IsSpecialFunctionExpressionContext differentiates from other interfaces.
	IsSpecialFunctionExpressionContext()
}

type SpecialFunctionExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecialFunctionExpressionContext() *SpecialFunctionExpressionContext {
	var p = new(SpecialFunctionExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_specialFunctionExpression
	return p
}

func InitEmptySpecialFunctionExpressionContext(p *SpecialFunctionExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_specialFunctionExpression
}

func (*SpecialFunctionExpressionContext) IsSpecialFunctionExpressionContext() {}

func NewSpecialFunctionExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecialFunctionExpressionContext {
	var p = new(SpecialFunctionExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_specialFunctionExpression

	return p
}

func (s *SpecialFunctionExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecialFunctionExpressionContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCHAR, 0)
}

func (s *SpecialFunctionExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SpecialFunctionExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SpecialFunctionExpressionContext) DAY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDAY, 0)
}

func (s *SpecialFunctionExpressionContext) HOUR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserHOUR, 0)
}

func (s *SpecialFunctionExpressionContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *SpecialFunctionExpressionContext) LEFT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLEFT, 0)
}

func (s *SpecialFunctionExpressionContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIKE, 0)
}

func (s *SpecialFunctionExpressionContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMINUTE, 0)
}

func (s *SpecialFunctionExpressionContext) MOD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMOD, 0)
}

func (s *SpecialFunctionExpressionContext) MONTH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMONTH, 0)
}

func (s *SpecialFunctionExpressionContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserQUARTER, 0)
}

func (s *SpecialFunctionExpressionContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREGEXP, 0)
}

func (s *SpecialFunctionExpressionContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPLACE, 0)
}

func (s *SpecialFunctionExpressionContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRIGHT, 0)
}

func (s *SpecialFunctionExpressionContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRLIKE, 0)
}

func (s *SpecialFunctionExpressionContext) SECOND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSECOND, 0)
}

func (s *SpecialFunctionExpressionContext) TIMESTAMPADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTIMESTAMPADD, 0)
}

func (s *SpecialFunctionExpressionContext) UnitIdentifier() IUnitIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitIdentifierContext)
}

func (s *SpecialFunctionExpressionContext) TIMESTAMPDIFF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTIMESTAMPDIFF, 0)
}

func (s *SpecialFunctionExpressionContext) YEAR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserYEAR, 0)
}

func (s *SpecialFunctionExpressionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPASSWORD, 0)
}

func (s *SpecialFunctionExpressionContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *SpecialFunctionExpressionContext) FLOOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFLOOR, 0)
}

func (s *SpecialFunctionExpressionContext) CEIL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCEIL, 0)
}

func (s *SpecialFunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialFunctionExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecialFunctionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSpecialFunctionExpression(s)
	}
}

func (s *SpecialFunctionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSpecialFunctionExpression(s)
	}
}

func (s *SpecialFunctionExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSpecialFunctionExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SpecialFunctionExpression() (localctx ISpecialFunctionExpressionContext) {
	localctx = NewSpecialFunctionExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 884, DorisSQLParserParserRULE_specialFunctionExpression)
	var _la int

	p.SetState(7343)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserCHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7202)
			p.Match(DorisSQLParserParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7203)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7204)
			p.expression(0)
		}
		{
			p.SetState(7205)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserDAY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7207)
			p.Match(DorisSQLParserParserDAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7208)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7209)
			p.expression(0)
		}
		{
			p.SetState(7210)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserHOUR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7212)
			p.Match(DorisSQLParserParserHOUR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7213)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7214)
			p.expression(0)
		}
		{
			p.SetState(7215)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserIF:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7217)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7218)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7227)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(7219)
				p.expression(0)
			}
			p.SetState(7224)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(7220)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7221)
					p.expression(0)
				}

				p.SetState(7226)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7229)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserLEFT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7230)
			p.Match(DorisSQLParserParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7231)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7232)
			p.expression(0)
		}
		{
			p.SetState(7233)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7234)
			p.expression(0)
		}
		{
			p.SetState(7235)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserLIKE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7237)
			p.Match(DorisSQLParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7238)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7239)
			p.expression(0)
		}
		{
			p.SetState(7240)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7241)
			p.expression(0)
		}
		{
			p.SetState(7242)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserMINUTE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7244)
			p.Match(DorisSQLParserParserMINUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7245)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7246)
			p.expression(0)
		}
		{
			p.SetState(7247)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserMOD:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7249)
			p.Match(DorisSQLParserParserMOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7250)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7251)
			p.expression(0)
		}
		{
			p.SetState(7252)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7253)
			p.expression(0)
		}
		{
			p.SetState(7254)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserMONTH:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(7256)
			p.Match(DorisSQLParserParserMONTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7257)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7258)
			p.expression(0)
		}
		{
			p.SetState(7259)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserQUARTER:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(7261)
			p.Match(DorisSQLParserParserQUARTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7262)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7263)
			p.expression(0)
		}
		{
			p.SetState(7264)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserREGEXP:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(7266)
			p.Match(DorisSQLParserParserREGEXP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7267)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7268)
			p.expression(0)
		}
		{
			p.SetState(7269)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7270)
			p.expression(0)
		}
		{
			p.SetState(7271)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserREPLACE:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(7273)
			p.Match(DorisSQLParserParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7274)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7283)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(7275)
				p.expression(0)
			}
			p.SetState(7280)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(7276)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7277)
					p.expression(0)
				}

				p.SetState(7282)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7285)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserRIGHT:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(7286)
			p.Match(DorisSQLParserParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7287)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7288)
			p.expression(0)
		}
		{
			p.SetState(7289)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7290)
			p.expression(0)
		}
		{
			p.SetState(7291)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserRLIKE:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(7293)
			p.Match(DorisSQLParserParserRLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7294)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7295)
			p.expression(0)
		}
		{
			p.SetState(7296)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7297)
			p.expression(0)
		}
		{
			p.SetState(7298)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserSECOND:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(7300)
			p.Match(DorisSQLParserParserSECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7301)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7302)
			p.expression(0)
		}
		{
			p.SetState(7303)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserTIMESTAMPADD:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(7305)
			p.Match(DorisSQLParserParserTIMESTAMPADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7306)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7307)
			p.UnitIdentifier()
		}
		{
			p.SetState(7308)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7309)
			p.expression(0)
		}
		{
			p.SetState(7310)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7311)
			p.expression(0)
		}
		{
			p.SetState(7312)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserTIMESTAMPDIFF:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(7314)
			p.Match(DorisSQLParserParserTIMESTAMPDIFF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7315)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7316)
			p.UnitIdentifier()
		}
		{
			p.SetState(7317)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7318)
			p.expression(0)
		}
		{
			p.SetState(7319)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7320)
			p.expression(0)
		}
		{
			p.SetState(7321)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserYEAR:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(7323)
			p.Match(DorisSQLParserParserYEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7324)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7325)
			p.expression(0)
		}
		{
			p.SetState(7326)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserPASSWORD:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(7328)
			p.Match(DorisSQLParserParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7329)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7330)
			p.String_()
		}
		{
			p.SetState(7331)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserFLOOR:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(7333)
			p.Match(DorisSQLParserParserFLOOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7334)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7335)
			p.expression(0)
		}
		{
			p.SetState(7336)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserCEIL:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(7338)
			p.Match(DorisSQLParserParserCEIL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7339)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7340)
			p.expression(0)
		}
		{
			p.SetState(7341)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFunctionContext is an interface to support dynamic dispatch.
type IWindowFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	ROW_NUMBER() antlr.TerminalNode
	RANK() antlr.TerminalNode
	DENSE_RANK() antlr.TerminalNode
	CUME_DIST() antlr.TerminalNode
	PERCENT_RANK() antlr.TerminalNode
	NTILE() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	LEAD() antlr.TerminalNode
	AllIgnoreNulls() []IIgnoreNullsContext
	IgnoreNulls(i int) IIgnoreNullsContext
	LAG() antlr.TerminalNode
	FIRST_VALUE() antlr.TerminalNode
	LAST_VALUE() antlr.TerminalNode

	// IsWindowFunctionContext differentiates from other interfaces.
	IsWindowFunctionContext()
}

type WindowFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyWindowFunctionContext() *WindowFunctionContext {
	var p = new(WindowFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_windowFunction
	return p
}

func InitEmptyWindowFunctionContext(p *WindowFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_windowFunction
}

func (*WindowFunctionContext) IsWindowFunctionContext() {}

func NewWindowFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFunctionContext {
	var p = new(WindowFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_windowFunction

	return p
}

func (s *WindowFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFunctionContext) GetName() antlr.Token { return s.name }

func (s *WindowFunctionContext) SetName(v antlr.Token) { s.name = v }

func (s *WindowFunctionContext) ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROW_NUMBER, 0)
}

func (s *WindowFunctionContext) RANK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRANK, 0)
}

func (s *WindowFunctionContext) DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDENSE_RANK, 0)
}

func (s *WindowFunctionContext) CUME_DIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCUME_DIST, 0)
}

func (s *WindowFunctionContext) PERCENT_RANK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPERCENT_RANK, 0)
}

func (s *WindowFunctionContext) NTILE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNTILE, 0)
}

func (s *WindowFunctionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WindowFunctionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WindowFunctionContext) LEAD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLEAD, 0)
}

func (s *WindowFunctionContext) AllIgnoreNulls() []IIgnoreNullsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIgnoreNullsContext); ok {
			len++
		}
	}

	tst := make([]IIgnoreNullsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIgnoreNullsContext); ok {
			tst[i] = t.(IIgnoreNullsContext)
			i++
		}
	}

	return tst
}

func (s *WindowFunctionContext) IgnoreNulls(i int) IIgnoreNullsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIgnoreNullsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIgnoreNullsContext)
}

func (s *WindowFunctionContext) LAG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLAG, 0)
}

func (s *WindowFunctionContext) FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFIRST_VALUE, 0)
}

func (s *WindowFunctionContext) LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLAST_VALUE, 0)
}

func (s *WindowFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterWindowFunction(s)
	}
}

func (s *WindowFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitWindowFunction(s)
	}
}

func (s *WindowFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitWindowFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) WindowFunction() (localctx IWindowFunctionContext) {
	localctx = NewWindowFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 886, DorisSQLParserParserRULE_windowFunction)
	var _la int

	p.SetState(7442)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserROW_NUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7345)

			var _m = p.Match(DorisSQLParserParserROW_NUMBER)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7346)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7347)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserRANK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7348)

			var _m = p.Match(DorisSQLParserParserRANK)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7349)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7350)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserDENSE_RANK:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7351)

			var _m = p.Match(DorisSQLParserParserDENSE_RANK)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7352)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7353)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserCUME_DIST:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7354)

			var _m = p.Match(DorisSQLParserParserCUME_DIST)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7355)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7356)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserPERCENT_RANK:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7357)

			var _m = p.Match(DorisSQLParserParserPERCENT_RANK)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7358)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7359)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserNTILE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7360)

			var _m = p.Match(DorisSQLParserParserNTILE)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7361)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7363)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(7362)
				p.expression(0)
			}

		}
		{
			p.SetState(7365)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserLEAD:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7366)

			var _m = p.Match(DorisSQLParserParserLEAD)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7367)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7379)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(7368)
				p.expression(0)
			}
			p.SetState(7370)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserParserIGNORE {
				{
					p.SetState(7369)
					p.IgnoreNulls()
				}

			}
			p.SetState(7376)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(7372)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7373)
					p.expression(0)
				}

				p.SetState(7378)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7381)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7383)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserIGNORE {
			{
				p.SetState(7382)
				p.IgnoreNulls()
			}

		}

	case DorisSQLParserParserLAG:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7385)

			var _m = p.Match(DorisSQLParserParserLAG)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7386)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7398)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(7387)
				p.expression(0)
			}
			p.SetState(7389)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserParserIGNORE {
				{
					p.SetState(7388)
					p.IgnoreNulls()
				}

			}
			p.SetState(7395)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(7391)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7392)
					p.expression(0)
				}

				p.SetState(7397)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7400)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7402)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserIGNORE {
			{
				p.SetState(7401)
				p.IgnoreNulls()
			}

		}

	case DorisSQLParserParserFIRST_VALUE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(7404)

			var _m = p.Match(DorisSQLParserParserFIRST_VALUE)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7405)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7417)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(7406)
				p.expression(0)
			}
			p.SetState(7408)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserParserIGNORE {
				{
					p.SetState(7407)
					p.IgnoreNulls()
				}

			}
			p.SetState(7414)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(7410)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7411)
					p.expression(0)
				}

				p.SetState(7416)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7419)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7421)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserIGNORE {
			{
				p.SetState(7420)
				p.IgnoreNulls()
			}

		}

	case DorisSQLParserParserLAST_VALUE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(7423)

			var _m = p.Match(DorisSQLParserParserLAST_VALUE)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7424)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7436)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-40620503874086985) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-8927252667726604647) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&67583) != 0) {
			{
				p.SetState(7425)
				p.expression(0)
			}
			p.SetState(7427)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserParserIGNORE {
				{
					p.SetState(7426)
					p.IgnoreNulls()
				}

			}
			p.SetState(7433)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(7429)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7430)
					p.expression(0)
				}

				p.SetState(7435)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7438)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7440)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserIGNORE {
			{
				p.SetState(7439)
				p.IgnoreNulls()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetResult returns the result rule contexts.
	GetResult() IExpressionContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetResult sets the result rule contexts.
	SetResult(IExpressionContext)

	// Getter signatures
	WHEN() antlr.TerminalNode
	THEN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExpressionContext
	result    IExpressionContext
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_whenClause
	return p
}

func InitEmptyWhenClauseContext(p *WhenClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_whenClause
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) GetCondition() IExpressionContext { return s.condition }

func (s *WhenClauseContext) GetResult() IExpressionContext { return s.result }

func (s *WhenClauseContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *WhenClauseContext) SetResult(v IExpressionContext) { s.result = v }

func (s *WhenClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHEN, 0)
}

func (s *WhenClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTHEN, 0)
}

func (s *WhenClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WhenClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterWhenClause(s)
	}
}

func (s *WhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitWhenClause(s)
	}
}

func (s *WhenClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitWhenClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 888, DorisSQLParserParserRULE_whenClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7444)
		p.Match(DorisSQLParserParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7445)

		var _x = p.expression(0)

		localctx.(*WhenClauseContext).condition = _x
	}
	{
		p.SetState(7446)
		p.Match(DorisSQLParserParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7447)

		var _x = p.expression(0)

		localctx.(*WhenClauseContext).result = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOverContext is an interface to support dynamic dispatch.
type IOverContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetPartition returns the partition rule context list.
	GetPartition() []IExpressionContext

	// SetPartition sets the partition rule context list.
	SetPartition([]IExpressionContext)

	// Getter signatures
	OVER() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	ORDER() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	WindowFrame() IWindowFrameContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	BracketHint() IBracketHintContext

	// IsOverContext differentiates from other interfaces.
	IsOverContext()
}

type OverContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	_expression IExpressionContext
	partition   []IExpressionContext
}

func NewEmptyOverContext() *OverContext {
	var p = new(OverContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_over
	return p
}

func InitEmptyOverContext(p *OverContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_over
}

func (*OverContext) IsOverContext() {}

func NewOverContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverContext {
	var p = new(OverContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_over

	return p
}

func (s *OverContext) GetParser() antlr.Parser { return s.parser }

func (s *OverContext) Get_expression() IExpressionContext { return s._expression }

func (s *OverContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *OverContext) GetPartition() []IExpressionContext { return s.partition }

func (s *OverContext) SetPartition(v []IExpressionContext) { s.partition = v }

func (s *OverContext) OVER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOVER, 0)
}

func (s *OverContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPARTITION, 0)
}

func (s *OverContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserBY)
}

func (s *OverContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, i)
}

func (s *OverContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserORDER, 0)
}

func (s *OverContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *OverContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *OverContext) WindowFrame() IWindowFrameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameContext)
}

func (s *OverContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OverContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OverContext) BracketHint() IBracketHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBracketHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBracketHintContext)
}

func (s *OverContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterOver(s)
	}
}

func (s *OverContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitOver(s)
	}
}

func (s *OverContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitOver(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Over() (localctx IOverContext) {
	localctx = NewOverContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 890, DorisSQLParserParserRULE_over)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7449)
		p.Match(DorisSQLParserParserOVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7450)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7464)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserT__5 || _la == DorisSQLParserParserPARTITION {
		p.SetState(7452)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__5 {
			{
				p.SetState(7451)
				p.BracketHint()
			}

		}
		{
			p.SetState(7454)
			p.Match(DorisSQLParserParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7455)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7456)

			var _x = p.expression(0)

			localctx.(*OverContext)._expression = _x
		}
		localctx.(*OverContext).partition = append(localctx.(*OverContext).partition, localctx.(*OverContext)._expression)
		p.SetState(7461)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(7457)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7458)

				var _x = p.expression(0)

				localctx.(*OverContext)._expression = _x
			}
			localctx.(*OverContext).partition = append(localctx.(*OverContext).partition, localctx.(*OverContext)._expression)

			p.SetState(7463)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(7476)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserORDER {
		{
			p.SetState(7466)
			p.Match(DorisSQLParserParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7467)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7468)
			p.SortItem()
		}
		p.SetState(7473)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisSQLParserParserT__2 {
			{
				p.SetState(7469)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7470)
				p.SortItem()
			}

			p.SetState(7475)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(7479)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserRANGE || _la == DorisSQLParserParserROWS {
		{
			p.SetState(7478)
			p.WindowFrame()
		}

	}
	{
		p.SetState(7481)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIgnoreNullsContext is an interface to support dynamic dispatch.
type IIgnoreNullsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IGNORE() antlr.TerminalNode
	NULLS() antlr.TerminalNode

	// IsIgnoreNullsContext differentiates from other interfaces.
	IsIgnoreNullsContext()
}

type IgnoreNullsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIgnoreNullsContext() *IgnoreNullsContext {
	var p = new(IgnoreNullsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_ignoreNulls
	return p
}

func InitEmptyIgnoreNullsContext(p *IgnoreNullsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_ignoreNulls
}

func (*IgnoreNullsContext) IsIgnoreNullsContext() {}

func NewIgnoreNullsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IgnoreNullsContext {
	var p = new(IgnoreNullsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_ignoreNulls

	return p
}

func (s *IgnoreNullsContext) GetParser() antlr.Parser { return s.parser }

func (s *IgnoreNullsContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIGNORE, 0)
}

func (s *IgnoreNullsContext) NULLS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNULLS, 0)
}

func (s *IgnoreNullsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IgnoreNullsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IgnoreNullsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterIgnoreNulls(s)
	}
}

func (s *IgnoreNullsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitIgnoreNulls(s)
	}
}

func (s *IgnoreNullsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitIgnoreNulls(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) IgnoreNulls() (localctx IIgnoreNullsContext) {
	localctx = NewIgnoreNullsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 892, DorisSQLParserParserRULE_ignoreNulls)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7483)
		p.Match(DorisSQLParserParserIGNORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7484)
		p.Match(DorisSQLParserParserNULLS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameContext is an interface to support dynamic dispatch.
type IWindowFrameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFrameType returns the frameType token.
	GetFrameType() antlr.Token

	// SetFrameType sets the frameType token.
	SetFrameType(antlr.Token)

	// GetStart_ returns the start_ rule contexts.
	GetStart_() IFrameBoundContext

	// GetEnd returns the end rule contexts.
	GetEnd() IFrameBoundContext

	// SetStart_ sets the start_ rule contexts.
	SetStart_(IFrameBoundContext)

	// SetEnd sets the end rule contexts.
	SetEnd(IFrameBoundContext)

	// Getter signatures
	RANGE() antlr.TerminalNode
	AllFrameBound() []IFrameBoundContext
	FrameBound(i int) IFrameBoundContext
	ROWS() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	AND() antlr.TerminalNode

	// IsWindowFrameContext differentiates from other interfaces.
	IsWindowFrameContext()
}

type WindowFrameContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	frameType antlr.Token
	start_    IFrameBoundContext
	end       IFrameBoundContext
}

func NewEmptyWindowFrameContext() *WindowFrameContext {
	var p = new(WindowFrameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_windowFrame
	return p
}

func InitEmptyWindowFrameContext(p *WindowFrameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_windowFrame
}

func (*WindowFrameContext) IsWindowFrameContext() {}

func NewWindowFrameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameContext {
	var p = new(WindowFrameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_windowFrame

	return p
}

func (s *WindowFrameContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameContext) GetFrameType() antlr.Token { return s.frameType }

func (s *WindowFrameContext) SetFrameType(v antlr.Token) { s.frameType = v }

func (s *WindowFrameContext) GetStart_() IFrameBoundContext { return s.start_ }

func (s *WindowFrameContext) GetEnd() IFrameBoundContext { return s.end }

func (s *WindowFrameContext) SetStart_(v IFrameBoundContext) { s.start_ = v }

func (s *WindowFrameContext) SetEnd(v IFrameBoundContext) { s.end = v }

func (s *WindowFrameContext) RANGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRANGE, 0)
}

func (s *WindowFrameContext) AllFrameBound() []IFrameBoundContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrameBoundContext); ok {
			len++
		}
	}

	tst := make([]IFrameBoundContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrameBoundContext); ok {
			tst[i] = t.(IFrameBoundContext)
			i++
		}
	}

	return tst
}

func (s *WindowFrameContext) FrameBound(i int) IFrameBoundContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameBoundContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameBoundContext)
}

func (s *WindowFrameContext) ROWS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROWS, 0)
}

func (s *WindowFrameContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBETWEEN, 0)
}

func (s *WindowFrameContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAND, 0)
}

func (s *WindowFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterWindowFrame(s)
	}
}

func (s *WindowFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitWindowFrame(s)
	}
}

func (s *WindowFrameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitWindowFrame(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) WindowFrame() (localctx IWindowFrameContext) {
	localctx = NewWindowFrameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 894, DorisSQLParserParserRULE_windowFrame)
	p.SetState(7502)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 880, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7486)

			var _m = p.Match(DorisSQLParserParserRANGE)

			localctx.(*WindowFrameContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7487)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start_ = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7488)

			var _m = p.Match(DorisSQLParserParserROWS)

			localctx.(*WindowFrameContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7489)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start_ = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7490)

			var _m = p.Match(DorisSQLParserParserRANGE)

			localctx.(*WindowFrameContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7491)
			p.Match(DorisSQLParserParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7492)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start_ = _x
		}
		{
			p.SetState(7493)
			p.Match(DorisSQLParserParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7494)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).end = _x
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7496)

			var _m = p.Match(DorisSQLParserParserROWS)

			localctx.(*WindowFrameContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7497)
			p.Match(DorisSQLParserParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7498)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start_ = _x
		}
		{
			p.SetState(7499)
			p.Match(DorisSQLParserParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7500)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).end = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameBoundContext is an interface to support dynamic dispatch.
type IFrameBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFrameBoundContext differentiates from other interfaces.
	IsFrameBoundContext()
}

type FrameBoundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameBoundContext() *FrameBoundContext {
	var p = new(FrameBoundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_frameBound
	return p
}

func InitEmptyFrameBoundContext(p *FrameBoundContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_frameBound
}

func (*FrameBoundContext) IsFrameBoundContext() {}

func NewFrameBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameBoundContext {
	var p = new(FrameBoundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_frameBound

	return p
}

func (s *FrameBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameBoundContext) CopyAll(ctx *FrameBoundContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FrameBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BoundedFrameContext struct {
	FrameBoundContext
	boundType antlr.Token
}

func NewBoundedFrameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BoundedFrameContext {
	var p = new(BoundedFrameContext)

	InitEmptyFrameBoundContext(&p.FrameBoundContext)
	p.parser = parser
	p.CopyAll(ctx.(*FrameBoundContext))

	return p
}

func (s *BoundedFrameContext) GetBoundType() antlr.Token { return s.boundType }

func (s *BoundedFrameContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *BoundedFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoundedFrameContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BoundedFrameContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPRECEDING, 0)
}

func (s *BoundedFrameContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFOLLOWING, 0)
}

func (s *BoundedFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterBoundedFrame(s)
	}
}

func (s *BoundedFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitBoundedFrame(s)
	}
}

func (s *BoundedFrameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitBoundedFrame(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnboundedFrameContext struct {
	FrameBoundContext
	boundType antlr.Token
}

func NewUnboundedFrameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnboundedFrameContext {
	var p = new(UnboundedFrameContext)

	InitEmptyFrameBoundContext(&p.FrameBoundContext)
	p.parser = parser
	p.CopyAll(ctx.(*FrameBoundContext))

	return p
}

func (s *UnboundedFrameContext) GetBoundType() antlr.Token { return s.boundType }

func (s *UnboundedFrameContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *UnboundedFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnboundedFrameContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUNBOUNDED, 0)
}

func (s *UnboundedFrameContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPRECEDING, 0)
}

func (s *UnboundedFrameContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFOLLOWING, 0)
}

func (s *UnboundedFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterUnboundedFrame(s)
	}
}

func (s *UnboundedFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitUnboundedFrame(s)
	}
}

func (s *UnboundedFrameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitUnboundedFrame(s)

	default:
		return t.VisitChildren(s)
	}
}

type CurrentRowBoundContext struct {
	FrameBoundContext
}

func NewCurrentRowBoundContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentRowBoundContext {
	var p = new(CurrentRowBoundContext)

	InitEmptyFrameBoundContext(&p.FrameBoundContext)
	p.parser = parser
	p.CopyAll(ctx.(*FrameBoundContext))

	return p
}

func (s *CurrentRowBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentRowBoundContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCURRENT, 0)
}

func (s *CurrentRowBoundContext) ROW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROW, 0)
}

func (s *CurrentRowBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterCurrentRowBound(s)
	}
}

func (s *CurrentRowBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitCurrentRowBound(s)
	}
}

func (s *CurrentRowBoundContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitCurrentRowBound(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) FrameBound() (localctx IFrameBoundContext) {
	localctx = NewFrameBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 896, DorisSQLParserParserRULE_frameBound)
	var _la int

	p.SetState(7513)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 881, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUnboundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7504)
			p.Match(DorisSQLParserParserUNBOUNDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7505)

			var _m = p.Match(DorisSQLParserParserPRECEDING)

			localctx.(*UnboundedFrameContext).boundType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewUnboundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7506)
			p.Match(DorisSQLParserParserUNBOUNDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7507)

			var _m = p.Match(DorisSQLParserParserFOLLOWING)

			localctx.(*UnboundedFrameContext).boundType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewCurrentRowBoundContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7508)
			p.Match(DorisSQLParserParserCURRENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7509)
			p.Match(DorisSQLParserParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewBoundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7510)
			p.expression(0)
		}
		{
			p.SetState(7511)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*BoundedFrameContext).boundType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserFOLLOWING || _la == DorisSQLParserParserPRECEDING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*BoundedFrameContext).boundType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBackupRestoreObjectDescContext is an interface to support dynamic dispatch.
type IBackupRestoreObjectDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BackupRestoreTableDesc() IBackupRestoreTableDescContext
	ALL() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	FUNCTION() antlr.TerminalNode
	FUNCTIONS() antlr.TerminalNode
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	VIEWS() antlr.TerminalNode

	// IsBackupRestoreObjectDescContext differentiates from other interfaces.
	IsBackupRestoreObjectDescContext()
}

type BackupRestoreObjectDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackupRestoreObjectDescContext() *BackupRestoreObjectDescContext {
	var p = new(BackupRestoreObjectDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_backupRestoreObjectDesc
	return p
}

func InitEmptyBackupRestoreObjectDescContext(p *BackupRestoreObjectDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_backupRestoreObjectDesc
}

func (*BackupRestoreObjectDescContext) IsBackupRestoreObjectDescContext() {}

func NewBackupRestoreObjectDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BackupRestoreObjectDescContext {
	var p = new(BackupRestoreObjectDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_backupRestoreObjectDesc

	return p
}

func (s *BackupRestoreObjectDescContext) GetParser() antlr.Parser { return s.parser }

func (s *BackupRestoreObjectDescContext) BackupRestoreTableDesc() IBackupRestoreTableDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackupRestoreTableDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackupRestoreTableDescContext)
}

func (s *BackupRestoreObjectDescContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, 0)
}

func (s *BackupRestoreObjectDescContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *BackupRestoreObjectDescContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFUNCTION, 0)
}

func (s *BackupRestoreObjectDescContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFUNCTIONS, 0)
}

func (s *BackupRestoreObjectDescContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *BackupRestoreObjectDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BackupRestoreObjectDescContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLE, 0)
}

func (s *BackupRestoreObjectDescContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLES, 0)
}

func (s *BackupRestoreObjectDescContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMATERIALIZED, 0)
}

func (s *BackupRestoreObjectDescContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVIEW, 0)
}

func (s *BackupRestoreObjectDescContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVIEWS, 0)
}

func (s *BackupRestoreObjectDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackupRestoreObjectDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BackupRestoreObjectDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterBackupRestoreObjectDesc(s)
	}
}

func (s *BackupRestoreObjectDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitBackupRestoreObjectDesc(s)
	}
}

func (s *BackupRestoreObjectDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitBackupRestoreObjectDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) BackupRestoreObjectDesc() (localctx IBackupRestoreObjectDescContext) {
	localctx = NewBackupRestoreObjectDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 898, DorisSQLParserParserRULE_backupRestoreObjectDesc)
	var _la int

	p.SetState(7554)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 889, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7515)
			p.BackupRestoreTableDesc()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(7524)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserParserALL:
			{
				p.SetState(7516)
				p.Match(DorisSQLParserParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7517)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserParserFUNCTION || _la == DorisSQLParserParserFUNCTIONS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		case DorisSQLParserParserFUNCTION, DorisSQLParserParserFUNCTIONS:
			{
				p.SetState(7518)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserParserFUNCTION || _la == DorisSQLParserParserFUNCTIONS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(7519)
				p.QualifiedName()
			}
			p.SetState(7522)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserParserAS {
				{
					p.SetState(7520)
					p.Match(DorisSQLParserParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7521)
					p.Identifier()
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(7530)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserParserALL:
			{
				p.SetState(7526)
				p.Match(DorisSQLParserParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7527)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserParserTABLE || _la == DorisSQLParserParserTABLES) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		case DorisSQLParserParserTABLE, DorisSQLParserParserTABLES:
			{
				p.SetState(7528)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserParserTABLE || _la == DorisSQLParserParserTABLES) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(7529)
				p.BackupRestoreTableDesc()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(7542)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserParserALL:
			{
				p.SetState(7532)
				p.Match(DorisSQLParserParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7533)
				p.Match(DorisSQLParserParserMATERIALIZED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7534)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserParserVIEW || _la == DorisSQLParserParserVIEWS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		case DorisSQLParserParserMATERIALIZED:
			{
				p.SetState(7535)
				p.Match(DorisSQLParserParserMATERIALIZED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7536)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserParserVIEW || _la == DorisSQLParserParserVIEWS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(7537)
				p.QualifiedName()
			}
			p.SetState(7540)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserParserAS {
				{
					p.SetState(7538)
					p.Match(DorisSQLParserParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7539)
					p.Identifier()
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(7552)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserParserALL:
			{
				p.SetState(7544)
				p.Match(DorisSQLParserParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7545)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserParserVIEW || _la == DorisSQLParserParserVIEWS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		case DorisSQLParserParserVIEW, DorisSQLParserParserVIEWS:
			{
				p.SetState(7546)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisSQLParserParserVIEW || _la == DorisSQLParserParserVIEWS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(7547)
				p.QualifiedName()
			}
			p.SetState(7550)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisSQLParserParserAS {
				{
					p.SetState(7548)
					p.Match(DorisSQLParserParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7549)
					p.Identifier()
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableDescContext is an interface to support dynamic dispatch.
type ITableDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext

	// IsTableDescContext differentiates from other interfaces.
	IsTableDescContext()
}

type TableDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableDescContext() *TableDescContext {
	var p = new(TableDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_tableDesc
	return p
}

func InitEmptyTableDescContext(p *TableDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_tableDesc
}

func (*TableDescContext) IsTableDescContext() {}

func NewTableDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableDescContext {
	var p = new(TableDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_tableDesc

	return p
}

func (s *TableDescContext) GetParser() antlr.Parser { return s.parser }

func (s *TableDescContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableDescContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *TableDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTableDesc(s)
	}
}

func (s *TableDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTableDesc(s)
	}
}

func (s *TableDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTableDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) TableDesc() (localctx ITableDescContext) {
	localctx = NewTableDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 900, DorisSQLParserParserRULE_tableDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7556)
		p.QualifiedName()
	}
	p.SetState(7558)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPARTITION || _la == DorisSQLParserParserPARTITIONS || _la == DorisSQLParserParserTEMPORARY {
		{
			p.SetState(7557)
			p.PartitionNames()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBackupRestoreTableDescContext is an interface to support dynamic dispatch.
type IBackupRestoreTableDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsBackupRestoreTableDescContext differentiates from other interfaces.
	IsBackupRestoreTableDescContext()
}

type BackupRestoreTableDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackupRestoreTableDescContext() *BackupRestoreTableDescContext {
	var p = new(BackupRestoreTableDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_backupRestoreTableDesc
	return p
}

func InitEmptyBackupRestoreTableDescContext(p *BackupRestoreTableDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_backupRestoreTableDesc
}

func (*BackupRestoreTableDescContext) IsBackupRestoreTableDescContext() {}

func NewBackupRestoreTableDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BackupRestoreTableDescContext {
	var p = new(BackupRestoreTableDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_backupRestoreTableDesc

	return p
}

func (s *BackupRestoreTableDescContext) GetParser() antlr.Parser { return s.parser }

func (s *BackupRestoreTableDescContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *BackupRestoreTableDescContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *BackupRestoreTableDescContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *BackupRestoreTableDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BackupRestoreTableDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackupRestoreTableDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BackupRestoreTableDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterBackupRestoreTableDesc(s)
	}
}

func (s *BackupRestoreTableDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitBackupRestoreTableDesc(s)
	}
}

func (s *BackupRestoreTableDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitBackupRestoreTableDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) BackupRestoreTableDesc() (localctx IBackupRestoreTableDescContext) {
	localctx = NewBackupRestoreTableDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 902, DorisSQLParserParserRULE_backupRestoreTableDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7560)
		p.QualifiedName()
	}
	p.SetState(7562)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPARTITION || _la == DorisSQLParserParserPARTITIONS || _la == DorisSQLParserParserTEMPORARY {
		{
			p.SetState(7561)
			p.PartitionNames()
		}

	}
	p.SetState(7566)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserAS {
		{
			p.SetState(7564)
			p.Match(DorisSQLParserParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7565)
			p.Identifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplainDescContext is an interface to support dynamic dispatch.
type IExplainDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	EXPLAIN() antlr.TerminalNode
	LOGICAL() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	VERBOSE() antlr.TerminalNode
	COSTS() antlr.TerminalNode
	SCHEDULER() antlr.TerminalNode

	// IsExplainDescContext differentiates from other interfaces.
	IsExplainDescContext()
}

type ExplainDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainDescContext() *ExplainDescContext {
	var p = new(ExplainDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_explainDesc
	return p
}

func InitEmptyExplainDescContext(p *ExplainDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_explainDesc
}

func (*ExplainDescContext) IsExplainDescContext() {}

func NewExplainDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainDescContext {
	var p = new(ExplainDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_explainDesc

	return p
}

func (s *ExplainDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainDescContext) DESC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDESC, 0)
}

func (s *ExplainDescContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDESCRIBE, 0)
}

func (s *ExplainDescContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXPLAIN, 0)
}

func (s *ExplainDescContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOGICAL, 0)
}

func (s *ExplainDescContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserANALYZE, 0)
}

func (s *ExplainDescContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVERBOSE, 0)
}

func (s *ExplainDescContext) COSTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOSTS, 0)
}

func (s *ExplainDescContext) SCHEDULER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSCHEDULER, 0)
}

func (s *ExplainDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplainDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterExplainDesc(s)
	}
}

func (s *ExplainDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitExplainDesc(s)
	}
}

func (s *ExplainDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitExplainDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ExplainDesc() (localctx IExplainDescContext) {
	localctx = NewExplainDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 904, DorisSQLParserParserRULE_explainDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7568)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-125)) & ^0x3f) == 0 && ((int64(1)<<(_la-125))&16777219) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(7570)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserANALYZE || _la == DorisSQLParserParserCOSTS || _la == DorisSQLParserParserLOGICAL || _la == DorisSQLParserParserSCHEDULER || _la == DorisSQLParserParserVERBOSE {
		{
			p.SetState(7569)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserANALYZE || _la == DorisSQLParserParserCOSTS || _la == DorisSQLParserParserLOGICAL || _la == DorisSQLParserParserSCHEDULER || _la == DorisSQLParserParserVERBOSE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptimizerTraceContext is an interface to support dynamic dispatch.
type IOptimizerTraceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRACE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	LOGS() antlr.TerminalNode
	TIMES() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	REASON() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsOptimizerTraceContext differentiates from other interfaces.
	IsOptimizerTraceContext()
}

type OptimizerTraceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptimizerTraceContext() *OptimizerTraceContext {
	var p = new(OptimizerTraceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_optimizerTrace
	return p
}

func InitEmptyOptimizerTraceContext(p *OptimizerTraceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_optimizerTrace
}

func (*OptimizerTraceContext) IsOptimizerTraceContext() {}

func NewOptimizerTraceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptimizerTraceContext {
	var p = new(OptimizerTraceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_optimizerTrace

	return p
}

func (s *OptimizerTraceContext) GetParser() antlr.Parser { return s.parser }

func (s *OptimizerTraceContext) TRACE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTRACE, 0)
}

func (s *OptimizerTraceContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserALL, 0)
}

func (s *OptimizerTraceContext) LOGS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOGS, 0)
}

func (s *OptimizerTraceContext) TIMES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTIMES, 0)
}

func (s *OptimizerTraceContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVALUES, 0)
}

func (s *OptimizerTraceContext) REASON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREASON, 0)
}

func (s *OptimizerTraceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *OptimizerTraceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptimizerTraceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptimizerTraceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterOptimizerTrace(s)
	}
}

func (s *OptimizerTraceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitOptimizerTrace(s)
	}
}

func (s *OptimizerTraceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitOptimizerTrace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) OptimizerTrace() (localctx IOptimizerTraceContext) {
	localctx = NewOptimizerTraceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 906, DorisSQLParserParserRULE_optimizerTrace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7572)
		p.Match(DorisSQLParserParserTRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7573)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserALL || _la == DorisSQLParserParserLOGS || _la == DorisSQLParserParserREASON || _la == DorisSQLParserParserTIMES || _la == DorisSQLParserParserVALUES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(7575)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262756702208) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-6664167256628462851) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-1331487429127569487) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&-7546427580836201) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-4573491655345179) != 0) || ((int64((_la-324)) & ^0x3f) == 0 && ((int64(1)<<(_la-324))&9114828243924942831) != 0) || ((int64((_la-389)) & ^0x3f) == 0 && ((int64(1)<<(_la-389))&-6956096606152176261) != 0) || ((int64((_la-453)) & ^0x3f) == 0 && ((int64(1)<<(_la-453))&70849595962729) != 0) || ((int64((_la-525)) & ^0x3f) == 0 && ((int64(1)<<(_la-525))&263) != 0) {
		{
			p.SetState(7574)
			p.Identifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionExprContext is an interface to support dynamic dispatch.
type IPartitionExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	FunctionCall() IFunctionCallContext

	// IsPartitionExprContext differentiates from other interfaces.
	IsPartitionExprContext()
}

type PartitionExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionExprContext() *PartitionExprContext {
	var p = new(PartitionExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_partitionExpr
	return p
}

func InitEmptyPartitionExprContext(p *PartitionExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_partitionExpr
}

func (*PartitionExprContext) IsPartitionExprContext() {}

func NewPartitionExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionExprContext {
	var p = new(PartitionExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_partitionExpr

	return p
}

func (s *PartitionExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionExprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PartitionExprContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *PartitionExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPartitionExpr(s)
	}
}

func (s *PartitionExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPartitionExpr(s)
	}
}

func (s *PartitionExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPartitionExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PartitionExpr() (localctx IPartitionExprContext) {
	localctx = NewPartitionExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 908, DorisSQLParserParserRULE_partitionExpr)
	p.SetState(7579)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 895, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7577)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7578)
			p.FunctionCall()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDescContext is an interface to support dynamic dispatch.
type IPartitionDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	AllRangePartitionDesc() []IRangePartitionDescContext
	RangePartitionDesc(i int) IRangePartitionDescContext
	PrimaryExpression() IPrimaryExpressionContext
	LIST() antlr.TerminalNode
	AllListPartitionDesc() []IListPartitionDescContext
	ListPartitionDesc(i int) IListPartitionDescContext
	FunctionCall() IFunctionCallContext
	AllPartitionExpr() []IPartitionExprContext
	PartitionExpr(i int) IPartitionExprContext

	// IsPartitionDescContext differentiates from other interfaces.
	IsPartitionDescContext()
}

type PartitionDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDescContext() *PartitionDescContext {
	var p = new(PartitionDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_partitionDesc
	return p
}

func InitEmptyPartitionDescContext(p *PartitionDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_partitionDesc
}

func (*PartitionDescContext) IsPartitionDescContext() {}

func NewPartitionDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDescContext {
	var p = new(PartitionDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_partitionDesc

	return p
}

func (s *PartitionDescContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDescContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPARTITION, 0)
}

func (s *PartitionDescContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *PartitionDescContext) RANGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRANGE, 0)
}

func (s *PartitionDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PartitionDescContext) AllRangePartitionDesc() []IRangePartitionDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRangePartitionDescContext); ok {
			len++
		}
	}

	tst := make([]IRangePartitionDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRangePartitionDescContext); ok {
			tst[i] = t.(IRangePartitionDescContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDescContext) RangePartitionDesc(i int) IRangePartitionDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangePartitionDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangePartitionDescContext)
}

func (s *PartitionDescContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *PartitionDescContext) LIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIST, 0)
}

func (s *PartitionDescContext) AllListPartitionDesc() []IListPartitionDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IListPartitionDescContext); ok {
			len++
		}
	}

	tst := make([]IListPartitionDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IListPartitionDescContext); ok {
			tst[i] = t.(IListPartitionDescContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDescContext) ListPartitionDesc(i int) IListPartitionDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListPartitionDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListPartitionDescContext)
}

func (s *PartitionDescContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *PartitionDescContext) AllPartitionExpr() []IPartitionExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionExprContext); ok {
			len++
		}
	}

	tst := make([]IPartitionExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionExprContext); ok {
			tst[i] = t.(IPartitionExprContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDescContext) PartitionExpr(i int) IPartitionExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionExprContext)
}

func (s *PartitionDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPartitionDesc(s)
	}
}

func (s *PartitionDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPartitionDesc(s)
	}
}

func (s *PartitionDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPartitionDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PartitionDesc() (localctx IPartitionDescContext) {
	localctx = NewPartitionDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 910, DorisSQLParserParserRULE_partitionDesc)
	var _la int

	var _alt int

	p.SetState(7669)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 907, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7581)
			p.Match(DorisSQLParserParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7582)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7583)
			p.Match(DorisSQLParserParserRANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7584)
			p.IdentifierList()
		}
		{
			p.SetState(7585)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7594)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserPARTITION || _la == DorisSQLParserParserSTART {
			{
				p.SetState(7586)
				p.RangePartitionDesc()
			}
			p.SetState(7591)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(7587)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7588)
					p.RangePartitionDesc()
				}

				p.SetState(7593)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7596)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7598)
			p.Match(DorisSQLParserParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7599)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7600)
			p.Match(DorisSQLParserParserRANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7601)
			p.primaryExpression(0)
		}
		{
			p.SetState(7602)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7611)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserPARTITION || _la == DorisSQLParserParserSTART {
			{
				p.SetState(7603)
				p.RangePartitionDesc()
			}
			p.SetState(7608)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(7604)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7605)
					p.RangePartitionDesc()
				}

				p.SetState(7610)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7613)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7615)
			p.Match(DorisSQLParserParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7616)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7618)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserLIST {
			{
				p.SetState(7617)
				p.Match(DorisSQLParserParserLIST)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7620)
			p.IdentifierList()
		}
		{
			p.SetState(7621)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7630)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserPARTITION {
			{
				p.SetState(7622)
				p.ListPartitionDesc()
			}
			p.SetState(7627)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(7623)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7624)
					p.ListPartitionDesc()
				}

				p.SetState(7629)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7632)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7634)
			p.Match(DorisSQLParserParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7635)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7637)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserLIST {
			{
				p.SetState(7636)
				p.Match(DorisSQLParserParserLIST)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7639)
			p.IdentifierList()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7640)
			p.Match(DorisSQLParserParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7641)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7642)
			p.FunctionCall()
		}
		{
			p.SetState(7643)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7652)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserPARTITION || _la == DorisSQLParserParserSTART {
			{
				p.SetState(7644)
				p.RangePartitionDesc()
			}
			p.SetState(7649)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisSQLParserParserT__2 {
				{
					p.SetState(7645)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7646)
					p.RangePartitionDesc()
				}

				p.SetState(7651)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7654)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7656)
			p.Match(DorisSQLParserParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7657)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7658)
			p.FunctionCall()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7659)
			p.Match(DorisSQLParserParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7660)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7661)
			p.PartitionExpr()
		}
		p.SetState(7666)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 906, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(7662)
					p.Match(DorisSQLParserParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7663)
					p.PartitionExpr()
				}

			}
			p.SetState(7668)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 906, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListPartitionDescContext is an interface to support dynamic dispatch.
type IListPartitionDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleItemListPartitionDesc() ISingleItemListPartitionDescContext
	MultiItemListPartitionDesc() IMultiItemListPartitionDescContext

	// IsListPartitionDescContext differentiates from other interfaces.
	IsListPartitionDescContext()
}

type ListPartitionDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListPartitionDescContext() *ListPartitionDescContext {
	var p = new(ListPartitionDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_listPartitionDesc
	return p
}

func InitEmptyListPartitionDescContext(p *ListPartitionDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_listPartitionDesc
}

func (*ListPartitionDescContext) IsListPartitionDescContext() {}

func NewListPartitionDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListPartitionDescContext {
	var p = new(ListPartitionDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_listPartitionDesc

	return p
}

func (s *ListPartitionDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ListPartitionDescContext) SingleItemListPartitionDesc() ISingleItemListPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleItemListPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleItemListPartitionDescContext)
}

func (s *ListPartitionDescContext) MultiItemListPartitionDesc() IMultiItemListPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiItemListPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiItemListPartitionDescContext)
}

func (s *ListPartitionDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListPartitionDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListPartitionDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterListPartitionDesc(s)
	}
}

func (s *ListPartitionDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitListPartitionDesc(s)
	}
}

func (s *ListPartitionDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitListPartitionDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ListPartitionDesc() (localctx IListPartitionDescContext) {
	localctx = NewListPartitionDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 912, DorisSQLParserParserRULE_listPartitionDesc)
	p.SetState(7673)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 908, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7671)
			p.SingleItemListPartitionDesc()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7672)
			p.MultiItemListPartitionDesc()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleItemListPartitionDescContext is an interface to support dynamic dispatch.
type ISingleItemListPartitionDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	VALUES() antlr.TerminalNode
	IN() antlr.TerminalNode
	SingleListPartitionValues() ISingleListPartitionValuesContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsSingleItemListPartitionDescContext differentiates from other interfaces.
	IsSingleItemListPartitionDescContext()
}

type SingleItemListPartitionDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleItemListPartitionDescContext() *SingleItemListPartitionDescContext {
	var p = new(SingleItemListPartitionDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_singleItemListPartitionDesc
	return p
}

func InitEmptySingleItemListPartitionDescContext(p *SingleItemListPartitionDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_singleItemListPartitionDesc
}

func (*SingleItemListPartitionDescContext) IsSingleItemListPartitionDescContext() {}

func NewSingleItemListPartitionDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleItemListPartitionDescContext {
	var p = new(SingleItemListPartitionDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_singleItemListPartitionDesc

	return p
}

func (s *SingleItemListPartitionDescContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleItemListPartitionDescContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPARTITION, 0)
}

func (s *SingleItemListPartitionDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SingleItemListPartitionDescContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVALUES, 0)
}

func (s *SingleItemListPartitionDescContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *SingleItemListPartitionDescContext) SingleListPartitionValues() ISingleListPartitionValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleListPartitionValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleListPartitionValuesContext)
}

func (s *SingleItemListPartitionDescContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *SingleItemListPartitionDescContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *SingleItemListPartitionDescContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *SingleItemListPartitionDescContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *SingleItemListPartitionDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleItemListPartitionDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleItemListPartitionDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSingleItemListPartitionDesc(s)
	}
}

func (s *SingleItemListPartitionDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSingleItemListPartitionDesc(s)
	}
}

func (s *SingleItemListPartitionDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSingleItemListPartitionDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SingleItemListPartitionDesc() (localctx ISingleItemListPartitionDescContext) {
	localctx = NewSingleItemListPartitionDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 914, DorisSQLParserParserRULE_singleItemListPartitionDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7675)
		p.Match(DorisSQLParserParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7679)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(7676)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7677)
			p.Match(DorisSQLParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7678)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(7681)
		p.Identifier()
	}
	{
		p.SetState(7682)
		p.Match(DorisSQLParserParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7683)
		p.Match(DorisSQLParserParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7684)
		p.SingleListPartitionValues()
	}
	p.SetState(7686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserT__1 {
		{
			p.SetState(7685)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiItemListPartitionDescContext is an interface to support dynamic dispatch.
type IMultiItemListPartitionDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	VALUES() antlr.TerminalNode
	IN() antlr.TerminalNode
	MultiListPartitionValues() IMultiListPartitionValuesContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsMultiItemListPartitionDescContext differentiates from other interfaces.
	IsMultiItemListPartitionDescContext()
}

type MultiItemListPartitionDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiItemListPartitionDescContext() *MultiItemListPartitionDescContext {
	var p = new(MultiItemListPartitionDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_multiItemListPartitionDesc
	return p
}

func InitEmptyMultiItemListPartitionDescContext(p *MultiItemListPartitionDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_multiItemListPartitionDesc
}

func (*MultiItemListPartitionDescContext) IsMultiItemListPartitionDescContext() {}

func NewMultiItemListPartitionDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiItemListPartitionDescContext {
	var p = new(MultiItemListPartitionDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_multiItemListPartitionDesc

	return p
}

func (s *MultiItemListPartitionDescContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiItemListPartitionDescContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPARTITION, 0)
}

func (s *MultiItemListPartitionDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MultiItemListPartitionDescContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVALUES, 0)
}

func (s *MultiItemListPartitionDescContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIN, 0)
}

func (s *MultiItemListPartitionDescContext) MultiListPartitionValues() IMultiListPartitionValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiListPartitionValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiListPartitionValuesContext)
}

func (s *MultiItemListPartitionDescContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *MultiItemListPartitionDescContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *MultiItemListPartitionDescContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *MultiItemListPartitionDescContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *MultiItemListPartitionDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiItemListPartitionDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiItemListPartitionDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterMultiItemListPartitionDesc(s)
	}
}

func (s *MultiItemListPartitionDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitMultiItemListPartitionDesc(s)
	}
}

func (s *MultiItemListPartitionDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitMultiItemListPartitionDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) MultiItemListPartitionDesc() (localctx IMultiItemListPartitionDescContext) {
	localctx = NewMultiItemListPartitionDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 916, DorisSQLParserParserRULE_multiItemListPartitionDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7688)
		p.Match(DorisSQLParserParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7692)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(7689)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7690)
			p.Match(DorisSQLParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7691)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(7694)
		p.Identifier()
	}
	{
		p.SetState(7695)
		p.Match(DorisSQLParserParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7696)
		p.Match(DorisSQLParserParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7697)
		p.MultiListPartitionValues()
	}
	p.SetState(7699)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserT__1 {
		{
			p.SetState(7698)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiListPartitionValuesContext is an interface to support dynamic dispatch.
type IMultiListPartitionValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSingleListPartitionValues() []ISingleListPartitionValuesContext
	SingleListPartitionValues(i int) ISingleListPartitionValuesContext

	// IsMultiListPartitionValuesContext differentiates from other interfaces.
	IsMultiListPartitionValuesContext()
}

type MultiListPartitionValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiListPartitionValuesContext() *MultiListPartitionValuesContext {
	var p = new(MultiListPartitionValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_multiListPartitionValues
	return p
}

func InitEmptyMultiListPartitionValuesContext(p *MultiListPartitionValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_multiListPartitionValues
}

func (*MultiListPartitionValuesContext) IsMultiListPartitionValuesContext() {}

func NewMultiListPartitionValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiListPartitionValuesContext {
	var p = new(MultiListPartitionValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_multiListPartitionValues

	return p
}

func (s *MultiListPartitionValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiListPartitionValuesContext) AllSingleListPartitionValues() []ISingleListPartitionValuesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleListPartitionValuesContext); ok {
			len++
		}
	}

	tst := make([]ISingleListPartitionValuesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleListPartitionValuesContext); ok {
			tst[i] = t.(ISingleListPartitionValuesContext)
			i++
		}
	}

	return tst
}

func (s *MultiListPartitionValuesContext) SingleListPartitionValues(i int) ISingleListPartitionValuesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleListPartitionValuesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleListPartitionValuesContext)
}

func (s *MultiListPartitionValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiListPartitionValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiListPartitionValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterMultiListPartitionValues(s)
	}
}

func (s *MultiListPartitionValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitMultiListPartitionValues(s)
	}
}

func (s *MultiListPartitionValuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitMultiListPartitionValues(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) MultiListPartitionValues() (localctx IMultiListPartitionValuesContext) {
	localctx = NewMultiListPartitionValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 918, DorisSQLParserParserRULE_multiListPartitionValues)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7701)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7702)
		p.SingleListPartitionValues()
	}
	p.SetState(7707)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(7703)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7704)
			p.SingleListPartitionValues()
		}

		p.SetState(7709)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7710)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleListPartitionValuesContext is an interface to support dynamic dispatch.
type ISingleListPartitionValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllListPartitionValue() []IListPartitionValueContext
	ListPartitionValue(i int) IListPartitionValueContext

	// IsSingleListPartitionValuesContext differentiates from other interfaces.
	IsSingleListPartitionValuesContext()
}

type SingleListPartitionValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleListPartitionValuesContext() *SingleListPartitionValuesContext {
	var p = new(SingleListPartitionValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_singleListPartitionValues
	return p
}

func InitEmptySingleListPartitionValuesContext(p *SingleListPartitionValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_singleListPartitionValues
}

func (*SingleListPartitionValuesContext) IsSingleListPartitionValuesContext() {}

func NewSingleListPartitionValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleListPartitionValuesContext {
	var p = new(SingleListPartitionValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_singleListPartitionValues

	return p
}

func (s *SingleListPartitionValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleListPartitionValuesContext) AllListPartitionValue() []IListPartitionValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IListPartitionValueContext); ok {
			len++
		}
	}

	tst := make([]IListPartitionValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IListPartitionValueContext); ok {
			tst[i] = t.(IListPartitionValueContext)
			i++
		}
	}

	return tst
}

func (s *SingleListPartitionValuesContext) ListPartitionValue(i int) IListPartitionValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListPartitionValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListPartitionValueContext)
}

func (s *SingleListPartitionValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleListPartitionValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleListPartitionValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSingleListPartitionValues(s)
	}
}

func (s *SingleListPartitionValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSingleListPartitionValues(s)
	}
}

func (s *SingleListPartitionValuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSingleListPartitionValues(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SingleListPartitionValues() (localctx ISingleListPartitionValuesContext) {
	localctx = NewSingleListPartitionValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 920, DorisSQLParserParserRULE_singleListPartitionValues)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7712)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7713)
		p.ListPartitionValue()
	}
	p.SetState(7718)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(7714)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7715)
			p.ListPartitionValue()
		}

		p.SetState(7720)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7721)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListPartitionValuesContext is an interface to support dynamic dispatch.
type IListPartitionValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleListPartitionValues() ISingleListPartitionValuesContext
	MultiListPartitionValues() IMultiListPartitionValuesContext

	// IsListPartitionValuesContext differentiates from other interfaces.
	IsListPartitionValuesContext()
}

type ListPartitionValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListPartitionValuesContext() *ListPartitionValuesContext {
	var p = new(ListPartitionValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_listPartitionValues
	return p
}

func InitEmptyListPartitionValuesContext(p *ListPartitionValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_listPartitionValues
}

func (*ListPartitionValuesContext) IsListPartitionValuesContext() {}

func NewListPartitionValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListPartitionValuesContext {
	var p = new(ListPartitionValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_listPartitionValues

	return p
}

func (s *ListPartitionValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *ListPartitionValuesContext) SingleListPartitionValues() ISingleListPartitionValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleListPartitionValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleListPartitionValuesContext)
}

func (s *ListPartitionValuesContext) MultiListPartitionValues() IMultiListPartitionValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiListPartitionValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiListPartitionValuesContext)
}

func (s *ListPartitionValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListPartitionValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListPartitionValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterListPartitionValues(s)
	}
}

func (s *ListPartitionValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitListPartitionValues(s)
	}
}

func (s *ListPartitionValuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitListPartitionValues(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ListPartitionValues() (localctx IListPartitionValuesContext) {
	localctx = NewListPartitionValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 922, DorisSQLParserParserRULE_listPartitionValues)
	p.SetState(7725)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 915, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7723)
			p.SingleListPartitionValues()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7724)
			p.MultiListPartitionValues()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListPartitionValueContext is an interface to support dynamic dispatch.
type IListPartitionValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL() antlr.TerminalNode
	String_() IStringContext

	// IsListPartitionValueContext differentiates from other interfaces.
	IsListPartitionValueContext()
}

type ListPartitionValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListPartitionValueContext() *ListPartitionValueContext {
	var p = new(ListPartitionValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_listPartitionValue
	return p
}

func InitEmptyListPartitionValueContext(p *ListPartitionValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_listPartitionValue
}

func (*ListPartitionValueContext) IsListPartitionValueContext() {}

func NewListPartitionValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListPartitionValueContext {
	var p = new(ListPartitionValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_listPartitionValue

	return p
}

func (s *ListPartitionValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ListPartitionValueContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNULL, 0)
}

func (s *ListPartitionValueContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ListPartitionValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListPartitionValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListPartitionValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterListPartitionValue(s)
	}
}

func (s *ListPartitionValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitListPartitionValue(s)
	}
}

func (s *ListPartitionValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitListPartitionValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ListPartitionValue() (localctx IListPartitionValueContext) {
	localctx = NewListPartitionValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 924, DorisSQLParserParserRULE_listPartitionValue)
	p.SetState(7729)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserNULL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7727)
			p.Match(DorisSQLParserParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserSINGLE_QUOTED_TEXT, DorisSQLParserParserDOUBLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7728)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringListContext is an interface to support dynamic dispatch.
type IStringListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsStringListContext differentiates from other interfaces.
	IsStringListContext()
}

type StringListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringListContext() *StringListContext {
	var p = new(StringListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_stringList
	return p
}

func InitEmptyStringListContext(p *StringListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_stringList
}

func (*StringListContext) IsStringListContext() {}

func NewStringListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringListContext {
	var p = new(StringListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_stringList

	return p
}

func (s *StringListContext) GetParser() antlr.Parser { return s.parser }

func (s *StringListContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *StringListContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *StringListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterStringList(s)
	}
}

func (s *StringListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitStringList(s)
	}
}

func (s *StringListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitStringList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) StringList() (localctx IStringListContext) {
	localctx = NewStringListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 926, DorisSQLParserParserRULE_stringList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7731)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7732)
		p.String_()
	}
	p.SetState(7737)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(7733)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7734)
			p.String_()
		}

		p.SetState(7739)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7740)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralExpressionListContext is an interface to support dynamic dispatch.
type ILiteralExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLiteralExpression() []ILiteralExpressionContext
	LiteralExpression(i int) ILiteralExpressionContext

	// IsLiteralExpressionListContext differentiates from other interfaces.
	IsLiteralExpressionListContext()
}

type LiteralExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralExpressionListContext() *LiteralExpressionListContext {
	var p = new(LiteralExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_literalExpressionList
	return p
}

func InitEmptyLiteralExpressionListContext(p *LiteralExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_literalExpressionList
}

func (*LiteralExpressionListContext) IsLiteralExpressionListContext() {}

func NewLiteralExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralExpressionListContext {
	var p = new(LiteralExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_literalExpressionList

	return p
}

func (s *LiteralExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralExpressionListContext) AllLiteralExpression() []ILiteralExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			len++
		}
	}

	tst := make([]ILiteralExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILiteralExpressionContext); ok {
			tst[i] = t.(ILiteralExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LiteralExpressionListContext) LiteralExpression(i int) ILiteralExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionContext)
}

func (s *LiteralExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterLiteralExpressionList(s)
	}
}

func (s *LiteralExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitLiteralExpressionList(s)
	}
}

func (s *LiteralExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitLiteralExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) LiteralExpressionList() (localctx ILiteralExpressionListContext) {
	localctx = NewLiteralExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 928, DorisSQLParserParserRULE_literalExpressionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7742)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7743)
		p.LiteralExpression()
	}
	p.SetState(7748)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(7744)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7745)
			p.LiteralExpression()
		}

		p.SetState(7750)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7751)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangePartitionDescContext is an interface to support dynamic dispatch.
type IRangePartitionDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleRangePartition() ISingleRangePartitionContext
	MultiRangePartition() IMultiRangePartitionContext

	// IsRangePartitionDescContext differentiates from other interfaces.
	IsRangePartitionDescContext()
}

type RangePartitionDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangePartitionDescContext() *RangePartitionDescContext {
	var p = new(RangePartitionDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_rangePartitionDesc
	return p
}

func InitEmptyRangePartitionDescContext(p *RangePartitionDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_rangePartitionDesc
}

func (*RangePartitionDescContext) IsRangePartitionDescContext() {}

func NewRangePartitionDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangePartitionDescContext {
	var p = new(RangePartitionDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_rangePartitionDesc

	return p
}

func (s *RangePartitionDescContext) GetParser() antlr.Parser { return s.parser }

func (s *RangePartitionDescContext) SingleRangePartition() ISingleRangePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleRangePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleRangePartitionContext)
}

func (s *RangePartitionDescContext) MultiRangePartition() IMultiRangePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiRangePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiRangePartitionContext)
}

func (s *RangePartitionDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangePartitionDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangePartitionDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRangePartitionDesc(s)
	}
}

func (s *RangePartitionDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRangePartitionDesc(s)
	}
}

func (s *RangePartitionDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRangePartitionDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) RangePartitionDesc() (localctx IRangePartitionDescContext) {
	localctx = NewRangePartitionDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 930, DorisSQLParserParserRULE_rangePartitionDesc)
	p.SetState(7755)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserPARTITION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7753)
			p.SingleRangePartition()
		}

	case DorisSQLParserParserSTART:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7754)
			p.MultiRangePartition()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleRangePartitionContext is an interface to support dynamic dispatch.
type ISingleRangePartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	VALUES() antlr.TerminalNode
	PartitionKeyDesc() IPartitionKeyDescContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsSingleRangePartitionContext differentiates from other interfaces.
	IsSingleRangePartitionContext()
}

type SingleRangePartitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleRangePartitionContext() *SingleRangePartitionContext {
	var p = new(SingleRangePartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_singleRangePartition
	return p
}

func InitEmptySingleRangePartitionContext(p *SingleRangePartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_singleRangePartition
}

func (*SingleRangePartitionContext) IsSingleRangePartitionContext() {}

func NewSingleRangePartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleRangePartitionContext {
	var p = new(SingleRangePartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_singleRangePartition

	return p
}

func (s *SingleRangePartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleRangePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPARTITION, 0)
}

func (s *SingleRangePartitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SingleRangePartitionContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVALUES, 0)
}

func (s *SingleRangePartitionContext) PartitionKeyDesc() IPartitionKeyDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionKeyDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionKeyDescContext)
}

func (s *SingleRangePartitionContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIF, 0)
}

func (s *SingleRangePartitionContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNOT, 0)
}

func (s *SingleRangePartitionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXISTS, 0)
}

func (s *SingleRangePartitionContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *SingleRangePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleRangePartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleRangePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSingleRangePartition(s)
	}
}

func (s *SingleRangePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSingleRangePartition(s)
	}
}

func (s *SingleRangePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSingleRangePartition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SingleRangePartition() (localctx ISingleRangePartitionContext) {
	localctx = NewSingleRangePartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 932, DorisSQLParserParserRULE_singleRangePartition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7757)
		p.Match(DorisSQLParserParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7761)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserIF {
		{
			p.SetState(7758)
			p.Match(DorisSQLParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7759)
			p.Match(DorisSQLParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7760)
			p.Match(DorisSQLParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(7763)
		p.Identifier()
	}
	{
		p.SetState(7764)
		p.Match(DorisSQLParserParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7765)
		p.PartitionKeyDesc()
	}
	p.SetState(7767)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserT__1 {
		{
			p.SetState(7766)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiRangePartitionContext is an interface to support dynamic dispatch.
type IMultiRangePartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	END() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	Interval() IIntervalContext
	INTEGER_VALUE() antlr.TerminalNode

	// IsMultiRangePartitionContext differentiates from other interfaces.
	IsMultiRangePartitionContext()
}

type MultiRangePartitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiRangePartitionContext() *MultiRangePartitionContext {
	var p = new(MultiRangePartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_multiRangePartition
	return p
}

func InitEmptyMultiRangePartitionContext(p *MultiRangePartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_multiRangePartition
}

func (*MultiRangePartitionContext) IsMultiRangePartitionContext() {}

func NewMultiRangePartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiRangePartitionContext {
	var p = new(MultiRangePartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_multiRangePartition

	return p
}

func (s *MultiRangePartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiRangePartitionContext) START() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTART, 0)
}

func (s *MultiRangePartitionContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *MultiRangePartitionContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *MultiRangePartitionContext) END() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEND, 0)
}

func (s *MultiRangePartitionContext) EVERY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEVERY, 0)
}

func (s *MultiRangePartitionContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *MultiRangePartitionContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, 0)
}

func (s *MultiRangePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiRangePartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiRangePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterMultiRangePartition(s)
	}
}

func (s *MultiRangePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitMultiRangePartition(s)
	}
}

func (s *MultiRangePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitMultiRangePartition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) MultiRangePartition() (localctx IMultiRangePartitionContext) {
	localctx = NewMultiRangePartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 934, DorisSQLParserParserRULE_multiRangePartition)
	p.SetState(7795)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 922, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7769)
			p.Match(DorisSQLParserParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7770)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7771)
			p.String_()
		}
		{
			p.SetState(7772)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7773)
			p.Match(DorisSQLParserParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7774)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7775)
			p.String_()
		}
		{
			p.SetState(7776)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7777)
			p.Match(DorisSQLParserParserEVERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7778)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7779)
			p.Interval()
		}
		{
			p.SetState(7780)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7782)
			p.Match(DorisSQLParserParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7783)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7784)
			p.String_()
		}
		{
			p.SetState(7785)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7786)
			p.Match(DorisSQLParserParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7787)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7788)
			p.String_()
		}
		{
			p.SetState(7789)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7790)
			p.Match(DorisSQLParserParserEVERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7791)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7792)
			p.Match(DorisSQLParserParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7793)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionRangeDescContext is an interface to support dynamic dispatch.
type IPartitionRangeDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	END() antlr.TerminalNode

	// IsPartitionRangeDescContext differentiates from other interfaces.
	IsPartitionRangeDescContext()
}

type PartitionRangeDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionRangeDescContext() *PartitionRangeDescContext {
	var p = new(PartitionRangeDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_partitionRangeDesc
	return p
}

func InitEmptyPartitionRangeDescContext(p *PartitionRangeDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_partitionRangeDesc
}

func (*PartitionRangeDescContext) IsPartitionRangeDescContext() {}

func NewPartitionRangeDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionRangeDescContext {
	var p = new(PartitionRangeDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_partitionRangeDesc

	return p
}

func (s *PartitionRangeDescContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionRangeDescContext) START() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTART, 0)
}

func (s *PartitionRangeDescContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *PartitionRangeDescContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *PartitionRangeDescContext) END() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEND, 0)
}

func (s *PartitionRangeDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionRangeDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionRangeDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPartitionRangeDesc(s)
	}
}

func (s *PartitionRangeDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPartitionRangeDesc(s)
	}
}

func (s *PartitionRangeDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPartitionRangeDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PartitionRangeDesc() (localctx IPartitionRangeDescContext) {
	localctx = NewPartitionRangeDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 936, DorisSQLParserParserRULE_partitionRangeDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7797)
		p.Match(DorisSQLParserParserSTART)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7798)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7799)
		p.String_()
	}
	{
		p.SetState(7800)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7801)
		p.Match(DorisSQLParserParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7802)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7803)
		p.String_()
	}
	{
		p.SetState(7804)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionKeyDescContext is an interface to support dynamic dispatch.
type IPartitionKeyDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LESS() antlr.TerminalNode
	THAN() antlr.TerminalNode
	MAXVALUE() antlr.TerminalNode
	AllPartitionValueList() []IPartitionValueListContext
	PartitionValueList(i int) IPartitionValueListContext

	// IsPartitionKeyDescContext differentiates from other interfaces.
	IsPartitionKeyDescContext()
}

type PartitionKeyDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionKeyDescContext() *PartitionKeyDescContext {
	var p = new(PartitionKeyDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_partitionKeyDesc
	return p
}

func InitEmptyPartitionKeyDescContext(p *PartitionKeyDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_partitionKeyDesc
}

func (*PartitionKeyDescContext) IsPartitionKeyDescContext() {}

func NewPartitionKeyDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionKeyDescContext {
	var p = new(PartitionKeyDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_partitionKeyDesc

	return p
}

func (s *PartitionKeyDescContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionKeyDescContext) LESS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLESS, 0)
}

func (s *PartitionKeyDescContext) THAN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTHAN, 0)
}

func (s *PartitionKeyDescContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMAXVALUE, 0)
}

func (s *PartitionKeyDescContext) AllPartitionValueList() []IPartitionValueListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueListContext); ok {
			tst[i] = t.(IPartitionValueListContext)
			i++
		}
	}

	return tst
}

func (s *PartitionKeyDescContext) PartitionValueList(i int) IPartitionValueListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueListContext)
}

func (s *PartitionKeyDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionKeyDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionKeyDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPartitionKeyDesc(s)
	}
}

func (s *PartitionKeyDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPartitionKeyDesc(s)
	}
}

func (s *PartitionKeyDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPartitionKeyDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PartitionKeyDesc() (localctx IPartitionKeyDescContext) {
	localctx = NewPartitionKeyDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 938, DorisSQLParserParserRULE_partitionKeyDesc)
	p.SetState(7818)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserLESS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7806)
			p.Match(DorisSQLParserParserLESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7807)
			p.Match(DorisSQLParserParserTHAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7810)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisSQLParserParserMAXVALUE:
			{
				p.SetState(7808)
				p.Match(DorisSQLParserParserMAXVALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisSQLParserParserT__1:
			{
				p.SetState(7809)
				p.PartitionValueList()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case DorisSQLParserParserT__5:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7812)
			p.Match(DorisSQLParserParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7813)
			p.PartitionValueList()
		}
		{
			p.SetState(7814)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7815)
			p.PartitionValueList()
		}
		{
			p.SetState(7816)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionValueListContext is an interface to support dynamic dispatch.
type IPartitionValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPartitionValue() []IPartitionValueContext
	PartitionValue(i int) IPartitionValueContext

	// IsPartitionValueListContext differentiates from other interfaces.
	IsPartitionValueListContext()
}

type PartitionValueListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionValueListContext() *PartitionValueListContext {
	var p = new(PartitionValueListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_partitionValueList
	return p
}

func InitEmptyPartitionValueListContext(p *PartitionValueListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_partitionValueList
}

func (*PartitionValueListContext) IsPartitionValueListContext() {}

func NewPartitionValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValueListContext {
	var p = new(PartitionValueListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_partitionValueList

	return p
}

func (s *PartitionValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValueListContext) AllPartitionValue() []IPartitionValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueContext); ok {
			tst[i] = t.(IPartitionValueContext)
			i++
		}
	}

	return tst
}

func (s *PartitionValueListContext) PartitionValue(i int) IPartitionValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueContext)
}

func (s *PartitionValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionValueListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPartitionValueList(s)
	}
}

func (s *PartitionValueListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPartitionValueList(s)
	}
}

func (s *PartitionValueListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPartitionValueList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PartitionValueList() (localctx IPartitionValueListContext) {
	localctx = NewPartitionValueListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 940, DorisSQLParserParserRULE_partitionValueList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7820)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7821)
		p.PartitionValue()
	}
	p.SetState(7826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(7822)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7823)
			p.PartitionValue()
		}

		p.SetState(7828)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7829)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyPartitionContext is an interface to support dynamic dispatch.
type IKeyPartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionColName returns the partitionColName rule contexts.
	GetPartitionColName() IIdentifierContext

	// GetPartitionColValue returns the partitionColValue rule contexts.
	GetPartitionColValue() ILiteralExpressionContext

	// SetPartitionColName sets the partitionColName rule contexts.
	SetPartitionColName(IIdentifierContext)

	// SetPartitionColValue sets the partitionColValue rule contexts.
	SetPartitionColValue(ILiteralExpressionContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	Identifier() IIdentifierContext
	LiteralExpression() ILiteralExpressionContext

	// IsKeyPartitionContext differentiates from other interfaces.
	IsKeyPartitionContext()
}

type KeyPartitionContext struct {
	antlr.BaseParserRuleContext
	parser            antlr.Parser
	partitionColName  IIdentifierContext
	partitionColValue ILiteralExpressionContext
}

func NewEmptyKeyPartitionContext() *KeyPartitionContext {
	var p = new(KeyPartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_keyPartition
	return p
}

func InitEmptyKeyPartitionContext(p *KeyPartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_keyPartition
}

func (*KeyPartitionContext) IsKeyPartitionContext() {}

func NewKeyPartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyPartitionContext {
	var p = new(KeyPartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_keyPartition

	return p
}

func (s *KeyPartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyPartitionContext) GetPartitionColName() IIdentifierContext { return s.partitionColName }

func (s *KeyPartitionContext) GetPartitionColValue() ILiteralExpressionContext {
	return s.partitionColValue
}

func (s *KeyPartitionContext) SetPartitionColName(v IIdentifierContext) { s.partitionColName = v }

func (s *KeyPartitionContext) SetPartitionColValue(v ILiteralExpressionContext) {
	s.partitionColValue = v
}

func (s *KeyPartitionContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEQ, 0)
}

func (s *KeyPartitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *KeyPartitionContext) LiteralExpression() ILiteralExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionContext)
}

func (s *KeyPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyPartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterKeyPartition(s)
	}
}

func (s *KeyPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitKeyPartition(s)
	}
}

func (s *KeyPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitKeyPartition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) KeyPartition() (localctx IKeyPartitionContext) {
	localctx = NewKeyPartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 942, DorisSQLParserParserRULE_keyPartition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7831)

		var _x = p.Identifier()

		localctx.(*KeyPartitionContext).partitionColName = _x
	}
	{
		p.SetState(7832)
		p.Match(DorisSQLParserParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7833)

		var _x = p.LiteralExpression()

		localctx.(*KeyPartitionContext).partitionColValue = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionValueContext is an interface to support dynamic dispatch.
type IPartitionValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAXVALUE() antlr.TerminalNode
	String_() IStringContext

	// IsPartitionValueContext differentiates from other interfaces.
	IsPartitionValueContext()
}

type PartitionValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionValueContext() *PartitionValueContext {
	var p = new(PartitionValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_partitionValue
	return p
}

func InitEmptyPartitionValueContext(p *PartitionValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_partitionValue
}

func (*PartitionValueContext) IsPartitionValueContext() {}

func NewPartitionValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValueContext {
	var p = new(PartitionValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_partitionValue

	return p
}

func (s *PartitionValueContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValueContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMAXVALUE, 0)
}

func (s *PartitionValueContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *PartitionValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPartitionValue(s)
	}
}

func (s *PartitionValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPartitionValue(s)
	}
}

func (s *PartitionValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPartitionValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PartitionValue() (localctx IPartitionValueContext) {
	localctx = NewPartitionValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 944, DorisSQLParserParserRULE_partitionValue)
	p.SetState(7837)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserMAXVALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7835)
			p.Match(DorisSQLParserParserMAXVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserSINGLE_QUOTED_TEXT, DorisSQLParserParserDOUBLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7836)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDistributionClauseContext is an interface to support dynamic dispatch.
type IDistributionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTRIBUTED() antlr.TerminalNode
	BY() antlr.TerminalNode
	HASH() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	BUCKETS() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsDistributionClauseContext differentiates from other interfaces.
	IsDistributionClauseContext()
}

type DistributionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistributionClauseContext() *DistributionClauseContext {
	var p = new(DistributionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_distributionClause
	return p
}

func InitEmptyDistributionClauseContext(p *DistributionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_distributionClause
}

func (*DistributionClauseContext) IsDistributionClauseContext() {}

func NewDistributionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistributionClauseContext {
	var p = new(DistributionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_distributionClause

	return p
}

func (s *DistributionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DistributionClauseContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDISTRIBUTED, 0)
}

func (s *DistributionClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *DistributionClauseContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserHASH, 0)
}

func (s *DistributionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DistributionClauseContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBUCKETS, 0)
}

func (s *DistributionClauseContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, 0)
}

func (s *DistributionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistributionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DistributionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDistributionClause(s)
	}
}

func (s *DistributionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDistributionClause(s)
	}
}

func (s *DistributionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDistributionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DistributionClause() (localctx IDistributionClauseContext) {
	localctx = NewDistributionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 946, DorisSQLParserParserRULE_distributionClause)
	var _la int

	p.SetState(7851)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 928, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7839)
			p.Match(DorisSQLParserParserDISTRIBUTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7840)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7841)
			p.Match(DorisSQLParserParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7842)
			p.IdentifierList()
		}
		p.SetState(7845)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserBUCKETS {
			{
				p.SetState(7843)
				p.Match(DorisSQLParserParserBUCKETS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7844)
				p.Match(DorisSQLParserParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7847)
			p.Match(DorisSQLParserParserDISTRIBUTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7848)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7849)
			p.Match(DorisSQLParserParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7850)
			p.IdentifierList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDistributionDescContext is an interface to support dynamic dispatch.
type IDistributionDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTRIBUTED() antlr.TerminalNode
	BY() antlr.TerminalNode
	HASH() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	BUCKETS() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	RANDOM() antlr.TerminalNode

	// IsDistributionDescContext differentiates from other interfaces.
	IsDistributionDescContext()
}

type DistributionDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistributionDescContext() *DistributionDescContext {
	var p = new(DistributionDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_distributionDesc
	return p
}

func InitEmptyDistributionDescContext(p *DistributionDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_distributionDesc
}

func (*DistributionDescContext) IsDistributionDescContext() {}

func NewDistributionDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistributionDescContext {
	var p = new(DistributionDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_distributionDesc

	return p
}

func (s *DistributionDescContext) GetParser() antlr.Parser { return s.parser }

func (s *DistributionDescContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDISTRIBUTED, 0)
}

func (s *DistributionDescContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBY, 0)
}

func (s *DistributionDescContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserHASH, 0)
}

func (s *DistributionDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DistributionDescContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBUCKETS, 0)
}

func (s *DistributionDescContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, 0)
}

func (s *DistributionDescContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRANDOM, 0)
}

func (s *DistributionDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistributionDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DistributionDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDistributionDesc(s)
	}
}

func (s *DistributionDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDistributionDesc(s)
	}
}

func (s *DistributionDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDistributionDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DistributionDesc() (localctx IDistributionDescContext) {
	localctx = NewDistributionDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 948, DorisSQLParserParserRULE_distributionDesc)
	var _la int

	p.SetState(7872)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 931, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7853)
			p.Match(DorisSQLParserParserDISTRIBUTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7854)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7855)
			p.Match(DorisSQLParserParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7856)
			p.IdentifierList()
		}
		p.SetState(7859)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserBUCKETS {
			{
				p.SetState(7857)
				p.Match(DorisSQLParserParserBUCKETS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7858)
				p.Match(DorisSQLParserParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7861)
			p.Match(DorisSQLParserParserDISTRIBUTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7862)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7863)
			p.Match(DorisSQLParserParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7864)
			p.IdentifierList()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7865)
			p.Match(DorisSQLParserParserDISTRIBUTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7866)
			p.Match(DorisSQLParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7867)
			p.Match(DorisSQLParserParserRANDOM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7870)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserBUCKETS {
			{
				p.SetState(7868)
				p.Match(DorisSQLParserParserBUCKETS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7869)
				p.Match(DorisSQLParserParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshSchemeDescContext is an interface to support dynamic dispatch.
type IRefreshSchemeDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REFRESH() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	Interval() IIntervalContext
	INCREMENTAL() antlr.TerminalNode
	MANUAL() antlr.TerminalNode
	IMMEDIATE() antlr.TerminalNode
	DEFERRED() antlr.TerminalNode
	START() antlr.TerminalNode
	String_() IStringContext

	// IsRefreshSchemeDescContext differentiates from other interfaces.
	IsRefreshSchemeDescContext()
}

type RefreshSchemeDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefreshSchemeDescContext() *RefreshSchemeDescContext {
	var p = new(RefreshSchemeDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_refreshSchemeDesc
	return p
}

func InitEmptyRefreshSchemeDescContext(p *RefreshSchemeDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_refreshSchemeDesc
}

func (*RefreshSchemeDescContext) IsRefreshSchemeDescContext() {}

func NewRefreshSchemeDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshSchemeDescContext {
	var p = new(RefreshSchemeDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_refreshSchemeDesc

	return p
}

func (s *RefreshSchemeDescContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshSchemeDescContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREFRESH, 0)
}

func (s *RefreshSchemeDescContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserASYNC, 0)
}

func (s *RefreshSchemeDescContext) EVERY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEVERY, 0)
}

func (s *RefreshSchemeDescContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *RefreshSchemeDescContext) INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINCREMENTAL, 0)
}

func (s *RefreshSchemeDescContext) MANUAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMANUAL, 0)
}

func (s *RefreshSchemeDescContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIMMEDIATE, 0)
}

func (s *RefreshSchemeDescContext) DEFERRED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDEFERRED, 0)
}

func (s *RefreshSchemeDescContext) START() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTART, 0)
}

func (s *RefreshSchemeDescContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *RefreshSchemeDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshSchemeDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshSchemeDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterRefreshSchemeDesc(s)
	}
}

func (s *RefreshSchemeDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitRefreshSchemeDesc(s)
	}
}

func (s *RefreshSchemeDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitRefreshSchemeDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) RefreshSchemeDesc() (localctx IRefreshSchemeDescContext) {
	localctx = NewRefreshSchemeDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 950, DorisSQLParserParserRULE_refreshSchemeDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7874)
		p.Match(DorisSQLParserParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7876)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserDEFERRED || _la == DorisSQLParserParserIMMEDIATE {
		{
			p.SetState(7875)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisSQLParserParserDEFERRED || _la == DorisSQLParserParserIMMEDIATE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(7894)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 934, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(7878)
			p.Match(DorisSQLParserParserASYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(7879)
			p.Match(DorisSQLParserParserASYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7885)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserSTART {
			{
				p.SetState(7880)
				p.Match(DorisSQLParserParserSTART)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7881)
				p.Match(DorisSQLParserParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7882)
				p.String_()
			}
			{
				p.SetState(7883)
				p.Match(DorisSQLParserParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7887)
			p.Match(DorisSQLParserParserEVERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7888)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7889)
			p.Interval()
		}
		{
			p.SetState(7890)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(7892)
			p.Match(DorisSQLParserParserINCREMENTAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(7893)
			p.Match(DorisSQLParserParserMANUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatusDescContext is an interface to support dynamic dispatch.
type IStatusDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACTIVE() antlr.TerminalNode
	INACTIVE() antlr.TerminalNode

	// IsStatusDescContext differentiates from other interfaces.
	IsStatusDescContext()
}

type StatusDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatusDescContext() *StatusDescContext {
	var p = new(StatusDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_statusDesc
	return p
}

func InitEmptyStatusDescContext(p *StatusDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_statusDesc
}

func (*StatusDescContext) IsStatusDescContext() {}

func NewStatusDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatusDescContext {
	var p = new(StatusDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_statusDesc

	return p
}

func (s *StatusDescContext) GetParser() antlr.Parser { return s.parser }

func (s *StatusDescContext) ACTIVE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserACTIVE, 0)
}

func (s *StatusDescContext) INACTIVE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINACTIVE, 0)
}

func (s *StatusDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatusDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatusDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterStatusDesc(s)
	}
}

func (s *StatusDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitStatusDesc(s)
	}
}

func (s *StatusDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitStatusDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) StatusDesc() (localctx IStatusDescContext) {
	localctx = NewStatusDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 952, DorisSQLParserParserRULE_statusDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7896)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserACTIVE || _la == DorisSQLParserParserINACTIVE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertiesContext is an interface to support dynamic dispatch.
type IPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROPERTIES() antlr.TerminalNode
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext

	// IsPropertiesContext differentiates from other interfaces.
	IsPropertiesContext()
}

type PropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertiesContext() *PropertiesContext {
	var p = new(PropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_properties
	return p
}

func InitEmptyPropertiesContext(p *PropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_properties
}

func (*PropertiesContext) IsPropertiesContext() {}

func NewPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertiesContext {
	var p = new(PropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_properties

	return p
}

func (s *PropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertiesContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROPERTIES, 0)
}

func (s *PropertiesContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *PropertiesContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *PropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterProperties(s)
	}
}

func (s *PropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitProperties(s)
	}
}

func (s *PropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Properties() (localctx IPropertiesContext) {
	localctx = NewPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 954, DorisSQLParserParserRULE_properties)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7898)
		p.Match(DorisSQLParserParserPROPERTIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7899)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7900)
		p.Property()
	}
	p.SetState(7905)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(7901)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7902)
			p.Property()
		}

		p.SetState(7907)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7908)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtPropertiesContext is an interface to support dynamic dispatch.
type IExtPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BROKER() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsExtPropertiesContext differentiates from other interfaces.
	IsExtPropertiesContext()
}

type ExtPropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtPropertiesContext() *ExtPropertiesContext {
	var p = new(ExtPropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_extProperties
	return p
}

func InitEmptyExtPropertiesContext(p *ExtPropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_extProperties
}

func (*ExtPropertiesContext) IsExtPropertiesContext() {}

func NewExtPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtPropertiesContext {
	var p = new(ExtPropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_extProperties

	return p
}

func (s *ExtPropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtPropertiesContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBROKER, 0)
}

func (s *ExtPropertiesContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *ExtPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtPropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterExtProperties(s)
	}
}

func (s *ExtPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitExtProperties(s)
	}
}

func (s *ExtPropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitExtProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ExtProperties() (localctx IExtPropertiesContext) {
	localctx = NewExtPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 956, DorisSQLParserParserRULE_extProperties)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7910)
		p.Match(DorisSQLParserParserBROKER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7911)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyListContext is an interface to support dynamic dispatch.
type IPropertyListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext

	// IsPropertyListContext differentiates from other interfaces.
	IsPropertyListContext()
}

type PropertyListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyListContext() *PropertyListContext {
	var p = new(PropertyListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_propertyList
	return p
}

func InitEmptyPropertyListContext(p *PropertyListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_propertyList
}

func (*PropertyListContext) IsPropertyListContext() {}

func NewPropertyListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyListContext {
	var p = new(PropertyListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_propertyList

	return p
}

func (s *PropertyListContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyListContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *PropertyListContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *PropertyListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterPropertyList(s)
	}
}

func (s *PropertyListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitPropertyList(s)
	}
}

func (s *PropertyListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitPropertyList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) PropertyList() (localctx IPropertyListContext) {
	localctx = NewPropertyListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 958, DorisSQLParserParserRULE_propertyList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7913)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7914)
		p.Property()
	}
	p.SetState(7919)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(7915)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7916)
			p.Property()
		}

		p.SetState(7921)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7922)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserPropertyListContext is an interface to support dynamic dispatch.
type IUserPropertyListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext

	// IsUserPropertyListContext differentiates from other interfaces.
	IsUserPropertyListContext()
}

type UserPropertyListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserPropertyListContext() *UserPropertyListContext {
	var p = new(UserPropertyListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_userPropertyList
	return p
}

func InitEmptyUserPropertyListContext(p *UserPropertyListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_userPropertyList
}

func (*UserPropertyListContext) IsUserPropertyListContext() {}

func NewUserPropertyListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserPropertyListContext {
	var p = new(UserPropertyListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_userPropertyList

	return p
}

func (s *UserPropertyListContext) GetParser() antlr.Parser { return s.parser }

func (s *UserPropertyListContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *UserPropertyListContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *UserPropertyListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserPropertyListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserPropertyListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterUserPropertyList(s)
	}
}

func (s *UserPropertyListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitUserPropertyList(s)
	}
}

func (s *UserPropertyListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitUserPropertyList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) UserPropertyList() (localctx IUserPropertyListContext) {
	localctx = NewUserPropertyListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 960, DorisSQLParserParserRULE_userPropertyList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7924)
		p.Property()
	}
	p.SetState(7929)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(7925)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7926)
			p.Property()
		}

		p.SetState(7931)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyContext is an interface to support dynamic dispatch.
type IPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IStringContext

	// GetValue returns the value rule contexts.
	GetValue() IStringContext

	// SetKey sets the key rule contexts.
	SetKey(IStringContext)

	// SetValue sets the value rule contexts.
	SetValue(IStringContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsPropertyContext differentiates from other interfaces.
	IsPropertyContext()
}

type PropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IStringContext
	value  IStringContext
}

func NewEmptyPropertyContext() *PropertyContext {
	var p = new(PropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_property
	return p
}

func InitEmptyPropertyContext(p *PropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_property
}

func (*PropertyContext) IsPropertyContext() {}

func NewPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyContext {
	var p = new(PropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_property

	return p
}

func (s *PropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyContext) GetKey() IStringContext { return s.key }

func (s *PropertyContext) GetValue() IStringContext { return s.value }

func (s *PropertyContext) SetKey(v IStringContext) { s.key = v }

func (s *PropertyContext) SetValue(v IStringContext) { s.value = v }

func (s *PropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEQ, 0)
}

func (s *PropertyContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *PropertyContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *PropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterProperty(s)
	}
}

func (s *PropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitProperty(s)
	}
}

func (s *PropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Property() (localctx IPropertyContext) {
	localctx = NewPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 962, DorisSQLParserParserRULE_property)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7932)

		var _x = p.String_()

		localctx.(*PropertyContext).key = _x
	}
	{
		p.SetState(7933)
		p.Match(DorisSQLParserParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7934)

		var _x = p.String_()

		localctx.(*PropertyContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlinePropertiesContext is an interface to support dynamic dispatch.
type IInlinePropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInlineProperty() []IInlinePropertyContext
	InlineProperty(i int) IInlinePropertyContext

	// IsInlinePropertiesContext differentiates from other interfaces.
	IsInlinePropertiesContext()
}

type InlinePropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlinePropertiesContext() *InlinePropertiesContext {
	var p = new(InlinePropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_inlineProperties
	return p
}

func InitEmptyInlinePropertiesContext(p *InlinePropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_inlineProperties
}

func (*InlinePropertiesContext) IsInlinePropertiesContext() {}

func NewInlinePropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlinePropertiesContext {
	var p = new(InlinePropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_inlineProperties

	return p
}

func (s *InlinePropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *InlinePropertiesContext) AllInlineProperty() []IInlinePropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInlinePropertyContext); ok {
			len++
		}
	}

	tst := make([]IInlinePropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInlinePropertyContext); ok {
			tst[i] = t.(IInlinePropertyContext)
			i++
		}
	}

	return tst
}

func (s *InlinePropertiesContext) InlineProperty(i int) IInlinePropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlinePropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlinePropertyContext)
}

func (s *InlinePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlinePropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlinePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterInlineProperties(s)
	}
}

func (s *InlinePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitInlineProperties(s)
	}
}

func (s *InlinePropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitInlineProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) InlineProperties() (localctx IInlinePropertiesContext) {
	localctx = NewInlinePropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 964, DorisSQLParserParserRULE_inlineProperties)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7936)
		p.InlineProperty()
	}
	p.SetState(7940)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262756702208) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-6664167256628462851) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-1331487429127569487) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&-7546427580836201) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-4573491655345179) != 0) || ((int64((_la-324)) & ^0x3f) == 0 && ((int64(1)<<(_la-324))&9114828243924942831) != 0) || ((int64((_la-389)) & ^0x3f) == 0 && ((int64(1)<<(_la-389))&-6956096606152176261) != 0) || ((int64((_la-453)) & ^0x3f) == 0 && ((int64(1)<<(_la-453))&70849595962729) != 0) || ((int64((_la-525)) & ^0x3f) == 0 && ((int64(1)<<(_la-525))&263) != 0) {
		{
			p.SetState(7937)
			p.InlineProperty()
		}

		p.SetState(7942)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlinePropertyContext is an interface to support dynamic dispatch.
type IInlinePropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IIdentifierContext

	// GetValue returns the value rule contexts.
	GetValue() IStringContext

	// SetKey sets the key rule contexts.
	SetKey(IIdentifierContext)

	// SetValue sets the value rule contexts.
	SetValue(IStringContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	Identifier() IIdentifierContext
	String_() IStringContext

	// IsInlinePropertyContext differentiates from other interfaces.
	IsInlinePropertyContext()
}

type InlinePropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IIdentifierContext
	value  IStringContext
}

func NewEmptyInlinePropertyContext() *InlinePropertyContext {
	var p = new(InlinePropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_inlineProperty
	return p
}

func InitEmptyInlinePropertyContext(p *InlinePropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_inlineProperty
}

func (*InlinePropertyContext) IsInlinePropertyContext() {}

func NewInlinePropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlinePropertyContext {
	var p = new(InlinePropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_inlineProperty

	return p
}

func (s *InlinePropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *InlinePropertyContext) GetKey() IIdentifierContext { return s.key }

func (s *InlinePropertyContext) GetValue() IStringContext { return s.value }

func (s *InlinePropertyContext) SetKey(v IIdentifierContext) { s.key = v }

func (s *InlinePropertyContext) SetValue(v IStringContext) { s.value = v }

func (s *InlinePropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEQ, 0)
}

func (s *InlinePropertyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InlinePropertyContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *InlinePropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlinePropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlinePropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterInlineProperty(s)
	}
}

func (s *InlinePropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitInlineProperty(s)
	}
}

func (s *InlinePropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitInlineProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) InlineProperty() (localctx IInlinePropertyContext) {
	localctx = NewInlinePropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 966, DorisSQLParserParserRULE_inlineProperty)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7943)

		var _x = p.Identifier()

		localctx.(*InlinePropertyContext).key = _x
	}
	{
		p.SetState(7944)
		p.Match(DorisSQLParserParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7945)

		var _x = p.String_()

		localctx.(*InlinePropertyContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarTypeContext is an interface to support dynamic dispatch.
type IVarTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GLOBAL() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	VERBOSE() antlr.TerminalNode

	// IsVarTypeContext differentiates from other interfaces.
	IsVarTypeContext()
}

type VarTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarTypeContext() *VarTypeContext {
	var p = new(VarTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_varType
	return p
}

func InitEmptyVarTypeContext(p *VarTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_varType
}

func (*VarTypeContext) IsVarTypeContext() {}

func NewVarTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarTypeContext {
	var p = new(VarTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_varType

	return p
}

func (s *VarTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *VarTypeContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGLOBAL, 0)
}

func (s *VarTypeContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOCAL, 0)
}

func (s *VarTypeContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSESSION, 0)
}

func (s *VarTypeContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVERBOSE, 0)
}

func (s *VarTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterVarType(s)
	}
}

func (s *VarTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitVarType(s)
	}
}

func (s *VarTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitVarType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) VarType() (localctx IVarTypeContext) {
	localctx = NewVarTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 968, DorisSQLParserParserRULE_varType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7947)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserGLOBAL || _la == DorisSQLParserParserLOCAL || _la == DorisSQLParserParserSESSION || _la == DorisSQLParserParserVERBOSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommentContext is an interface to support dynamic dispatch.
type ICommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMENT() antlr.TerminalNode
	String_() IStringContext

	// IsCommentContext differentiates from other interfaces.
	IsCommentContext()
}

type CommentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentContext() *CommentContext {
	var p = new(CommentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_comment
	return p
}

func InitEmptyCommentContext(p *CommentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_comment
}

func (*CommentContext) IsCommentContext() {}

func NewCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentContext {
	var p = new(CommentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_comment

	return p
}

func (s *CommentContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOMMENT, 0)
}

func (s *CommentContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterComment(s)
	}
}

func (s *CommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitComment(s)
	}
}

func (s *CommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitComment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Comment() (localctx ICommentContext) {
	localctx = NewCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 970, DorisSQLParserParserRULE_comment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7949)
		p.Match(DorisSQLParserParserCOMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7950)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOutfileContext is an interface to support dynamic dispatch.
type IOutfileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFile returns the file rule contexts.
	GetFile() IStringContext

	// SetFile sets the file rule contexts.
	SetFile(IStringContext)

	// Getter signatures
	INTO() antlr.TerminalNode
	OUTFILE() antlr.TerminalNode
	String_() IStringContext
	FileFormat() IFileFormatContext
	Properties() IPropertiesContext

	// IsOutfileContext differentiates from other interfaces.
	IsOutfileContext()
}

type OutfileContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	file   IStringContext
}

func NewEmptyOutfileContext() *OutfileContext {
	var p = new(OutfileContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_outfile
	return p
}

func InitEmptyOutfileContext(p *OutfileContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_outfile
}

func (*OutfileContext) IsOutfileContext() {}

func NewOutfileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OutfileContext {
	var p = new(OutfileContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_outfile

	return p
}

func (s *OutfileContext) GetParser() antlr.Parser { return s.parser }

func (s *OutfileContext) GetFile() IStringContext { return s.file }

func (s *OutfileContext) SetFile(v IStringContext) { s.file = v }

func (s *OutfileContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTO, 0)
}

func (s *OutfileContext) OUTFILE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOUTFILE, 0)
}

func (s *OutfileContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *OutfileContext) FileFormat() IFileFormatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileFormatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileFormatContext)
}

func (s *OutfileContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *OutfileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OutfileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OutfileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterOutfile(s)
	}
}

func (s *OutfileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitOutfile(s)
	}
}

func (s *OutfileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitOutfile(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Outfile() (localctx IOutfileContext) {
	localctx = NewOutfileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 972, DorisSQLParserParserRULE_outfile)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7952)
		p.Match(DorisSQLParserParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7953)
		p.Match(DorisSQLParserParserOUTFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7954)

		var _x = p.String_()

		localctx.(*OutfileContext).file = _x
	}
	p.SetState(7956)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFORMAT {
		{
			p.SetState(7955)
			p.FileFormat()
		}

	}
	p.SetState(7959)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserPROPERTIES {
		{
			p.SetState(7958)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFileFormatContext is an interface to support dynamic dispatch.
type IFileFormatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FORMAT() antlr.TerminalNode
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext
	String_() IStringContext

	// IsFileFormatContext differentiates from other interfaces.
	IsFileFormatContext()
}

type FileFormatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileFormatContext() *FileFormatContext {
	var p = new(FileFormatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_fileFormat
	return p
}

func InitEmptyFileFormatContext(p *FileFormatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_fileFormat
}

func (*FileFormatContext) IsFileFormatContext() {}

func NewFileFormatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileFormatContext {
	var p = new(FileFormatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_fileFormat

	return p
}

func (s *FileFormatContext) GetParser() antlr.Parser { return s.parser }

func (s *FileFormatContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFORMAT, 0)
}

func (s *FileFormatContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *FileFormatContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FileFormatContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *FileFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileFormatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterFileFormat(s)
	}
}

func (s *FileFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitFileFormat(s)
	}
}

func (s *FileFormatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitFileFormat(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) FileFormat() (localctx IFileFormatContext) {
	localctx = NewFileFormatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 974, DorisSQLParserParserRULE_fileFormat)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7961)
		p.Match(DorisSQLParserParserFORMAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7962)
		p.Match(DorisSQLParserParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7965)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserACCESS, DorisSQLParserParserACTIVE, DorisSQLParserParserADMIN, DorisSQLParserParserADVISOR, DorisSQLParserParserAFTER, DorisSQLParserParserAGGREGATE, DorisSQLParserParserANTI, DorisSQLParserParserAPPLY, DorisSQLParserParserARRAY_AGG, DorisSQLParserParserARRAY_AGG_DISTINCT, DorisSQLParserParserASYNC, DorisSQLParserParserAUTHORS, DorisSQLParserParserAUTHENTICATION, DorisSQLParserParserAUTOMATED, DorisSQLParserParserAUTO_INCREMENT, DorisSQLParserParserAVG, DorisSQLParserParserBACKEND, DorisSQLParserParserBACKENDS, DorisSQLParserParserBACKUP, DorisSQLParserParserBASE, DorisSQLParserParserBASELINE, DorisSQLParserParserBEGIN, DorisSQLParserParserBINARY, DorisSQLParserParserBITMAP_UNION, DorisSQLParserParserBLACKHOLE, DorisSQLParserParserBLACKLIST, DorisSQLParserParserBODY, DorisSQLParserParserBOOLEAN, DorisSQLParserParserBRANCH, DorisSQLParserParserBROKER, DorisSQLParserParserBUCKETS, DorisSQLParserParserBUILTIN, DorisSQLParserParserCACHE, DorisSQLParserParserCANCEL, DorisSQLParserParserCAST, DorisSQLParserParserCATALOG, DorisSQLParserParserCATALOGS, DorisSQLParserParserCEIL, DorisSQLParserParserCHAIN, DorisSQLParserParserCHARSET, DorisSQLParserParserCLEAN, DorisSQLParserParserCLEAR, DorisSQLParserParserCLUSTER, DorisSQLParserParserCLUSTERS, DorisSQLParserParserCNGROUP, DorisSQLParserParserCNGROUPS, DorisSQLParserParserCOLLATION, DorisSQLParserParserCOLUMNS, DorisSQLParserParserCOMMENT, DorisSQLParserParserCOMMIT, DorisSQLParserParserCOMMITTED, DorisSQLParserParserCOMPACT, DorisSQLParserParserCOMPUTE, DorisSQLParserParserCONFIG, DorisSQLParserParserCONNECTION, DorisSQLParserParserCONSISTENT, DorisSQLParserParserCOSTS, DorisSQLParserParserCOUNT, DorisSQLParserParserCUME_DIST, DorisSQLParserParserCUMULATIVE, DorisSQLParserParserCURRENT, DorisSQLParserParserDATA, DorisSQLParserParserDATACACHE, DorisSQLParserParserDATE, DorisSQLParserParserDATETIME, DorisSQLParserParserDAY, DorisSQLParserParserDAYS, DorisSQLParserParserDEALLOCATE, DorisSQLParserParserDECOMMISSION, DorisSQLParserParserDIALECT, DorisSQLParserParserDICTIONARY, DorisSQLParserParserDICTIONARY_GET, DorisSQLParserParserDISABLE, DorisSQLParserParserDISTRIBUTED, DorisSQLParserParserDISTRIBUTION, DorisSQLParserParserDUPLICATE, DorisSQLParserParserDYNAMIC, DorisSQLParserParserENABLE, DorisSQLParserParserENCLOSE, DorisSQLParserParserEND, DorisSQLParserParserENGINE, DorisSQLParserParserENGINES, DorisSQLParserParserERRORS, DorisSQLParserParserESCAPE, DorisSQLParserParserEVENTS, DorisSQLParserParserEXCEPT, DorisSQLParserParserEXCLUDE, DorisSQLParserParserEXECUTE, DorisSQLParserParserEXPORT, DorisSQLParserParserEXTERNAL, DorisSQLParserParserEXTRACT, DorisSQLParserParserEVERY, DorisSQLParserParserFAILPOINT, DorisSQLParserParserFAILPOINTS, DorisSQLParserParserFIELDS, DorisSQLParserParserFILE, DorisSQLParserParserFILTER, DorisSQLParserParserFIRST, DorisSQLParserParserFLOOR, DorisSQLParserParserFN, DorisSQLParserParserFOLLOWING, DorisSQLParserParserFOLLOWER, DorisSQLParserParserFORMAT, DorisSQLParserParserFREE, DorisSQLParserParserFRONTEND, DorisSQLParserParserFRONTENDS, DorisSQLParserParserFUNCTIONS, DorisSQLParserParserGLOBAL, DorisSQLParserParserGRANTS, DorisSQLParserParserGROUP_CONCAT, DorisSQLParserParserHASH, DorisSQLParserParserHELP, DorisSQLParserParserHISTOGRAM, DorisSQLParserParserHLL_UNION, DorisSQLParserParserHOST, DorisSQLParserParserHOUR, DorisSQLParserParserHOURS, DorisSQLParserParserHUB, DorisSQLParserParserIDENTIFIED, DorisSQLParserParserIMPERSONATE, DorisSQLParserParserIMAGE, DorisSQLParserParserINACTIVE, DorisSQLParserParserINCREMENTAL, DorisSQLParserParserINDEXES, DorisSQLParserParserINSTALL, DorisSQLParserParserINTEGRATION, DorisSQLParserParserINTEGRATIONS, DorisSQLParserParserINTERMEDIATE, DorisSQLParserParserINTERVAL, DorisSQLParserParserOVERWRITE, DorisSQLParserParserISOLATION, DorisSQLParserParserJOB, DorisSQLParserParserLABEL, DorisSQLParserParserLAST, DorisSQLParserParserLESS, DorisSQLParserParserLEVEL, DorisSQLParserParserLIST, DorisSQLParserParserLOCAL, DorisSQLParserParserLOCATION, DorisSQLParserParserLOCATIONS, DorisSQLParserParserLOGS, DorisSQLParserParserLOGICAL, DorisSQLParserParserMANUAL, DorisSQLParserParserMAP, DorisSQLParserParserMAPPING, DorisSQLParserParserMAPPINGS, DorisSQLParserParserMASKING, DorisSQLParserParserMATCH, DorisSQLParserParserMATERIALIZED, DorisSQLParserParserMAX, DorisSQLParserParserMERGE, DorisSQLParserParserMIN, DorisSQLParserParserMINUTE, DorisSQLParserParserMINUTES, DorisSQLParserParserMINUS, DorisSQLParserParserMETA, DorisSQLParserParserMODE, DorisSQLParserParserMODIFY, DorisSQLParserParserMONTH, DorisSQLParserParserMULTIPLE, DorisSQLParserParserNAME, DorisSQLParserParserNAMES, DorisSQLParserParserNEGATIVE, DorisSQLParserParserNGRAMBF, DorisSQLParserParserNO, DorisSQLParserParserNODE, DorisSQLParserParserNODES, DorisSQLParserParserNONE, DorisSQLParserParserNULLS, DorisSQLParserParserNUMBER, DorisSQLParserParserNUMERIC, DorisSQLParserParserOBSERVER, DorisSQLParserParserOF, DorisSQLParserParserOFF, DorisSQLParserParserOFFSET, DorisSQLParserParserONLY, DorisSQLParserParserOPEN, DorisSQLParserParserOPERATE, DorisSQLParserParserOPTIMIZER, DorisSQLParserParserOPTION, DorisSQLParserParserPARTITIONS, DorisSQLParserParserPASSWORD, DorisSQLParserParserPATH, DorisSQLParserParserPAUSE, DorisSQLParserParserPENDING, DorisSQLParserParserPERCENT_RANK, DorisSQLParserParserPERCENTILE_UNION, DorisSQLParserParserPLAN, DorisSQLParserParserPLUGIN, DorisSQLParserParserPLUGINS, DorisSQLParserParserPIPE, DorisSQLParserParserPIPES, DorisSQLParserParserPIVOT, DorisSQLParserParserPOLICY, DorisSQLParserParserPOLICIES, DorisSQLParserParserPRECEDING, DorisSQLParserParserPREDICATE, DorisSQLParserParserPRIORITY, DorisSQLParserParserPRIVILEGES, DorisSQLParserParserPROBABILITY, DorisSQLParserParserPROC, DorisSQLParserParserPROCESSLIST, DorisSQLParserParserPROFILE, DorisSQLParserParserPROFILELIST, DorisSQLParserParserPROPERTIES, DorisSQLParserParserPROPERTY, DorisSQLParserParserPROVIDER, DorisSQLParserParserPROVIDERS, DorisSQLParserParserQUALIFY, DorisSQLParserParserQUARTER, DorisSQLParserParserQUERY, DorisSQLParserParserQUERIES, DorisSQLParserParserQUEUE, DorisSQLParserParserQUOTA, DorisSQLParserParserRANDOM, DorisSQLParserParserRANK, DorisSQLParserParserREASON, DorisSQLParserParserRECOVER, DorisSQLParserParserREFRESH, DorisSQLParserParserREWRITE, DorisSQLParserParserREMOVE, DorisSQLParserParserREPAIR, DorisSQLParserParserREPEATABLE, DorisSQLParserParserREPLACE_IF_NOT_NULL, DorisSQLParserParserREPLICA, DorisSQLParserParserREPOSITORY, DorisSQLParserParserREPOSITORIES, DorisSQLParserParserRESOURCE, DorisSQLParserParserRESOURCES, DorisSQLParserParserRESTORE, DorisSQLParserParserRESUME, DorisSQLParserParserRETAIN, DorisSQLParserParserRETENTION, DorisSQLParserParserRETURNS, DorisSQLParserParserRETRY, DorisSQLParserParserREVERT, DorisSQLParserParserROLE, DorisSQLParserParserROLES, DorisSQLParserParserROLLBACK, DorisSQLParserParserROLLUP, DorisSQLParserParserROUTINE, DorisSQLParserParserROW, DorisSQLParserParserRULE, DorisSQLParserParserRULES, DorisSQLParserParserRUNNING, DorisSQLParserParserSAMPLE, DorisSQLParserParserSCHEDULE, DorisSQLParserParserSCHEDULER, DorisSQLParserParserSECOND, DorisSQLParserParserSECURITY, DorisSQLParserParserSEMI, DorisSQLParserParserSEPARATOR, DorisSQLParserParserSERIALIZABLE, DorisSQLParserParserSESSION, DorisSQLParserParserSETS, DorisSQLParserParserSIGNED, DorisSQLParserParserSKIP_HEADER, DorisSQLParserParserSNAPSHOT, DorisSQLParserParserSNAPSHOTS, DorisSQLParserParserSQLBLACKLIST, DorisSQLParserParserSTART, DorisSQLParserParserSTATS, DorisSQLParserParserSTATUS, DorisSQLParserParserSTOP, DorisSQLParserParserSTORAGE, DorisSQLParserParserSTREAM, DorisSQLParserParserSTRING, DorisSQLParserParserSUBMIT, DorisSQLParserParserSUM, DorisSQLParserParserSUSPEND, DorisSQLParserParserSYNC, DorisSQLParserParserSYSTEM_TIME, DorisSQLParserParserSWAP, DorisSQLParserParserSTRUCT, DorisSQLParserParserTABLES, DorisSQLParserParserTABLET, DorisSQLParserParserTABLETS, DorisSQLParserParserTAG, DorisSQLParserParserTASK, DorisSQLParserParserTEMPORARY, DorisSQLParserParserTHAN, DorisSQLParserParserTIME, DorisSQLParserParserTIMES, DorisSQLParserParserTIMESTAMP, DorisSQLParserParserTIMESTAMPADD, DorisSQLParserParserTIMESTAMPDIFF, DorisSQLParserParserTRANSACTION, DorisSQLParserParserTRANSLATE, DorisSQLParserParserTRACE, DorisSQLParserParserTRIGGERS, DorisSQLParserParserTRIM_SPACE, DorisSQLParserParserTRUNCATE, DorisSQLParserParserTYPE, DorisSQLParserParserTYPES, DorisSQLParserParserUNBOUNDED, DorisSQLParserParserUNCOMMITTED, DorisSQLParserParserUNINSTALL, DorisSQLParserParserUNSET, DorisSQLParserParserUSAGE, DorisSQLParserParserUSER, DorisSQLParserParserUSERS, DorisSQLParserParserVALUE, DorisSQLParserParserVARBINARY, DorisSQLParserParserVARIABLES, DorisSQLParserParserVECTOR, DorisSQLParserParserVERBOSE, DorisSQLParserParserVERSION, DorisSQLParserParserVIEW, DorisSQLParserParserVIEWS, DorisSQLParserParserVOLUME, DorisSQLParserParserVOLUMES, DorisSQLParserParserWAREHOUSE, DorisSQLParserParserWAREHOUSES, DorisSQLParserParserWARNINGS, DorisSQLParserParserWEEK, DorisSQLParserParserWHITELIST, DorisSQLParserParserWORK, DorisSQLParserParserWRITE, DorisSQLParserParserYEAR, DorisSQLParserParserLOCK, DorisSQLParserParserUNLOCK, DorisSQLParserParserLOW_PRIORITY, DorisSQLParserParserDISK, DorisSQLParserParserBEFORE, DorisSQLParserParserFIELD, DorisSQLParserParserPERSISTENT, DorisSQLParserParserARRAY_ELEMENT, DorisSQLParserParserLETTER_IDENTIFIER, DorisSQLParserParserDIGIT_IDENTIFIER, DorisSQLParserParserBACKQUOTED_IDENTIFIER, DorisSQLParserParserDOTDOTDOT:
		{
			p.SetState(7963)
			p.Identifier()
		}

	case DorisSQLParserParserSINGLE_QUOTED_TEXT, DorisSQLParserParserDOUBLE_QUOTED_TEXT:
		{
			p.SetState(7964)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringContext is an interface to support dynamic dispatch.
type IStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SINGLE_QUOTED_TEXT() antlr.TerminalNode
	DOUBLE_QUOTED_TEXT() antlr.TerminalNode

	// IsStringContext differentiates from other interfaces.
	IsStringContext()
}

type StringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringContext() *StringContext {
	var p = new(StringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_string
	return p
}

func InitEmptyStringContext(p *StringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_string
}

func (*StringContext) IsStringContext() {}

func NewStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringContext {
	var p = new(StringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_string

	return p
}

func (s *StringContext) GetParser() antlr.Parser { return s.parser }

func (s *StringContext) SINGLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSINGLE_QUOTED_TEXT, 0)
}

func (s *StringContext) DOUBLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDOUBLE_QUOTED_TEXT, 0)
}

func (s *StringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterString(s)
	}
}

func (s *StringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitString(s)
	}
}

func (s *StringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) String_() (localctx IStringContext) {
	localctx = NewStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 976, DorisSQLParserParserRULE_string)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7967)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserSINGLE_QUOTED_TEXT || _la == DorisSQLParserParserDOUBLE_QUOTED_TEXT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBinaryContext is an interface to support dynamic dispatch.
type IBinaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BINARY_SINGLE_QUOTED_TEXT() antlr.TerminalNode
	BINARY_DOUBLE_QUOTED_TEXT() antlr.TerminalNode

	// IsBinaryContext differentiates from other interfaces.
	IsBinaryContext()
}

type BinaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinaryContext() *BinaryContext {
	var p = new(BinaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_binary
	return p
}

func InitEmptyBinaryContext(p *BinaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_binary
}

func (*BinaryContext) IsBinaryContext() {}

func NewBinaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinaryContext {
	var p = new(BinaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_binary

	return p
}

func (s *BinaryContext) GetParser() antlr.Parser { return s.parser }

func (s *BinaryContext) BINARY_SINGLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBINARY_SINGLE_QUOTED_TEXT, 0)
}

func (s *BinaryContext) BINARY_DOUBLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBINARY_DOUBLE_QUOTED_TEXT, 0)
}

func (s *BinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterBinary(s)
	}
}

func (s *BinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitBinary(s)
	}
}

func (s *BinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Binary() (localctx IBinaryContext) {
	localctx = NewBinaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 978, DorisSQLParserParserRULE_binary)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7969)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserBINARY_SINGLE_QUOTED_TEXT || _la == DorisSQLParserParserBINARY_DOUBLE_QUOTED_TEXT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQ() antlr.TerminalNode
	NEQ() antlr.TerminalNode
	LT() antlr.TerminalNode
	LTE() antlr.TerminalNode
	GT() antlr.TerminalNode
	GTE() antlr.TerminalNode
	EQ_FOR_NULL() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_comparisonOperator
	return p
}

func InitEmptyComparisonOperatorContext(p *ComparisonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_comparisonOperator
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEQ, 0)
}

func (s *ComparisonOperatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNEQ, 0)
}

func (s *ComparisonOperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLT, 0)
}

func (s *ComparisonOperatorContext) LTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLTE, 0)
}

func (s *ComparisonOperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGT, 0)
}

func (s *ComparisonOperatorContext) GTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGTE, 0)
}

func (s *ComparisonOperatorContext) EQ_FOR_NULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEQ_FOR_NULL, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitComparisonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 980, DorisSQLParserParserRULE_comparisonOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7971)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-492)) & ^0x3f) == 0 && ((int64(1)<<(_la-492))&127) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanValueContext is an interface to support dynamic dispatch.
type IBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBooleanValueContext differentiates from other interfaces.
	IsBooleanValueContext()
}

type BooleanValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueContext() *BooleanValueContext {
	var p = new(BooleanValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_booleanValue
	return p
}

func InitEmptyBooleanValueContext(p *BooleanValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_booleanValue
}

func (*BooleanValueContext) IsBooleanValueContext() {}

func NewBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueContext {
	var p = new(BooleanValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_booleanValue

	return p
}

func (s *BooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTRUE, 0)
}

func (s *BooleanValueContext) FALSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFALSE, 0)
}

func (s *BooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterBooleanValue(s)
	}
}

func (s *BooleanValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitBooleanValue(s)
	}
}

func (s *BooleanValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitBooleanValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) BooleanValue() (localctx IBooleanValueContext) {
	localctx = NewBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 982, DorisSQLParserParserRULE_booleanValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7973)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserFALSE || _la == DorisSQLParserParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalContext is an interface to support dynamic dispatch.
type IIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value rule contexts.
	GetValue() IExpressionContext

	// GetFrom returns the from rule contexts.
	GetFrom() IUnitIdentifierContext

	// SetValue sets the value rule contexts.
	SetValue(IExpressionContext)

	// SetFrom sets the from rule contexts.
	SetFrom(IUnitIdentifierContext)

	// Getter signatures
	INTERVAL() antlr.TerminalNode
	Expression() IExpressionContext
	UnitIdentifier() IUnitIdentifierContext

	// IsIntervalContext differentiates from other interfaces.
	IsIntervalContext()
}

type IntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  IExpressionContext
	from   IUnitIdentifierContext
}

func NewEmptyIntervalContext() *IntervalContext {
	var p = new(IntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_interval
	return p
}

func InitEmptyIntervalContext(p *IntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_interval
}

func (*IntervalContext) IsIntervalContext() {}

func NewIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalContext {
	var p = new(IntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_interval

	return p
}

func (s *IntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalContext) GetValue() IExpressionContext { return s.value }

func (s *IntervalContext) GetFrom() IUnitIdentifierContext { return s.from }

func (s *IntervalContext) SetValue(v IExpressionContext) { s.value = v }

func (s *IntervalContext) SetFrom(v IUnitIdentifierContext) { s.from = v }

func (s *IntervalContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTERVAL, 0)
}

func (s *IntervalContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalContext) UnitIdentifier() IUnitIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitIdentifierContext)
}

func (s *IntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterInterval(s)
	}
}

func (s *IntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitInterval(s)
	}
}

func (s *IntervalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitInterval(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Interval() (localctx IIntervalContext) {
	localctx = NewIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 984, DorisSQLParserParserRULE_interval)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7975)
		p.Match(DorisSQLParserParserINTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7976)

		var _x = p.expression(0)

		localctx.(*IntervalContext).value = _x
	}
	{
		p.SetState(7977)

		var _x = p.UnitIdentifier()

		localctx.(*IntervalContext).from = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITaskIntervalContext is an interface to support dynamic dispatch.
type ITaskIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value rule contexts.
	GetValue() IExpressionContext

	// GetFrom returns the from rule contexts.
	GetFrom() ITaskUnitIdentifierContext

	// SetValue sets the value rule contexts.
	SetValue(IExpressionContext)

	// SetFrom sets the from rule contexts.
	SetFrom(ITaskUnitIdentifierContext)

	// Getter signatures
	INTERVAL() antlr.TerminalNode
	Expression() IExpressionContext
	TaskUnitIdentifier() ITaskUnitIdentifierContext

	// IsTaskIntervalContext differentiates from other interfaces.
	IsTaskIntervalContext()
}

type TaskIntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  IExpressionContext
	from   ITaskUnitIdentifierContext
}

func NewEmptyTaskIntervalContext() *TaskIntervalContext {
	var p = new(TaskIntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_taskInterval
	return p
}

func InitEmptyTaskIntervalContext(p *TaskIntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_taskInterval
}

func (*TaskIntervalContext) IsTaskIntervalContext() {}

func NewTaskIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TaskIntervalContext {
	var p = new(TaskIntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_taskInterval

	return p
}

func (s *TaskIntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *TaskIntervalContext) GetValue() IExpressionContext { return s.value }

func (s *TaskIntervalContext) GetFrom() ITaskUnitIdentifierContext { return s.from }

func (s *TaskIntervalContext) SetValue(v IExpressionContext) { s.value = v }

func (s *TaskIntervalContext) SetFrom(v ITaskUnitIdentifierContext) { s.from = v }

func (s *TaskIntervalContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTERVAL, 0)
}

func (s *TaskIntervalContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TaskIntervalContext) TaskUnitIdentifier() ITaskUnitIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITaskUnitIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITaskUnitIdentifierContext)
}

func (s *TaskIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TaskIntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TaskIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTaskInterval(s)
	}
}

func (s *TaskIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTaskInterval(s)
	}
}

func (s *TaskIntervalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTaskInterval(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) TaskInterval() (localctx ITaskIntervalContext) {
	localctx = NewTaskIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 986, DorisSQLParserParserRULE_taskInterval)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7979)
		p.Match(DorisSQLParserParserINTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7980)

		var _x = p.expression(0)

		localctx.(*TaskIntervalContext).value = _x
	}
	{
		p.SetState(7981)

		var _x = p.TaskUnitIdentifier()

		localctx.(*TaskIntervalContext).from = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITaskUnitIdentifierContext is an interface to support dynamic dispatch.
type ITaskUnitIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	SECOND() antlr.TerminalNode

	// IsTaskUnitIdentifierContext differentiates from other interfaces.
	IsTaskUnitIdentifierContext()
}

type TaskUnitIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTaskUnitIdentifierContext() *TaskUnitIdentifierContext {
	var p = new(TaskUnitIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_taskUnitIdentifier
	return p
}

func InitEmptyTaskUnitIdentifierContext(p *TaskUnitIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_taskUnitIdentifier
}

func (*TaskUnitIdentifierContext) IsTaskUnitIdentifierContext() {}

func NewTaskUnitIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TaskUnitIdentifierContext {
	var p = new(TaskUnitIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_taskUnitIdentifier

	return p
}

func (s *TaskUnitIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TaskUnitIdentifierContext) DAY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDAY, 0)
}

func (s *TaskUnitIdentifierContext) HOUR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserHOUR, 0)
}

func (s *TaskUnitIdentifierContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMINUTE, 0)
}

func (s *TaskUnitIdentifierContext) SECOND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSECOND, 0)
}

func (s *TaskUnitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TaskUnitIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TaskUnitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTaskUnitIdentifier(s)
	}
}

func (s *TaskUnitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTaskUnitIdentifier(s)
	}
}

func (s *TaskUnitIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTaskUnitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) TaskUnitIdentifier() (localctx ITaskUnitIdentifierContext) {
	localctx = NewTaskUnitIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 988, DorisSQLParserParserRULE_taskUnitIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7983)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserDAY || _la == DorisSQLParserParserHOUR || _la == DorisSQLParserParserMINUTE || _la == DorisSQLParserParserSECOND) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitIdentifierContext is an interface to support dynamic dispatch.
type IUnitIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YEAR() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	MILLISECOND() antlr.TerminalNode
	MICROSECOND() antlr.TerminalNode

	// IsUnitIdentifierContext differentiates from other interfaces.
	IsUnitIdentifierContext()
}

type UnitIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitIdentifierContext() *UnitIdentifierContext {
	var p = new(UnitIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_unitIdentifier
	return p
}

func InitEmptyUnitIdentifierContext(p *UnitIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_unitIdentifier
}

func (*UnitIdentifierContext) IsUnitIdentifierContext() {}

func NewUnitIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitIdentifierContext {
	var p = new(UnitIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_unitIdentifier

	return p
}

func (s *UnitIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitIdentifierContext) YEAR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserYEAR, 0)
}

func (s *UnitIdentifierContext) MONTH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMONTH, 0)
}

func (s *UnitIdentifierContext) WEEK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWEEK, 0)
}

func (s *UnitIdentifierContext) DAY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDAY, 0)
}

func (s *UnitIdentifierContext) HOUR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserHOUR, 0)
}

func (s *UnitIdentifierContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMINUTE, 0)
}

func (s *UnitIdentifierContext) SECOND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSECOND, 0)
}

func (s *UnitIdentifierContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserQUARTER, 0)
}

func (s *UnitIdentifierContext) MILLISECOND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMILLISECOND, 0)
}

func (s *UnitIdentifierContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMICROSECOND, 0)
}

func (s *UnitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterUnitIdentifier(s)
	}
}

func (s *UnitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitUnitIdentifier(s)
	}
}

func (s *UnitIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitUnitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) UnitIdentifier() (localctx IUnitIdentifierContext) {
	localctx = NewUnitIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 990, DorisSQLParserParserRULE_unitIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7985)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserDAY || _la == DorisSQLParserParserHOUR || ((int64((_la-261)) & ^0x3f) == 0 && ((int64(1)<<(_la-261))&1035) != 0) || _la == DorisSQLParserParserQUARTER || _la == DorisSQLParserParserSECOND || _la == DorisSQLParserParserWEEK || _la == DorisSQLParserParserYEAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitBoundaryContext is an interface to support dynamic dispatch.
type IUnitBoundaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLOOR() antlr.TerminalNode
	CEIL() antlr.TerminalNode

	// IsUnitBoundaryContext differentiates from other interfaces.
	IsUnitBoundaryContext()
}

type UnitBoundaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitBoundaryContext() *UnitBoundaryContext {
	var p = new(UnitBoundaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_unitBoundary
	return p
}

func InitEmptyUnitBoundaryContext(p *UnitBoundaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_unitBoundary
}

func (*UnitBoundaryContext) IsUnitBoundaryContext() {}

func NewUnitBoundaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitBoundaryContext {
	var p = new(UnitBoundaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_unitBoundary

	return p
}

func (s *UnitBoundaryContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitBoundaryContext) FLOOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFLOOR, 0)
}

func (s *UnitBoundaryContext) CEIL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCEIL, 0)
}

func (s *UnitBoundaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitBoundaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitBoundaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterUnitBoundary(s)
	}
}

func (s *UnitBoundaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitUnitBoundary(s)
	}
}

func (s *UnitBoundaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitUnitBoundary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) UnitBoundary() (localctx IUnitBoundaryContext) {
	localctx = NewUnitBoundaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 992, DorisSQLParserParserRULE_unitBoundary)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7987)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisSQLParserParserCEIL || _la == DorisSQLParserParserFLOOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeContext is an interface to support dynamic dispatch.
type ITypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BaseType() IBaseTypeContext
	DecimalType() IDecimalTypeContext
	ArrayType() IArrayTypeContext
	StructType() IStructTypeContext
	MapType() IMapTypeContext

	// IsTypeContext differentiates from other interfaces.
	IsTypeContext()
}

type TypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeContext() *TypeContext {
	var p = new(TypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_type
	return p
}

func InitEmptyTypeContext(p *TypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_type
}

func (*TypeContext) IsTypeContext() {}

func NewTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeContext {
	var p = new(TypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_type

	return p
}

func (s *TypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeContext) BaseType() IBaseTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTypeContext)
}

func (s *TypeContext) DecimalType() IDecimalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalTypeContext)
}

func (s *TypeContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *TypeContext) StructType() IStructTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructTypeContext)
}

func (s *TypeContext) MapType() IMapTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapTypeContext)
}

func (s *TypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterType(s)
	}
}

func (s *TypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitType(s)
	}
}

func (s *TypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Type_() (localctx ITypeContext) {
	localctx = NewTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 994, DorisSQLParserParserRULE_type)
	p.SetState(7994)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserBIGINT, DorisSQLParserParserBINARY, DorisSQLParserParserBITMAP, DorisSQLParserParserBOOLEAN, DorisSQLParserParserCHAR, DorisSQLParserParserDATE, DorisSQLParserParserDATETIME, DorisSQLParserParserDOUBLE, DorisSQLParserParserFLOAT, DorisSQLParserParserHLL, DorisSQLParserParserINT, DorisSQLParserParserINTEGER, DorisSQLParserParserJSON, DorisSQLParserParserLARGEINT, DorisSQLParserParserPERCENTILE, DorisSQLParserParserSIGNED, DorisSQLParserParserSMALLINT, DorisSQLParserParserSTRING, DorisSQLParserParserTEXT, DorisSQLParserParserTIME, DorisSQLParserParserTINYINT, DorisSQLParserParserUNSIGNED, DorisSQLParserParserVARBINARY, DorisSQLParserParserVARCHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7989)
			p.BaseType()
		}

	case DorisSQLParserParserDECIMAL, DorisSQLParserParserDECIMALV2, DorisSQLParserParserDECIMAL32, DorisSQLParserParserDECIMAL64, DorisSQLParserParserDECIMAL128, DorisSQLParserParserNUMBER, DorisSQLParserParserNUMERIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7990)
			p.DecimalType()
		}

	case DorisSQLParserParserARRAY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7991)
			p.ArrayType()
		}

	case DorisSQLParserParserSTRUCT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7992)
			p.StructType()
		}

	case DorisSQLParserParserMAP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7993)
			p.MapType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY() antlr.TerminalNode
	LT() antlr.TerminalNode
	Type_() ITypeContext
	GT() antlr.TerminalNode

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_arrayType
	return p
}

func InitEmptyArrayTypeContext(p *ArrayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_arrayType
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserARRAY, 0)
}

func (s *ArrayTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLT, 0)
}

func (s *ArrayTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ArrayTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGT, 0)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (s *ArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 996, DorisSQLParserParserRULE_arrayType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7996)
		p.Match(DorisSQLParserParserARRAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7997)
		p.Match(DorisSQLParserParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7998)
		p.Type_()
	}
	{
		p.SetState(7999)
		p.Match(DorisSQLParserParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapTypeContext is an interface to support dynamic dispatch.
type IMapTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAP() antlr.TerminalNode
	LT() antlr.TerminalNode
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	GT() antlr.TerminalNode

	// IsMapTypeContext differentiates from other interfaces.
	IsMapTypeContext()
}

type MapTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapTypeContext() *MapTypeContext {
	var p = new(MapTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_mapType
	return p
}

func InitEmptyMapTypeContext(p *MapTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_mapType
}

func (*MapTypeContext) IsMapTypeContext() {}

func NewMapTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapTypeContext {
	var p = new(MapTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_mapType

	return p
}

func (s *MapTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *MapTypeContext) MAP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMAP, 0)
}

func (s *MapTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLT, 0)
}

func (s *MapTypeContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *MapTypeContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *MapTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGT, 0)
}

func (s *MapTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterMapType(s)
	}
}

func (s *MapTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitMapType(s)
	}
}

func (s *MapTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitMapType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) MapType() (localctx IMapTypeContext) {
	localctx = NewMapTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 998, DorisSQLParserParserRULE_mapType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8001)
		p.Match(DorisSQLParserParserMAP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8002)
		p.Match(DorisSQLParserParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8003)
		p.Type_()
	}
	{
		p.SetState(8004)
		p.Match(DorisSQLParserParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8005)
		p.Type_()
	}
	{
		p.SetState(8006)
		p.Match(DorisSQLParserParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubfieldDescContext is an interface to support dynamic dispatch.
type ISubfieldDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext
	Identifier() IIdentifierContext
	NestedFieldName() INestedFieldNameContext

	// IsSubfieldDescContext differentiates from other interfaces.
	IsSubfieldDescContext()
}

type SubfieldDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubfieldDescContext() *SubfieldDescContext {
	var p = new(SubfieldDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_subfieldDesc
	return p
}

func InitEmptySubfieldDescContext(p *SubfieldDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_subfieldDesc
}

func (*SubfieldDescContext) IsSubfieldDescContext() {}

func NewSubfieldDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubfieldDescContext {
	var p = new(SubfieldDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_subfieldDesc

	return p
}

func (s *SubfieldDescContext) GetParser() antlr.Parser { return s.parser }

func (s *SubfieldDescContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *SubfieldDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubfieldDescContext) NestedFieldName() INestedFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedFieldNameContext)
}

func (s *SubfieldDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubfieldDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubfieldDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSubfieldDesc(s)
	}
}

func (s *SubfieldDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSubfieldDesc(s)
	}
}

func (s *SubfieldDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSubfieldDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SubfieldDesc() (localctx ISubfieldDescContext) {
	localctx = NewSubfieldDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1000, DorisSQLParserParserRULE_subfieldDesc)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(8010)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 943, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(8008)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(8009)
			p.NestedFieldName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(8012)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubfieldDescsContext is an interface to support dynamic dispatch.
type ISubfieldDescsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSubfieldDesc() []ISubfieldDescContext
	SubfieldDesc(i int) ISubfieldDescContext

	// IsSubfieldDescsContext differentiates from other interfaces.
	IsSubfieldDescsContext()
}

type SubfieldDescsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubfieldDescsContext() *SubfieldDescsContext {
	var p = new(SubfieldDescsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_subfieldDescs
	return p
}

func InitEmptySubfieldDescsContext(p *SubfieldDescsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_subfieldDescs
}

func (*SubfieldDescsContext) IsSubfieldDescsContext() {}

func NewSubfieldDescsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubfieldDescsContext {
	var p = new(SubfieldDescsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_subfieldDescs

	return p
}

func (s *SubfieldDescsContext) GetParser() antlr.Parser { return s.parser }

func (s *SubfieldDescsContext) AllSubfieldDesc() []ISubfieldDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubfieldDescContext); ok {
			len++
		}
	}

	tst := make([]ISubfieldDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubfieldDescContext); ok {
			tst[i] = t.(ISubfieldDescContext)
			i++
		}
	}

	return tst
}

func (s *SubfieldDescsContext) SubfieldDesc(i int) ISubfieldDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubfieldDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubfieldDescContext)
}

func (s *SubfieldDescsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubfieldDescsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubfieldDescsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterSubfieldDescs(s)
	}
}

func (s *SubfieldDescsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitSubfieldDescs(s)
	}
}

func (s *SubfieldDescsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitSubfieldDescs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) SubfieldDescs() (localctx ISubfieldDescsContext) {
	localctx = NewSubfieldDescsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1002, DorisSQLParserParserRULE_subfieldDescs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8014)
		p.SubfieldDesc()
	}
	p.SetState(8019)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(8015)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8016)
			p.SubfieldDesc()
		}

		p.SetState(8021)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructTypeContext is an interface to support dynamic dispatch.
type IStructTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRUCT() antlr.TerminalNode
	LT() antlr.TerminalNode
	SubfieldDescs() ISubfieldDescsContext
	GT() antlr.TerminalNode

	// IsStructTypeContext differentiates from other interfaces.
	IsStructTypeContext()
}

type StructTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructTypeContext() *StructTypeContext {
	var p = new(StructTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_structType
	return p
}

func InitEmptyStructTypeContext(p *StructTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_structType
}

func (*StructTypeContext) IsStructTypeContext() {}

func NewStructTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructTypeContext {
	var p = new(StructTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_structType

	return p
}

func (s *StructTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StructTypeContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTRUCT, 0)
}

func (s *StructTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLT, 0)
}

func (s *StructTypeContext) SubfieldDescs() ISubfieldDescsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubfieldDescsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubfieldDescsContext)
}

func (s *StructTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGT, 0)
}

func (s *StructTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterStructType(s)
	}
}

func (s *StructTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitStructType(s)
	}
}

func (s *StructTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitStructType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) StructType() (localctx IStructTypeContext) {
	localctx = NewStructTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1004, DorisSQLParserParserRULE_structType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8022)
		p.Match(DorisSQLParserParserSTRUCT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8023)
		p.Match(DorisSQLParserParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8024)
		p.SubfieldDescs()
	}
	{
		p.SetState(8025)
		p.Match(DorisSQLParserParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER_VALUE() antlr.TerminalNode

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_typeParameter
	return p
}

func InitEmptyTypeParameterContext(p *TypeParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_typeParameter
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, 0)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (s *TypeParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTypeParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) TypeParameter() (localctx ITypeParameterContext) {
	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1006, DorisSQLParserParserRULE_typeParameter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8027)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8028)
		p.Match(DorisSQLParserParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8029)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBaseTypeContext is an interface to support dynamic dispatch.
type IBaseTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BOOLEAN() antlr.TerminalNode
	TINYINT() antlr.TerminalNode
	TypeParameter() ITypeParameterContext
	SMALLINT() antlr.TerminalNode
	SIGNED() antlr.TerminalNode
	INT() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	UNSIGNED() antlr.TerminalNode
	BIGINT() antlr.TerminalNode
	LARGEINT() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	TIME() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	VARCHAR() antlr.TerminalNode
	STRING() antlr.TerminalNode
	TEXT() antlr.TerminalNode
	BITMAP() antlr.TerminalNode
	HLL() antlr.TerminalNode
	PERCENTILE() antlr.TerminalNode
	JSON() antlr.TerminalNode
	VARBINARY() antlr.TerminalNode
	BINARY() antlr.TerminalNode

	// IsBaseTypeContext differentiates from other interfaces.
	IsBaseTypeContext()
}

type BaseTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseTypeContext() *BaseTypeContext {
	var p = new(BaseTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_baseType
	return p
}

func InitEmptyBaseTypeContext(p *BaseTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_baseType
}

func (*BaseTypeContext) IsBaseTypeContext() {}

func NewBaseTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseTypeContext {
	var p = new(BaseTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_baseType

	return p
}

func (s *BaseTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBOOLEAN, 0)
}

func (s *BaseTypeContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTINYINT, 0)
}

func (s *BaseTypeContext) TypeParameter() ITypeParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *BaseTypeContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSMALLINT, 0)
}

func (s *BaseTypeContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSIGNED, 0)
}

func (s *BaseTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINT, 0)
}

func (s *BaseTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER, 0)
}

func (s *BaseTypeContext) UNSIGNED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUNSIGNED, 0)
}

func (s *BaseTypeContext) BIGINT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBIGINT, 0)
}

func (s *BaseTypeContext) LARGEINT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLARGEINT, 0)
}

func (s *BaseTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFLOAT, 0)
}

func (s *BaseTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDOUBLE, 0)
}

func (s *BaseTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATE, 0)
}

func (s *BaseTypeContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATETIME, 0)
}

func (s *BaseTypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTIME, 0)
}

func (s *BaseTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCHAR, 0)
}

func (s *BaseTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVARCHAR, 0)
}

func (s *BaseTypeContext) STRING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTRING, 0)
}

func (s *BaseTypeContext) TEXT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTEXT, 0)
}

func (s *BaseTypeContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBITMAP, 0)
}

func (s *BaseTypeContext) HLL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserHLL, 0)
}

func (s *BaseTypeContext) PERCENTILE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPERCENTILE, 0)
}

func (s *BaseTypeContext) JSON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserJSON, 0)
}

func (s *BaseTypeContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVARBINARY, 0)
}

func (s *BaseTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBINARY, 0)
}

func (s *BaseTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterBaseType(s)
	}
}

func (s *BaseTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitBaseType(s)
	}
}

func (s *BaseTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitBaseType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) BaseType() (localctx IBaseTypeContext) {
	localctx = NewBaseTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1008, DorisSQLParserParserRULE_baseType)
	var _la int

	p.SetState(8099)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 959, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8031)
			p.Match(DorisSQLParserParserBOOLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8032)
			p.Match(DorisSQLParserParserTINYINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8034)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__1 {
			{
				p.SetState(8033)
				p.TypeParameter()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8036)
			p.Match(DorisSQLParserParserSMALLINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8038)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__1 {
			{
				p.SetState(8037)
				p.TypeParameter()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(8040)
			p.Match(DorisSQLParserParserSIGNED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8042)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserINT {
			{
				p.SetState(8041)
				p.Match(DorisSQLParserParserINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(8044)
			p.Match(DorisSQLParserParserSIGNED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8046)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserINTEGER {
			{
				p.SetState(8045)
				p.Match(DorisSQLParserParserINTEGER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(8048)
			p.Match(DorisSQLParserParserUNSIGNED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8050)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserINT {
			{
				p.SetState(8049)
				p.Match(DorisSQLParserParserINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(8052)
			p.Match(DorisSQLParserParserUNSIGNED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8054)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserINTEGER {
			{
				p.SetState(8053)
				p.Match(DorisSQLParserParserINTEGER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(8056)
			p.Match(DorisSQLParserParserINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8058)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__1 {
			{
				p.SetState(8057)
				p.TypeParameter()
			}

		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(8060)
			p.Match(DorisSQLParserParserINTEGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8062)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__1 {
			{
				p.SetState(8061)
				p.TypeParameter()
			}

		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(8064)
			p.Match(DorisSQLParserParserBIGINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8066)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__1 {
			{
				p.SetState(8065)
				p.TypeParameter()
			}

		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(8068)
			p.Match(DorisSQLParserParserLARGEINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8070)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__1 {
			{
				p.SetState(8069)
				p.TypeParameter()
			}

		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(8072)
			p.Match(DorisSQLParserParserFLOAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(8073)
			p.Match(DorisSQLParserParserDOUBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(8074)
			p.Match(DorisSQLParserParserDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(8075)
			p.Match(DorisSQLParserParserDATETIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(8076)
			p.Match(DorisSQLParserParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(8077)
			p.Match(DorisSQLParserParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8079)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__1 {
			{
				p.SetState(8078)
				p.TypeParameter()
			}

		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(8081)
			p.Match(DorisSQLParserParserVARCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8083)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__1 {
			{
				p.SetState(8082)
				p.TypeParameter()
			}

		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(8085)
			p.Match(DorisSQLParserParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(8086)
			p.Match(DorisSQLParserParserTEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(8087)
			p.Match(DorisSQLParserParserBITMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(8088)
			p.Match(DorisSQLParserParserHLL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(8089)
			p.Match(DorisSQLParserParserPERCENTILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(8090)
			p.Match(DorisSQLParserParserJSON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(8091)
			p.Match(DorisSQLParserParserVARBINARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8093)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__1 {
			{
				p.SetState(8092)
				p.TypeParameter()
			}

		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(8095)
			p.Match(DorisSQLParserParserBINARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8097)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__1 {
			{
				p.SetState(8096)
				p.TypeParameter()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecimalTypeContext is an interface to support dynamic dispatch.
type IDecimalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPrecision returns the precision token.
	GetPrecision() antlr.Token

	// GetScale returns the scale token.
	GetScale() antlr.Token

	// SetPrecision sets the precision token.
	SetPrecision(antlr.Token)

	// SetScale sets the scale token.
	SetScale(antlr.Token)

	// Getter signatures
	DECIMAL() antlr.TerminalNode
	DECIMALV2() antlr.TerminalNode
	DECIMAL32() antlr.TerminalNode
	DECIMAL64() antlr.TerminalNode
	DECIMAL128() antlr.TerminalNode
	NUMERIC() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsDecimalTypeContext differentiates from other interfaces.
	IsDecimalTypeContext()
}

type DecimalTypeContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	precision antlr.Token
	scale     antlr.Token
}

func NewEmptyDecimalTypeContext() *DecimalTypeContext {
	var p = new(DecimalTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_decimalType
	return p
}

func InitEmptyDecimalTypeContext(p *DecimalTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_decimalType
}

func (*DecimalTypeContext) IsDecimalTypeContext() {}

func NewDecimalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalTypeContext {
	var p = new(DecimalTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_decimalType

	return p
}

func (s *DecimalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalTypeContext) GetPrecision() antlr.Token { return s.precision }

func (s *DecimalTypeContext) GetScale() antlr.Token { return s.scale }

func (s *DecimalTypeContext) SetPrecision(v antlr.Token) { s.precision = v }

func (s *DecimalTypeContext) SetScale(v antlr.Token) { s.scale = v }

func (s *DecimalTypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDECIMAL, 0)
}

func (s *DecimalTypeContext) DECIMALV2() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDECIMALV2, 0)
}

func (s *DecimalTypeContext) DECIMAL32() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDECIMAL32, 0)
}

func (s *DecimalTypeContext) DECIMAL64() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDECIMAL64, 0)
}

func (s *DecimalTypeContext) DECIMAL128() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDECIMAL128, 0)
}

func (s *DecimalTypeContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNUMERIC, 0)
}

func (s *DecimalTypeContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNUMBER, 0)
}

func (s *DecimalTypeContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserINTEGER_VALUE)
}

func (s *DecimalTypeContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, i)
}

func (s *DecimalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDecimalType(s)
	}
}

func (s *DecimalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDecimalType(s)
	}
}

func (s *DecimalTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDecimalType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) DecimalType() (localctx IDecimalTypeContext) {
	localctx = NewDecimalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1010, DorisSQLParserParserRULE_decimalType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8101)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-111)) & ^0x3f) == 0 && ((int64(1)<<(_la-111))&31) != 0) || _la == DorisSQLParserParserNUMBER || _la == DorisSQLParserParserNUMERIC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(8109)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserT__1 {
		{
			p.SetState(8102)
			p.Match(DorisSQLParserParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8103)

			var _m = p.Match(DorisSQLParserParserINTEGER_VALUE)

			localctx.(*DecimalTypeContext).precision = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8106)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisSQLParserParserT__2 {
			{
				p.SetState(8104)
				p.Match(DorisSQLParserParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8105)

				var _m = p.Match(DorisSQLParserParserINTEGER_VALUE)

				localctx.(*DecimalTypeContext).scale = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(8108)
			p.Match(DorisSQLParserParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDOT_IDENTIFIER() []antlr.TerminalNode
	DOT_IDENTIFIER(i int) antlr.TerminalNode

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_qualifiedName
	return p
}

func InitEmptyQualifiedNameContext(p *QualifiedNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_qualifiedName
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedNameContext) AllDOT_IDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(DorisSQLParserParserDOT_IDENTIFIER)
}

func (s *QualifiedNameContext) DOT_IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDOT_IDENTIFIER, i)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterQualifiedName(s)
	}
}

func (s *QualifiedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitQualifiedName(s)
	}
}

func (s *QualifiedNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitQualifiedName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) QualifiedName() (localctx IQualifiedNameContext) {
	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1012, DorisSQLParserParserRULE_qualifiedName)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8111)
		p.Identifier()
	}
	p.SetState(8117)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 963, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(8115)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisSQLParserParserDOT_IDENTIFIER:
				{
					p.SetState(8112)
					p.Match(DorisSQLParserParserDOT_IDENTIFIER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case DorisSQLParserParserT__0:
				{
					p.SetState(8113)
					p.Match(DorisSQLParserParserT__0)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(8114)
					p.Identifier()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(8119)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 963, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableNameContext is an interface to support dynamic dispatch.
type ITableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext

	// IsTableNameContext differentiates from other interfaces.
	IsTableNameContext()
}

type TableNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableNameContext() *TableNameContext {
	var p = new(TableNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_tableName
	return p
}

func InitEmptyTableNameContext(p *TableNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_tableName
}

func (*TableNameContext) IsTableNameContext() {}

func NewTableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableNameContext {
	var p = new(TableNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_tableName

	return p
}

func (s *TableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TableNameContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (s *TableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitTableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) TableName() (localctx ITableNameContext) {
	localctx = NewTableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1014, DorisSQLParserParserRULE_tableName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8120)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWriteBranchContext is an interface to support dynamic dispatch.
type IWriteBranchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VERSION() antlr.TerminalNode
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode
	Identifier() IIdentifierContext
	FOR() antlr.TerminalNode

	// IsWriteBranchContext differentiates from other interfaces.
	IsWriteBranchContext()
}

type WriteBranchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteBranchContext() *WriteBranchContext {
	var p = new(WriteBranchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_writeBranch
	return p
}

func InitEmptyWriteBranchContext(p *WriteBranchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_writeBranch
}

func (*WriteBranchContext) IsWriteBranchContext() {}

func NewWriteBranchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteBranchContext {
	var p = new(WriteBranchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_writeBranch

	return p
}

func (s *WriteBranchContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteBranchContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVERSION, 0)
}

func (s *WriteBranchContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *WriteBranchContext) OF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOF, 0)
}

func (s *WriteBranchContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WriteBranchContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFOR, 0)
}

func (s *WriteBranchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteBranchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteBranchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterWriteBranch(s)
	}
}

func (s *WriteBranchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitWriteBranch(s)
	}
}

func (s *WriteBranchContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitWriteBranch(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) WriteBranch() (localctx IWriteBranchContext) {
	localctx = NewWriteBranchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1016, DorisSQLParserParserRULE_writeBranch)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(8123)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserFOR {
		{
			p.SetState(8122)
			p.Match(DorisSQLParserParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(8125)
		p.Match(DorisSQLParserParserVERSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8126)
		p.Match(DorisSQLParserParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8127)
		p.Match(DorisSQLParserParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8128)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) CopyAll(ctx *IdentifierContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BackQuotedIdentifierContext struct {
	IdentifierContext
}

func NewBackQuotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BackQuotedIdentifierContext {
	var p = new(BackQuotedIdentifierContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *BackQuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackQuotedIdentifierContext) BACKQUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBACKQUOTED_IDENTIFIER, 0)
}

func (s *BackQuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterBackQuotedIdentifier(s)
	}
}

func (s *BackQuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitBackQuotedIdentifier(s)
	}
}

func (s *BackQuotedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitBackQuotedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type DigitIdentifierContext struct {
	IdentifierContext
}

func NewDigitIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DigitIdentifierContext {
	var p = new(DigitIdentifierContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *DigitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitIdentifierContext) DIGIT_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDIGIT_IDENTIFIER, 0)
}

func (s *DigitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDigitIdentifier(s)
	}
}

func (s *DigitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDigitIdentifier(s)
	}
}

func (s *DigitIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDigitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnquotedIdentifierContext struct {
	IdentifierContext
}

func NewUnquotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnquotedIdentifierContext {
	var p = new(UnquotedIdentifierContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *UnquotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnquotedIdentifierContext) LETTER_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLETTER_IDENTIFIER, 0)
}

func (s *UnquotedIdentifierContext) NonReserved() INonReservedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonReservedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonReservedContext)
}

func (s *UnquotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitUnquotedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1018, DorisSQLParserParserRULE_identifier)
	p.SetState(8134)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserLETTER_IDENTIFIER:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8130)
			p.Match(DorisSQLParserParserLETTER_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserACCESS, DorisSQLParserParserACTIVE, DorisSQLParserParserADMIN, DorisSQLParserParserADVISOR, DorisSQLParserParserAFTER, DorisSQLParserParserAGGREGATE, DorisSQLParserParserANTI, DorisSQLParserParserAPPLY, DorisSQLParserParserARRAY_AGG, DorisSQLParserParserARRAY_AGG_DISTINCT, DorisSQLParserParserASYNC, DorisSQLParserParserAUTHORS, DorisSQLParserParserAUTHENTICATION, DorisSQLParserParserAUTOMATED, DorisSQLParserParserAUTO_INCREMENT, DorisSQLParserParserAVG, DorisSQLParserParserBACKEND, DorisSQLParserParserBACKENDS, DorisSQLParserParserBACKUP, DorisSQLParserParserBASE, DorisSQLParserParserBASELINE, DorisSQLParserParserBEGIN, DorisSQLParserParserBINARY, DorisSQLParserParserBITMAP_UNION, DorisSQLParserParserBLACKHOLE, DorisSQLParserParserBLACKLIST, DorisSQLParserParserBODY, DorisSQLParserParserBOOLEAN, DorisSQLParserParserBRANCH, DorisSQLParserParserBROKER, DorisSQLParserParserBUCKETS, DorisSQLParserParserBUILTIN, DorisSQLParserParserCACHE, DorisSQLParserParserCANCEL, DorisSQLParserParserCAST, DorisSQLParserParserCATALOG, DorisSQLParserParserCATALOGS, DorisSQLParserParserCEIL, DorisSQLParserParserCHAIN, DorisSQLParserParserCHARSET, DorisSQLParserParserCLEAN, DorisSQLParserParserCLEAR, DorisSQLParserParserCLUSTER, DorisSQLParserParserCLUSTERS, DorisSQLParserParserCNGROUP, DorisSQLParserParserCNGROUPS, DorisSQLParserParserCOLLATION, DorisSQLParserParserCOLUMNS, DorisSQLParserParserCOMMENT, DorisSQLParserParserCOMMIT, DorisSQLParserParserCOMMITTED, DorisSQLParserParserCOMPACT, DorisSQLParserParserCOMPUTE, DorisSQLParserParserCONFIG, DorisSQLParserParserCONNECTION, DorisSQLParserParserCONSISTENT, DorisSQLParserParserCOSTS, DorisSQLParserParserCOUNT, DorisSQLParserParserCUME_DIST, DorisSQLParserParserCUMULATIVE, DorisSQLParserParserCURRENT, DorisSQLParserParserDATA, DorisSQLParserParserDATACACHE, DorisSQLParserParserDATE, DorisSQLParserParserDATETIME, DorisSQLParserParserDAY, DorisSQLParserParserDAYS, DorisSQLParserParserDEALLOCATE, DorisSQLParserParserDECOMMISSION, DorisSQLParserParserDIALECT, DorisSQLParserParserDICTIONARY, DorisSQLParserParserDICTIONARY_GET, DorisSQLParserParserDISABLE, DorisSQLParserParserDISTRIBUTED, DorisSQLParserParserDISTRIBUTION, DorisSQLParserParserDUPLICATE, DorisSQLParserParserDYNAMIC, DorisSQLParserParserENABLE, DorisSQLParserParserENCLOSE, DorisSQLParserParserEND, DorisSQLParserParserENGINE, DorisSQLParserParserENGINES, DorisSQLParserParserERRORS, DorisSQLParserParserESCAPE, DorisSQLParserParserEVENTS, DorisSQLParserParserEXCEPT, DorisSQLParserParserEXCLUDE, DorisSQLParserParserEXECUTE, DorisSQLParserParserEXPORT, DorisSQLParserParserEXTERNAL, DorisSQLParserParserEXTRACT, DorisSQLParserParserEVERY, DorisSQLParserParserFAILPOINT, DorisSQLParserParserFAILPOINTS, DorisSQLParserParserFIELDS, DorisSQLParserParserFILE, DorisSQLParserParserFILTER, DorisSQLParserParserFIRST, DorisSQLParserParserFLOOR, DorisSQLParserParserFN, DorisSQLParserParserFOLLOWING, DorisSQLParserParserFOLLOWER, DorisSQLParserParserFORMAT, DorisSQLParserParserFREE, DorisSQLParserParserFRONTEND, DorisSQLParserParserFRONTENDS, DorisSQLParserParserFUNCTIONS, DorisSQLParserParserGLOBAL, DorisSQLParserParserGRANTS, DorisSQLParserParserGROUP_CONCAT, DorisSQLParserParserHASH, DorisSQLParserParserHELP, DorisSQLParserParserHISTOGRAM, DorisSQLParserParserHLL_UNION, DorisSQLParserParserHOST, DorisSQLParserParserHOUR, DorisSQLParserParserHOURS, DorisSQLParserParserHUB, DorisSQLParserParserIDENTIFIED, DorisSQLParserParserIMPERSONATE, DorisSQLParserParserIMAGE, DorisSQLParserParserINACTIVE, DorisSQLParserParserINCREMENTAL, DorisSQLParserParserINDEXES, DorisSQLParserParserINSTALL, DorisSQLParserParserINTEGRATION, DorisSQLParserParserINTEGRATIONS, DorisSQLParserParserINTERMEDIATE, DorisSQLParserParserINTERVAL, DorisSQLParserParserOVERWRITE, DorisSQLParserParserISOLATION, DorisSQLParserParserJOB, DorisSQLParserParserLABEL, DorisSQLParserParserLAST, DorisSQLParserParserLESS, DorisSQLParserParserLEVEL, DorisSQLParserParserLIST, DorisSQLParserParserLOCAL, DorisSQLParserParserLOCATION, DorisSQLParserParserLOCATIONS, DorisSQLParserParserLOGS, DorisSQLParserParserLOGICAL, DorisSQLParserParserMANUAL, DorisSQLParserParserMAP, DorisSQLParserParserMAPPING, DorisSQLParserParserMAPPINGS, DorisSQLParserParserMASKING, DorisSQLParserParserMATCH, DorisSQLParserParserMATERIALIZED, DorisSQLParserParserMAX, DorisSQLParserParserMERGE, DorisSQLParserParserMIN, DorisSQLParserParserMINUTE, DorisSQLParserParserMINUTES, DorisSQLParserParserMINUS, DorisSQLParserParserMETA, DorisSQLParserParserMODE, DorisSQLParserParserMODIFY, DorisSQLParserParserMONTH, DorisSQLParserParserMULTIPLE, DorisSQLParserParserNAME, DorisSQLParserParserNAMES, DorisSQLParserParserNEGATIVE, DorisSQLParserParserNGRAMBF, DorisSQLParserParserNO, DorisSQLParserParserNODE, DorisSQLParserParserNODES, DorisSQLParserParserNONE, DorisSQLParserParserNULLS, DorisSQLParserParserNUMBER, DorisSQLParserParserNUMERIC, DorisSQLParserParserOBSERVER, DorisSQLParserParserOF, DorisSQLParserParserOFF, DorisSQLParserParserOFFSET, DorisSQLParserParserONLY, DorisSQLParserParserOPEN, DorisSQLParserParserOPERATE, DorisSQLParserParserOPTIMIZER, DorisSQLParserParserOPTION, DorisSQLParserParserPARTITIONS, DorisSQLParserParserPASSWORD, DorisSQLParserParserPATH, DorisSQLParserParserPAUSE, DorisSQLParserParserPENDING, DorisSQLParserParserPERCENT_RANK, DorisSQLParserParserPERCENTILE_UNION, DorisSQLParserParserPLAN, DorisSQLParserParserPLUGIN, DorisSQLParserParserPLUGINS, DorisSQLParserParserPIPE, DorisSQLParserParserPIPES, DorisSQLParserParserPIVOT, DorisSQLParserParserPOLICY, DorisSQLParserParserPOLICIES, DorisSQLParserParserPRECEDING, DorisSQLParserParserPREDICATE, DorisSQLParserParserPRIORITY, DorisSQLParserParserPRIVILEGES, DorisSQLParserParserPROBABILITY, DorisSQLParserParserPROC, DorisSQLParserParserPROCESSLIST, DorisSQLParserParserPROFILE, DorisSQLParserParserPROFILELIST, DorisSQLParserParserPROPERTIES, DorisSQLParserParserPROPERTY, DorisSQLParserParserPROVIDER, DorisSQLParserParserPROVIDERS, DorisSQLParserParserQUALIFY, DorisSQLParserParserQUARTER, DorisSQLParserParserQUERY, DorisSQLParserParserQUERIES, DorisSQLParserParserQUEUE, DorisSQLParserParserQUOTA, DorisSQLParserParserRANDOM, DorisSQLParserParserRANK, DorisSQLParserParserREASON, DorisSQLParserParserRECOVER, DorisSQLParserParserREFRESH, DorisSQLParserParserREWRITE, DorisSQLParserParserREMOVE, DorisSQLParserParserREPAIR, DorisSQLParserParserREPEATABLE, DorisSQLParserParserREPLACE_IF_NOT_NULL, DorisSQLParserParserREPLICA, DorisSQLParserParserREPOSITORY, DorisSQLParserParserREPOSITORIES, DorisSQLParserParserRESOURCE, DorisSQLParserParserRESOURCES, DorisSQLParserParserRESTORE, DorisSQLParserParserRESUME, DorisSQLParserParserRETAIN, DorisSQLParserParserRETENTION, DorisSQLParserParserRETURNS, DorisSQLParserParserRETRY, DorisSQLParserParserREVERT, DorisSQLParserParserROLE, DorisSQLParserParserROLES, DorisSQLParserParserROLLBACK, DorisSQLParserParserROLLUP, DorisSQLParserParserROUTINE, DorisSQLParserParserROW, DorisSQLParserParserRULE, DorisSQLParserParserRULES, DorisSQLParserParserRUNNING, DorisSQLParserParserSAMPLE, DorisSQLParserParserSCHEDULE, DorisSQLParserParserSCHEDULER, DorisSQLParserParserSECOND, DorisSQLParserParserSECURITY, DorisSQLParserParserSEMI, DorisSQLParserParserSEPARATOR, DorisSQLParserParserSERIALIZABLE, DorisSQLParserParserSESSION, DorisSQLParserParserSETS, DorisSQLParserParserSIGNED, DorisSQLParserParserSKIP_HEADER, DorisSQLParserParserSNAPSHOT, DorisSQLParserParserSNAPSHOTS, DorisSQLParserParserSQLBLACKLIST, DorisSQLParserParserSTART, DorisSQLParserParserSTATS, DorisSQLParserParserSTATUS, DorisSQLParserParserSTOP, DorisSQLParserParserSTORAGE, DorisSQLParserParserSTREAM, DorisSQLParserParserSTRING, DorisSQLParserParserSUBMIT, DorisSQLParserParserSUM, DorisSQLParserParserSUSPEND, DorisSQLParserParserSYNC, DorisSQLParserParserSYSTEM_TIME, DorisSQLParserParserSWAP, DorisSQLParserParserSTRUCT, DorisSQLParserParserTABLES, DorisSQLParserParserTABLET, DorisSQLParserParserTABLETS, DorisSQLParserParserTAG, DorisSQLParserParserTASK, DorisSQLParserParserTEMPORARY, DorisSQLParserParserTHAN, DorisSQLParserParserTIME, DorisSQLParserParserTIMES, DorisSQLParserParserTIMESTAMP, DorisSQLParserParserTIMESTAMPADD, DorisSQLParserParserTIMESTAMPDIFF, DorisSQLParserParserTRANSACTION, DorisSQLParserParserTRANSLATE, DorisSQLParserParserTRACE, DorisSQLParserParserTRIGGERS, DorisSQLParserParserTRIM_SPACE, DorisSQLParserParserTRUNCATE, DorisSQLParserParserTYPE, DorisSQLParserParserTYPES, DorisSQLParserParserUNBOUNDED, DorisSQLParserParserUNCOMMITTED, DorisSQLParserParserUNINSTALL, DorisSQLParserParserUNSET, DorisSQLParserParserUSAGE, DorisSQLParserParserUSER, DorisSQLParserParserUSERS, DorisSQLParserParserVALUE, DorisSQLParserParserVARBINARY, DorisSQLParserParserVARIABLES, DorisSQLParserParserVECTOR, DorisSQLParserParserVERBOSE, DorisSQLParserParserVERSION, DorisSQLParserParserVIEW, DorisSQLParserParserVIEWS, DorisSQLParserParserVOLUME, DorisSQLParserParserVOLUMES, DorisSQLParserParserWAREHOUSE, DorisSQLParserParserWAREHOUSES, DorisSQLParserParserWARNINGS, DorisSQLParserParserWEEK, DorisSQLParserParserWHITELIST, DorisSQLParserParserWORK, DorisSQLParserParserWRITE, DorisSQLParserParserYEAR, DorisSQLParserParserLOCK, DorisSQLParserParserUNLOCK, DorisSQLParserParserLOW_PRIORITY, DorisSQLParserParserDISK, DorisSQLParserParserBEFORE, DorisSQLParserParserFIELD, DorisSQLParserParserPERSISTENT, DorisSQLParserParserARRAY_ELEMENT, DorisSQLParserParserDOTDOTDOT:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8131)
			p.NonReserved()
		}

	case DorisSQLParserParserDIGIT_IDENTIFIER:
		localctx = NewDigitIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8132)
			p.Match(DorisSQLParserParserDIGIT_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserBACKQUOTED_IDENTIFIER:
		localctx = NewBackQuotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(8133)
			p.Match(DorisSQLParserParserBACKQUOTED_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierWithAliasContext is an interface to support dynamic dispatch.
type IIdentifierWithAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOriginalName returns the originalName rule contexts.
	GetOriginalName() IIdentifierContext

	// GetAlias returns the alias rule contexts.
	GetAlias() IIdentifierContext

	// SetOriginalName sets the originalName rule contexts.
	SetOriginalName(IIdentifierContext)

	// SetAlias sets the alias rule contexts.
	SetAlias(IIdentifierContext)

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AS() antlr.TerminalNode

	// IsIdentifierWithAliasContext differentiates from other interfaces.
	IsIdentifierWithAliasContext()
}

type IdentifierWithAliasContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	originalName IIdentifierContext
	alias        IIdentifierContext
}

func NewEmptyIdentifierWithAliasContext() *IdentifierWithAliasContext {
	var p = new(IdentifierWithAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_identifierWithAlias
	return p
}

func InitEmptyIdentifierWithAliasContext(p *IdentifierWithAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_identifierWithAlias
}

func (*IdentifierWithAliasContext) IsIdentifierWithAliasContext() {}

func NewIdentifierWithAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierWithAliasContext {
	var p = new(IdentifierWithAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_identifierWithAlias

	return p
}

func (s *IdentifierWithAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierWithAliasContext) GetOriginalName() IIdentifierContext { return s.originalName }

func (s *IdentifierWithAliasContext) GetAlias() IIdentifierContext { return s.alias }

func (s *IdentifierWithAliasContext) SetOriginalName(v IIdentifierContext) { s.originalName = v }

func (s *IdentifierWithAliasContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *IdentifierWithAliasContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierWithAliasContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierWithAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAS, 0)
}

func (s *IdentifierWithAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierWithAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierWithAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterIdentifierWithAlias(s)
	}
}

func (s *IdentifierWithAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitIdentifierWithAlias(s)
	}
}

func (s *IdentifierWithAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitIdentifierWithAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) IdentifierWithAlias() (localctx IIdentifierWithAliasContext) {
	localctx = NewIdentifierWithAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1020, DorisSQLParserParserRULE_identifierWithAlias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8136)

		var _x = p.Identifier()

		localctx.(*IdentifierWithAliasContext).originalName = _x
	}
	p.SetState(8139)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisSQLParserParserAS {
		{
			p.SetState(8137)
			p.Match(DorisSQLParserParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8138)

			var _x = p.Identifier()

			localctx.(*IdentifierWithAliasContext).alias = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierWithAliasListContext is an interface to support dynamic dispatch.
type IIdentifierWithAliasListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierWithAlias() []IIdentifierWithAliasContext
	IdentifierWithAlias(i int) IIdentifierWithAliasContext

	// IsIdentifierWithAliasListContext differentiates from other interfaces.
	IsIdentifierWithAliasListContext()
}

type IdentifierWithAliasListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierWithAliasListContext() *IdentifierWithAliasListContext {
	var p = new(IdentifierWithAliasListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_identifierWithAliasList
	return p
}

func InitEmptyIdentifierWithAliasListContext(p *IdentifierWithAliasListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_identifierWithAliasList
}

func (*IdentifierWithAliasListContext) IsIdentifierWithAliasListContext() {}

func NewIdentifierWithAliasListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierWithAliasListContext {
	var p = new(IdentifierWithAliasListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_identifierWithAliasList

	return p
}

func (s *IdentifierWithAliasListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierWithAliasListContext) AllIdentifierWithAlias() []IIdentifierWithAliasContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierWithAliasContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierWithAliasContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierWithAliasContext); ok {
			tst[i] = t.(IIdentifierWithAliasContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierWithAliasListContext) IdentifierWithAlias(i int) IIdentifierWithAliasContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierWithAliasContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierWithAliasContext)
}

func (s *IdentifierWithAliasListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierWithAliasListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierWithAliasListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterIdentifierWithAliasList(s)
	}
}

func (s *IdentifierWithAliasListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitIdentifierWithAliasList(s)
	}
}

func (s *IdentifierWithAliasListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitIdentifierWithAliasList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) IdentifierWithAliasList() (localctx IIdentifierWithAliasListContext) {
	localctx = NewIdentifierWithAliasListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1022, DorisSQLParserParserRULE_identifierWithAliasList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8141)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8142)
		p.IdentifierWithAlias()
	}
	p.SetState(8147)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(8143)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8144)
			p.IdentifierWithAlias()
		}

		p.SetState(8149)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(8150)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_identifierList
	return p
}

func InitEmptyIdentifierListContext(p *IdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_identifierList
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierListContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (s *IdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1024, DorisSQLParserParserRULE_identifierList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8152)
		p.Match(DorisSQLParserParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8153)
		p.Identifier()
	}
	p.SetState(8158)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(8154)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8155)
			p.Identifier()
		}

		p.SetState(8160)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(8161)
		p.Match(DorisSQLParserParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrStringContext is an interface to support dynamic dispatch.
type IIdentifierOrStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	String_() IStringContext

	// IsIdentifierOrStringContext differentiates from other interfaces.
	IsIdentifierOrStringContext()
}

type IdentifierOrStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrStringContext() *IdentifierOrStringContext {
	var p = new(IdentifierOrStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_identifierOrString
	return p
}

func InitEmptyIdentifierOrStringContext(p *IdentifierOrStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_identifierOrString
}

func (*IdentifierOrStringContext) IsIdentifierOrStringContext() {}

func NewIdentifierOrStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrStringContext {
	var p = new(IdentifierOrStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_identifierOrString

	return p
}

func (s *IdentifierOrStringContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrStringContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierOrStringContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *IdentifierOrStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterIdentifierOrString(s)
	}
}

func (s *IdentifierOrStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitIdentifierOrString(s)
	}
}

func (s *IdentifierOrStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitIdentifierOrString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) IdentifierOrString() (localctx IIdentifierOrStringContext) {
	localctx = NewIdentifierOrStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1026, DorisSQLParserParserRULE_identifierOrString)
	p.SetState(8165)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserACCESS, DorisSQLParserParserACTIVE, DorisSQLParserParserADMIN, DorisSQLParserParserADVISOR, DorisSQLParserParserAFTER, DorisSQLParserParserAGGREGATE, DorisSQLParserParserANTI, DorisSQLParserParserAPPLY, DorisSQLParserParserARRAY_AGG, DorisSQLParserParserARRAY_AGG_DISTINCT, DorisSQLParserParserASYNC, DorisSQLParserParserAUTHORS, DorisSQLParserParserAUTHENTICATION, DorisSQLParserParserAUTOMATED, DorisSQLParserParserAUTO_INCREMENT, DorisSQLParserParserAVG, DorisSQLParserParserBACKEND, DorisSQLParserParserBACKENDS, DorisSQLParserParserBACKUP, DorisSQLParserParserBASE, DorisSQLParserParserBASELINE, DorisSQLParserParserBEGIN, DorisSQLParserParserBINARY, DorisSQLParserParserBITMAP_UNION, DorisSQLParserParserBLACKHOLE, DorisSQLParserParserBLACKLIST, DorisSQLParserParserBODY, DorisSQLParserParserBOOLEAN, DorisSQLParserParserBRANCH, DorisSQLParserParserBROKER, DorisSQLParserParserBUCKETS, DorisSQLParserParserBUILTIN, DorisSQLParserParserCACHE, DorisSQLParserParserCANCEL, DorisSQLParserParserCAST, DorisSQLParserParserCATALOG, DorisSQLParserParserCATALOGS, DorisSQLParserParserCEIL, DorisSQLParserParserCHAIN, DorisSQLParserParserCHARSET, DorisSQLParserParserCLEAN, DorisSQLParserParserCLEAR, DorisSQLParserParserCLUSTER, DorisSQLParserParserCLUSTERS, DorisSQLParserParserCNGROUP, DorisSQLParserParserCNGROUPS, DorisSQLParserParserCOLLATION, DorisSQLParserParserCOLUMNS, DorisSQLParserParserCOMMENT, DorisSQLParserParserCOMMIT, DorisSQLParserParserCOMMITTED, DorisSQLParserParserCOMPACT, DorisSQLParserParserCOMPUTE, DorisSQLParserParserCONFIG, DorisSQLParserParserCONNECTION, DorisSQLParserParserCONSISTENT, DorisSQLParserParserCOSTS, DorisSQLParserParserCOUNT, DorisSQLParserParserCUME_DIST, DorisSQLParserParserCUMULATIVE, DorisSQLParserParserCURRENT, DorisSQLParserParserDATA, DorisSQLParserParserDATACACHE, DorisSQLParserParserDATE, DorisSQLParserParserDATETIME, DorisSQLParserParserDAY, DorisSQLParserParserDAYS, DorisSQLParserParserDEALLOCATE, DorisSQLParserParserDECOMMISSION, DorisSQLParserParserDIALECT, DorisSQLParserParserDICTIONARY, DorisSQLParserParserDICTIONARY_GET, DorisSQLParserParserDISABLE, DorisSQLParserParserDISTRIBUTED, DorisSQLParserParserDISTRIBUTION, DorisSQLParserParserDUPLICATE, DorisSQLParserParserDYNAMIC, DorisSQLParserParserENABLE, DorisSQLParserParserENCLOSE, DorisSQLParserParserEND, DorisSQLParserParserENGINE, DorisSQLParserParserENGINES, DorisSQLParserParserERRORS, DorisSQLParserParserESCAPE, DorisSQLParserParserEVENTS, DorisSQLParserParserEXCEPT, DorisSQLParserParserEXCLUDE, DorisSQLParserParserEXECUTE, DorisSQLParserParserEXPORT, DorisSQLParserParserEXTERNAL, DorisSQLParserParserEXTRACT, DorisSQLParserParserEVERY, DorisSQLParserParserFAILPOINT, DorisSQLParserParserFAILPOINTS, DorisSQLParserParserFIELDS, DorisSQLParserParserFILE, DorisSQLParserParserFILTER, DorisSQLParserParserFIRST, DorisSQLParserParserFLOOR, DorisSQLParserParserFN, DorisSQLParserParserFOLLOWING, DorisSQLParserParserFOLLOWER, DorisSQLParserParserFORMAT, DorisSQLParserParserFREE, DorisSQLParserParserFRONTEND, DorisSQLParserParserFRONTENDS, DorisSQLParserParserFUNCTIONS, DorisSQLParserParserGLOBAL, DorisSQLParserParserGRANTS, DorisSQLParserParserGROUP_CONCAT, DorisSQLParserParserHASH, DorisSQLParserParserHELP, DorisSQLParserParserHISTOGRAM, DorisSQLParserParserHLL_UNION, DorisSQLParserParserHOST, DorisSQLParserParserHOUR, DorisSQLParserParserHOURS, DorisSQLParserParserHUB, DorisSQLParserParserIDENTIFIED, DorisSQLParserParserIMPERSONATE, DorisSQLParserParserIMAGE, DorisSQLParserParserINACTIVE, DorisSQLParserParserINCREMENTAL, DorisSQLParserParserINDEXES, DorisSQLParserParserINSTALL, DorisSQLParserParserINTEGRATION, DorisSQLParserParserINTEGRATIONS, DorisSQLParserParserINTERMEDIATE, DorisSQLParserParserINTERVAL, DorisSQLParserParserOVERWRITE, DorisSQLParserParserISOLATION, DorisSQLParserParserJOB, DorisSQLParserParserLABEL, DorisSQLParserParserLAST, DorisSQLParserParserLESS, DorisSQLParserParserLEVEL, DorisSQLParserParserLIST, DorisSQLParserParserLOCAL, DorisSQLParserParserLOCATION, DorisSQLParserParserLOCATIONS, DorisSQLParserParserLOGS, DorisSQLParserParserLOGICAL, DorisSQLParserParserMANUAL, DorisSQLParserParserMAP, DorisSQLParserParserMAPPING, DorisSQLParserParserMAPPINGS, DorisSQLParserParserMASKING, DorisSQLParserParserMATCH, DorisSQLParserParserMATERIALIZED, DorisSQLParserParserMAX, DorisSQLParserParserMERGE, DorisSQLParserParserMIN, DorisSQLParserParserMINUTE, DorisSQLParserParserMINUTES, DorisSQLParserParserMINUS, DorisSQLParserParserMETA, DorisSQLParserParserMODE, DorisSQLParserParserMODIFY, DorisSQLParserParserMONTH, DorisSQLParserParserMULTIPLE, DorisSQLParserParserNAME, DorisSQLParserParserNAMES, DorisSQLParserParserNEGATIVE, DorisSQLParserParserNGRAMBF, DorisSQLParserParserNO, DorisSQLParserParserNODE, DorisSQLParserParserNODES, DorisSQLParserParserNONE, DorisSQLParserParserNULLS, DorisSQLParserParserNUMBER, DorisSQLParserParserNUMERIC, DorisSQLParserParserOBSERVER, DorisSQLParserParserOF, DorisSQLParserParserOFF, DorisSQLParserParserOFFSET, DorisSQLParserParserONLY, DorisSQLParserParserOPEN, DorisSQLParserParserOPERATE, DorisSQLParserParserOPTIMIZER, DorisSQLParserParserOPTION, DorisSQLParserParserPARTITIONS, DorisSQLParserParserPASSWORD, DorisSQLParserParserPATH, DorisSQLParserParserPAUSE, DorisSQLParserParserPENDING, DorisSQLParserParserPERCENT_RANK, DorisSQLParserParserPERCENTILE_UNION, DorisSQLParserParserPLAN, DorisSQLParserParserPLUGIN, DorisSQLParserParserPLUGINS, DorisSQLParserParserPIPE, DorisSQLParserParserPIPES, DorisSQLParserParserPIVOT, DorisSQLParserParserPOLICY, DorisSQLParserParserPOLICIES, DorisSQLParserParserPRECEDING, DorisSQLParserParserPREDICATE, DorisSQLParserParserPRIORITY, DorisSQLParserParserPRIVILEGES, DorisSQLParserParserPROBABILITY, DorisSQLParserParserPROC, DorisSQLParserParserPROCESSLIST, DorisSQLParserParserPROFILE, DorisSQLParserParserPROFILELIST, DorisSQLParserParserPROPERTIES, DorisSQLParserParserPROPERTY, DorisSQLParserParserPROVIDER, DorisSQLParserParserPROVIDERS, DorisSQLParserParserQUALIFY, DorisSQLParserParserQUARTER, DorisSQLParserParserQUERY, DorisSQLParserParserQUERIES, DorisSQLParserParserQUEUE, DorisSQLParserParserQUOTA, DorisSQLParserParserRANDOM, DorisSQLParserParserRANK, DorisSQLParserParserREASON, DorisSQLParserParserRECOVER, DorisSQLParserParserREFRESH, DorisSQLParserParserREWRITE, DorisSQLParserParserREMOVE, DorisSQLParserParserREPAIR, DorisSQLParserParserREPEATABLE, DorisSQLParserParserREPLACE_IF_NOT_NULL, DorisSQLParserParserREPLICA, DorisSQLParserParserREPOSITORY, DorisSQLParserParserREPOSITORIES, DorisSQLParserParserRESOURCE, DorisSQLParserParserRESOURCES, DorisSQLParserParserRESTORE, DorisSQLParserParserRESUME, DorisSQLParserParserRETAIN, DorisSQLParserParserRETENTION, DorisSQLParserParserRETURNS, DorisSQLParserParserRETRY, DorisSQLParserParserREVERT, DorisSQLParserParserROLE, DorisSQLParserParserROLES, DorisSQLParserParserROLLBACK, DorisSQLParserParserROLLUP, DorisSQLParserParserROUTINE, DorisSQLParserParserROW, DorisSQLParserParserRULE, DorisSQLParserParserRULES, DorisSQLParserParserRUNNING, DorisSQLParserParserSAMPLE, DorisSQLParserParserSCHEDULE, DorisSQLParserParserSCHEDULER, DorisSQLParserParserSECOND, DorisSQLParserParserSECURITY, DorisSQLParserParserSEMI, DorisSQLParserParserSEPARATOR, DorisSQLParserParserSERIALIZABLE, DorisSQLParserParserSESSION, DorisSQLParserParserSETS, DorisSQLParserParserSIGNED, DorisSQLParserParserSKIP_HEADER, DorisSQLParserParserSNAPSHOT, DorisSQLParserParserSNAPSHOTS, DorisSQLParserParserSQLBLACKLIST, DorisSQLParserParserSTART, DorisSQLParserParserSTATS, DorisSQLParserParserSTATUS, DorisSQLParserParserSTOP, DorisSQLParserParserSTORAGE, DorisSQLParserParserSTREAM, DorisSQLParserParserSTRING, DorisSQLParserParserSUBMIT, DorisSQLParserParserSUM, DorisSQLParserParserSUSPEND, DorisSQLParserParserSYNC, DorisSQLParserParserSYSTEM_TIME, DorisSQLParserParserSWAP, DorisSQLParserParserSTRUCT, DorisSQLParserParserTABLES, DorisSQLParserParserTABLET, DorisSQLParserParserTABLETS, DorisSQLParserParserTAG, DorisSQLParserParserTASK, DorisSQLParserParserTEMPORARY, DorisSQLParserParserTHAN, DorisSQLParserParserTIME, DorisSQLParserParserTIMES, DorisSQLParserParserTIMESTAMP, DorisSQLParserParserTIMESTAMPADD, DorisSQLParserParserTIMESTAMPDIFF, DorisSQLParserParserTRANSACTION, DorisSQLParserParserTRANSLATE, DorisSQLParserParserTRACE, DorisSQLParserParserTRIGGERS, DorisSQLParserParserTRIM_SPACE, DorisSQLParserParserTRUNCATE, DorisSQLParserParserTYPE, DorisSQLParserParserTYPES, DorisSQLParserParserUNBOUNDED, DorisSQLParserParserUNCOMMITTED, DorisSQLParserParserUNINSTALL, DorisSQLParserParserUNSET, DorisSQLParserParserUSAGE, DorisSQLParserParserUSER, DorisSQLParserParserUSERS, DorisSQLParserParserVALUE, DorisSQLParserParserVARBINARY, DorisSQLParserParserVARIABLES, DorisSQLParserParserVECTOR, DorisSQLParserParserVERBOSE, DorisSQLParserParserVERSION, DorisSQLParserParserVIEW, DorisSQLParserParserVIEWS, DorisSQLParserParserVOLUME, DorisSQLParserParserVOLUMES, DorisSQLParserParserWAREHOUSE, DorisSQLParserParserWAREHOUSES, DorisSQLParserParserWARNINGS, DorisSQLParserParserWEEK, DorisSQLParserParserWHITELIST, DorisSQLParserParserWORK, DorisSQLParserParserWRITE, DorisSQLParserParserYEAR, DorisSQLParserParserLOCK, DorisSQLParserParserUNLOCK, DorisSQLParserParserLOW_PRIORITY, DorisSQLParserParserDISK, DorisSQLParserParserBEFORE, DorisSQLParserParserFIELD, DorisSQLParserParserPERSISTENT, DorisSQLParserParserARRAY_ELEMENT, DorisSQLParserParserLETTER_IDENTIFIER, DorisSQLParserParserDIGIT_IDENTIFIER, DorisSQLParserParserBACKQUOTED_IDENTIFIER, DorisSQLParserParserDOTDOTDOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8163)
			p.Identifier()
		}

	case DorisSQLParserParserSINGLE_QUOTED_TEXT, DorisSQLParserParserDOUBLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8164)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrStringListContext is an interface to support dynamic dispatch.
type IIdentifierOrStringListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext

	// IsIdentifierOrStringListContext differentiates from other interfaces.
	IsIdentifierOrStringListContext()
}

type IdentifierOrStringListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrStringListContext() *IdentifierOrStringListContext {
	var p = new(IdentifierOrStringListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_identifierOrStringList
	return p
}

func InitEmptyIdentifierOrStringListContext(p *IdentifierOrStringListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_identifierOrStringList
}

func (*IdentifierOrStringListContext) IsIdentifierOrStringListContext() {}

func NewIdentifierOrStringListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrStringListContext {
	var p = new(IdentifierOrStringListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_identifierOrStringList

	return p
}

func (s *IdentifierOrStringListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrStringListContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierOrStringListContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *IdentifierOrStringListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrStringListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrStringListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterIdentifierOrStringList(s)
	}
}

func (s *IdentifierOrStringListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitIdentifierOrStringList(s)
	}
}

func (s *IdentifierOrStringListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitIdentifierOrStringList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) IdentifierOrStringList() (localctx IIdentifierOrStringListContext) {
	localctx = NewIdentifierOrStringListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1028, DorisSQLParserParserRULE_identifierOrStringList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8167)
		p.IdentifierOrString()
	}
	p.SetState(8172)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(8168)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8169)
			p.IdentifierOrString()
		}

		p.SetState(8174)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrStringOrStarContext is an interface to support dynamic dispatch.
type IIdentifierOrStringOrStarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASTERISK_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	String_() IStringContext

	// IsIdentifierOrStringOrStarContext differentiates from other interfaces.
	IsIdentifierOrStringOrStarContext()
}

type IdentifierOrStringOrStarContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrStringOrStarContext() *IdentifierOrStringOrStarContext {
	var p = new(IdentifierOrStringOrStarContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_identifierOrStringOrStar
	return p
}

func InitEmptyIdentifierOrStringOrStarContext(p *IdentifierOrStringOrStarContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_identifierOrStringOrStar
}

func (*IdentifierOrStringOrStarContext) IsIdentifierOrStringOrStarContext() {}

func NewIdentifierOrStringOrStarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrStringOrStarContext {
	var p = new(IdentifierOrStringOrStarContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_identifierOrStringOrStar

	return p
}

func (s *IdentifierOrStringOrStarContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrStringOrStarContext) ASTERISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserASTERISK_SYMBOL, 0)
}

func (s *IdentifierOrStringOrStarContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierOrStringOrStarContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *IdentifierOrStringOrStarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrStringOrStarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrStringOrStarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterIdentifierOrStringOrStar(s)
	}
}

func (s *IdentifierOrStringOrStarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitIdentifierOrStringOrStar(s)
	}
}

func (s *IdentifierOrStringOrStarContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitIdentifierOrStringOrStar(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) IdentifierOrStringOrStar() (localctx IIdentifierOrStringOrStarContext) {
	localctx = NewIdentifierOrStringOrStarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1030, DorisSQLParserParserRULE_identifierOrStringOrStar)
	p.SetState(8178)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserASTERISK_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8175)
			p.Match(DorisSQLParserParserASTERISK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserACCESS, DorisSQLParserParserACTIVE, DorisSQLParserParserADMIN, DorisSQLParserParserADVISOR, DorisSQLParserParserAFTER, DorisSQLParserParserAGGREGATE, DorisSQLParserParserANTI, DorisSQLParserParserAPPLY, DorisSQLParserParserARRAY_AGG, DorisSQLParserParserARRAY_AGG_DISTINCT, DorisSQLParserParserASYNC, DorisSQLParserParserAUTHORS, DorisSQLParserParserAUTHENTICATION, DorisSQLParserParserAUTOMATED, DorisSQLParserParserAUTO_INCREMENT, DorisSQLParserParserAVG, DorisSQLParserParserBACKEND, DorisSQLParserParserBACKENDS, DorisSQLParserParserBACKUP, DorisSQLParserParserBASE, DorisSQLParserParserBASELINE, DorisSQLParserParserBEGIN, DorisSQLParserParserBINARY, DorisSQLParserParserBITMAP_UNION, DorisSQLParserParserBLACKHOLE, DorisSQLParserParserBLACKLIST, DorisSQLParserParserBODY, DorisSQLParserParserBOOLEAN, DorisSQLParserParserBRANCH, DorisSQLParserParserBROKER, DorisSQLParserParserBUCKETS, DorisSQLParserParserBUILTIN, DorisSQLParserParserCACHE, DorisSQLParserParserCANCEL, DorisSQLParserParserCAST, DorisSQLParserParserCATALOG, DorisSQLParserParserCATALOGS, DorisSQLParserParserCEIL, DorisSQLParserParserCHAIN, DorisSQLParserParserCHARSET, DorisSQLParserParserCLEAN, DorisSQLParserParserCLEAR, DorisSQLParserParserCLUSTER, DorisSQLParserParserCLUSTERS, DorisSQLParserParserCNGROUP, DorisSQLParserParserCNGROUPS, DorisSQLParserParserCOLLATION, DorisSQLParserParserCOLUMNS, DorisSQLParserParserCOMMENT, DorisSQLParserParserCOMMIT, DorisSQLParserParserCOMMITTED, DorisSQLParserParserCOMPACT, DorisSQLParserParserCOMPUTE, DorisSQLParserParserCONFIG, DorisSQLParserParserCONNECTION, DorisSQLParserParserCONSISTENT, DorisSQLParserParserCOSTS, DorisSQLParserParserCOUNT, DorisSQLParserParserCUME_DIST, DorisSQLParserParserCUMULATIVE, DorisSQLParserParserCURRENT, DorisSQLParserParserDATA, DorisSQLParserParserDATACACHE, DorisSQLParserParserDATE, DorisSQLParserParserDATETIME, DorisSQLParserParserDAY, DorisSQLParserParserDAYS, DorisSQLParserParserDEALLOCATE, DorisSQLParserParserDECOMMISSION, DorisSQLParserParserDIALECT, DorisSQLParserParserDICTIONARY, DorisSQLParserParserDICTIONARY_GET, DorisSQLParserParserDISABLE, DorisSQLParserParserDISTRIBUTED, DorisSQLParserParserDISTRIBUTION, DorisSQLParserParserDUPLICATE, DorisSQLParserParserDYNAMIC, DorisSQLParserParserENABLE, DorisSQLParserParserENCLOSE, DorisSQLParserParserEND, DorisSQLParserParserENGINE, DorisSQLParserParserENGINES, DorisSQLParserParserERRORS, DorisSQLParserParserESCAPE, DorisSQLParserParserEVENTS, DorisSQLParserParserEXCEPT, DorisSQLParserParserEXCLUDE, DorisSQLParserParserEXECUTE, DorisSQLParserParserEXPORT, DorisSQLParserParserEXTERNAL, DorisSQLParserParserEXTRACT, DorisSQLParserParserEVERY, DorisSQLParserParserFAILPOINT, DorisSQLParserParserFAILPOINTS, DorisSQLParserParserFIELDS, DorisSQLParserParserFILE, DorisSQLParserParserFILTER, DorisSQLParserParserFIRST, DorisSQLParserParserFLOOR, DorisSQLParserParserFN, DorisSQLParserParserFOLLOWING, DorisSQLParserParserFOLLOWER, DorisSQLParserParserFORMAT, DorisSQLParserParserFREE, DorisSQLParserParserFRONTEND, DorisSQLParserParserFRONTENDS, DorisSQLParserParserFUNCTIONS, DorisSQLParserParserGLOBAL, DorisSQLParserParserGRANTS, DorisSQLParserParserGROUP_CONCAT, DorisSQLParserParserHASH, DorisSQLParserParserHELP, DorisSQLParserParserHISTOGRAM, DorisSQLParserParserHLL_UNION, DorisSQLParserParserHOST, DorisSQLParserParserHOUR, DorisSQLParserParserHOURS, DorisSQLParserParserHUB, DorisSQLParserParserIDENTIFIED, DorisSQLParserParserIMPERSONATE, DorisSQLParserParserIMAGE, DorisSQLParserParserINACTIVE, DorisSQLParserParserINCREMENTAL, DorisSQLParserParserINDEXES, DorisSQLParserParserINSTALL, DorisSQLParserParserINTEGRATION, DorisSQLParserParserINTEGRATIONS, DorisSQLParserParserINTERMEDIATE, DorisSQLParserParserINTERVAL, DorisSQLParserParserOVERWRITE, DorisSQLParserParserISOLATION, DorisSQLParserParserJOB, DorisSQLParserParserLABEL, DorisSQLParserParserLAST, DorisSQLParserParserLESS, DorisSQLParserParserLEVEL, DorisSQLParserParserLIST, DorisSQLParserParserLOCAL, DorisSQLParserParserLOCATION, DorisSQLParserParserLOCATIONS, DorisSQLParserParserLOGS, DorisSQLParserParserLOGICAL, DorisSQLParserParserMANUAL, DorisSQLParserParserMAP, DorisSQLParserParserMAPPING, DorisSQLParserParserMAPPINGS, DorisSQLParserParserMASKING, DorisSQLParserParserMATCH, DorisSQLParserParserMATERIALIZED, DorisSQLParserParserMAX, DorisSQLParserParserMERGE, DorisSQLParserParserMIN, DorisSQLParserParserMINUTE, DorisSQLParserParserMINUTES, DorisSQLParserParserMINUS, DorisSQLParserParserMETA, DorisSQLParserParserMODE, DorisSQLParserParserMODIFY, DorisSQLParserParserMONTH, DorisSQLParserParserMULTIPLE, DorisSQLParserParserNAME, DorisSQLParserParserNAMES, DorisSQLParserParserNEGATIVE, DorisSQLParserParserNGRAMBF, DorisSQLParserParserNO, DorisSQLParserParserNODE, DorisSQLParserParserNODES, DorisSQLParserParserNONE, DorisSQLParserParserNULLS, DorisSQLParserParserNUMBER, DorisSQLParserParserNUMERIC, DorisSQLParserParserOBSERVER, DorisSQLParserParserOF, DorisSQLParserParserOFF, DorisSQLParserParserOFFSET, DorisSQLParserParserONLY, DorisSQLParserParserOPEN, DorisSQLParserParserOPERATE, DorisSQLParserParserOPTIMIZER, DorisSQLParserParserOPTION, DorisSQLParserParserPARTITIONS, DorisSQLParserParserPASSWORD, DorisSQLParserParserPATH, DorisSQLParserParserPAUSE, DorisSQLParserParserPENDING, DorisSQLParserParserPERCENT_RANK, DorisSQLParserParserPERCENTILE_UNION, DorisSQLParserParserPLAN, DorisSQLParserParserPLUGIN, DorisSQLParserParserPLUGINS, DorisSQLParserParserPIPE, DorisSQLParserParserPIPES, DorisSQLParserParserPIVOT, DorisSQLParserParserPOLICY, DorisSQLParserParserPOLICIES, DorisSQLParserParserPRECEDING, DorisSQLParserParserPREDICATE, DorisSQLParserParserPRIORITY, DorisSQLParserParserPRIVILEGES, DorisSQLParserParserPROBABILITY, DorisSQLParserParserPROC, DorisSQLParserParserPROCESSLIST, DorisSQLParserParserPROFILE, DorisSQLParserParserPROFILELIST, DorisSQLParserParserPROPERTIES, DorisSQLParserParserPROPERTY, DorisSQLParserParserPROVIDER, DorisSQLParserParserPROVIDERS, DorisSQLParserParserQUALIFY, DorisSQLParserParserQUARTER, DorisSQLParserParserQUERY, DorisSQLParserParserQUERIES, DorisSQLParserParserQUEUE, DorisSQLParserParserQUOTA, DorisSQLParserParserRANDOM, DorisSQLParserParserRANK, DorisSQLParserParserREASON, DorisSQLParserParserRECOVER, DorisSQLParserParserREFRESH, DorisSQLParserParserREWRITE, DorisSQLParserParserREMOVE, DorisSQLParserParserREPAIR, DorisSQLParserParserREPEATABLE, DorisSQLParserParserREPLACE_IF_NOT_NULL, DorisSQLParserParserREPLICA, DorisSQLParserParserREPOSITORY, DorisSQLParserParserREPOSITORIES, DorisSQLParserParserRESOURCE, DorisSQLParserParserRESOURCES, DorisSQLParserParserRESTORE, DorisSQLParserParserRESUME, DorisSQLParserParserRETAIN, DorisSQLParserParserRETENTION, DorisSQLParserParserRETURNS, DorisSQLParserParserRETRY, DorisSQLParserParserREVERT, DorisSQLParserParserROLE, DorisSQLParserParserROLES, DorisSQLParserParserROLLBACK, DorisSQLParserParserROLLUP, DorisSQLParserParserROUTINE, DorisSQLParserParserROW, DorisSQLParserParserRULE, DorisSQLParserParserRULES, DorisSQLParserParserRUNNING, DorisSQLParserParserSAMPLE, DorisSQLParserParserSCHEDULE, DorisSQLParserParserSCHEDULER, DorisSQLParserParserSECOND, DorisSQLParserParserSECURITY, DorisSQLParserParserSEMI, DorisSQLParserParserSEPARATOR, DorisSQLParserParserSERIALIZABLE, DorisSQLParserParserSESSION, DorisSQLParserParserSETS, DorisSQLParserParserSIGNED, DorisSQLParserParserSKIP_HEADER, DorisSQLParserParserSNAPSHOT, DorisSQLParserParserSNAPSHOTS, DorisSQLParserParserSQLBLACKLIST, DorisSQLParserParserSTART, DorisSQLParserParserSTATS, DorisSQLParserParserSTATUS, DorisSQLParserParserSTOP, DorisSQLParserParserSTORAGE, DorisSQLParserParserSTREAM, DorisSQLParserParserSTRING, DorisSQLParserParserSUBMIT, DorisSQLParserParserSUM, DorisSQLParserParserSUSPEND, DorisSQLParserParserSYNC, DorisSQLParserParserSYSTEM_TIME, DorisSQLParserParserSWAP, DorisSQLParserParserSTRUCT, DorisSQLParserParserTABLES, DorisSQLParserParserTABLET, DorisSQLParserParserTABLETS, DorisSQLParserParserTAG, DorisSQLParserParserTASK, DorisSQLParserParserTEMPORARY, DorisSQLParserParserTHAN, DorisSQLParserParserTIME, DorisSQLParserParserTIMES, DorisSQLParserParserTIMESTAMP, DorisSQLParserParserTIMESTAMPADD, DorisSQLParserParserTIMESTAMPDIFF, DorisSQLParserParserTRANSACTION, DorisSQLParserParserTRANSLATE, DorisSQLParserParserTRACE, DorisSQLParserParserTRIGGERS, DorisSQLParserParserTRIM_SPACE, DorisSQLParserParserTRUNCATE, DorisSQLParserParserTYPE, DorisSQLParserParserTYPES, DorisSQLParserParserUNBOUNDED, DorisSQLParserParserUNCOMMITTED, DorisSQLParserParserUNINSTALL, DorisSQLParserParserUNSET, DorisSQLParserParserUSAGE, DorisSQLParserParserUSER, DorisSQLParserParserUSERS, DorisSQLParserParserVALUE, DorisSQLParserParserVARBINARY, DorisSQLParserParserVARIABLES, DorisSQLParserParserVECTOR, DorisSQLParserParserVERBOSE, DorisSQLParserParserVERSION, DorisSQLParserParserVIEW, DorisSQLParserParserVIEWS, DorisSQLParserParserVOLUME, DorisSQLParserParserVOLUMES, DorisSQLParserParserWAREHOUSE, DorisSQLParserParserWAREHOUSES, DorisSQLParserParserWARNINGS, DorisSQLParserParserWEEK, DorisSQLParserParserWHITELIST, DorisSQLParserParserWORK, DorisSQLParserParserWRITE, DorisSQLParserParserYEAR, DorisSQLParserParserLOCK, DorisSQLParserParserUNLOCK, DorisSQLParserParserLOW_PRIORITY, DorisSQLParserParserDISK, DorisSQLParserParserBEFORE, DorisSQLParserParserFIELD, DorisSQLParserParserPERSISTENT, DorisSQLParserParserARRAY_ELEMENT, DorisSQLParserParserLETTER_IDENTIFIER, DorisSQLParserParserDIGIT_IDENTIFIER, DorisSQLParserParserBACKQUOTED_IDENTIFIER, DorisSQLParserParserDOTDOTDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8176)
			p.Identifier()
		}

	case DorisSQLParserParserSINGLE_QUOTED_TEXT, DorisSQLParserParserDOUBLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8177)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserContext is an interface to support dynamic dispatch.
type IUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUserContext differentiates from other interfaces.
	IsUserContext()
}

type UserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserContext() *UserContext {
	var p = new(UserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_user
	return p
}

func InitEmptyUserContext(p *UserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_user
}

func (*UserContext) IsUserContext() {}

func NewUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserContext {
	var p = new(UserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_user

	return p
}

func (s *UserContext) GetParser() antlr.Parser { return s.parser }

func (s *UserContext) CopyAll(ctx *UserContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UserWithHostAndBlanketContext struct {
	UserContext
}

func NewUserWithHostAndBlanketContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserWithHostAndBlanketContext {
	var p = new(UserWithHostAndBlanketContext)

	InitEmptyUserContext(&p.UserContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserContext))

	return p
}

func (s *UserWithHostAndBlanketContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserWithHostAndBlanketContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *UserWithHostAndBlanketContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *UserWithHostAndBlanketContext) AT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAT, 0)
}

func (s *UserWithHostAndBlanketContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterUserWithHostAndBlanket(s)
	}
}

func (s *UserWithHostAndBlanketContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitUserWithHostAndBlanket(s)
	}
}

func (s *UserWithHostAndBlanketContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitUserWithHostAndBlanket(s)

	default:
		return t.VisitChildren(s)
	}
}

type UserWithHostContext struct {
	UserContext
}

func NewUserWithHostContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserWithHostContext {
	var p = new(UserWithHostContext)

	InitEmptyUserContext(&p.UserContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserContext))

	return p
}

func (s *UserWithHostContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserWithHostContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *UserWithHostContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *UserWithHostContext) AT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAT, 0)
}

func (s *UserWithHostContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterUserWithHost(s)
	}
}

func (s *UserWithHostContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitUserWithHost(s)
	}
}

func (s *UserWithHostContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitUserWithHost(s)

	default:
		return t.VisitChildren(s)
	}
}

type UserWithoutHostContext struct {
	UserContext
}

func NewUserWithoutHostContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserWithoutHostContext {
	var p = new(UserWithoutHostContext)

	InitEmptyUserContext(&p.UserContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserContext))

	return p
}

func (s *UserWithoutHostContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserWithoutHostContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *UserWithoutHostContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterUserWithoutHost(s)
	}
}

func (s *UserWithoutHostContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitUserWithoutHost(s)
	}
}

func (s *UserWithoutHostContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitUserWithoutHost(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) User() (localctx IUserContext) {
	localctx = NewUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1032, DorisSQLParserParserRULE_user)
	p.SetState(8191)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 972, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUserWithoutHostContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8180)
			p.IdentifierOrString()
		}

	case 2:
		localctx = NewUserWithHostContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8181)
			p.IdentifierOrString()
		}
		{
			p.SetState(8182)
			p.Match(DorisSQLParserParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8183)
			p.IdentifierOrString()
		}

	case 3:
		localctx = NewUserWithHostAndBlanketContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8185)
			p.IdentifierOrString()
		}
		{
			p.SetState(8186)
			p.Match(DorisSQLParserParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8187)
			p.Match(DorisSQLParserParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8188)
			p.IdentifierOrString()
		}
		{
			p.SetState(8189)
			p.Match(DorisSQLParserParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentContext is an interface to support dynamic dispatch.
type IAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQ() antlr.TerminalNode
	ExpressionOrDefault() IExpressionOrDefaultContext

	// IsAssignmentContext differentiates from other interfaces.
	IsAssignmentContext()
}

type AssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentContext() *AssignmentContext {
	var p = new(AssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_assignment
	return p
}

func InitEmptyAssignmentContext(p *AssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_assignment
}

func (*AssignmentContext) IsAssignmentContext() {}

func NewAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentContext {
	var p = new(AssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_assignment

	return p
}

func (s *AssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEQ, 0)
}

func (s *AssignmentContext) ExpressionOrDefault() IExpressionOrDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionOrDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionOrDefaultContext)
}

func (s *AssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAssignment(s)
	}
}

func (s *AssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAssignment(s)
	}
}

func (s *AssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Assignment() (localctx IAssignmentContext) {
	localctx = NewAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1034, DorisSQLParserParserRULE_assignment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8193)
		p.Identifier()
	}
	{
		p.SetState(8194)
		p.Match(DorisSQLParserParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8195)
		p.ExpressionOrDefault()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentListContext is an interface to support dynamic dispatch.
type IAssignmentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAssignment() []IAssignmentContext
	Assignment(i int) IAssignmentContext

	// IsAssignmentListContext differentiates from other interfaces.
	IsAssignmentListContext()
}

type AssignmentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentListContext() *AssignmentListContext {
	var p = new(AssignmentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_assignmentList
	return p
}

func InitEmptyAssignmentListContext(p *AssignmentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_assignmentList
}

func (*AssignmentListContext) IsAssignmentListContext() {}

func NewAssignmentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentListContext {
	var p = new(AssignmentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_assignmentList

	return p
}

func (s *AssignmentListContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentListContext) AllAssignment() []IAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentContext); ok {
			tst[i] = t.(IAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentListContext) Assignment(i int) IAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *AssignmentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterAssignmentList(s)
	}
}

func (s *AssignmentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitAssignmentList(s)
	}
}

func (s *AssignmentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitAssignmentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) AssignmentList() (localctx IAssignmentListContext) {
	localctx = NewAssignmentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1036, DorisSQLParserParserRULE_assignmentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8197)
		p.Assignment()
	}
	p.SetState(8202)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisSQLParserParserT__2 {
		{
			p.SetState(8198)
			p.Match(DorisSQLParserParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8199)
			p.Assignment()
		}

		p.SetState(8204)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_number
	return p
}

func InitEmptyNumberContext(p *NumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_number
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) CopyAll(ctx *NumberContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DecimalValueContext struct {
	NumberContext
}

func NewDecimalValueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecimalValueContext {
	var p = new(DecimalValueContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *DecimalValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalValueContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDECIMAL_VALUE, 0)
}

func (s *DecimalValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDecimalValue(s)
	}
}

func (s *DecimalValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDecimalValue(s)
	}
}

func (s *DecimalValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDecimalValue(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntegerValueContext struct {
	NumberContext
}

func NewIntegerValueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerValueContext {
	var p = new(IntegerValueContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *IntegerValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerValueContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGER_VALUE, 0)
}

func (s *IntegerValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterIntegerValue(s)
	}
}

func (s *IntegerValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitIntegerValue(s)
	}
}

func (s *IntegerValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitIntegerValue(s)

	default:
		return t.VisitChildren(s)
	}
}

type DoubleValueContext struct {
	NumberContext
}

func NewDoubleValueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoubleValueContext {
	var p = new(DoubleValueContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *DoubleValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoubleValueContext) DOUBLE_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDOUBLE_VALUE, 0)
}

func (s *DoubleValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterDoubleValue(s)
	}
}

func (s *DoubleValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitDoubleValue(s)
	}
}

func (s *DoubleValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitDoubleValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1038, DorisSQLParserParserRULE_number)
	p.SetState(8208)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisSQLParserParserDECIMAL_VALUE:
		localctx = NewDecimalValueContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8205)
			p.Match(DorisSQLParserParserDECIMAL_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserDOUBLE_VALUE:
		localctx = NewDoubleValueContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8206)
			p.Match(DorisSQLParserParserDOUBLE_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisSQLParserParserINTEGER_VALUE:
		localctx = NewIntegerValueContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8207)
			p.Match(DorisSQLParserParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonReservedContext is an interface to support dynamic dispatch.
type INonReservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACCESS() antlr.TerminalNode
	ACTIVE() antlr.TerminalNode
	ADVISOR() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	AGGREGATE() antlr.TerminalNode
	APPLY() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	AUTHORS() antlr.TerminalNode
	AVG() antlr.TerminalNode
	ADMIN() antlr.TerminalNode
	ANTI() antlr.TerminalNode
	AUTHENTICATION() antlr.TerminalNode
	AUTO_INCREMENT() antlr.TerminalNode
	AUTOMATED() antlr.TerminalNode
	ARRAY_AGG() antlr.TerminalNode
	ARRAY_AGG_DISTINCT() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	BACKENDS() antlr.TerminalNode
	BACKUP() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	BITMAP_UNION() antlr.TerminalNode
	BLACKLIST() antlr.TerminalNode
	BLACKHOLE() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	BODY() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	BRANCH() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	BUILTIN() antlr.TerminalNode
	BASE() antlr.TerminalNode
	BEFORE() antlr.TerminalNode
	BASELINE() antlr.TerminalNode
	CACHE() antlr.TerminalNode
	CAST() antlr.TerminalNode
	CANCEL() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	CATALOGS() antlr.TerminalNode
	CEIL() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CLEAN() antlr.TerminalNode
	CLEAR() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	CLUSTERS() antlr.TerminalNode
	CNGROUP() antlr.TerminalNode
	CNGROUPS() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	CUME_DIST() antlr.TerminalNode
	CUMULATIVE() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	COMPUTE() antlr.TerminalNode
	CONNECTION() antlr.TerminalNode
	CONSISTENT() antlr.TerminalNode
	COSTS() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	CONFIG() antlr.TerminalNode
	COMPACT() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATACACHE() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	DAY() antlr.TerminalNode
	DAYS() antlr.TerminalNode
	DECOMMISSION() antlr.TerminalNode
	DIALECT() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	DISK() antlr.TerminalNode
	DISTRIBUTION() antlr.TerminalNode
	DUPLICATE() antlr.TerminalNode
	DYNAMIC() antlr.TerminalNode
	DISTRIBUTED() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	DICTIONARY_GET() antlr.TerminalNode
	DEALLOCATE() antlr.TerminalNode
	ENABLE() antlr.TerminalNode
	END() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	ENGINES() antlr.TerminalNode
	ERRORS() antlr.TerminalNode
	EVENTS() antlr.TerminalNode
	EXECUTE() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	EXTRACT() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	ENCLOSE() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	FAILPOINT() antlr.TerminalNode
	FAILPOINTS() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	FILE() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	FLOOR() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	FN() antlr.TerminalNode
	FRONTEND() antlr.TerminalNode
	FRONTENDS() antlr.TerminalNode
	FOLLOWER() antlr.TerminalNode
	FREE() antlr.TerminalNode
	FUNCTIONS() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	GRANTS() antlr.TerminalNode
	GROUP_CONCAT() antlr.TerminalNode
	HASH() antlr.TerminalNode
	HISTOGRAM() antlr.TerminalNode
	HELP() antlr.TerminalNode
	HLL_UNION() antlr.TerminalNode
	HOST() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	HOURS() antlr.TerminalNode
	HUB() antlr.TerminalNode
	IDENTIFIED() antlr.TerminalNode
	IMAGE() antlr.TerminalNode
	IMPERSONATE() antlr.TerminalNode
	INACTIVE() antlr.TerminalNode
	INCREMENTAL() antlr.TerminalNode
	INDEXES() antlr.TerminalNode
	INSTALL() antlr.TerminalNode
	INTEGRATION() antlr.TerminalNode
	INTEGRATIONS() antlr.TerminalNode
	INTERMEDIATE() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	ISOLATION() antlr.TerminalNode
	JOB() antlr.TerminalNode
	LABEL() antlr.TerminalNode
	LAST() antlr.TerminalNode
	LESS() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	LIST() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	LOCATION() antlr.TerminalNode
	LOGS() antlr.TerminalNode
	LOGICAL() antlr.TerminalNode
	LOW_PRIORITY() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	LOCATIONS() antlr.TerminalNode
	MANUAL() antlr.TerminalNode
	MAP() antlr.TerminalNode
	MAPPING() antlr.TerminalNode
	MAPPINGS() antlr.TerminalNode
	MASKING() antlr.TerminalNode
	MATCH() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	MAX() antlr.TerminalNode
	META() antlr.TerminalNode
	MIN() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MINUTES() antlr.TerminalNode
	MODE() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	MULTIPLE() antlr.TerminalNode
	NAME() antlr.TerminalNode
	NAMES() antlr.TerminalNode
	NEGATIVE() antlr.TerminalNode
	NO() antlr.TerminalNode
	NODE() antlr.TerminalNode
	NODES() antlr.TerminalNode
	NONE() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	NUMERIC() antlr.TerminalNode
	OBSERVER() antlr.TerminalNode
	OF() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	OPTIMIZER() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	OPERATE() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	OVERWRITE() antlr.TerminalNode
	OFF() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	PATH() antlr.TerminalNode
	PAUSE() antlr.TerminalNode
	PENDING() antlr.TerminalNode
	PERCENTILE_UNION() antlr.TerminalNode
	PIVOT() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	PLUGINS() antlr.TerminalNode
	POLICY() antlr.TerminalNode
	POLICIES() antlr.TerminalNode
	PERCENT_RANK() antlr.TerminalNode
	PREDICATE() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	PRIORITY() antlr.TerminalNode
	PROC() antlr.TerminalNode
	PROCESSLIST() antlr.TerminalNode
	PROFILE() antlr.TerminalNode
	PROFILELIST() antlr.TerminalNode
	PROVIDER() antlr.TerminalNode
	PROVIDERS() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	PROBABILITY() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode
	PIPE() antlr.TerminalNode
	PIPES() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	QUERIES() antlr.TerminalNode
	QUEUE() antlr.TerminalNode
	QUOTA() antlr.TerminalNode
	QUALIFY() antlr.TerminalNode
	REASON() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	REWRITE() antlr.TerminalNode
	RANDOM() antlr.TerminalNode
	RANK() antlr.TerminalNode
	RECOVER() antlr.TerminalNode
	REFRESH() antlr.TerminalNode
	REPAIR() antlr.TerminalNode
	REPEATABLE() antlr.TerminalNode
	REPLACE_IF_NOT_NULL() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	REPOSITORY() antlr.TerminalNode
	REPOSITORIES() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	RESOURCES() antlr.TerminalNode
	RESTORE() antlr.TerminalNode
	RESUME() antlr.TerminalNode
	RETAIN() antlr.TerminalNode
	RETENTION() antlr.TerminalNode
	RETURNS() antlr.TerminalNode
	RETRY() antlr.TerminalNode
	REVERT() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	ROLES() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	ROW() antlr.TerminalNode
	RUNNING() antlr.TerminalNode
	RULE() antlr.TerminalNode
	RULES() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	SCHEDULER() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	SEPARATOR() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	SETS() antlr.TerminalNode
	SIGNED() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	SNAPSHOTS() antlr.TerminalNode
	SQLBLACKLIST() antlr.TerminalNode
	START() antlr.TerminalNode
	STREAM() antlr.TerminalNode
	SUM() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	STOP() antlr.TerminalNode
	SKIP_HEADER() antlr.TerminalNode
	SWAP() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	STRING() antlr.TerminalNode
	STRUCT() antlr.TerminalNode
	STATS() antlr.TerminalNode
	SUBMIT() antlr.TerminalNode
	SUSPEND() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	SYSTEM_TIME() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	TABLET() antlr.TerminalNode
	TABLETS() antlr.TerminalNode
	TAG() antlr.TerminalNode
	TASK() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	TIMESTAMPADD() antlr.TerminalNode
	TIMESTAMPDIFF() antlr.TerminalNode
	THAN() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMES() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	TRACE() antlr.TerminalNode
	TRANSLATE() antlr.TerminalNode
	TRIM_SPACE() antlr.TerminalNode
	TRIGGERS() antlr.TerminalNode
	TRUNCATE() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	TYPES() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	UNSET() antlr.TerminalNode
	UNINSTALL() antlr.TerminalNode
	USAGE() antlr.TerminalNode
	USER() antlr.TerminalNode
	USERS() antlr.TerminalNode
	UNLOCK() antlr.TerminalNode
	VALUE() antlr.TerminalNode
	VARBINARY() antlr.TerminalNode
	VARIABLES() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	VIEWS() antlr.TerminalNode
	VERBOSE() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	VOLUMES() antlr.TerminalNode
	WARNINGS() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	WHITELIST() antlr.TerminalNode
	WORK() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	WAREHOUSES() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	DOTDOTDOT() antlr.TerminalNode
	NGRAMBF() antlr.TerminalNode
	VECTOR() antlr.TerminalNode
	FIELD() antlr.TerminalNode
	ARRAY_ELEMENT() antlr.TerminalNode
	PERSISTENT() antlr.TerminalNode
	EXCLUDE() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode

	// IsNonReservedContext differentiates from other interfaces.
	IsNonReservedContext()
}

type NonReservedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedContext() *NonReservedContext {
	var p = new(NonReservedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_nonReserved
	return p
}

func InitEmptyNonReservedContext(p *NonReservedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisSQLParserParserRULE_nonReserved
}

func (*NonReservedContext) IsNonReservedContext() {}

func NewNonReservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedContext {
	var p = new(NonReservedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisSQLParserParserRULE_nonReserved

	return p
}

func (s *NonReservedContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedContext) ACCESS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserACCESS, 0)
}

func (s *NonReservedContext) ACTIVE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserACTIVE, 0)
}

func (s *NonReservedContext) ADVISOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADVISOR, 0)
}

func (s *NonReservedContext) AFTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAFTER, 0)
}

func (s *NonReservedContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAGGREGATE, 0)
}

func (s *NonReservedContext) APPLY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAPPLY, 0)
}

func (s *NonReservedContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserASYNC, 0)
}

func (s *NonReservedContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAUTHORS, 0)
}

func (s *NonReservedContext) AVG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAVG, 0)
}

func (s *NonReservedContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserADMIN, 0)
}

func (s *NonReservedContext) ANTI() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserANTI, 0)
}

func (s *NonReservedContext) AUTHENTICATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAUTHENTICATION, 0)
}

func (s *NonReservedContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAUTO_INCREMENT, 0)
}

func (s *NonReservedContext) AUTOMATED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserAUTOMATED, 0)
}

func (s *NonReservedContext) ARRAY_AGG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserARRAY_AGG, 0)
}

func (s *NonReservedContext) ARRAY_AGG_DISTINCT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserARRAY_AGG_DISTINCT, 0)
}

func (s *NonReservedContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBACKEND, 0)
}

func (s *NonReservedContext) BACKENDS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBACKENDS, 0)
}

func (s *NonReservedContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBACKUP, 0)
}

func (s *NonReservedContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBEGIN, 0)
}

func (s *NonReservedContext) BITMAP_UNION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBITMAP_UNION, 0)
}

func (s *NonReservedContext) BLACKLIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBLACKLIST, 0)
}

func (s *NonReservedContext) BLACKHOLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBLACKHOLE, 0)
}

func (s *NonReservedContext) BINARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBINARY, 0)
}

func (s *NonReservedContext) BODY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBODY, 0)
}

func (s *NonReservedContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBOOLEAN, 0)
}

func (s *NonReservedContext) BRANCH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBRANCH, 0)
}

func (s *NonReservedContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBROKER, 0)
}

func (s *NonReservedContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBUCKETS, 0)
}

func (s *NonReservedContext) BUILTIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBUILTIN, 0)
}

func (s *NonReservedContext) BASE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBASE, 0)
}

func (s *NonReservedContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBEFORE, 0)
}

func (s *NonReservedContext) BASELINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserBASELINE, 0)
}

func (s *NonReservedContext) CACHE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCACHE, 0)
}

func (s *NonReservedContext) CAST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCAST, 0)
}

func (s *NonReservedContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCANCEL, 0)
}

func (s *NonReservedContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCATALOG, 0)
}

func (s *NonReservedContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCATALOGS, 0)
}

func (s *NonReservedContext) CEIL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCEIL, 0)
}

func (s *NonReservedContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCHAIN, 0)
}

func (s *NonReservedContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCHARSET, 0)
}

func (s *NonReservedContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCLEAN, 0)
}

func (s *NonReservedContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCLEAR, 0)
}

func (s *NonReservedContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCLUSTER, 0)
}

func (s *NonReservedContext) CLUSTERS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCLUSTERS, 0)
}

func (s *NonReservedContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCNGROUP, 0)
}

func (s *NonReservedContext) CNGROUPS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCNGROUPS, 0)
}

func (s *NonReservedContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCURRENT, 0)
}

func (s *NonReservedContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLLATION, 0)
}

func (s *NonReservedContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOLUMNS, 0)
}

func (s *NonReservedContext) CUME_DIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCUME_DIST, 0)
}

func (s *NonReservedContext) CUMULATIVE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCUMULATIVE, 0)
}

func (s *NonReservedContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOMMENT, 0)
}

func (s *NonReservedContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOMMIT, 0)
}

func (s *NonReservedContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOMMITTED, 0)
}

func (s *NonReservedContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOMPUTE, 0)
}

func (s *NonReservedContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCONNECTION, 0)
}

func (s *NonReservedContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCONSISTENT, 0)
}

func (s *NonReservedContext) COSTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOSTS, 0)
}

func (s *NonReservedContext) COUNT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOUNT, 0)
}

func (s *NonReservedContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCONFIG, 0)
}

func (s *NonReservedContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserCOMPACT, 0)
}

func (s *NonReservedContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATA, 0)
}

func (s *NonReservedContext) DATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATE, 0)
}

func (s *NonReservedContext) DATACACHE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATACACHE, 0)
}

func (s *NonReservedContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDATETIME, 0)
}

func (s *NonReservedContext) DAY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDAY, 0)
}

func (s *NonReservedContext) DAYS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDAYS, 0)
}

func (s *NonReservedContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDECOMMISSION, 0)
}

func (s *NonReservedContext) DIALECT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDIALECT, 0)
}

func (s *NonReservedContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDISABLE, 0)
}

func (s *NonReservedContext) DISK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDISK, 0)
}

func (s *NonReservedContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDISTRIBUTION, 0)
}

func (s *NonReservedContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDUPLICATE, 0)
}

func (s *NonReservedContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDYNAMIC, 0)
}

func (s *NonReservedContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDISTRIBUTED, 0)
}

func (s *NonReservedContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDICTIONARY, 0)
}

func (s *NonReservedContext) DICTIONARY_GET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDICTIONARY_GET, 0)
}

func (s *NonReservedContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDEALLOCATE, 0)
}

func (s *NonReservedContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserENABLE, 0)
}

func (s *NonReservedContext) END() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEND, 0)
}

func (s *NonReservedContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserENGINE, 0)
}

func (s *NonReservedContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserENGINES, 0)
}

func (s *NonReservedContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserERRORS, 0)
}

func (s *NonReservedContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEVENTS, 0)
}

func (s *NonReservedContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXECUTE, 0)
}

func (s *NonReservedContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXTERNAL, 0)
}

func (s *NonReservedContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXTRACT, 0)
}

func (s *NonReservedContext) EVERY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEVERY, 0)
}

func (s *NonReservedContext) ENCLOSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserENCLOSE, 0)
}

func (s *NonReservedContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserESCAPE, 0)
}

func (s *NonReservedContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXPORT, 0)
}

func (s *NonReservedContext) FAILPOINT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFAILPOINT, 0)
}

func (s *NonReservedContext) FAILPOINTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFAILPOINTS, 0)
}

func (s *NonReservedContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFIELDS, 0)
}

func (s *NonReservedContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFILE, 0)
}

func (s *NonReservedContext) FILTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFILTER, 0)
}

func (s *NonReservedContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFIRST, 0)
}

func (s *NonReservedContext) FLOOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFLOOR, 0)
}

func (s *NonReservedContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFOLLOWING, 0)
}

func (s *NonReservedContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFORMAT, 0)
}

func (s *NonReservedContext) FN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFN, 0)
}

func (s *NonReservedContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFRONTEND, 0)
}

func (s *NonReservedContext) FRONTENDS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFRONTENDS, 0)
}

func (s *NonReservedContext) FOLLOWER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFOLLOWER, 0)
}

func (s *NonReservedContext) FREE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFREE, 0)
}

func (s *NonReservedContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFUNCTIONS, 0)
}

func (s *NonReservedContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGLOBAL, 0)
}

func (s *NonReservedContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGRANTS, 0)
}

func (s *NonReservedContext) GROUP_CONCAT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserGROUP_CONCAT, 0)
}

func (s *NonReservedContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserHASH, 0)
}

func (s *NonReservedContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserHISTOGRAM, 0)
}

func (s *NonReservedContext) HELP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserHELP, 0)
}

func (s *NonReservedContext) HLL_UNION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserHLL_UNION, 0)
}

func (s *NonReservedContext) HOST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserHOST, 0)
}

func (s *NonReservedContext) HOUR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserHOUR, 0)
}

func (s *NonReservedContext) HOURS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserHOURS, 0)
}

func (s *NonReservedContext) HUB() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserHUB, 0)
}

func (s *NonReservedContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIDENTIFIED, 0)
}

func (s *NonReservedContext) IMAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIMAGE, 0)
}

func (s *NonReservedContext) IMPERSONATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserIMPERSONATE, 0)
}

func (s *NonReservedContext) INACTIVE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINACTIVE, 0)
}

func (s *NonReservedContext) INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINCREMENTAL, 0)
}

func (s *NonReservedContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINDEXES, 0)
}

func (s *NonReservedContext) INSTALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINSTALL, 0)
}

func (s *NonReservedContext) INTEGRATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGRATION, 0)
}

func (s *NonReservedContext) INTEGRATIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTEGRATIONS, 0)
}

func (s *NonReservedContext) INTERMEDIATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTERMEDIATE, 0)
}

func (s *NonReservedContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserINTERVAL, 0)
}

func (s *NonReservedContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserISOLATION, 0)
}

func (s *NonReservedContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserJOB, 0)
}

func (s *NonReservedContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLABEL, 0)
}

func (s *NonReservedContext) LAST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLAST, 0)
}

func (s *NonReservedContext) LESS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLESS, 0)
}

func (s *NonReservedContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLEVEL, 0)
}

func (s *NonReservedContext) LIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLIST, 0)
}

func (s *NonReservedContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOCAL, 0)
}

func (s *NonReservedContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOCATION, 0)
}

func (s *NonReservedContext) LOGS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOGS, 0)
}

func (s *NonReservedContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOGICAL, 0)
}

func (s *NonReservedContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOW_PRIORITY, 0)
}

func (s *NonReservedContext) LOCK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOCK, 0)
}

func (s *NonReservedContext) LOCATIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserLOCATIONS, 0)
}

func (s *NonReservedContext) MANUAL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMANUAL, 0)
}

func (s *NonReservedContext) MAP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMAP, 0)
}

func (s *NonReservedContext) MAPPING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMAPPING, 0)
}

func (s *NonReservedContext) MAPPINGS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMAPPINGS, 0)
}

func (s *NonReservedContext) MASKING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMASKING, 0)
}

func (s *NonReservedContext) MATCH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMATCH, 0)
}

func (s *NonReservedContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMATERIALIZED, 0)
}

func (s *NonReservedContext) MAX() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMAX, 0)
}

func (s *NonReservedContext) META() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMETA, 0)
}

func (s *NonReservedContext) MIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMIN, 0)
}

func (s *NonReservedContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMINUTE, 0)
}

func (s *NonReservedContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMINUTES, 0)
}

func (s *NonReservedContext) MODE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMODE, 0)
}

func (s *NonReservedContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMODIFY, 0)
}

func (s *NonReservedContext) MONTH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMONTH, 0)
}

func (s *NonReservedContext) MERGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMERGE, 0)
}

func (s *NonReservedContext) MINUS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMINUS, 0)
}

func (s *NonReservedContext) MULTIPLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserMULTIPLE, 0)
}

func (s *NonReservedContext) NAME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNAME, 0)
}

func (s *NonReservedContext) NAMES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNAMES, 0)
}

func (s *NonReservedContext) NEGATIVE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNEGATIVE, 0)
}

func (s *NonReservedContext) NO() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNO, 0)
}

func (s *NonReservedContext) NODE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNODE, 0)
}

func (s *NonReservedContext) NODES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNODES, 0)
}

func (s *NonReservedContext) NONE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNONE, 0)
}

func (s *NonReservedContext) NULLS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNULLS, 0)
}

func (s *NonReservedContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNUMBER, 0)
}

func (s *NonReservedContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNUMERIC, 0)
}

func (s *NonReservedContext) OBSERVER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOBSERVER, 0)
}

func (s *NonReservedContext) OF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOF, 0)
}

func (s *NonReservedContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOFFSET, 0)
}

func (s *NonReservedContext) ONLY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserONLY, 0)
}

func (s *NonReservedContext) OPTIMIZER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOPTIMIZER, 0)
}

func (s *NonReservedContext) OPEN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOPEN, 0)
}

func (s *NonReservedContext) OPERATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOPERATE, 0)
}

func (s *NonReservedContext) OPTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOPTION, 0)
}

func (s *NonReservedContext) OVERWRITE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOVERWRITE, 0)
}

func (s *NonReservedContext) OFF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserOFF, 0)
}

func (s *NonReservedContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPARTITIONS, 0)
}

func (s *NonReservedContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPASSWORD, 0)
}

func (s *NonReservedContext) PATH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPATH, 0)
}

func (s *NonReservedContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPAUSE, 0)
}

func (s *NonReservedContext) PENDING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPENDING, 0)
}

func (s *NonReservedContext) PERCENTILE_UNION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPERCENTILE_UNION, 0)
}

func (s *NonReservedContext) PIVOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPIVOT, 0)
}

func (s *NonReservedContext) PLAN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPLAN, 0)
}

func (s *NonReservedContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPLUGIN, 0)
}

func (s *NonReservedContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPLUGINS, 0)
}

func (s *NonReservedContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPOLICY, 0)
}

func (s *NonReservedContext) POLICIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPOLICIES, 0)
}

func (s *NonReservedContext) PERCENT_RANK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPERCENT_RANK, 0)
}

func (s *NonReservedContext) PREDICATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPREDICATE, 0)
}

func (s *NonReservedContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPRECEDING, 0)
}

func (s *NonReservedContext) PRIORITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPRIORITY, 0)
}

func (s *NonReservedContext) PROC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROC, 0)
}

func (s *NonReservedContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROCESSLIST, 0)
}

func (s *NonReservedContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROFILE, 0)
}

func (s *NonReservedContext) PROFILELIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROFILELIST, 0)
}

func (s *NonReservedContext) PROVIDER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROVIDER, 0)
}

func (s *NonReservedContext) PROVIDERS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROVIDERS, 0)
}

func (s *NonReservedContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPRIVILEGES, 0)
}

func (s *NonReservedContext) PROBABILITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROBABILITY, 0)
}

func (s *NonReservedContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROPERTIES, 0)
}

func (s *NonReservedContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPROPERTY, 0)
}

func (s *NonReservedContext) PIPE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPIPE, 0)
}

func (s *NonReservedContext) PIPES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPIPES, 0)
}

func (s *NonReservedContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserQUARTER, 0)
}

func (s *NonReservedContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserQUERY, 0)
}

func (s *NonReservedContext) QUERIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserQUERIES, 0)
}

func (s *NonReservedContext) QUEUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserQUEUE, 0)
}

func (s *NonReservedContext) QUOTA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserQUOTA, 0)
}

func (s *NonReservedContext) QUALIFY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserQUALIFY, 0)
}

func (s *NonReservedContext) REASON() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREASON, 0)
}

func (s *NonReservedContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREMOVE, 0)
}

func (s *NonReservedContext) REWRITE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREWRITE, 0)
}

func (s *NonReservedContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRANDOM, 0)
}

func (s *NonReservedContext) RANK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRANK, 0)
}

func (s *NonReservedContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRECOVER, 0)
}

func (s *NonReservedContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREFRESH, 0)
}

func (s *NonReservedContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPAIR, 0)
}

func (s *NonReservedContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPEATABLE, 0)
}

func (s *NonReservedContext) REPLACE_IF_NOT_NULL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPLACE_IF_NOT_NULL, 0)
}

func (s *NonReservedContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPLICA, 0)
}

func (s *NonReservedContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPOSITORY, 0)
}

func (s *NonReservedContext) REPOSITORIES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREPOSITORIES, 0)
}

func (s *NonReservedContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRESOURCE, 0)
}

func (s *NonReservedContext) RESOURCES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRESOURCES, 0)
}

func (s *NonReservedContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRESTORE, 0)
}

func (s *NonReservedContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRESUME, 0)
}

func (s *NonReservedContext) RETAIN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRETAIN, 0)
}

func (s *NonReservedContext) RETENTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRETENTION, 0)
}

func (s *NonReservedContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRETURNS, 0)
}

func (s *NonReservedContext) RETRY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRETRY, 0)
}

func (s *NonReservedContext) REVERT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserREVERT, 0)
}

func (s *NonReservedContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROLE, 0)
}

func (s *NonReservedContext) ROLES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROLES, 0)
}

func (s *NonReservedContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROLLUP, 0)
}

func (s *NonReservedContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROLLBACK, 0)
}

func (s *NonReservedContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROUTINE, 0)
}

func (s *NonReservedContext) ROW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserROW, 0)
}

func (s *NonReservedContext) RUNNING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRUNNING, 0)
}

func (s *NonReservedContext) RULE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRULE, 0)
}

func (s *NonReservedContext) RULES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserRULES, 0)
}

func (s *NonReservedContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSAMPLE, 0)
}

func (s *NonReservedContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSCHEDULE, 0)
}

func (s *NonReservedContext) SCHEDULER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSCHEDULER, 0)
}

func (s *NonReservedContext) SECOND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSECOND, 0)
}

func (s *NonReservedContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSECURITY, 0)
}

func (s *NonReservedContext) SEPARATOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSEPARATOR, 0)
}

func (s *NonReservedContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSERIALIZABLE, 0)
}

func (s *NonReservedContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSEMI, 0)
}

func (s *NonReservedContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSESSION, 0)
}

func (s *NonReservedContext) SETS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSETS, 0)
}

func (s *NonReservedContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSIGNED, 0)
}

func (s *NonReservedContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSNAPSHOT, 0)
}

func (s *NonReservedContext) SNAPSHOTS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSNAPSHOTS, 0)
}

func (s *NonReservedContext) SQLBLACKLIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSQLBLACKLIST, 0)
}

func (s *NonReservedContext) START() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTART, 0)
}

func (s *NonReservedContext) STREAM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTREAM, 0)
}

func (s *NonReservedContext) SUM() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSUM, 0)
}

func (s *NonReservedContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTATUS, 0)
}

func (s *NonReservedContext) STOP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTOP, 0)
}

func (s *NonReservedContext) SKIP_HEADER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSKIP_HEADER, 0)
}

func (s *NonReservedContext) SWAP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSWAP, 0)
}

func (s *NonReservedContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTORAGE, 0)
}

func (s *NonReservedContext) STRING() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTRING, 0)
}

func (s *NonReservedContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTRUCT, 0)
}

func (s *NonReservedContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSTATS, 0)
}

func (s *NonReservedContext) SUBMIT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSUBMIT, 0)
}

func (s *NonReservedContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSUSPEND, 0)
}

func (s *NonReservedContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSYNC, 0)
}

func (s *NonReservedContext) SYSTEM_TIME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserSYSTEM_TIME, 0)
}

func (s *NonReservedContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLES, 0)
}

func (s *NonReservedContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLET, 0)
}

func (s *NonReservedContext) TABLETS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTABLETS, 0)
}

func (s *NonReservedContext) TAG() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTAG, 0)
}

func (s *NonReservedContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTASK, 0)
}

func (s *NonReservedContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTEMPORARY, 0)
}

func (s *NonReservedContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTIMESTAMP, 0)
}

func (s *NonReservedContext) TIMESTAMPADD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTIMESTAMPADD, 0)
}

func (s *NonReservedContext) TIMESTAMPDIFF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTIMESTAMPDIFF, 0)
}

func (s *NonReservedContext) THAN() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTHAN, 0)
}

func (s *NonReservedContext) TIME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTIME, 0)
}

func (s *NonReservedContext) TIMES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTIMES, 0)
}

func (s *NonReservedContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTRANSACTION, 0)
}

func (s *NonReservedContext) TRACE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTRACE, 0)
}

func (s *NonReservedContext) TRANSLATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTRANSLATE, 0)
}

func (s *NonReservedContext) TRIM_SPACE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTRIM_SPACE, 0)
}

func (s *NonReservedContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTRIGGERS, 0)
}

func (s *NonReservedContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTRUNCATE, 0)
}

func (s *NonReservedContext) TYPE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTYPE, 0)
}

func (s *NonReservedContext) TYPES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserTYPES, 0)
}

func (s *NonReservedContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUNBOUNDED, 0)
}

func (s *NonReservedContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUNCOMMITTED, 0)
}

func (s *NonReservedContext) UNSET() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUNSET, 0)
}

func (s *NonReservedContext) UNINSTALL() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUNINSTALL, 0)
}

func (s *NonReservedContext) USAGE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSAGE, 0)
}

func (s *NonReservedContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSER, 0)
}

func (s *NonReservedContext) USERS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUSERS, 0)
}

func (s *NonReservedContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserUNLOCK, 0)
}

func (s *NonReservedContext) VALUE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVALUE, 0)
}

func (s *NonReservedContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVARBINARY, 0)
}

func (s *NonReservedContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVARIABLES, 0)
}

func (s *NonReservedContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVIEW, 0)
}

func (s *NonReservedContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVIEWS, 0)
}

func (s *NonReservedContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVERBOSE, 0)
}

func (s *NonReservedContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVERSION, 0)
}

func (s *NonReservedContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVOLUME, 0)
}

func (s *NonReservedContext) VOLUMES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVOLUMES, 0)
}

func (s *NonReservedContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWARNINGS, 0)
}

func (s *NonReservedContext) WEEK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWEEK, 0)
}

func (s *NonReservedContext) WHITELIST() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWHITELIST, 0)
}

func (s *NonReservedContext) WORK() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWORK, 0)
}

func (s *NonReservedContext) WRITE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWRITE, 0)
}

func (s *NonReservedContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWAREHOUSE, 0)
}

func (s *NonReservedContext) WAREHOUSES() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserWAREHOUSES, 0)
}

func (s *NonReservedContext) YEAR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserYEAR, 0)
}

func (s *NonReservedContext) DOTDOTDOT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserDOTDOTDOT, 0)
}

func (s *NonReservedContext) NGRAMBF() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserNGRAMBF, 0)
}

func (s *NonReservedContext) VECTOR() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserVECTOR, 0)
}

func (s *NonReservedContext) FIELD() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserFIELD, 0)
}

func (s *NonReservedContext) ARRAY_ELEMENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserARRAY_ELEMENT, 0)
}

func (s *NonReservedContext) PERSISTENT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserPERSISTENT, 0)
}

func (s *NonReservedContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXCLUDE, 0)
}

func (s *NonReservedContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(DorisSQLParserParserEXCEPT, 0)
}

func (s *NonReservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonReservedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.EnterNonReserved(s)
	}
}

func (s *NonReservedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisSQLParserListener); ok {
		listenerT.ExitNonReserved(s)
	}
}

func (s *NonReservedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisSQLParserVisitor:
		return t.VisitNonReserved(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisSQLParserParser) NonReserved() (localctx INonReservedContext) {
	localctx = NewNonReservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1040, DorisSQLParserParserRULE_nonReserved)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8210)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262756702208) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-6664167256628462851) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-1331487429127569487) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&-7546427580836201) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-4573491655345179) != 0) || ((int64((_la-324)) & ^0x3f) == 0 && ((int64(1)<<(_la-324))&9114828243924942831) != 0) || ((int64((_la-389)) & ^0x3f) == 0 && ((int64(1)<<(_la-389))&-6956096606152176261) != 0) || ((int64((_la-453)) & ^0x3f) == 0 && ((int64(1)<<(_la-453))&70849595962729) != 0) || _la == DorisSQLParserParserDOTDOTDOT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *DorisSQLParserParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 382:
		var t *QueryPrimaryContext = nil
		if localctx != nil {
			t = localctx.(*QueryPrimaryContext)
		}
		return p.QueryPrimary_Sempred(t, predIndex)

	case 426:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 428:
		var t *BooleanExpressionContext = nil
		if localctx != nil {
			t = localctx.(*BooleanExpressionContext)
		}
		return p.BooleanExpression_Sempred(t, predIndex)

	case 432:
		var t *ValueExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ValueExpressionContext)
		}
		return p.ValueExpression_Sempred(t, predIndex)

	case 433:
		var t *PrimaryExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryExpressionContext)
		}
		return p.PrimaryExpression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *DorisSQLParserParser) QueryPrimary_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DorisSQLParserParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DorisSQLParserParser) BooleanExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DorisSQLParserParser) ValueExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DorisSQLParserParser) PrimaryExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 15:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 23)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 20)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 20:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 21:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
